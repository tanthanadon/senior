import numpy as np import odl n = 128 space = odl . uniform_discr ( [ 0 , 0 ] , [ n , n ] , [ n , n ] ) filter_width = 3.0 ft = odl . trafos . FourierTransform ( space ) c = filter_width ** 2 / 4.0 ** 2 gaussian = ft . range . element ( lambda x : np . exp ( - ( x [ 0 ] ** 2 + x [ 1 ] ** 2 ) * c ) ) convolution = ft . inverse * gaussian * ft phantom = odl . phantom . shepp_logan ( space , modified = True ) data = convolution ( phantom ) data += odl . phantom . white_noise ( convolution . range ) * np . mean ( data ) * 0.1 data . show ( <str> ) gradient = odl . Gradient ( space , method = <str> ) op = odl . BroadcastOperator ( convolution , gradient ) f = odl . solvers . ZeroFunctional ( op . domain ) l2_norm_squared = odl . solvers . L2NormSquared ( space ) . translated ( data ) l1_norm = 0.01 * odl . solvers . L1Norm ( gradient . range ) g = odl . solvers . SeparableSum ( l2_norm_squared , l1_norm ) op_norm = 1.1 * odl . power_method_opnorm ( op ) niter = 300 tau = 10.0 / op_norm sigma = 0.1 / op_norm callback = ( odl . solvers . CallbackPrintIteration ( ) & odl . solvers . CallbackShow ( step = 20 ) ) x = op . domain . zero ( ) odl . solvers . pdhg ( x , f , g , op , niter = niter , tau = tau , sigma = sigma , callback = callback ) phantom . show ( title = <str> ) data . show ( title = <str> ) x . show ( title = <str> , force_show = True )  