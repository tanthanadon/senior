from __future__ import absolute_import , division , print_function from numbers import Integral import numpy as np from odl . operator . operator import Operator from odl . set import ComplexNumbers , RealNumbers from odl . space import ProductSpace , tensor_space from odl . space . base_tensors import TensorSpace from odl . space . weighting import ArrayWeighting from odl . util import dtype_repr , indent , signature_string , writable_array __all__ = ( <str> , <str> , <str> , <str> , <str> , <str> , <str> ) _SUPPORTED_DIFF_METHODS = ( <str> , <str> , <str> ) class PointwiseTensorFieldOperator ( Operator ) :      def __init__ ( self , domain , range , base_space , linear = False ) :          if not is_compatible_space ( domain , base_space ) :              raise ValueError ( <str> <str> . format ( domain , base_space ) )  if not is_compatible_space ( range , base_space ) :              raise ValueError ( <str> <str> . format ( range , base_space ) )  super ( PointwiseTensorFieldOperator , self ) . __init__ ( domain = domain , range = range , linear = linear ) self . __base_space = base_space  @ property def base_space ( self ) :          return self . __base_space   class PointwiseNorm ( PointwiseTensorFieldOperator ) :      def __init__ ( self , vfspace , exponent = None , weighting = None ) :          if not isinstance ( vfspace , ProductSpace ) :              raise TypeError ( <str> <str> . format ( vfspace ) )  super ( PointwiseNorm , self ) . __init__ ( domain = vfspace , range = vfspace [ 0 ] , base_space = vfspace [ 0 ] , linear = False ) if exponent is None :              if self . domain . exponent is None :                  raise ValueError ( <str> <str> . format ( self . domain ) )  self . _exponent = self . domain . exponent  elif exponent < 1 :              raise ValueError ( <str> )  else :              self . _exponent = float ( exponent )  if weighting is None :              if hasattr ( self . domain . weighting , <str> ) :                  self . __weights = self . domain . weighting . array  elif hasattr ( self . domain . weighting , <str> ) :                  self . __weights = ( self . domain . weighting . const * np . ones ( len ( self . domain ) ) )  else :                  raise ValueError ( <str> <str> <str> . format ( self . domain . weighting ) )   elif np . isscalar ( weighting ) :              if weighting <= 0 :                  raise ValueError ( <str> <str> . format ( weighting ) )  self . __weights = float ( weighting ) * np . ones ( len ( self . domain ) )  else :              self . __weights = np . asarray ( weighting , dtype = <str> ) if ( not np . all ( self . weights > 0 ) or not np . all ( np . isfinite ( self . weights ) ) ) :                  raise ValueError ( <str> <str> . format ( weighting ) )   self . __is_weighted = not np . array_equiv ( self . weights , 1.0 )  @ property def exponent ( self ) :          return self . _exponent  @ property def weights ( self ) :          return self . __weights  @ property def is_weighted ( self ) :          return self . __is_weighted  def _call ( self , f , out ) :          if self . exponent == 1.0 :              self . _call_vecfield_1 ( f , out )  elif self . exponent == float ( <str> ) :              self . _call_vecfield_inf ( f , out )  else :              self . _call_vecfield_p ( f , out )   def _call_vecfield_1 ( self , vf , out ) :          vf [ 0 ] . ufuncs . absolute ( out = out ) if self . is_weighted :              out *= self . weights [ 0 ]  if len ( self . domain ) == 1 :              return  tmp = self . range . element ( ) for fi , wi in zip ( vf [ 1 : ] , self . weights [ 1 : ] ) :              fi . ufuncs . absolute ( out = tmp ) if self . is_weighted :                  tmp *= wi  out += tmp   def _call_vecfield_inf ( self , vf , out ) :          vf [ 0 ] . ufuncs . absolute ( out = out ) if self . is_weighted :              out *= self . weights [ 0 ]  if len ( self . domain ) == 1 :              return  tmp = self . range . element ( ) for vfi , wi in zip ( vf [ 1 : ] , self . weights [ 1 : ] ) :              vfi . ufuncs . absolute ( out = tmp ) if self . is_weighted :                  tmp *= wi  out . ufuncs . maximum ( tmp , out = out )   def _call_vecfield_p ( self , vf , out ) :          if len ( self . domain ) == 1 :              vf [ 0 ] . ufuncs . absolute ( out = out ) if self . is_weighted :                  out *= self . weights [ 0 ] ** ( 1 / self . exponent )  return  self . _abs_pow_ufunc ( vf [ 0 ] , out = out , p = self . exponent ) if self . is_weighted :              out *= self . weights [ 0 ]  tmp = self . range . element ( ) for fi , wi in zip ( vf [ 1 : ] , self . weights [ 1 : ] ) :              self . _abs_pow_ufunc ( fi , out = tmp , p = self . exponent ) if self . is_weighted :                  tmp *= wi  out += tmp  self . _abs_pow_ufunc ( out , out = out , p = ( 1 / self . exponent ) )  def _abs_pow_ufunc ( self , fi , out , p ) :          if p == 0.5 :              fi . ufuncs . absolute ( out = out ) out . ufuncs . sqrt ( out = out )  elif p == 2.0 and self . base_space . field == RealNumbers ( ) :              fi . multiply ( fi , out = out )  else :              fi . ufuncs . absolute ( out = out ) out . ufuncs . power ( p , out = out )   def derivative ( self , vf ) :          if self . domain . field == ComplexNumbers ( ) :              raise NotImplementedError ( <str> <str> )  if self . exponent == float ( <str> ) :              raise NotImplementedError ( <str> <str> )  vf = self . domain . element ( vf ) vf_pwnorm_fac = self ( vf ) if self . exponent != 2 :              vf_pwnorm_fac **= ( self . exponent - 1 )  inner_vf = vf . copy ( ) for gi in inner_vf :              gi *= gi . ufuncs . absolute ( ) . ufuncs . power ( self . exponent - 2 ) if self . exponent >= 2 :                  nz = ( vf_pwnorm_fac . asarray ( ) != 0 ) gi [ nz ] /= vf_pwnorm_fac [ nz ]  else :                  gi /= vf_pwnorm_fac   return PointwiseInner ( self . domain , inner_vf , weighting = self . weights )   class PointwiseInnerBase ( PointwiseTensorFieldOperator ) :      def __init__ ( self , adjoint , vfspace , vecfield , weighting = None ) :          if not isinstance ( vfspace , ProductSpace ) :              raise TypeError ( <str> <str> . format ( vfspace ) )  if adjoint :              super ( PointwiseInnerBase , self ) . __init__ ( domain = vfspace [ 0 ] , range = vfspace , base_space = vfspace [ 0 ] , linear = True )  else :              super ( PointwiseInnerBase , self ) . __init__ ( domain = vfspace , range = vfspace [ 0 ] , base_space = vfspace [ 0 ] , linear = True )  if ( vfspace . field == ComplexNumbers ( ) and not hasattr ( self . base_space . element_type , <str> ) ) :              raise NotImplementedError ( <str> <str> <str> . format ( self . base_space . element_type ) )  self . _vecfield = vfspace . element ( vecfield ) if weighting is None :              if hasattr ( vfspace . weighting , <str> ) :                  self . __weights = vfspace . weighting . array  elif hasattr ( vfspace . weighting , <str> ) :                  self . __weights = ( vfspace . weighting . const * np . ones ( len ( vfspace ) ) )  else :                  raise ValueError ( <str> <str> <str> . format ( vfspace . weighting ) )   elif np . isscalar ( weighting ) :              self . __weights = float ( weighting ) * np . ones ( len ( vfspace ) )  else :              self . __weights = np . asarray ( weighting , dtype = <str> )  self . __is_weighted = not np . array_equiv ( self . weights , 1.0 )  @ property def vecfield ( self ) :          return self . _vecfield  @ property def weights ( self ) :          return self . __weights  @ property def is_weighted ( self ) :          return self . __is_weighted  @ property def adjoint ( self ) :          raise NotImplementedError ( <str> )   class PointwiseInner ( PointwiseInnerBase ) :      def __init__ ( self , vfspace , vecfield , weighting = None ) :          super ( PointwiseInner , self ) . __init__ ( adjoint = False , vfspace = vfspace , vecfield = vecfield , weighting = weighting )  @ property def vecfield ( self ) :          return self . _vecfield  def _call ( self , vf , out ) :          if self . domain . field == ComplexNumbers ( ) :              vf [ 0 ] . multiply ( self . _vecfield [ 0 ] . conj ( ) , out = out )  else :              vf [ 0 ] . multiply ( self . _vecfield [ 0 ] , out = out )  if self . is_weighted :              out *= self . weights [ 0 ]  if len ( self . domain ) == 1 :              return  tmp = self . range . element ( ) for vfi , gi , wi in zip ( vf [ 1 : ] , self . vecfield [ 1 : ] , self . weights [ 1 : ] ) :              if self . domain . field == ComplexNumbers ( ) :                  vfi . multiply ( gi . conj ( ) , out = tmp )  else :                  vfi . multiply ( gi , out = tmp )  if self . is_weighted :                  tmp *= wi  out += tmp   @ property def adjoint ( self ) :          return PointwiseInnerAdjoint ( sspace = self . base_space , vecfield = self . vecfield , vfspace = self . domain , weighting = self . weights )   class PointwiseInnerAdjoint ( PointwiseInnerBase ) :      def __init__ ( self , sspace , vecfield , vfspace = None , weighting = None ) :          if vfspace is None :              vfspace = ProductSpace ( sspace , len ( vecfield ) , weighting = weighting )  else :              if not isinstance ( vfspace , ProductSpace ) :                  raise TypeError ( <str> <str> . format ( vfspace ) )  if vfspace [ 0 ] != sspace :                  raise ValueError ( <str> <str> <str> . format ( vfspace [ 0 ] , sspace ) )   super ( PointwiseInnerAdjoint , self ) . __init__ ( adjoint = True , vfspace = vfspace , vecfield = vecfield , weighting = weighting ) if hasattr ( self . range . weighting , <str> ) :              self . __ran_weights = self . range . weighting . array  elif hasattr ( self . range . weighting , <str> ) :              self . __ran_weights = ( self . range . weighting . const * np . ones ( len ( self . range ) ) )  else :              raise ValueError ( <str> <str> <str> . format ( self . range . weighting ) )   def _call ( self , f , out ) :          for vfi , oi , ran_wi , dom_wi in zip ( self . vecfield , out , self . __ran_weights , self . weights ) :              vfi . multiply ( f , out = oi ) if not np . isclose ( ran_wi , dom_wi ) :                  oi *= dom_wi / ran_wi    @ property def adjoint ( self ) :          return PointwiseInner ( vfspace = self . range , vecfield = self . vecfield , weighting = self . weights )   class PointwiseSum ( PointwiseInner ) :      def __init__ ( self , vfspace , weighting = None ) :          if not isinstance ( vfspace , ProductSpace ) :              raise TypeError ( <str> <str> . format ( vfspace ) )  ones = vfspace . one ( ) super ( PointwiseSum , self ) . __init__ ( vfspace , vecfield = ones , weighting = weighting )   class MatrixOperator ( Operator ) :      def __init__ ( self , matrix , domain = None , range = None , axis = 0 ) :          <str> import scipy . sparse if scipy . sparse . isspmatrix ( matrix ) :              self . __matrix = matrix  else :              self . __matrix = np . array ( matrix , copy = False , ndmin = 2 )  self . __axis , axis_in = int ( axis ) , axis if self . axis != axis_in :              raise ValueError ( <str> . format ( axis_in ) )  if self . matrix . ndim != 2 :              raise ValueError ( <str> <str> . format ( self . matrix . ndim ) )  if domain is None :              domain = tensor_space ( ( self . matrix . shape [ 1 ] , ) , dtype = self . matrix . dtype )  else :              if not isinstance ( domain , TensorSpace ) :                  raise TypeError ( <str> <str> . format ( domain ) )  if scipy . sparse . isspmatrix ( self . matrix ) and domain . ndim > 1 :                  raise ValueError ( <str> <str> )  if domain . shape [ axis ] != self . matrix . shape [ 1 ] :                  raise ValueError ( <str> <str> <str> . format ( domain . shape [ axis ] , self . matrix . shape [ 1 ] ) )   range_shape = list ( domain . shape ) range_shape [ self . axis ] = self . matrix . shape [ 0 ] if range is None :              range_dtype = np . promote_types ( self . matrix . dtype , domain . dtype ) if ( range_shape != domain . shape and isinstance ( domain . weighting , ArrayWeighting ) ) :                  weighting = None  else :                  weighting = domain . weighting  range = tensor_space ( range_shape , dtype = range_dtype , weighting = weighting , exponent = domain . exponent )  else :              if not isinstance ( range , TensorSpace ) :                  raise TypeError ( <str> <str> . format ( range ) )  if range . shape != tuple ( range_shape ) :                  raise ValueError ( <str> <str> . format ( tuple ( range_shape ) , range . shape ) )   result_dtype = np . promote_types ( domain . dtype , self . matrix . dtype ) if not np . can_cast ( result_dtype , range . dtype ) :              raise ValueError ( <str> <str> <str> . format ( dtype_repr ( result_dtype ) , dtype_repr ( range . dtype ) ) )  super ( MatrixOperator , self ) . __init__ ( domain , range , linear = True )  @ property def matrix ( self ) :          return self . __matrix  @ property def axis ( self ) :          return self . __axis  @ property def adjoint ( self ) :          return MatrixOperator ( self . matrix . conj ( ) . T , domain = self . range , range = self . domain , axis = self . axis )  @ property def inverse ( self ) :          import scipy . sparse if scipy . sparse . isspmatrix ( self . matrix ) :              dense_matrix = self . matrix . toarray ( )  else :              dense_matrix = self . matrix  return MatrixOperator ( np . linalg . inv ( dense_matrix ) , domain = self . range , range = self . domain , axis = self . axis )  def _call ( self , x , out = None ) :          import scipy . sparse if out is None :              if scipy . sparse . isspmatrix ( self . matrix ) :                  out = self . matrix . dot ( x )  else :                  dot = np . tensordot ( self . matrix , x , axes = ( 1 , self . axis ) ) out = np . moveaxis ( dot , 0 , self . axis )   else :              if scipy . sparse . isspmatrix ( self . matrix ) :                  out [ : ] = self . matrix . dot ( x )  elif self . range . ndim == 1 :                  with writable_array ( out ) as out_arr :                      self . matrix . dot ( x , out = out_arr )   else :                  dot = np . tensordot ( self . matrix , x , axes = ( 1 , self . axis ) ) out [ : ] = np . moveaxis ( dot , 0 , self . axis )   return out  def __repr__ ( self ) :          import scipy . sparse if scipy . sparse . isspmatrix ( self . matrix ) :              matrix_str = repr ( self . matrix )  else :              matrix_str = np . array2string ( self . matrix , separator = <str> )  posargs = [ matrix_str ] range_shape = list ( self . domain . shape ) range_shape [ self . axis ] = self . matrix . shape [ 0 ] optargs = [ ( <str> , self . domain , tensor_space ( self . matrix . shape [ 1 ] , self . matrix . dtype ) ) , ( <str> , self . range , tensor_space ( range_shape , self . matrix . dtype ) ) , ( <str> , self . axis , 0 ) ] inner_str = signature_string ( posargs , optargs , sep = [ <str> , <str> , <str> ] , mod = [ [ <str> ] , [ <str> , <str> , <str> ] ] ) return <str> . format ( self . __class__ . __name__ , indent ( inner_str ) )  def __str__ ( self ) :          return repr ( self )   def _normalize_sampling_points ( sampling_points , ndim ) :      sampling_points_in = sampling_points if ndim == 0 :          sampling_points = [ np . array ( sampling_points , dtype = int , copy = False ) ] if sampling_points [ 0 ] . size != 0 :              raise ValueError ( <str> <str> )   elif ndim == 1 :          if isinstance ( sampling_points , Integral ) :              sampling_points = ( sampling_points , )  sampling_points = np . array ( sampling_points , dtype = int , copy = False , ndmin = 1 ) if sampling_points . ndim == 2 and sampling_points . shape [ 0 ] == 1 :              sampling_points = sampling_points [ 0 ]  sampling_points = [ sampling_points ] if sampling_points [ 0 ] . ndim > 1 :              raise ValueError ( <str> <str> . format ( sampling_points_in ) )   else :          try :              iter ( sampling_points )  except TypeError :              raise TypeError ( <str> <str> )  else :              if np . ndim ( sampling_points ) == 1 :                  sampling_points = [ np . array ( p , dtype = int ) for p in sampling_points ]  else :                  sampling_points = [ np . array ( pts , dtype = int , copy = False , ndmin = 1 ) for pts in sampling_points ] if any ( pts . ndim != 1 for pts in sampling_points ) :                      raise ValueError ( <str> <str> . format ( sampling_points_in ) )     return sampling_points  class SamplingOperator ( Operator ) :      def __init__ ( self , domain , sampling_points , variant = <str> ) :          if not isinstance ( domain , TensorSpace ) :              raise TypeError ( <str> <str> . format ( domain ) )  self . __sampling_points = _normalize_sampling_points ( sampling_points , domain . ndim ) indices_flat = np . ravel_multi_index ( self . sampling_points , dims = domain . shape ) if np . isscalar ( indices_flat ) :              self . _indices_flat = np . array ( [ indices_flat ] , dtype = int )  else :              self . _indices_flat = indices_flat  self . __variant = str ( variant ) . lower ( ) if self . variant not in ( <str> , <str> ) :              raise ValueError ( <str> . format ( variant ) )  ran = tensor_space ( self . sampling_points [ 0 ] . size , dtype = domain . dtype ) super ( SamplingOperator , self ) . __init__ ( domain , ran , linear = True )  @ property def variant ( self ) :          return self . __variant  @ property def sampling_points ( self ) :          return self . __sampling_points  def _call ( self , x ) :          out = x . asarray ( ) . ravel ( ) [ self . _indices_flat ] if self . variant == <str> :              weights = 1.0  elif self . variant == <str> :              weights = getattr ( self . domain , <str> , 1.0 )  else :              raise RuntimeError ( <str> . format ( self . variant ) )  if weights != 1.0 :              out *= weights  return out  @ property def adjoint ( self ) :          if self . variant == <str> :              variant = <str>  elif self . variant == <str> :              variant = <str>  else :              raise RuntimeError ( <str> . format ( self . variant ) )  return WeightedSumSamplingOperator ( self . domain , self . sampling_points , variant )  def __repr__ ( self ) :          posargs = [ self . domain , self . sampling_points ] optargs = [ ( <str> , self . variant , <str> ) ] sig_str = signature_string ( posargs , optargs , mod = [ <str> , <str> ] , sep = [ <str> , <str> , <str> ] ) return <str> . format ( self . __class__ . __name__ , indent ( sig_str ) )  def __str__ ( self ) :          return repr ( self )   class WeightedSumSamplingOperator ( Operator ) :      <str> def __init__ ( self , range , sampling_points , variant = <str> ) :          if not isinstance ( range , TensorSpace ) :              raise TypeError ( <str> <str> . format ( range ) )  self . __sampling_points = _normalize_sampling_points ( sampling_points , range . ndim ) indices_flat = np . ravel_multi_index ( self . sampling_points , dims = range . shape ) if np . isscalar ( indices_flat ) :              self . _indices_flat = np . array ( [ indices_flat ] , dtype = int )  else :              self . _indices_flat = indices_flat  self . __variant = str ( variant ) . lower ( ) if self . variant not in ( <str> , <str> ) :              raise ValueError ( <str> . format ( variant ) )  domain = tensor_space ( self . sampling_points [ 0 ] . size , dtype = range . dtype ) super ( WeightedSumSamplingOperator , self ) . __init__ ( domain , range , linear = True )  @ property def variant ( self ) :          return self . __variant  @ property def sampling_points ( self ) :          return self . __sampling_points  def _call ( self , x ) :          y = np . bincount ( self . _indices_flat , weights = x , minlength = self . range . size ) out = y . reshape ( self . range . shape ) if self . variant == <str> :              weights = getattr ( self . range , <str> , 1.0 )  elif self . variant == <str> :              weights = 1.0  else :              raise RuntimeError ( <str> <str> . format ( self . variant ) )  if weights != 1.0 :              out /= weights  return out  @ property def adjoint ( self ) :          if self . variant == <str> :              variant = <str>  elif self . variant == <str> :              variant = <str>  else :              raise RuntimeError ( <str> <str> . format ( self . variant ) )  return SamplingOperator ( self . range , self . sampling_points , variant )  def __repr__ ( self ) :          posargs = [ self . range , self . sampling_points ] optargs = [ ( <str> , self . variant , <str> ) ] sig_str = signature_string ( posargs , optargs , mod = [ <str> , <str> ] , sep = [ <str> , <str> , <str> ] ) return <str> . format ( self . __class__ . __name__ , indent ( sig_str ) )  def __str__ ( self ) :          return repr ( self )   class FlatteningOperator ( Operator ) :      def __init__ ( self , domain , order = <str> ) :          if not isinstance ( domain , TensorSpace ) :              raise TypeError ( <str> <str> . format ( domain ) )  self . __order = str ( order ) . upper ( ) if self . order not in ( <str> , <str> ) :              raise ValueError ( <str> . format ( order ) )  range = tensor_space ( domain . size , dtype = domain . dtype ) super ( FlatteningOperator , self ) . __init__ ( domain , range , linear = True )  def _call ( self , x ) :          return np . ravel ( x , order = self . order )  @ property def order ( self ) :          return self . __order  @ property def adjoint ( self ) :          scaling = getattr ( self . domain , <str> , 1.0 ) return 1 / scaling * self . inverse  @ property def inverse ( self ) :          op = self scaling = getattr ( self . domain , <str> , 1.0 ) class FlatteningOperatorInverse ( Operator ) :              def __init__ ( self ) :                  super ( FlatteningOperatorInverse , self ) . __init__ ( op . range , op . domain , linear = True )  def _call ( self , x ) :                  return np . reshape ( x . asarray ( ) , self . range . shape , order = op . order )  @ property def adjoint ( self ) :                  return scaling * op  @ property def inverse ( self ) :                  return op  def __repr__ ( self ) :                  return <str> . format ( op )  def __str__ ( self ) :                  return repr ( self )   return FlatteningOperatorInverse ( )  def __repr__ ( self ) :          posargs = [ self . domain ] optargs = [ ( <str> , self . order , <str> ) ] sig_str = signature_string ( posargs , optargs , mod = [ <str> , <str> ] , sep = [ <str> , <str> , <str> ] ) return <str> . format ( self . __class__ . __name__ , indent ( sig_str ) )  def __str__ ( self ) :          return repr ( self )   def is_compatible_space ( space , base_space ) :      if isinstance ( base_space , ProductSpace ) :          return False  if isinstance ( space , ProductSpace ) :          if not space . is_power_space :              return False  elif len ( space ) == 0 :              return False  else :              return is_compatible_space ( space [ 0 ] , base_space )   else :          if hasattr ( space , <str> ) and hasattr ( base_space , <str> ) :              comp_space = space . astype ( base_space . dtype )  else :              comp_space = space  return comp_space == base_space   if __name__ == <str> :      from odl . util . testutils import run_doctests run_doctests ( )   