import numpy as np import odl lam = 0.01 data_matching = <str> space = odl . uniform_discr ( min_pt = [ - 20 , - 20 ] , max_pt = [ 20 , 20 ] , shape = [ 512 , 512 ] ) angle_partition = odl . uniform_partition ( 0 , np . pi , 22 ) detector_partition = odl . uniform_partition ( - 30 , 30 , 512 ) geometry = odl . tomo . Parallel2dGeometry ( angle_partition , detector_partition ) ray_trafo = odl . tomo . RayTransform ( space , geometry ) phantom = odl . phantom . shepp_logan ( space , modified = True ) data = ray_trafo ( phantom ) gradient = odl . Gradient ( space ) f = odl . solvers . IndicatorBox ( space , 0 , 1 ) if data_matching == <str> :      indicator_zero = odl . solvers . IndicatorZero ( ray_trafo . range ) indicator_data = indicator_zero . translated ( data )  elif data_matching == <str> :      eps = 5.0 raw_noise = odl . phantom . white_noise ( ray_trafo . range ) data += raw_noise * eps / raw_noise . norm ( ) indicator_l2_ball = odl . solvers . IndicatorLpUnitBall ( ray_trafo . range , 2 ) indicator_data = indicator_l2_ball . translated ( data / eps ) * ( 1 / eps )  else :      raise RuntimeError ( <str> )  cross_norm = lam * odl . solvers . GroupL1Norm ( gradient . range ) lin_ops = [ ray_trafo , gradient ] g = [ indicator_data , cross_norm ] callback = ( odl . solvers . CallbackShow ( <str> , step = 5 , clim = [ 0 , 1 ] ) & odl . solvers . CallbackPrintIteration ( ) ) x = ray_trafo . domain . zero ( ) odl . solvers . douglas_rachford_pd ( x , f , g , lin_ops , tau = 0.1 , sigma = [ 0.1 , 0.02 ] , lam = 1.5 , niter = 200 , callback = callback ) fbp_recon = odl . tomo . fbp_op ( ray_trafo ) ( data ) fbp_recon . show ( <str> ) phantom . show ( <str> ) data . show ( <str> , force_show = True )  