 from __future__ import print_function , division , absolute_import from itertools import product from numbers import Integral import numpy as np from odl . set import LinearSpace from odl . set . space import LinearSpaceElement from odl . space . weighting import ( Weighting , ArrayWeighting , ConstWeighting , CustomInner , CustomNorm , CustomDist ) from odl . util import is_real_dtype , signature_string , indent from odl . util . ufuncs import ProductSpaceUfuncs __all__ = ( <str> , ) class ProductSpace ( LinearSpace ) :      def __init__ ( self , * spaces , ** kwargs ) :          field = kwargs . pop ( <str> , None ) dist = kwargs . pop ( <str> , None ) norm = kwargs . pop ( <str> , None ) inner = kwargs . pop ( <str> , None ) weighting = kwargs . pop ( <str> , None ) exponent = float ( kwargs . pop ( <str> , 2.0 ) ) if kwargs :              raise TypeError ( <str> <str> . format ( kwargs ) )  if sum ( x is None for x in ( dist , norm , inner , weighting ) ) < 3 :              raise ValueError ( <str> <str> )  if any ( x is not None for x in ( dist , norm , inner ) ) and exponent != 2.0 :              raise ValueError ( <str> <str> )  if len ( spaces ) == 2 and isinstance ( spaces [ 1 ] , Integral ) :              field = spaces [ 0 ] . field spaces = [ spaces [ 0 ] ] * spaces [ 1 ]  if not all ( isinstance ( spc , LinearSpace ) for spc in spaces ) :              raise TypeError ( <str> <str> <str> . format ( spaces ) )  if not all ( spc . field == spaces [ 0 ] . field for spc in spaces ) :              raise ValueError ( <str> )  self . __spaces = tuple ( spaces ) self . __is_power_space = all ( spc == self . spaces [ 0 ] for spc in self . spaces [ 1 : ] ) if field is None :              if len ( self ) == 0 :                  raise ValueError ( <str> )  else :                  field = self . spaces [ 0 ] . field   super ( ProductSpace , self ) . __init__ ( field ) if weighting is not None :              if isinstance ( weighting , Weighting ) :                  self . __weighting = weighting  elif np . isscalar ( weighting ) :                  self . __weighting = ProductSpaceConstWeighting ( weighting , exponent )  elif weighting is None :                  pass  else :                  arr = np . asarray ( weighting ) if arr . dtype == object :                      raise ValueError ( <str> <str> . format ( weighting ) )  if arr . ndim == 1 :                      self . __weighting = ProductSpaceArrayWeighting ( arr , exponent )  else :                      raise ValueError ( <str> <str> . format ( arr . ndim ) )    elif dist is not None :              self . __weighting = ProductSpaceCustomDist ( dist )  elif norm is not None :              self . __weighting = ProductSpaceCustomNorm ( norm )  elif inner is not None :              self . __weighting = ProductSpaceCustomInner ( inner )  else :              self . __weighting = ProductSpaceConstWeighting ( 1.0 , exponent )   def __len__ ( self ) :          return len ( self . spaces )  @ property def nbytes ( self ) :          return sum ( spc . nbytes for spc in self . spaces )  @ property def shape ( self ) :          if len ( self ) == 0 :              return ( )  elif self . is_power_space :              try :                  sub_shape = self [ 0 ] . shape  except AttributeError :                  sub_shape = ( )   else :              sub_shape = ( )  return ( len ( self ) , ) + sub_shape  @ property def size ( self ) :          return ( 0 if self . shape == ( ) else int ( np . prod ( self . shape , dtype = <str> ) ) )  @ property def spaces ( self ) :          return self . __spaces  @ property def is_power_space ( self ) :          return self . __is_power_space  @ property def exponent ( self ) :          return self . weighting . exponent  @ property def weighting ( self ) :          return self . __weighting  @ property def is_weighted ( self ) :          return not ( isinstance ( self . weighting , ProductSpaceConstWeighting ) and self . weighting . const == 1.0 )  @ property def dtype ( self ) :          dtypes = [ space . dtype for space in self . spaces ] if all ( dtype == dtypes [ 0 ] for dtype in dtypes ) :              return dtypes [ 0 ]  else :              raise AttributeError ( <str> )   @ property def is_real ( self ) :          return all ( spc . is_real for spc in self . spaces )  @ property def is_complex ( self ) :          return all ( spc . is_complex for spc in self . spaces )  @ property def real_space ( self ) :          return ProductSpace ( * [ space . real_space for space in self . spaces ] )  @ property def complex_space ( self ) :          return ProductSpace ( * [ space . complex_space for space in self . spaces ] )  def astype ( self , dtype ) :          if dtype is None :              raise ValueError ( <str> )  dtype = np . dtype ( dtype ) current_dtype = getattr ( self , <str> , object ) if dtype == current_dtype :              return self  else :              return ProductSpace ( * [ space . astype ( dtype ) for space in self . spaces ] )   def element ( self , inp = None , cast = True ) :          if inp is None :              inp = [ space . element ( ) for space in self . spaces ]  if inp in self :              return inp  if len ( inp ) != len ( self ) :              raise ValueError ( <str> <str> . format ( len ( inp ) , len ( self ) ) )  if ( all ( isinstance ( v , LinearSpaceElement ) and v . space == space for v , space in zip ( inp , self . spaces ) ) ) :              parts = list ( inp )  elif cast :              parts = [ space . element ( arg ) for arg , space in zip ( inp , self . spaces ) ]  else :              raise TypeError ( <str> <str> . format ( inp ) )  return self . element_type ( self , parts )  @ property def examples ( self ) :          for examples in product ( * [ spc . examples for spc in self . spaces ] ) :              name = <str> . join ( name for name , _ in examples ) element = self . element ( [ elem for _ , elem in examples ] ) yield ( name , element )   def zero ( self ) :          return self . element ( [ space . zero ( ) for space in self . spaces ] )  def one ( self ) :          return self . element ( [ space . one ( ) for space in self . spaces ] )  def _lincomb ( self , a , x , b , y , out ) :          for space , xp , yp , outp in zip ( self . spaces , x . parts , y . parts , out . parts ) :              space . _lincomb ( a , xp , b , yp , outp )   def _dist ( self , x1 , x2 ) :          return self . weighting . dist ( x1 , x2 )  def _norm ( self , x ) :          return self . weighting . norm ( x )  def _inner ( self , x1 , x2 ) :          return self . weighting . inner ( x1 , x2 )  def _multiply ( self , x1 , x2 , out ) :          for spc , xp , yp , outp in zip ( self . spaces , x1 . parts , x2 . parts , out . parts ) :              spc . _multiply ( xp , yp , outp )   def _divide ( self , x1 , x2 , out ) :          for spc , xp , yp , outp in zip ( self . spaces , x1 . parts , x2 . parts , out . parts ) :              spc . _divide ( xp , yp , outp )   def __eq__ ( self , other ) :          if other is self :              return True  else :              return ( isinstance ( other , ProductSpace ) and len ( self ) == len ( other ) and self . weighting == other . weighting and all ( x == y for x , y in zip ( self . spaces , other . spaces ) ) )   def __hash__ ( self ) :          return hash ( ( type ( self ) , self . spaces , self . weighting ) )  def __getitem__ ( self , indices ) :          if isinstance ( indices , Integral ) :              return self . spaces [ indices ]  elif isinstance ( indices , slice ) :              return ProductSpace ( * self . spaces [ indices ] , field = self . field )  elif isinstance ( indices , tuple ) :              if not indices :                  return self  idx = indices [ 0 ] if isinstance ( idx , Integral ) :                  space = self . spaces [ idx ] rest_indcs = indices [ 1 : ] if not rest_indcs :                      return space  elif isinstance ( space , ProductSpace ) :                      return space [ rest_indcs ]  else :                      raise IndexError ( <str> <str> <str> . format ( rest_indcs ) )   elif isinstance ( idx , slice ) :                  spaces = self . spaces [ idx ] rest_indcs = indices [ 1 : ] if len ( spaces ) == 0 and rest_indcs :                      raise IndexError ( <str> <str> <str> . format ( rest_indcs ) )  if not rest_indcs :                      return ProductSpace ( * spaces )  elif all ( isinstance ( space , ProductSpace ) for space in spaces ) :                      return ProductSpace ( * ( space [ rest_indcs ] for space in spaces ) , field = self . field )  else :                      raise IndexError ( <str> <str> <str> . format ( rest_indcs ) )   else :                  raise TypeError ( <str> <str> )   elif isinstance ( indices , list ) :              return ProductSpace ( * [ self . spaces [ i ] for i in indices ] , field = self . field )  else :              raise TypeError ( <str> <str> . format ( indices ) )   def __str__ ( self ) :          if len ( self ) == 0 :              return <str>  elif self . is_power_space :              return <str> . format ( self . spaces [ 0 ] , len ( self ) )  else :              return <str> . join ( str ( space ) for space in self . spaces )   def __repr__ ( self ) :          weight_str = self . weighting . repr_part edgeitems = np . get_printoptions ( ) [ <str> ] if len ( self ) == 0 :              posargs = [ ] posmod = <str> optargs = [ ( <str> , self . field , None ) ] oneline = True  elif self . is_power_space :              posargs = [ self . spaces [ 0 ] , len ( self ) ] posmod = <str> optargs = [ ] oneline = True  elif self . size <= 2 * edgeitems :              posargs = self . spaces posmod = <str> optargs = [ ] argstr = <str> . join ( repr ( s ) for s in self . spaces ) oneline = ( len ( argstr + weight_str ) <= 40 and <str> not in argstr + weight_str )  else :              posargs = ( self . spaces [ : edgeitems ] + ( <str> , ) + self . spaces [ - edgeitems : ] ) posmod = [ <str> ] * edgeitems + [ <str> ] + [ <str> ] * edgeitems optargs = [ ] oneline = False  if oneline :              inner_str = signature_string ( posargs , optargs , sep = <str> , mod = [ posmod , <str> ] ) if weight_str :                  inner_str = <str> . join ( [ inner_str , weight_str ] )  return <str> . format ( self . __class__ . __name__ , inner_str )  else :              inner_str = signature_string ( posargs , optargs , sep = <str> , mod = [ posmod , <str> ] ) if weight_str :                  inner_str = <str> . join ( [ inner_str , weight_str ] )  return <str> . format ( self . __class__ . __name__ , indent ( inner_str ) )   @ property def element_type ( self ) :          return ProductSpaceElement   class ProductSpaceElement ( LinearSpaceElement ) :      def __init__ ( self , space , parts ) :          super ( ProductSpaceElement , self ) . __init__ ( space ) self . __parts = tuple ( parts )  @ property def parts ( self ) :          return self . __parts  @ property def shape ( self ) :          return self . space . shape  @ property def ndim ( self ) :          return len ( self . shape )  @ property def size ( self ) :          return int ( np . prod ( self . shape ) )  @ property def dtype ( self ) :          return self . space . dtype  def __len__ ( self ) :          return len ( self . space )  @ property def nbytes ( self ) :          return self . space . nbytes  def __eq__ ( self , other ) :          if other is self :              return True  elif other not in self . space :              return False  else :              return all ( sp == op for sp , op in zip ( self . parts , other . parts ) )   def __getitem__ ( self , indices ) :          if isinstance ( indices , Integral ) :              return self . parts [ indices ]  elif isinstance ( indices , slice ) :              return self . space [ indices ] . element ( self . parts [ indices ] )  elif isinstance ( indices , list ) :              out_parts = [ self . parts [ i ] for i in indices ] return self . space [ indices ] . element ( out_parts )  elif isinstance ( indices , tuple ) :              if len ( indices ) == 0 :                  return ProductSpace ( ) . element ( )  elif len ( indices ) == 1 :                  return self [ indices [ 0 ] ]  else :                  if isinstance ( indices [ 0 ] , Integral ) :                      return self . parts [ indices [ 0 ] ] [ indices [ 1 : ] ]  else :                      if isinstance ( indices [ 0 ] , list ) :                          part = [ self . parts [ i ] for i in indices [ 0 ] ]  else :                          part = self . parts [ indices [ 0 ] ]  if ( len ( indices [ 1 : ] ) == 1 and not all ( isinstance ( p , ProductSpaceElement ) for p in part ) ) :                          idx = indices [ 1 ] indexed = [ p [ idx : idx + 1 ] for p in part ]  else :                          indexed = [ p [ indices [ 1 : ] ] for p in part ]  new_space = ProductSpace ( * ( p . space for p in indexed ) ) return new_space . element ( indexed )    else :              raise TypeError ( <str> . format ( type ( indices ) ) )   def __setitem__ ( self , indices , values ) :          if isinstance ( indices , Integral ) :              indexed_parts = ( self . parts [ indices ] , ) values = ( values , )  elif isinstance ( indices , slice ) :              indexed_parts = self . parts [ indices ]  elif isinstance ( indices , list ) :              indexed_parts = tuple ( self . parts [ i ] for i in indices )  elif isinstance ( indices , tuple ) :              if len ( indices ) == 0 :                  return  else :                  part = self . parts [ indices [ 0 ] ] if isinstance ( part , LinearSpaceElement ) :                      part . __setitem__ ( indices [ 1 : ] , values )  else :                      for p in part :                          p . __setitem__ ( indices [ 1 : ] , values )   return   else :              raise TypeError ( <str> . format ( type ( indices ) ) )  try :              iter ( values )  except TypeError :              for p in indexed_parts :                  p [ : ] = values   else :              if self . space . is_power_space and values in self . space [ 0 ] :                  for p in indexed_parts :                      p [ : ] = values   else :                  if len ( values ) != len ( indexed_parts ) :                      raise ValueError ( <str> <str> <str> . format ( len ( values ) , len ( indexed_parts ) ) )  for p , v in zip ( indexed_parts , values ) :                      p [ : ] = v     def asarray ( self , out = None ) :          if not self . space . is_power_space :              raise ValueError ( <str> <str> )  else :              if out is None :                  out = np . empty ( self . shape , self . dtype )  for i in range ( len ( self ) ) :                  out [ i ] = np . asarray ( self [ i ] )  return out   def __array__ ( self ) :          return self . asarray ( )  def __array_wrap__ ( self , array ) :          return self . space . element ( array )  @ property def ufuncs ( self ) :          return ProductSpaceUfuncs ( self )  @ property def real ( self ) :          real_part = [ part . real for part in self . parts ] return self . space . real_space . element ( real_part )  @ real . setter def real ( self , newreal ) :          try :              iter ( newreal )  except TypeError :              for part in self . parts :                  part . real = newreal  return  if self . space . is_power_space :              try :                  for part in self . parts :                      part . real = newreal   except ( ValueError , TypeError ) :                  for part , new_re in zip ( self . parts , newreal ) :                      part . real = new_re  pass   elif len ( newreal ) == len ( self ) :              for part , new_re in zip ( self . parts , newreal ) :                  part . real = new_re   else :              raise ValueError ( <str> <str> . format ( newreal , self ) )   @ property def imag ( self ) :          imag_part = [ part . imag for part in self . parts ] return self . space . real_space . element ( imag_part )  @ imag . setter def imag ( self , newimag ) :          try :              iter ( newimag )  except TypeError :              for part in self . parts :                  part . imag = newimag  return  if self . space . is_power_space :              try :                  for part in self . parts :                      part . imag = newimag   except ( ValueError , TypeError ) :                  for part , new_im in zip ( self . parts , newimag ) :                      part . imag = new_im  pass   elif len ( newimag ) == len ( self ) :              for part , new_im in zip ( self . parts , newimag ) :                  part . imag = new_im   else :              raise ValueError ( <str> <str> <str> . format ( newimag , self ) )   def conj ( self ) :          complex_conj = [ part . conj ( ) for part in self . parts ] return self . space . element ( complex_conj )  def __str__ ( self ) :          return repr ( self )  def __repr__ ( self ) :          inner_str = <str> if len ( self ) < 5 :              inner_str += <str> . join ( <str> . format ( _indent ( _strip_space ( part ) ) ) for part in self . parts )  else :              inner_str += <str> . join ( <str> . format ( _indent ( _strip_space ( part ) ) ) for part in self . parts [ : 3 ] ) inner_str += <str> inner_str += <str> . join ( <str> . format ( _indent ( _strip_space ( part ) ) ) for part in self . parts [ - 1 : ] )  inner_str += <str> return <str> . format ( self . space , inner_str )  def show ( self , title = None , indices = None , ** kwargs ) :          if title is None :              title = <str>  if indices is None :              if len ( self ) < 5 :                  indices = list ( range ( len ( self ) ) )  else :                  indices = list ( np . linspace ( 0 , len ( self ) - 1 , 4 , dtype = int ) )   else :              if ( isinstance ( indices , tuple ) or ( isinstance ( indices , list ) and not all ( isinstance ( idx , Integral ) for idx in indices ) ) ) :                  indices , kwargs [ <str> ] = indices [ 0 ] , indices [ 1 : ]  if indices is None :                  indices = slice ( None )  if isinstance ( indices , slice ) :                  indices = list ( range ( * indices . indices ( len ( self ) ) ) )  elif isinstance ( indices , Integral ) :                  indices = [ indices ]  else :                  pass   in_figs = kwargs . pop ( <str> , None ) in_figs = [ None ] * len ( indices ) if in_figs is None else in_figs figs = [ ] parts = self [ indices ] if len ( parts ) == 0 :              return ( )  elif len ( parts ) == 1 :              fig = parts [ 0 ] . show ( title = title , fig = in_figs [ 0 ] , ** kwargs ) figs . append ( fig )  else :              for i , part , fig in zip ( indices , parts , in_figs ) :                  fig = part . show ( title = <str> . format ( title , i ) , fig = fig , ** kwargs ) figs . append ( fig )   return tuple ( figs )   def _broadcast_arithmetic ( op ) :      def _broadcast_arithmetic_impl ( self , other ) :          if ( self . space . is_power_space and other in self . space [ 0 ] ) :              results = [ ] for xi in self :                  res = getattr ( xi , op ) ( other ) if res is NotImplemented :                      return NotImplemented  else :                      results . append ( res )   return self . space . element ( results )  else :              return getattr ( LinearSpaceElement , op ) ( self , other )   docstring = . format ( op = op ) _broadcast_arithmetic_impl . __doc__ = docstring return _broadcast_arithmetic_impl  for op in [ <str> , <str> , <str> , <str> , <str> ] :      for modifier in [ <str> , <str> , <str> ] :          name = <str> . format ( modifier , op ) setattr ( ProductSpaceElement , name , _broadcast_arithmetic ( name ) )   class ProductSpaceArrayWeighting ( ArrayWeighting ) :      def __init__ ( self , array , exponent = 2.0 ) :          super ( ProductSpaceArrayWeighting , self ) . __init__ ( array , impl = <str> , exponent = exponent )  def inner ( self , x1 , x2 ) :          if self . exponent != 2.0 :              raise NotImplementedError ( <str> <str> <str> . format ( self . exponent ) )  inners = np . fromiter ( ( x1i . inner ( x2i ) for x1i , x2i in zip ( x1 , x2 ) ) , dtype = x1 [ 0 ] . space . dtype , count = len ( x1 ) ) inner = np . dot ( inners , self . array ) if is_real_dtype ( x1 [ 0 ] . dtype ) :              return float ( inner )  else :              return complex ( inner )   def norm ( self , x ) :          if self . exponent == 2.0 :              norm_squared = self . inner ( x , x ) . real return np . sqrt ( norm_squared )  else :              norms = np . fromiter ( ( xi . norm ( ) for xi in x ) , dtype = np . float64 , count = len ( x ) ) if self . exponent in ( 1.0 , float ( <str> ) ) :                  norms *= self . array  else :                  norms *= self . array ** ( 1.0 / self . exponent )  return float ( np . linalg . norm ( norms , ord = self . exponent ) )    class ProductSpaceConstWeighting ( ConstWeighting ) :      def __init__ ( self , constant , exponent = 2.0 ) :          super ( ProductSpaceConstWeighting , self ) . __init__ ( constant , impl = <str> , exponent = exponent )  def inner ( self , x1 , x2 ) :          if self . exponent != 2.0 :              raise NotImplementedError ( <str> <str> <str> . format ( self . exponent ) )  inners = np . fromiter ( ( x1i . inner ( x2i ) for x1i , x2i in zip ( x1 , x2 ) ) , dtype = x1 [ 0 ] . space . dtype , count = len ( x1 ) ) inner = self . const * np . sum ( inners ) return x1 . space . field . element ( inner )  def norm ( self , x ) :          if self . exponent == 2.0 :              norm_squared = self . inner ( x , x ) . real return np . sqrt ( norm_squared )  else :              norms = np . fromiter ( ( xi . norm ( ) for xi in x ) , dtype = np . float64 , count = len ( x ) ) if self . exponent in ( 1.0 , float ( <str> ) ) :                  return ( self . const * float ( np . linalg . norm ( norms , ord = self . exponent ) ) )  else :                  return ( self . const ** ( 1 / self . exponent ) * float ( np . linalg . norm ( norms , ord = self . exponent ) ) )    def dist ( self , x1 , x2 ) :          dnorms = np . fromiter ( ( ( x1i - x2i ) . norm ( ) for x1i , x2i in zip ( x1 , x2 ) ) , dtype = np . float64 , count = len ( x1 ) ) if self . exponent == float ( <str> ) :              return self . const * np . linalg . norm ( dnorms , ord = self . exponent )  else :              return ( self . const ** ( 1 / self . exponent ) * np . linalg . norm ( dnorms , ord = self . exponent ) )    class ProductSpaceCustomInner ( CustomInner ) :      def __init__ ( self , inner ) :          super ( ProductSpaceCustomInner , self ) . __init__ ( impl = <str> , inner = inner )   class ProductSpaceCustomNorm ( CustomNorm ) :      def __init__ ( self , norm ) :          super ( ProductSpaceCustomNorm , self ) . __init__ ( norm , impl = <str> )   class ProductSpaceCustomDist ( CustomDist ) :      def __init__ ( self , dist ) :          super ( ProductSpaceCustomDist , self ) . __init__ ( dist , impl = <str> )   def _strip_space ( x ) :      r = repr ( x ) space_repr = <str> . format ( x . space ) if r . startswith ( space_repr ) and r . endswith ( <str> ) :          r = r [ len ( space_repr ) : - 1 ]  return r  def _indent ( x ) :      lines = x . splitlines ( ) for i , line in enumerate ( lines ) :          lines [ i ] = <str> + line  return <str> . join ( lines )  if __name__ == <str> :      from odl . util . testutils import run_doctests run_doctests ( )   