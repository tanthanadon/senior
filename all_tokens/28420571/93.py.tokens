from __future__ import print_function , division , absolute_import import numpy as np from odl . discr import ResizingOperator from odl . trafos import FourierTransform , PYFFTW_AVAILABLE __all__ = ( <str> , <str> , <str> , <str> ) def _axis_in_detector ( geometry ) :      du , dv = geometry . det_axes_init axis = geometry . axis c = np . array ( [ np . vdot ( axis , du ) , np . vdot ( axis , dv ) ] ) cnorm = np . linalg . norm ( c ) assert cnorm != 0 return c / cnorm  def _rotation_direction_in_detector ( geometry ) :      du , dv = geometry . det_axes_init axis = geometry . axis det_normal = np . cross ( dv , du ) rot_dir = np . cross ( axis , det_normal ) c = np . array ( [ np . vdot ( rot_dir , du ) , np . vdot ( rot_dir , dv ) ] ) cnorm = np . linalg . norm ( c ) assert cnorm != 0 return c / cnorm  def _fbp_filter ( norm_freq , filter_type , frequency_scaling ) :      if callable ( filter_type ) :          filt = filter_type ( norm_freq )  elif filter_type == <str> :          filt = np . copy ( norm_freq )  elif filter_type == <str> :          filt = norm_freq * np . sinc ( norm_freq / ( 2 * frequency_scaling ) )  elif filter_type == <str> :          filt = norm_freq * np . cos ( norm_freq * np . pi / ( 2 * frequency_scaling ) )  elif filter_type == <str> :          filt = norm_freq * ( 0.54 + 0.46 * np . cos ( norm_freq * np . pi / ( frequency_scaling ) ) )  elif filter_type == <str> :          filt = norm_freq * ( np . cos ( norm_freq * np . pi / ( 2 * frequency_scaling ) ) ** 2 )  else :          raise ValueError ( <str> <str> . format ( filter_type ) )  indicator = ( norm_freq <= frequency_scaling ) filt *= indicator return filt  def tam_danielson_window ( ray_trafo , smoothing_width = 0.05 , n_pi = 1 ) :      src_radius = ray_trafo . geometry . src_radius det_radius = ray_trafo . geometry . det_radius pitch = ray_trafo . geometry . pitch if pitch == 0 :          raise ValueError ( <str> <str> )  smoothing_width = float ( smoothing_width ) if smoothing_width < 0 :          raise ValueError ( <str> )  if n_pi % 2 != 1 :          raise ValueError ( <str> . format ( n_pi ) )  axis_proj = _axis_in_detector ( ray_trafo . geometry ) rot_dir = _rotation_direction_in_detector ( ray_trafo . geometry ) dx = ( rot_dir [ 0 ] * ray_trafo . range . meshgrid [ 1 ] + rot_dir [ 1 ] * ray_trafo . range . meshgrid [ 2 ] ) dx_axis = dx * src_radius / ( src_radius + det_radius ) def Vn ( u ) :          return ( pitch / ( 2 * np . pi ) * ( 1 + ( u / src_radius ) ** 2 ) * ( n_pi * np . pi / 2.0 - np . arctan ( u / src_radius ) ) )  lower_proj_axis = - Vn ( dx_axis ) upper_proj_axis = Vn ( - dx_axis ) lower_proj = lower_proj_axis * ( src_radius + det_radius ) / src_radius upper_proj = upper_proj_axis * ( src_radius + det_radius ) / src_radius interval = ( upper_proj - lower_proj ) width = interval * smoothing_width / np . sqrt ( 2 ) def window_fcn ( x ) :          import scipy . special x_along_axis = axis_proj [ 0 ] * x [ 1 ] + axis_proj [ 1 ] * x [ 2 ] if smoothing_width != 0 :              lower_wndw = 0.5 * ( 1 + scipy . special . erf ( ( x_along_axis - lower_proj ) / width ) ) upper_wndw = 0.5 * ( 1 + scipy . special . erf ( ( upper_proj - x_along_axis ) / width ) )  else :              lower_wndw = ( x_along_axis >= lower_proj ) upper_wndw = ( x_along_axis <= upper_proj )  return lower_wndw * upper_wndw  return ray_trafo . range . element ( window_fcn ) / n_pi  def parker_weighting ( ray_trafo , q = 0.25 ) :      src_radius = ray_trafo . geometry . src_radius det_radius = ray_trafo . geometry . det_radius ndim = ray_trafo . geometry . ndim angles = ray_trafo . range . meshgrid [ 0 ] min_rot_angle = ray_trafo . geometry . motion_partition . min_pt alen = ray_trafo . geometry . motion_params . length if ray_trafo . geometry . ndim != 2 :          pitch = ray_trafo . geometry . pitch if pitch != 0 :              raise ValueError ( <str> <str> )   if ndim == 2 :          dx = ray_trafo . range . meshgrid [ 1 ]  elif ndim == 3 :          rot_dir = _rotation_direction_in_detector ( ray_trafo . geometry ) if rot_dir [ 0 ] == 0 :              dx = rot_dir [ 1 ] * ray_trafo . range . meshgrid [ 2 ]  elif rot_dir [ 1 ] == 0 :              dx = rot_dir [ 0 ] * ray_trafo . range . meshgrid [ 1 ]  else :              dx = ( rot_dir [ 0 ] * ray_trafo . range . meshgrid [ 1 ] + rot_dir [ 1 ] * ray_trafo . range . meshgrid [ 2 ] )   dx_abs_max = np . max ( np . abs ( dx ) ) max_fan_angle = 2 * np . arctan2 ( dx_abs_max , src_radius + det_radius ) delta = max_fan_angle / 2 epsilon = alen - np . pi - max_fan_angle if epsilon < 0 :          raise Exception ( <str> )  def S ( betap ) :          return ( 0.5 * ( 1.0 + np . sin ( np . pi * betap ) ) * ( np . abs ( betap ) < 0.5 ) + ( betap >= 0.5 ) )  def b ( alpha ) :          return q * ( 2 * delta - 2 * alpha + epsilon )  beta = np . asarray ( angles - min_rot_angle , dtype = ray_trafo . range . dtype ) alpha = np . asarray ( np . arctan2 ( dx , src_radius + det_radius ) , dtype = ray_trafo . range . dtype ) S_sum = S ( beta / b ( alpha ) - 0.5 ) S_sum += S ( ( beta - 2 * delta + 2 * alpha - epsilon ) / b ( alpha ) + 0.5 ) S_sum -= S ( ( beta - np . pi + 2 * alpha ) / b ( - alpha ) - 0.5 ) S_sum -= S ( ( beta - np . pi - 2 * delta - epsilon ) / b ( - alpha ) + 0.5 ) scale = 0.5 * alen / np . pi return ray_trafo . range . element ( np . broadcast_to ( S_sum * scale , ray_trafo . range . shape ) )  def fbp_filter_op ( ray_trafo , padding = True , filter_type = <str> , frequency_scaling = 1.0 ) :      impl = <str> if PYFFTW_AVAILABLE else <str> alen = ray_trafo . geometry . motion_params . length if ray_trafo . domain . ndim == 2 :          def fourier_filter ( x ) :              abs_freq = np . abs ( x [ 1 ] ) norm_freq = abs_freq / np . max ( abs_freq ) filt = _fbp_filter ( norm_freq , filter_type , frequency_scaling ) scaling = 1 / ( 2 * alen ) return filt * np . max ( abs_freq ) * scaling  if padding :              ran_shp = ( ray_trafo . range . shape [ 0 ] , ray_trafo . range . shape [ 1 ] * 2 - 1 ) resizing = ResizingOperator ( ray_trafo . range , ran_shp = ran_shp ) fourier = FourierTransform ( resizing . range , axes = 1 , impl = impl ) fourier = fourier * resizing  else :              fourier = FourierTransform ( ray_trafo . range , axes = 1 , impl = impl )   elif ray_trafo . domain . ndim == 3 :          rot_dir = _rotation_direction_in_detector ( ray_trafo . geometry ) used_axes = ( rot_dir != 0 ) if used_axes [ 0 ] and not used_axes [ 1 ] :              axes = [ 1 ]  elif not used_axes [ 0 ] and used_axes [ 1 ] :              axes = [ 2 ]  else :              axes = [ 1 , 2 ]  if hasattr ( ray_trafo . geometry , <str> ) :              scale = ( ray_trafo . geometry . src_radius / ( ray_trafo . geometry . src_radius + ray_trafo . geometry . det_radius ) ) if ray_trafo . geometry . pitch != 0 :                  scale *= alen / ( np . pi )   else :              scale = 1.0  def fourier_filter ( x ) :              if not used_axes [ 0 ] :                  abs_freq = np . abs ( rot_dir [ 1 ] * x [ 2 ] )  elif not used_axes [ 1 ] :                  abs_freq = np . abs ( rot_dir [ 0 ] * x [ 1 ] )  else :                  abs_freq = np . abs ( rot_dir [ 0 ] * x [ 1 ] + rot_dir [ 1 ] * x [ 2 ] )  norm_freq = abs_freq / np . max ( abs_freq ) filt = _fbp_filter ( norm_freq , filter_type , frequency_scaling ) scaling = scale * np . max ( abs_freq ) / ( 2 * alen ) return filt * scaling  if padding :              if used_axes [ 0 ] :                  padded_shape_u = ray_trafo . range . shape [ 1 ] * 2 - 1  else :                  padded_shape_u = ray_trafo . range . shape [ 1 ]  if used_axes [ 1 ] :                  padded_shape_v = ray_trafo . range . shape [ 2 ] * 2 - 1  else :                  padded_shape_v = ray_trafo . range . shape [ 2 ]  ran_shp = ( ray_trafo . range . shape [ 0 ] , padded_shape_u , padded_shape_v ) resizing = ResizingOperator ( ray_trafo . range , ran_shp = ran_shp ) fourier = FourierTransform ( resizing . range , axes = axes , impl = impl ) fourier = fourier * resizing  else :              fourier = FourierTransform ( ray_trafo . range , axes = axes , impl = impl )   else :          raise NotImplementedError ( <str> )  ramp_function = fourier . range . element ( fourier_filter ) weight = 1 if not ray_trafo . range . is_weighted :          weight *= ray_trafo . range . cell_volume  if not ray_trafo . domain . is_weighted :          weight /= ray_trafo . domain . cell_volume  ramp_function *= weight return fourier . inverse * ramp_function * fourier  def fbp_op ( ray_trafo , padding = True , filter_type = <str> , frequency_scaling = 1.0 ) :      return ray_trafo . adjoint * fbp_filter_op ( ray_trafo , padding , filter_type , frequency_scaling )  if __name__ == <str> :      import odl import matplotlib . pyplot as plt from odl . util . testutils import run_doctests x = np . linspace ( 0 , 1 , 100 ) cutoff = 0.7 plt . figure ( <str> ) for filter_name in [ <str> , <str> , <str> , <str> , <str> , np . sqrt ] :          plt . plot ( x , _fbp_filter ( x , filter_name , cutoff ) , label = filter_name )  plt . title ( <str> . format ( cutoff ) ) plt . legend ( loc = 2 ) reco_space = odl . uniform_discr ( min_pt = [ - 20 , - 20 , 0 ] , max_pt = [ 20 , 20 , 40 ] , shape = [ 300 , 300 , 300 ] ) angle_partition = odl . uniform_partition ( 0 , 8 * 2 * np . pi , 2000 ) detector_partition = odl . uniform_partition ( [ - 40 , - 4 ] , [ 40 , 4 ] , [ 500 , 500 ] ) geometry = odl . tomo . ConeFlatGeometry ( angle_partition , detector_partition , src_radius = 100 , det_radius = 100 , pitch = 5.0 ) ray_trafo = odl . tomo . RayTransform ( reco_space , geometry , impl = <str> ) td_window = tam_danielson_window ( ray_trafo , smoothing_width = 0 ) td_window . show ( <str> , coords = [ 0 , None , None ] ) geometry = odl . tomo . cone_beam_geometry ( reco_space , src_radius = 40 , det_radius = 80 ) ray_trafo = odl . tomo . RayTransform ( reco_space , geometry , impl = <str> ) parker_weighting = parker_weighting ( ray_trafo ) parker_weighting . show ( <str> ) run_doctests ( )   