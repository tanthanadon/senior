import numpy as np from odl . discr import uniform_discr from odl . trafos . backends import PYFFTW_AVAILABLE __all__ = ( ) def filter_image_sep2d ( image , fh , fv , impl = <str> , padding = None ) :      impl , impl_in = str ( impl ) . lower ( ) , impl image = np . asarray ( image ) if image . ndim != 2 :          raise ValueError ( <str> <str> . format ( image . ndim ) )  if image . size == 0 :          raise ValueError ( <str> )  if not np . issubsctype ( image . dtype , np . floating ) :          image = image . astype ( float )  fh = np . asarray ( fh ) . astype ( image . dtype ) if fh . ndim != 1 :          raise ValueError ( <str> )  elif fh . size == 0 :          raise ValueError ( <str> )  elif fh . size > image . shape [ 0 ] :          raise ValueError ( <str> <str> . format ( fh . size , image . shape [ 0 ] ) )  fv = np . asarray ( fv ) . astype ( image . dtype ) if fv . ndim != 1 :          raise ValueError ( <str> )  elif fv . size == 0 :          raise ValueError ( <str> )  elif fv . size > image . shape [ 0 ] :          raise ValueError ( <str> <str> . format ( fv . size , image . shape [ 1 ] ) )  if padding is None :          padding = min ( max ( len ( fh ) , len ( fv ) ) - 1 , 64 )  if padding != 0 :          image_padded = np . pad ( image , padding , mode = <str> )  else :          image_padded = image . copy ( ) if impl == <str> else image  def prepare_for_fft ( filt , n_new ) :          mid = ( len ( filt ) - 1 ) // 2 padded = np . zeros ( n_new , dtype = filt . dtype ) padded [ : len ( filt ) - mid ] = filt [ mid : ] padded [ len ( padded ) - mid : ] = filt [ : mid ] return padded  fh = prepare_for_fft ( fh , image_padded . shape [ 0 ] ) fv = prepare_for_fft ( fv , image_padded . shape [ 1 ] ) if impl == <str> :          image_ft = np . fft . rfftn ( image_padded ) fh_ft = np . fft . fft ( fh ) fv_ft = np . fft . rfft ( fv ) image_ft *= fh_ft [ : , None ] image_ft *= fv_ft [ None , : ] conv = np . fft . irfftn ( image_ft , s = image_padded . shape ) if conv . dtype != image . dtype :              conv = conv . astype ( image . dtype )   elif impl == <str> :          if not PYFFTW_AVAILABLE :              raise ValueError ( <str> <str> )  import pyfftw import multiprocessing out_img_shape = ( image_padded . shape [ 0 ] , image_padded . shape [ 1 ] // 2 + 1 ) out_img_dtype = np . result_type ( image_padded , 1j ) out_img = np . empty ( out_img_shape , out_img_dtype ) out_fh_shape = out_img_shape [ 0 ] out_fh_dtype = np . result_type ( fh , 1j ) fh_c = fh . astype ( out_fh_dtype ) out_fh = np . empty ( out_fh_shape , out_fh_dtype ) out_fv_shape = out_img_shape [ 1 ] out_fv_dtype = np . result_type ( fv , 1j ) out_fv = np . empty ( out_fv_shape , out_fv_dtype ) plan = pyfftw . FFTW ( image_padded , out_img , axes = ( 0 , 1 ) , direction = <str> , flags = [ <str> ] , threads = multiprocessing . cpu_count ( ) ) plan ( image_padded , out_img ) plan = pyfftw . FFTW ( fh_c , out_fh , axes = ( 0 , ) , direction = <str> , flags = [ <str> ] , threads = multiprocessing . cpu_count ( ) ) plan ( fh_c , out_fh ) plan = pyfftw . FFTW ( fv , out_fv , axes = ( 0 , ) , direction = <str> , flags = [ <str> ] , threads = multiprocessing . cpu_count ( ) ) plan ( fv , out_fv ) out_img *= out_fh [ : , None ] out_img *= out_fv [ None , : ] conv = image_padded plan = pyfftw . FFTW ( out_img . copy ( ) , conv , axes = ( 0 , 1 ) , direction = <str> , flags = [ <str> ] , threads = multiprocessing . cpu_count ( ) ) plan ( out_img , conv )  else :          raise ValueError ( <str> . format ( impl_in ) )  if padding :          return conv [ padding : - padding , padding : - padding ]  else :          return conv   def haarpsi_similarity_map ( img1 , img2 , axis , c , a ) :      import scipy . special impl = <str> if PYFFTW_AVAILABLE else <str> dec_lo_lvl1 = np . array ( [ np . sqrt ( 2 ) , np . sqrt ( 2 ) ] ) dec_lo_lvl2 = np . repeat ( dec_lo_lvl1 , 2 ) dec_hi_lvl1 = np . array ( [ - np . sqrt ( 2 ) , np . sqrt ( 2 ) ] ) dec_hi_lvl2 = np . repeat ( dec_hi_lvl1 , 2 ) if axis == 0 :          fh_lvl1 = dec_hi_lvl1 fv_lvl1 = dec_lo_lvl1 fh_lvl2 = dec_hi_lvl2 fv_lvl2 = dec_lo_lvl2  elif axis == 1 :          fh_lvl1 = dec_lo_lvl1 fv_lvl1 = dec_hi_lvl1 fh_lvl2 = dec_lo_lvl2 fv_lvl2 = dec_hi_lvl2  else :          raise ValueError ( <str> )  img1_lvl1 = filter_image_sep2d ( img1 , fh_lvl1 , fv_lvl1 , impl = impl ) img1_lvl2 = filter_image_sep2d ( img1 , fh_lvl2 , fv_lvl2 , impl = impl ) img2_lvl1 = filter_image_sep2d ( img2 , fh_lvl1 , fv_lvl1 , impl = impl ) img2_lvl2 = filter_image_sep2d ( img2 , fh_lvl2 , fv_lvl2 , impl = impl ) c = float ( c ) def S ( x , y ) :          num = 2 * x num *= y num += c ** 2 denom = x ** 2 denom += y ** 2 denom += c ** 2 frac = num frac /= denom return frac  np . abs ( img1_lvl1 , out = img1_lvl1 ) np . abs ( img2_lvl1 , out = img2_lvl1 ) np . abs ( img1_lvl2 , out = img1_lvl2 ) np . abs ( img2_lvl2 , out = img2_lvl2 ) sim_lvl1 = S ( img1_lvl1 , img2_lvl1 ) sim_lvl2 = S ( img1_lvl2 , img2_lvl2 ) sim = sim_lvl1 sim += sim_lvl2 sim /= 2 sim *= a return scipy . special . expit ( sim )  def haarpsi_weight_map ( img1 , img2 , axis ) :      impl = <str> if PYFFTW_AVAILABLE else <str> dec_lo_lvl3 = np . repeat ( [ np . sqrt ( 2 ) , np . sqrt ( 2 ) ] , 4 ) dec_hi_lvl3 = np . repeat ( [ - np . sqrt ( 2 ) , np . sqrt ( 2 ) ] , 4 ) if axis == 0 :          fh_lvl3 = dec_hi_lvl3 fv_lvl3 = dec_lo_lvl3  elif axis == 1 :          fh_lvl3 = dec_lo_lvl3 fv_lvl3 = dec_hi_lvl3  else :          raise ValueError ( <str> )  img1_lvl3 = filter_image_sep2d ( img1 , fh_lvl3 , fv_lvl3 , impl = impl ) img2_lvl3 = filter_image_sep2d ( img2 , fh_lvl3 , fv_lvl3 , impl = impl ) np . abs ( img1_lvl3 , out = img1_lvl3 ) np . abs ( img2_lvl3 , out = img2_lvl3 ) return np . maximum ( img1_lvl3 , img2_lvl3 )  def spherical_sum ( image , binning_factor = 1.0 ) :      r = np . sqrt ( sum ( xi ** 2 for xi in image . space . meshgrid ) ) rmax = max ( np . linalg . norm ( c ) for c in image . space . domain . corners ( ) ) n_bins = int ( np . sqrt ( sum ( n ** 2 for n in image . shape ) ) / binning_factor ) rad_sum , _ = np . histogram ( r , weights = image , bins = n_bins , range = ( 0 , rmax ) ) out_spc = uniform_discr ( min_pt = 0 , max_pt = rmax , shape = n_bins , impl = image . space . impl , dtype = image . space . dtype , interp = <str> , axis_labels = [ <str> ] ) return out_spc . element ( rad_sum )   