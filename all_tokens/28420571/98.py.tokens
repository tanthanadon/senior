from __future__ import print_function , division , absolute_import import numpy as np from odl . util . normalize import normalized_scalar_param_list , safe_int_conv __all__ = ( <str> , <str> , <str> , <str> ) _SUPPORTED_RESIZE_PAD_MODES = ( <str> , <str> , <str> , <str> , <str> ) def apply_on_boundary ( array , func , only_once = True , which_boundaries = None , axis_order = None , out = None ) :      array = np . asarray ( array ) if callable ( func ) :          func = [ func ] * array . ndim  elif len ( func ) != array . ndim :          raise ValueError ( <str> <str> . format ( len ( func ) , array . ndim ) )  if which_boundaries is None :          which_boundaries = ( [ ( True , True ) ] * array . ndim )  elif len ( which_boundaries ) != array . ndim :          raise ValueError ( <str> <str> . format ( len ( which_boundaries ) , array . ndim ) )  if axis_order is None :          axis_order = list ( range ( array . ndim ) )  elif len ( axis_order ) != array . ndim :          raise ValueError ( <str> <str> . format ( len ( axis_order ) , array . ndim ) )  if out is None :          out = array . copy ( )  else :          out [ : ] = array  slices = [ slice ( None ) ] * array . ndim for ax , function , which in zip ( axis_order , func , which_boundaries ) :          if only_once :              slc_l = list ( slices ) slc_r = list ( slices )  else :              slc_l = [ slice ( None ) ] * array . ndim slc_r = [ slice ( None ) ] * array . ndim  slc_l [ ax ] = 0 slc_r [ ax ] = - 1 slc_l , slc_r = tuple ( slc_l ) , tuple ( slc_r ) try :              func_l , func_r = function  except TypeError :              func_l = func_r = function  try :              mod_left , mod_right = which  except TypeError :              mod_left = mod_right = which  if mod_left and func_l is not None :              out [ slc_l ] = func_l ( out [ slc_l ] ) start = 1  else :              start = None  if mod_right and func_r is not None :              out [ slc_r ] = func_r ( out [ slc_r ] ) end = - 1  else :              end = None  slices [ ax ] = slice ( start , end )  return out  def fast_1d_tensor_mult ( ndarr , onedim_arrs , axes = None , out = None ) :      if out is None :          out = np . array ( ndarr , copy = True )  else :          out [ : ] = ndarr  if not onedim_arrs :          raise ValueError ( <str> )  if axes is None :          axes = list ( range ( out . ndim - len ( onedim_arrs ) , out . ndim ) ) axes_in = None  elif len ( axes ) != len ( onedim_arrs ) :          raise ValueError ( <str> <str> . format ( len ( onedim_arrs ) , len ( axes ) ) )  else :          axes , axes_in = np . array ( axes , dtype = int ) , axes axes [ axes < 0 ] += out . ndim axes = list ( axes )  if not all ( 0 <= ai < out . ndim for ai in axes ) :          raise ValueError ( <str> <str> . format ( axes_in , out . ndim ) )  alist = [ np . atleast_1d ( np . asarray ( a ) . squeeze ( ) ) for a in onedim_arrs ] if any ( a . ndim != 1 for a in alist ) :          raise ValueError ( <str> )  if len ( axes ) < out . ndim :          factor = np . array ( 1.0 ) for ax , arr in zip ( axes , alist ) :              slc = [ None ] * out . ndim slc [ ax ] = slice ( None ) factor = factor * arr [ tuple ( slc ) ]  out *= factor  else :          last_ax = np . argmax ( out . strides ) last_arr = alist [ axes . index ( last_ax ) ] factor = np . array ( 1.0 ) for ax , arr in zip ( axes , alist ) :              if ax == last_ax :                  continue  slc = [ None ] * out . ndim slc [ ax ] = slice ( None ) factor = factor * arr [ tuple ( slc ) ]  out *= factor slc = [ None ] * out . ndim slc [ last_ax ] = slice ( None ) out *= last_arr [ tuple ( slc ) ]  return out  def resize_array ( arr , newshp , offset = None , pad_mode = <str> , pad_const = 0 , direction = <str> , out = None ) :      try :          newshp = tuple ( newshp )  except TypeError :          raise TypeError ( <str> . format ( newshp ) )  if out is not None :          if not isinstance ( out , np . ndarray ) :              raise TypeError ( <str> <str> . format ( out ) )  if out . shape != newshp :              raise ValueError ( <str> <str> . format ( newshp , out . shape ) )  order = <str> if out . flags . c_contiguous else <str> arr = np . asarray ( arr , dtype = out . dtype , order = order ) if arr . ndim != out . ndim :              raise ValueError ( <str> <str> . format ( arr . ndim , out . ndim ) )   else :          arr = np . asarray ( arr ) order = <str> if arr . flags . c_contiguous else <str> out = np . empty ( newshp , dtype = arr . dtype , order = order ) if len ( newshp ) != arr . ndim :              raise ValueError ( <str> <str> <str> . format ( arr . ndim , len ( newshp ) ) )   if offset is None :          offset = [ 0 ] * out . ndim  else :          offset = normalized_scalar_param_list ( offset , out . ndim , param_conv = safe_int_conv , keep_none = False )  pad_mode , pad_mode_in = str ( pad_mode ) . lower ( ) , pad_mode if pad_mode not in _SUPPORTED_RESIZE_PAD_MODES :          raise ValueError ( <str> . format ( pad_mode_in ) )  if ( pad_mode == <str> and not np . can_cast ( pad_const , out . dtype ) and any ( n_new > n_orig for n_orig , n_new in zip ( arr . shape , out . shape ) ) ) :          raise ValueError ( <str> <str> <str> . format ( pad_const , out . dtype ) )  direction , direction_in = str ( direction ) . lower ( ) , direction if direction not in ( <str> , <str> ) :          raise ValueError ( <str> <str> . format ( direction_in ) )  if direction == <str> and pad_mode == <str> and pad_const != 0 :          raise ValueError ( <str> <str> . format ( pad_const ) )  if direction == <str> and pad_mode == <str> and pad_const != 0 :          out . fill ( pad_const )  else :          out . fill ( 0 )  if direction == <str> :          if pad_mode == <str> :              _assign_intersection ( out , arr , offset )  else :              _assign_intersection ( out , arr , offset ) _apply_padding ( out , arr , offset , pad_mode , <str> )   else :          if pad_mode == <str> :              _assign_intersection ( out , arr , offset )  else :              tmp = arr . copy ( ) _apply_padding ( tmp , out , offset , pad_mode , <str> ) _assign_intersection ( out , tmp , offset )   return out  def _intersection_slice_tuples ( lhs_arr , rhs_arr , offset ) :      lhs_slc , rhs_slc = [ ] , [ ] for istart , n_lhs , n_rhs in zip ( offset , lhs_arr . shape , rhs_arr . shape ) :          istop = istart + min ( n_lhs , n_rhs ) inner_slc = slice ( istart , istop ) if n_lhs > n_rhs :              lhs_slc . append ( inner_slc ) rhs_slc . append ( slice ( None ) )  elif n_lhs < n_rhs :              lhs_slc . append ( slice ( None ) ) rhs_slc . append ( inner_slc )  else :              lhs_slc . append ( slice ( None ) ) rhs_slc . append ( slice ( None ) )   return tuple ( lhs_slc ) , tuple ( rhs_slc )  def _assign_intersection ( lhs_arr , rhs_arr , offset ) :      lhs_slc , rhs_slc = _intersection_slice_tuples ( lhs_arr , rhs_arr , offset ) lhs_arr [ lhs_slc ] = rhs_arr [ rhs_slc ]  def _padding_slices_outer ( lhs_arr , rhs_arr , axis , offset ) :      istart_inner = offset [ axis ] istop_inner = istart_inner + min ( lhs_arr . shape [ axis ] , rhs_arr . shape [ axis ] ) return slice ( istart_inner ) , slice ( istop_inner , None )  def _padding_slices_inner ( lhs_arr , rhs_arr , axis , offset , pad_mode ) :      istart_inner = offset [ axis ] n_large = max ( lhs_arr . shape [ axis ] , rhs_arr . shape [ axis ] ) n_small = min ( lhs_arr . shape [ axis ] , rhs_arr . shape [ axis ] ) istop_inner = istart_inner + n_small n_pad_l = istart_inner n_pad_r = n_large - istop_inner if pad_mode == <str> :          pad_slc_l = slice ( istop_inner - n_pad_l , istop_inner ) pad_slc_r = slice ( istart_inner , istart_inner + n_pad_r )  elif pad_mode == <str> :          pad_slc_l = slice ( istart_inner + n_pad_l , istart_inner , - 1 ) istop_r = istop_inner - 2 - n_pad_r if istop_r == - 1 :              istop_r = None  pad_slc_r = slice ( istop_inner - 2 , istop_r , - 1 )  elif pad_mode in ( <str> , <str> ) :          pad_slc_l = slice ( istart_inner , istart_inner + 1 ) pad_slc_r = slice ( istop_inner - 1 , istop_inner )  else :          pad_slc_l , pad_slc_r = slice ( 0 ) , slice ( 0 )  return pad_slc_l , pad_slc_r  def _apply_padding ( lhs_arr , rhs_arr , offset , pad_mode , direction ) :      if pad_mode not in ( <str> , <str> , <str> , <str> ) :          return  full_slc = [ slice ( None ) ] * lhs_arr . ndim intersec_slc , _ = _intersection_slice_tuples ( lhs_arr , rhs_arr , offset ) if direction == <str> :          working_slc = list ( intersec_slc )  else :          working_slc = list ( full_slc )  for axis , ( n_lhs , n_rhs ) in enumerate ( zip ( lhs_arr . shape , rhs_arr . shape ) ) :          if n_lhs <= n_rhs :              continue  n_pad_l = offset [ axis ] n_pad_r = n_lhs - n_rhs - n_pad_l if pad_mode == <str> and n_rhs == 0 :              raise ValueError ( <str> <str> <str> . format ( axis ) )  if pad_mode == <str> and n_rhs < 2 :              raise ValueError ( <str> <str> <str> . format ( axis , n_rhs ) )  for lr , pad_len in [ ( <str> , n_pad_l ) , ( <str> , n_pad_r ) ] :              if pad_mode == <str> and pad_len > n_rhs :                  raise ValueError ( <str> <str> <str> <str> . format ( axis , lr , pad_len , n_rhs ) )  elif pad_mode == <str> and pad_len >= n_rhs :                  raise ValueError ( <str> <str> <str> <str> <str> . format ( axis , lr , pad_len , n_rhs ) )   lhs_slc_l , lhs_slc_r , rhs_slc_l , rhs_slc_r = map ( list , [ working_slc ] * 4 ) pad_slc_outer_l , pad_slc_outer_r = _padding_slices_outer ( lhs_arr , rhs_arr , axis , offset ) if direction == <str> :              lhs_slc_l [ axis ] = pad_slc_outer_l lhs_slc_r [ axis ] = pad_slc_outer_r  else :              rhs_slc_l [ axis ] = pad_slc_outer_l rhs_slc_r [ axis ] = pad_slc_outer_r  if pad_mode in ( <str> , <str> ) :              pad_slc_inner_l , pad_slc_inner_r = _padding_slices_inner ( lhs_arr , rhs_arr , axis , offset , pad_mode ) if direction == <str> :                  rhs_slc_l [ axis ] = pad_slc_inner_l rhs_slc_r [ axis ] = pad_slc_inner_r lhs_slc_l , rhs_slc_l , lhs_slc_r , rhs_slc_r = map ( tuple , [ lhs_slc_l , rhs_slc_l , lhs_slc_r , rhs_slc_r ] ) lhs_arr [ lhs_slc_l ] = lhs_arr [ rhs_slc_l ] lhs_arr [ lhs_slc_r ] = lhs_arr [ rhs_slc_r ]  else :                  lhs_slc_l [ axis ] = pad_slc_inner_l lhs_slc_r [ axis ] = pad_slc_inner_r lhs_slc_l , rhs_slc_l , lhs_slc_r , rhs_slc_r = map ( tuple , [ lhs_slc_l , rhs_slc_l , lhs_slc_r , rhs_slc_r ] ) lhs_arr [ lhs_slc_l ] += lhs_arr [ rhs_slc_l ] lhs_arr [ lhs_slc_r ] += lhs_arr [ rhs_slc_r ]   elif pad_mode == <str> :              left_slc , right_slc = _padding_slices_inner ( lhs_arr , rhs_arr , axis , offset , pad_mode ) if direction == <str> :                  rhs_slc_l [ axis ] = left_slc rhs_slc_r [ axis ] = right_slc lhs_slc_l , rhs_slc_l , lhs_slc_r , rhs_slc_r = map ( tuple , [ lhs_slc_l , rhs_slc_l , lhs_slc_r , rhs_slc_r ] ) lhs_arr [ lhs_slc_l ] = lhs_arr [ rhs_slc_l ] lhs_arr [ lhs_slc_r ] = lhs_arr [ rhs_slc_r ]  else :                  lhs_slc_l [ axis ] = left_slc lhs_slc_r [ axis ] = right_slc lhs_slc_l , rhs_slc_l , lhs_slc_r , rhs_slc_r = map ( tuple , [ lhs_slc_l , rhs_slc_l , lhs_slc_r , rhs_slc_r ] ) lhs_arr [ lhs_slc_l ] += np . sum ( lhs_arr [ rhs_slc_l ] , axis = axis , keepdims = True , dtype = lhs_arr . dtype ) lhs_arr [ lhs_slc_r ] += np . sum ( lhs_arr [ rhs_slc_r ] , axis = axis , keepdims = True , dtype = lhs_arr . dtype )   elif pad_mode == <str> :              bcast_slc = [ None ] * lhs_arr . ndim bcast_slc [ axis ] = slice ( None ) bcast_slc = tuple ( bcast_slc ) left_slc , right_slc = _padding_slices_inner ( lhs_arr , rhs_arr , axis , offset , pad_mode ) bdry_slc_l = list ( working_slc ) bdry_slc_l [ axis ] = left_slc bdry_slc_l = tuple ( bdry_slc_l ) bdry_slc_r = list ( working_slc ) bdry_slc_r [ axis ] = right_slc bdry_slc_r = tuple ( bdry_slc_r ) slope_slc_l = list ( working_slc ) slope_slc_l [ axis ] = slice ( left_slc . start , left_slc . stop + 1 ) slope_slc_l = tuple ( slope_slc_l ) slope_slc_r = list ( working_slc ) slope_slc_r [ axis ] = slice ( right_slc . start - 1 , right_slc . stop ) slope_slc_r = tuple ( slope_slc_r ) arange_l = np . arange ( - n_pad_l , 0 , dtype = lhs_arr . dtype ) [ bcast_slc ] arange_r = np . arange ( 1 , n_pad_r + 1 , dtype = lhs_arr . dtype ) [ bcast_slc ] lhs_slc_l , rhs_slc_l , lhs_slc_r , rhs_slc_r = map ( tuple , [ lhs_slc_l , rhs_slc_l , lhs_slc_r , rhs_slc_r ] ) if direction == <str> :                  slope_l = np . diff ( lhs_arr [ slope_slc_l ] , n = 1 , axis = axis ) slope_r = np . diff ( lhs_arr [ slope_slc_r ] , n = 1 , axis = axis ) lhs_arr [ lhs_slc_l ] = lhs_arr [ bdry_slc_l ] + arange_l * slope_l lhs_arr [ lhs_slc_r ] = lhs_arr [ bdry_slc_r ] + arange_r * slope_r  else :                  lhs_arr [ bdry_slc_l ] += np . sum ( lhs_arr [ rhs_slc_l ] , axis = axis , keepdims = True , dtype = lhs_arr . dtype ) lhs_arr [ bdry_slc_r ] += np . sum ( lhs_arr [ rhs_slc_r ] , axis = axis , keepdims = True , dtype = lhs_arr . dtype ) moment1_l = np . sum ( arange_l * lhs_arr [ rhs_slc_l ] , axis = axis , keepdims = True , dtype = lhs_arr . dtype ) moment1_r = np . sum ( arange_r * lhs_arr [ rhs_slc_r ] , axis = axis , keepdims = True , dtype = lhs_arr . dtype ) sign = np . array ( [ - 1 , 1 ] ) [ bcast_slc ] lhs_arr [ slope_slc_l ] += moment1_l * sign lhs_arr [ slope_slc_r ] += moment1_r * sign   if direction == <str> :              working_slc [ axis ] = full_slc [ axis ]  else :              working_slc [ axis ] = intersec_slc [ axis ]    def zscore ( arr ) :      arr = arr - np . mean ( arr ) std = np . std ( arr ) if std != 0 :          arr /= std  return arr  if __name__ == <str> :      from odl . util . testutils import run_doctests run_doctests ( )   