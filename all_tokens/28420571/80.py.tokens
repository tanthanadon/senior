from __future__ import absolute_import , division , print_function from builtins import object from multiprocessing import Lock import numpy as np from packaging . version import parse as parse_version from odl . discr import DiscreteLp from odl . tomo . backends . astra_setup import ( ASTRA_VERSION , astra_algorithm , astra_data , astra_projection_geometry , astra_projector , astra_volume_geometry ) from odl . tomo . geometry import ( ConeBeamGeometry , FanBeamGeometry , Geometry , Parallel2dGeometry , Parallel3dAxisGeometry ) try :      import astra ASTRA_CUDA_AVAILABLE = astra . astra . use_cuda ( )  except ImportError :      ASTRA_CUDA_AVAILABLE = False  __all__ = ( <str> , <str> , <str> , ) class AstraCudaProjectorImpl ( object ) :      algo_id = None vol_id = None sino_id = None proj_id = None def __init__ ( self , geometry , reco_space , proj_space ) :          assert isinstance ( geometry , Geometry ) assert isinstance ( reco_space , DiscreteLp ) assert isinstance ( proj_space , DiscreteLp ) self . geometry = geometry self . reco_space = reco_space self . proj_space = proj_space self . create_ids ( ) self . _mutex = Lock ( )  def call_forward ( self , vol_data , out = None ) :          with self . _mutex :              assert vol_data in self . reco_space if out is not None :                  assert out in self . proj_space  else :                  out = self . proj_space . element ( )  if self . geometry . ndim == 2 :                  astra . data2d . store ( self . vol_id , vol_data . asarray ( ) )  elif self . geometry . ndim == 3 :                  astra . data3d . store ( self . vol_id , vol_data . asarray ( ) )  else :                  raise RuntimeError ( <str> )  astra . algorithm . run ( self . algo_id ) if self . geometry . ndim == 2 :                  out [ : ] = self . out_array  elif self . geometry . ndim == 3 :                  out [ : ] = np . swapaxes ( self . out_array , 0 , 1 ) . reshape ( self . proj_space . shape )  if ( isinstance ( self . geometry , Parallel2dGeometry ) and parse_version ( ASTRA_VERSION ) < parse_version ( <str> ) ) :                  out *= 1 / float ( self . geometry . det_partition . cell_volume )  return out   def create_ids ( self ) :          if self . geometry . motion_partition . ndim == 1 :              motion_shape = self . geometry . motion_partition . shape  else :              motion_shape = ( np . prod ( self . geometry . motion_partition . shape ) , )  proj_shape = motion_shape + self . geometry . det_partition . shape proj_ndim = len ( proj_shape ) if proj_ndim == 2 :              astra_proj_shape = proj_shape astra_vol_shape = self . reco_space . shape  elif proj_ndim == 3 :              astra_proj_shape = ( proj_shape [ 1 ] , proj_shape [ 0 ] , proj_shape [ 2 ] ) astra_vol_shape = self . reco_space . shape  self . in_array = np . empty ( astra_vol_shape , dtype = <str> , order = <str> ) self . out_array = np . empty ( astra_proj_shape , dtype = <str> , order = <str> ) vol_geom = astra_volume_geometry ( self . reco_space ) proj_geom = astra_projection_geometry ( self . geometry ) self . vol_id = astra_data ( vol_geom , datatype = <str> , ndim = self . reco_space . ndim , data = self . in_array , allow_copy = False ) proj_type = <str> if proj_ndim == 2 else <str> self . proj_id = astra_projector ( proj_type , vol_geom , proj_geom , proj_ndim ) self . sino_id = astra_data ( proj_geom , datatype = <str> , ndim = proj_ndim , data = self . out_array , allow_copy = False ) self . algo_id = astra_algorithm ( <str> , proj_ndim , self . vol_id , self . sino_id , proj_id = self . proj_id , impl = <str> )  def __del__ ( self ) :          if self . geometry . ndim == 2 :              adata , aproj = astra . data2d , astra . projector  else :              adata , aproj = astra . data3d , astra . projector3d  if self . algo_id is not None :              astra . algorithm . delete ( self . algo_id ) self . algo_id = None  if self . vol_id is not None :              adata . delete ( self . vol_id ) self . vol_id = None  if self . sino_id is not None :              adata . delete ( self . sino_id ) self . sino_id = None  if self . proj_id is not None :              aproj . delete ( self . proj_id ) self . proj_id = None    class AstraCudaBackProjectorImpl ( object ) :      algo_id = None vol_id = None sino_id = None proj_id = None def __init__ ( self , geometry , reco_space , proj_space ) :          assert isinstance ( geometry , Geometry ) assert isinstance ( reco_space , DiscreteLp ) assert isinstance ( proj_space , DiscreteLp ) self . geometry = geometry self . reco_space = reco_space self . proj_space = proj_space self . create_ids ( ) self . _mutex = Lock ( )  def call_backward ( self , proj_data , out = None ) :          with self . _mutex :              assert proj_data in self . proj_space if out is not None :                  assert out in self . reco_space  else :                  out = self . reco_space . element ( )  if self . geometry . ndim == 2 :                  astra . data2d . store ( self . sino_id , proj_data . asarray ( ) )  elif self . geometry . ndim == 3 :                  shape = ( - 1 , ) + self . geometry . det_partition . shape reshaped_proj_data = proj_data . asarray ( ) . reshape ( shape ) swapped_proj_data = np . ascontiguousarray ( np . swapaxes ( reshaped_proj_data , 0 , 1 ) ) astra . data3d . store ( self . sino_id , swapped_proj_data )  astra . algorithm . run ( self . algo_id ) out [ : ] = self . out_array out *= astra_cuda_bp_scaling_factor ( self . proj_space , self . reco_space , self . geometry ) return out   def create_ids ( self ) :          if self . geometry . motion_partition . ndim == 1 :              motion_shape = self . geometry . motion_partition . shape  else :              motion_shape = ( np . prod ( self . geometry . motion_partition . shape ) , )  proj_shape = motion_shape + self . geometry . det_partition . shape proj_ndim = len ( proj_shape ) if proj_ndim == 2 :              astra_proj_shape = proj_shape astra_vol_shape = self . reco_space . shape  elif proj_ndim == 3 :              astra_proj_shape = ( proj_shape [ 1 ] , proj_shape [ 0 ] , proj_shape [ 2 ] ) astra_vol_shape = self . reco_space . shape  self . in_array = np . empty ( astra_proj_shape , dtype = <str> , order = <str> ) self . out_array = np . empty ( astra_vol_shape , dtype = <str> , order = <str> ) vol_geom = astra_volume_geometry ( self . reco_space ) proj_geom = astra_projection_geometry ( self . geometry ) self . sino_id = astra_data ( proj_geom , datatype = <str> , data = self . in_array , ndim = proj_ndim , allow_copy = False ) proj_type = <str> if proj_ndim == 2 else <str> self . proj_id = astra_projector ( proj_type , vol_geom , proj_geom , proj_ndim ) self . vol_id = astra_data ( vol_geom , datatype = <str> , data = self . out_array , ndim = self . reco_space . ndim , allow_copy = False ) self . algo_id = astra_algorithm ( <str> , proj_ndim , self . vol_id , self . sino_id , proj_id = self . proj_id , impl = <str> )  def __del__ ( self ) :          if self . geometry . ndim == 2 :              adata , aproj = astra . data2d , astra . projector  else :              adata , aproj = astra . data3d , astra . projector3d  if self . algo_id is not None :              astra . algorithm . delete ( self . algo_id ) self . algo_id = None  if self . vol_id is not None :              adata . delete ( self . vol_id ) self . vol_id = None  if self . sino_id is not None :              adata . delete ( self . sino_id ) self . sino_id = None  if self . proj_id is not None :              aproj . delete ( self . proj_id ) self . proj_id = None    def astra_cuda_bp_scaling_factor ( proj_space , reco_space , geometry ) :      angle_extent = geometry . motion_partition . extent num_angles = geometry . motion_partition . shape scaling_factor = ( angle_extent / num_angles ) . prod ( ) proj_extent = float ( proj_space . partition . extent . prod ( ) ) proj_size = float ( proj_space . partition . size ) proj_weighting = proj_extent / proj_size scaling_factor *= ( proj_space . weighting . const / proj_weighting ) scaling_factor /= ( reco_space . weighting . const / reco_space . cell_volume ) if parse_version ( ASTRA_VERSION ) < parse_version ( <str> ) :          if isinstance ( geometry , Parallel2dGeometry ) :              scaling_factor *= float ( reco_space . cell_volume )  elif ( isinstance ( geometry , FanBeamGeometry ) and geometry . det_curvature_radius is None ) :              scaling_factor *= float ( reco_space . cell_volume ) src_radius = geometry . src_radius det_radius = geometry . det_radius scaling_factor *= ( ( src_radius + det_radius ) / src_radius )  elif isinstance ( geometry , Parallel3dAxisGeometry ) :              voxel_stride = reco_space . cell_sides [ 0 ] scaling_factor /= float ( voxel_stride )  elif ( isinstance ( geometry , ConeBeamGeometry ) and geometry . det_curvature_radius is None ) :              voxel_stride = reco_space . cell_sides [ 0 ] scaling_factor /= float ( voxel_stride ) src_radius = geometry . src_radius det_radius = geometry . det_radius scaling_factor *= ( ( src_radius + det_radius ) / src_radius ) ** 2   elif parse_version ( ASTRA_VERSION ) < parse_version ( <str> ) :          if isinstance ( geometry , Parallel2dGeometry ) :              scaling_factor *= float ( reco_space . cell_volume )  elif ( isinstance ( geometry , FanBeamGeometry ) and geometry . det_curvature_radius is None ) :              scaling_factor *= float ( reco_space . cell_volume ) src_radius = geometry . src_radius det_radius = geometry . det_radius scaling_factor *= ( ( src_radius + det_radius ) / src_radius )  elif isinstance ( geometry , Parallel3dAxisGeometry ) :              scaling_factor /= reco_space . cell_volume  elif ( isinstance ( geometry , ConeBeamGeometry ) and geometry . det_curvature_radius is None ) :              scaling_factor /= reco_space . cell_volume src_radius = geometry . src_radius det_radius = geometry . det_radius scaling_factor *= ( ( src_radius + det_radius ) / src_radius ) ** 2 det_px_area = geometry . det_partition . cell_volume scaling_factor *= ( src_radius ** 2 * det_px_area ** 2 / reco_space . cell_volume ** 2 )   elif parse_version ( ASTRA_VERSION ) < parse_version ( <str> ) :          if isinstance ( geometry , Parallel2dGeometry ) :              scaling_factor *= float ( reco_space . cell_volume )  elif ( isinstance ( geometry , FanBeamGeometry ) and geometry . det_curvature_radius is None ) :              scaling_factor *= float ( reco_space . cell_volume ) src_radius = geometry . src_radius det_radius = geometry . det_radius scaling_factor *= ( ( src_radius + det_radius ) / src_radius )  elif isinstance ( geometry , Parallel3dAxisGeometry ) :              scaling_factor /= reco_space . cell_volume  elif ( isinstance ( geometry , ConeBeamGeometry ) and geometry . det_curvature_radius is None ) :              scaling_factor /= reco_space . cell_volume src_radius = geometry . src_radius det_radius = geometry . det_radius scaling_factor *= ( ( src_radius + det_radius ) / src_radius ) ** 2 det_px_area = geometry . det_partition . cell_volume scaling_factor *= ( src_radius ** 2 * det_px_area ** 2 )   else :          scaling_factor /= float ( reco_space . cell_volume ) scaling_factor *= float ( geometry . det_partition . cell_volume )  return scaling_factor  if __name__ == <str> :      from odl . util . testutils import run_doctests run_doctests ( )   