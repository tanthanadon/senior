from __future__ import print_function , division , absolute_import import numpy as np from odl . discr . lp_discr import uniform_discr_fromdiscr from odl . util . numerics import resize_array __all__ = ( <str> , <str> , <str> , <str> , <str> , <str> ) def cuboid ( space , min_pt = None , max_pt = None ) :      dom_min_pt = np . asarray ( space . domain . min ( ) ) dom_max_pt = np . asarray ( space . domain . max ( ) ) if min_pt is None :          min_pt = dom_min_pt * 0.75 + dom_max_pt * 0.25  if max_pt is None :          max_pt = dom_min_pt * 0.25 + dom_max_pt * 0.75  min_pt = np . atleast_1d ( min_pt ) max_pt = np . atleast_1d ( max_pt ) if min_pt . shape != ( space . ndim , ) :          raise ValueError ( <str> <str> . format ( ( space . ndim , ) , min_pt . shape ) )  if max_pt . shape != ( space . ndim , ) :          raise ValueError ( <str> <str> . format ( ( space . ndim , ) , max_pt . shape ) )  def phantom ( x ) :          result = True for xi , xmin , xmax in zip ( x , min_pt , max_pt ) :              result = ( result & np . less_equal ( xmin , xi ) & np . less_equal ( xi , xmax ) )  return result  return space . element ( phantom )  def defrise ( space , nellipses = 8 , alternating = False , min_pt = None , max_pt = None ) :      ellipses = defrise_ellipses ( space . ndim , nellipses = nellipses , alternating = alternating ) return ellipsoid_phantom ( space , ellipses , min_pt , max_pt )  def defrise_ellipses ( ndim , nellipses = 8 , alternating = False ) :      ellipses = [ ] if ndim == 2 :          for i in range ( nellipses ) :              if alternating :                  value = ( - 1.0 + 2.0 * ( i % 2 ) )  else :                  value = 1.0  axis_1 = 0.5 axis_2 = 0.5 / ( nellipses + 1 ) center_x = 0.0 center_y = - 1 + 2.0 / ( nellipses + 1.0 ) * ( i + 1 ) rotation = 0 ellipses . append ( [ value , axis_1 , axis_2 , center_x , center_y , rotation ] )   elif ndim == 3 :          for i in range ( nellipses ) :              if alternating :                  value = ( - 1.0 + 2.0 * ( i % 2 ) )  else :                  value = 1.0  axis_1 = axis_2 = 0.5 axis_3 = 0.5 / ( nellipses + 1 ) center_x = center_y = 0.0 center_z = - 1 + 2.0 / ( nellipses + 1.0 ) * ( i + 1 ) rotation_phi = rotation_theta = rotation_psi = 0 ellipses . append ( [ value , axis_1 , axis_2 , axis_3 , center_x , center_y , center_z , rotation_phi , rotation_theta , rotation_psi ] )   return ellipses  def indicate_proj_axis ( space , scale_structures = 0.5 ) :      if not 0 < scale_structures <= 1 :          raise ValueError ( <str> <str> . format ( scale_structures ) )  assert space . ndim in ( 2 , 3 ) shape = space . shape phan = np . zeros ( shape ) shape = np . array ( shape ) - 1 cen = np . round ( 0.5 * shape ) dx = np . floor ( scale_structures * 0.25 * shape ) dx [ dx == 0 ] = 1 ix0 = int ( ( cen - 3 * dx ) [ 0 ] ) if space . ndim == 2 :          ix , iy = ( cen - 1 * dx ) . astype ( int ) phan [ ix0 : ix , iy : - iy ] = 1  elif space . ndim == 3 :          ix , iy , iz = ( cen - 1 * dx ) . astype ( int ) phan [ ix0 : ix , iy : - iy , iz : - iz ] = 1  ix0 = int ( ( cen + 1 * dx ) [ 1 ] ) ix1 = int ( ( cen + 2 * dx ) [ 1 ] ) iy0 = int ( cen [ 1 ] ) if space . ndim == 2 :          phan [ ix0 : ix1 , iy0 : - iy ] = 1  elif space . ndim == 3 :          iz = int ( ( cen - dx ) [ 2 ] ) phan [ ix0 : ix1 , iy0 : - iy , iz : - iz ] = 1  ix0 = int ( ( cen + 2 * dx ) [ 1 ] ) ix1 = int ( ( cen + 3 * dx ) [ 1 ] ) iy1 = int ( cen [ 1 ] ) if space . ndim == 2 :          phan [ ix0 : ix1 , iy : iy1 ] = 1  elif space . ndim == 3 :          iz = int ( ( cen - dx ) [ 2 ] ) phan [ ix0 : ix1 , iy : iy1 , iz : - iz ] = 1  return space . element ( phan )  def _getshapes_2d ( center , max_radius , shape ) :      index_mean = shape * center index_radius = max_radius / 2.0 * np . array ( shape ) min_idx = np . maximum ( np . floor ( index_mean - index_radius ) , 0 ) . astype ( int ) max_idx = np . ceil ( index_mean + index_radius ) . astype ( int ) idx = [ slice ( minx , maxx ) for minx , maxx in zip ( min_idx , max_idx ) ] shapes = [ ( idx [ 0 ] , slice ( None ) ) , ( slice ( None ) , idx [ 1 ] ) ] return tuple ( idx ) , tuple ( shapes )  def _ellipse_phantom_2d ( space , ellipses ) :      p = np . zeros ( space . shape , dtype = space . dtype ) minp = space . grid . min_pt maxp = space . grid . max_pt grid_in = space . grid . meshgrid grid = [ ] for i in range ( 2 ) :          mean_i = ( minp [ i ] + maxp [ i ] ) / 2.0 diff_i = ( maxp [ i ] - minp [ i ] ) / 2.0 or 1.0 grid . append ( ( grid_in [ i ] - mean_i ) / diff_i )  for ellip in ellipses :          assert len ( ellip ) == 6 intensity = ellip [ 0 ] a_squared = ellip [ 1 ] ** 2 b_squared = ellip [ 2 ] ** 2 x0 = ellip [ 3 ] y0 = ellip [ 4 ] theta = ellip [ 5 ] scales = [ 1 / a_squared , 1 / b_squared ] center = ( np . array ( [ x0 , y0 ] ) + 1.0 ) / 2.0 if theta != 0 :              ctheta = np . cos ( theta ) stheta = np . sin ( theta ) mat = np . array ( [ [ ctheta , stheta ] , [ - stheta , ctheta ] ] ) max_radius = np . sqrt ( np . abs ( mat ) . dot ( [ a_squared , b_squared ] ) ) idx , shapes = _getshapes_2d ( center , max_radius , space . shape ) subgrid = [ g [ idi ] for g , idi in zip ( grid , shapes ) ] offset_points = [ vec * ( xi - x0i ) [ ... , None ] for xi , vec , x0i in zip ( subgrid , mat . T , [ x0 , y0 ] ) ] rotated = offset_points [ 0 ] + offset_points [ 1 ] np . square ( rotated , out = rotated ) radius = np . dot ( rotated , scales )  else :              max_radius = np . sqrt ( [ a_squared , b_squared ] ) idx , shapes = _getshapes_2d ( center , max_radius , space . shape ) subgrid = [ g [ idi ] for g , idi in zip ( grid , shapes ) ] squared_dist = [ ai * ( xi - x0i ) ** 2 for xi , ai , x0i in zip ( subgrid , scales , [ x0 , y0 ] ) ] radius = squared_dist [ 0 ] + squared_dist [ 1 ]  inside = radius <= 1 p [ idx ] [ inside ] += intensity  return space . element ( p )  def _getshapes_3d ( center , max_radius , shape ) :      index_mean = shape * center index_radius = max_radius / 2.0 * np . array ( shape ) min_idx = np . floor ( index_mean - index_radius ) . astype ( int ) min_idx = np . maximum ( min_idx , 0 ) max_idx = np . ceil ( index_mean + index_radius ) . astype ( int ) idx = [ slice ( minx , maxx ) for minx , maxx in zip ( min_idx , max_idx ) ] shapes = [ ( idx [ 0 ] , slice ( None ) , slice ( None ) ) , ( slice ( None ) , idx [ 1 ] , slice ( None ) ) , ( slice ( None ) , slice ( None ) , idx [ 2 ] ) ] return tuple ( idx ) , tuple ( shapes )  def _ellipsoid_phantom_3d ( space , ellipsoids ) :      p = np . zeros ( space . shape , dtype = space . dtype ) minp = space . grid . min_pt maxp = space . grid . max_pt grid_in = space . grid . meshgrid grid = [ ] for i in range ( 3 ) :          mean_i = ( minp [ i ] + maxp [ i ] ) / 2.0 diff_i = ( maxp [ i ] - minp [ i ] ) / 2.0 or 1.0 grid . append ( ( grid_in [ i ] - mean_i ) / diff_i )  for ellip in ellipsoids :          assert len ( ellip ) == 10 intensity = ellip [ 0 ] a_squared = ellip [ 1 ] ** 2 b_squared = ellip [ 2 ] ** 2 c_squared = ellip [ 3 ] ** 2 x0 = ellip [ 4 ] y0 = ellip [ 5 ] z0 = ellip [ 6 ] phi = ellip [ 7 ] theta = ellip [ 8 ] psi = ellip [ 9 ] scales = [ 1 / a_squared , 1 / b_squared , 1 / c_squared ] center = ( np . array ( [ x0 , y0 , z0 ] ) + 1.0 ) / 2.0 if any ( [ phi , theta , psi ] ) :              cphi = np . cos ( phi ) sphi = np . sin ( phi ) ctheta = np . cos ( theta ) stheta = np . sin ( theta ) cpsi = np . cos ( psi ) spsi = np . sin ( psi ) mat = np . array ( [ [ cpsi * cphi - ctheta * sphi * spsi , cpsi * sphi + ctheta * cphi * spsi , spsi * stheta ] , [ - spsi * cphi - ctheta * sphi * cpsi , - spsi * sphi + ctheta * cphi * cpsi , cpsi * stheta ] , [ stheta * sphi , - stheta * cphi , ctheta ] ] ) max_radius = np . sqrt ( np . abs ( mat ) . dot ( [ a_squared , b_squared , c_squared ] ) ) idx , shapes = _getshapes_3d ( center , max_radius , space . shape ) subgrid = [ g [ idi ] for g , idi in zip ( grid , shapes ) ] offset_points = [ vec * ( xi - x0i ) [ ... , None ] for xi , vec , x0i in zip ( subgrid , mat . T , [ x0 , y0 , z0 ] ) ] rotated = offset_points [ 0 ] + offset_points [ 1 ] + offset_points [ 2 ] np . square ( rotated , out = rotated ) radius = np . dot ( rotated , scales )  else :              max_radius = np . sqrt ( [ a_squared , b_squared , c_squared ] ) idx , shapes = _getshapes_3d ( center , max_radius , space . shape ) subgrid = [ g [ idi ] for g , idi in zip ( grid , shapes ) ] squared_dist = [ ai * ( xi - x0i ) ** 2 for xi , ai , x0i in zip ( subgrid , scales , [ x0 , y0 , z0 ] ) ] radius = squared_dist [ 0 ] + ( squared_dist [ 1 ] + squared_dist [ 2 ] )  inside = radius <= 1 p [ idx ] [ inside ] += intensity  return space . element ( p )  def ellipsoid_phantom ( space , ellipsoids , min_pt = None , max_pt = None ) :      if space . ndim == 2 :          _phantom = _ellipse_phantom_2d  elif space . ndim == 3 :          _phantom = _ellipsoid_phantom_3d  else :          raise ValueError ( <str> )  if min_pt is None and max_pt is None :          return _phantom ( space , ellipsoids )  else :          if min_pt is None :              snapped_min_pt = space . min_pt  else :              min_pt_cell = space . partition [ space . partition . index ( min_pt ) ] snapped_min_pt = min_pt_cell . min_pt  if max_pt is None :              snapped_max_pt = space . max_pt  else :              max_pt_cell = space . partition [ space . partition . index ( max_pt ) ] snapped_max_pt = max_pt_cell . max_pt for i in range ( space . ndim ) :                  if max_pt [ i ] in space . partition . cell_boundary_vecs [ i ] :                      snapped_max_pt [ i ] = max_pt [ i ]    tmp_space = uniform_discr_fromdiscr ( space , min_pt = snapped_min_pt , max_pt = snapped_max_pt , cell_sides = space . cell_sides ) tmp_phantom = _phantom ( tmp_space , ellipsoids ) offset = space . partition . index ( tmp_space . min_pt ) return space . element ( resize_array ( tmp_phantom , space . shape , offset ) )   def smooth_cuboid ( space , min_pt = None , max_pt = None , axis = 0 ) :      dom_min_pt = space . domain . min ( ) dom_max_pt = space . domain . max ( ) if min_pt is None :          min_pt = dom_min_pt * 0.75 + dom_max_pt * 0.25  if max_pt is None :          max_pt = dom_min_pt * 0.25 + dom_max_pt * 0.75  min_pt = np . atleast_1d ( min_pt ) max_pt = np . atleast_1d ( max_pt ) axis = np . array ( axis , dtype = int , ndmin = 1 ) if min_pt . shape != ( space . ndim , ) :          raise ValueError ( <str> <str> . format ( ( space . ndim , ) , min_pt . shape ) )  if max_pt . shape != ( space . ndim , ) :          raise ValueError ( <str> <str> . format ( ( space . ndim , ) , max_pt . shape ) )  sign = 0 for i , coord in enumerate ( space . meshgrid ) :          sign = sign | ( coord < min_pt [ i ] ) | ( coord > max_pt [ i ] )  values = 0 for i in axis :          coord = space . meshgrid [ i ] extent = ( dom_max_pt [ i ] - dom_min_pt [ i ] ) values = values + 2 * ( coord - dom_min_pt [ i ] ) / extent - 1  sign = ( 3 * sign - 2 ) / axis . size values = values * sign values = ( values - np . min ( values ) ) / ( np . max ( values ) - np . min ( values ) ) return space . element ( values )  def tgv_phantom ( space , edge_smoothing = 0.2 ) :      if space . ndim != 2 :          raise ValueError ( <str> <str> . format ( space . ndim ) )  y , x = space . meshgrid scale = edge_smoothing / np . min ( space . shape ) def sigmoid ( val ) :          if edge_smoothing != 0 :              val = val / scale return 1 / ( 1 + np . exp ( - val ) )  else :              return ( val > 0 ) . astype ( val . dtype )   x = ( x - np . min ( x ) ) / ( np . max ( x ) - np . min ( x ) ) y = ( y - np . min ( y ) ) / ( np . max ( y ) - np . min ( y ) ) values = - ( x + y ) / 2 indicator = np . ones ( space . shape ) indicator *= sigmoid ( - ( 0.015199034981905914 * x - y + 0.13896260554885403 ) ) indicator *= sigmoid ( ( 0.3333333333333323 * y - x + 0.598958333333334 ) ) indicator *= sigmoid ( ( - 2.4193548387096726 * y - x + 2.684979838709672 ) ) values += indicator * 2 * ( x + y - 1 ) x_c = x - 0.71606842360499456 y_c = y - 0.18357884949910641 width = 0.55677657235995637 height = 0.37279391542283741 phi = 0.62911754900697558 x_c_rot = ( np . cos ( phi ) * x_c - np . sin ( phi ) * y_c ) / width y_c_rot = ( np . sin ( phi ) * x_c + np . cos ( phi ) * y_c ) / height indicator = sigmoid ( np . sqrt ( x_c_rot ** 2 + y_c_rot ** 2 ) - 1 ) values = indicator * values + 1.5 * ( 1 - indicator ) * ( - x - 2 * y + 0.6 ) values = ( values - np . min ( values ) ) / ( np . max ( values ) - np . min ( values ) ) return space . element ( values )  if __name__ == <str> :      import odl space = odl . uniform_discr ( - 1 , 1 , 300 ) cuboid ( space ) . show ( <str> ) space = odl . uniform_discr ( [ - 1 , - 1 ] , [ 1 , 1 ] , [ 300 , 300 ] ) cuboid ( space ) . show ( <str> ) smooth_cuboid ( space ) . show ( <str> ) smooth_cuboid ( space , axis = [ 0 , 1 ] ) . show ( <str> ) tgv_phantom ( space ) . show ( <str> ) space = odl . uniform_discr ( [ - 1 , - 1 , - 1 ] , [ 1 , 1 , 1 ] , [ 300 , 300 , 300 ] ) cuboid ( space ) . show ( <str> ) indicate_proj_axis ( space ) . show ( <str> ) space = odl . uniform_discr ( [ - 1 , - 1 ] , [ 1 , 1 ] , [ 300 , 300 ] ) ellipses = [ [ 1.0 , 1.0 , 1.0 , 0.0 , 0.0 , 0.0 ] , [ 1.0 , 0.6 , 0.6 , 0.0 , 0.0 , 0.0 ] ] ellipsoid_phantom ( space , ellipses ) . show ( <str> ) space = odl . uniform_discr ( [ - 1 , - 1 , - 1 ] , [ 1 , 1 , 1 ] , [ 300 , 300 , 300 ] ) ellipsoids = [ [ 1.0 , 1.0 , 1.0 , 1.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ] , [ 1.0 , 0.6 , 0.6 , 0.6 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ] ] ellipsoid_phantom ( space , ellipsoids ) . show ( <str> ) space = odl . uniform_discr ( [ - 1 , - 1 ] , [ 1 , 1 ] , [ 300 , 300 ] ) defrise ( space ) . show ( <str> ) space = odl . uniform_discr ( [ - 1 , - 1 , - 1 ] , [ 1 , 1 , 1 ] , [ 300 , 300 , 300 ] ) defrise ( space ) . show ( <str> , coords = [ 0 , None , None ] ) from odl . util . testutils import run_doctests run_doctests ( )   