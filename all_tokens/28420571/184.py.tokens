import numpy as np import torch from torch import nn import odl from odl . contrib import torch as odl_torch matrix = np . array ( [ [ 1 , 0 , 0 ] , [ 0 , 1 , 1 ] ] , dtype = <str> ) odl_op = odl . MatrixOperator ( matrix ) op_layer = odl_torch . OperatorModule ( odl_op ) inp = torch . ones ( ( 1 , 3 ) ) print ( <str> ) print ( op_layer ( inp ) ) print ( ) inp = torch . ones ( ( 1 , 1 , 3 ) ) print ( <str> ) print ( op_layer ( inp ) ) print ( ) layer_before = nn . Linear ( 3 , 3 ) layer_after = nn . Linear ( 2 , 2 ) model1 = nn . Sequential ( layer_before , op_layer , layer_after ) print ( <str> ) print ( model1 ) print ( ) inp = torch . ones ( ( 1 , 3 ) ) print ( <str> ) print ( model1 ( inp ) ) layer_before = nn . Conv1d ( 1 , 2 , 2 ) layer_after = nn . Conv1d ( 2 , 1 , 2 ) model2 = nn . Sequential ( layer_before , op_layer , layer_after ) print ( <str> ) print ( model2 ) print ( ) inp = torch . ones ( ( 1 , 1 , 4 ) ) print ( <str> ) print ( model2 ( inp ) ) loss_func = nn . MSELoss ( ) model = model1 inp = torch . ones ( ( 1 , 3 ) , requires_grad = True ) target = torch . zeros ( ( 1 , 2 ) ) loss = loss_func ( model ( inp ) , target ) print ( <str> , loss . item ( ) ) print ( ) loss . backward ( ) print ( <str> ) for p in model . named_parameters ( ) :      name , value = p print ( <str> . format ( name ) ) print ( value ) print ( <str> ) print ( value . grad )   