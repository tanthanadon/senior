import numpy as np import odl space = odl . uniform_discr ( min_pt = [ - 20 , - 20 ] , max_pt = [ 20 , 20 ] , shape = [ 100 , 100 ] , dtype = <str> ) angle_partition = odl . uniform_partition ( 0 , np . pi , 300 ) detector_partition = odl . uniform_partition ( - 30 , 30 , 300 ) geometry = odl . tomo . Parallel2dGeometry ( angle_partition , detector_partition ) ray_trafo = odl . tomo . RayTransform ( space , geometry ) forward_op = odl . DiagonalOperator ( ray_trafo , 2 ) ellipses = odl . phantom . shepp_logan_ellipsoids ( space . ndim , modified = True ) phantom = forward_op . domain . element ( [ odl . phantom . ellipsoid_phantom ( space , ellipses [ : 2 ] ) , odl . phantom . ellipsoid_phantom ( space , ellipses ) ] ) phantom . show ( <str> ) data = forward_op ( phantom ) data [ 1 ] += odl . phantom . white_noise ( forward_op . range [ 1 ] ) * np . mean ( data [ 1 ] ) data . show ( <str> ) gradient = odl . Gradient ( ray_trafo . domain ) pgradient = odl . DiagonalOperator ( gradient , 2 ) l2err1 = odl . solvers . L2NormSquared ( ray_trafo . range ) . translated ( data [ 0 ] ) l2err2 = odl . solvers . L2NormSquared ( ray_trafo . range ) . translated ( data [ 1 ] ) l2err = odl . solvers . SeparableSum ( l2err1 , 0.1 * l2err2 ) nuc_norm = odl . solvers . NuclearNorm ( pgradient . range , singular_vector_exp = 1 ) lam = 0.1 lin_ops = [ forward_op , pgradient ] g = [ l2err , lam * nuc_norm ] f = odl . solvers . IndicatorBox ( forward_op . domain , 0 , 1 ) func = f + l2err * forward_op + lam * nuc_norm * pgradient callback = ( odl . solvers . CallbackShow ( ) & odl . solvers . CallbackPrint ( func = func ) ) x = forward_op . domain . zero ( ) odl . solvers . douglas_rachford_pd ( x , f , g , lin_ops , tau = 0.5 , sigma = [ 0.01 , 0.1 ] , niter = 100 , callback = callback ) x . show ( <str> , force_show = True )  