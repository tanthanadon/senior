from __future__ import print_function , division , absolute_import import numpy as np from odl . discr import uniform_partition from odl . tomo . geometry . detector import Flat1dDetector , Flat2dDetector from odl . tomo . geometry . geometry import ( DivergentBeamGeometry , AxisOrientedGeometry ) from odl . tomo . util . utility import ( euler_matrix , transform_system , is_inside_bounds ) from odl . util import signature_string , indent , array_str __all__ = ( <str> , <str> , <str> , <str> ) class FanFlatGeometry ( DivergentBeamGeometry ) :      _default_config = dict ( src_to_det_init = ( 0 , 1 ) , det_axis_init = ( 1 , 0 ) ) def __init__ ( self , apart , dpart , src_radius , det_radius , src_to_det_init = ( 0 , 1 ) , ** kwargs ) :          default_src_to_det_init = self . _default_config [ <str> ] default_det_axis_init = self . _default_config [ <str> ] det_axis_init = kwargs . pop ( <str> , None ) if src_to_det_init is not None :              self . _src_to_det_init_arg = np . asarray ( src_to_det_init , dtype = float )  else :              self . _src_to_det_init_arg = None  if det_axis_init is not None :              self . _det_axis_init_arg = np . asarray ( det_axis_init , dtype = float )  else :              self . _det_axis_init_arg = None  vecs_to_transform = [ ] if det_axis_init is None :              vecs_to_transform . append ( default_det_axis_init )  transformed_vecs = transform_system ( src_to_det_init , default_src_to_det_init , vecs_to_transform ) transformed_vecs = list ( transformed_vecs ) src_to_det_init = transformed_vecs . pop ( 0 ) if det_axis_init is None :              det_axis_init = transformed_vecs . pop ( 0 )  assert transformed_vecs == [ ] if np . array_equiv ( src_to_det_init , 0 ) :              raise ValueError ( <str> )  else :              src_to_det_init /= np . linalg . norm ( src_to_det_init )  self . __src_to_det_init = src_to_det_init check_bounds = kwargs . get ( <str> , True ) detector = Flat1dDetector ( dpart , axis = det_axis_init , check_bounds = check_bounds ) translation = kwargs . pop ( <str> , None ) super ( FanFlatGeometry , self ) . __init__ ( ndim = 2 , motion_part = apart , detector = detector , translation = translation , ** kwargs ) self . __src_radius = float ( src_radius ) if self . src_radius < 0 :              raise ValueError ( <str> <str> . format ( src_radius ) )  self . __det_radius = float ( det_radius ) if self . det_radius < 0 :              raise ValueError ( <str> <str> . format ( det_radius ) )  if self . src_radius == 0 and self . det_radius == 0 :              raise ValueError ( <str> <str> )  if self . motion_partition . ndim != 1 :              raise ValueError ( <str> <str> . format ( self . motion_partition . ndim ) )   @ classmethod def frommatrix ( cls , apart , dpart , src_radius , det_radius , init_matrix , ** kwargs ) :          init_matrix = np . asarray ( init_matrix , dtype = float ) if init_matrix . shape not in ( ( 2 , 2 ) , ( 2 , 3 ) ) :              raise ValueError ( <str> <str> <str> . format ( init_matrix . shape ) )  trafo_matrix = init_matrix [ : , : 2 ] translation = init_matrix [ : , 2 : ] . squeeze ( ) default_src_to_det_init = cls . _default_config [ <str> ] default_det_axis_init = cls . _default_config [ <str> ] vecs_to_transform = [ default_det_axis_init ] transformed_vecs = transform_system ( default_src_to_det_init , None , vecs_to_transform , matrix = trafo_matrix ) src_to_det , det_axis = transformed_vecs if translation . size != 0 :              kwargs [ <str> ] = translation  return cls ( apart , dpart , src_radius , det_radius , src_to_det , det_axis_init = det_axis , ** kwargs )  @ property def src_radius ( self ) :          return self . __src_radius  @ property def det_radius ( self ) :          return self . __det_radius  @ property def src_to_det_init ( self ) :          return self . __src_to_det_init  @ property def det_axis_init ( self ) :          return self . detector . axis  def det_axis ( self , angle ) :          return self . rotation_matrix ( angle ) . dot ( self . det_axis_init )  @ property def angles ( self ) :          return self . motion_grid . coord_vectors [ 0 ]  def src_position ( self , angle ) :          squeeze_out = ( np . shape ( angle ) == ( ) ) angle = np . array ( angle , dtype = float , copy = False , ndmin = 1 ) center_to_src_init = - self . src_radius * self . src_to_det_init pos_vec = ( self . translation [ None , : ] + self . rotation_matrix ( angle ) . dot ( center_to_src_init ) ) if squeeze_out :              pos_vec = pos_vec . squeeze ( )  return pos_vec  def det_refpoint ( self , angle ) :          squeeze_out = ( np . shape ( angle ) == ( ) ) angle = np . array ( angle , dtype = float , copy = False , ndmin = 1 ) center_to_det_init = self . det_radius * self . src_to_det_init refpt = ( self . translation [ None , : ] + self . rotation_matrix ( angle ) . dot ( center_to_det_init ) ) if squeeze_out :              refpt = refpt . squeeze ( )  return refpt  def rotation_matrix ( self , angle ) :          squeeze_out = ( np . shape ( angle ) == ( ) ) angle = np . array ( angle , dtype = float , copy = False , ndmin = 1 ) if ( self . check_bounds and not is_inside_bounds ( angle , self . motion_params ) ) :              raise ValueError ( <str> <str> . format ( angle , self . motion_params ) )  matrix = euler_matrix ( angle ) if squeeze_out :              matrix = matrix . squeeze ( )  return matrix  def __repr__ ( self ) :          posargs = [ self . motion_partition , self . det_partition ] optargs = [ ( <str> , self . src_radius , - 1 ) , ( <str> , self . det_radius , - 1 ) ] if not np . allclose ( self . src_to_det_init , self . _default_config [ <str> ] ) :              optargs . append ( [ <str> , array_str ( self . src_to_det_init ) , <str> ] )  if self . _det_axis_init_arg is not None :              optargs . append ( [ <str> , array_str ( self . _det_axis_init_arg ) , <str> ] )  if not np . array_equal ( self . translation , ( 0 , 0 ) ) :              optargs . append ( [ <str> , array_str ( self . translation ) , <str> ] )  sig_str = signature_string ( posargs , optargs , sep = <str> ) return <str> . format ( self . __class__ . __name__ , indent ( sig_str ) )  def __getitem__ ( self , indices ) :          part = self . partition [ indices ] apart = part . byaxis [ 0 ] dpart = part . byaxis [ 1 ] return FanFlatGeometry ( apart , dpart , src_radius = self . src_radius , det_radius = self . det_radius , src_to_det_init = self . src_to_det_init , det_axis_init = self . _det_axis_init_arg , translation = self . translation )   class ConeFlatGeometry ( DivergentBeamGeometry , AxisOrientedGeometry ) :      _default_config = dict ( axis = ( 0 , 0 , 1 ) , src_to_det_init = ( 0 , 1 , 0 ) , det_axes_init = ( ( 1 , 0 , 0 ) , ( 0 , 0 , 1 ) ) ) def __init__ ( self , apart , dpart , src_radius , det_radius , pitch = 0 , axis = ( 0 , 0 , 1 ) , ** kwargs ) :          default_axis = self . _default_config [ <str> ] default_src_to_det_init = self . _default_config [ <str> ] default_det_axes_init = self . _default_config [ <str> ] src_to_det_init = kwargs . pop ( <str> , None ) det_axes_init = kwargs . pop ( <str> , None ) if src_to_det_init is not None :              self . _src_to_det_init_arg = np . asarray ( src_to_det_init , dtype = float )  else :              self . _src_to_det_init_arg = None  if det_axes_init is not None :              self . _det_axes_init_arg = tuple ( np . asarray ( a , dtype = float ) for a in det_axes_init )  else :              self . _det_axes_init_arg = None  vecs_to_transform = [ ] if src_to_det_init is None :              vecs_to_transform . append ( default_src_to_det_init )  if det_axes_init is None :              vecs_to_transform . extend ( default_det_axes_init )  transformed_vecs = transform_system ( axis , default_axis , vecs_to_transform ) transformed_vecs = list ( transformed_vecs ) axis = transformed_vecs . pop ( 0 ) if src_to_det_init is None :              src_to_det_init = transformed_vecs . pop ( 0 )  if det_axes_init is None :              det_axes_init = ( transformed_vecs . pop ( 0 ) , transformed_vecs . pop ( 0 ) )  assert transformed_vecs == [ ] if np . linalg . norm ( src_to_det_init ) == 0 :              raise ValueError ( <str> )  else :              src_to_det_init /= np . linalg . norm ( src_to_det_init )  self . __pitch = float ( pitch ) self . __offset_along_axis = float ( kwargs . pop ( <str> , 0 ) ) self . __src_radius = float ( src_radius ) self . __src_to_det_init = src_to_det_init AxisOrientedGeometry . __init__ ( self , axis ) check_bounds = kwargs . get ( <str> , True ) detector = Flat2dDetector ( dpart , axes = det_axes_init , check_bounds = check_bounds ) super ( ConeFlatGeometry , self ) . __init__ ( ndim = 3 , motion_part = apart , detector = detector , ** kwargs ) if self . src_radius < 0 :              raise ValueError ( <str> <str> . format ( src_radius ) )  self . __det_radius = float ( det_radius ) if self . det_radius < 0 :              raise ValueError ( <str> <str> . format ( det_radius ) )  if self . src_radius == 0 and self . det_radius == 0 :              raise ValueError ( <str> <str> )  if self . motion_partition . ndim != 1 :              raise ValueError ( <str> <str> . format ( self . motion_partition . ndim ) )   @ classmethod def frommatrix ( cls , apart , dpart , src_radius , det_radius , init_matrix , pitch = 0 , ** kwargs ) :          for key in ( <str> , <str> , <str> , <str> ) :              if key in kwargs :                  raise TypeError ( <str> <str> . format ( key ) )   init_matrix = np . asarray ( init_matrix , dtype = float ) if init_matrix . shape not in ( ( 3 , 3 ) , ( 3 , 4 ) ) :              raise ValueError ( <str> <str> <str> . format ( init_matrix . shape ) )  trafo_matrix = init_matrix [ : , : 3 ] translation = init_matrix [ : , 3 : ] . squeeze ( ) default_axis = cls . _default_config [ <str> ] default_src_to_det_init = cls . _default_config [ <str> ] default_det_axes_init = cls . _default_config [ <str> ] vecs_to_transform = ( default_src_to_det_init , ) + default_det_axes_init transformed_vecs = transform_system ( default_axis , None , vecs_to_transform , matrix = trafo_matrix ) axis , src_to_det , det_axis_0 , det_axis_1 = transformed_vecs if translation . size == 0 :              pass  else :              kwargs [ <str> ] = translation  return cls ( apart , dpart , src_radius , det_radius , pitch , axis , src_to_det_init = src_to_det , det_axes_init = [ det_axis_0 , det_axis_1 ] , ** kwargs )  @ property def src_radius ( self ) :          return self . __src_radius  @ property def det_radius ( self ) :          return self . __det_radius  @ property def pitch ( self ) :          return self . __pitch  @ property def src_to_det_init ( self ) :          return self . __src_to_det_init  @ property def det_axes_init ( self ) :          return self . detector . axes  @ property def offset_along_axis ( self ) :          return self . __offset_along_axis  @ property def angles ( self ) :          return self . motion_grid . coord_vectors [ 0 ]  def det_axes ( self , angle ) :          axes = self . rotation_matrix ( angle ) . dot ( self . det_axes_init . T ) return np . rollaxis ( axes , - 1 , - 2 )  def det_refpoint ( self , angle ) :          squeeze_out = ( np . shape ( angle ) == ( ) ) angle = np . array ( angle , dtype = float , copy = False , ndmin = 1 ) rot_matrix = self . rotation_matrix ( angle ) extra_dims = angle . ndim center_to_det_init = self . det_radius * self . src_to_det_init circle_component = rot_matrix . dot ( center_to_det_init ) shift_along_axis = ( self . offset_along_axis + self . pitch * angle / ( 2 * np . pi ) ) pitch_component = np . multiply . outer ( shift_along_axis , self . axis ) transl_slc = ( None , ) * extra_dims + ( slice ( None ) , ) refpt = ( self . translation [ transl_slc ] + circle_component + pitch_component ) if squeeze_out :              refpt = refpt . squeeze ( )  return refpt  def src_position ( self , angle ) :          squeeze_out = ( np . shape ( angle ) == ( ) ) angle = np . array ( angle , dtype = float , copy = False , ndmin = 1 ) rot_matrix = self . rotation_matrix ( angle ) extra_dims = angle . ndim center_to_src_init = - self . src_radius * self . src_to_det_init circle_component = rot_matrix . dot ( center_to_src_init ) shift_along_axis = ( self . offset_along_axis + self . pitch * angle / ( 2 * np . pi ) ) pitch_component = np . multiply . outer ( shift_along_axis , self . axis ) transl_slc = ( None , ) * extra_dims + ( slice ( None ) , ) refpt = ( self . translation [ transl_slc ] + circle_component + pitch_component ) if squeeze_out :              refpt = refpt . squeeze ( )  return refpt  def __repr__ ( self ) :          posargs = [ self . motion_partition , self . det_partition ] optargs = [ ( <str> , self . src_radius , - 1 ) , ( <str> , self . det_radius , - 1 ) , ( <str> , self . pitch , 0 ) ] if not np . allclose ( self . axis , self . _default_config [ <str> ] ) :              optargs . append ( [ <str> , array_str ( self . axis ) , <str> ] )  optargs . append ( [ <str> , self . offset_along_axis , 0 ] ) if self . _src_to_det_init_arg is not None :              optargs . append ( [ <str> , array_str ( self . _src_to_det_init_arg ) , None ] )  if self . _det_axes_init_arg is not None :              optargs . append ( [ <str> , tuple ( array_str ( a ) for a in self . _det_axes_init_arg ) , None ] )  if not np . array_equal ( self . translation , ( 0 , 0 , 0 ) ) :              optargs . append ( [ <str> , array_str ( self . translation ) , <str> ] )  sig_str = signature_string ( posargs , optargs , sep = <str> ) return <str> . format ( self . __class__ . __name__ , indent ( sig_str ) )  def __getitem__ ( self , indices ) :          part = self . partition [ indices ] apart = part . byaxis [ 0 ] dpart = part . byaxis [ 1 : ] return ConeFlatGeometry ( apart , dpart , src_radius = self . src_radius , det_radius = self . det_radius , pitch = self . pitch , axis = self . axis , offset_along_axis = self . offset_along_axis , src_to_det_init = self . _src_to_det_init_arg , det_axes_init = self . _det_axes_init_arg , translation = self . translation )  rotation_matrix = AxisOrientedGeometry . rotation_matrix  def cone_beam_geometry ( space , src_radius , det_radius , num_angles = None , short_scan = False , det_shape = None ) :      corners = space . domain . corners ( ) [ : , : 2 ] rho = np . max ( np . linalg . norm ( corners , axis = 1 ) ) min_side = min ( space . partition . cell_sides [ : 2 ] ) omega = np . pi / min_side rs = float ( src_radius ) if ( rs <= rho ) :          raise ValueError ( <str> <str> )  rd = float ( det_radius ) r = src_radius + det_radius w = 2 * rho * ( rs + rd ) / rs rb = np . hypot ( r , w / 2 ) num_px_horiz = 2 * int ( np . ceil ( w * omega * r / ( 2 * np . pi * rb ) ) ) + 1 if space . ndim == 2 :          det_min_pt = - w / 2 det_max_pt = w / 2 if det_shape is None :              det_shape = num_px_horiz   elif space . ndim == 3 :          dist = rs - rho half_cone_angle = max ( np . arctan ( abs ( space . partition . min_pt [ 2 ] ) / dist ) , np . arctan ( abs ( space . partition . max_pt [ 2 ] ) / dist ) ) h = 2 * np . sin ( half_cone_angle ) * ( rs + rd ) min_mag = ( rs + rd ) / ( rs + rho ) delta_h = min_mag * space . cell_sides [ 2 ] num_px_vert = int ( np . ceil ( h / delta_h ) ) h = num_px_vert * delta_h det_min_pt = [ - w / 2 , - h / 2 ] det_max_pt = [ w / 2 , h / 2 ] if det_shape is None :              det_shape = [ num_px_horiz , num_px_vert ]   fan_angle = 2 * np . arctan ( rho / rs ) if short_scan :          max_angle = min ( np . pi + fan_angle , 2 * np . pi )  else :          max_angle = 2 * np . pi  if num_angles is None :          num_angles = int ( np . ceil ( max_angle * omega * rho / np . pi * r / ( r + rho ) ) )  angle_partition = uniform_partition ( 0 , max_angle , num_angles ) det_partition = uniform_partition ( det_min_pt , det_max_pt , det_shape ) if space . ndim == 2 :          return FanFlatGeometry ( angle_partition , det_partition , src_radius , det_radius )  elif space . ndim == 3 :          return ConeFlatGeometry ( angle_partition , det_partition , src_radius , det_radius )  else :          raise ValueError ( <str> )   def helical_geometry ( space , src_radius , det_radius , num_turns , n_pi = 1 , num_angles = None , det_shape = None ) :      corners = space . domain . corners ( ) [ : , : 2 ] rho = np . max ( np . linalg . norm ( corners , axis = 1 ) ) offset_along_axis = space . partition . min_pt [ 2 ] pitch = space . partition . extent [ 2 ] / num_turns min_side = min ( space . partition . cell_sides [ : 2 ] ) omega = np . pi / min_side rs = float ( src_radius ) if ( rs <= rho ) :          raise ValueError ( <str> <str> )  rd = float ( det_radius ) r = rs + rd w = 2 * rho * ( rs + rd ) / rs rb = np . hypot ( r , w / 2 ) num_px_horiz = 2 * int ( np . ceil ( w * omega * r / ( 2 * np . pi * rb ) ) ) + 1 h_axis = ( pitch / ( 2 * np . pi ) * ( 1 + ( - rho / src_radius ) ** 2 ) * ( n_pi * np . pi / 2.0 - np . arctan ( - rho / src_radius ) ) ) h = 2 * h_axis * ( rs + rd ) / rs min_mag = r / rs dh = 0.5 * space . partition . cell_sides [ 2 ] * min_mag num_px_vert = int ( np . ceil ( h / dh ) ) det_min_pt = [ - w / 2 , - h / 2 ] det_max_pt = [ w / 2 , h / 2 ] if det_shape is None :          det_shape = [ num_px_horiz , num_px_vert ]  max_angle = 2 * np . pi * num_turns if num_angles is None :          num_angles = int ( np . ceil ( max_angle * omega * rho / np . pi * r / ( r + rho ) ) )  angle_partition = uniform_partition ( 0 , max_angle , num_angles ) det_partition = uniform_partition ( det_min_pt , det_max_pt , det_shape ) return ConeFlatGeometry ( angle_partition , det_partition , src_radius , det_radius , offset_along_axis = offset_along_axis , pitch = pitch )  if __name__ == <str> :      from odl . util . testutils import run_doctests run_doctests ( )   