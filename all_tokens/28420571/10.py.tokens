from __future__ import print_function , division , absolute_import from copy import copy import numpy as np from odl . operator . operator import Operator from odl . set import LinearSpace , Field , RealNumbers , ComplexNumbers from odl . set . space import LinearSpaceElement from odl . space import ProductSpace __all__ = ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) class ScalingOperator ( Operator ) :      def __init__ ( self , domain , scalar ) :          if not isinstance ( domain , ( LinearSpace , Field ) ) :              raise TypeError ( <str> <str> . format ( domain ) )  super ( ScalingOperator , self ) . __init__ ( domain , domain , linear = True ) self . __scalar = domain . field . element ( scalar )  @ property def scalar ( self ) :          return self . __scalar  def _call ( self , x , out = None ) :          if out is None :              out = self . scalar * x  else :              out . lincomb ( self . scalar , x )  return out  @ property def inverse ( self ) :          if self . scalar == 0.0 :              raise ZeroDivisionError ( <str> <str> )  return ScalingOperator ( self . domain , 1.0 / self . scalar )  @ property def adjoint ( self ) :          if complex ( self . scalar ) . imag == 0.0 :              return self  else :              return ScalingOperator ( self . domain , self . scalar . conjugate ( ) )   def norm ( self , estimate = False , ** kwargs ) :          return np . abs ( self . scalar )  def __repr__ ( self ) :          return <str> . format ( self . __class__ . __name__ , self . domain , self . scalar )  def __str__ ( self ) :          return <str> . format ( self . scalar )   class IdentityOperator ( ScalingOperator ) :      def __init__ ( self , space ) :          super ( IdentityOperator , self ) . __init__ ( space , 1 )  def __repr__ ( self ) :          return <str> . format ( self . __class__ . __name__ , self . domain )  def __str__ ( self ) :          return <str>   class LinCombOperator ( Operator ) :      def __init__ ( self , space , a , b ) :          domain = ProductSpace ( space , space ) super ( LinCombOperator , self ) . __init__ ( domain , space , linear = True ) self . a = a self . b = b  def _call ( self , x , out = None ) :          if out is None :              out = self . range . element ( )  out . lincomb ( self . a , x [ 0 ] , self . b , x [ 1 ] ) return out  def __repr__ ( self ) :          return <str> . format ( self . __class__ . __name__ , self . range , self . a , self . b )  def __str__ ( self ) :          return <str> . format ( self . a , self . b )   class MultiplyOperator ( Operator ) :      def __init__ ( self , multiplicand , domain = None , range = None ) :          if domain is None :              domain = multiplicand . space  if range is None :              range = multiplicand . space  super ( MultiplyOperator , self ) . __init__ ( domain , range , linear = True ) self . __multiplicand = multiplicand self . __domain_is_field = isinstance ( domain , Field ) self . __range_is_field = isinstance ( range , Field )  @ property def multiplicand ( self ) :          return self . __multiplicand  def _call ( self , x , out = None ) :          if out is None :              return x * self . multiplicand  elif not self . __range_is_field :              if self . __domain_is_field :                  out . lincomb ( x , self . multiplicand )  else :                  out . assign ( self . multiplicand * x )   else :              raise ValueError ( <str> )   @ property def adjoint ( self ) :          if self . __domain_is_field :              if isinstance ( self . domain , RealNumbers ) :                  return InnerProductOperator ( self . multiplicand )  elif isinstance ( self . domain , ComplexNumbers ) :                  return InnerProductOperator ( self . multiplicand . conjugate ( ) )  else :                  raise NotImplemented ( <str> <str> . format ( self . domain ) )   elif self . domain . is_complex :              return MultiplyOperator ( np . conj ( self . multiplicand ) , domain = self . range , range = self . domain )  else :              return MultiplyOperator ( self . multiplicand , domain = self . range , range = self . domain )   def __repr__ ( self ) :          return <str> . format ( self . __class__ . __name__ , self . multiplicand )  def __str__ ( self ) :          return <str> . format ( self . y )   class PowerOperator ( Operator ) :      def __init__ ( self , domain , exponent ) :          super ( PowerOperator , self ) . __init__ ( domain , domain , linear = ( exponent == 1 ) ) self . __exponent = float ( exponent ) self . __domain_is_field = isinstance ( domain , Field )  @ property def exponent ( self ) :          return self . __exponent  def _call ( self , x , out = None ) :          if out is None :              return x ** self . exponent  elif self . __domain_is_field :              raise ValueError ( <str> )  else :              out . assign ( x ) out **= self . exponent   def derivative ( self , point ) :          return self . exponent * MultiplyOperator ( point ** ( self . exponent - 1 ) , domain = self . domain , range = self . range )  def __repr__ ( self ) :          return <str> . format ( self . __class__ . __name__ , self . domain , self . exponent )  def __str__ ( self ) :          return <str> . format ( self . exponent )   class InnerProductOperator ( Operator ) :      def __init__ ( self , vector ) :          super ( InnerProductOperator , self ) . __init__ ( vector . space , vector . space . field , linear = True ) self . __vector = vector  @ property def vector ( self ) :          return self . __vector  def _call ( self , x ) :          return x . inner ( self . vector )  @ property def adjoint ( self ) :          return MultiplyOperator ( self . vector , self . vector . space . field )  @ property def T ( self ) :          return self . vector  def __repr__ ( self ) :          return <str> . format ( self . __class__ . __name__ , self . vector )  def __str__ ( self ) :          return <str> . format ( self . vector )   class NormOperator ( Operator ) :      def __init__ ( self , space ) :          super ( NormOperator , self ) . __init__ ( space , RealNumbers ( ) , linear = False )  def _call ( self , x ) :          return x . norm ( )  def derivative ( self , point ) :          point = self . domain . element ( point ) norm = point . norm ( ) if norm == 0 :              raise ValueError ( <str> )  return InnerProductOperator ( point / norm )  def __repr__ ( self ) :          return <str> . format ( self . __class__ . __name__ , self . domain )  def __str__ ( self ) :          return <str> . format ( self . __class__ . __name__ , self . domain )   class DistOperator ( Operator ) :      def __init__ ( self , vector ) :          super ( DistOperator , self ) . __init__ ( vector . space , RealNumbers ( ) , linear = False ) self . __vector = vector  @ property def vector ( self ) :          return self . __vector  def _call ( self , x ) :          return self . vector . dist ( x )  def derivative ( self , point ) :          point = self . domain . element ( point ) diff = point - self . vector dist = self . vector . dist ( point ) if dist == 0 :              raise ValueError ( <str> <str> . format ( self . vector ) )  return InnerProductOperator ( diff / dist )  def __repr__ ( self ) :          return <str> . format ( self . __class__ . __name__ , self . vector )  def __str__ ( self ) :          return <str> . format ( self . __class__ . __name__ , self . vector )   class ConstantOperator ( Operator ) :      def __init__ ( self , constant , domain = None , range = None ) :          if ( ( domain is None or range is None ) and not isinstance ( constant , LinearSpaceElement ) ) :              raise TypeError ( <str> <str> <str> . format ( constant ) )  if domain is None :              domain = constant . space  if range is None :              range = constant . space  self . __constant = range . element ( constant ) linear = self . constant . norm ( ) == 0 super ( ConstantOperator , self ) . __init__ ( domain , range , linear = linear )  @ property def constant ( self ) :          return self . __constant  def _call ( self , x , out = None ) :          if out is None :              return self . range . element ( copy ( self . constant ) )  else :              out . assign ( self . constant )   @ property def adjoint ( self ) :           def derivative ( self , point ) :          return ZeroOperator ( domain = self . domain , range = self . range )  def __repr__ ( self ) :          return <str> . format ( self . __class__ . __name__ , self . constant )  def __str__ ( self ) :          return <str> . format ( self . constant )   class ZeroOperator ( Operator ) :      def __init__ ( self , domain , range = None ) :          if range is None :              range = domain  super ( ZeroOperator , self ) . __init__ ( domain , range , linear = True )  def _call ( self , x , out = None ) :          if self . domain == self . range :              if out is None :                  out = 0 * x  else :                  out . lincomb ( 0 , x )   else :              result = self . range . zero ( ) if out is None :                  out = result  else :                  out . assign ( result )   return out  @ property def adjoint ( self ) :          return ZeroOperator ( domain = self . range , range = self . domain )  def __repr__ ( self ) :          return <str> . format ( self . __class__ . __name__ , self . domain )  def __str__ ( self ) :          return <str>   class RealPart ( Operator ) :      def __init__ ( self , space ) :          real_space = space . real_space self . space_is_real = ( space == real_space ) linear = True super ( RealPart , self ) . __init__ ( space , real_space , linear = linear )  def _call ( self , x ) :          return x . real  def derivative ( self , x ) :          <str> return self  @ property def inverse ( self ) :          if self . space_is_real :              return self  else :              return ComplexEmbedding ( self . domain , scalar = 1 )   @ property def adjoint ( self ) :          if self . space_is_real :              return self  else :              return ComplexEmbedding ( self . domain , scalar = 1 )    class ImagPart ( Operator ) :      def __init__ ( self , space ) :          real_space = space . real_space self . space_is_real = ( space == real_space ) linear = True super ( ImagPart , self ) . __init__ ( space , real_space , linear = linear )  def _call ( self , x ) :          return x . imag  def derivative ( self , x ) :          <str> return self  @ property def inverse ( self ) :          if self . space_is_real :              return ZeroOperator ( self . domain )  else :              return ComplexEmbedding ( self . domain , scalar = 1j )   @ property def adjoint ( self ) :          if self . space_is_real :              return ZeroOperator ( self . domain )  else :              return ComplexEmbedding ( self . domain , scalar = 1j )    class ComplexEmbedding ( Operator ) :      def __init__ ( self , space , scalar = 1.0 ) :          complex_space = space . complex_space self . scalar = complex_space . field . element ( scalar ) super ( ComplexEmbedding , self ) . __init__ ( space , complex_space , linear = True )  def _call ( self , x , out ) :          if self . domain . is_real :              out . real = self . scalar . real * x out . imag = self . scalar . imag * x  else :              out . lincomb ( self . scalar , x )   @ property def inverse ( self ) :          if self . domain . is_real :              if self . scalar . real == self . scalar :                  return ( 1 / self . scalar . real ) * RealPart ( self . range )  elif 1j * self . scalar . imag == self . scalar :                  return ( 1 / self . scalar . imag ) * ImagPart ( self . range )  else :                  inv_scalar = ( 1 / self . scalar ) . conjugate ( ) return ( ( inv_scalar . real ) * RealPart ( self . range ) + ( inv_scalar . imag ) * ImagPart ( self . range ) )   else :              return ComplexEmbedding ( self . range , self . scalar . conjugate ( ) )   @ property def adjoint ( self ) :          if self . domain . is_real :              if self . scalar . real == self . scalar :                  return self . scalar . real * RealPart ( self . range )  elif 1j * self . scalar . imag == self . scalar :                  return self . scalar . imag * ImagPart ( self . range )  else :                  return ( self . scalar . real * RealPart ( self . range ) + self . scalar . imag * ImagPart ( self . range ) )   else :              return ComplexEmbedding ( self . range , self . scalar . conjugate ( ) )    class ComplexModulus ( Operator ) :      def __init__ ( self , space ) :          real_space = space . real_space super ( ComplexModulus , self ) . __init__ ( space , real_space , linear = False )  def _call ( self , x ) :          return ( x . real ** 2 + x . imag ** 2 ) . ufuncs . sqrt ( )  def derivative ( self , x ) :          <str> op = self x = self . domain . element ( x ) class ComplexModulusDerivative ( Operator ) :              def _call ( self , y , out ) :                  out [ : ] = x . real * y . real out += x . imag * y . imag out /= op ( x ) return out  @ property def adjoint ( self ) :                  <str> deriv = self class ComplexModulusDerivativeAdjoint ( Operator ) :                      def _call ( self , u , out ) :                          out . assign ( x ) tmp = u / op ( x ) out . real *= tmp out . imag *= tmp return out  @ property def adjoint ( self ) :                          return deriv   return ComplexModulusDerivativeAdjoint ( deriv . range , deriv . domain , linear = deriv . domain . is_real )   return ComplexModulusDerivative ( op . domain , op . range , linear = op . domain . is_real )   class ComplexModulusSquared ( Operator ) :      def __init__ ( self , space ) :          real_space = space . real_space super ( ComplexModulusSquared , self ) . __init__ ( space , real_space , linear = False )  def _call ( self , x ) :          return x . real ** 2 + x . imag ** 2  def derivative ( self , x ) :          <str> op = self x = self . domain . element ( x ) class ComplexModulusSquaredDerivative ( Operator ) :              def _call ( self , y , out ) :                  x . real . multiply ( y . real , out = out ) out += x . imag * y . imag return out  @ property def adjoint ( self ) :                  <str> deriv = self class ComplexModulusSquaredDerivAdj ( Operator ) :                      def _call ( self , u , out ) :                          out . assign ( x ) out . real *= u out . imag *= u return out  @ property def adjoint ( self ) :                          return deriv   return ComplexModulusSquaredDerivAdj ( deriv . range , deriv . domain , linear = deriv . domain . is_real )   return ComplexModulusSquaredDerivative ( op . domain , op . range , linear = op . domain . is_real )   if __name__ == <str> :      from odl . util . testutils import run_doctests run_doctests ( )   