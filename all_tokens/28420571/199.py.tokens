from __future__ import print_function , division , absolute_import from builtins import int , object from collections import OrderedDict from itertools import permutations import numpy as np import struct import warnings from odl . contrib . mrc . uncompr_bin import ( FileReaderRawBinaryWithHeader , FileWriterRawBinaryWithHeader , header_fields_from_table ) __all__ = ( <str> , <str> , <str> ) MRC_2014_SPEC_TABLE = MRC_HEADER_SIZE = 1024 MRC_SPEC_KEYS = { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } MRC_DTYPE_TO_NPY_DTYPE = { <str> : np . dtype ( <str> ) , <str> : np . dtype ( <str> ) , <str> : np . dtype ( <str> ) } MRC_MODE_TO_NPY_DTYPE = { 0 : np . dtype ( <str> ) , 1 : np . dtype ( <str> ) , 2 : np . dtype ( <str> ) , 6 : np . dtype ( <str> ) } NPY_DTYPE_TO_MRC_MODE = { v : k for k , v in MRC_MODE_TO_NPY_DTYPE . items ( ) } ANGSTROM_IN_METERS = 1e-10 MICRON_IN_METERS = 1e-6 def print_mrc2014_spec ( ) :      print ( MRC_2014_SPEC_TABLE )  print_mrc2014_spec . __doc__ += MRC_2014_SPEC_TABLE MRC_FEI_EXT_HEADER_SECTION = MRC_FEI_SECTION_SIZE = 128 MRC_FEI_NUM_SECTIONS = 1024 def print_fei_ext_header_spec ( ) :      print ( MRC_FEI_EXT_HEADER_SECTION )  print_fei_ext_header_spec . __doc__ += MRC_FEI_EXT_HEADER_SECTION class MRCHeaderProperties ( object ) :      print_mrc2014_spec = staticmethod ( print_mrc2014_spec ) print_fei_ext_header_spec = staticmethod ( print_fei_ext_header_spec ) @ property def header_size ( self ) :          standard_header_size = MRC_HEADER_SIZE try :              extra_header_size = int ( self . header [ <str> ] [ <str> ] )  except KeyError :              extra_header_size = 0  return standard_header_size + extra_header_size  @ property def data_shape ( self ) :          if not self . header :              return - 1  try :              nx = self . header [ <str> ] [ <str> ] ny = self . header [ <str> ] [ <str> ] nz = self . header [ <str> ] [ <str> ]  except KeyError :              return - 1  else :              return tuple ( int ( n ) for n in ( nx , ny , nz ) )   @ property def data_storage_shape ( self ) :          if self . data_shape == - 1 :              return - 1  else :              return tuple ( self . data_shape [ ax ] for ax in np . argsort ( self . data_axis_order ) )   @ property def data_dtype ( self ) :          if not self . header :              return self . _init_data_dtype  try :              mode = int ( self . header [ <str> ] [ <str> ] )  except KeyError :              return self . _init_data_dtype  else :              try :                  return MRC_MODE_TO_NPY_DTYPE [ mode ]  except KeyError :                  raise ValueError ( <str> . format ( mode ) )    @ property def data_kind ( self ) :          ispg = self . header [ <str> ] [ <str> ] if ispg == 0 :              return <str>  elif ispg == 1 :              return <str>  else :              return <str>   @ property def data_axis_order ( self ) :          if not self . header :              return ( 0 , 1 , 2 )  try :              mapc = self . header [ <str> ] [ <str> ] mapr = self . header [ <str> ] [ <str> ] maps = self . header [ <str> ] [ <str> ]  except KeyError :              return ( 0 , 1 , 2 )  else :              axis_order = tuple ( int ( m ) - 1 for m in [ mapc , mapr , maps ] ) if ( sorted ( axis_order ) != [ 0 , 1 , 2 ] ) :                  warnings . warn ( <str> <str> . format ( tuple ( m + 1 for m in axis_order ) ) , RuntimeWarning ) axis_order = ( 0 , 1 , 2 )  return axis_order   @ property def cell_sides_angstrom ( self ) :          return np . asarray ( self . header [ <str> ] [ <str> ] , dtype = float ) / self . data_shape  @ property def cell_sides ( self ) :          return self . cell_sides_angstrom * ANGSTROM_IN_METERS  @ property def mrc_version ( self ) :          nversion = int ( self . header [ <str> ] [ <str> ] ) return nversion // 10 , nversion % 10  @ property def extended_header_size ( self ) :          return int ( self . header [ <str> ] [ <str> ] )  @ property def extended_header_type ( self ) :          return <str> . join ( self . header [ <str> ] [ <str> ] . astype ( str ) )  @ property def labels ( self ) :          label_array = self . header [ <str> ] [ <str> ] labels = tuple ( <str> . join ( row . astype ( str ) ) for row in label_array ) try :              nlabels = int ( self . header [ <str> ] [ <str> ] )  except KeyError :              nlabels = len ( labels )  if any ( label . strip ( ) for label in labels [ nlabels : ] ) :              return labels  else :              return labels [ : nlabels ]    class FileReaderMRC ( MRCHeaderProperties , FileReaderRawBinaryWithHeader ) :      def __init__ ( self , file , header_fields = None ) :          if header_fields is None :              header_fields = header_fields_from_table ( spec_table = MRC_2014_SPEC_TABLE , keys = MRC_SPEC_KEYS , dtype_map = MRC_DTYPE_TO_NPY_DTYPE )  super ( FileReaderMRC , self ) . __init__ ( file , header_fields )  def read_extended_header ( self , groupby = <str> , force_type = <str> ) :          ext_header_type = str ( force_type ) . upper ( ) or self . extended_header_type if ext_header_type != <str> :              raise ValueError ( <str> <str> . format ( self . extended_header_type ) )  groupby , groupby_in = str ( groupby ) . lower ( ) , groupby ext_header_len = int ( self . header [ <str> ] [ <str> ] ) if ext_header_len % MRC_FEI_SECTION_SIZE :              raise ValueError ( <str> <str> <str> . format ( ext_header_len , MRC_FEI_SECTION_SIZE ) )  num_sections = ext_header_len // MRC_FEI_SECTION_SIZE if num_sections != MRC_FEI_NUM_SECTIONS :              raise ValueError ( <str> <str> <str> . format ( num_sections , MRC_FEI_NUM_SECTIONS ) )  section_fields = header_fields_from_table ( MRC_FEI_EXT_HEADER_SECTION , keys = MRC_SPEC_KEYS , dtype_map = MRC_DTYPE_TO_NPY_DTYPE ) ext_header = OrderedDict ( ) for field in section_fields :              value_list = [ ] field_offset = field [ <str> ] field_dtype = field [ <str> ] field_dshape = field [ <str> ] num_items = int ( np . prod ( field_dshape ) ) size_bytes = num_items * field_dtype . itemsize fmt = <str> . format ( num_items , field_dtype . char ) for section in range ( num_sections ) :                  start = section * MRC_FEI_SECTION_SIZE + field_offset self . file . seek ( start ) packed_value = self . file . read ( size_bytes ) value_list . append ( struct . unpack ( fmt , packed_value ) )  ext_header [ field [ <str> ] ] = np . array ( value_list , dtype = field_dtype )  if groupby == <str> :              return ext_header  elif groupby == <str> :              return tuple ( { key : ext_header [ key ] [ i ] for key in ext_header } for i in range ( num_sections ) )  else :              raise ValueError ( <str> <str> . format ( groupby_in ) )   def read_data ( self , dstart = None , dend = None , swap_axes = True ) :          data = super ( FileReaderMRC , self ) . read_data ( dstart , dend ) data = data . reshape ( self . data_shape , order = <str> ) if swap_axes :              data = np . transpose ( data , axes = self . data_axis_order ) assert data . shape == self . data_shape  return data   class FileWriterMRC ( MRCHeaderProperties , FileWriterRawBinaryWithHeader ) :      def write_data ( self , data , dstart = None , swap_axes = True ) :          if dstart is None :              shape = self . data_shape dstart = int ( self . header_size )  elif dstart < 0 :              raise ValueError ( <str> <str> . format ( dstart ) )  else :              shape = - 1 dstart = int ( dstart )  if dstart < self . header_size :              raise ValueError ( <str> <str> <str> . format ( dstart , self . header_size ) )  data = np . asarray ( data , dtype = self . data_dtype ) . reshape ( shape ) if swap_axes :              data = np . transpose ( data , axes = np . argsort ( self . data_axis_order ) ) assert data . shape == self . data_storage_shape  data = data . reshape ( - 1 , order = <str> ) self . file . seek ( dstart ) data . tofile ( self . file )   def mrc_header_from_params ( shape , dtype , kind , ** kwargs ) :      shape = [ int ( n ) for n in shape ] kind , kind_in = str ( kind ) . lower ( ) , kind if kind not in ( <str> , <str> ) :          raise ValueError ( <str> . format ( kind_in ) )  extent = kwargs . pop ( <str> , shape ) axis_order = kwargs . pop ( <str> , ( 0 , 1 , 2 ) ) if tuple ( axis_order ) not in permutations ( ( 0 , 1 , 2 ) ) :          raise ValueError ( <str> <str> . format ( axis_order ) )  dmin = kwargs . pop ( <str> , 1.0 ) dmax = kwargs . pop ( <str> , 0.0 ) dmean = kwargs . pop ( <str> , min ( dmin , dmax ) - 1.0 ) rms = kwargs . pop ( <str> , - 1.0 ) mrc_version = kwargs . pop ( <str> , ( 2014 , 0 ) ) if len ( mrc_version ) != 2 :          raise ValueError ( <str> <str> . format ( mrc_version ) )  text_labels_in = kwargs . pop ( <str> , [ ] ) nlabl = len ( text_labels_in ) if nlabl > 10 :          raise ValueError ( <str> <str> . format ( nlabl ) )  text_labels = [ str ( label ) . ljust ( 80 ) for label in text_labels_in ] if any ( len ( label ) > 80 for label in text_labels ) :          raise ValueError ( <str> )  nx , ny , nz = [ np . array ( n , dtype = <str> ) . reshape ( [ 1 ] ) for n in shape ] mode = np . array ( NPY_DTYPE_TO_MRC_MODE [ np . dtype ( dtype ) ] , dtype = <str> ) . reshape ( [ 1 ] ) mx , my , mz = nx , ny , nz cella = np . array ( extent ) . reshape ( [ 3 ] ) . astype ( <str> ) mapc , mapr , maps = [ np . array ( m , dtype = <str> ) . reshape ( [ 1 ] ) + 1 for m in axis_order ] dmin , dmax , dmean , rms = [ np . array ( x , dtype = <str> ) . reshape ( [ 1 ] ) for x in ( dmin , dmax , dmean , rms ) ] ispg = 1 if kind == <str> else 0 ispg = np . array ( ispg , dtype = <str> , ndmin = 1 ) nsymbt = np . array ( [ 0 ] , dtype = <str> ) exttype = np . fromstring ( <str> , dtype = <str> ) nversion = np . array ( 10 * mrc_version [ 0 ] + mrc_version [ 1 ] , dtype = <str> ) . reshape ( [ 1 ] ) origin = np . zeros ( 3 , dtype = <str> ) map = np . fromstring ( <str> , dtype = <str> ) machst = np . fromiter ( <str> , dtype = <str> ) nlabl = np . array ( nlabl , dtype = <str> ) . reshape ( [ 1 ] ) label = np . zeros ( ( 10 , 80 ) , dtype = <str> ) for i , label_i in enumerate ( text_labels ) :          label [ i ] = np . fromstring ( label_i , dtype = <str> )  header_fields = header_fields_from_table ( MRC_2014_SPEC_TABLE , MRC_SPEC_KEYS , MRC_DTYPE_TO_NPY_DTYPE ) header = OrderedDict ( ) for field in header_fields :          header [ field [ <str> ] ] = { <str> : field [ <str> ] , <str> : eval ( field [ <str> ] ) }  return header   