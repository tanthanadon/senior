from __future__ import division import numpy as np import odl from odl . solvers import pdhg from odl . util . testutils import all_almost_equal PLACES = 8 TAU = 0.3 SIGMA = 0.7 THETA = 0.9 DATA = np . arange ( 6 ) def test_pdhg_simple_space ( ) :      space = odl . uniform_discr ( 0 , 1 , DATA . size ) op = odl . IdentityOperator ( space ) discr_vec = op . domain . element ( DATA ) discr_vec_relax = discr_vec . copy ( ) discr_dual = op . range . zero ( ) f = odl . solvers . ZeroFunctional ( space ) g = f . convex_conj pdhg ( discr_vec , f , g , op , niter = 1 , tau = TAU , sigma = SIGMA , theta = THETA , callback = None , x_relax = discr_vec_relax , y = discr_dual ) vec_expl = ( 1 - TAU * SIGMA ) * DATA assert all_almost_equal ( discr_vec , vec_expl , PLACES ) vec_relax_expl = ( 1 + THETA ) * vec_expl - THETA * DATA assert all_almost_equal ( discr_vec_relax , vec_relax_expl , PLACES ) pdhg ( discr_vec , f , g , op , niter = 1 , tau = TAU , sigma = SIGMA , theta = THETA ) vec_expl *= ( 1 - SIGMA * TAU ) assert all_almost_equal ( discr_vec , vec_expl , PLACES ) discr_vec [ : ] = vec_expl pdhg ( discr_vec , f , g , op , niter = 1 , tau = TAU , sigma = SIGMA , theta = THETA , x_relax = discr_vec_relax , y = discr_dual ) vec_expl = vec_expl - TAU * SIGMA * ( DATA + vec_relax_expl ) assert all_almost_equal ( discr_vec , vec_expl , PLACES ) discr_vec = op . domain . element ( DATA ) discr_vec_relax_no_gamma = op . domain . element ( DATA ) pdhg ( discr_vec , f , g , op , niter = 1 , tau = TAU , sigma = SIGMA , theta = 1 , gamma_primal = None , x_relax = discr_vec_relax_no_gamma ) discr_vec = op . domain . element ( DATA ) discr_vec_relax_g0 = op . domain . element ( DATA ) pdhg ( discr_vec , f , g , op , niter = 1 , tau = TAU , sigma = SIGMA , theta = 0 , gamma_primal = 0 , x_relax = discr_vec_relax_g0 ) assert discr_vec != discr_vec_relax_no_gamma assert all_almost_equal ( discr_vec_relax_no_gamma , discr_vec_relax_g0 ) pdhg ( discr_vec , f , g , op , niter = 1 , tau = TAU , sigma = SIGMA , theta = THETA , callback = odl . solvers . CallbackPrintIteration ( ) )  def test_pdhg_product_space ( ) :      space = odl . uniform_discr ( 0 , 1 , DATA . size ) identity = odl . IdentityOperator ( space ) prod_op = odl . BroadcastOperator ( identity , - 2 * identity ) discr_vec_0 = prod_op . domain . element ( DATA ) discr_vec = discr_vec_0 . copy ( ) f = odl . solvers . ZeroFunctional ( prod_op . domain ) g = odl . solvers . ZeroFunctional ( prod_op . range ) . convex_conj pdhg ( discr_vec , f , g , prod_op , niter = 1 , tau = TAU , sigma = SIGMA , theta = THETA ) vec_expl = discr_vec_0 - TAU * SIGMA * prod_op . adjoint ( prod_op ( discr_vec_0 ) ) assert all_almost_equal ( discr_vec , vec_expl , PLACES )  if __name__ == <str> :      odl . util . test_file ( __file__ )   