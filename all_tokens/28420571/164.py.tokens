from __future__ import absolute_import , division , print_function from builtins import int , object from numbers import Complex , Integral , Real import numpy as np from past . types . basestring import basestring from odl . util import is_int_dtype , is_numeric_dtype , is_real_dtype , unique __all__ = ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) class Set ( object ) :      def __contains__ ( self , other ) :          raise NotImplementedError ( <str> )  def contains_set ( self , other ) :          return self == other  def contains_all ( self , other ) :          return all ( x in self for x in other )  def __eq__ ( self , other ) :          raise NotImplementedError ( <str> )  def __ne__ ( self , other ) :          return not self . __eq__ ( other )  def __cmp__ ( self , other ) :          raise TypeError ( <str> <str> . format ( self . __class__ . __name__ , type ( other ) ) )  def element ( self , inp = None ) :          raise NotImplementedError ( <str> )  @ property def examples ( self ) :          yield ( <str> , self . element ( ) )  def __repr__ ( self ) :          return <str> . format ( self . __class__ . __name__ )  def __str__ ( self ) :          return <str> . format ( self . __class__ . __name__ )   class EmptySet ( Set ) :      def __contains__ ( self , other ) :          return other is None  def contains_set ( self , other ) :          return isinstance ( other , EmptySet )  def __eq__ ( self , other ) :          return isinstance ( other , EmptySet )  def __hash__ ( self ) :          return hash ( type ( self ) )  def element ( self , inp = None ) :          return None   class UniversalSet ( Set ) :      def __contains__ ( self , other ) :          return True  def contains_set ( self , other ) :          return isinstance ( other , Set )  def __eq__ ( self , other ) :          return isinstance ( other , UniversalSet )  def __hash__ ( self ) :          return hash ( type ( self ) )  def element ( self , inp = None ) :          return inp   class Strings ( Set ) :      def __init__ ( self , length ) :          length , length_in = int ( length ) , length if length <= 0 :              raise ValueError ( <str> <str> . format ( length_in ) )  self . __length = length  @ property def length ( self ) :          return self . __length  def __contains__ ( self , other ) :          return isinstance ( other , basestring ) and len ( other ) == self . length  def contains_all ( self , other ) :          dtype = getattr ( other , <str> , None ) if dtype is None :              dtype = np . result_type ( * other )  dtype_str = np . dtype ( <str> . format ( self . length ) ) dtype_uni = np . dtype ( <str> . format ( self . length ) ) return dtype in ( dtype_str , dtype_uni )  def __eq__ ( self , other ) :          return isinstance ( other , Strings ) and other . length == self . length  def __hash__ ( self ) :          return hash ( ( type ( self ) , self . length ) )  def element ( self , inp = None ) :          if inp is not None :              s = str ( inp ) [ : self . length ] s += <str> * ( self . length - len ( s ) ) return s  else :              return <str> * self . length   @ property def examples ( self ) :          hello_str = <str> [ : self . length ] hello_str += <str> * ( self . length - len ( hello_str ) ) world_str = <str> [ : self . length ] world_str += <str> * ( self . length - len ( world_str ) ) return [ ( <str> , hello_str ) , ( <str> , world_str ) ]  def __repr__ ( self ) :          return <str> . format ( self . length )   class Field ( Set ) :      @ property def field ( self ) :          return self   class ComplexNumbers ( Field ) :      def __contains__ ( self , other ) :          return isinstance ( other , Complex )  def contains_set ( self , other ) :          if other is self :              return True  return ( isinstance ( other , ComplexNumbers ) or isinstance ( other , RealNumbers ) or isinstance ( other , Integers ) )  def contains_all ( self , other ) :          dtype = getattr ( other , <str> , None ) if dtype is None :              dtype = np . result_type ( * other )  return is_numeric_dtype ( dtype )  def __eq__ ( self , other ) :          if other is self :              return True  return isinstance ( other , ComplexNumbers )  def __hash__ ( self ) :          return hash ( type ( self ) )  def element ( self , inp = None ) :          if inp is None :              return complex ( 0.0 , 0.0 )  else :              return complex ( inp )   @ property def examples ( self ) :          numbers = [ - 1.0 , 0.5 , 0.0 + 2.0j , 0.0 , 0.01 , 1.0 + 1.0j , 1.0j , 1.0 ] return [ ( str ( x ) , x ) for x in numbers ]   class RealNumbers ( Field ) :      def __contains__ ( self , other ) :          return isinstance ( other , Real )  def contains_set ( self , other ) :          if other is self :              return True  return ( isinstance ( other , RealNumbers ) or isinstance ( other , Integers ) )  def contains_all ( self , array ) :          dtype = getattr ( array , <str> , None ) if dtype is None :              dtype = np . result_type ( * array )  return is_real_dtype ( dtype )  def __eq__ ( self , other ) :          if other is self :              return True  return isinstance ( other , RealNumbers )  def __hash__ ( self ) :          return hash ( type ( self ) )  def element ( self , inp = None ) :          if inp is not None :              return float ( inp )  else :              return 0.0   @ property def examples ( self ) :          numbers = [ - 1.0 , 0.5 , 0.0 , 0.01 , 1.0 ] return [ ( str ( x ) , x ) for x in numbers ]   class Integers ( Set ) :      def __contains__ ( self , other ) :          return isinstance ( other , Integral )  def contains_set ( self , other ) :          if other is self :              return True  return isinstance ( other , Integers )  def contains_all ( self , other ) :          dtype = getattr ( other , <str> , None ) if dtype is None :              dtype = np . result_type ( * other )  return is_int_dtype ( dtype )  def __eq__ ( self , other ) :          if other is self :              return True  return isinstance ( other , Integers )  def __hash__ ( self ) :          return hash ( type ( self ) )  def element ( self , inp = None ) :          if inp is not None :              return int ( inp )  else :              return 0   @ property def examples ( self ) :          numbers = [ - 1 , 0 , 1 ] return [ ( str ( x ) , x ) for x in numbers ]   class CartesianProduct ( Set ) :      def __init__ ( self , * sets ) :          for set_ in sets :              if not isinstance ( set_ , Set ) :                  raise TypeError ( <str> . format ( set_ ) )   self . __sets = tuple ( sets )  @ property def sets ( self ) :          return self . __sets  def __contains__ ( self , other ) :          try :              len ( other )  except TypeError :              return False  return ( len ( other ) == len ( self ) and all ( p in set_ for set_ , p in zip ( self . sets , other ) ) )  def __eq__ ( self , other ) :          return ( type ( self ) == type ( other ) and self . sets == other . sets )  def __hash__ ( self ) :          return hash ( ( type ( self ) , self . sets ) )  def element ( self , inp = None ) :          if inp is None :              tpl = tuple ( set_ . element ( ) for set_ in self . sets )  else :              tpl = tuple ( set_ . element ( inpt ) for inpt , set_ in zip ( inp , self . sets ) ) if len ( tpl ) != len ( self ) :                  raise ValueError ( <str> <str> . format ( len ( tpl ) , len ( self ) ) )   return tpl  def __len__ ( self ) :          return len ( self . sets )  def __getitem__ ( self , indices ) :          if isinstance ( indices , slice ) :              return CartesianProduct ( * self . sets [ indices ] )  else :              return self . sets [ indices ]   def __str__ ( self ) :          return <str> . join ( str ( set_ ) for set_ in self . sets )  def __repr__ ( self ) :          sets_str = <str> . join ( repr ( set_ ) for set_ in self . sets ) return <str> . format ( self . __class__ . __name__ , sets_str )   class SetUnion ( Set ) :      def __init__ ( self , * sets ) :          for set_ in sets :              if not isinstance ( set_ , Set ) :                  raise TypeError ( <str> . format ( set_ ) )   self . __sets = tuple ( unique ( sets ) )  @ property def sets ( self ) :          return self . __sets  def __contains__ ( self , other ) :          return any ( other in set for set in self . sets )  def __eq__ ( self , other ) :          return ( type ( self ) == type ( other ) and all ( set_ in other for set_ in self ) and all ( set_ in self for set_ in other ) )  def __hash__ ( self ) :          return hash ( ( type ( self ) , set ( self . sets ) ) )  def element ( self , inp = None ) :          for set in self . sets :              try :                  return set . element ( inp )  except NotImplementedError :                  pass   raise NotImplementedError ( <str> <str> )  def __len__ ( self ) :          return len ( self . sets )  def __getitem__ ( self , indcs ) :          if isinstance ( indcs , slice ) :              return SetUnion ( * self . sets [ indcs ] )  else :              return self . sets [ indcs ]   def __repr__ ( self ) :          sets_str = <str> . join ( repr ( set_ ) for set_ in self . sets ) return <str> . format ( self . __class__ . __name__ , sets_str )   class SetIntersection ( Set ) :      def __init__ ( self , * sets ) :          for set_ in sets :              if not isinstance ( set_ , Set ) :                  raise TypeError ( <str> . format ( set_ ) )   self . __sets = tuple ( unique ( sets ) )  @ property def sets ( self ) :          return self . __sets  def __contains__ ( self , other ) :          return all ( other in set for set in self . sets )  def __eq__ ( self , other ) :          return ( type ( self ) == type ( other ) and all ( set_ in other for set_ in self ) and all ( set_ in self for set_ in other ) )  def __hash__ ( self ) :          return hash ( ( type ( self ) , set ( self . sets ) ) )  def __len__ ( self ) :          return len ( self . sets )  def __getitem__ ( self , indcs ) :          if isinstance ( indcs , slice ) :              return SetIntersection ( * self . sets [ indcs ] )  else :              return self . sets [ indcs ]   def __repr__ ( self ) :          sets_str = <str> . join ( repr ( set_ ) for set_ in self . sets ) return <str> . format ( self . __class__ . __name__ , sets_str )   class FiniteSet ( Set ) :      def __init__ ( self , * elements ) :          self . __elements = tuple ( unique ( elements ) )  @ property def elements ( self ) :          return self . __elements  def __contains__ ( self , other ) :          return other in self . elements  def __eq__ ( self , other ) :          return ( type ( self ) == type ( other ) and all ( el in other for el in self ) and all ( el in self for el in other ) )  def __hash__ ( self ) :          return hash ( ( type ( self ) , set ( self . elements ) ) )  def element ( self , inp = None ) :          if inp is None :              return self . elements [ 0 ]  elif inp in self . elements :              return inp  else :              raise ValueError ( <str> <str> . format ( inp , self ) )   def __getitem__ ( self , indcs ) :          if isinstance ( indcs , slice ) :              return FiniteSet ( * self . elements [ indcs ] )  else :              return self . elements [ indcs ]   def __repr__ ( self ) :          elements_str = <str> . join ( repr ( el ) for el in self . elements ) return <str> . format ( self . __class__ . __name__ , elements_str )   if __name__ == <str> :      from odl . util . testutils import run_doctests run_doctests ( )   