from __future__ import print_function , division , absolute_import import numpy as np from odl . tomo . geometry . parallel import Parallel3dAxisGeometry from odl . tomo . util . utility import transform_system from odl . util import signature_string , indent , array_str __all__ = ( <str> , ) class ParallelHoleCollimatorGeometry ( Parallel3dAxisGeometry ) :      def __init__ ( self , apart , dpart , det_radius , axis = ( 0 , 0 , 1 ) , ** kwargs ) :          self . __det_radius = float ( det_radius ) if self . det_radius <= 0 :              raise ValueError ( <str> <str> . format ( det_radius ) )  orig_to_det_init = kwargs . pop ( <str> , None ) if orig_to_det_init is not None :              orig_to_det_init = np . asarray ( orig_to_det_init , dtype = float ) orig_to_det_norm = np . linalg . norm ( orig_to_det_init ) if orig_to_det_norm == 0 :                  raise ValueError ( <str> )  else :                  det_pos_init = ( orig_to_det_init / orig_to_det_norm * self . det_radius )  kwargs [ <str> ] = det_pos_init  self . _orig_to_det_init_arg = orig_to_det_init super ( ParallelHoleCollimatorGeometry , self ) . __init__ ( apart , dpart , axis , ** kwargs )  @ classmethod def frommatrix ( cls , apart , dpart , det_radius , init_matrix , ** kwargs ) :          init_matrix = np . asarray ( init_matrix , dtype = float ) if init_matrix . shape not in ( ( 3 , 3 ) , ( 3 , 4 ) ) :              raise ValueError ( <str> <str> <str> . format ( init_matrix . shape ) )  trafo_matrix = init_matrix [ : , : 3 ] translation = init_matrix [ : , 3 : ] . squeeze ( ) default_axis = cls . _default_config [ <str> ] default_orig_to_det_init = ( np . array ( cls . _default_config [ <str> ] , dtype = float ) / np . linalg . norm ( cls . _default_config [ <str> ] ) ) default_det_axes_init = cls . _default_config [ <str> ] vecs_to_transform = ( ( default_orig_to_det_init , ) + default_det_axes_init ) transformed_vecs = transform_system ( default_axis , None , vecs_to_transform , matrix = trafo_matrix ) axis , orig_to_det , det_axis_0 , det_axis_1 = transformed_vecs if translation . size != 0 :              kwargs [ <str> ] = translation  return cls ( apart , dpart , det_radius , axis , orig_to_det_init = orig_to_det , det_axes_init = [ det_axis_0 , det_axis_1 ] , ** kwargs )  @ property def det_radius ( self ) :          return self . __det_radius  @ property def orig_to_det_init ( self ) :          return self . det_pos_init / np . linalg . norm ( self . det_pos_init )  def __repr__ ( self ) :          posargs = [ self . motion_partition , self . det_partition ] optargs = [ ( <str> , self . det_radius , - 1 ) ] if not np . allclose ( self . axis , self . _default_config [ <str> ] ) :              optargs . append ( [ <str> , array_str ( self . axis ) , <str> ] )  if self . _orig_to_det_init_arg is not None :              optargs . append ( [ <str> , array_str ( self . _orig_to_det_init_arg ) , <str> ] )  if self . _det_axes_init_arg is not None :              optargs . append ( [ <str> , tuple ( array_str ( a ) for a in self . _det_axes_init_arg ) , None ] )  if not np . array_equal ( self . translation , ( 0 , 0 , 0 ) ) :              optargs . append ( [ <str> , array_str ( self . translation ) , <str> ] )  sig_str = signature_string ( posargs , optargs , sep = <str> ) return <str> . format ( self . __class__ . __name__ , indent ( sig_str ) )    