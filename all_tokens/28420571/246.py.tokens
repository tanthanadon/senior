import numpy as np import odl from odl . contrib . param_opt import optimal_parameters reconstruction_method = <str> signal_to_noise = 5.0 space = odl . uniform_discr ( min_pt = [ - 20 , - 20 ] , max_pt = [ 20 , 20 ] , shape = [ 128 , 128 ] , dtype = <str> ) geometry = odl . tomo . parallel_beam_geometry ( space ) ray_trafo = odl . tomo . RayTransform ( space , geometry ) phantoms = [ odl . phantom . shepp_logan ( space , modified = True ) , odl . phantom . derenzo_sources ( space ) ] data = [ ] for phantom in phantoms :      noiseless_data = ray_trafo ( phantom ) noise_scale = ( 1 / signal_to_noise ) * np . mean ( noiseless_data ) noise = noise_scale * odl . phantom . white_noise ( ray_trafo . range ) noisy_data = noiseless_data + noise data . append ( noisy_data )  if reconstruction_method == <str> :      def reconstruction ( proj_data , lam ) :          print ( <str> . format ( lam ) ) fbp_op = odl . tomo . fbp_op ( ray_trafo , filter_type = <str> , frequency_scaling = 1 / lam ) return fbp_op ( proj_data )  initial_param = 1.0  elif reconstruction_method == <str> :      def reconstruction ( proj_data , parameters ) :          lam , sigma = parameters print ( <str> . format ( lam , sigma ) ) if lam <= 0 or sigma <= 0 :              return np . inf * space . one ( )  l2_norm = odl . solvers . L2NormSquared ( ray_trafo . range ) data_discrepancy = l2_norm * ( ray_trafo - proj_data ) gradient = odl . Gradient ( space ) l1_norm = odl . solvers . GroupL1Norm ( gradient . range ) smoothed_l1 = odl . solvers . MoreauEnvelope ( l1_norm , sigma = sigma ) regularizer = smoothed_l1 * gradient obj_fun = data_discrepancy + lam * regularizer maxiter = 30 num_store = 5 x = ray_trafo . domain . zero ( ) odl . solvers . bfgs_method ( obj_fun , x , maxiter = maxiter , num_store = num_store , hessinv_estimate = odl . ScalingOperator ( space , 1 / odl . power_method_opnorm ( ray_trafo ) ** 2 ) ) return x  initial_param = [ 0.1 , 0.05 ]  elif reconstruction_method == <str> :      def reconstruction ( proj_data , lam ) :          lam = float ( lam ) print ( <str> . format ( lam ) ) if lam <= 0 :              return np . inf * space . one ( )  gradient = odl . Gradient ( space ) op = odl . BroadcastOperator ( ray_trafo , gradient ) f = odl . solvers . ZeroFunctional ( op . domain ) l2_norm = odl . solvers . L2NormSquared ( ray_trafo . range ) . translated ( proj_data ) l1_norm = lam * odl . solvers . GroupL1Norm ( gradient . range ) g = odl . solvers . SeparableSum ( l2_norm , l1_norm ) op_norm = 1.5 * odl . power_method_opnorm ( op , maxiter = 10 ) x = op . domain . zero ( ) odl . solvers . pdhg ( x , f , g , op , niter = 200 , tau = 1.0 / op_norm , sigma = 1.0 / op_norm ) return x  initial_param = 0.1  else :      raise RuntimeError ( <str> )  def fom ( reco , true_image ) :      gradient = odl . Gradient ( reco . space ) return ( gradient ( reco - true_image ) . norm ( ) + reco . space . dist ( reco , true_image ) )  optimal_parameters = optimal_parameters ( reconstruction , fom , phantoms , data , initial_param = initial_param ) reco_0 = reconstruction ( data [ 0 ] , initial_param ) reco_0 . show ( reconstruction_method + <str> ) reco_1 = reconstruction ( data [ 1 ] , initial_param ) reco_1 . show ( reconstruction_method + <str> ) reco_0_opt = reconstruction ( data [ 0 ] , optimal_parameters ) reco_0_opt . show ( reconstruction_method + <str> ) reco_1_opt = reconstruction ( data [ 1 ] , optimal_parameters ) reco_1_opt . show ( reconstruction_method + <str> , force_show = True )  