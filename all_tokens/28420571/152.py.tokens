from __future__ import print_function , division , absolute_import import numpy as np from odl . set import LinearSpace , RealNumbers , Field from odl . space import ProductSpace , tensor_space from odl . operator import Operator , MultiplyOperator from odl . solvers import ( Functional , ScalingFunctional , FunctionalQuotient , ConstantFunctional ) from odl . util . ufuncs import UFUNCS __all__ = ( ) SUPP_TYPECODES = <str> SUPP_TYPECODES_TO_DTYPES = { tc : np . dtype ( tc ) for tc in SUPP_TYPECODES } def find_min_signature ( ufunc , dtypes_in ) :      if not isinstance ( ufunc , np . ufunc ) :          ufunc = getattr ( np , str ( ufunc ) )  dtypes_in = [ np . dtype ( dt_in ) for dt_in in dtypes_in ] tcs_in = [ dt . base . char for dt in dtypes_in ] if len ( tcs_in ) != ufunc . nin :          raise ValueError ( <str> <str> . format ( ufunc . nin , ufunc , len ( tcs_in ) ) )  valid_sigs = [ ] for sig in ufunc . types :          sig_tcs_in , sig_tcs_out = sig . split ( <str> ) if all ( np . dtype ( tc_in ) <= np . dtype ( sig_tc_in ) and sig_tc_in in SUPP_TYPECODES for tc_in , sig_tc_in in zip ( tcs_in , sig_tcs_in ) ) :              valid_sigs . append ( sig )   if not valid_sigs :          raise TypeError ( <str> <str> . format ( ufunc , tuple ( dt . name for dt in dtypes_in ) ) )  def in_dtypes ( sig ) :          sig_tcs_in = sig . split ( <str> ) [ 0 ] return tuple ( np . dtype ( tc ) for tc in sig_tcs_in )  return min ( valid_sigs , key = in_dtypes )  def dtypes_out ( ufunc , dtypes_in ) :      sig = find_min_signature ( ufunc , dtypes_in ) tcs_out = sig . split ( <str> ) [ 1 ] return tuple ( np . dtype ( tc ) for tc in tcs_out )  def _is_integer_only_ufunc ( name ) :      return <str> in name or <str> in name or name == <str>  LINEAR_UFUNCS = [ <str> , <str> , <str> , <str> , <str> ] RAW_EXAMPLES_DOCSTRING = def gradient_factory ( name ) :      if name == <str> :          def gradient ( self ) :              return cos ( self . domain )   elif name == <str> :          def gradient ( self ) :              return - sin ( self . domain )   elif name == <str> :          def gradient ( self ) :              return 1 + square ( self . domain ) * self   elif name == <str> :          def gradient ( self ) :              return FunctionalQuotient ( ConstantFunctional ( self . domain , 0.5 ) , self )   elif name == <str> :          def gradient ( self ) :              return ScalingFunctional ( self . domain , 2.0 )   elif name == <str> :          def gradient ( self ) :              return reciprocal ( self . domain )   elif name == <str> :          def gradient ( self ) :              return self   elif name == <str> :          def gradient ( self ) :              return FunctionalQuotient ( ConstantFunctional ( self . domain , - 1.0 ) , square ( self . domain ) )   elif name == <str> :          def gradient ( self ) :              return cosh ( self . domain )   elif name == <str> :          def gradient ( self ) :              return sinh ( self . domain )   else :          gradient = Functional . gradient  return gradient  def derivative_factory ( name ) :      if name == <str> :          def derivative ( self , point ) :              return MultiplyOperator ( cos ( self . domain ) ( point ) )   elif name == <str> :          def derivative ( self , point ) :              point = self . domain . element ( point ) return MultiplyOperator ( - sin ( self . domain ) ( point ) )   elif name == <str> :          def derivative ( self , point ) :              return MultiplyOperator ( 1 + self ( point ) ** 2 )   elif name == <str> :          def derivative ( self , point ) :              return MultiplyOperator ( 0.5 / self ( point ) )   elif name == <str> :          def derivative ( self , point ) :              point = self . domain . element ( point ) return MultiplyOperator ( 2.0 * point )   elif name == <str> :          def derivative ( self , point ) :              point = self . domain . element ( point ) return MultiplyOperator ( 1.0 / point )   elif name == <str> :          def derivative ( self , point ) :              return MultiplyOperator ( self ( point ) )   elif name == <str> :          def derivative ( self , point ) :              point = self . domain . element ( point ) return MultiplyOperator ( - self ( point ) ** 2 )   elif name == <str> :          def derivative ( self , point ) :              point = self . domain . element ( point ) return MultiplyOperator ( cosh ( self . domain ) ( point ) )   elif name == <str> :          def derivative ( self , point ) :              return MultiplyOperator ( sinh ( self . domain ) ( point ) )   else :          derivative = Operator . derivative  return derivative  def ufunc_class_factory ( name , nargin , nargout , docstring ) :      assert 0 <= nargin <= 2 def __init__ ( self , space ) :          if not isinstance ( space , LinearSpace ) :              raise TypeError ( <str> . format ( space ) )  if nargin == 1 :              domain = space0 = space dtypes = [ space . dtype ]  elif nargin == len ( space ) == 2 and isinstance ( space , ProductSpace ) :              domain = space space0 = space [ 0 ] dtypes = [ space [ 0 ] . dtype , space [ 1 ] . dtype ]  else :              domain = ProductSpace ( space , nargin ) space0 = space dtypes = [ space . dtype , space . dtype ]  dts_out = dtypes_out ( name , dtypes ) if nargout == 1 :              range = space0 . astype ( dts_out [ 0 ] )  else :              range = ProductSpace ( space0 . astype ( dts_out [ 0 ] ) , space0 . astype ( dts_out [ 1 ] ) )  linear = name in LINEAR_UFUNCS Operator . __init__ ( self , domain = domain , range = range , linear = linear )  def _call ( self , x , out = None ) :          if out is None :              if nargin == 1 :                  return getattr ( x . ufuncs , name ) ( )  else :                  return getattr ( x [ 0 ] . ufuncs , name ) ( * x [ 1 : ] )   else :              if nargin == 1 :                  return getattr ( x . ufuncs , name ) ( out = out )  else :                  return getattr ( x [ 0 ] . ufuncs , name ) ( * x [ 1 : ] , out = out )    def __repr__ ( self ) :          return <str> . format ( name , self . domain )  if <str> in name or <str> in name or name == <str> :          dtype = int  else :          dtype = float  space = tensor_space ( 3 , dtype = dtype ) if nargin == 1 :          vec = space . element ( [ - 1 , 1 , 2 ] ) arg = <str> . format ( vec ) with np . errstate ( all = <str> ) :              result = getattr ( vec . ufuncs , name ) ( )   else :          vec = space . element ( [ - 1 , 1 , 2 ] ) vec2 = space . element ( [ 3 , 4 , 5 ] ) arg = <str> . format ( vec , vec2 ) with np . errstate ( all = <str> ) :              result = getattr ( vec . ufuncs , name ) ( vec2 )   if nargout == 2 :          result_space = ProductSpace ( vec . space , 2 ) result = repr ( result_space . element ( result ) )  examples_docstring = RAW_EXAMPLES_DOCSTRING . format ( space = space , name = name , arg = arg , result = result ) full_docstring = docstring + examples_docstring attributes = { <str> : __init__ , <str> : _call , <str> : derivative_factory ( name ) , <str> : __repr__ , <str> : full_docstring } full_name = name + <str> return type ( full_name , ( Operator , ) , attributes )  def ufunc_functional_factory ( name , nargin , nargout , docstring ) :      assert 0 <= nargin <= 2 def __init__ ( self , field ) :          if not isinstance ( field , Field ) :              raise TypeError ( <str> . format ( space ) )  if _is_integer_only_ufunc ( name ) :              raise ValueError ( <str> <str> . format ( name ) )  linear = name in LINEAR_UFUNCS Functional . __init__ ( self , space = field , linear = linear )  def _call ( self , x ) :          if nargin == 1 :              return getattr ( np , name ) ( x )  else :              return getattr ( np , name ) ( * x )   def __repr__ ( self ) :          return <str> . format ( name , self . domain )  if nargin != 1 :          raise NotImplementedError ( <str> )  if nargout != 1 :          raise NotImplementedError ( <str> )  space = RealNumbers ( ) val = 1.0 arg = <str> . format ( val ) with np . errstate ( all = <str> ) :          result = np . float64 ( getattr ( np , name ) ( val ) )  examples_docstring = RAW_EXAMPLES_DOCSTRING . format ( space = space , name = name , arg = arg , result = result ) full_docstring = docstring + examples_docstring attributes = { <str> : __init__ , <str> : _call , <str> : property ( gradient_factory ( name ) ) , <str> : __repr__ , <str> : full_docstring } full_name = name + <str> return type ( full_name , ( Functional , ) , attributes )  RAW_UFUNC_FACTORY_DOCSTRING = RAW_UFUNC_FACTORY_FUNCTIONAL_DOCSTRING = RAW_UFUNC_FACTORY_OPERATOR_DOCSTRING = for name , nargin , nargout , docstring in UFUNCS :      def indirection ( name , docstring ) :          def ufunc_factory ( domain = RealNumbers ( ) ) :              try :                  if isinstance ( domain , Field ) :                      return globals ( ) [ name + <str> ] ( domain )  else :                      return globals ( ) [ name + <str> ] ( domain )   except KeyError :                  raise ValueError ( <str> . format ( domain ) )   return ufunc_factory  globals ( ) [ name + <str> ] = ufunc_class_factory ( name , nargin , nargout , docstring ) if not _is_integer_only_ufunc ( name ) :          operator_example = RAW_UFUNC_FACTORY_OPERATOR_DOCSTRING . format ( name = name )  else :          operator_example = <str>  if not _is_integer_only_ufunc ( name ) and nargin == 1 and nargout == 1 :          globals ( ) [ name + <str> ] = ufunc_functional_factory ( name , nargin , nargout , docstring ) functional_example = RAW_UFUNC_FACTORY_FUNCTIONAL_DOCSTRING . format ( name = name )  else :          functional_example = <str>  ufunc_factory = indirection ( name , docstring ) ufunc_factory . __doc__ = RAW_UFUNC_FACTORY_DOCSTRING . format ( docstring = docstring , name = name , functional_example = functional_example , operator_example = operator_example ) globals ( ) [ name ] = ufunc_factory __all__ += ( name , )  if __name__ == <str> :      from odl . util . testutils import run_doctests run_doctests ( )   