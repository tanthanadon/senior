from __future__ import print_function , division , absolute_import from future . utils import native import theano import numpy as np from odl . solvers import Functional __all__ = ( <str> , ) class TheanoOperator ( theano . Op ) :      __props__ = ( <str> , ) def __init__ ( self , operator ) :          self . operator = operator  def make_node ( self , x ) :          x = theano . tensor . as_tensor_variable ( x ) if isinstance ( self . operator , Functional ) :              out_type = theano . tensor . TensorVariable ( theano . tensor . TensorType ( self . operator . domain . dtype , ( ) ) )  else :              out_type = theano . tensor . TensorVariable ( theano . tensor . TensorType ( self . operator . range . dtype , [ False ] * len ( self . operator . range . shape ) ) )  return theano . Apply ( self , [ x ] , [ out_type . type ( ) ] )  def perform ( self , node , inputs , output_storage ) :          x = inputs [ 0 ] z = output_storage [ 0 ] z [ 0 ] = np . asarray ( self . operator ( x ) )  def infer_shape ( self , node , input_shapes ) :          if isinstance ( self . operator , Functional ) :              return [ ( ) ]  else :              return [ tuple ( native ( si ) for si in self . operator . range . shape ) ]   def grad ( self , inputs , output_grads ) :          <str> return self . R_op ( inputs , output_grads )  def R_op ( self , inputs , eval_points ) :          try :              dom_weight = self . operator . domain . weighting . const  except AttributeError :              dom_weight = 1.0  try :              ran_weight = self . operator . range . weighting . const  except AttributeError :              ran_weight = 1.0  scale = dom_weight / ran_weight op = self class TheanoJacobianAdjoint ( theano . Op ) :              __props__ = ( ) def make_node ( self , x , v ) :                  x = theano . tensor . as_tensor_variable ( x ) v = theano . tensor . as_tensor_variable ( v ) return theano . Apply ( self , [ x , v ] , [ x . type ( ) ] )  def perform ( self , node , inputs_storage , output_storage ) :                  x = inputs_storage [ 0 ] v = inputs_storage [ 1 ] out = output_storage [ 0 ] out [ 0 ] = np . asarray ( op . operator . derivative ( x ) . adjoint ( v ) ) if scale != 1.0 :                      out [ 0 ] *= scale   def infer_shape ( self , node , input_shapes ) :                  return [ tuple ( native ( si ) for si in op . operator . domain . shape ) ]   r_op = TheanoJacobianAdjoint ( ) r_op_apply = r_op ( inputs [ 0 ] , eval_points [ 0 ] ) return [ r_op_apply ]   if __name__ == <str> :      from odl . util . testutils import run_doctests run_doctests ( )   