 from __future__ import print_function , division , absolute_import import numpy as np from odl . set . sets import Set from odl . util import ( array_str , is_valid_input_array , is_valid_input_meshgrid , safe_int_conv ) __all__ = ( <str> , ) class IntervalProd ( Set ) :      def __init__ ( self , min_pt , max_pt ) :          super ( IntervalProd , self ) . __init__ ( ) self . __min_pt = np . atleast_1d ( min_pt ) . astype ( <str> ) self . __max_pt = np . atleast_1d ( max_pt ) . astype ( <str> ) if self . min_pt . ndim > 1 :              raise ValueError ( <str> <str> . format ( self . min_pt . ndim ) )  if self . max_pt . ndim > 1 :              raise ValueError ( <str> <str> . format ( self . max_pt . ndim ) )  if len ( self . min_pt ) != len ( self . max_pt ) :              raise ValueError ( <str> <str> <str> . format ( len ( self . min_pt ) , len ( self . max_pt ) ) )  for axis , ( xmin , xmax ) in enumerate ( zip ( self . min_pt , self . max_pt ) ) :              if np . isnan ( xmin ) :                  raise ValueError ( <str> . format ( axis ) )  if np . isnan ( xmax ) :                  raise ValueError ( <str> . format ( axis ) )  if xmax < xmin :                  raise ValueError ( <str> <str> . format ( axis , xmax , xmin ) )   self . __nondegen_byaxis = ( self . min_pt != self . max_pt )  @ property def min_pt ( self ) :          return self . __min_pt  @ property def max_pt ( self ) :          return self . __max_pt  @ property def ndim ( self ) :          return len ( self . min_pt )  @ property def true_ndim ( self ) :          return np . count_nonzero ( self . nondegen_byaxis )  @ property def volume ( self ) :          return self . measure ( ndim = self . ndim )  @ property def length ( self ) :          if self . ndim != 1 :              raise NotImplementedError ( <str> )  return self . volume  @ property def area ( self ) :          if self . ndim != 2 :              raise NotImplementedError ( <str> )  return self . volume  @ property def mid_pt ( self ) :          midp = ( self . max_pt + self . min_pt ) / 2. midp [ ~ self . nondegen_byaxis ] = self . min_pt [ ~ self . nondegen_byaxis ] return midp  @ property def nondegen_byaxis ( self ) :          return self . __nondegen_byaxis  def min ( self ) :          return self . min_pt  def max ( self ) :          return self . max_pt  @ property def extent ( self ) :          return self . max ( ) - self . min ( )  def element ( self , inp = None ) :          if inp is None :              return self . mid_pt  elif inp in self :              if self . ndim == 1 :                  return float ( inp )  else :                  return np . asarray ( inp )   else :              raise TypeError ( <str> <str> . format ( inp , self ) )   def approx_equals ( self , other , atol ) :          if other is self :              return True  elif not isinstance ( other , IntervalProd ) :              return False  return ( np . allclose ( self . min_pt , other . min_pt , atol = atol , rtol = 0.0 ) and np . allclose ( self . max_pt , other . max_pt , atol = atol , rtol = 0.0 ) )  def __eq__ ( self , other ) :          if other is self :              return True  elif not isinstance ( other , IntervalProd ) :              return False  return ( np . all ( self . min_pt == other . min_pt ) and np . all ( self . max_pt == other . max_pt ) )  def __hash__ ( self ) :          return hash ( ( type ( self ) , tuple ( self . min_pt ) , tuple ( self . max_pt ) ) )  def approx_contains ( self , point , atol ) :          try :              point = np . array ( point , dtype = np . float , copy = False , ndmin = 1 )  except ( ValueError , TypeError ) :              return False  if point . size == 0 :              return True  elif point . shape != ( self . ndim , ) :              return False  return self . dist ( point , exponent = np . inf ) <= atol  def __contains__ ( self , other ) :          try :              point = np . array ( other , dtype = np . float , copy = False , ndmin = 1 )  except ( ValueError , TypeError ) :              return False  if point . shape != ( self . ndim , ) :              return False  return ( self . min_pt <= point ) . all ( ) and ( point <= self . max_pt ) . all ( )  def contains_set ( self , other , atol = 0.0 ) :          if self is other :              return True  try :              return ( self . approx_contains ( other . min ( ) , atol ) and self . approx_contains ( other . max ( ) , atol ) )  except AttributeError :              raise AttributeError ( <str> <str> . format ( other ) )   def contains_all ( self , other , atol = 0.0 ) :          atol = float ( atol ) if other in self :              return True  if hasattr ( other , <str> ) :              return self . contains_all ( other . meshgrid , atol = atol )  elif is_valid_input_meshgrid ( other , self . ndim ) :              vecs = tuple ( vec . squeeze ( ) for vec in other ) mins = np . fromiter ( ( np . min ( vec ) for vec in vecs ) , dtype = float ) maxs = np . fromiter ( ( np . max ( vec ) for vec in vecs ) , dtype = float ) return ( np . all ( mins >= self . min_pt - atol ) and np . all ( maxs <= self . max_pt + atol ) )  other = np . asarray ( other ) if is_valid_input_array ( other , self . ndim ) :              if self . ndim == 1 :                  mins = np . min ( other ) maxs = np . max ( other )  else :                  mins = np . min ( other , axis = 1 ) maxs = np . max ( other , axis = 1 )  return np . all ( mins >= self . min_pt ) and np . all ( maxs <= self . max_pt )  else :              return False   def measure ( self , ndim = None ) :          if self . true_ndim == 0 :              return 0.0  if ndim is None :              return self . measure ( ndim = self . true_ndim )  elif ndim < self . true_ndim :              return np . inf  elif ndim > self . true_ndim :              return 0.0  else :              return np . prod ( self . extent [ self . nondegen_byaxis ] )   def dist ( self , point , exponent = 2.0 ) :          point = np . atleast_1d ( point ) if len ( point ) != self . ndim :              raise ValueError ( <str> <str> . format ( self . ndim , len ( point ) ) )  if np . any ( np . isnan ( point ) ) :              return float ( <str> )  i_larger = np . where ( point > self . max_pt ) i_smaller = np . where ( point < self . min_pt ) if len ( i_larger [ 0 ] ) == 0 and len ( i_smaller [ 0 ] ) == 0 :              return 0.0  else :              proj = np . concatenate ( ( point [ i_larger ] , point [ i_smaller ] ) ) border = np . concatenate ( ( self . max_pt [ i_larger ] , self . min_pt [ i_smaller ] ) ) return np . linalg . norm ( proj - border , ord = exponent )   def collapse ( self , indices , values ) :          indices = np . atleast_1d ( indices ) . astype ( <str> , casting = <str> ) values = np . atleast_1d ( values ) if len ( indices ) != len ( values ) :              raise ValueError ( <str> <str> <str> . format ( indices , values , len ( indices ) , len ( values ) ) )  for axis , index in enumerate ( indices ) :              if not 0 <= index <= self . ndim :                  raise IndexError ( <str> <str> . format ( axis , index , self . ndim - 1 ) )   if np . any ( values < self . min_pt [ indices ] ) :              raise ValueError ( <str> <str> <str> . format ( values , self . min_pt [ indices ] ) )  if np . any ( values > self . max_pt [ indices ] ) :              raise ValueError ( <str> <str> <str> . format ( values , self . max_pt [ indices ] ) )  b_new = self . min_pt . copy ( ) b_new [ indices ] = values e_new = self . max_pt . copy ( ) e_new [ indices ] = values return IntervalProd ( b_new , e_new )  def squeeze ( self ) :          b_new = self . min_pt [ self . nondegen_byaxis ] e_new = self . max_pt [ self . nondegen_byaxis ] return IntervalProd ( b_new , e_new )  def insert ( self , index , * intvs ) :          index , index_in = safe_int_conv ( index ) , index if not - self . ndim <= index <= self . ndim :              raise IndexError ( <str> <str> . format ( index_in , self . ndim ) )  if index < 0 :              index += self . ndim  if len ( intvs ) == 0 :              return IntervalProd ( self . min_pt , self . max_pt )  elif len ( intvs ) == 1 :              intv = intvs [ 0 ] if not isinstance ( intv , IntervalProd ) :                  raise TypeError ( <str> <str> . format ( intv ) )  new_min_pt = np . empty ( self . ndim + intv . ndim ) new_max_pt = np . empty ( self . ndim + intv . ndim ) new_min_pt [ : index ] = self . min_pt [ : index ] new_max_pt [ : index ] = self . max_pt [ : index ] new_min_pt [ index : index + intv . ndim ] = intv . min_pt new_max_pt [ index : index + intv . ndim ] = intv . max_pt if index < self . ndim :                  new_min_pt [ index + intv . ndim : ] = self . min_pt [ index : ] new_max_pt [ index + intv . ndim : ] = self . max_pt [ index : ]  return IntervalProd ( new_min_pt , new_max_pt )  else :              return self . insert ( index , intvs [ 0 ] ) . insert ( index + intvs [ 0 ] . ndim , * ( intvs [ 1 : ] ) )   def append ( self , * intvs ) :          return self . insert ( self . ndim , * intvs )  def corners ( self , order = <str> ) :          from odl . discr . grid import RectGrid minmax_vecs = [ 0 ] * self . ndim for axis in np . where ( ~ self . nondegen_byaxis ) [ 0 ] :              minmax_vecs [ axis ] = self . min_pt [ axis ]  for axis in np . where ( self . nondegen_byaxis ) [ 0 ] :              minmax_vecs [ axis ] = ( self . min_pt [ axis ] , self . max_pt [ axis ] )  minmax_grid = RectGrid ( * minmax_vecs ) return minmax_grid . points ( order = order )  def __len__ ( self ) :          return self . ndim  def __getitem__ ( self , indices ) :          return IntervalProd ( self . min_pt [ indices ] , self . max_pt [ indices ] )  def __pos__ ( self ) :          return self  def __neg__ ( self ) :          return type ( self ) ( - self . max_pt , - self . min_pt )  def __add__ ( self , other ) :          if isinstance ( other , IntervalProd ) :              if self . ndim != other . ndim :                  raise ValueError ( <str> <str> <str> . format ( self , other , self . ndim , other . ndim ) )  return type ( self ) ( self . min_pt + other . min_pt , self . max_pt + other . max_pt )  elif np . isscalar ( other ) :              return type ( self ) ( self . min_pt + other , self . max_pt + other )  else :              return NotImplemented   def __sub__ ( self , other ) :          return self + ( - other )  def __mul__ ( self , other ) :          if isinstance ( other , IntervalProd ) :              if self . ndim != other . ndim :                  raise ValueError ( <str> <str> <str> . format ( self , other , self . ndim , other . ndim ) )  comp_mat = np . empty ( [ self . ndim , 4 ] ) comp_mat [ : , 0 ] = self . min_pt * other . min_pt comp_mat [ : , 1 ] = self . min_pt * other . max_pt comp_mat [ : , 2 ] = self . max_pt * other . min_pt comp_mat [ : , 3 ] = self . max_pt * other . max_pt new_min_pt = np . min ( comp_mat , axis = 1 ) new_max_pt = np . max ( comp_mat , axis = 1 ) return type ( self ) ( new_min_pt , new_max_pt )  elif np . isscalar ( other ) :              vec1 = self . min_pt * other vec2 = self . max_pt * other return type ( self ) ( np . minimum ( vec1 , vec2 ) , np . maximum ( vec1 , vec2 ) )  else :              return NotImplemented   def __div__ ( self , other ) :          return self * ( 1.0 / other )  __truediv__ = __div__ def __rdiv__ ( self , other ) :          if np . isscalar ( other ) :              for axis , ( xmin , xmax ) in enumerate ( zip ( self . min_pt , self . max_pt ) ) :                  if xmin <= 0 and xmax >= 0 :                      raise ValueError ( <str> <str> . format ( axis , [ xmin , xmax ] ) )   vec1 = other / self . min_pt vec2 = other / self . max_pt return type ( self ) ( np . minimum ( vec1 , vec2 ) , np . maximum ( vec1 , vec2 ) )  else :              return NotImplemented   __rtruediv__ = __rdiv__ def __repr__ ( self ) :          if self . ndim == 1 :              return <str> . format ( self . __class__ . __name__ , self . min_pt [ 0 ] , self . max_pt [ 0 ] )  else :              return <str> . format ( self . __class__ . __name__ , array_str ( self . min_pt ) , array_str ( self . max_pt ) )   def __str__ ( self ) :          return <str> . join ( <str> . format ( xmin , xmax ) for xmin , xmax in zip ( self . min_pt , self . max_pt ) )   if __name__ == <str> :      from odl . util . testutils import run_doctests run_doctests ( )   