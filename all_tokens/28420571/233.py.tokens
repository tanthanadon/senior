from __future__ import division import numpy as np import os import dicom import odl import tqdm from dicom . datadict import DicomDictionary , NameDict , CleanName from odl . contrib . datasets . ct . mayo_dicom_dict import new_dict_items DicomDictionary . update ( new_dict_items ) NameDict . update ( ( CleanName ( tag ) , tag ) for tag in new_dict_items ) __all__ = ( <str> , <str> ) def _read_projections ( folder , indices ) :      datasets = [ ] file_names = sorted ( [ f for f in os . listdir ( folder ) if f . endswith ( <str> ) ] ) if len ( file_names ) == 0 :          raise ValueError ( <str> . format ( folder ) )  file_names = file_names [ indices ] data_array = None for i , file_name in enumerate ( tqdm . tqdm ( file_names , <str> ) ) :          dataset = dicom . read_file ( folder + <str> + file_name ) rows = dataset . NumberofDetectorRows cols = dataset . NumberofDetectorColumns hu_factor = dataset . HUCalibrationFactor rescale_intercept = dataset . RescaleIntercept rescale_slope = dataset . RescaleSlope proj_array = np . array ( np . frombuffer ( dataset . PixelData , <str> ) , dtype = <str> ) proj_array = proj_array . reshape ( [ rows , cols ] , order = <str> ) . T proj_array *= rescale_slope proj_array += rescale_intercept proj_array /= hu_factor if data_array is None :              data_array = np . empty ( ( len ( file_names ) , cols , rows ) , dtype = <str> )  data_array [ i ] = proj_array [ : , : : - 1 ] datasets . append ( dataset )  return datasets , data_array  def load_projections ( folder , indices = None ) :      datasets , data_array = _read_projections ( folder , indices ) angles = [ d . DetectorFocalCenterAngularPosition for d in datasets ] angles = - np . unwrap ( angles ) - np . pi shape = np . array ( [ datasets [ 0 ] . NumberofDetectorColumns , datasets [ 0 ] . NumberofDetectorRows ] ) pixel_size = np . array ( [ datasets [ 0 ] . DetectorElementTransverseSpacing , datasets [ 0 ] . DetectorElementAxialSpacing ] ) minp = - ( np . array ( datasets [ 0 ] . DetectorCentralElement ) - 0.5 ) * pixel_size maxp = minp + shape * pixel_size src_radius = datasets [ 0 ] . DetectorFocalCenterRadialDistance det_radius = ( datasets [ 0 ] . ConstantRadialDistance - datasets [ 0 ] . DetectorFocalCenterRadialDistance ) pitch = ( ( datasets [ - 1 ] . DetectorFocalCenterAxialPosition - datasets [ 0 ] . DetectorFocalCenterAxialPosition ) / ( ( np . max ( angles ) - np . min ( angles ) ) / ( 2 * np . pi ) ) ) offset_axial = np . array ( [ d . SourceAxialPositionShift for d in datasets ] ) offset_angular = np . array ( [ d . SourceAngularPositionShift for d in datasets ] ) offset_radial = np . array ( [ d . SourceRadialDistanceShift for d in datasets ] ) angles = angles - offset_angular offset_detector_by_angles = det_radius * np . mean ( offset_angular ) minp [ 0 ] -= offset_detector_by_angles maxp [ 0 ] -= offset_detector_by_angles src_radius = src_radius + np . mean ( offset_radial ) mean_offset_along_axis_for_ffz = np . mean ( offset_axial ) * ( src_radius / ( src_radius + det_radius ) ) detector_partition = odl . uniform_partition ( minp , maxp , shape ) offset_along_axis = ( mean_offset_along_axis_for_ffz + datasets [ 0 ] . DetectorFocalCenterAxialPosition - angles [ 0 ] / ( 2 * np . pi ) * pitch ) angle_partition = odl . nonuniform_partition ( angles ) geometry = odl . tomo . ConeFlatGeometry ( angle_partition , detector_partition , src_radius = src_radius , det_radius = det_radius , pitch = pitch , offset_along_axis = offset_along_axis ) spc = odl . uniform_discr ( [ - 1 ] * 3 , [ 1 ] * 3 , [ 32 ] * 3 ) ray_trafo = odl . tomo . RayTransform ( spc , geometry , interp = <str> ) theta , up , vp = ray_trafo . range . grid . meshgrid d = src_radius + det_radius u = d * np . arctan ( up / d ) v = d / np . sqrt ( d ** 2 + up ** 2 ) * vp proj_data_cylinder = ray_trafo . range . element ( data_array ) interpolated_values = proj_data_cylinder . interpolation ( ( theta , u , v ) ) proj_data = ray_trafo . range . element ( interpolated_values ) return geometry , proj_data . asarray ( )  def load_reconstruction ( folder , slice_start = 0 , slice_end = - 1 ) :      file_names = sorted ( [ f for f in os . listdir ( folder ) if f . endswith ( <str> ) ] ) if len ( file_names ) == 0 :          raise ValueError ( <str> . format ( folder ) )  volumes = [ ] datasets = [ ] file_names = file_names [ slice_start : slice_end ] for file_name in tqdm . tqdm ( file_names , <str> ) :          dataset = dicom . read_file ( folder + <str> + file_name ) pixel_size = np . array ( dataset . PixelSpacing ) pixel_thickness = float ( dataset . SliceThickness ) rows = dataset . Rows cols = dataset . Columns data_array = np . array ( np . frombuffer ( dataset . PixelData , <str> ) , dtype = <str> ) data_array = data_array . reshape ( [ cols , rows ] , order = <str> ) data_array = np . rot90 ( data_array , - 1 ) hu_values = ( dataset . RescaleSlope * data_array + dataset . RescaleIntercept ) densities = ( hu_values + 1000 ) / 1000 volumes . append ( densities ) datasets . append ( dataset )  voxel_size = np . array ( list ( pixel_size ) + [ pixel_thickness ] ) shape = np . array ( [ rows , cols , len ( volumes ) ] ) mid_pt = ( np . array ( dataset . ReconstructionTargetCenterPatient ) - np . array ( dataset . DataCollectionCenterPatient ) ) reconstruction_size = ( voxel_size * shape ) min_pt = mid_pt - reconstruction_size / 2 max_pt = mid_pt + reconstruction_size / 2 min_pt [ 1 ] , max_pt [ 1 ] = - max_pt [ 1 ] , - min_pt [ 1 ] if len ( datasets ) > 1 :          slice_distance = np . abs ( float ( datasets [ 1 ] . DataCollectionCenterPatient [ 2 ] ) - float ( datasets [ 0 ] . DataCollectionCenterPatient [ 2 ] ) )  else :          slice_distance = pixel_thickness  min_pt [ 2 ] = - np . array ( datasets [ 0 ] . DataCollectionCenterPatient ) [ 2 ] min_pt [ 2 ] -= 0.5 * slice_distance max_pt [ 2 ] = - np . array ( datasets [ - 1 ] . DataCollectionCenterPatient ) [ 2 ] max_pt [ 2 ] += 0.5 * slice_distance partition = odl . uniform_partition ( min_pt , max_pt , shape ) volume = np . transpose ( np . array ( volumes ) , ( 1 , 2 , 0 ) ) return partition , volume  if __name__ == <str> :      from odl . util . testutils import run_doctests run_doctests ( )   