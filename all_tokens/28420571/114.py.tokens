from __future__ import print_function , division , absolute_import import numpy as np from odl . discr import DiscreteLp from odl . phantom . geometric import ellipsoid_phantom __all__ = ( <str> , <str> , <str> ) def _shepp_logan_ellipse_2d ( ) :      rad18 = np . deg2rad ( 18.0 ) return [ [ 2.00 , .6900 , .9200 , 0.0000 , 0.0000 , 0 ] , [ - .98 , .6624 , .8740 , 0.0000 , - .0184 , 0 ] , [ - .02 , .1100 , .3100 , 0.2200 , 0.0000 , - rad18 ] , [ - .02 , .1600 , .4100 , - .2200 , 0.0000 , rad18 ] , [ 0.01 , .2100 , .2500 , 0.0000 , 0.3500 , 0 ] , [ 0.01 , .0460 , .0460 , 0.0000 , 0.1000 , 0 ] , [ 0.01 , .0460 , .0460 , 0.0000 , - .1000 , 0 ] , [ 0.01 , .0460 , .0230 , - .0800 , - .6050 , 0 ] , [ 0.01 , .0230 , .0230 , 0.0000 , - .6060 , 0 ] , [ 0.01 , .0230 , .0460 , 0.0600 , - .6050 , 0 ] ]  def _shepp_logan_ellipsoids_3d ( ) :      rad18 = np . deg2rad ( 18.0 ) return [ [ 2.00 , .6900 , .9200 , .810 , 0.0000 , 0.0000 , 0.00 , 0.0 , 0 , 0 ] , [ - .98 , .6624 , .8740 , .780 , 0.0000 , - .0184 , 0.00 , 0.0 , 0 , 0 ] , [ - .02 , .1100 , .3100 , .220 , 0.2200 , 0.0000 , 0.00 , - rad18 , 0 , 0 ] , [ - .02 , .1600 , .4100 , .280 , - .2200 , 0.0000 , 0.00 , rad18 , 0 , 0 ] , [ 0.01 , .2100 , .2500 , .410 , 0.0000 , 0.3500 , 0.00 , 0.0 , 0 , 0 ] , [ 0.01 , .0460 , .0460 , .050 , 0.0000 , 0.1000 , 0.00 , 0.0 , 0 , 0 ] , [ 0.01 , .0460 , .0460 , .050 , 0.0000 , - .1000 , 0.00 , 0.0 , 0 , 0 ] , [ 0.01 , .0460 , .0230 , .050 , - .0800 , - .6050 , 0.00 , 0.0 , 0 , 0 ] , [ 0.01 , .0230 , .0230 , .020 , 0.0000 , - .6060 , 0.00 , 0.0 , 0 , 0 ] , [ 0.01 , .0230 , .0460 , .020 , 0.0600 , - .6050 , 0.00 , 0.0 , 0 , 0 ] ]  def _modified_shepp_logan_ellipsoids ( ellipsoids ) :      intensities = [ 1.0 , - 0.8 , - 0.2 , - 0.2 , 0.1 , 0.1 , 0.1 , 0.1 , 0.1 , 0.1 ] intensities [ 2 ] += 5e-17 intensities [ 3 ] += 5e-17 assert len ( ellipsoids ) == len ( intensities ) for ellipsoid , intensity in zip ( ellipsoids , intensities ) :          ellipsoid [ 0 ] = intensity   def shepp_logan_ellipsoids ( ndim , modified = False ) :      if ndim == 2 :          ellipsoids = _shepp_logan_ellipse_2d ( )  elif ndim == 3 :          ellipsoids = _shepp_logan_ellipsoids_3d ( )  else :          raise ValueError ( <str> )  if modified :          _modified_shepp_logan_ellipsoids ( ellipsoids )  return ellipsoids  def shepp_logan ( space , modified = False , min_pt = None , max_pt = None ) :      ellipsoids = shepp_logan_ellipsoids ( space . ndim , modified ) return ellipsoid_phantom ( space , ellipsoids , min_pt , max_pt )  def _analytical_forbild_phantom ( resolution , ear ) :      sha = 0.2 * np . sqrt ( 3 ) y016b = - 14.294530834372887 a16b = 0.443194085308632 b16b = 3.892760834372886 E = [ [ - 4.7 , 4.3 , 1.79989 , 1.79989 , 0 , 0.010 , 0 ] , [ 4.7 , 4.3 , 1.79989 , 1.79989 , 0 , 0.010 , 0 ] , [ - 1.08 , - 9 , 0.4 , 0.4 , 0 , 0.0025 , 0 ] , [ 1.08 , - 9 , 0.4 , 0.4 , 0 , - 0.0025 , 0 ] , [ 0 , 0 , 9.6 , 12 , 0 , 1.800 , 0 ] , [ 0 , 8.4 , 1.8 , 3.0 , 0 , - 1.050 , 0 ] , [ 1.9 , 5.4 , 0.41633 , 1.17425 , - 31.07698 , 0.750 , 0 ] , [ - 1.9 , 5.4 , 0.41633 , 1.17425 , 31.07698 , 0.750 , 0 ] , [ - 4.3 , 6.8 , 1.8 , 0.24 , - 30 , 0.750 , 0 ] , [ 4.3 , 6.8 , 1.8 , 0.24 , 30 , 0.750 , 0 ] , [ 0 , - 3.6 , 1.8 , 3.6 , 0 , - 0.005 , 0 ] , [ 6.39395 , - 6.39395 , 1.2 , 0.42 , 58.1 , 0.005 , 0 ] , [ 0 , 3.6 , 2 , 2 , 0 , 0.750 , 4 ] , [ 0 , 9.6 , 1.8 , 3.0 , 0 , 1.800 , 4 ] , [ 0 , 0 , 9.0 , 11.4 , 0 , 0.750 , 3 ] , [ 0 , y016b , a16b , b16b , 0 , 0.750 , 1 ] , [ 0 , 0 , 9.0 , 11.4 , 0 , - 0.750 , ear ] , [ 9.1 , 0 , 4.2 , 1.8 , 0 , 0.750 , 1 ] ] E = np . array ( E ) cavity1 = np . arange ( 8.8 , 5.6 , - 0.4 ) [ : , None ] cavity2 = np . zeros ( [ 9 , 1 ] ) cavity3_7 = np . ones ( [ 53 , 1 ] ) * [ 0.15 , 0.15 , 0 , - 1.800 , 0 ] for j in range ( 1 , 4 ) :          kj = 8 - 2 * int ( np . floor ( j / 3 ) ) dj = 0.2 * int ( np . mod ( j , 2 ) ) cavity1 = np . vstack ( ( cavity1 , cavity1 [ 0 : kj ] - dj , cavity1 [ 0 : kj ] - dj ) ) cavity2 = np . vstack ( ( cavity2 , j * sha * np . ones ( [ kj , 1 ] ) , - j * sha * np . ones ( [ kj , 1 ] ) ) )  E_cavity = np . hstack ( ( cavity1 , cavity2 , cavity3_7 ) ) x0 = - 7.0 y0 = - 1.0 d0_xy = 0.04 d_xy = [ 0.0357 , 0.0312 , 0.0278 , 0.0250 ] ab = 0.5 * np . ones ( [ 5 , 1 ] ) * d_xy ab = ab . T . ravel ( ) [ : , None ] * np . ones ( [ 1 , 4 ] ) abr = ab . T . ravel ( ) [ : , None ] leftear4_7 = np . hstack ( [ abr , abr , np . ones ( [ 80 , 1 ] ) * [ 0 , 0.75 , 0 ] ] ) x00 = np . zeros ( [ 0 , 1 ] ) y00 = np . zeros ( [ 0 , 1 ] ) for i in range ( 1 , 5 ) :          y00 = np . vstack ( ( y00 , ( y0 + np . arange ( 0 , 5 ) * 2 * d_xy [ i - 1 ] ) [ : , None ] ) ) x00 = np . vstack ( ( x00 , ( x0 + 2 * ( i - 1 ) * d0_xy ) * np . ones ( [ 5 , 1 ] ) ) )  x00 = x00 * np . ones ( [ 1 , 4 ] ) x00 = x00 . T . ravel ( ) [ : , None ] y00 = np . vstack ( [ y00 , y00 + 12 * d0_xy , y00 + 24 * d0_xy , y00 + 36 * d0_xy ] ) leftear = np . hstack ( [ x00 , y00 , leftear4_7 ] ) C = [ [ 1.2 , 1.2 , 0.27884 , 0.27884 , 0.60687 , 0.60687 , 0.2 , 0.2 , - 2.605 , - 2.605 , - 10.71177 , y016b + 10.71177 , 8.88740 , - 0.21260 ] , [ 0 , 180 , 90 , 270 , 90 , 270 , 0 , 180 , 15 , 165 , 90 , 270 , 0 , 0 ] ] C = np . array ( C ) if not resolution and not ear :          phantomE = E [ : 17 , : ] phantomC = C [ : , : 12 ]  elif not resolution and ear :          phantomE = np . vstack ( [ E , E_cavity ] ) phantomC = C  elif resolution and not ear :          phantomE = np . vstack ( [ leftear , E [ : 17 , : ] ] ) phantomC = C [ : , : 12 ]  else :          phantomE = np . vstack ( [ leftear , E , E_cavity ] ) phantomC = C  return phantomE , phantomC  def forbild ( space , resolution = False , ear = True , value_type = <str> , scale = <str> ) :      def transposeravel ( arr ) :          return arr . T . ravel ( )  if not isinstance ( space , DiscreteLp ) :          raise TypeError ( <str> )  if space . ndim != 2 :          raise TypeError ( <str> )  scale , scale_in = str ( scale ) . lower ( ) , scale value_type , value_type_in = str ( value_type ) . lower ( ) , value_type phantomE , phantomC = _analytical_forbild_phantom ( resolution , ear ) xcoord , ycoord = space . points ( ) . T if scale == <str> :          xcoord = ( ( xcoord - space . min_pt [ 0 ] ) / ( space . max_pt [ 0 ] - space . min_pt [ 0 ] ) ) xcoord = 25.8 * xcoord - 12.8 ycoord = ( ( ycoord - space . min_pt [ 1 ] ) / ( space . max_pt [ 1 ] - space . min_pt [ 1 ] ) ) ycoord = 25.8 * ycoord - 12.8  elif scale == <str> :          pass  elif scale == <str> :          xcoord *= 100.0 ycoord *= 100.0  elif scale == <str> :          xcoord /= 10.0 ycoord /= 10.0  else :          raise ValueError ( <str> . format ( scale_in ) )  image = np . zeros ( space . size ) nclipinfo = 0 for k in range ( phantomE . shape [ 0 ] ) :          Vx0 = np . array ( [ transposeravel ( xcoord ) - phantomE [ k , 0 ] , transposeravel ( ycoord ) - phantomE [ k , 1 ] ] ) D = np . array ( [ [ 1 / phantomE [ k , 2 ] , 0 ] , [ 0 , 1 / phantomE [ k , 3 ] ] ] ) phi = np . deg2rad ( phantomE [ k , 4 ] ) Q = np . array ( [ [ np . cos ( phi ) , np . sin ( phi ) ] , [ - np . sin ( phi ) , np . cos ( phi ) ] ] ) f = phantomE [ k , 5 ] nclip = int ( phantomE [ k , 6 ] ) equation1 = np . sum ( D . dot ( Q ) . dot ( Vx0 ) ** 2 , axis = 0 ) i = ( equation1 <= 1.0 ) for _ in range ( nclip ) :              d = phantomC [ 0 , nclipinfo ] psi = np . deg2rad ( phantomC [ 1 , nclipinfo ] ) equation2 = np . array ( [ np . cos ( psi ) , np . sin ( psi ) ] ) . dot ( Vx0 ) i &= ( equation2 < d ) nclipinfo += 1  image [ i ] += f  if value_type == <str> :          materials = np . zeros ( space . size , dtype = space . dtype ) materials [ ( image > 1.043 ) & ( image <= 1.047 ) ] = 1 materials [ ( image > 1.047 ) & ( image <= 1.048 ) ] = 2 materials [ ( image > 1.048 ) & ( image <= 1.052 ) ] = 3 materials [ ( image > 1.052 ) & ( image <= 1.053 ) ] = 4 materials [ ( image > 1.053 ) & ( image <= 1.058 ) ] = 5 materials [ ( image > 1.058 ) & ( image <= 1.062 ) ] = 6 materials [ image > 1.75 ] = 7 return space . element ( materials . reshape ( space . shape ) )  elif value_type == <str> :          return space . element ( image . reshape ( space . shape ) )  else :          raise ValueError ( <str> . format ( value_type_in ) )   if __name__ == <str> :      import odl from odl . util . testutils import run_doctests discr = odl . uniform_discr ( [ - 1 , - 1 ] , [ 1 , 1 ] , [ 1000 , 1000 ] ) shepp_logan ( discr , modified = True ) . show ( <str> ) shepp_logan ( discr , modified = False ) . show ( <str> ) forbild ( discr ) . show ( <str> , clim = [ 1.035 , 1.065 ] ) forbild ( discr , value_type = <str> ) . show ( <str> ) discr = odl . uniform_discr ( [ - 1 , - 1 , - 1 ] , [ 1 , 1 , 1 ] , [ 300 , 300 , 300 ] ) shepp_logan ( discr , modified = True ) . show ( <str> ) shepp_logan ( discr , modified = False ) . show ( <str> ) run_doctests ( )   