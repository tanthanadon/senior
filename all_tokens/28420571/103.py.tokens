 from __future__ import print_function , division , absolute_import from builtins import object from future . moves . itertools import zip_longest import numpy as np import sys import os import warnings from time import time from packaging import version from odl . util . utility import run_from_ipython , is_string __all__ = ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) def _ndigits ( a , b , default = None ) :      dtype1 = getattr ( a , <str> , object ) dtype2 = getattr ( b , <str> , object ) return min ( dtype_ndigits ( dtype1 , default ) , dtype_ndigits ( dtype2 , default ) )  def dtype_ndigits ( dtype , default = None ) :      small_dtypes = [ np . float32 , np . complex64 ] tiny_dtypes = [ np . float16 ] if dtype in tiny_dtypes :          return 1  elif dtype in small_dtypes :          return 3  else :          return default if default is not None else 5   def dtype_tol ( dtype , default = None ) :      return 10 ** - dtype_ndigits ( dtype , default )  def all_equal ( iter1 , iter2 ) :      try :          if iter1 == iter2 :              return True   except ValueError :          pass  if iter1 is None and iter2 is None :          return True  try :          it1 = iter ( iter1 ) it2 = iter ( iter2 )  except TypeError :          try :              return iter1 == iter2  except ValueError :              return False   diff_length_sentinel = object ( ) for [ ip1 , ip2 ] in zip_longest ( it1 , it2 , fillvalue = diff_length_sentinel ) :          if ip1 is diff_length_sentinel or ip2 is diff_length_sentinel :              return False  if not all_equal ( ip1 , ip2 ) :              return False   return True  def all_almost_equal_array ( v1 , v2 , ndigits ) :      return np . allclose ( v1 , v2 , rtol = 10 ** - ndigits , atol = 10 ** - ndigits , equal_nan = True )  def all_almost_equal ( iter1 , iter2 , ndigits = None ) :      try :          if iter1 is iter2 or iter1 == iter2 :              return True   except ValueError :          pass  if iter1 is None and iter2 is None :          return True  if hasattr ( iter1 , <str> ) and hasattr ( iter2 , <str> ) :          if ndigits is None :              ndigits = _ndigits ( iter1 , iter2 , None )  return all_almost_equal_array ( iter1 , iter2 , ndigits )  try :          it1 = iter ( iter1 ) it2 = iter ( iter2 )  except TypeError :          if ndigits is None :              ndigits = _ndigits ( iter1 , iter2 , None )  return np . isclose ( iter1 , iter2 , atol = 10 ** - ndigits , rtol = 10 ** - ndigits , equal_nan = True )  diff_length_sentinel = object ( ) for [ ip1 , ip2 ] in zip_longest ( it1 , it2 , fillvalue = diff_length_sentinel ) :          if ip1 is diff_length_sentinel or ip2 is diff_length_sentinel :              return False  if not all_almost_equal ( ip1 , ip2 , ndigits ) :              return False   return True  def is_subdict ( subdict , dictionary ) :      return all ( item in dictionary . items ( ) for item in subdict . items ( ) )  try :      import pytest  except ImportError :      def _pass ( function ) :          return function  never_skip = _pass skip_if_no_pywavelets = _pass skip_if_no_pyfftw = _pass skip_if_no_largescale = _pass skip_if_no_benchmark = _pass  else :      never_skip = pytest . mark . skipif ( <str> , reason = <str> ) skip_if_no_pywavelets = pytest . mark . skipif ( <str> , reason = <str> ) skip_if_no_pyfftw = pytest . mark . skipif ( <str> , reason = <str> ) skip_if_no_largescale = pytest . mark . skipif ( <str> , reason = <str> ) skip_if_no_benchmark = pytest . mark . skipif ( <str> , reason = <str> )  def simple_fixture ( name , params , fmt = None ) :      import _pytest if fmt is None :          fmt_str = <str> fmt_default = <str> ids = [ ] for p in params :              if ( isinstance ( p , _pytest . mark . MarkDecorator ) and p . name == <str> ) :                  if is_string ( p . args [ 1 ] ) :                      ids . append ( fmt_str . format ( name = name , value = p . args [ 1 ] ) )  else :                      ids . append ( fmt_default . format ( name = name , value = p . args [ 1 ] ) )   else :                  if is_string ( p ) :                      ids . append ( fmt_str . format ( name = name , value = p ) )  else :                      ids . append ( fmt_default . format ( name = name , value = p ) )     else :          ids = [ fmt . format ( name = name , value = p ) for p in params ]  wrapper = pytest . fixture ( scope = <str> , ids = ids , params = params ) return wrapper ( lambda request : request . param )  def noise_array ( space ) :      from odl . space import ProductSpace if isinstance ( space , ProductSpace ) :          return np . array ( [ noise_array ( si ) for si in space ] )  else :          if space . dtype == bool :              arr = np . random . randint ( 0 , 2 , size = space . shape ) . astype ( bool )  elif np . issubdtype ( space . dtype , np . unsignedinteger ) :              arr = np . random . randint ( 0 , 10 , space . shape )  elif np . issubdtype ( space . dtype , np . signedinteger ) :              arr = np . random . randint ( - 10 , 10 , space . shape )  elif np . issubdtype ( space . dtype , np . floating ) :              arr = np . random . randn ( * space . shape )  elif np . issubdtype ( space . dtype , np . complexfloating ) :              arr = ( np . random . randn ( * space . shape ) + 1j * np . random . randn ( * space . shape ) ) / np . sqrt ( 2.0 )  else :              raise ValueError ( <str> . format ( space . dtype ) )  return arr . astype ( space . dtype , copy = False )   def noise_element ( space ) :      return space . element ( noise_array ( space ) )  def noise_elements ( space , n = 1 ) :      arrs = tuple ( noise_array ( space ) for _ in range ( n ) ) elems = tuple ( space . element ( arr . copy ( ) ) for arr in arrs ) if n == 1 :          return tuple ( arrs + elems )  else :          return arrs , elems   class FailCounter ( object ) :      def __init__ ( self , test_name , err_msg = None , logger = print ) :          self . num_failed = 0 self . test_name = test_name self . err_msg = err_msg self . fail_strings = [ ] self . log = logger  def __enter__ ( self ) :          return self  def fail ( self , string = None ) :          self . num_failed += 1 if string is not None :              self . fail_strings += [ str ( string ) ]   def __exit__ ( self , type , value , traceback ) :          if self . num_failed == 0 :              self . log ( <str> <str> . format ( self . test_name ) )  else :              print ( self . test_name ) for fail_string in self . fail_strings :                  print ( fail_string )  if self . err_msg is not None :                  print ( self . err_msg )  print ( <str> . format ( self . num_failed ) )    class Timer ( object ) :      def __init__ ( self , name = None ) :          if name is not None :              self . name = name  else :              self . name = <str>  self . tstart = None  def __enter__ ( self ) :          self . tstart = time ( )  def __exit__ ( self , type , value , traceback ) :          time_str = <str> . format ( time ( ) - self . tstart ) print ( <str> . format ( self . name , time_str ) )   def timeit ( arg ) :      if callable ( arg ) :          def timed_function ( * args , ** kwargs ) :              with Timer ( str ( arg ) ) :                  return arg ( * args , ** kwargs )   return timed_function  else :          def _timeit_helper ( func ) :              def timed_function ( * args , ** kwargs ) :                  with Timer ( arg ) :                      return func ( * args , ** kwargs )   return timed_function  return _timeit_helper   class ProgressBar ( object ) :      def __init__ ( self , text = <str> , * njobs ) :          self . text = str ( text ) if len ( njobs ) == 0 :              raise ValueError ( <str> )  self . njobs = njobs self . current_progress = 0.0 self . index = 0 self . done = False self . start ( )  def start ( self ) :          sys . stdout . write ( <str> . format ( self . text , <str> * 30 ) ) sys . stdout . flush ( )  def update ( self , * indices ) :          if indices :              if len ( indices ) != len ( self . njobs ) :                  raise ValueError ( <str> )  self . index = np . ravel_multi_index ( indices , self . njobs ) + 1  else :              self . index += 1  progress = self . index / np . prod ( self . njobs ) if progress < 1.0 :              if progress > self . current_progress + 0.001 :                  sys . stdout . write ( <str> . format ( self . text , <str> * int ( 30 * progress ) , 100 * progress ) ) self . current_progress = progress   else :              if not self . done :                  sys . stdout . write ( <str> . format ( self . text , <str> * 30 ) ) self . done = True   sys . stdout . flush ( )   class ProgressRange ( object ) :      def __init__ ( self , text , n ) :          self . current = 0 self . n = n self . bar = ProgressBar ( text , n )  def __iter__ ( self ) :          return self  def __next__ ( self ) :          if self . current < self . n :              val = self . current self . current += 1 self . bar . update ( ) return val  else :              raise StopIteration ( )    def test ( arguments = None ) :      try :          import pytest  except ImportError :          raise ImportError ( <str> <str> <str> )  if version . parse ( pytest . __version__ ) >= version . parse ( <str> ) :          raise RuntimeError ( <str> <str> <str> <str> )  from . pytest_plugins import collect_ignore this_dir = os . path . dirname ( __file__ ) odl_root = os . path . abspath ( os . path . join ( this_dir , os . pardir , os . pardir ) ) args = [ <str> , <str> . format ( root = odl_root ) ] ignores = [ <str> . format ( file ) for file in collect_ignore ] args . extend ( ignores ) if arguments is not None :          args . extend ( arguments )  pytest . main ( args )  def run_doctests ( skip_if = False , ** kwargs ) :      from doctest import testmod , NORMALIZE_WHITESPACE , SKIP from packaging . version import parse as parse_version import odl import numpy as np optionflags = kwargs . pop ( <str> , NORMALIZE_WHITESPACE ) if skip_if :          optionflags |= SKIP  extraglobs = kwargs . pop ( <str> , { <str> : odl , <str> : np } ) if run_from_ipython ( ) :          try :              import spyder  except ImportError :              pass  else :              if parse_version ( spyder . __version__ ) < parse_version ( <str> ) :                  warnings . warn ( <str> <str> <str> <str> , RuntimeWarning )    testmod ( optionflags = optionflags , extraglobs = extraglobs , ** kwargs )  def test_file ( file , args = None ) :      try :          import pytest  except ImportError :          raise ImportError ( <str> <str> <str> )  if args is None :          args = [ ]  args . extend ( [ str ( file . replace ( <str> , <str> ) ) , <str> , <str> ] ) pytest . main ( args )  if __name__ == <str> :      run_doctests ( )   