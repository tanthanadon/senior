from __future__ import division import numpy as np import pytest from packaging . version import parse as parse_version import odl from odl . tomo . util . testutils import ( skip_if_no_astra , skip_if_no_astra_cuda , skip_if_no_skimage ) from odl . util . testutils import simple_fixture , skip_if_no_largescale pytestmark = skip_if_no_largescale dtype_params = [ <str> , <str> , <str> ] dtype = simple_fixture ( <str> , dtype_params ) projectors = [ ] projectors . extend ( ( pytest . param ( proj_cfg , marks = skip_if_no_astra ) for proj_cfg in [ <str> , <str> , <str> , <str> , <str> , <str> ] ) ) projectors . extend ( ( pytest . param ( proj_cfg , marks = skip_if_no_astra_cuda ) for proj_cfg in [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] ) ) projectors . extend ( ( pytest . param ( proj_cfg , marks = skip_if_no_skimage ) for proj_cfg in [ <str> ] ) ) projector_ids = [ <str> . format ( * p . values [ 0 ] . split ( ) ) for p in projectors ] weighting = simple_fixture ( <str> , [ None , 1.0 ] ) @ pytest . fixture ( scope = <str> , params = projectors , ids = projector_ids ) def projector ( request , dtype , weighting ) :      n_angles = 200 geom , impl , angles = request . param . split ( ) if angles == <str> :          apart = odl . uniform_partition ( 0 , 2 * np . pi , n_angles )  elif angles == <str> :          min_pt = 2 * ( 2.0 * np . pi ) / n_angles max_pt = ( 2.0 * np . pi ) - 2 * ( 2.0 * np . pi ) / n_angles points = np . linspace ( min_pt , max_pt , n_angles ) points += np . random . rand ( n_angles ) * ( max_pt - min_pt ) / ( 5 * n_angles ) apart = odl . nonuniform_partition ( points )  elif angles == <str> :          min_pt = 2 * ( 2.0 * np . pi ) / n_angles max_pt = ( 2.0 * np . pi ) - 2 * ( 2.0 * np . pi ) / n_angles points = np . linspace ( min_pt ** 0.5 , max_pt ** 0.5 , n_angles ) ** 2 apart = odl . nonuniform_partition ( points )  else :          assert False  if geom == <str> :          reco_space = odl . uniform_discr ( [ - 20 , - 20 ] , [ 20 , 20 ] , [ 100 , 100 ] , dtype = dtype , weighting = weighting ) dpart = odl . uniform_partition ( - 30 , 30 , 200 ) geom = odl . tomo . Parallel2dGeometry ( apart , dpart ) return odl . tomo . RayTransform ( reco_space , geom , impl = impl )  elif geom == <str> :          reco_space = odl . uniform_discr ( [ - 20 , - 20 , - 20 ] , [ 20 , 20 , 20 ] , [ 100 , 100 , 100 ] , dtype = dtype , weighting = weighting ) dpart = odl . uniform_partition ( [ - 30 , - 30 ] , [ 30 , 30 ] , [ 200 , 200 ] ) geom = odl . tomo . Parallel3dAxisGeometry ( apart , dpart , axis = [ 1 , 0 , 0 ] ) return odl . tomo . RayTransform ( reco_space , geom , impl = impl )  elif geom == <str> :          reco_space = odl . uniform_discr ( [ - 20 , - 20 ] , [ 20 , 20 ] , [ 100 , 100 ] , dtype = dtype ) dpart = odl . uniform_partition ( - 30 , 30 , 200 ) geom = odl . tomo . FanBeamGeometry ( apart , dpart , src_radius = 200 , det_radius = 100 ) return odl . tomo . RayTransform ( reco_space , geom , impl = impl )  elif geom == <str> :          reco_space = odl . uniform_discr ( [ - 20 , - 20 , - 20 ] , [ 20 , 20 , 20 ] , [ 100 , 100 , 100 ] , dtype = dtype ) dpart = odl . uniform_partition ( [ - 30 , - 30 ] , [ 30 , 30 ] , [ 200 , 200 ] ) geom = odl . tomo . ConeBeamGeometry ( apart , dpart , src_radius = 200 , det_radius = 100 , axis = [ 1 , 0 , 0 ] ) return odl . tomo . RayTransform ( reco_space , geom , impl = impl )  elif geom == <str> :          reco_space = odl . uniform_discr ( [ - 20 , - 20 , 0 ] , [ 20 , 20 , 40 ] , [ 100 , 100 , 100 ] , dtype = dtype ) n_angles = 700 apart = odl . uniform_partition ( 0 , 8 * 2 * np . pi , n_angles ) dpart = odl . uniform_partition ( [ - 30 , - 3 ] , [ 30 , 3 ] , [ 200 , 20 ] ) geom = odl . tomo . ConeBeamGeometry ( apart , dpart , pitch = 5.0 , src_radius = 200 , det_radius = 100 ) return odl . tomo . RayTransform ( reco_space , geom , impl = impl )  else :          raise ValueError ( <str> )   def test_adjoint ( projector ) :      if ( parse_version ( odl . tomo . ASTRA_VERSION ) < parse_version ( <str> ) and isinstance ( projector . geometry , odl . tomo . ConeBeamGeometry ) ) :          rtol = 0.1  else :          rtol = 0.05  vol = odl . phantom . shepp_logan ( projector . domain , modified = True ) proj = projector ( vol ) backproj = projector . adjoint ( proj ) result_AxAx = proj . inner ( proj ) result_xAtAx = backproj . inner ( vol ) assert result_AxAx == pytest . approx ( result_xAtAx , rel = rtol )  def test_adjoint_of_adjoint ( projector ) :      vol = odl . phantom . shepp_logan ( projector . domain , modified = True ) proj = projector ( vol ) proj_adj_adj = projector . adjoint . adjoint ( vol ) assert proj == proj_adj_adj proj_adj = projector . adjoint ( proj ) proj_adj_adj_adj = projector . adjoint . adjoint . adjoint ( proj ) assert proj_adj == proj_adj_adj_adj  def test_reconstruction ( projector ) :      if ( isinstance ( projector . geometry , odl . tomo . ConeBeamGeometry ) and projector . geometry . pitch != 0 ) :          pytest . skip ( <str> )  vol = odl . phantom . shepp_logan ( projector . domain , modified = True ) projections = projector ( vol ) recon = projector . domain . zero ( ) odl . solvers . conjugate_gradient_normal ( projector , recon , projections , niter = 20 ) maxerr = vol . norm ( ) * 0.5 if np . issubsctype ( projector . domain . dtype , np . complexfloating ) :          maxerr *= np . sqrt ( 2 )  assert recon . dist ( vol ) < maxerr  if __name__ == <str> :      odl . util . test_file ( __file__ , [ <str> ] )   