import odl space = odl . uniform_discr ( 0 , 1 , 100 ) pspace = odl . ProductSpace ( space , 2 ) gradient = odl . Gradient ( space , pad_mode = <str> ) pgradient = odl . DiagonalOperator ( gradient , 2 ) data = pspace . element ( [ lambda x : x , lambda x : x > 0.6 ] ) data . show ( <str> ) l2err = odl . solvers . L2NormSquared ( pspace ) . translated ( data ) nuc_norm = 0.02 * odl . solvers . NuclearNorm ( pgradient . range ) lin_ops = [ odl . IdentityOperator ( pspace ) , pgradient ] g = [ l2err , nuc_norm ] f = odl . solvers . ZeroFunctional ( pspace ) func = f + l2err + nuc_norm * pgradient callback = ( odl . solvers . CallbackPrint ( func ) & odl . solvers . CallbackShow ( step = 20 ) ) x = data . copy ( ) odl . solvers . douglas_rachford_pd ( x , f , g , lin_ops , tau = 1e-2 , sigma = [ 1.0 , 1e-3 ] , niter = 2000 , callback = callback ) x . show ( <str> , force_show = True )  