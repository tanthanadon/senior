import odl space = odl . uniform_discr ( min_pt = [ - 20 , - 20 ] , max_pt = [ 20 , 20 ] , shape = [ 128 , 128 ] , dtype = <str> ) geometry = odl . tomo . parallel_beam_geometry ( space ) split = <str> if split == <str> :      n = 20 ns = geometry . angles . size // n ray_trafos = [ odl . tomo . RayTransform ( space , geometry [ i * ns : ( i + 1 ) * ns ] ) for i in range ( n ) ]  elif split == <str> :      n = 20 ray_trafos = [ odl . tomo . RayTransform ( space , geometry [ i : : n ] ) for i in range ( n ) ]  ray_trafo = odl . BroadcastOperator ( * ray_trafos ) phantom = odl . phantom . shepp_logan ( space , modified = True ) data = ray_trafo ( phantom ) omega = n * odl . power_method_opnorm ( ray_trafo ) ** ( - 2 ) callback = ( odl . solvers . CallbackPrintIteration ( ) & odl . solvers . CallbackShow ( ) ) x = space . zero ( ) odl . solvers . kaczmarz ( ray_trafos , x , data , niter = 5 , omega = omega , callback = callback , callback_loop = <str> ) phantom . show ( title = <str> ) x . show ( title = <str> , force_show = True )  