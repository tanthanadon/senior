from __future__ import absolute_import , division , print_function import numpy as np from odl . discr import DiscreteLp , discr_sequence_space from odl . operator import Operator from odl . set import ComplexNumbers , RealNumbers from odl . trafos . backends . pyfftw_bindings import ( PYFFTW_AVAILABLE , _pyfftw_to_local , pyfftw_call ) from odl . trafos . util import ( dft_postprocess_data , dft_preprocess_data , reciprocal_grid , reciprocal_space ) from odl . util import ( complex_dtype , conj_exponent , dtype_repr , is_complex_floating_dtype , is_real_dtype , normalized_axes_tuple , normalized_scalar_param_list ) __all__ = ( <str> , <str> , <str> , <str> ) _SUPPORTED_FOURIER_IMPLS = ( <str> , ) _DEFAULT_FOURIER_IMPL = <str> if PYFFTW_AVAILABLE :      _SUPPORTED_FOURIER_IMPLS += ( <str> , ) _DEFAULT_FOURIER_IMPL = <str>  class DiscreteFourierTransformBase ( Operator ) :      def __init__ ( self , inverse , domain , range = None , axes = None , sign = <str> , halfcomplex = False , impl = None ) :          if not isinstance ( domain , DiscreteLp ) :              raise TypeError ( <str> <str> . format ( domain ) )  if range is not None and not isinstance ( range , DiscreteLp ) :              raise TypeError ( <str> <str> . format ( range ) )  if impl is None :              impl = _DEFAULT_FOURIER_IMPL  impl , impl_in = str ( impl ) . lower ( ) , impl if impl not in _SUPPORTED_FOURIER_IMPLS :              raise ValueError ( <str> . format ( impl_in ) )  self . __impl = impl if axes is None :              axes = tuple ( np . arange ( domain . ndim ) )  self . __axes = normalized_axes_tuple ( axes , domain . ndim ) if domain . field == ComplexNumbers ( ) :              self . __halfcomplex = False  else :              self . __halfcomplex = bool ( halfcomplex )  ran_dtype = complex_dtype ( domain . dtype ) if sign not in ( <str> , <str> ) :              raise ValueError ( <str> . format ( sign ) )  fwd_sign = ( <str> if sign == <str> else <str> ) if inverse else sign if fwd_sign == <str> and self . halfcomplex :              raise ValueError ( <str> <str> )  self . __sign = sign ran_shape = reciprocal_grid ( domain . grid , shift = False , halfcomplex = halfcomplex , axes = axes ) . shape if range is None :              impl = domain . tspace . impl range = discr_sequence_space ( ran_shape , ran_dtype , impl , exponent = conj_exponent ( domain . exponent ) )  else :              if range . shape != ran_shape :                  raise ValueError ( <str> <str> . format ( ran_shape , range . shape ) )  if range . dtype != ran_dtype :                  raise ValueError ( <str> <str> . format ( dtype_repr ( ran_dtype ) , dtype_repr ( range . dtype ) ) )   if inverse :              super ( DiscreteFourierTransformBase , self ) . __init__ ( range , domain , linear = True )  else :              super ( DiscreteFourierTransformBase , self ) . __init__ ( domain , range , linear = True )  self . _fftw_plan = None  def _call ( self , x , out , ** kwargs ) :          if self . impl == <str> :              out [ : ] = self . _call_numpy ( x . asarray ( ) )  else :              out [ : ] = self . _call_pyfftw ( x . asarray ( ) , out . asarray ( ) , ** kwargs )   @ property def impl ( self ) :          return self . __impl  @ property def axes ( self ) :          return self . __axes  @ property def sign ( self ) :          return self . __sign  @ property def halfcomplex ( self ) :          return self . __halfcomplex  @ property def adjoint ( self ) :          if self . domain . exponent == 2.0 and self . range . exponent == 2.0 :              return self . inverse  else :              raise NotImplementedError ( <str> <str> . format ( self . domain . exponent , self . range . exponent ) )   @ property def inverse ( self ) :          raise NotImplementedError ( <str> )  def _call_numpy ( self , x ) :          raise NotImplementedError ( <str> )  def _call_pyfftw ( self , x , out , ** kwargs ) :          assert isinstance ( x , np . ndarray ) assert isinstance ( out , np . ndarray ) kwargs . pop ( <str> , None ) kwargs . pop ( <str> , None ) kwargs . pop ( <str> , None ) flags = list ( _pyfftw_to_local ( flag ) for flag in kwargs . pop ( <str> , ( <str> , ) ) ) try :              flags . remove ( <str> )  except ValueError :              pass  try :              flags . remove ( <str> )  except ValueError :              pass  effort = flags [ 0 ] if flags else <str> direction = <str> if self . sign == <str> else <str> self . _fftw_plan = pyfftw_call ( x , out , direction = direction , axes = self . axes , halfcomplex = self . halfcomplex , planning_effort = effort , fftw_plan = self . _fftw_plan , normalise_idft = False ) return out  def init_fftw_plan ( self , planning_effort = <str> , ** kwargs ) :          if self . impl != <str> :              raise ValueError ( <str> )  x = self . domain . element ( ) y = self . range . element ( ) kwargs . pop ( <str> , None ) direction = <str> if self . sign == <str> else <str> self . _fftw_plan = pyfftw_call ( x . asarray ( ) , y . asarray ( ) , direction = direction , halfcomplex = self . halfcomplex , axes = self . axes , planning_effort = planning_effort , ** kwargs )  def clear_fftw_plan ( self ) :          if self . impl != <str> :              raise ValueError ( <str> )  self . _fftw_plan = None   class DiscreteFourierTransform ( DiscreteFourierTransformBase ) :      def __init__ ( self , domain , range = None , axes = None , sign = <str> , halfcomplex = False , impl = None ) :          super ( DiscreteFourierTransform , self ) . __init__ ( inverse = False , domain = domain , range = range , axes = axes , sign = sign , halfcomplex = halfcomplex , impl = impl )  def _call_numpy ( self , x ) :          assert isinstance ( x , np . ndarray ) if self . halfcomplex :              return np . fft . rfftn ( x , axes = self . axes )  else :              if self . sign == <str> :                  return np . fft . fftn ( x , axes = self . axes )  else :                  return ( np . prod ( np . take ( self . domain . shape , self . axes ) ) * np . fft . ifftn ( x , axes = self . axes ) )    def _call_pyfftw ( self , x , out , ** kwargs ) :          assert isinstance ( x , np . ndarray ) assert isinstance ( out , np . ndarray ) kwargs . pop ( <str> , None ) kwargs . pop ( <str> , None ) kwargs . pop ( <str> , None ) flags = list ( _pyfftw_to_local ( flag ) for flag in kwargs . pop ( <str> , ( <str> , ) ) ) try :              flags . remove ( <str> )  except ValueError :              pass  try :              flags . remove ( <str> )  except ValueError :              pass  effort = flags [ 0 ] if flags else <str> direction = <str> if self . sign == <str> else <str> self . _fftw_plan = pyfftw_call ( x , out , direction = direction , axes = self . axes , halfcomplex = self . halfcomplex , planning_effort = effort , fftw_plan = self . _fftw_plan , normalise_idft = False ) return out  @ property def inverse ( self ) :          sign = <str> if self . sign == <str> else <str> return DiscreteFourierTransformInverse ( domain = self . range , range = self . domain , axes = self . axes , halfcomplex = self . halfcomplex , sign = sign )   class DiscreteFourierTransformInverse ( DiscreteFourierTransformBase ) :      def __init__ ( self , range , domain = None , axes = None , sign = <str> , halfcomplex = False , impl = None ) :          super ( DiscreteFourierTransformInverse , self ) . __init__ ( inverse = True , domain = range , range = domain , axes = axes , sign = sign , halfcomplex = halfcomplex , impl = impl )  def _call_numpy ( self , x ) :          if self . halfcomplex :              return np . fft . irfftn ( x , axes = self . axes )  else :              if self . sign == <str> :                  return np . fft . ifftn ( x , axes = self . axes )  else :                  return ( np . fft . fftn ( x , axes = self . axes ) / np . prod ( np . take ( self . domain . shape , self . axes ) ) )    def _call_pyfftw ( self , x , out , ** kwargs ) :          kwargs . pop ( <str> , None ) kwargs . pop ( <str> , None ) kwargs . pop ( <str> , None ) flags = list ( _pyfftw_to_local ( flag ) for flag in kwargs . pop ( <str> , ( <str> , ) ) ) try :              flags . remove ( <str> )  except ValueError :              pass  try :              flags . remove ( <str> )  except ValueError :              pass  effort = flags [ 0 ] if flags else <str> direction = <str> if self . sign == <str> else <str> self . _fftw_plan = pyfftw_call ( x , out , direction = direction , axes = self . axes , halfcomplex = self . halfcomplex , planning_effort = effort , fftw_plan = self . _fftw_plan , normalise_idft = True ) if self . sign == <str> :              out /= np . prod ( np . take ( self . domain . shape , self . axes ) )  return out  @ property def inverse ( self ) :          sign = <str> if self . sign == <str> else <str> return DiscreteFourierTransform ( domain = self . range , range = self . domain , axes = self . axes , halfcomplex = self . halfcomplex , sign = sign )   class FourierTransformBase ( Operator ) :      def __init__ ( self , inverse , domain , range = None , impl = None , ** kwargs ) :          if not isinstance ( domain , DiscreteLp ) :              raise TypeError ( <str> <str> . format ( domain ) )  if domain . impl != <str> :              raise NotImplementedError ( <str> <str> . format ( domain . tspace ) )  axes = kwargs . pop ( <str> , np . arange ( domain . ndim ) ) self . __axes = normalized_axes_tuple ( axes , domain . ndim ) if impl is None :              impl = _DEFAULT_FOURIER_IMPL  impl , impl_in = str ( impl ) . lower ( ) , impl if impl not in _SUPPORTED_FOURIER_IMPLS :              raise ValueError ( <str> . format ( impl_in ) )  self . __impl = impl halfcomplex = kwargs . pop ( <str> , True ) shift = kwargs . pop ( <str> , True ) if all ( domain . grid . is_uniform_byaxis [ i ] for i in self . axes ) :              if domain . field == ComplexNumbers ( ) :                  self . __halfcomplex = False  else :                  self . __halfcomplex = bool ( halfcomplex )  self . __shifts = normalized_scalar_param_list ( shift , length = len ( self . axes ) , param_conv = bool )  else :              raise NotImplementedError ( <str> )  sign = kwargs . pop ( <str> , <str> ) if sign not in ( <str> , <str> ) :              raise ValueError ( <str> . format ( sign ) )  fwd_sign = ( <str> if sign == <str> else <str> ) if inverse else sign if fwd_sign == <str> and self . halfcomplex :              raise ValueError ( <str> <str> )  self . __sign = sign if self . halfcomplex and not self . shifts [ - 1 ] :              raise ValueError ( <str> <str> )  tmp_r = kwargs . pop ( <str> , None ) tmp_f = kwargs . pop ( <str> , None ) if kwargs :              raise TypeError ( <str> <str> . format ( kwargs ) )  if range is None :              range = reciprocal_space ( domain , axes = self . axes , halfcomplex = self . halfcomplex , shift = self . shifts )  if inverse :              super ( FourierTransformBase , self ) . __init__ ( range , domain , linear = True )  else :              super ( FourierTransformBase , self ) . __init__ ( domain , range , linear = True )  self . _fftw_plan = None if tmp_r is not None :              tmp_r = domain . element ( tmp_r ) . asarray ( )  if tmp_f is not None :              tmp_f = range . element ( tmp_f ) . asarray ( )  self . _tmp_r = tmp_r self . _tmp_f = tmp_f  def _call ( self , x , out , ** kwargs ) :          if self . impl == <str> :              out [ : ] = self . _call_numpy ( x . asarray ( ) )  else :              out [ : ] = self . _call_pyfftw ( x . asarray ( ) , out . asarray ( ) , ** kwargs )   def _call_numpy ( self , x ) :          raise NotImplementedError ( <str> )  def _call_pyfftw ( self , x , out , ** kwargs ) :          raise NotImplementedError ( <str> )  @ property def impl ( self ) :          return self . __impl  @ property def axes ( self ) :          return self . __axes  @ property def sign ( self ) :          return self . __sign  @ property def halfcomplex ( self ) :          return self . __halfcomplex  @ property def shifts ( self ) :          return self . __shifts  @ property def adjoint ( self ) :          if self . domain . exponent == 2.0 and self . range . exponent == 2.0 :              return self . inverse  else :              raise NotImplementedError ( <str> <str> . format ( self . domain . exponent , self . range . exponent ) )   @ property def inverse ( self ) :          sign = <str> if self . sign == <str> else <str> return FourierTransformInverse ( domain = self . range , range = self . domain , impl = self . impl , axes = self . axes , halfcomplex = self . halfcomplex , shift = self . shifts , sign = sign , tmp_r = self . _tmp_r , tmp_f = self . _tmp_f )  def create_temporaries ( self , r = True , f = True ) :          inverse = isinstance ( self , FourierTransformInverse ) if inverse :              rspace = self . range fspace = self . domain  else :              rspace = self . domain fspace = self . range  if r :              self . _tmp_r = rspace . element ( ) . asarray ( )  if f :              self . _tmp_f = fspace . element ( ) . asarray ( )   def clear_temporaries ( self ) :          self . _tmp_r = None self . _tmp_f = None  def init_fftw_plan ( self , planning_effort = <str> , ** kwargs ) :          if self . impl != <str> :              raise ValueError ( <str> )  inverse = isinstance ( self , FourierTransformInverse ) if inverse :              rspace = self . range fspace = self . domain  else :              rspace = self . domain fspace = self . range  if rspace . field == ComplexNumbers ( ) :              if self . _tmp_r is not None :                  arr_in = arr_out = self . _tmp_r  elif self . _tmp_f is not None :                  arr_in = arr_out = self . _tmp_f  else :                  arr_in = arr_out = rspace . element ( ) . asarray ( )   elif self . halfcomplex :              if self . _tmp_r is not None :                  arr_r = self . _tmp_r  else :                  arr_r = rspace . element ( ) . asarray ( )  if self . _tmp_f is not None :                  arr_f = self . _tmp_f  else :                  arr_f = fspace . element ( ) . asarray ( )  if inverse :                  arr_in , arr_out = arr_f , arr_r  else :                  arr_in , arr_out = arr_r , arr_f   else :              if self . _tmp_f is not None :                  arr_in = arr_out = self . _tmp_f  else :                  arr_in = arr_out = fspace . element ( ) . asarray ( )   kwargs . pop ( <str> , None ) direction = <str> if self . sign == <str> else <str> self . _fftw_plan = pyfftw_call ( arr_in , arr_out , direction = direction , halfcomplex = self . halfcomplex , axes = self . axes , planning_effort = planning_effort , ** kwargs )  def clear_fftw_plan ( self ) :          if self . impl != <str> :              raise ValueError ( <str> )  self . _fftw_plan = None   class FourierTransform ( FourierTransformBase ) :      def __init__ ( self , domain , range = None , impl = None , ** kwargs ) :          super ( FourierTransform , self ) . __init__ ( inverse = False , domain = domain , range = range , impl = impl , ** kwargs )  def _preprocess ( self , x , out = None ) :          if out is None :              if self . domain . field == ComplexNumbers ( ) :                  out = self . _tmp_r if self . _tmp_r is not None else self . _tmp_f  elif self . domain . field == RealNumbers ( ) and not self . halfcomplex :                  out = self . _tmp_f  else :                  out = self . _tmp_r   return dft_preprocess_data ( x , shift = self . shifts , axes = self . axes , sign = self . sign , out = out )  def _postprocess ( self , x , out = None ) :          if out is None :              if self . domain . field == ComplexNumbers ( ) :                  out = self . _tmp_r if self . _tmp_r is not None else self . _tmp_f  else :                  out = self . _tmp_f   return dft_postprocess_data ( out , real_grid = self . domain . grid , recip_grid = self . range . grid , shift = self . shifts , axes = self . axes , sign = self . sign , interp = <str> , op = <str> , out = out )  def _call_numpy ( self , x ) :          preproc = self . _preprocess ( x ) if self . halfcomplex :              out = np . fft . rfftn ( preproc , axes = self . axes )  else :              if self . sign == <str> :                  out = np . fft . fftn ( preproc , axes = self . axes )  else :                  out = np . fft . ifftn ( preproc , axes = self . axes ) out *= np . prod ( np . take ( self . domain . shape , self . axes ) )   self . _postprocess ( out , out = out ) return out  def _call_pyfftw ( self , x , out , ** kwargs ) :          kwargs . pop ( <str> , None ) kwargs . pop ( <str> , None ) kwargs . pop ( <str> , None ) if self . halfcomplex :              preproc = self . _preprocess ( x ) assert is_real_dtype ( preproc . dtype )  else :              preproc = self . _preprocess ( x , out = out ) assert is_complex_floating_dtype ( preproc . dtype )  direction = <str> if self . sign == <str> else <str> self . _fftw_plan = pyfftw_call ( preproc , out , direction = direction , halfcomplex = self . halfcomplex , axes = self . axes , normalise_idft = False , ** kwargs ) assert is_complex_floating_dtype ( out . dtype ) out = self . _postprocess ( out , out = out ) assert is_complex_floating_dtype ( out . dtype ) return out  @ property def inverse ( self ) :          sign = <str> if self . sign == <str> else <str> return FourierTransformInverse ( domain = self . range , range = self . domain , impl = self . impl , axes = self . axes , halfcomplex = self . halfcomplex , shift = self . shifts , sign = sign , tmp_r = self . _tmp_r , tmp_f = self . _tmp_f )   class FourierTransformInverse ( FourierTransformBase ) :      def __init__ ( self , range , domain = None , impl = None , ** kwargs ) :          super ( FourierTransformInverse , self ) . __init__ ( inverse = True , domain = range , range = domain , impl = impl , ** kwargs )  def _preprocess ( self , x , out = None ) :          if out is None :              if self . range . field == ComplexNumbers ( ) :                  out = self . _tmp_r if self . _tmp_r is not None else self . _tmp_f  else :                  out = self . _tmp_f   return dft_postprocess_data ( x , real_grid = self . range . grid , recip_grid = self . domain . grid , shift = self . shifts , axes = self . axes , sign = self . sign , interp = <str> , op = <str> , out = out )  def _postprocess ( self , x , out = None ) :          if out is None :              if self . range . field == ComplexNumbers ( ) :                  out = self . _tmp_r if self . _tmp_r is not None else self . _tmp_f  elif self . range . field == RealNumbers ( ) and not self . halfcomplex :                  out = self . _tmp_f  else :                  out = self . _tmp_r   return dft_preprocess_data ( x , shift = self . shifts , axes = self . axes , sign = self . sign , out = out )  def _call_numpy ( self , x ) :          preproc = self . _preprocess ( x ) if self . halfcomplex :              s = np . asarray ( self . range . shape ) [ list ( self . axes ) ] out = np . fft . irfftn ( preproc , axes = self . axes , s = s )  else :              if self . sign == <str> :                  out = np . fft . fftn ( preproc , axes = self . axes ) out /= np . prod ( np . take ( self . domain . shape , self . axes ) )  else :                  out = np . fft . ifftn ( preproc , axes = self . axes )   self . _postprocess ( out , out = out ) if self . halfcomplex :              assert is_real_dtype ( out . dtype )  if self . range . field == RealNumbers ( ) :              return out . real  else :              return out   def _call_pyfftw ( self , x , out , ** kwargs ) :          kwargs . pop ( <str> , None ) kwargs . pop ( <str> , None ) kwargs . pop ( <str> , None ) if self . range . field == ComplexNumbers ( ) :              preproc = self . _preprocess ( x , out = out )  else :              preproc = self . _preprocess ( x )  direction = <str> if self . sign == <str> else <str> if self . range . field == RealNumbers ( ) and not self . halfcomplex :              self . _fftw_plan = pyfftw_call ( preproc , preproc , direction = direction , halfcomplex = self . halfcomplex , axes = self . axes , normalise_idft = True , ** kwargs ) fft_arr = preproc  else :              self . _fftw_plan = pyfftw_call ( preproc , out , direction = direction , halfcomplex = self . halfcomplex , axes = self . axes , normalise_idft = True , ** kwargs ) fft_arr = out  if self . sign == <str> :              fft_arr /= np . prod ( np . take ( self . domain . shape , self . axes ) )  self . _postprocess ( fft_arr , out = out ) return out  @ property def inverse ( self ) :          sign = <str> if self . sign == <str> else <str> return FourierTransform ( domain = self . range , range = self . domain , impl = self . impl , axes = self . axes , halfcomplex = self . halfcomplex , shift = self . shifts , sign = sign , tmp_r = self . _tmp_r , tmp_f = self . _tmp_f )   if __name__ == <str> :      from odl . util . testutils import run_doctests run_doctests ( )   