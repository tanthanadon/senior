from __future__ import print_function , division , absolute_import from numbers import Integral import numpy as np from odl . discr . discretization import ( DiscretizedSpace , DiscretizedSpaceElement , tspace_type ) from odl . discr . discr_mappings import ( PointCollocation , NearestInterpolation , LinearInterpolation , PerAxisInterpolation ) from odl . discr . partition import ( RectPartition , uniform_partition_fromintv , uniform_partition ) from odl . set import RealNumbers , ComplexNumbers , IntervalProd from odl . space import FunctionSpace , ProductSpace from odl . space . entry_points import tensor_space_impl from odl . space . weighting import ConstWeighting from odl . util import ( apply_on_boundary , is_real_dtype , is_complex_floating_dtype , is_string , is_floating_dtype , is_numeric_dtype , dtype_str , array_str , signature_string , indent , npy_printoptions , normalized_scalar_param_list , safe_int_conv , normalized_nodes_on_bdry ) __all__ = ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) _SUPPORTED_INTERP = ( <str> , <str> ) class DiscreteLp ( DiscretizedSpace ) :      def __init__ ( self , fspace , partition , tspace , interp = <str> , ** kwargs ) :          if not isinstance ( fspace , FunctionSpace ) :              raise TypeError ( <str> <str> . format ( fspace ) )  if not isinstance ( fspace . domain , IntervalProd ) :              raise TypeError ( <str> <str> . format ( fspace . domain ) )  if not isinstance ( partition , RectPartition ) :              raise TypeError ( <str> <str> . format ( partition ) )  if not fspace . domain . contains_set ( partition . set ) :              raise ValueError ( <str> <str> . format ( partition , fspace . domain ) )  if fspace . scalar_out_dtype != tspace . dtype :              raise ValueError ( <str> <str> <str> . format ( fspace . scalar_out_dtype , tspace . dtype ) )  self . __partition = partition if is_string ( interp ) :              interp , interp_in = str ( interp ) . lower ( ) , interp if interp not in _SUPPORTED_INTERP :                  raise ValueError ( <str> <str> . format ( interp_in ) )  self . __interp_byaxis = ( interp , ) * max ( partition . ndim , 1 )  else :              if len ( interp ) != partition . ndim :                  raise ValueError ( <str> <str> . format ( partition . ndim , len ( interp ) ) )  self . __interp_byaxis = tuple ( str ( s ) . lower ( ) for s in interp ) if any ( s not in _SUPPORTED_INTERP for s in self . interp_byaxis ) :                  raise ValueError ( <str> <str> . format ( interp ) )   sampling = PointCollocation ( fspace , self . partition , tspace ) if all ( s == <str> for s in self . interp_byaxis ) :              interpol = NearestInterpolation ( fspace , self . partition , tspace )  elif all ( s == <str> for s in self . interp_byaxis ) :              interpol = LinearInterpolation ( fspace , self . partition , tspace )  else :              interpol = PerAxisInterpolation ( fspace , self . partition , tspace , self . interp_byaxis )  super ( DiscreteLp , self ) . __init__ ( fspace , tspace , sampling , interpol ) axis_labels = kwargs . pop ( <str> , None ) if axis_labels is None :              if self . ndim <= 3 :                  self . __axis_labels = ( <str> , <str> , <str> ) [ : self . ndim ]  else :                  self . __axis_labels = tuple ( <str> . format ( axis ) for axis in range ( self . ndim ) )   else :              self . __axis_labels = tuple ( str ( label ) for label in axis_labels )  if kwargs :              raise ValueError ( <str> <str> . format ( kwargs ) )   @ property def interp ( self ) :          if self . ndim == 0 :              return <str>  elif all ( interp == self . interp_byaxis [ 0 ] for interp in self . interp_byaxis ) :              return self . interp_byaxis [ 0 ]  else :              return self . interp_byaxis   @ property def interp_byaxis ( self ) :          return self . __interp_byaxis  @ property def axis_labels ( self ) :          return self . __axis_labels  @ property def partition ( self ) :          return self . __partition  @ property def exponent ( self ) :          return self . tspace . exponent  @ property def min_pt ( self ) :          return self . partition . min_pt  @ property def max_pt ( self ) :          return self . partition . max_pt  @ property def is_uniform_byaxis ( self ) :          return self . partition . is_uniform_byaxis  @ property def is_uniform ( self ) :          return self . partition . is_uniform  @ property def grid ( self ) :          return self . partition . grid  @ property def shape ( self ) :          return self . partition . shape  @ property def ndim ( self ) :          return self . partition . ndim  @ property def size ( self ) :          return self . partition . size  @ property def cell_sides ( self ) :          return self . partition . cell_sides  @ property def cell_volume ( self ) :          return self . partition . cell_volume  @ property def meshgrid ( self ) :          return self . partition . meshgrid  def points ( self , order = <str> ) :          return self . partition . points ( order )  @ property def default_order ( self ) :          return self . tspace . default_order  @ property def tangent_bundle ( self ) :          if self . ndim == 0 :              return ProductSpace ( field = self . field )  else :              return ProductSpace ( self , self . ndim )   @ property def is_uniformly_weighted ( self ) :          try :              is_uniformly_weighted = self . __is_uniformly_weighted  except AttributeError :              bdry_fracs = self . partition . boundary_cell_fractions is_uniformly_weighted = ( np . allclose ( bdry_fracs , 1.0 ) or self . exponent == float ( <str> ) or not getattr ( self . tspace , <str> , False ) ) self . __is_uniformly_weighted = is_uniformly_weighted  return is_uniformly_weighted  def element ( self , inp = None , order = None , ** kwargs ) :          if inp is None :              return self . element_type ( self , self . tspace . element ( order = order ) )  elif inp in self and order is None :              return inp  elif inp in self . tspace and order is None :              return self . element_type ( self , inp )  elif callable ( inp ) :              vectorized = kwargs . pop ( <str> , True ) inp_elem = self . fspace . element ( inp , vectorized = vectorized ) sampled = self . sampling ( inp_elem , ** kwargs ) return self . element_type ( self , self . tspace . element ( sampled , order = order ) )  else :              return self . element_type ( self , self . tspace . element ( inp , order = order ) )   def _astype ( self , dtype ) :          fspace = self . fspace . astype ( dtype ) tspace = self . tspace . astype ( dtype ) return type ( self ) ( fspace , self . partition , tspace , interp = self . interp , axis_labels = self . axis_labels )  def _inner ( self , x , y ) :          if self . is_uniform and not self . is_uniformly_weighted :              bdry_fracs = self . partition . boundary_cell_fractions func_list = _scaling_func_list ( bdry_fracs , exponent = 1.0 ) x_arr = apply_on_boundary ( x , func = func_list , only_once = False ) return super ( DiscreteLp , self ) . _inner ( self . element ( x_arr ) , y )  else :              return super ( DiscreteLp , self ) . _inner ( x , y )   def _norm ( self , x ) :          if self . is_uniform and not self . is_uniformly_weighted :              bdry_fracs = self . partition . boundary_cell_fractions func_list = _scaling_func_list ( bdry_fracs , exponent = self . exponent ) x_arr = apply_on_boundary ( x , func = func_list , only_once = False ) return super ( DiscreteLp , self ) . _norm ( self . element ( x_arr ) )  else :              return super ( DiscreteLp , self ) . _norm ( x )   def _dist ( self , x , y ) :          if self . is_uniform and not self . is_uniformly_weighted :              bdry_fracs = self . partition . boundary_cell_fractions func_list = _scaling_func_list ( bdry_fracs , exponent = self . exponent ) arrs = [ apply_on_boundary ( vec , func = func_list , only_once = False ) for vec in ( x , y ) ] return super ( DiscreteLp , self ) . _dist ( self . element ( arrs [ 0 ] ) , self . element ( arrs [ 1 ] ) )  else :              return super ( DiscreteLp , self ) . _dist ( x , y )   @ property def byaxis_in ( self ) :          space = self class DiscreteLpByaxisIn ( object ) :              def __getitem__ ( self , indices ) :                  fspace = space . fspace . byaxis_in [ indices ] part = space . partition . byaxis [ indices ] if isinstance ( space . weighting , ConstWeighting ) :                      try :                          iter ( indices )  except TypeError :                          newshape = space . shape [ indices ]  else :                          newshape = tuple ( space . shape [ int ( i ) ] for i in indices )  weighting = part . cell_volume tspace = type ( space . tspace ) ( newshape , space . dtype , exponent = space . exponent , weighting = weighting )  else :                      tspace = space . tspace . byaxis [ indices ]  try :                      iter ( indices )  except TypeError :                      interp = space . interp_byaxis [ indices ] labels = space . axis_labels [ indices ]  else :                      interp = tuple ( space . interp_byaxis [ int ( i ) ] for i in indices ) labels = tuple ( space . axis_labels [ int ( i ) ] for i in indices )  return DiscreteLp ( fspace , part , tspace , interp , axis_labels = labels )  def __repr__ ( self ) :                  return repr ( space ) + <str>   return DiscreteLpByaxisIn ( )  def __repr__ ( self ) :          if ( uniform_partition_fromintv ( self . fspace . domain , self . shape , nodes_on_bdry = False ) == self . partition ) :              use_uniform = True nodes_on_bdry = False  elif ( uniform_partition_fromintv ( self . fspace . domain , self . shape , nodes_on_bdry = True ) == self . partition ) :              use_uniform = True nodes_on_bdry = True  else :              use_uniform = False  if use_uniform :              ctor = <str> if self . ndim == 1 :                  posargs = [ self . min_pt [ 0 ] , self . max_pt [ 0 ] , self . shape [ 0 ] ] posmod = [ <str> , <str> , <str> ]  else :                  posargs = [ self . min_pt , self . max_pt , self . shape ] posmod = [ array_str , array_str , <str> ]  default_dtype_s = dtype_str ( self . tspace . default_dtype ( RealNumbers ( ) ) ) dtype_s = dtype_str ( self . dtype ) optargs = [ ( <str> , self . interp , <str> ) , ( <str> , self . impl , <str> ) , ( <str> , nodes_on_bdry , False ) , ( <str> , dtype_s , default_dtype_s ) ] if ( self . exponent == float ( <str> ) or self . ndim == 0 or not is_floating_dtype ( self . dtype ) ) :                  if ( not isinstance ( self . weighting , ConstWeighting ) or not np . isclose ( self . weighting . const , 1.0 ) ) :                      optargs . append ( ( <str> , self . weighting . const , None ) )   else :                  if ( not isinstance ( self . weighting , ConstWeighting ) or not np . isclose ( self . weighting . const , self . cell_volume ) ) :                      optargs . append ( ( <str> , self . weighting . const , None ) )   optmod = [ <str> ] * len ( optargs ) if self . dtype in ( float , complex , int , bool ) :                  optmod [ 3 ] = <str>  with npy_printoptions ( precision = 4 ) :                  inner_str = signature_string ( posargs , optargs , mod = [ posmod , optmod ] )  return <str> . format ( ctor , inner_str )  else :              ctor = self . __class__ . __name__ posargs = [ self . fspace , self . partition , self . tspace ] optargs = [ ( <str> , self . interp , <str> ) ] with npy_printoptions ( precision = 4 ) :                  inner_str = signature_string ( posargs , optargs , sep = [ <str> , <str> , <str> ] , mod = [ <str> , <str> ] )  return <str> . format ( ctor , indent ( inner_str ) )   def __str__ ( self ) :          return repr ( self )  @ property def element_type ( self ) :          return DiscreteLpElement   class DiscreteLpElement ( DiscretizedSpaceElement ) :      @ property def cell_sides ( self ) :          return self . space . cell_sides  @ property def cell_volume ( self ) :          return self . space . cell_volume  @ property def data ( self ) :          return self . tensor . data  @ property def real ( self ) :          return self . space . real_space . element ( self . tensor . real )  @ real . setter def real ( self , newreal ) :          self . tensor . real = newreal  @ property def imag ( self ) :          return self . space . real_space . element ( self . tensor . imag )  @ imag . setter def imag ( self , newimag ) :          if self . space . is_real :              raise ValueError ( <str> )  self . tensor . imag = newimag  def conj ( self , out = None ) :          if out is None :              return self . space . element ( self . tensor . conj ( ) )  else :              self . tensor . conj ( out = out . tensor ) return out   def __setitem__ ( self , indices , values ) :          if values in self . space :              self . tensor [ indices ] = values . tensor  else :              super ( DiscreteLpElement , self ) . __setitem__ ( indices , values )   def __array_ufunc__ ( self , ufunc , method , * inputs , ** kwargs ) :          out_tuple = kwargs . pop ( <str> , ( ) ) if method == <str> and len ( out_tuple ) not in ( 0 , ufunc . nout ) :              raise ValueError ( <str> <str> . format ( ufunc . nout , len ( out_tuple ) ) )  elif method != <str> and len ( out_tuple ) not in ( 0 , 1 ) :              raise ValueError ( <str> <str> . format ( method , len ( out_tuple ) ) )  valid_out_types = ( type ( self ) , type ( self . tensor ) , type ( self . tensor . data ) ) if not all ( isinstance ( o , valid_out_types ) or o is None for o in out_tuple ) :              return NotImplemented  out = out1 = out2 = None if len ( out_tuple ) == 1 :              out = getattr ( out_tuple [ 0 ] , <str> , out_tuple [ 0 ] )  elif len ( out_tuple ) == 2 :              out1 = getattr ( out_tuple [ 0 ] , <str> , out_tuple [ 0 ] ) out2 = getattr ( out_tuple [ 1 ] , <str> , out_tuple [ 1 ] )  input_tensors = tuple ( elem . tensor if isinstance ( elem , type ( self ) ) else elem for elem in inputs ) keepdims = kwargs . pop ( <str> , False ) axis = kwargs . get ( <str> , None ) if axis is None :              reduced_axes = list ( range ( 1 , self . ndim ) )  else :              try :                  iter ( axis )  except TypeError :                  axis = ( int ( axis ) , )  reduced_axes = [ i for i in range ( self . ndim ) if i not in axis ]  weighting = self . space . weighting if method == <str> :              if ufunc . nout == 1 :                  kwargs [ <str> ] = ( out , ) res_tens = self . tensor . __array_ufunc__ ( ufunc , <str> , * input_tensors , ** kwargs ) if out is None :                      out_dtype = ( res_tens . dtype , self . space . fspace . out_shape ) fspace = FunctionSpace ( self . space . fspace . domain , out_dtype ) res_space = DiscreteLp ( fspace , self . space . partition , res_tens . space , self . space . interp_byaxis , axis_labels = self . space . axis_labels ) result = res_space . element ( res_tens )  else :                      result = out_tuple [ 0 ]  return result  elif ufunc . nout == 2 :                  kwargs [ <str> ] = ( out1 , out2 ) res1_tens , res2_tens = self . tensor . __array_ufunc__ ( ufunc , <str> , * input_tensors , ** kwargs ) if out1 is None :                      out_dtype = ( res1_tens . dtype , self . space . fspace . out_shape ) fspace = FunctionSpace ( self . space . fspace . domain , out_dtype ) res_space = DiscreteLp ( fspace , self . space . partition , res1_tens . space , self . space . interp_byaxis , axis_labels = self . space . axis_labels ) result1 = res_space . element ( res1_tens )  else :                      result1 = out_tuple [ 0 ]  if out2 is None :                      out_dtype = ( res2_tens . dtype , self . space . fspace . out_shape ) fspace = FunctionSpace ( self . space . fspace . domain , out_dtype ) res_space = DiscreteLp ( fspace , self . space . partition , res2_tens . space , self . space . interp_byaxis , axis_labels = self . space . axis_labels ) result2 = res_space . element ( res2_tens )  else :                      result2 = out_tuple [ 1 ]  return result1 , result2  else :                  raise NotImplementedError ( <str> <str> . format ( ufunc . nout ) )   elif method == <str> and keepdims :              raise ValueError ( <str> <str> <str> )  elif method == <str> :              raise ValueError ( <str> )  elif ( method == <str> and not all ( isinstance ( inp , type ( self ) ) for inp in inputs ) ) :                  raise TypeError ( <str> <str> <str> . format ( type ( self ) , tuple ( type ( inp ) for inp in inputs ) ) )  else :              if method != <str> :                  kwargs [ <str> ] = ( out , )  res_tens = self . tensor . __array_ufunc__ ( ufunc , method , * input_tensors , ** kwargs ) if np . isscalar ( res_tens ) or res_tens is None :                  return res_tens  if out is None :                  if method == <str> :                      fspace = FunctionSpace ( self . space . domain , out_dtype = res_tens . dtype ) res_space = DiscreteLp ( fspace , self . space . partition , res_tens . space , self . space . interp_byaxis , axis_labels = self . space . axis_labels ) result = res_space . element ( res_tens )  elif method == <str> :                      inp1 , inp2 = inputs domain = inp1 . space . domain . append ( inp2 . space . domain ) fspace = FunctionSpace ( domain , out_dtype = res_tens . dtype ) part = inp1 . space . partition . append ( inp2 . space . partition ) interp = ( inp1 . space . interp_byaxis + inp2 . space . interp_byaxis ) labels1 = [ lbl + <str> for lbl in inp1 . space . axis_labels ] labels2 = [ lbl + <str> for lbl in inp2 . space . axis_labels ] labels = labels1 + labels2 if all ( isinstance ( inp . space . weighting , ConstWeighting ) for inp in inputs ) :                          weighting = ( inp1 . space . weighting . const * inp2 . space . weighting . const ) tspace = type ( res_tens . space ) ( res_tens . shape , res_tens . dtype , exponent = res_tens . space . exponent , weighting = weighting )  else :                          tspace = res_tens . space  res_space = DiscreteLp ( fspace , part , tspace , interp , axis_labels = labels ) result = res_space . element ( res_tens )  elif method == <str> :                      res_space = self . space . byaxis_in [ reduced_axes ] . astype ( res_tens . dtype ) result = res_space . element ( res_tens )  else :                      raise RuntimeError ( <str> )   else :                  result = out_tuple [ 0 ]  return result   def show ( self , title = None , method = <str> , coords = None , indices = None , force_show = False , fig = None , ** kwargs ) :          from odl . util . graphics import show_discrete_data if <str> not in kwargs and not isinstance ( self . space . interp , tuple ) :              kwargs [ <str> ] = self . space . interp  if self . ndim == 0 :              raise ValueError ( <str> )  if coords is not None :              if indices is not None :                  raise ValueError ( <str> )  partition = self . space . partition shape = self . shape indices = [ ] for axis , ( n , coord ) in enumerate ( zip ( shape , coords ) ) :                  try :                      coord_minp , coord_maxp = coord  except TypeError :                      coord_minp = coord_maxp = coord  subpart = partition . byaxis [ axis ] if coord_minp is not None :                      coord_minp = subpart . set . element ( coord_minp )  if coord_maxp is not None :                      coord_maxp = subpart . set . element ( coord_maxp )  if len ( subpart ) == 0 :                      indices . append ( 0 )  elif coord_minp is not None and coord_minp == coord_maxp :                      indices . append ( subpart . index ( coord_minp ) )  else :                      if coord_minp is None :                          min_ind = 0  else :                          min_ind = np . floor ( subpart . index ( coord_minp , floating = True ) )  if coord_maxp is None :                          max_ind = len ( subpart )  else :                          max_ind = np . ceil ( subpart . index ( coord_maxp , floating = True ) )  indices . append ( slice ( int ( min_ind ) , int ( max_ind ) ) )    if indices is None and self . ndim >= 3 :              indices = ( ( slice ( None ) , ) * 2 + tuple ( n // 2 for n in self . space . shape [ 2 : ] ) )  if isinstance ( indices , ( Integral , slice ) ) :              indices = ( indices , )  elif indices is None or indices == Ellipsis :              indices = ( slice ( None ) , ) * self . ndim  if len ( indices ) == 1 :              indices = tuple ( indices ) + ( Ellipsis , )  if indices . count ( Ellipsis ) > 1 :              raise ValueError ( <str> )  elif Ellipsis in indices :              pos = indices . index ( Ellipsis ) indices = ( tuple ( indices [ : pos ] ) + ( slice ( None ) , ) * ( self . ndim - len ( indices ) + 1 ) + tuple ( indices [ pos + 1 : ] ) )  if len ( indices ) < self . ndim :              raise ValueError ( <str> . format ( len ( indices ) , self . ndim ) )  if len ( indices ) > self . ndim :              raise ValueError ( <str> . format ( len ( indices ) , self . ndim ) )  indices = tuple ( slice ( None ) if idx is None else idx for idx in indices ) squeezed_axes = [ axis for axis in range ( self . ndim ) if not isinstance ( indices [ axis ] , Integral ) ] axis_labels = [ self . space . axis_labels [ axis ] for axis in squeezed_axes ] part = self . space . partition [ indices ] . squeeze ( ) values = self . asarray ( ) [ indices ] . squeeze ( ) return show_discrete_data ( values , part , title = title , method = method , force_show = force_show , fig = fig , axis_labels = axis_labels , ** kwargs )   def uniform_discr_frompartition ( partition , dtype = None , impl = <str> , ** kwargs ) :      if not isinstance ( partition , RectPartition ) :          raise TypeError ( <str> <str> . format ( partition ) )  if not partition . is_uniform :          raise ValueError ( <str> )  if dtype is not None :          dtype = np . dtype ( dtype )  fspace = FunctionSpace ( partition . set , out_dtype = dtype ) ds_type = tspace_type ( fspace , impl , dtype ) if dtype is None :          dtype = ds_type . default_dtype ( )  weighting = kwargs . pop ( <str> , None ) exponent = kwargs . pop ( <str> , 2.0 ) if weighting is None and is_numeric_dtype ( dtype ) :          if exponent == float ( <str> ) or partition . ndim == 0 :              weighting = 1.0  else :              weighting = partition . cell_volume   tspace = ds_type ( partition . shape , dtype , exponent = exponent , weighting = weighting ) return DiscreteLp ( fspace , partition , tspace , ** kwargs )  def uniform_discr_fromspace ( fspace , shape , dtype = None , impl = <str> , ** kwargs ) :      if not isinstance ( fspace , FunctionSpace ) :          raise TypeError ( <str> <str> . format ( fspace ) )  if not isinstance ( fspace . domain , IntervalProd ) :          raise TypeError ( <str> <str> . format ( fspace . domain ) )  if dtype is None :          dtype = fspace . out_dtype  else :          dtype , dtype_in = np . dtype ( dtype ) , dtype if not np . can_cast ( fspace . scalar_out_dtype , dtype , casting = <str> ) :              raise ValueError ( <str> <str> <str> . format ( fspace . out , dtype_in ) )   if fspace . field == RealNumbers ( ) and not is_real_dtype ( dtype ) :          raise ValueError ( <str> <str> <str> . format ( fspace , dtype ) )  elif ( fspace . field == ComplexNumbers ( ) and not is_complex_floating_dtype ( dtype ) ) :          raise ValueError ( <str> <str> <str> . format ( fspace , dtype ) )  nodes_on_bdry = kwargs . pop ( <str> , False ) partition = uniform_partition_fromintv ( fspace . domain , shape , nodes_on_bdry ) return uniform_discr_frompartition ( partition , dtype , impl , ** kwargs )  def uniform_discr_fromintv ( intv_prod , shape , dtype = None , impl = <str> , ** kwargs ) :      if dtype is None :          dtype = tensor_space_impl ( str ( impl ) . lower ( ) ) . default_dtype ( )  fspace = FunctionSpace ( intv_prod , out_dtype = dtype ) return uniform_discr_fromspace ( fspace , shape , dtype , impl , ** kwargs )  def uniform_discr ( min_pt , max_pt , shape , dtype = None , impl = <str> , ** kwargs ) :      intv_prod = IntervalProd ( min_pt , max_pt ) return uniform_discr_fromintv ( intv_prod , shape , dtype , impl , ** kwargs )  def discr_sequence_space ( shape , dtype = None , impl = <str> , ** kwargs ) :      shape = np . atleast_1d ( shape ) return uniform_discr ( [ 0 ] * len ( shape ) , shape - 1 , shape , dtype , impl , nodes_on_bdry = True , ** kwargs )  def uniform_discr_fromdiscr ( discr , min_pt = None , max_pt = None , shape = None , cell_sides = None , ** kwargs ) :      if not isinstance ( discr , DiscreteLp ) :          raise TypeError ( <str> <str> . format ( discr ) )  if not discr . is_uniform :          raise ValueError ( <str> <str> . format ( discr ) )  min_pt = normalized_scalar_param_list ( min_pt , discr . ndim , param_conv = float , keep_none = True ) max_pt = normalized_scalar_param_list ( max_pt , discr . ndim , param_conv = float , keep_none = True ) shape = normalized_scalar_param_list ( shape , discr . ndim , param_conv = safe_int_conv , keep_none = True ) cell_sides = normalized_scalar_param_list ( cell_sides , discr . ndim , param_conv = float , keep_none = True ) nodes_on_bdry = kwargs . pop ( <str> , False ) nodes_on_bdry = normalized_nodes_on_bdry ( nodes_on_bdry , discr . ndim ) new_min_pt = [ ] new_max_pt = [ ] new_shape = [ ] new_csides = [ ] for i , ( xmin , xmax , n , s , old_xmin , old_xmax , old_n , old_s ) in enumerate ( zip ( min_pt , max_pt , shape , cell_sides , discr . min_pt , discr . max_pt , discr . shape , discr . cell_sides ) ) :          num_params = sum ( p is not None for p in ( xmin , xmax , n , s ) ) if num_params == 0 :              new_params = [ old_xmin , old_xmax , old_n , None ]  elif num_params == 1 :              if xmin is not None :                  new_params = [ xmin , old_xmax + ( xmin - old_xmin ) , old_n , None ]  elif xmax is not None :                  new_params = [ old_xmin + ( xmax - old_xmax ) , xmax , old_n , None ]  elif n is not None :                  new_params = [ old_xmin , old_xmax , n , None ]  else :                  new_params = [ old_xmin , old_xmax , None , s ]   elif num_params == 2 :              if xmin is not None and xmax is not None :                  new_params = [ xmin , xmax , old_n , None ]  elif xmin is not None and n is not None :                  new_params = [ xmin , None , n , old_s ]  elif xmin is not None and s is not None :                  new_params = [ xmin , None , old_n , s ]  elif xmax is not None and n is not None :                  new_params = [ None , xmax , n , old_s ]  elif xmax is not None and s is not None :                  new_params = [ None , xmax , old_n , s ]  else :                  raise ValueError ( <str> <str> <str> . format ( i ) )   else :              new_params = [ xmin , xmax , n , s ]  new_min_pt . append ( new_params [ 0 ] ) new_max_pt . append ( new_params [ 1 ] ) new_shape . append ( new_params [ 2 ] ) new_csides . append ( new_params [ 3 ] )  new_part = uniform_partition ( min_pt = new_min_pt , max_pt = new_max_pt , shape = new_shape , cell_sides = new_csides , nodes_on_bdry = nodes_on_bdry ) return uniform_discr_frompartition ( new_part , exponent = discr . exponent , interp = discr . interp , impl = discr . impl , ** kwargs )  def _scaling_func_list ( bdry_fracs , exponent ) :      def scaling ( factor ) :          def scaling_func ( x ) :              return x * factor  return scaling_func  func_list = [ ] for frac_l , frac_r in bdry_fracs :          func_list_entry = [ ] if np . isclose ( frac_l , 1.0 ) :              func_list_entry . append ( None )  else :              func_list_entry . append ( scaling ( frac_l ** ( 1 / exponent ) ) )  if np . isclose ( frac_r , 1.0 ) :              func_list_entry . append ( None )  else :              func_list_entry . append ( scaling ( frac_r ** ( 1 / exponent ) ) )  func_list . append ( func_list_entry )  return func_list  if __name__ == <str> :      from odl . util . testutils import run_doctests run_doctests ( )   