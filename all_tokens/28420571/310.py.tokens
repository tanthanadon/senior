import numpy as np import odl n = 256 subsampling = 0.5 lam = 0.003 space = odl . uniform_discr ( [ 0 , 0 ] , [ n , n ] , [ n , n ] ) ft = odl . trafos . FourierTransform ( space ) sampling_points = np . random . rand ( * ft . range . shape ) < subsampling sampling_mask = ft . range . element ( sampling_points ) mri_op = sampling_mask * ft phantom = odl . phantom . shepp_logan ( space , modified = True ) noisy_data = mri_op ( phantom ) + odl . phantom . white_noise ( mri_op . range ) * 0.1 phantom . show ( <str> ) noisy_data . show ( <str> ) gradient = odl . Gradient ( space ) lin_ops = [ mri_op , gradient ] g = [ odl . solvers . L2Norm ( mri_op . range ) . translated ( noisy_data ) , lam * odl . solvers . L1Norm ( gradient . range ) ] f = odl . solvers . IndicatorBox ( space , 0 , 1 ) x = mri_op . domain . zero ( ) callback = ( odl . solvers . CallbackShow ( step = 5 , clim = [ 0 , 1 ] ) & odl . solvers . CallbackPrintIteration ( ) ) odl . solvers . douglas_rachford_pd ( x , f , g , lin_ops , tau = 2.0 , sigma = [ 1.0 , 0.1 ] , niter = 500 , callback = callback ) x . show ( <str> ) ft . inverse ( noisy_data ) . show ( <str> , force_show = True )  