import numpy as np import odl reco_space = odl . uniform_discr ( min_pt = [ - 20 , - 20 ] , max_pt = [ 20 , 20 ] , shape = [ 300 , 300 ] , dtype = <str> ) angle_partition = odl . uniform_partition ( 0 , np . pi , 360 ) detector_partition = odl . uniform_partition ( - 30 , 30 , 512 ) geometry = odl . tomo . Parallel2dGeometry ( angle_partition , detector_partition ) ray_trafo = odl . tomo . RayTransform ( reco_space , geometry ) discr_phantom = odl . phantom . shepp_logan ( reco_space , modified = True ) data = ray_trafo ( discr_phantom ) data += odl . phantom . white_noise ( ray_trafo . range ) * np . mean ( data ) * 0.1 gradient = odl . Gradient ( reco_space ) op = odl . BroadcastOperator ( ray_trafo , gradient ) f = odl . solvers . ZeroFunctional ( op . domain ) l2_norm = odl . solvers . L2NormSquared ( ray_trafo . range ) . translated ( data ) l1_norm = 0.015 * odl . solvers . L1Norm ( gradient . range ) g = odl . solvers . SeparableSum ( l2_norm , l1_norm ) op_norm = 1.1 * odl . power_method_opnorm ( op ) niter = 200 tau = 1.0 / op_norm sigma = 1.0 / op_norm callback = ( odl . solvers . CallbackPrintIteration ( step = 10 ) & odl . solvers . CallbackShow ( step = 10 ) ) x = op . domain . zero ( ) odl . solvers . pdhg ( x , f , g , op , niter = niter , tau = tau , sigma = sigma , callback = callback ) discr_phantom . show ( title = <str> ) data . show ( title = <str> ) x . show ( title = <str> , force_show = True )  