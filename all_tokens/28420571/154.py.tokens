from __future__ import print_function , division , absolute_import from builtins import object import numpy as np from odl . discr . grid import RectGrid , uniform_grid_fromintv from odl . set import IntervalProd from odl . util import ( normalized_index_expression , normalized_nodes_on_bdry , normalized_scalar_param_list , safe_int_conv , signature_string , indent , array_str , npy_printoptions ) __all__ = ( <str> , <str> , <str> , <str> , <str> ) class RectPartition ( object ) :      def __init__ ( self , intv_prod , grid ) :          super ( RectPartition , self ) . __init__ ( ) if not isinstance ( intv_prod , IntervalProd ) :              raise TypeError ( <str> <str> . format ( intv_prod ) )  if not isinstance ( grid , RectGrid ) :              raise TypeError ( <str> <str> . format ( grid ) )  if intv_prod . ndim != grid . ndim :              raise ValueError ( <str> <str> <str> . format ( intv_prod , intv_prod . ndim , grid , grid . ndim ) )  if not intv_prod . contains_set ( grid ) :              raise ValueError ( <str> <str> . format ( grid , intv_prod ) )  self . __set = intv_prod self . __grid = grid bdry_vecs = [ ] for ax , vec in enumerate ( self . grid . coord_vectors ) :              bdry = np . empty ( len ( vec ) + 1 ) bdry [ 1 : - 1 ] = ( vec [ 1 : ] + vec [ : - 1 ] ) / 2.0 bdry [ 0 ] = self . min ( ) [ ax ] bdry [ - 1 ] = self . max ( ) [ ax ] bdry_vecs . append ( bdry )  self . __cell_boundary_vecs = tuple ( bdry_vecs ) left_on_bdry = np . isclose ( self . grid . min_pt , self . set . min_pt ) [ : , None ] right_on_bdry = np . isclose ( self . grid . max_pt , self . set . max_pt ) [ : , None ] on_bdry = np . hstack ( [ left_on_bdry , right_on_bdry ] ) . tolist ( ) self . __nodes_on_bdry = tuple ( tuple ( r ) for r in on_bdry )  @ property def cell_boundary_vecs ( self ) :          return self . __cell_boundary_vecs  @ property def set ( self ) :          return self . __set  @ property def nodes_on_bdry ( self ) :          if self . size == 0 :              return True  nodes_on_bdry = [ ] for on_bdry in self . nodes_on_bdry_byaxis :              left , right = on_bdry if left == right :                  nodes_on_bdry . append ( left )  else :                  nodes_on_bdry . append ( ( left , right ) )   if all ( on_bdry == nodes_on_bdry [ 0 ] for on_bdry in nodes_on_bdry [ 1 : ] ) :              return nodes_on_bdry [ 0 ]  else :              return tuple ( nodes_on_bdry )   @ property def nodes_on_bdry_byaxis ( self ) :          return self . __nodes_on_bdry  @ property def min_pt ( self ) :          return self . set . min_pt  @ property def max_pt ( self ) :          return self . set . max_pt  @ property def mid_pt ( self ) :          return self . set . mid_pt  def min ( self ) :          return self . set . min ( )  def max ( self ) :          return self . set . max ( )  @ property def extent ( self ) :          return self . set . extent  @ property def grid ( self ) :          return self . __grid  @ property def is_uniform_byaxis ( self ) :          return self . grid . is_uniform_byaxis  @ property def is_uniform ( self ) :          return self . grid . is_uniform  @ property def has_isotropic_cells ( self ) :          return self . is_uniform and np . allclose ( self . cell_sides [ : - 1 ] , self . cell_sides [ 1 : ] )  @ property def ndim ( self ) :          return self . grid . ndim  @ property def shape ( self ) :          return self . grid . shape  @ property def size ( self ) :          return self . grid . size  def __len__ ( self ) :          return len ( self . grid )  def points ( self , order = <str> ) :          return self . grid . points ( order )  @ property def meshgrid ( self ) :          return self . grid . meshgrid  @ property def coord_vectors ( self ) :          return self . grid . coord_vectors  @ property def boundary_cell_fractions ( self ) :          frac_list = [ ] for ax , ( cvec , bmin , bmax ) in enumerate ( zip ( self . grid . coord_vectors , self . set . min_pt , self . set . max_pt ) ) :              if len ( cvec ) == 1 :                  frac_list . append ( ( 1.0 , 1.0 ) )  else :                  left_frac = 0.5 + ( cvec [ 0 ] - bmin ) / ( cvec [ 1 ] - cvec [ 0 ] ) right_frac = 0.5 + ( bmax - cvec [ - 1 ] ) / ( cvec [ - 1 ] - cvec [ - 2 ] ) frac_list . append ( ( left_frac , right_frac ) )   return tuple ( frac_list )  @ property def cell_sizes_vecs ( self ) :          csizes = [ ] for ax , cvec in enumerate ( self . grid . coord_vectors ) :              if len ( cvec ) == 1 :                  csizes . append ( np . array ( [ 0.0 ] ) )  else :                  csize = np . empty_like ( cvec ) csize [ 1 : - 1 ] = ( cvec [ 2 : ] - cvec [ : - 2 ] ) / 2.0 csize [ 0 ] = ( cvec [ 0 ] + cvec [ 1 ] ) / 2 - self . min ( ) [ ax ] csize [ - 1 ] = self . max ( ) [ ax ] - ( cvec [ - 2 ] + cvec [ - 1 ] ) / 2 csizes . append ( csize )   return tuple ( csizes )  @ property def cell_sides ( self ) :          sides = self . grid . stride sides [ sides == 0 ] = self . extent [ sides == 0 ] return sides  @ property def cell_volume ( self ) :          return 0.0 if self . size == 0 else float ( np . prod ( self . cell_sides ) )  def approx_equals ( self , other , atol ) :          if other is self :              return True  elif not isinstance ( other , RectPartition ) :              return False  else :              return ( self . set . approx_equals ( other . set , atol = atol ) and self . grid . approx_equals ( other . grid , atol = atol ) )   def __eq__ ( self , other ) :          if other is self :              return True  return ( type ( other ) is type ( self ) and self . set == other . set and self . grid == other . grid )  def __hash__ ( self ) :          return hash ( ( type ( self ) , self . set , self . grid ) )  def __ne__ ( self , other ) :          return not ( self == other )  def __getitem__ ( self , indices ) :          if isinstance ( indices , list ) :              if indices == [ ] :                  new_min_pt = new_max_pt = [ ]  else :                  new_min_pt = [ self . cell_boundary_vecs [ 0 ] [ : - 1 ] [ indices ] [ 0 ] ] new_max_pt = [ self . cell_boundary_vecs [ 0 ] [ 1 : ] [ indices ] [ - 1 ] ] for cvec in self . cell_boundary_vecs [ 1 : ] :                      new_min_pt . append ( cvec [ 0 ] ) new_max_pt . append ( cvec [ - 1 ] )   new_intvp = IntervalProd ( new_min_pt , new_max_pt ) new_grid = self . grid [ indices ] return RectPartition ( new_intvp , new_grid )  indices = normalized_index_expression ( indices , self . shape , int_to_slice = True ) new_min_pt , new_max_pt = [ ] , [ ] for cvec , idx in zip ( self . cell_boundary_vecs , indices ) :              if isinstance ( idx , slice ) :                  idx = slice ( idx . start , idx . stop , None )  sub_min_pt = cvec [ : - 1 ] [ idx ] sub_max_pt = cvec [ 1 : ] [ idx ] new_min_pt . append ( sub_min_pt [ 0 ] ) new_max_pt . append ( sub_max_pt [ - 1 ] )  new_intvp = IntervalProd ( new_min_pt , new_max_pt ) new_grid = self . grid [ indices ] return RectPartition ( new_intvp , new_grid )  def insert ( self , index , * parts ) :          if not all ( isinstance ( p , RectPartition ) for p in parts ) :              raise TypeError ( <str> <str> <str> . format ( <str> . join ( repr ( p ) for p in parts ) ) )  newgrid = self . grid . insert ( index , * ( p . grid for p in parts ) ) newset = self . set . insert ( index , * ( p . set for p in parts ) ) return RectPartition ( newset , newgrid )  def append ( self , * parts ) :          return self . insert ( self . ndim , * parts )  def squeeze ( self , axis = None ) :          if axis is None :              rng = range ( self . ndim )  else :              rng = list ( np . atleast_1d ( np . arange ( self . ndim ) [ axis ] ) )  new_indcs = [ i for i in range ( self . ndim ) if i not in rng or self . grid . nondegen_byaxis [ i ] ] newset = self . set [ new_indcs ] return RectPartition ( newset , self . grid . squeeze ( axis ) )  def index ( self , value , floating = False ) :          value = np . atleast_1d ( self . set . element ( value ) ) result = [ ] for val , cell_bdry_vec in zip ( value , self . cell_boundary_vecs ) :              ind = np . searchsorted ( cell_bdry_vec , val ) if floating :                  if cell_bdry_vec [ ind ] == val :                      result . append ( float ( ind ) )  else :                      csize = float ( cell_bdry_vec [ ind ] - cell_bdry_vec [ ind - 1 ] ) result . append ( ind - ( cell_bdry_vec [ ind ] - val ) / csize )   else :                  if cell_bdry_vec [ ind ] == val and ind != len ( cell_bdry_vec ) - 1 :                      result . append ( ind )  else :                      result . append ( ind - 1 )    if self . ndim == 1 :              result = result [ 0 ]  else :              result = tuple ( result )  return result  @ property def byaxis ( self ) :          partition = self class RectPartitionByAxis ( object ) :              def __getitem__ ( self , indices ) :                  try :                      iter ( indices )  except TypeError :                      slc = np . zeros ( partition . ndim , dtype = object ) slc [ indices ] = slice ( None ) squeeze_axes = np . where ( slc == 0 ) [ 0 ] newpart = partition [ tuple ( slc ) ] . squeeze ( squeeze_axes )  else :                      indices = [ int ( i ) for i in indices ] byaxis = partition . byaxis parts = [ byaxis [ i ] for i in indices ] if not parts :                          newpart = uniform_partition ( [ ] , [ ] , ( ) )  else :                          newpart = parts [ 0 ] . append ( * ( parts [ 1 : ] ) )   return newpart  def __repr__ ( self ) :                  return <str> . format ( partition )   return RectPartitionByAxis ( )  def __repr__ ( self ) :          if self . ndim == 0 :              return <str>  bdry_fracs = np . vstack ( self . boundary_cell_fractions ) default_bdry_fracs = np . all ( np . isclose ( bdry_fracs , 0.5 ) | np . isclose ( bdry_fracs , 1.0 ) ) csizes_l = np . fromiter ( ( s [ 0 ] for s in self . cell_sizes_vecs ) , dtype = float ) csizes_r = np . fromiter ( ( s [ - 1 ] for s in self . cell_sizes_vecs ) , dtype = float ) shift_l = ( ( bdry_fracs [ : , 0 ] . astype ( float ) . squeeze ( ) - 0.5 ) * csizes_l ) shift_r = ( ( bdry_fracs [ : , 1 ] . astype ( float ) . squeeze ( ) - 0.5 ) * csizes_r ) if self . is_uniform and default_bdry_fracs :              ctor = <str> if self . ndim == 1 :                  posargs = [ self . min_pt [ 0 ] , self . max_pt [ 0 ] , self . shape [ 0 ] ] posmod = [ <str> , <str> , <str> ]  else :                  posargs = [ self . min_pt , self . max_pt , self . shape ] posmod = [ array_str , array_str , <str> ]  optargs = [ ( <str> , self . nodes_on_bdry , False ) ] with npy_printoptions ( precision = 4 ) :                  sig_str = signature_string ( posargs , optargs , mod = [ posmod , <str> ] )  return <str> . format ( ctor , sig_str )  else :              ctor = <str> posargs = self . coord_vectors posmod = array_str optargs = [ ] nodes_def_min_pt = self . grid . min_pt - shift_l nodes_def_max_pt = self . grid . max_pt + shift_r def_min_pt = self . grid . min_pt - 0.5 * csizes_l def_max_pt = self . grid . max_pt + 0.5 * csizes_r optmod = [ ] if ( np . allclose ( self . min_pt , nodes_def_min_pt ) and np . allclose ( self . max_pt , nodes_def_max_pt ) ) :                  optargs . append ( ( <str> , self . nodes_on_bdry , False ) ) optmod . append ( <str> )  else :                  if not np . allclose ( self . min_pt , def_min_pt ) :                      if self . ndim == 1 :                          optargs . append ( ( <str> , self . min_pt [ 0 ] , None ) ) optmod . append ( <str> )  else :                          with npy_printoptions ( precision = 4 ) :                              optargs . append ( ( <str> , array_str ( self . min_pt ) , <str> ) )  optmod . append ( <str> )   if not np . allclose ( self . max_pt , def_max_pt ) :                      if self . ndim == 1 :                          optargs . append ( ( <str> , self . max_pt [ 0 ] , None ) ) optmod . append ( <str> )  else :                          with npy_printoptions ( precision = 4 ) :                              optargs . append ( ( <str> , array_str ( self . max_pt ) , <str> ) )  optmod . append ( <str> )    sig_str = signature_string ( posargs , optargs , mod = [ posmod , optmod ] , sep = [ <str> , <str> , <str> ] ) return <str> . format ( ctor , indent ( sig_str ) )   def __str__ ( self ) :          return repr ( self )   def uniform_partition_fromintv ( intv_prod , shape , nodes_on_bdry = False ) :      grid = uniform_grid_fromintv ( intv_prod , shape , nodes_on_bdry = nodes_on_bdry ) return RectPartition ( intv_prod , grid )  def uniform_partition_fromgrid ( grid , min_pt = None , max_pt = None ) :      if min_pt is None :          min_pt = { i : None for i in range ( grid . ndim ) }  elif not hasattr ( min_pt , <str> ) :          min_pt = np . atleast_1d ( min_pt ) min_pt = { i : float ( v ) for i , v in enumerate ( min_pt ) }  else :          min_pt . update ( { i : None for i in range ( grid . ndim ) if i not in min_pt and i - grid . ndim not in min_pt } )  if max_pt is None :          max_pt = { i : None for i in range ( grid . ndim ) }  elif not hasattr ( max_pt , <str> ) :          max_pt = np . atleast_1d ( max_pt ) max_pt = { i : float ( v ) for i , v in enumerate ( max_pt ) }  else :          max_pt . update ( { i : None for i in range ( grid . ndim ) if i not in max_pt and i - grid . ndim not in max_pt } )  min_pt_vec = np . empty ( grid . ndim ) for ax , xmin in min_pt . items ( ) :          if xmin is None :              cvec = grid . coord_vectors [ ax ] if len ( cvec ) == 1 :                  raise ValueError ( <str> <str> . format ( ax ) )  min_pt_vec [ ax ] = cvec [ 0 ] - ( cvec [ 1 ] - cvec [ 0 ] ) / 2  else :              min_pt_vec [ ax ] = xmin   max_pt_vec = np . empty ( grid . ndim ) for ax , xmax in max_pt . items ( ) :          if xmax is None :              cvec = grid . coord_vectors [ ax ] if len ( cvec ) == 1 :                  raise ValueError ( <str> <str> . format ( ax ) )  max_pt_vec [ ax ] = cvec [ - 1 ] + ( cvec [ - 1 ] - cvec [ - 2 ] ) / 2  else :              max_pt_vec [ ax ] = xmax   return RectPartition ( IntervalProd ( min_pt_vec , max_pt_vec ) , grid )  def uniform_partition ( min_pt = None , max_pt = None , shape = None , cell_sides = None , nodes_on_bdry = False ) :      sizes = [ np . size ( p ) for p in ( min_pt , max_pt , shape , cell_sides ) if p is not None ] ndim = int ( np . max ( sizes ) ) min_pt = normalized_scalar_param_list ( min_pt , ndim , param_conv = float , keep_none = True ) max_pt = normalized_scalar_param_list ( max_pt , ndim , param_conv = float , keep_none = True ) shape = normalized_scalar_param_list ( shape , ndim , param_conv = safe_int_conv , keep_none = True ) cell_sides = normalized_scalar_param_list ( cell_sides , ndim , param_conv = float , keep_none = True ) nodes_on_bdry = normalized_nodes_on_bdry ( nodes_on_bdry , ndim ) for i , ( xmin , xmax , n , dx , on_bdry ) in enumerate ( zip ( min_pt , max_pt , shape , cell_sides , nodes_on_bdry ) ) :          num_params = sum ( p is not None for p in ( xmin , xmax , n , dx ) ) if num_params < 3 :              raise ValueError ( <str> <str> <str> <str> . format ( i , num_params ) )  try :              bdry_l , bdry_r = on_bdry  except TypeError :              bdry_l = bdry_r = on_bdry  if xmin is None :              min_pt [ i ] = xmax - ( n - sum ( [ bdry_l , bdry_r ] ) / 2.0 ) * dx  elif xmax is None :              max_pt [ i ] = xmin + ( n - sum ( [ bdry_l , bdry_r ] ) / 2.0 ) * dx  elif n is None :              n_calc = ( xmax - xmin ) / dx + sum ( [ bdry_l , bdry_r ] ) / 2.0 n_round = int ( round ( n_calc ) ) if abs ( n_calc - n_round ) > 1e-5 :                  raise ValueError ( <str> <str> <str> . format ( i , n_calc , xmax , xmin , dx ) )  shape [ i ] = n_round  elif dx is None :              pass  else :              xmax_calc = xmin + ( n - sum ( [ bdry_l , bdry_r ] ) / 2.0 ) * dx if not np . isclose ( xmax , xmax_calc ) :                  raise ValueError ( <str> <str> <str> <str> . format ( i , xmax_calc , xmin , n , dx , xmax ) )    return uniform_partition_fromintv ( IntervalProd ( min_pt , max_pt ) , shape , nodes_on_bdry )  def nonuniform_partition ( * coord_vecs , ** kwargs ) :      min_pt = kwargs . pop ( <str> , None ) max_pt = kwargs . pop ( <str> , None ) nodes_on_bdry = kwargs . pop ( <str> , False ) sizes = [ len ( coord_vecs ) ] + [ np . size ( p ) for p in ( min_pt , max_pt ) ] ndim = int ( np . max ( sizes ) ) min_pt = normalized_scalar_param_list ( min_pt , ndim , param_conv = float , keep_none = True ) max_pt = normalized_scalar_param_list ( max_pt , ndim , param_conv = float , keep_none = True ) nodes_on_bdry = normalized_nodes_on_bdry ( nodes_on_bdry , ndim ) for i , ( xmin , xmax , ( bdry_l , bdry_r ) , coords ) in enumerate ( zip ( min_pt , max_pt , nodes_on_bdry , coord_vecs ) ) :          if xmin is not None and bdry_l :              raise ValueError ( <str> <str> . format ( i ) )  if xmax is not None and bdry_r :              raise ValueError ( <str> <str> . format ( i ) )  coords = np . array ( coords , copy = False , ndmin = 1 ) if xmin is None :              if bdry_l or len ( coords ) == 1 :                  min_pt [ i ] = coords [ 0 ]  else :                  min_pt [ i ] = coords [ 0 ] - ( coords [ 1 ] - coords [ 0 ] ) / 2.0   if xmax is None :              if bdry_r or len ( coords ) == 1 :                  max_pt [ i ] = coords [ - 1 ]  else :                  max_pt [ i ] = coords [ - 1 ] + ( coords [ - 1 ] - coords [ - 2 ] ) / 2.0    interval = IntervalProd ( min_pt , max_pt ) grid = RectGrid ( * coord_vecs ) return RectPartition ( interval , grid )  if __name__ == <str> :      from odl . util . testutils import run_doctests run_doctests ( )   