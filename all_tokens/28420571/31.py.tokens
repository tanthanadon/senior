from __future__ import division from itertools import product import numpy as np import pytest import odl from odl . trafos . util . ft_utils import ( reciprocal_grid , realspace_grid , dft_preprocess_data ) from odl . util import all_almost_equal , all_equal from odl . util . testutils import simple_fixture halfcomplex = simple_fixture ( <str> , [ True , False ] ) shift = simple_fixture ( <str> , [ True , False ] ) parity = simple_fixture ( <str> , [ <str> , <str> ] ) sign = simple_fixture ( <str> , [ <str> , <str> ] ) def test_reciprocal_grid_1d ( halfcomplex , shift , parity ) :      shape = 10 if parity == <str> else 11 grid = odl . uniform_grid ( 0 , 1 , shape = shape ) s = grid . stride n = np . array ( grid . shape ) rgrid = reciprocal_grid ( grid , shift = shift , halfcomplex = halfcomplex ) true_recip_stride = 2 * np . pi / ( s * n ) assert all_almost_equal ( rgrid . stride , true_recip_stride ) if halfcomplex :          assert all_equal ( rgrid . shape , n // 2 + 1 ) if parity == <str> and shift :              assert all_almost_equal ( rgrid . max_pt , - true_recip_stride / 2 )  elif parity == <str> and not shift :              assert all_almost_equal ( rgrid . max_pt , true_recip_stride / 2 )  elif ( parity == <str> and not shift ) or ( parity == <str> and shift ) :              assert all_almost_equal ( rgrid . max_pt , 0 )  else :              raise RuntimeError ( <str> )   else :          assert all_equal ( rgrid . shape , n ) if ( parity == <str> and shift ) or ( parity == <str> and not shift ) :              assert all_almost_equal ( rgrid [ n // 2 ] , 0 )  elif ( parity == <str> and shift ) or ( parity == <str> and not shift ) :              atol = 0.999 * true_recip_stride / 2 assert not rgrid . approx_contains ( 0 , atol = atol )  else :              raise RuntimeError ( <str> )  if not shift :              assert all_almost_equal ( rgrid . min_pt , - rgrid . max_pt ) if parity == <str> :                  assert all_almost_equal ( rgrid . mid_pt , 0 )    irgrid = realspace_grid ( rgrid , grid . min_pt , halfcomplex = halfcomplex , halfcx_parity = parity ) assert irgrid . approx_equals ( grid , atol = 1e-6 )  def test_reciprocal_grid_nd ( ) :      grid = odl . uniform_grid ( [ 0 ] * 3 , [ 1 ] * 3 , shape = ( 3 , 4 , 5 ) ) s = grid . stride n = np . array ( grid . shape ) true_recip_stride = 2 * np . pi / ( s * n ) rgrid = reciprocal_grid ( grid , shift = False , halfcomplex = False ) assert all_equal ( rgrid . shape , n ) assert all_almost_equal ( rgrid . stride , true_recip_stride ) assert all_almost_equal ( rgrid . min_pt , - rgrid . max_pt ) irgrid = realspace_grid ( rgrid , grid . min_pt , halfcomplex = False ) assert irgrid . approx_equals ( grid , atol = 1e-6 )  def test_reciprocal_grid_nd_shift_list ( ) :      grid = odl . uniform_grid ( [ 0 ] * 3 , [ 1 ] * 3 , shape = ( 3 , 4 , 5 ) ) s = grid . stride n = np . array ( grid . shape ) shift = [ False , True , False ] true_recip_stride = 2 * np . pi / ( s * n ) rgrid = reciprocal_grid ( grid , shift = shift , halfcomplex = False ) noshift = np . where ( np . logical_not ( shift ) ) assert all_equal ( rgrid . shape , n ) assert all_almost_equal ( rgrid . stride , true_recip_stride ) assert all_almost_equal ( rgrid . min_pt [ noshift ] , - rgrid . max_pt [ noshift ] ) assert all_almost_equal ( rgrid [ n // 2 ] , [ 0 ] * 3 ) irgrid = realspace_grid ( rgrid , grid . min_pt , halfcomplex = False ) assert irgrid . approx_equals ( grid , atol = 1e-6 )  def test_reciprocal_grid_nd_axes ( ) :      grid = odl . uniform_grid ( [ 0 ] * 3 , [ 1 ] * 3 , shape = ( 3 , 4 , 5 ) ) s = grid . stride n = np . array ( grid . shape ) axes_list = [ [ 1 , - 1 ] , [ 0 ] , 0 , [ 0 , 2 , 1 ] , [ 2 , 0 ] ] for axes in axes_list :          active = np . zeros ( grid . ndim , dtype = bool ) active [ axes ] = True inactive = np . logical_not ( active ) true_recip_stride = np . empty ( grid . ndim ) true_recip_stride [ active ] = 2 * np . pi / ( s [ active ] * n [ active ] ) true_recip_stride [ inactive ] = s [ inactive ] rgrid = reciprocal_grid ( grid , shift = False , axes = axes , halfcomplex = False ) assert all_equal ( rgrid . shape , n ) assert all_almost_equal ( rgrid . stride , true_recip_stride ) assert all_almost_equal ( rgrid . min_pt [ active ] , - rgrid . max_pt [ active ] ) assert all_equal ( rgrid . min_pt [ inactive ] , grid . min_pt [ inactive ] ) assert all_equal ( rgrid . max_pt [ inactive ] , grid . max_pt [ inactive ] ) irgrid = realspace_grid ( rgrid , grid . min_pt , axes = axes , halfcomplex = False ) assert irgrid . approx_equals ( grid , atol = 1e-6 )   def test_reciprocal_grid_nd_halfcomplex ( ) :      grid = odl . uniform_grid ( [ 0 ] * 3 , [ 1 ] * 3 , shape = ( 3 , 4 , 5 ) ) s = grid . stride n = np . array ( grid . shape ) stride_last = 2 * np . pi / ( s [ - 1 ] * n [ - 1 ] ) n [ - 1 ] = n [ - 1 ] // 2 + 1 rgrid = reciprocal_grid ( grid , shift = False , halfcomplex = True ) assert all_equal ( rgrid . shape , n ) assert rgrid . max_pt [ - 1 ] == 0 rgrid = reciprocal_grid ( grid , shift = True , halfcomplex = True ) assert all_equal ( rgrid . shape , n ) assert rgrid . max_pt [ - 1 ] == - stride_last / 2 irgrid = realspace_grid ( rgrid , grid . min_pt , halfcomplex = True , halfcx_parity = <str> ) assert irgrid . approx_equals ( grid , atol = 1e-6 ) with pytest . raises ( ValueError ) :          realspace_grid ( rgrid , grid . min_pt , halfcomplex = True , halfcx_parity = <str> )   def test_dft_preprocess_data ( sign ) :      shape = ( 2 , 3 , 4 ) correct_arr = [ ] for i , j , k in product ( range ( shape [ 0 ] ) , range ( shape [ 1 ] ) , range ( shape [ 2 ] ) ) :          correct_arr . append ( ( 1 + 1j ) * ( 1 - 2 * ( ( i + j + k ) % 2 ) ) )  arr = np . ones ( shape , dtype = <str> ) * ( 1 + 1j ) preproc = dft_preprocess_data ( arr , shift = True , sign = sign ) dft_preprocess_data ( arr , shift = True , out = arr , sign = sign ) assert all_almost_equal ( preproc . ravel ( ) , correct_arr ) assert all_almost_equal ( arr . ravel ( ) , correct_arr ) imag = 1j if sign == <str> else - 1j correct_arr = [ ] for i , j , k in product ( range ( shape [ 0 ] ) , range ( shape [ 1 ] ) , range ( shape [ 2 ] ) ) :          argsum = sum ( ( idx * ( 1 - 1 / shp ) ) for idx , shp in zip ( ( i , j , k ) , shape ) ) correct_arr . append ( ( 1 + 1j ) * np . exp ( imag * np . pi * argsum ) )  arr = np . ones ( shape , dtype = <str> ) * ( 1 + 1j ) dft_preprocess_data ( arr , shift = False , out = arr , sign = sign ) assert all_almost_equal ( arr . ravel ( ) , correct_arr ) with pytest . raises ( ValueError ) :          dft_preprocess_data ( arr , out = arr , sign = 1 )  arr = np . zeros ( shape , dtype = <str> ) with pytest . raises ( ValueError ) :          dft_preprocess_data ( arr )   def test_dft_preprocess_data_halfcomplex ( sign ) :      shape = ( 2 , 3 , 4 ) correct_arr = [ ] for i , j , k in product ( range ( shape [ 0 ] ) , range ( shape [ 1 ] ) , range ( shape [ 2 ] ) ) :          correct_arr . append ( 1 - 2 * ( ( i + j + k ) % 2 ) )  arr = np . ones ( shape , dtype = <str> ) preproc = dft_preprocess_data ( arr , shift = True , sign = sign ) out = np . empty_like ( arr ) dft_preprocess_data ( arr , shift = True , out = out , sign = sign ) dft_preprocess_data ( arr , shift = True , out = arr , sign = sign ) assert all_almost_equal ( preproc . ravel ( ) , correct_arr ) assert all_almost_equal ( arr . ravel ( ) , correct_arr ) assert all_almost_equal ( out . ravel ( ) , correct_arr ) imag = 1j if sign == <str> else - 1j correct_arr = [ ] for i , j , k in product ( range ( shape [ 0 ] ) , range ( shape [ 1 ] ) , range ( shape [ 2 ] ) ) :          argsum = sum ( ( idx * ( 1 - 1 / shp ) ) for idx , shp in zip ( ( i , j , k ) , shape ) ) correct_arr . append ( np . exp ( imag * np . pi * argsum ) )  arr = np . ones ( shape , dtype = <str> ) preproc = dft_preprocess_data ( arr , shift = False , sign = sign ) assert all_almost_equal ( preproc . ravel ( ) , correct_arr ) arr = np . ones ( shape , dtype = <str> ) preproc = dft_preprocess_data ( arr , shift = False , sign = sign ) assert all_almost_equal ( preproc . ravel ( ) , correct_arr ) arr = np . ones ( shape , dtype = <str> ) with pytest . raises ( ValueError ) :          dft_preprocess_data ( arr , shift = False , out = arr , sign = sign )   def test_dft_preprocess_data_with_axes ( sign ) :      shape = ( 2 , 3 , 4 ) axes = 1 correct_arr = [ ] for _ , j , __ in product ( range ( shape [ 0 ] ) , range ( shape [ 1 ] ) , range ( shape [ 2 ] ) ) :          correct_arr . append ( 1 - 2 * ( j % 2 ) )  arr = np . ones ( shape , dtype = <str> ) dft_preprocess_data ( arr , shift = True , axes = axes , out = arr , sign = sign ) assert all_almost_equal ( arr . ravel ( ) , correct_arr ) axes = [ 0 , - 1 ] correct_arr = [ ] for i , _ , k in product ( range ( shape [ 0 ] ) , range ( shape [ 1 ] ) , range ( shape [ 2 ] ) ) :          correct_arr . append ( 1 - 2 * ( ( i + k ) % 2 ) )  arr = np . ones ( shape , dtype = <str> ) dft_preprocess_data ( arr , shift = True , axes = axes , out = arr , sign = sign ) assert all_almost_equal ( arr . ravel ( ) , correct_arr )  if __name__ == <str> :      odl . util . test_file ( __file__ )   