from __future__ import print_function , division , absolute_import import numpy as np __all__ = ( <str> , <str> , <str> , <str> , <str> , <str> , <str> ) def euler_matrix ( phi , theta = None , psi = None ) :      if theta is None and psi is None :          squeeze_out = ( np . shape ( phi ) == ( ) ) ndim = 2 phi = np . array ( phi , dtype = float , copy = False , ndmin = 1 ) theta = psi = 0.0  else :          squeeze_out = ( np . broadcast ( phi , theta , psi ) . shape == ( ) ) ndim = 3 phi = np . array ( phi , dtype = float , copy = False , ndmin = 1 ) if theta is None :              theta = 0.0  if psi is None :              psi = 0.0  theta = np . array ( theta , dtype = float , copy = False , ndmin = 1 ) psi = np . array ( psi , dtype = float , copy = False , ndmin = 1 ) ndim = 3  cph = np . cos ( phi ) sph = np . sin ( phi ) cth = np . cos ( theta ) sth = np . sin ( theta ) cps = np . cos ( psi ) sps = np . sin ( psi ) if ndim == 2 :          mat = np . array ( [ [ cph , - sph ] , [ sph , cph ] ] )  else :          mat = np . array ( [ [ cph * cps - sph * cth * sps , - cph * sps - sph * cth * cps , sph * sth ] , [ sph * cps + cph * cth * sps , - sph * sps + cph * cth * cps , - cph * sth ] , [ sth * sps + 0 * cph , sth * cps + 0 * cph , cth + 0 * ( cph + cps ) ] ] )  if squeeze_out :          return mat . squeeze ( )  else :          extra_dims = len ( np . broadcast ( phi , theta , psi ) . shape ) newaxes = list ( range ( 2 , 2 + extra_dims ) ) + [ 0 , 1 ] return np . transpose ( mat , newaxes )   def axis_rotation ( axis , angle , vectors , axis_shift = ( 0 , 0 , 0 ) ) :      rot_matrix = axis_rotation_matrix ( axis , angle ) vectors = np . asarray ( vectors , dtype = float ) if vectors . shape == ( 3 , ) :          vectors = vectors [ None , : ]  elif vectors . ndim == 2 and vectors . shape [ 1 ] == 3 :          pass  else :          raise ValueError ( <str> <str> . format ( vectors . shape ) )  axis_shift = np . asarray ( axis_shift , dtype = float ) axis = np . asarray ( axis , dtype = float ) axis_shift = axis_shift - axis . dot ( axis_shift ) * axis centered_vecs = vectors - axis_shift [ None , : ] rot_vecs = rot_matrix . dot ( centered_vecs . T ) . T return axis_shift [ None , : ] + rot_vecs  def axis_rotation_matrix ( axis , angle ) :      scalar_out = ( np . shape ( angle ) == ( ) ) axis = np . asarray ( axis ) if axis . shape != ( 3 , ) :          raise ValueError ( <str> <str> . format ( axis . shape ) )  angle = np . array ( angle , dtype = float , copy = False , ndmin = 1 ) cross_mat = np . array ( [ [ 0 , - axis [ 2 ] , axis [ 1 ] ] , [ axis [ 2 ] , 0 , - axis [ 0 ] ] , [ - axis [ 1 ] , axis [ 0 ] , 0 ] ] ) dy_mat = np . outer ( axis , axis ) id_mat = np . eye ( 3 ) cos_ang = np . cos ( angle ) sin_ang = np . sin ( angle ) extra_dims = cos_ang . ndim mat_slc = ( None , ) * extra_dims + ( slice ( None ) , slice ( None ) ) ang_slc = ( slice ( None ) , ) * extra_dims + ( None , None ) cross_mat = cross_mat [ mat_slc ] dy_mat = dy_mat [ mat_slc ] id_mat = id_mat [ mat_slc ] cos_ang = cos_ang [ ang_slc ] sin_ang = sin_ang [ ang_slc ] axis_mat = cos_ang * id_mat + ( 1. - cos_ang ) * dy_mat + sin_ang * cross_mat if scalar_out :          return axis_mat . squeeze ( )  else :          return axis_mat   def rotation_matrix_from_to ( from_vec , to_vec ) :      <str> from_vec , from_vec_in = ( np . array ( from_vec , dtype = float , copy = True ) , from_vec ) to_vec , to_vec_in = np . array ( to_vec , dtype = float , copy = True ) , to_vec if from_vec . shape not in ( ( 2 , ) , ( 3 , ) ) :          raise ValueError ( <str> <str> . format ( from_vec . shape ) )  if to_vec . shape not in ( ( 2 , ) , ( 3 , ) ) :          raise ValueError ( <str> <str> . format ( to_vec . shape ) )  if from_vec . shape != to_vec . shape :          raise ValueError ( <str> <str> <str> . format ( from_vec . shape , to_vec . shape ) )  ndim = len ( from_vec ) from_vec_norm = np . linalg . norm ( from_vec ) if from_vec_norm < 1e-10 :          raise ValueError ( <str> . format ( from_vec_in ) )  from_vec /= from_vec_norm to_vec_norm = np . linalg . norm ( to_vec ) if to_vec_norm < 1e-10 :          raise ValueError ( <str> . format ( to_vec_in ) )  to_vec /= to_vec_norm if ndim == 2 :          dot = np . dot ( from_vec , to_vec ) from_rot = ( - from_vec [ 1 ] , from_vec [ 0 ] ) if dot == 0 :              angle = np . pi / 2 if np . dot ( from_rot , to_vec ) > 0 else - np . pi / 2  elif np . array_equal ( to_vec , - from_vec ) :              angle = np . pi  else :              angle = ( np . sign ( np . dot ( from_rot , to_vec ) ) * np . arccos ( np . dot ( from_vec , to_vec ) ) )  return np . array ( [ [ np . cos ( angle ) , - np . sin ( angle ) ] , [ np . sin ( angle ) , np . cos ( angle ) ] ] )  elif ndim == 3 :          normal = np . cross ( from_vec , to_vec ) normal_norm = np . linalg . norm ( normal ) if normal_norm < 1e-10 :              normal = perpendicular_vector ( from_vec ) angle = 0 if np . dot ( from_vec , to_vec ) > 0 else np . pi return axis_rotation_matrix ( normal , angle )  else :              normal /= normal_norm binormal = np . cross ( normal , from_vec ) angle = ( np . sign ( np . dot ( binormal , to_vec ) ) * np . arccos ( np . dot ( from_vec , to_vec ) ) ) return axis_rotation_matrix ( normal , angle )   else :          raise RuntimeError ( <str> )   def transform_system ( principal_vec , principal_default , other_vecs , matrix = None ) :      transformed_vecs = [ ] principal_vec = np . asarray ( principal_vec , dtype = float ) ndim = principal_vec . shape [ 0 ] if matrix is None :          principal_default = np . asarray ( principal_default , dtype = float ) pr_norm = np . linalg . norm ( principal_vec ) pr_default_norm = np . linalg . norm ( principal_default ) if pr_default_norm == 0.0 and pr_norm != 0.0 :              raise ValueError ( <str> <str> . format ( principal_default , principal_vec ) )  elif pr_norm == 0.0 and pr_default_norm != 0.0 :              raise ValueError ( <str> <str> . format ( principal_default , principal_vec ) )  elif pr_norm == 0.0 and pr_default_norm == 0.0 :              dilation = 1.0  else :              dilation = ( np . linalg . norm ( principal_vec ) / np . linalg . norm ( principal_default ) )  if np . allclose ( principal_vec , dilation * principal_default ) :              matrix = np . eye ( ndim )  else :              matrix = rotation_matrix_from_to ( principal_default , principal_vec )  transformed_vecs . append ( principal_vec )  else :          matrix = np . asarray ( matrix , dtype = float ) if matrix . shape != ( ndim , ndim ) :              raise ValueError ( <str> <str> . format ( ( ndim , ndim ) , matrix . shape ) )  svals = np . linalg . svd ( matrix , compute_uv = False ) condition = np . inf if 0.0 in svals else svals [ 0 ] / svals [ - 1 ] if condition > 1e6 :              raise np . linalg . LinAlgError ( <str> <str> . format ( condition ) )  transformed_vecs . append ( matrix . dot ( principal_vec ) )  for vec in other_vecs :          if vec is None :              transformed_vecs . append ( None )  else :              transformed_vecs . append ( matrix . dot ( vec ) )   return tuple ( transformed_vecs )  def is_rotation_matrix ( mat , show_diff = False ) :      from scipy . linalg import det , norm dim = mat . shape [ 0 ] if dim != mat . shape [ 1 ] :          return False  determ = det ( mat ) right_handed = ( np . abs ( determ - 1. ) < 1E-10 ) orthonorm_diff = mat * mat . T - np . eye ( dim ) diff_norm = norm ( orthonorm_diff , 2 ) orthonormal = ( diff_norm < 1E-10 ) if not right_handed or not orthonormal :          if show_diff :              print ( <str> , mat ) print ( <str> , determ ) print ( <str> , orthonorm_diff ) print ( <str> , diff_norm )  return False  return True  def angles_from_matrix ( rot_matrix ) :      if rot_matrix . shape == ( 2 , 2 ) :          theta = np . atan2 ( rot_matrix [ 1 , 0 ] , rot_matrix [ 0 , 0 ] ) return theta ,  elif rot_matrix . shape == ( 3 , 3 ) :          if rot_matrix [ 2 , 2 ] == 1. :              theta = 0. psi = 0. phi = np . atan2 ( rot_matrix [ 1 , 0 ] , rot_matrix [ 0 , 0 ] ) if phi < 0 :                  phi += 2 * np . pi   else :              phi = np . atan2 ( rot_matrix [ 0 , 2 ] , - rot_matrix [ 1 , 2 ] ) psi = np . atan2 ( rot_matrix [ 2 , 0 ] , rot_matrix [ 2 , 1 ] ) theta = np . acos ( rot_matrix [ 2 , 2 ] ) if phi < 0. or psi < 0. :                  phi += np . pi psi += np . pi theta = - theta   return phi , theta , psi  else :          raise ValueError ( <str> <str> . format ( rot_matrix . shape ) )   def to_lab_sys ( vec_in_local_coords , local_sys ) :      vec_in_local_coords = np . array ( vec_in_local_coords ) trafo_matrix = np . matrix ( local_sys ) . T return np . dot ( trafo_matrix , vec_in_local_coords )  def to_local_sys ( vec_in_lab_coords , local_sys ) :      vec_in_lab_coords = np . array ( vec_in_lab_coords ) trafo_matrix = np . matrix ( local_sys ) return np . dot ( trafo_matrix , vec_in_lab_coords )  def perpendicular_vector ( vec ) :      squeeze_out = ( np . ndim ( vec ) == 1 ) vec = np . array ( vec , dtype = float , copy = False , ndmin = 2 ) if np . any ( np . all ( vec == 0 , axis = - 1 ) ) :          raise ValueError ( <str> )  result = np . zeros ( vec . shape ) cond = np . any ( vec [ ... , : 2 ] != 0 , axis = - 1 ) result [ cond , 0 ] = - vec [ cond , 1 ] result [ cond , 1 ] = vec [ cond , 0 ] result [ ~ cond , 0 ] = 1 result /= np . linalg . norm ( result , axis = - 1 , keepdims = True ) if squeeze_out :          result = result . squeeze ( )  return result  def is_inside_bounds ( value , params ) :      if value in params :          return True  else :          if params . ndim == 1 :              return params . contains_all ( np . ravel ( value ) )  else :              bcast_value = np . broadcast_arrays ( * value ) stacked_value = np . vstack ( bcast_value ) flat_value = stacked_value . reshape ( params . ndim , - 1 ) return params . contains_all ( flat_value )    if __name__ == <str> :      from odl . util . testutils import run_doctests run_doctests ( )   