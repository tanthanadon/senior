from __future__ import print_function , division , absolute_import import numpy as np __all__ = ( <str> , <str> , <str> , <str> , <str> ) def normalized_scalar_param_list ( param , length , param_conv = None , keep_none = True , return_nonconv = False ) :      length , length_in = int ( length ) , length if length < 0 :          raise ValueError ( <str> <str> . format ( length_in ) )  param = np . array ( param , dtype = object , copy = True , ndmin = 1 ) nonconv_list = list ( np . broadcast_to ( param , ( length , ) ) ) if len ( nonconv_list ) != length :          raise ValueError ( <str> <str> . format ( len ( nonconv_list ) , length ) )  if param_conv is None :          out_list = list ( nonconv_list )  else :          out_list = [ ] for p in nonconv_list :              if p is None and keep_none :                  out_list . append ( p )  else :                  out_list . append ( param_conv ( p ) )    if return_nonconv :          return out_list , nonconv_list  else :          return out_list   def normalized_index_expression ( indices , shape , int_to_slice = False ) :      ndim = len ( shape ) if np . isscalar ( indices ) :          indices = [ indices , Ellipsis ]  elif ( isinstance ( indices , slice ) or indices is Ellipsis ) :          indices = [ indices ]  indices = list ( indices ) if len ( indices ) < ndim and Ellipsis not in indices :          indices . append ( Ellipsis )  if Ellipsis in indices :          if indices . count ( Ellipsis ) > 1 :              raise ValueError ( <str> )  eidx = indices . index ( Ellipsis ) extra_dims = ndim - len ( indices ) + 1 indices = ( indices [ : eidx ] + [ slice ( None ) ] * extra_dims + indices [ eidx + 1 : ] )  for ( i , idx ) , n in zip ( enumerate ( indices ) , shape ) :          if np . isscalar ( idx ) :              if idx < 0 :                  idx += n  if idx >= n :                  raise IndexError ( <str> <str> <str> . format ( idx , i , n ) )  if int_to_slice :                  indices [ i ] = slice ( idx , idx + 1 )    if any ( s . start == s . stop and s . start is not None or s . start == n for s , n in zip ( indices , shape ) if isinstance ( s , slice ) ) :          raise ValueError ( <str> )  if None in indices :          raise ValueError ( <str> )  if len ( indices ) > ndim :          raise IndexError ( <str> <str> . format ( len ( indices ) , ndim ) )  return tuple ( indices )  def normalized_nodes_on_bdry ( nodes_on_bdry , length ) :      shape = np . shape ( nodes_on_bdry ) if shape == ( ) :          out_list = [ ( bool ( nodes_on_bdry ) , bool ( nodes_on_bdry ) ) ] * length  elif length == 1 and shape == ( 2 , ) :          out_list = [ ( bool ( nodes_on_bdry [ 0 ] ) , bool ( nodes_on_bdry [ 1 ] ) ) ]  elif len ( nodes_on_bdry ) == length :          out_list = [ ] for i , on_bdry in enumerate ( nodes_on_bdry ) :              shape_i = np . shape ( on_bdry ) if shape_i == ( ) :                  out_list . append ( ( bool ( on_bdry ) , bool ( on_bdry ) ) )  elif shape_i == ( 2 , ) :                  out_list . append ( ( bool ( on_bdry [ 0 ] ) , bool ( on_bdry [ 1 ] ) ) )  else :                  raise ValueError ( <str> <str> . format ( i , shape_i ) )    else :          raise ValueError ( <str> <str> . format ( shape , length ) )  return out_list  def normalized_axes_tuple ( axes , ndim ) :      try :          axes , axes_in = ( int ( axes ) , ) , axes  except TypeError :          axes , axes_in = tuple ( int ( axis ) for axis in axes ) , axes if any ( axis != axis_in for axis , axis_in in zip ( axes , axes_in ) ) :              raise ValueError ( <str> <str> . format ( axes_in ) )   else :          if axes [ 0 ] != axes_in :              raise TypeError ( <str> <str> . format ( axes_in ) )   if len ( set ( axes ) ) != len ( axes ) :          raise ValueError ( <str> )  ndim , ndim_in = int ( ndim ) , ndim if ndim <= 0 :          raise ValueError ( <str> . format ( ndim_in ) )  axes_arr = np . array ( axes ) axes_arr [ axes_arr < 0 ] += ndim if np . any ( ( axes_arr < 0 ) | ( axes_arr >= ndim ) ) :          raise ValueError ( <str> <str> . format ( ndim , axes_in ) )  return tuple ( axes_arr )  def safe_int_conv ( number ) :      try :          return int ( np . array ( number ) . astype ( int , casting = <str> ) )  except TypeError :          raise ValueError ( <str> . format ( number ) )   if __name__ == <str> :      from odl . util . testutils import run_doctests run_doctests ( )   