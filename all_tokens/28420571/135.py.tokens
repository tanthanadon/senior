from __future__ import print_function , division , absolute_import from builtins import next import numpy as np from odl . operator import IdentityOperator , OperatorComp , OperatorSum from odl . util import normalized_scalar_param_list __all__ = ( <str> , <str> , <str> , <str> , <str> ) def landweber ( op , x , rhs , niter , omega = None , projection = None , callback = None ) :      <str> if x not in op . domain :          raise TypeError ( <str> <str> . format ( x , op . domain ) )  if omega is None :          omega = 1 / op . norm ( estimate = True ) ** 2  tmp_ran = op . range . element ( ) tmp_dom = op . domain . element ( ) for _ in range ( niter ) :          op ( x , out = tmp_ran ) tmp_ran -= rhs op . derivative ( x ) . adjoint ( tmp_ran , out = tmp_dom ) x . lincomb ( 1 , x , - omega , tmp_dom ) if projection is not None :              projection ( x )  if callback is not None :              callback ( x )    def conjugate_gradient ( op , x , rhs , niter , callback = None ) :      if op . domain != op . range :          raise ValueError ( <str> )  if x not in op . domain :          raise TypeError ( <str> <str> . format ( x , op . domain ) )  r = op ( x ) r . lincomb ( 1 , rhs , - 1 , r ) p = r . copy ( ) d = op . domain . element ( ) sqnorm_r_old = r . norm ( ) ** 2 if sqnorm_r_old == 0 :          return  for _ in range ( niter ) :          op ( p , out = d ) inner_p_d = p . inner ( d ) if inner_p_d == 0.0 :              return  alpha = sqnorm_r_old / inner_p_d x . lincomb ( 1 , x , alpha , p ) r . lincomb ( 1 , r , - alpha , d ) sqnorm_r_new = r . norm ( ) ** 2 beta = sqnorm_r_new / sqnorm_r_old sqnorm_r_old = sqnorm_r_new p . lincomb ( 1 , r , beta , p ) if callback is not None :              callback ( x )    def conjugate_gradient_normal ( op , x , rhs , niter = 1 , callback = None ) :      if x not in op . domain :          raise TypeError ( <str> <str> . format ( x , op . domain ) )  d = op ( x ) d . lincomb ( 1 , rhs , - 1 , d ) p = op . derivative ( x ) . adjoint ( d ) s = p . copy ( ) q = op . range . element ( ) sqnorm_s_old = s . norm ( ) ** 2 for _ in range ( niter ) :          op ( p , out = q ) sqnorm_q = q . norm ( ) ** 2 if sqnorm_q == 0.0 :              return  a = sqnorm_s_old / sqnorm_q x . lincomb ( 1 , x , a , p ) d . lincomb ( 1 , d , - a , q ) op . derivative ( p ) . adjoint ( d , out = s ) sqnorm_s_new = s . norm ( ) ** 2 b = sqnorm_s_new / sqnorm_s_old sqnorm_s_old = sqnorm_s_new p . lincomb ( 1 , s , b , p ) if callback is not None :              callback ( x )    def exp_zero_seq ( base ) :      value = 1.0 while True :          value /= base yield value   def gauss_newton ( op , x , rhs , niter , zero_seq = exp_zero_seq ( 2.0 ) , callback = None ) :      if x not in op . domain :          raise TypeError ( <str> <str> . format ( x , op . domain ) )  x0 = x . copy ( ) id_op = IdentityOperator ( op . domain ) dx = op . domain . zero ( ) tmp_dom = op . domain . element ( ) u = op . domain . element ( ) tmp_ran = op . range . element ( ) v = op . range . element ( ) for _ in range ( niter ) :          tm = next ( zero_seq ) deriv = op . derivative ( x ) deriv_adjoint = deriv . adjoint op ( x , out = tmp_ran ) v . lincomb ( 1 , rhs , - 1 , tmp_ran ) tmp_dom . lincomb ( 1 , x0 , - 1 , x ) deriv ( tmp_dom , out = tmp_ran ) v -= tmp_ran deriv_adjoint ( v , out = u ) tikh_op = OperatorSum ( OperatorComp ( deriv . adjoint , deriv ) , tm * id_op , tmp_dom ) conjugate_gradient ( tikh_op , dx , u , 3 ) x . lincomb ( 1 , x0 , 1 , dx ) if callback is not None :              callback ( x )    def kaczmarz ( ops , x , rhs , niter , omega = 1 , projection = None , random = False , callback = None , callback_loop = <str> ) :      <str> domain = ops [ 0 ] . domain if any ( domain != opi . domain for opi in ops ) :          raise ValueError ( <str> )  if x not in domain :          raise TypeError ( <str> <str> . format ( x , domain ) )  if len ( ops ) != len ( rhs ) :          raise ValueError ( <str> <str> . format ( len ( ops ) , len ( rhs ) ) )  omega = normalized_scalar_param_list ( omega , len ( ops ) , param_conv = float ) ranges = [ opi . range for opi in ops ] unique_ranges = set ( ranges ) tmp_rans = { ran : ran . element ( ) for ran in unique_ranges } tmp_dom = domain . element ( ) for _ in range ( niter ) :          if random :              rng = np . random . permutation ( range ( len ( ops ) ) )  else :              rng = range ( len ( ops ) )  for i in rng :              tmp_ran = tmp_rans [ ops [ i ] . range ] ops [ i ] ( x , out = tmp_ran ) tmp_ran -= rhs [ i ] ops [ i ] . derivative ( x ) . adjoint ( tmp_ran , out = tmp_dom ) x . lincomb ( 1 , x , - omega [ i ] , tmp_dom ) if projection is not None :                  projection ( x )  if callback is not None and callback_loop == <str> :                  callback ( x )   if callback is not None and callback_loop == <str> :              callback ( x )    if __name__ == <str> :      from odl . util . testutils import run_doctests run_doctests ( )   