from __future__ import print_function , division , absolute_import from builtins import object from numbers import Integral import numpy as np from odl . set . sets import RealNumbers , ComplexNumbers from odl . set . space import LinearSpace , LinearSpaceElement from odl . util import ( is_numeric_dtype , is_real_dtype , is_floating_dtype , is_real_floating_dtype , is_complex_floating_dtype , safe_int_conv , array_str , dtype_str , signature_string , indent , writable_array ) from odl . util . ufuncs import TensorSpaceUfuncs from odl . util . utility import TYPE_MAP_R2C , TYPE_MAP_C2R __all__ = ( <str> , ) class TensorSpace ( LinearSpace ) :      def __init__ ( self , shape , dtype ) :          try :              shape , shape_in = tuple ( safe_int_conv ( s ) for s in shape ) , shape  except TypeError :              shape , shape_in = ( safe_int_conv ( shape ) , ) , shape  if any ( s < 0 for s in shape ) :              raise ValueError ( <str> <str> . format ( shape_in ) )  dtype = np . dtype ( dtype ) self . __shape = dtype . shape + shape self . __dtype = dtype . base if is_real_dtype ( self . dtype ) :              field = RealNumbers ( ) self . __real_dtype = self . dtype self . __real_space = self self . __complex_dtype = TYPE_MAP_R2C . get ( self . dtype , None ) self . __complex_space = None  elif is_complex_floating_dtype ( self . dtype ) :              field = ComplexNumbers ( ) self . __real_dtype = TYPE_MAP_C2R [ self . dtype ] self . __real_space = None self . __complex_dtype = self . dtype self . __complex_space = self  else :              field = None  LinearSpace . __init__ ( self , field )  @ property def impl ( self ) :          raise NotImplementedError ( <str> )  @ property def shape ( self ) :          return self . __shape  @ property def dtype ( self ) :          return self . __dtype  @ property def is_real ( self ) :          return is_real_floating_dtype ( self . dtype )  @ property def is_complex ( self ) :          return is_complex_floating_dtype ( self . dtype )  @ property def real_dtype ( self ) :          if not is_numeric_dtype ( self . dtype ) :              raise NotImplementedError ( <str> )  return self . __real_dtype  @ property def complex_dtype ( self ) :          if not is_numeric_dtype ( self . dtype ) :              raise NotImplementedError ( <str> )  return self . __complex_dtype  @ property def real_space ( self ) :          if not is_numeric_dtype ( self . dtype ) :              raise ValueError ( <str> )  return self . astype ( self . real_dtype )  @ property def complex_space ( self ) :          if not is_numeric_dtype ( self . dtype ) :              raise ValueError ( <str> )  return self . astype ( self . complex_dtype )  def _astype ( self , dtype ) :          kwargs = { } if is_floating_dtype ( dtype ) :              weighting = getattr ( self , <str> , None ) if weighting is not None :                  kwargs [ <str> ] = weighting   return type ( self ) ( self . shape , dtype = dtype , ** kwargs )  def astype ( self , dtype ) :          if dtype is None :              raise ValueError ( <str> )  dtype = np . dtype ( dtype ) if dtype == self . dtype :              return self  if is_numeric_dtype ( self . dtype ) :              if dtype == self . __real_dtype :                  if self . __real_space is None :                      self . __real_space = self . _astype ( dtype )  return self . __real_space  elif dtype == self . __complex_dtype :                  if self . __complex_space is None :                      self . __complex_space = self . _astype ( dtype )  return self . __complex_space  else :                  return self . _astype ( dtype )   else :              return self . _astype ( dtype )   @ property def default_order ( self ) :          raise NotImplementedError ( <str> )  @ property def size ( self ) :          return ( 0 if self . shape == ( ) else int ( np . prod ( self . shape , dtype = <str> ) ) )  @ property def ndim ( self ) :          return len ( self . shape )  def __len__ ( self ) :          return int ( self . shape [ 0 ] )  @ property def itemsize ( self ) :          return int ( self . dtype . itemsize )  @ property def nbytes ( self ) :          return self . size * self . itemsize  def __contains__ ( self , other ) :          return getattr ( other , <str> , None ) == self  def __eq__ ( self , other ) :          if other is self :              return True  return ( type ( other ) is type ( self ) and self . shape == other . shape and self . dtype == other . dtype )  def __hash__ ( self ) :          return hash ( ( type ( self ) , self . shape , self . dtype ) )  def __repr__ ( self ) :          posargs = [ self . shape , dtype_str ( self . dtype ) ] return <str> . format ( self . __class__ . __name__ , signature_string ( posargs , [ ] ) )  def __str__ ( self ) :          return repr ( self )  @ property def examples ( self ) :          rand_state = np . random . get_state ( ) np . random . seed ( 1337 ) if is_numeric_dtype ( self . dtype ) :              yield ( <str> , self . element ( np . linspace ( 0 , 1 , self . size ) . reshape ( self . shape ) ) ) yield ( <str> , self . element ( np . random . standard_normal ( self . shape ) ) )  if self . is_real :              yield ( <str> , self . element ( np . random . uniform ( size = self . shape ) ) )  elif self . is_complex :              yield ( <str> , self . element ( np . random . uniform ( size = self . shape ) + np . random . uniform ( size = self . shape ) * 1j ) )  else :              raise NotImplementedError ( <str> <str> )  np . random . set_state ( rand_state )  def zero ( self ) :          raise NotImplementedError ( <str> )  def one ( self ) :          raise NotImplementedError ( <str> )  def _multiply ( self , x1 , x2 , out ) :          raise NotImplementedError ( <str> )  def _divide ( self , x1 , x2 , out ) :          raise NotImplementedError ( <str> )  @ staticmethod def default_dtype ( field = None ) :          raise NotImplementedError ( <str> )  @ staticmethod def available_dtypes ( ) :          raise NotImplementedError ( <str> )  @ property def element_type ( self ) :          return Tensor   class Tensor ( LinearSpaceElement ) :      def asarray ( self , out = None ) :          raise NotImplementedError ( <str> )  def __getitem__ ( self , indices ) :          raise NotImplementedError ( <str> )  def __setitem__ ( self , indices , values ) :          raise NotImplementedError ( <str> )  @ property def impl ( self ) :          return self . space . impl  @ property def shape ( self ) :          return self . space . shape  @ property def dtype ( self ) :          return self . space . dtype  @ property def size ( self ) :          return self . space . size  @ property def ndim ( self ) :          return self . space . ndim  def __len__ ( self ) :          return len ( self . space )  @ property def itemsize ( self ) :          return self . space . itemsize  @ property def nbytes ( self ) :          return self . space . nbytes  def astype ( self , dtype ) :          raise NotImplementedError ( <str> )  def __repr__ ( self ) :          maxsize_full_print = 2 * np . get_printoptions ( ) [ <str> ] self_str = array_str ( self , nprint = maxsize_full_print ) if self . ndim == 1 and self . size <= maxsize_full_print :              return <str> . format ( self . space , self_str )  else :              return <str> . format ( self . space , indent ( self_str ) )   def __str__ ( self ) :          return array_str ( self )  def __bool__ ( self ) :          if self . size > 1 :              raise ValueError ( <str> <str> <str> )  else :              return bool ( self . asarray ( ) )   def __array__ ( self , dtype = None ) :          if dtype is None :              return self . asarray ( )  else :              return self . asarray ( ) . astype ( dtype , copy = False )   def __array_wrap__ ( self , array ) :          if array . ndim == 0 :              return self . space . field . element ( array )  else :              return self . space . element ( array )   def __array_ufunc__ ( self , ufunc , method , * inputs , ** kwargs ) :          out_tuple = kwargs . pop ( <str> , ( ) ) if method == <str> and len ( out_tuple ) not in ( 0 , ufunc . nout ) :              raise ValueError ( <str> <str> <str> . format ( ufunc . __name__ , ufunc . nout , len ( out_tuple ) ) )  elif method != <str> and len ( out_tuple ) not in ( 0 , 1 ) :              raise ValueError ( <str> <str> . format ( ufunc . __name__ , method , len ( out_tuple ) ) )  valid_types = ( type ( self ) , type ( self . data ) , np . ndarray ) if not all ( isinstance ( o , valid_types ) or o is None for o in out_tuple ) :              return NotImplemented  out = out1 = out2 = None if len ( out_tuple ) == 1 :              out = out_tuple [ 0 ]  elif len ( out_tuple ) == 2 :              out1 = out_tuple [ 0 ] out2 = out_tuple [ 1 ]  inputs = tuple ( np . asarray ( inp ) if isinstance ( inp , ( type ( self ) , type ( self . data ) ) ) else inp for inp in inputs ) out_dtype = kwargs . get ( <str> , None ) if out_dtype is None :              array_kwargs = { }  else :              array_kwargs = { <str> : out_dtype }  class CtxNone ( object ) :              __enter__ = __exit__ = lambda * _ : None  if method == <str> :              if ufunc . nout == 1 :                  if out is None :                      out_ctx = CtxNone ( )  else :                      out_ctx = writable_array ( out , ** array_kwargs )  with out_ctx as out_arr :                      kwargs [ <str> ] = out_arr res = ufunc ( * inputs , ** kwargs )  return res  elif ufunc . nout == 2 :                  if out1 is not None :                      out1_ctx = writable_array ( out1 , ** array_kwargs )  else :                      out1_ctx = CtxNone ( )  if out2 is not None :                      out2_ctx = writable_array ( out2 , ** array_kwargs )  else :                      out2_ctx = CtxNone ( )  with out1_ctx as out1_arr , out2_ctx as out2_arr :                      kwargs [ <str> ] = ( out1_arr , out2_arr ) res1 , res2 = ufunc ( * inputs , ** kwargs )  return res1 , res2  else :                  raise NotImplementedError ( <str> <str> . format ( ufunc . nout ) )   else :              if out is None :                  out_ctx = CtxNone ( )  else :                  out_ctx = writable_array ( out , ** array_kwargs )  if method == <str> :                  with writable_array ( inputs [ 0 ] ) as inp_arr :                      res = ufunc . at ( inp_arr , * inputs [ 1 : ] , ** kwargs )   else :                  with out_ctx as out_arr :                      kwargs [ <str> ] = out_arr res = getattr ( ufunc , method ) ( * inputs , ** kwargs )   return res   @ property def ufuncs ( self ) :          return TensorSpaceUfuncs ( self )  def show ( self , title = None , method = <str> , indices = None , force_show = False , fig = None , ** kwargs ) :          from odl . discr import uniform_grid from odl . util . graphics import show_discrete_data if indices is None and self . ndim >= 3 :              indices = tuple ( [ slice ( None ) ] * 2 + [ n // 2 for n in self . space . shape [ 2 : ] ] )  if isinstance ( indices , ( Integral , slice ) ) :              indices = ( indices , )  elif indices is None or indices == Ellipsis :              indices = ( slice ( None ) , ) * self . ndim  else :              indices = tuple ( indices )  indices = tuple ( slice ( None ) if idx is None else idx for idx in indices ) if Ellipsis in indices :              pos = indices . index ( Ellipsis ) indices = ( indices [ : pos ] + ( np . s_ [ : ] , ) * ( self . ndim - len ( indices ) + 1 ) + indices [ pos + 1 : ] )  if len ( indices ) < self . ndim :              raise ValueError ( <str> . format ( len ( indices ) , self . ndim ) )  if len ( indices ) > self . ndim :              raise ValueError ( <str> . format ( len ( indices ) , self . ndim ) )  full_grid = uniform_grid ( [ 0 ] * self . ndim , np . array ( self . shape ) - 1 , self . shape ) grid = full_grid [ indices ] . squeeze ( ) values = self . asarray ( ) [ indices ] . squeeze ( ) return show_discrete_data ( values , grid , title = title , method = method , force_show = force_show , fig = fig , ** kwargs )   if __name__ == <str> :      from odl . util . testutils import run_doctests run_doctests ( )   