import numpy as np import scipy . misc import odl import matplotlib . pyplot as plt image = np . rot90 ( scipy . misc . ascent ( ) [ : : 2 , : : 2 ] . astype ( <str> ) , 3 ) shape = image . shape image /= image . max ( ) space = odl . uniform_discr ( [ 0 , 0 ] , shape , shape ) orig = space . element ( image . copy ( ) ) d = odl . phantom . white_noise ( space , orig , 0.1 ) op = odl . Gradient ( space ) norm_op = np . sqrt ( 8 ) + 1e-4 lam = 0.1 f = 1 / ( 2 * lam ) * odl . solvers . L2NormSquared ( space ) . translated ( d ) g = odl . solvers . Huber ( op . range , gamma = .01 ) obj_fun = f + g * op mu_g = 1 / lam mu_f = 1 / f . grad_lipschitz class CallbackStore ( odl . solvers . Callback ) :      def __init__ ( self ) :          self . iteration_count = 0 self . iteration_counts = [ ] self . obj_function_values = [ ]  def __call__ ( self , x ) :          self . iteration_count += 1 self . iteration_counts . append ( self . iteration_count ) self . obj_function_values . append ( obj_fun ( x ) )  def reset ( self ) :          self . iteration_count = 0 self . iteration_counts = [ ] self . obj_function_values = [ ]   callback = odl . solvers . CallbackPrintIteration ( step = 10 ) & CallbackStore ( ) niter = 200 kappa1 = np . sqrt ( 1 + 0.999 * norm_op ** 2 / ( mu_g * mu_f ) ) tau1 = 1 / ( mu_g * ( kappa1 - 1 ) ) sigma1 = 1 / ( mu_f * ( kappa1 - 1 ) ) theta1 = 1 - 2 / ( 1 + kappa1 ) kappa2 = norm_op / np . sqrt ( mu_f * mu_g ) tau2 = 1 / norm_op * np . sqrt ( mu_f / mu_g ) sigma2 = 1 / norm_op * np . sqrt ( mu_g / mu_f ) theta2 = 1 - 2 / ( 2 + kappa2 ) x1 = space . zero ( ) callback ( x1 ) odl . solvers . pdhg ( x1 , f , g , op , niter , tau1 , sigma1 , theta = theta1 , callback = callback ) obj1 = callback . callbacks [ 1 ] . obj_function_values callback . reset ( ) x2 = space . zero ( ) callback ( x2 ) odl . solvers . pdhg ( x2 , f , g , op , niter , tau2 , sigma2 , theta = theta2 , callback = callback ) obj2 = callback . callbacks [ 1 ] . obj_function_values clim = [ 0 , 1 ] cmap = <str> orig . show ( <str> , clim = clim , cmap = cmap ) d . show ( <str> , clim = clim , cmap = cmap ) x1 . show ( <str> , clim = clim , cmap = cmap ) x2 . show ( <str> , clim = clim , cmap = cmap ) min_obj = min ( obj1 + obj2 ) def rel_fun ( x ) :      x = np . array ( x ) return ( x - min_obj ) / ( x [ 0 ] - min_obj )  iters = np . array ( callback . callbacks [ 1 ] . iteration_counts ) plt . figure ( ) plt . semilogy ( iters , rel_fun ( obj1 ) , color = <str> , label = <str> ) plt . semilogy ( iters , rel_fun ( obj2 ) , color = <str> , label = <str> ) rho = theta1 plt . semilogy ( iters [ 1 : ] , rho ** iters [ 1 : ] , <str> , color = <str> , label = <str> . format ( rho ) ) rho = theta2 plt . semilogy ( iters [ 1 : ] , rho ** iters [ 1 : ] , <str> , color = <str> , label = <str> . format ( rho ) ) plt . title ( <str> ) plt . ylim ( ( 1e-16 , 1 ) ) plt . legend ( )  