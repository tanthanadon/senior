from __future__ import division import numpy as np import odl from odl . discr . grid import sparse_meshgrid from odl . contrib . fom . util import spherical_sum __all__ = ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) def mean_squared_error ( data , ground_truth , mask = None , normalized = False , force_lower_is_better = True ) :      <str> if not hasattr ( data , <str> ) :          data = odl . vector ( data )  space = data . space ground_truth = space . element ( ground_truth ) l2norm = odl . solvers . L2Norm ( space ) if mask is not None :          data = data * mask ground_truth = ground_truth * mask  diff = data - ground_truth fom = l2norm ( diff ) ** 2 if normalized :          fom /= ( l2norm ( data ) + l2norm ( ground_truth ) ) ** 2  else :          fom /= l2norm ( space . one ( ) ) ** 2  return fom  def mean_absolute_error ( data , ground_truth , mask = None , normalized = False , force_lower_is_better = True ) :      <str> if not hasattr ( data , <str> ) :          data = odl . vector ( data )  space = data . space ground_truth = space . element ( ground_truth ) l1_norm = odl . solvers . L1Norm ( space ) if mask is not None :          data = data * mask ground_truth = ground_truth * mask  diff = data - ground_truth fom = l1_norm ( diff ) if normalized :          fom /= ( l1_norm ( data ) + l1_norm ( ground_truth ) )  else :          fom /= l1_norm ( space . one ( ) )  return fom  def mean_value_difference ( data , ground_truth , mask = None , normalized = False , force_lower_is_better = True ) :      <str> if not hasattr ( data , <str> ) :          data = odl . vector ( data )  space = data . space ground_truth = space . element ( ground_truth ) l1_norm = odl . solvers . L1Norm ( space ) if mask is not None :          data = data * mask ground_truth = ground_truth * mask  vol = l1_norm ( space . one ( ) ) data_mean = data . inner ( space . one ( ) ) / vol ground_truth_mean = ground_truth . inner ( space . one ( ) ) / vol fom = np . abs ( data_mean - ground_truth_mean ) if normalized :          fom /= ( np . abs ( data_mean ) + np . abs ( ground_truth_mean ) )  return fom  def standard_deviation_difference ( data , ground_truth , mask = None , normalized = False , force_lower_is_better = True ) :      <str> if not hasattr ( data , <str> ) :          data = odl . vector ( data )  space = data . space ground_truth = space . element ( ground_truth ) l1_norm = odl . solvers . L1Norm ( space ) l2_norm = odl . solvers . L2Norm ( space ) if mask is not None :          data = data * mask ground_truth = ground_truth * mask  vol = l1_norm ( space . one ( ) ) data_mean = data . inner ( space . one ( ) ) / vol ground_truth_mean = ground_truth . inner ( space . one ( ) ) / vol deviation_data = l2_norm ( data - data_mean ) deviation_ground_truth = l2_norm ( ground_truth - ground_truth_mean ) fom = np . abs ( deviation_data - deviation_ground_truth ) if normalized :          denom = deviation_data + deviation_ground_truth if denom == 0 :              fom = 0.0  else :              fom /= denom   return fom  def range_difference ( data , ground_truth , mask = None , normalized = False , force_lower_is_better = True ) :      <str> data = np . asarray ( data ) ground_truth = np . asarray ( ground_truth ) if mask is not None :          mask = np . asarray ( mask , dtype = bool ) data = data [ mask ] ground_truth = ground_truth [ mask ]  data_range = np . ptp ( data ) ground_truth_range = np . ptp ( ground_truth ) fom = np . abs ( data_range - ground_truth_range ) if normalized :          denom = np . abs ( data_range + ground_truth_range ) if denom == 0 :              fom = 0.0  else :              fom /= denom   return fom  def blurring ( data , ground_truth , mask = None , normalized = False , smoothness_factor = None ) :      <str> from scipy . ndimage . morphology import distance_transform_edt if not hasattr ( data , <str> ) :          data = odl . vector ( data )  space = data . space ground_truth = space . element ( ground_truth ) if smoothness_factor is None :          smoothness_factor = np . mean ( data . shape ) / 10  if mask is not None :          mask = distance_transform_edt ( 1 - mask ) mask = np . exp ( - mask / smoothness_factor )  return mean_squared_error ( data , ground_truth , mask , normalized )  def false_structures_mask ( foreground , smoothness_factor = None ) :      try :          space = foreground . space has_space = True  except AttributeError :          has_space = False foreground = np . asarray ( foreground ) space = odl . tensor_space ( foreground . shape , foreground . dtype ) foreground = space . element ( foreground )  from scipy . ndimage . morphology import distance_transform_edt unique = np . unique ( foreground ) if not np . array_equiv ( unique , [ 0. , 1. ] ) :          raise ValueError ( <str> <str> <str> . format ( unique ) )  result = distance_transform_edt ( 1.0 - foreground , sampling = getattr ( space , <str> , 1.0 ) ) if has_space :          return space . element ( result )  else :          return result   def ssim ( data , ground_truth , size = 11 , sigma = 1.5 , K1 = 0.01 , K2 = 0.03 , dynamic_range = None , normalized = False , force_lower_is_better = False ) :      <str> from scipy . signal import fftconvolve data = np . asarray ( data ) ground_truth = np . asarray ( ground_truth ) coords = np . linspace ( - ( size - 1 ) / 2 , ( size - 1 ) / 2 , size ) grid = sparse_meshgrid ( * ( [ coords ] * data . ndim ) ) window = np . exp ( - ( sum ( xi ** 2 for xi in grid ) / ( 2.0 * sigma ** 2 ) ) ) window /= np . sum ( window ) def smoothen ( img ) :          return fftconvolve ( window , img , mode = <str> )  if dynamic_range is None :          dynamic_range = np . max ( ground_truth ) - np . min ( ground_truth )  C1 = ( K1 * dynamic_range ) ** 2 C2 = ( K2 * dynamic_range ) ** 2 mu1 = smoothen ( data ) mu2 = smoothen ( ground_truth ) mu1_sq = mu1 * mu1 mu2_sq = mu2 * mu2 mu1_mu2 = mu1 * mu2 sigma1_sq = smoothen ( data * data ) - mu1_sq sigma2_sq = smoothen ( ground_truth * ground_truth ) - mu2_sq sigma12 = smoothen ( data * ground_truth ) - mu1_mu2 num = ( 2 * mu1_mu2 + C1 ) * ( 2 * sigma12 + C2 ) denom = ( mu1_sq + mu2_sq + C1 ) * ( sigma1_sq + sigma2_sq + C2 ) pointwise_ssim = num / denom result = np . mean ( pointwise_ssim ) if force_lower_is_better :          result = - result  if normalized :          result = ( result + 1.0 ) / 2.0  return result  def psnr ( data , ground_truth , use_zscore = False , force_lower_is_better = False ) :      if use_zscore :          data = odl . util . zscore ( data ) ground_truth = odl . util . zscore ( ground_truth )  mse = mean_squared_error ( data , ground_truth ) max_true = np . max ( np . abs ( ground_truth ) ) if mse == 0 :          result = np . inf  elif max_true == 0 :          result = - np . inf  else :          result = 20 * np . log10 ( max_true ) - 10 * np . log10 ( mse )  if force_lower_is_better :          return - result  else :          return result   def haarpsi ( data , ground_truth , a = 4.2 , c = None ) :      <str> import scipy . special from odl . contrib . fom . util import haarpsi_similarity_map , haarpsi_weight_map if c is None :          c = 3 * np . sqrt ( np . max ( np . abs ( ground_truth ) ) )  lsim_horiz = haarpsi_similarity_map ( data , ground_truth , axis = 0 , c = c , a = a ) lsim_vert = haarpsi_similarity_map ( data , ground_truth , axis = 1 , c = c , a = a ) wmap_horiz = haarpsi_weight_map ( data , ground_truth , axis = 0 ) wmap_vert = haarpsi_weight_map ( data , ground_truth , axis = 1 ) numer = np . sum ( lsim_horiz * wmap_horiz + lsim_vert * wmap_vert ) denom = np . sum ( wmap_horiz + wmap_vert ) return ( scipy . special . logit ( numer / denom ) / a ) ** 2  def noise_power_spectrum ( data , ground_truth , radial = False , radial_binning_factor = 2.0 ) :      try :          space = data . space assert isinstance ( space , odl . DiscreteLp )  except ( AttributeError , AssertionError ) :          data = np . asarray ( data ) space = odl . uniform_discr ( [ 0 ] * data . ndim , data . shape , data . shape , data . dtype ) data = space . element ( data )  ft = odl . trafos . FourierTransform ( space , halfcomplex = False ) nps = np . abs ( ft ( data - ground_truth ) ) . real ** 2 if radial :          return spherical_sum ( nps , binning_factor = radial_binning_factor )  else :          return nps   if __name__ == <str> :      from odl . util . testutils import run_doctests run_doctests ( )   