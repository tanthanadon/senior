from __future__ import division import numpy as np import odl from odl . contrib . fom . util import spherical_sum __all__ = ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) def mean_squared_error ( data , ground_truth , mask = None , normalized = False , force_lower_is_better = True ) :      <str> l2norm = odl . solvers . L2Norm ( data . space ) l2norm_squared = odl . solvers . L2NormSquared ( data . space ) if mask is not None :          data = data * mask ground_truth = ground_truth * mask  diff = data - ground_truth fom = l2norm_squared ( diff ) if normalized :          fom /= ( l2norm ( data ) + l2norm ( ground_truth ) ) ** 2  else :          fom /= l2norm_squared ( data . space . one ( ) )  return fom  def mean_absolute_error ( data , ground_truth , mask = None , normalized = False , force_lower_is_better = True ) :      <str> l1_norm = odl . solvers . L1Norm ( data . space ) if mask is not None :          data = data * mask ground_truth = ground_truth * mask  diff = data - ground_truth fom = l1_norm ( diff ) if normalized :          fom /= ( l1_norm ( data ) + l1_norm ( ground_truth ) )  else :          fom /= l1_norm ( data . space . one ( ) )  return fom  def mean_value_difference ( data , ground_truth , mask = None , normalized = False , force_lower_is_better = True ) :      <str> l1_norm = odl . solvers . L1Norm ( data . space ) if mask is not None :          data = data * mask ground_truth = ground_truth * mask  vol = l1_norm ( data . space . one ( ) ) data_mean = data . inner ( data . space . one ( ) ) / vol ground_truth_mean = ground_truth . inner ( ground_truth . space . one ( ) ) / vol fom = np . abs ( data_mean - ground_truth_mean ) if normalized :          fom /= ( np . abs ( data_mean ) + np . abs ( ground_truth_mean ) )  return fom  def standard_deviation_difference ( data , ground_truth , mask = None , normalized = False , force_lower_is_better = True ) :      <str> l1_norm = odl . solvers . L1Norm ( data . space ) l2_norm = odl . solvers . L2Norm ( data . space ) if mask is not None :          data = data * mask ground_truth = ground_truth * mask  vol = l1_norm ( data . space . one ( ) ) data_mean = data . inner ( data . space . one ( ) ) / vol ground_truth_mean = ground_truth . inner ( ground_truth . space . one ( ) ) / vol deviation_data = l2_norm ( data - data_mean ) deviation_ground_truth = l2_norm ( ground_truth - ground_truth_mean ) fom = np . abs ( deviation_data - deviation_ground_truth ) if normalized :          sum_deviation = deviation_data + deviation_ground_truth fom /= sum_deviation if np . isnan ( fom ) :              fom = 0   return fom  def range_difference ( data , ground_truth , mask = None , normalized = False , force_lower_is_better = True ) :      <str> if mask is None :          data_range = np . max ( data ) - np . min ( data ) ground_truth_range = np . max ( ground_truth ) - np . min ( ground_truth )  else :          mask = np . asarray ( mask ) data_range = ( np . max ( data . asarray ( ) [ mask ] ) - np . min ( data . asarray ( ) [ mask ] ) ) ground_truth_range = ( np . max ( ground_truth . asarray ( ) [ mask ] ) - np . min ( ground_truth . asarray ( ) [ mask ] ) )  fom = np . abs ( data_range - ground_truth_range ) if normalized :          fom /= np . abs ( data_range + ground_truth_range )  return fom  def blurring ( data , ground_truth , mask = None , normalized = False , smoothness_factor = None ) :      <str> from scipy . ndimage . morphology import distance_transform_edt if smoothness_factor is None :          smoothness_factor = np . mean ( data . space . shape ) / 10  if mask is not None :          mask = distance_transform_edt ( 1 - mask ) mask = np . exp ( - mask / smoothness_factor )  return mean_squared_error ( data , ground_truth , mask , normalized )  def false_structures_mask ( foreground , smoothness_factor = None ) :      from scipy . ndimage . morphology import distance_transform_edt space = foreground . space unique = np . unique ( foreground ) if not np . array_equiv ( unique , [ 0. , 1. ] ) :          raise ValueError ( <str> <str> <str> . format ( unique ) )  result = distance_transform_edt ( 1.0 - foreground , sampling = space . cell_sides ) return space . element ( result )  def ssim ( data , ground_truth , size = 11 , sigma = 1.5 , K1 = 0.01 , K2 = 0.03 , dynamic_range = None , normalized = False , force_lower_is_better = False ) :      <str> from scipy . signal import fftconvolve data = np . asarray ( data ) ground_truth = np . asarray ( ground_truth ) coords = np . linspace ( - ( size - 1 ) / 2 , ( size - 1 ) / 2 , size ) grid = np . meshgrid ( * ( [ coords ] * data . ndim ) , sparse = True ) window = np . exp ( - ( sum ( xi ** 2 for xi in grid ) / ( 2.0 * sigma ** 2 ) ) ) window /= np . sum ( window ) def smoothen ( img ) :          return fftconvolve ( window , img , mode = <str> )  if dynamic_range is None :          dynamic_range = np . max ( ground_truth ) - np . min ( ground_truth )  C1 = ( K1 * dynamic_range ) ** 2 C2 = ( K2 * dynamic_range ) ** 2 mu1 = smoothen ( data ) mu2 = smoothen ( ground_truth ) mu1_sq = mu1 * mu1 mu2_sq = mu2 * mu2 mu1_mu2 = mu1 * mu2 sigma1_sq = smoothen ( data * data ) - mu1_sq sigma2_sq = smoothen ( ground_truth * ground_truth ) - mu2_sq sigma12 = smoothen ( data * ground_truth ) - mu1_mu2 num = ( 2 * mu1_mu2 + C1 ) * ( 2 * sigma12 + C2 ) denom = ( mu1_sq + mu2_sq + C1 ) * ( sigma1_sq + sigma2_sq + C2 ) pointwise_ssim = num / denom result = np . mean ( pointwise_ssim ) if force_lower_is_better :          result = - result  if normalized :          result = ( result + 1.0 ) / 2.0  return result  def psnr ( data , ground_truth , use_zscore = False , force_lower_is_better = False ) :      if use_zscore :          data = odl . util . zscore ( data ) ground_truth = odl . util . zscore ( ground_truth )  mse = mean_squared_error ( data , ground_truth ) max_true = np . max ( np . abs ( ground_truth ) ) if mse == 0 :          result = np . inf  elif max_true == 0 :          result = - np . inf  else :          result = 20 * np . log10 ( max_true ) - 10 * np . log10 ( mse )  if force_lower_is_better :          return - result  else :          return result   def haarpsi ( data , ground_truth , a = 4.2 , c = None ) :      <str> import scipy . special from odl . contrib . fom . util import haarpsi_similarity_map , haarpsi_weight_map if c is None :          c = 3 * np . sqrt ( np . max ( np . abs ( ground_truth ) ) )  lsim_horiz = haarpsi_similarity_map ( data , ground_truth , axis = 0 , c = c , a = a ) lsim_vert = haarpsi_similarity_map ( data , ground_truth , axis = 1 , c = c , a = a ) wmap_horiz = haarpsi_weight_map ( data , ground_truth , axis = 0 ) wmap_vert = haarpsi_weight_map ( data , ground_truth , axis = 1 ) numer = np . sum ( lsim_horiz * wmap_horiz + lsim_vert * wmap_vert ) denom = np . sum ( wmap_horiz + wmap_vert ) return ( scipy . special . logit ( numer / denom ) / a ) ** 2  def noise_power_spectrum ( data , ground_truth , radial = False , radial_binning_factor = 2.0 ) :      ft = odl . trafos . FourierTransform ( data . space , halfcomplex = False ) nps = np . abs ( ft ( data - ground_truth ) ) . real ** 2 if radial :          return spherical_sum ( nps , binning_factor = radial_binning_factor )  else :          return nps   if __name__ == <str> :      from odl . util . testutils import run_doctests run_doctests ( )   