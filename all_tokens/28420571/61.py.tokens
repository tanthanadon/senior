from __future__ import division import numpy as np import pytest import odl from odl . discr . grid import sparse_meshgrid from odl . discr . discr_mappings import ( PointCollocation , NearestInterpolation , LinearInterpolation , PerAxisInterpolation ) from odl . util . testutils import all_almost_equal , all_equal def test_nearest_interpolation_1d_complex ( odl_tspace_impl ) :      impl = odl_tspace_impl intv = odl . IntervalProd ( 0 , 1 ) part = odl . uniform_partition_fromintv ( intv , 5 , nodes_on_bdry = False ) fspace = odl . FunctionSpace ( intv , out_dtype = complex ) tspace = odl . cn ( part . shape ) interp_op = NearestInterpolation ( fspace , part , tspace ) function = interp_op ( [ 0 + 1j , 1 + 2j , 2 + 3j , 3 + 4j , 4 + 5j ] ) val = function ( 0.35 ) assert val == 1.0 + 2.0j pts = np . array ( [ 0.4 , 0.0 , 0.65 , 0.95 ] ) true_arr = [ 1 + 2j , 0 + 1j , 3 + 4j , 4 + 5j ] assert all_equal ( function ( pts ) , true_arr ) pts = pts [ None , : ] assert all_equal ( function ( pts ) , true_arr ) out = np . empty ( 4 , dtype = <str> ) function ( pts , out = out ) assert all_equal ( out , true_arr ) mg = sparse_meshgrid ( [ 0.4 , 0.0 , 0.65 , 0.95 ] ) true_mg = [ 1 + 2j , 0 + 1j , 3 + 4j , 4 + 5j ] assert all_equal ( function ( mg ) , true_mg ) function ( mg , out = out ) assert all_equal ( out , true_mg ) assert repr ( interp_op ) != <str>  def test_nearest_interpolation_1d_variants ( ) :      intv = odl . IntervalProd ( 0 , 1 ) part = odl . uniform_partition_fromintv ( intv , 5 , nodes_on_bdry = False ) fspace = odl . FunctionSpace ( intv ) tspace = odl . rn ( part . shape ) interp_op = NearestInterpolation ( fspace , part , tspace , variant = <str> ) assert repr ( interp_op ) != <str> function = interp_op ( [ 0 , 1 , 2 , 3 , 4 ] ) pts = np . array ( [ 0.4 , 0.8 , 0.0 , 1.0 ] ) true_arr = [ 1 , 3 , 0 , 4 ] assert all_equal ( function ( pts ) , true_arr ) interp_op = NearestInterpolation ( fspace , part , tspace , variant = <str> ) assert repr ( interp_op ) != <str> function = interp_op ( [ 0 , 1 , 2 , 3 , 4 ] ) pts = np . array ( [ 0.4 , 0.8 , 0.0 , 1.0 ] ) true_arr = [ 2 , 4 , 0 , 4 ] assert all_equal ( function ( pts ) , true_arr )  def test_nearest_interpolation_2d_float ( ) :      rect = odl . IntervalProd ( [ 0 , 0 ] , [ 1 , 1 ] ) part = odl . uniform_partition_fromintv ( rect , [ 4 , 2 ] , nodes_on_bdry = False ) fspace = odl . FunctionSpace ( rect ) tspace = odl . rn ( part . shape ) interp_op = NearestInterpolation ( fspace , part , tspace ) function = interp_op ( np . reshape ( [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 ] , part . shape ) ) val = function ( [ 0.3 , 0.6 ] ) assert val == 3.0 pts = np . array ( [ [ 0.3 , 0.6 ] , [ 1.0 , 1.0 ] ] ) true_arr = [ 3 , 7 ] assert all_equal ( function ( pts . T ) , true_arr ) out = np . empty ( 2 , dtype = <str> ) function ( pts . T , out = out ) assert all_equal ( out , true_arr ) mg = sparse_meshgrid ( [ 0.3 , 1.0 ] , [ 0.4 , 1.0 ] ) true_mg = [ [ 2 , 3 ] , [ 6 , 7 ] ] assert all_equal ( function ( mg ) , true_mg ) out = np . empty ( ( 2 , 2 ) , dtype = <str> ) function ( mg , out = out ) assert all_equal ( out , true_mg ) assert repr ( interp_op ) != <str>  def test_nearest_interpolation_2d_string ( ) :      rect = odl . IntervalProd ( [ 0 , 0 ] , [ 1 , 1 ] ) part = odl . uniform_partition_fromintv ( rect , [ 4 , 2 ] , nodes_on_bdry = False ) fspace = odl . FunctionSpace ( rect , out_dtype = <str> ) tspace = odl . tensor_space ( part . shape , dtype = <str> ) interp_op = NearestInterpolation ( fspace , part , tspace ) values = np . array ( [ c for c in <str> ] ) . reshape ( tspace . shape ) function = interp_op ( values ) val = function ( [ 0.3 , 0.6 ] ) assert val == <str> pts = np . array ( [ [ 0.3 , 0.6 ] , [ 1.0 , 1.0 ] ] ) true_arr = [ <str> , <str> ] assert all_equal ( function ( pts . T ) , true_arr ) out = np . empty ( 2 , dtype = <str> ) function ( pts . T , out = out ) assert all_equal ( out , true_arr ) mg = sparse_meshgrid ( [ 0.3 , 1.0 ] , [ 0.4 , 1.0 ] ) true_mg = [ [ <str> , <str> ] , [ <str> , <str> ] ] assert all_equal ( function ( mg ) , true_mg ) out = np . empty ( ( 2 , 2 ) , dtype = <str> ) function ( mg , out = out ) assert all_equal ( out , true_mg ) assert repr ( interp_op ) != <str>  def test_linear_interpolation_1d ( ) :      intv = odl . IntervalProd ( 0 , 1 ) part = odl . uniform_partition_fromintv ( intv , 5 , nodes_on_bdry = False ) fspace = odl . FunctionSpace ( intv ) tspace = odl . rn ( part . shape ) interp_op = LinearInterpolation ( fspace , part , tspace ) function = interp_op ( [ 1 , 2 , 3 , 4 , 5 ] ) val = function ( 0.35 ) true_val = 0.75 * 2 + 0.25 * 3 assert val == pytest . approx ( true_val ) pts = np . array ( [ 0.4 , 0.0 , 0.65 , 0.95 ] ) true_arr = [ 2.5 , 0.5 , 3.75 , 3.75 ] assert all_almost_equal ( function ( pts ) , true_arr )  def test_linear_interpolation_2d ( ) :      rect = odl . IntervalProd ( [ 0 , 0 ] , [ 1 , 1 ] ) part = odl . uniform_partition_fromintv ( rect , [ 4 , 2 ] , nodes_on_bdry = False ) fspace = odl . FunctionSpace ( rect ) tspace = odl . rn ( part . shape ) interp_op = LinearInterpolation ( fspace , part , tspace ) values = np . arange ( 1 , 9 , dtype = <str> ) . reshape ( part . shape ) function = interp_op ( values ) rvals = values . reshape ( [ 4 , 2 ] ) val = function ( [ 0.3 , 0.6 ] ) l1 = ( 0.3 - 0.125 ) / ( 0.375 - 0.125 ) l2 = ( 0.6 - 0.25 ) / ( 0.75 - 0.25 ) true_val = ( ( 1 - l1 ) * ( 1 - l2 ) * rvals [ 0 , 0 ] + ( 1 - l1 ) * l2 * rvals [ 0 , 1 ] + l1 * ( 1 - l2 ) * rvals [ 1 , 0 ] + l1 * l2 * rvals [ 1 , 1 ] ) assert val == pytest . approx ( true_val ) pts = np . array ( [ [ 0.3 , 0.6 ] , [ 0.1 , 0.25 ] , [ 1.0 , 1.0 ] ] ) l1 = ( 0.3 - 0.125 ) / ( 0.375 - 0.125 ) l2 = ( 0.6 - 0.25 ) / ( 0.75 - 0.25 ) true_val_1 = ( ( 1 - l1 ) * ( 1 - l2 ) * rvals [ 0 , 0 ] + ( 1 - l1 ) * l2 * rvals [ 0 , 1 ] + l1 * ( 1 - l2 ) * rvals [ 1 , 0 ] + l1 * l2 * rvals [ 1 , 1 ] ) l1 = ( 0.125 - 0.1 ) / ( 0.375 - 0.125 ) true_val_2 = ( 1 - l1 ) * rvals [ 0 , 0 ] l1 = ( 1.0 - 0.875 ) / ( 0.875 - 0.625 ) l2 = ( 1.0 - 0.75 ) / ( 0.75 - 0.25 ) true_val_3 = ( 1 - l1 ) * ( 1 - l2 ) * rvals [ 3 , 1 ] true_arr = [ true_val_1 , true_val_2 , true_val_3 ] assert all_equal ( function ( pts . T ) , true_arr ) out = np . empty ( 3 , dtype = <str> ) function ( pts . T , out = out ) assert all_equal ( out , true_arr ) mg = sparse_meshgrid ( [ 0.3 , 1.0 ] , [ 0.4 , 0.75 ] ) lx1 = ( 0.3 - 0.125 ) / ( 0.375 - 0.125 ) lx2 = ( 1.0 - 0.875 ) / ( 0.875 - 0.625 ) ly1 = ( 0.4 - 0.25 ) / ( 0.75 - 0.25 ) true_val_11 = ( ( 1 - lx1 ) * ( 1 - ly1 ) * rvals [ 0 , 0 ] + ( 1 - lx1 ) * ly1 * rvals [ 0 , 1 ] + lx1 * ( 1 - ly1 ) * rvals [ 1 , 0 ] + lx1 * ly1 * rvals [ 1 , 1 ] ) true_val_12 = ( ( 1 - lx1 ) * rvals [ 0 , 1 ] + lx1 * rvals [ 1 , 1 ] ) true_val_21 = ( ( 1 - lx2 ) * ( 1 - ly1 ) * rvals [ 3 , 0 ] + ( 1 - lx2 ) * ly1 * rvals [ 3 , 1 ] ) true_val_22 = ( 1 - lx2 ) * rvals [ 3 , 1 ] true_mg = [ [ true_val_11 , true_val_12 ] , [ true_val_21 , true_val_22 ] ] assert all_equal ( function ( mg ) , true_mg ) out = np . empty ( ( 2 , 2 ) , dtype = <str> ) function ( mg , out = out ) assert all_equal ( out , true_mg ) assert repr ( interp_op ) != <str>  def test_per_axis_interpolation ( ) :      rect = odl . IntervalProd ( [ 0 , 0 ] , [ 1 , 1 ] ) part = odl . uniform_partition_fromintv ( rect , [ 4 , 2 ] , nodes_on_bdry = False ) fspace = odl . FunctionSpace ( rect ) tspace = odl . rn ( part . shape ) schemes = [ <str> , <str> ] variants = [ None , <str> ] interp_op = PerAxisInterpolation ( fspace , part , tspace , schemes = schemes , nn_variants = variants ) values = np . arange ( 1 , 9 , dtype = <str> ) . reshape ( part . shape ) function = interp_op ( values ) rvals = values . reshape ( [ 4 , 2 ] ) val = function ( [ 0.3 , 0.5 ] ) l1 = ( 0.3 - 0.125 ) / ( 0.375 - 0.125 ) true_val = ( 1 - l1 ) * rvals [ 0 , 1 ] + l1 * rvals [ 1 , 1 ] assert val == pytest . approx ( true_val ) pts = np . array ( [ [ 0.3 , 0.6 ] , [ 0.1 , 0.25 ] , [ 1.0 , 1.0 ] ] ) l1 = ( 0.3 - 0.125 ) / ( 0.375 - 0.125 ) true_val_1 = ( 1 - l1 ) * rvals [ 0 , 1 ] + l1 * rvals [ 1 , 1 ] l1 = ( 0.125 - 0.1 ) / ( 0.375 - 0.125 ) true_val_2 = ( 1 - l1 ) * rvals [ 0 , 0 ] l1 = ( 1.0 - 0.875 ) / ( 0.875 - 0.625 ) true_val_3 = ( 1 - l1 ) * rvals [ 3 , 1 ] true_arr = [ true_val_1 , true_val_2 , true_val_3 ] assert all_equal ( function ( pts . T ) , true_arr ) out = np . empty ( 3 , dtype = <str> ) function ( pts . T , out = out ) assert all_equal ( out , true_arr ) mg = sparse_meshgrid ( [ 0.3 , 1.0 ] , [ 0.4 , 0.85 ] ) lx1 = ( 0.3 - 0.125 ) / ( 0.375 - 0.125 ) lx2 = ( 1.0 - 0.875 ) / ( 0.875 - 0.625 ) true_val_11 = ( 1 - lx1 ) * rvals [ 0 , 0 ] + lx1 * rvals [ 1 , 0 ] true_val_12 = ( ( 1 - lx1 ) * rvals [ 0 , 1 ] + lx1 * rvals [ 1 , 1 ] ) true_val_21 = ( 1 - lx2 ) * rvals [ 3 , 0 ] true_val_22 = ( 1 - lx2 ) * rvals [ 3 , 1 ] true_mg = [ [ true_val_11 , true_val_12 ] , [ true_val_21 , true_val_22 ] ] assert all_equal ( function ( mg ) , true_mg ) out = np . empty ( ( 2 , 2 ) , dtype = <str> ) function ( mg , out = out ) assert all_equal ( out , true_mg ) assert repr ( interp_op ) != <str>  def test_collocation_interpolation_identity ( ) :      rect = odl . IntervalProd ( [ 0 , 0 ] , [ 1 , 1 ] ) part = odl . uniform_partition_fromintv ( rect , [ 4 , 2 ] ) space = odl . FunctionSpace ( rect ) tspace = odl . rn ( part . shape ) coll_op = PointCollocation ( space , part , tspace ) interp_ops = [ NearestInterpolation ( space , part , tspace , variant = <str> ) , NearestInterpolation ( space , part , tspace , variant = <str> ) , LinearInterpolation ( space , part , tspace ) , PerAxisInterpolation ( space , part , tspace , schemes = [ <str> , <str> ] ) ] values = np . arange ( 1 , 9 , dtype = <str> ) . reshape ( tspace . shape ) for interp_op in interp_ops :          ident_values = coll_op ( interp_op ( values ) ) assert all_almost_equal ( ident_values , values )   if __name__ == <str> :      odl . util . test_file ( __file__ )   