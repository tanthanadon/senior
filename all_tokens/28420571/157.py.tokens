from __future__ import absolute_import , division , print_function from itertools import product import numpy as np from odl . util import ( is_string , is_valid_input_array , is_valid_input_meshgrid , out_shape_from_array , out_shape_from_meshgrid ) __all__ = ( <str> , <str> , <str> , <str> , ) SUPPORTED_INTERP = [ <str> , <str> ] def point_collocation ( func , points , out = None , ** kwargs ) :      if out is None :          out = func ( points , ** kwargs )  else :          func ( points , out = out , ** kwargs )  return out  def _all_interp_equal ( interp_byaxis ) :      if len ( interp_byaxis ) == 0 :          return False  return all ( itp == interp_byaxis [ 0 ] for itp in interp_byaxis )  def _normalize_interp ( interp , ndim ) :      interp_in = interp if is_string ( interp ) :          interp = str ( interp ) . lower ( ) interp_byaxis = ( interp , ) * ndim  else :          interp_byaxis = tuple ( str ( itp ) . lower ( ) for itp in interp ) if len ( interp_byaxis ) != ndim :              raise ValueError ( <str> <str> . format ( len ( interp_byaxis , ndim ) ) )   if not all ( interp in SUPPORTED_INTERP for interp in interp_byaxis ) :          raise ValueError ( <str> <str> . format ( interp_in , SUPPORTED_INTERP ) )  return interp_byaxis  def _check_interp_input ( x , f ) :      errmsg_1d = ( <str> <str> <str> . format ( x ) ) errmsg_nd = ( <str> <str> <str> . format ( f . ndim , x ) ) if is_valid_input_meshgrid ( x , f . ndim ) :          x_is_scalar = False x_type = <str>  else :          x = np . asarray ( x ) if f . ndim == 1 and x . shape == ( ) :              x_is_scalar = True x = x . reshape ( ( 1 , 1 ) )  elif f . ndim == 1 and x . ndim == 1 :              x_is_scalar = False x = x . reshape ( ( 1 , x . size ) )  elif f . ndim > 1 and x . shape == ( f . ndim , ) :              x_is_scalar = True x = x . reshape ( ( f . ndim , 1 ) )  else :              x_is_scalar = False  if not is_valid_input_array ( x , f . ndim ) :              errmsg = errmsg_1d if f . ndim == 1 else errmsg_nd raise ValueError ( errmsg )  x_type = <str>  return x , x_type , x_is_scalar  def nearest_interpolator ( f , coord_vecs ) :      f = np . asarray ( f ) def nearest_interp ( x , out = None ) :          x , x_type , x_is_scalar = _check_interp_input ( x , f ) interpolator = _NearestInterpolator ( coord_vecs , f , input_type = x_type ) res = interpolator ( x , out = out ) if x_is_scalar :              res = res . item ( )  return res  return nearest_interp  def linear_interpolator ( f , coord_vecs ) :      f = np . asarray ( f ) def linear_interp ( x , out = None ) :          x , x_type , x_is_scalar = _check_interp_input ( x , f ) interpolator = _LinearInterpolator ( coord_vecs , f , input_type = x_type ) res = interpolator ( x , out = out ) if x_is_scalar :              res = res . item ( )  return res  return linear_interp  def per_axis_interpolator ( f , coord_vecs , interp ) :      f = np . asarray ( f ) interp = _normalize_interp ( interp , f . ndim ) def per_axis_interp ( x , out = None ) :          x , x_type , x_is_scalar = _check_interp_input ( x , f ) interpolator = _PerAxisInterpolator ( coord_vecs , f , interp = interp , input_type = x_type ) res = interpolator ( x , out = out ) if x_is_scalar :              res = res . item ( )  return res  return per_axis_interp  class _Interpolator ( object ) :      <str> def __init__ ( self , coord_vecs , values , input_type ) :          values = np . asarray ( values ) typ_ = str ( input_type ) . lower ( ) if typ_ not in ( <str> , <str> ) :              raise ValueError ( <str> <str> . format ( input_type ) )  if len ( coord_vecs ) > values . ndim :              raise ValueError ( <str> <str> . format ( len ( coord_vecs ) , values . ndim ) )  for i , p in enumerate ( coord_vecs ) :              if not np . asarray ( p ) . ndim == 1 :                  raise ValueError ( <str> <str> . format ( i ) )  if values . shape [ i ] != len ( p ) :                  raise ValueError ( <str> <str> . format ( len ( p ) , values . shape [ i ] , i ) )   self . coord_vecs = tuple ( np . asarray ( p ) for p in coord_vecs ) self . values = values self . input_type = input_type  def __call__ ( self , x , out = None ) :          ndim = len ( self . coord_vecs ) if self . input_type == <str> :              x = x . reshape ( [ ndim , - 1 ] ) out_shape = out_shape_from_array ( x )  else :              if len ( x ) != ndim :                  raise ValueError ( <str> <str> <str> . format ( len ( x ) , ndim ) )  out_shape = out_shape_from_meshgrid ( x )  if out is not None :              if not isinstance ( out , np . ndarray ) :                  raise TypeError ( <str> <str> . format ( out ) )  if out . shape != out_shape :                  raise ValueError ( <str> <str> . format ( out . shape , out_shape ) )  if out . dtype != self . values . dtype :                  raise ValueError ( <str> <str> <str> . format ( out . dtype , self . values . dtype ) )   indices , norm_distances = self . _find_indices ( x ) return self . _evaluate ( indices , norm_distances , out )  def _find_indices ( self , x ) :          index_vecs = [ ] norm_distances = [ ] for xi , cvec in zip ( x , self . coord_vecs ) :              idcs = np . searchsorted ( cvec , xi ) - 1 idcs [ idcs < 0 ] = 0 idcs [ idcs > cvec . size - 2 ] = cvec . size - 2 index_vecs . append ( idcs ) norm_distances . append ( ( xi - cvec [ idcs ] ) / ( cvec [ idcs + 1 ] - cvec [ idcs ] ) )  return index_vecs , norm_distances  def _evaluate ( self , indices , norm_distances , out = None ) :          raise NotImplementedError ( <str> )   class _NearestInterpolator ( _Interpolator ) :      <str> def __init__ ( self , coord_vecs , values , input_type ) :          super ( _NearestInterpolator , self ) . __init__ ( coord_vecs , values , input_type )  def _evaluate ( self , indices , norm_distances , out = None ) :          idx_res = [ ] for i , yi in zip ( indices , norm_distances ) :              idx_res . append ( np . where ( yi < .5 , i , i + 1 ) )  idx_res = tuple ( idx_res ) if out is not None :              out [ : ] = self . values [ idx_res ] return out  else :              return self . values [ idx_res ]    def _compute_nearest_weights_edge ( idcs , ndist ) :      lo = ( ndist < 0 ) hi = ( ndist > 1 ) w_lo = np . where ( ndist < 0.5 , 1.0 , 0.0 ) w_lo [ lo ] = 0 w_lo [ hi ] = 1 w_hi = np . where ( ndist < 0.5 , 0.0 , 1.0 ) w_hi [ lo ] = 1 w_hi [ hi ] = 0 edge = [ idcs , idcs + 1 ] edge [ 0 ] [ hi ] = - 1 edge [ 1 ] [ lo ] = 0 return w_lo , w_hi , edge  def _compute_linear_weights_edge ( idcs , ndist ) :      lo = np . where ( ndist < 0 ) hi = np . where ( ndist > 1 ) w_lo = ( 1 - ndist ) w_lo [ lo ] = 0 w_lo [ hi ] += 1 w_hi = np . copy ( ndist ) w_hi [ lo ] += 1 w_hi [ hi ] = 0 edge = [ idcs , idcs + 1 ] edge [ 0 ] [ hi ] = - 1 edge [ 1 ] [ lo ] = 0 return w_lo , w_hi , edge  def _create_weight_edge_lists ( indices , norm_distances , interp ) :      low_weights = [ ] high_weights = [ ] edge_indices = [ ] for i , ( idcs , yi , s ) in enumerate ( zip ( indices , norm_distances , interp ) ) :          if s == <str> :              w_lo , w_hi , edge = _compute_nearest_weights_edge ( idcs , yi )  elif s == <str> :              w_lo , w_hi , edge = _compute_linear_weights_edge ( idcs , yi )  else :              raise ValueError ( <str> . format ( interp ) )  low_weights . append ( w_lo ) high_weights . append ( w_hi ) edge_indices . append ( edge )  return low_weights , high_weights , edge_indices  class _PerAxisInterpolator ( _Interpolator ) :      def __init__ ( self , coord_vecs , values , input_type , interp ) :          super ( _PerAxisInterpolator , self ) . __init__ ( coord_vecs , values , input_type ) self . interp = interp  def _evaluate ( self , indices , norm_distances , out = None ) :          vslice = ( slice ( None ) , ) + ( None , ) * ( self . values . ndim - len ( indices ) ) if out is None :              out_shape = out_shape_from_meshgrid ( norm_distances ) out_dtype = self . values . dtype out = np . zeros ( out_shape , dtype = out_dtype )  else :              out [ : ] = 0.0  low_weights , high_weights , edge_indices = _create_weight_edge_lists ( indices , norm_distances , self . interp ) for lo_hi , edge in zip ( product ( * ( [ [ <str> , <str> ] ] * len ( indices ) ) ) , product ( * edge_indices ) ) :              weight = 1.0 for lh , w_lo , w_hi in zip ( lo_hi , low_weights , high_weights ) :                  if lh == <str> :                      weight = weight * w_lo  else :                      weight = weight * w_hi   out += np . asarray ( self . values [ edge ] ) * weight [ vslice ]  return np . array ( out , copy = False , ndmin = 1 )   class _LinearInterpolator ( _PerAxisInterpolator ) :      def __init__ ( self , coord_vecs , values , input_type ) :          super ( _LinearInterpolator , self ) . __init__ ( coord_vecs , values , input_type , interp = [ <str> ] * len ( coord_vecs ) , )   if __name__ == <str> :      from odl . util . testutils import run_doctests run_doctests ( )   