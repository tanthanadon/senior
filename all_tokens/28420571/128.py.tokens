from __future__ import print_function , division , absolute_import import numpy as np from odl . operator import ( Operator , IdentityOperator , ConstantOperator , DiagonalOperator , PointwiseNorm , MultiplyOperator ) from odl . space import ProductSpace from odl . set . space import LinearSpaceElement __all__ = ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) def combine_proximals ( * factory_list ) :      def diag_op_factory ( sigma ) :          if np . isscalar ( sigma ) :              sigma = [ sigma ] * len ( factory_list )  return DiagonalOperator ( * [ factory ( sigmai ) for sigmai , factory in zip ( sigma , factory_list ) ] )  return diag_op_factory  def proximal_convex_conj ( prox_factory ) :      def convex_conj_prox_factory ( sigma ) :          space = prox_factory ( sigma ) . domain mult_inner = MultiplyOperator ( 1.0 / sigma , domain = space , range = space ) mult_outer = MultiplyOperator ( sigma , domain = space , range = space ) result = ( IdentityOperator ( space ) - mult_outer * prox_factory ( 1.0 / sigma ) * mult_inner ) return result  return convex_conj_prox_factory  def proximal_translation ( prox_factory , y ) :      def translation_prox_factory ( sigma ) :          return ( ConstantOperator ( y ) + prox_factory ( sigma ) * ( IdentityOperator ( y . space ) - ConstantOperator ( y ) ) )  return translation_prox_factory  def proximal_arg_scaling ( prox_factory , scaling ) :      if np . isscalar ( scaling ) :          if scaling == 0 :              return proximal_const_func ( prox_factory ( 1.0 ) . domain )  elif scaling . imag != 0 :              raise ValueError ( <str> )  else :              scaling = float ( scaling . real )   else :          scaling = np . asarray ( scaling )  def arg_scaling_prox_factory ( sigma ) :          scaling_square = scaling * scaling prox = prox_factory ( sigma * scaling_square ) space = prox . domain mult_inner = MultiplyOperator ( scaling , domain = space , range = space ) mult_outer = MultiplyOperator ( 1 / scaling , domain = space , range = space ) return mult_outer * prox * mult_inner  return arg_scaling_prox_factory  def proximal_quadratic_perturbation ( prox_factory , a , u = None ) :      a = float ( a ) if a < 0 :          raise ValueError ( <str> <str> . format ( a ) )  if u is not None and not isinstance ( u , LinearSpaceElement ) :          raise TypeError ( <str> <str> . format ( u ) )  def quadratic_perturbation_prox_factory ( sigma ) :          if np . isscalar ( sigma ) :              sigma = float ( sigma )  else :              sigma = np . asarray ( sigma )  const = 1.0 / np . sqrt ( sigma * 2.0 * a + 1 ) prox = proximal_arg_scaling ( prox_factory , const ) ( sigma ) if u is not None :              return ( MultiplyOperator ( const , domain = u . space , range = u . space ) * prox * ( MultiplyOperator ( const , domain = u . space , range = u . space ) - sigma * const * u ) )  else :              space = prox . domain return ( MultiplyOperator ( const , domain = space , range = space ) * prox * MultiplyOperator ( const , domain = space , range = space ) )   return quadratic_perturbation_prox_factory  def proximal_composition ( proximal , operator , mu ) :      def proximal_composition_factory ( sigma ) :          Id = IdentityOperator ( operator . domain ) Ir = IdentityOperator ( operator . range ) prox_muf = proximal ( mu * sigma ) return ( Id + ( 1.0 / mu ) * operator . adjoint * ( ( prox_muf - Ir ) * operator ) )  return proximal_composition_factory  def proximal_const_func ( space ) :      def identity_factory ( sigma ) :          return IdentityOperator ( space )  return identity_factory  def proximal_box_constraint ( space , lower = None , upper = None ) :      if lower is not None and lower not in space and lower not in space . field :          lower = space . element ( lower )  if upper is not None and upper not in space and upper not in space . field :          upper = space . element ( upper )  if lower in space . field and upper in space . field :          if lower > upper :              raise ValueError ( <str> <str> . format ( lower , upper ) )   class ProxOpBoxConstraint ( Operator ) :          def __init__ ( self , sigma ) :              super ( ProxOpBoxConstraint , self ) . __init__ ( domain = space , range = space , linear = False )  def _call ( self , x , out ) :              if lower is not None and upper is None :                  x . ufuncs . maximum ( lower , out = out )  elif lower is None and upper is not None :                  x . ufuncs . minimum ( upper , out = out )  elif lower is not None and upper is not None :                  x . ufuncs . maximum ( lower , out = out ) out . ufuncs . minimum ( upper , out = out )  else :                  out . assign ( x )    return ProxOpBoxConstraint  def proximal_nonnegativity ( space ) :      return proximal_box_constraint ( space , lower = 0 )  def proximal_convex_conj_l2 ( space , lam = 1 , g = None ) :      prox_l2 = proximal_l2 ( space , lam = lam , g = g ) return proximal_convex_conj ( prox_l2 )  def proximal_l2 ( space , lam = 1 , g = None ) :      lam = float ( lam ) if g is not None and g not in space :          raise TypeError ( <str> . format ( g , space ) )  class ProximalL2 ( Operator ) :          def __init__ ( self , sigma ) :              super ( ProximalL2 , self ) . __init__ ( domain = space , range = space , linear = False ) self . sigma = float ( sigma )  def _call ( self , x , out ) :              dtype = getattr ( self . domain , <str> , float ) eps = np . finfo ( dtype ) . resolution * 10 if g is None :                  x_norm = x . norm ( ) * ( 1 + eps ) if x_norm > 0 :                      step = self . sigma * lam / x_norm  else :                      step = np . infty  if step < 1.0 :                      out . lincomb ( 1.0 - step , x )  else :                      out . set_zero ( )   else :                  x_norm = ( x - g ) . norm ( ) * ( 1 + eps ) if x_norm > 0 :                      step = self . sigma * lam / x_norm  else :                      step = np . infty  if step < 1.0 :                      out . lincomb ( 1.0 - step , x , step , g )  else :                      out . assign ( g )     return ProximalL2  def proximal_convex_conj_l2_squared ( space , lam = 1 , g = None ) :      lam = float ( lam ) if g is not None and g not in space :          raise TypeError ( <str> . format ( g , space ) )  class ProximalConvexConjL2Squared ( Operator ) :          def __init__ ( self , sigma ) :              super ( ProximalConvexConjL2Squared , self ) . __init__ ( domain = space , range = space , linear = g is None ) if np . isscalar ( sigma ) :                  self . sigma = float ( sigma )  else :                  self . sigma = space . element ( sigma )   def _call ( self , x , out ) :              sig = self . sigma if np . isscalar ( sig ) :                  if g is None :                      out . lincomb ( 1.0 / ( 1 + 0.5 * sig / lam ) , x )  else :                      out . lincomb ( 1.0 / ( 1 + 0.5 * sig / lam ) , x , - sig / ( 1 + 0.5 * sig / lam ) , g )   elif sig in space :                  if g is None :                      x . divide ( 1 + 0.5 / lam * sig , out = out )  else :                      sig . multiply ( g , out = out ) out . lincomb ( 1.0 , x , - 1.0 , out = out ) out . divide ( 1 + 0.5 / lam * sig , out = out )   else :                  raise RuntimeError ( <str> <str> )    return ProximalConvexConjL2Squared  def proximal_l2_squared ( space , lam = 1 , g = None ) :      class ProximalL2Squared ( Operator ) :          def __init__ ( self , sigma ) :              super ( ProximalL2Squared , self ) . __init__ ( domain = space , range = space , linear = g is None ) if np . isscalar ( sigma ) :                  self . sigma = float ( sigma )  else :                  self . sigma = space . element ( sigma )   def _call ( self , x , out ) :              sig = self . sigma if np . isscalar ( sig ) :                  if g is None :                      out . lincomb ( 1.0 / ( 1 + 2 * sig * lam ) , x )  else :                      out . lincomb ( 1.0 / ( 1 + 2 * sig * lam ) , x , 2 * sig * lam / ( 1 + 2 * sig * lam ) , g )   else :                  if g is None :                      x . divide ( 1.0 + 2.0 * sig * lam , out = out )  else :                      sig . multiply ( 2.0 * lam * g , out = out ) out . lincomb ( 1.0 , x , 1.0 , out = out ) out . divide ( 1.0 + 2 * sig * lam , out = out )     return ProximalL2Squared  def proximal_convex_conj_l1 ( space , lam = 1 , g = None ) :      dtype = getattr ( space , <str> , float ) eps = np . finfo ( dtype ) . resolution * 10 lam = float ( lam * ( 1 - eps ) ) if g is not None and g not in space :          raise TypeError ( <str> . format ( g , space ) )  class ProximalConvexConjL1 ( Operator ) :          def __init__ ( self , sigma ) :              super ( ProximalConvexConjL1 , self ) . __init__ ( domain = space , range = space , linear = False ) if np . isscalar ( sigma ) :                  self . sigma = float ( sigma )  else :                  self . sigma = space . element ( sigma )   def _call ( self , x , out ) :              if g is not None :                  diff = self . domain . element ( ) diff . lincomb ( 1 , x , - self . sigma , g )  else :                  if x is out :                      diff = x . copy ( )  else :                      diff = x   diff . ufuncs . absolute ( out = out ) out . ufuncs . maximum ( lam , out = out ) out /= lam diff . divide ( out , out = out )   return ProximalConvexConjL1  def proximal_convex_conj_l1_l2 ( space , lam = 1 , g = None ) :      dtype = getattr ( space , <str> , float ) eps = np . finfo ( dtype ) . resolution * 10 lam = float ( lam * ( 1 - eps ) ) if g is not None and g not in space :          raise TypeError ( <str> . format ( g , space ) )  class ProximalConvexConjL1L2 ( Operator ) :          def __init__ ( self , sigma ) :              super ( ProximalConvexConjL1L2 , self ) . __init__ ( domain = space , range = space , linear = False ) self . sigma = float ( sigma )  def _call ( self , x , out ) :              if g is not None :                  diff = self . domain . element ( ) diff . lincomb ( 1 , x , - self . sigma , g )  else :                  diff = x  pwnorm = PointwiseNorm ( self . domain , exponent = 2 ) denom = pwnorm ( diff ) denom . ufuncs . maximum ( lam , out = denom ) denom /= lam for out_i , diff_i in zip ( out , diff ) :                  diff_i . divide ( denom , out = out_i )    return ProximalConvexConjL1L2  def proximal_l1 ( space , lam = 1 , g = None ) :      lam = float ( lam ) if g is not None and g not in space :          raise TypeError ( <str> . format ( g , space ) )  class ProximalL1 ( Operator ) :          def __init__ ( self , sigma ) :              super ( ProximalL1 , self ) . __init__ ( domain = space , range = space , linear = False ) if np . isscalar ( sigma ) :                  self . sigma = float ( sigma )  else :                  self . sigma = space . element ( sigma )   def _call ( self , x , out ) :              if g is not None :                  diff = x - g  else :                  if x is out :                      diff = x . copy ( )  else :                      diff = x   denom = diff . ufuncs . absolute ( ) denom /= self . sigma * lam denom . ufuncs . maximum ( 1 , out = denom ) diff . ufuncs . divide ( denom , out = out ) out . lincomb ( 1 , x , - 1 , out )   return ProximalL1  def proximal_l1_l2 ( space , lam = 1 , g = None ) :      lam = float ( lam ) if g is not None and g not in space :          raise TypeError ( <str> . format ( g , space ) )  class ProximalL1L2 ( Operator ) :          def __init__ ( self , sigma ) :              super ( ProximalL1L2 , self ) . __init__ ( domain = space , range = space , linear = False ) self . sigma = float ( sigma )  def _call ( self , x , out ) :              if g is not None :                  diff = x - g  else :                  if x is out :                      diff = x . copy ( )  else :                      diff = x   pwnorm = PointwiseNorm ( self . domain , exponent = 2 ) denom = pwnorm ( diff ) denom /= self . sigma * lam denom . ufuncs . maximum ( 1 , out = denom ) for out_i , diff_i in zip ( out , diff ) :                  diff_i . divide ( denom , out = out_i )  out . lincomb ( 1 , x , - 1 , out )   return ProximalL1L2  def proximal_linfty ( space ) :      class ProximalLInfty ( Operator ) :          def __init__ ( self , sigma ) :              super ( ProximalLInfty , self ) . __init__ ( domain = space , range = space , linear = False ) self . sigma = float ( sigma )  def _call ( self , x , out ) :              radius = 1 if x is out :                  x = x . copy ( )  proj_l1 ( x , radius , out ) out . lincomb ( - 1 , out , 1 , x )   return ProximalLInfty  def proj_l1 ( x , radius = 1 , out = None ) :      if out is None :          out = x . space . element ( )  u = x . ufuncs . absolute ( ) v = x . ufuncs . sign ( ) proj_simplex ( u , radius , out ) out *= v return out  def proj_simplex ( x , diameter = 1 , out = None ) :      if out is None :          out = x . space . element ( )  x_sor = x . asarray ( ) . flatten ( ) x_sor . sort ( ) x_sor = x_sor [ : : - 1 ] j = np . arange ( 1 , x . size + 1 ) x_avrg = ( 1 / j ) * ( np . cumsum ( x_sor ) - diameter ) crit = x_sor - x_avrg i = np . argwhere ( crit >= 0 ) . flatten ( ) . max ( ) out [ : ] = np . maximum ( x - x_avrg [ i ] , 0 ) return out  def proximal_convex_conj_kl ( space , lam = 1 , g = None ) :      lam = float ( lam ) if g is not None and g not in space :          raise TypeError ( <str> . format ( g , space ) )  class ProximalConvexConjKL ( Operator ) :          def __init__ ( self , sigma ) :              super ( ProximalConvexConjKL , self ) . __init__ ( domain = space , range = space , linear = False ) self . sigma = float ( sigma )  def _call ( self , x , out ) :              if x is out :                  x = x . copy ( )  else :                  out . assign ( x )  out -= lam out . ufuncs . square ( out = out ) if g is None :                  out += 4.0 * lam * self . sigma  else :                  out . lincomb ( 1 , out , 4.0 * lam * self . sigma , g )  out . ufuncs . sqrt ( out = out ) out . lincomb ( 1 , x , - 1 , out ) out += lam out /= 2   return ProximalConvexConjKL  def proximal_convex_conj_kl_cross_entropy ( space , lam = 1 , g = None ) :      lam = float ( lam ) if g is not None and g not in space :          raise TypeError ( <str> . format ( g , space ) )  class ProximalConvexConjKLCrossEntropy ( Operator ) :          def __init__ ( self , sigma ) :              self . sigma = float ( sigma ) super ( ProximalConvexConjKLCrossEntropy , self ) . __init__ ( domain = space , range = space , linear = False )  def _call ( self , x , out ) :              import scipy . special if g is None :                  lambw = scipy . special . lambertw ( ( self . sigma / lam ) * np . exp ( x / lam ) )  else :                  lambw = scipy . special . lambertw ( ( self . sigma / lam ) * g * np . exp ( x / lam ) )  if not np . issubsctype ( self . domain . dtype , np . complexfloating ) :                  lambw = lambw . real  lambw = x . space . element ( lambw ) out . lincomb ( 1 , x , - lam , lambw )   return ProximalConvexConjKLCrossEntropy  def proximal_huber ( space , gamma ) :      gamma = float ( gamma ) class ProximalHuber ( Operator ) :          def __init__ ( self , sigma ) :              self . sigma = float ( sigma ) super ( ProximalHuber , self ) . __init__ ( domain = space , range = space , linear = False )  def _call ( self , x , out ) :              if isinstance ( self . domain , ProductSpace ) :                  norm = PointwiseNorm ( self . domain , 2 ) ( x )  else :                  norm = x . ufuncs . absolute ( )  mask = norm . ufuncs . less_equal ( gamma + self . sigma ) out [ mask ] = gamma / ( gamma + self . sigma ) * x [ mask ] mask . ufuncs . logical_not ( out = mask ) sign_x = x . ufuncs . sign ( ) out [ mask ] = x [ mask ] - self . sigma * sign_x [ mask ] return out   return ProximalHuber  if __name__ == <str> :      from odl . util . testutils import run_doctests run_doctests ( )   