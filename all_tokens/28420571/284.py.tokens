import numpy as np import odl reco_space = odl . uniform_discr ( min_pt = [ - 20 , - 20 ] , max_pt = [ 20 , 20 ] , shape = [ 300 , 300 ] , dtype = <str> ) geometry = odl . tomo . parallel_beam_geometry ( reco_space , num_angles = 180 ) ray_trafo = odl . tomo . RayTransform ( reco_space , geometry ) phantom = odl . phantom . shepp_logan ( reco_space , modified = True ) data = ray_trafo ( phantom ) data += odl . phantom . white_noise ( ray_trafo . range ) * np . mean ( data ) * 0.1 grad = odl . Gradient ( reco_space ) L = odl . BroadcastOperator ( ray_trafo , grad ) data_fit = odl . solvers . L2NormSquared ( ray_trafo . range ) . translated ( data ) reg_func = 0.015 * odl . solvers . L1Norm ( grad . range ) g = odl . solvers . SeparableSum ( data_fit , reg_func ) f = odl . solvers . ZeroFunctional ( L . domain ) op_norm = 1.1 * odl . power_method_opnorm ( L , maxiter = 20 ) niter = 200 sigma = 2.0 tau = sigma / op_norm ** 2 callback = ( odl . solvers . CallbackPrintIteration ( step = 10 ) & odl . solvers . CallbackShow ( step = 10 ) ) x = L . domain . zero ( ) odl . solvers . admm_linearized ( x , f , g , L , tau , sigma , niter , callback = callback ) phantom . show ( title = <str> ) data . show ( title = <str> ) x . show ( title = <str> , force_show = True )  