from __future__ import print_function , division , absolute_import import numpy as np from odl . discr import uniform_partition from odl . tomo . geometry . detector import Flat1dDetector , Flat2dDetector from odl . tomo . geometry . geometry import Geometry , AxisOrientedGeometry from odl . tomo . util import euler_matrix , transform_system , is_inside_bounds from odl . util import signature_string , indent , array_str __all__ = ( <str> , <str> , <str> , <str> , <str> ) class ParallelBeamGeometry ( Geometry ) :      def __init__ ( self , ndim , apart , detector , det_pos_init , ** kwargs ) :          super ( ParallelBeamGeometry , self ) . __init__ ( ndim , apart , detector , ** kwargs ) if self . ndim not in ( 2 , 3 ) :              raise ValueError ( <str> . format ( ndim ) )  self . __det_pos_init = np . asarray ( det_pos_init , dtype = <str> ) if self . det_pos_init . shape != ( self . ndim , ) :              raise ValueError ( <str> <str> . format ( self . ndim , self . det_pos_init . shape ) )   @ property def det_pos_init ( self ) :          return self . __det_pos_init  @ property def angles ( self ) :          if self . motion_partition . ndim == 1 :              return self . motion_grid . coord_vectors [ 0 ]  else :              return self . motion_grid . points ( ) . T   def det_refpoint ( self , angle ) :          if self . motion_params . ndim == 1 :              squeeze_out = ( np . shape ( angle ) == ( ) ) angle = np . array ( angle , dtype = float , copy = False , ndmin = 1 ) rot_matrix = self . rotation_matrix ( angle ) extra_dims = angle . ndim  elif self . motion_params . ndim in ( 2 , 3 ) :              squeeze_out = ( np . broadcast ( * angle ) . shape == ( ) ) angle = tuple ( np . array ( a , dtype = float , copy = False , ndmin = 1 ) for a in angle ) rot_matrix = self . rotation_matrix ( angle ) extra_dims = len ( np . broadcast ( * angle ) . shape )  else :              raise NotImplementedError ( <str> <str> <str> . format ( self . motion_params . ndim ) )  rot_part = rot_matrix . dot ( self . det_pos_init - self . translation ) pt_slc = ( None , ) * extra_dims + ( slice ( None ) , ) refpoint = self . translation [ pt_slc ] + rot_part if squeeze_out :              refpoint = refpoint . squeeze ( )  return refpoint  def det_to_src ( self , angle , dparam ) :          if self . motion_params . ndim == 1 :              squeeze_angle = ( np . shape ( angle ) == ( ) ) angle = np . array ( angle , dtype = float , copy = False , ndmin = 1 ) matrix = self . rotation_matrix ( angle )  else :              squeeze_angle = ( np . broadcast ( * angle ) . shape == ( ) ) angle = tuple ( np . array ( a , dtype = float , copy = False , ndmin = 1 ) for a in angle ) matrix = self . rotation_matrix ( angle )  if self . det_params . ndim == 1 :              squeeze_dparam = ( np . shape ( dparam ) == ( ) ) dparam = np . array ( dparam , dtype = float , copy = False , ndmin = 1 )  else :              squeeze_dparam = ( np . broadcast ( * dparam ) . shape == ( ) ) dparam = tuple ( np . array ( p , dtype = float , copy = False , ndmin = 1 ) for p in dparam )  normal = self . detector . surface_normal ( dparam ) matrix_axes = list ( range ( matrix . ndim ) ) normal_axes = list ( range ( matrix . ndim - 2 ) ) + [ matrix_axes [ - 1 ] ] out_axes = list ( range ( matrix . ndim - 1 ) ) det_to_src = np . einsum ( matrix , matrix_axes , normal , normal_axes , out_axes ) if squeeze_angle and squeeze_dparam :              det_to_src = det_to_src . squeeze ( )  return det_to_src   class Parallel2dGeometry ( ParallelBeamGeometry ) :      _default_config = dict ( det_pos_init = ( 0 , 1 ) , det_axis_init = ( 1 , 0 ) ) def __init__ ( self , apart , dpart , det_pos_init = ( 0 , 1 ) , ** kwargs ) :          default_det_pos_init = self . _default_config [ <str> ] default_det_axis_init = self . _default_config [ <str> ] det_axis_init = kwargs . pop ( <str> , None ) if det_pos_init is not None :              self . _det_pos_init_arg = np . asarray ( det_pos_init , dtype = float )  else :              self . _det_pos_init_arg = None  if det_axis_init is not None :              self . _det_axis_init_arg = np . asarray ( det_axis_init , dtype = float )  else :              self . _det_axis_init_arg = None  vecs_to_transform = [ ] if det_axis_init is None :              vecs_to_transform . append ( default_det_axis_init )  transformed_vecs = transform_system ( det_pos_init , default_det_pos_init , vecs_to_transform ) transformed_vecs = list ( transformed_vecs ) det_pos_init = transformed_vecs . pop ( 0 ) if det_axis_init is None :              det_axis_init = transformed_vecs . pop ( 0 )  assert transformed_vecs == [ ] translation = np . asarray ( kwargs . pop ( <str> , ( 0 , 0 ) ) , dtype = float ) det_pos_init += translation check_bounds = kwargs . get ( <str> , True ) detector = Flat1dDetector ( dpart , axis = det_axis_init , check_bounds = check_bounds ) super ( Parallel2dGeometry , self ) . __init__ ( ndim = 2 , apart = apart , detector = detector , det_pos_init = det_pos_init , translation = translation , ** kwargs ) if self . motion_partition . ndim != 1 :              raise ValueError ( <str> <str> . format ( self . motion_partition . ndim ) )   @ classmethod def frommatrix ( cls , apart , dpart , init_matrix , ** kwargs ) :          init_matrix = np . asarray ( init_matrix , dtype = float ) if init_matrix . shape not in ( ( 2 , 2 ) , ( 2 , 3 ) ) :              raise ValueError ( <str> <str> <str> . format ( init_matrix . shape ) )  trafo_matrix = init_matrix [ : , : 2 ] translation = init_matrix [ : , 2 : ] . squeeze ( ) default_det_pos_init = cls . _default_config [ <str> ] default_det_axis_init = cls . _default_config [ <str> ] vecs_to_transform = [ default_det_axis_init ] transformed_vecs = transform_system ( default_det_pos_init , None , vecs_to_transform , matrix = trafo_matrix ) det_pos , det_axis = transformed_vecs if translation . size != 0 :              kwargs [ <str> ] = translation  return cls ( apart , dpart , det_pos , det_axis_init = det_axis , ** kwargs )  @ property def det_axis_init ( self ) :          return self . detector . axis  def det_axis ( self , angle ) :          return self . rotation_matrix ( angle ) . dot ( self . det_axis_init )  def rotation_matrix ( self , angle ) :          squeeze_out = ( np . shape ( angle ) == ( ) ) angle = np . array ( angle , dtype = float , copy = False , ndmin = 1 ) if ( self . check_bounds and not is_inside_bounds ( angle , self . motion_params ) ) :              raise ValueError ( <str> <str> . format ( angle , self . motion_params ) )  if squeeze_out :              matrix = euler_matrix ( angle ) . squeeze ( )  else :              matrix = euler_matrix ( angle )  return matrix  def __repr__ ( self ) :          posargs = [ self . motion_partition , self . det_partition ] optargs = [ ] if not np . allclose ( self . det_pos_init - self . translation , self . _default_config [ <str> ] ) :              optargs . append ( [ <str> , array_str ( self . det_pos_init ) , <str> ] )  if self . _det_axis_init_arg is not None :              optargs . append ( [ <str> , array_str ( self . _det_axis_init_arg ) , <str> ] )  if not np . array_equal ( self . translation , ( 0 , 0 ) ) :              optargs . append ( [ <str> , array_str ( self . translation ) , <str> ] )  sig_str = signature_string ( posargs , optargs , sep = <str> ) return <str> . format ( self . __class__ . __name__ , indent ( sig_str ) )  def __getitem__ ( self , indices ) :          part = self . partition [ indices ] apart = part . byaxis [ 0 ] dpart = part . byaxis [ 1 ] return Parallel2dGeometry ( apart , dpart , det_pos_init = self . det_pos_init , det_axis_init = self . _det_axis_init_arg , translation = self . translation )   class Parallel3dEulerGeometry ( ParallelBeamGeometry ) :      _default_config = dict ( det_pos_init = ( 0 , 1 , 0 ) , det_axes_init = ( ( 1 , 0 , 0 ) , ( 0 , 0 , 1 ) ) ) def __init__ ( self , apart , dpart , det_pos_init = ( 0 , 1 , 0 ) , ** kwargs ) :          default_det_pos_init = self . _default_config [ <str> ] default_det_axes_init = self . _default_config [ <str> ] det_axes_init = kwargs . pop ( <str> , None ) if det_axes_init is not None :              self . _det_axes_init_arg = tuple ( np . asarray ( a , dtype = float ) for a in det_axes_init )  else :              self . _det_axes_init_arg = None  vecs_to_transform = [ ] if det_axes_init is None :              vecs_to_transform . extend ( default_det_axes_init )  transformed_vecs = transform_system ( det_pos_init , default_det_pos_init , vecs_to_transform ) transformed_vecs = list ( transformed_vecs ) det_pos_init = transformed_vecs . pop ( 0 ) if det_axes_init is None :              det_axes_init = ( transformed_vecs . pop ( 0 ) , transformed_vecs . pop ( 0 ) )  assert transformed_vecs == [ ] translation = np . asarray ( kwargs . pop ( <str> , ( 0 , 0 , 0 ) ) , dtype = float ) det_pos_init += translation check_bounds = kwargs . get ( <str> , True ) detector = Flat2dDetector ( dpart , axes = det_axes_init , check_bounds = check_bounds ) super ( Parallel3dEulerGeometry , self ) . __init__ ( ndim = 3 , apart = apart , detector = detector , det_pos_init = det_pos_init , translation = translation , ** kwargs ) if self . motion_partition . ndim not in ( 2 , 3 ) :              raise ValueError ( <str> <str> . format ( self . motion_partition . ndim ) )   @ classmethod def frommatrix ( cls , apart , dpart , init_matrix , ** kwargs ) :          init_matrix = np . asarray ( init_matrix , dtype = float ) if init_matrix . shape not in ( ( 3 , 3 ) , ( 3 , 4 ) ) :              raise ValueError ( <str> <str> <str> . format ( init_matrix . shape ) )  trafo_matrix = init_matrix [ : , : 3 ] translation = init_matrix [ : , 3 : ] . squeeze ( ) default_det_pos_init = cls . _default_config [ <str> ] default_det_axes_init = cls . _default_config [ <str> ] vecs_to_transform = default_det_axes_init transformed_vecs = transform_system ( default_det_pos_init , None , vecs_to_transform , matrix = trafo_matrix ) det_pos , det_axis_0 , det_axis_1 = transformed_vecs if translation . size != 0 :              kwargs [ <str> ] = translation  return cls ( apart , dpart , det_pos , det_axes_init = [ det_axis_0 , det_axis_1 ] , ** kwargs )  @ property def det_axes_init ( self ) :          return self . detector . axes  def det_axes ( self , angles ) :          axes = self . rotation_matrix ( angles ) . dot ( self . det_axes_init . T ) return np . rollaxis ( axes , - 1 , - 2 )  def rotation_matrix ( self , angles ) :          squeeze_out = ( np . broadcast ( * angles ) . shape == ( ) ) angles_in = angles angles = tuple ( np . array ( angle , dtype = float , copy = False , ndmin = 1 ) for angle in angles ) if ( self . check_bounds and not is_inside_bounds ( angles , self . motion_params ) ) :              raise ValueError ( <str> <str> . format ( angles_in , self . motion_params ) )  matrix = euler_matrix ( * angles ) if squeeze_out :              matrix = matrix . squeeze ( )  return matrix  def __repr__ ( self ) :          posargs = [ self . motion_partition , self . det_partition ] optargs = [ ] if not np . allclose ( self . det_pos_init - self . translation , self . _default_config [ <str> ] ) :              optargs . append ( [ <str> , array_str ( self . det_pos_init ) , <str> ] )  if self . _det_axes_init_arg is not None :              optargs . append ( [ ( <str> , tuple ( array_str ( a ) for a in self . _det_axes_init_arg ) , None ) ] )  if not np . array_equal ( self . translation , ( 0 , 0 , 0 ) ) :              optargs . append ( [ <str> , array_str ( self . translation ) , <str> ] )  sig_str = signature_string ( posargs , optargs , sep = <str> ) return <str> . format ( self . __class__ . __name__ , indent ( sig_str ) )   class Parallel3dAxisGeometry ( ParallelBeamGeometry , AxisOrientedGeometry ) :      _default_config = dict ( axis = ( 0 , 0 , 1 ) , det_pos_init = ( 0 , 1 , 0 ) , det_axes_init = ( ( 1 , 0 , 0 ) , ( 0 , 0 , 1 ) ) ) def __init__ ( self , apart , dpart , axis = ( 0 , 0 , 1 ) , ** kwargs ) :          default_axis = self . _default_config [ <str> ] default_det_pos_init = self . _default_config [ <str> ] default_det_axes_init = self . _default_config [ <str> ] det_pos_init = kwargs . pop ( <str> , None ) det_axes_init = kwargs . pop ( <str> , None ) if det_pos_init is not None :              self . _det_pos_init_arg = np . asarray ( det_pos_init , dtype = float )  else :              self . _det_pos_init_arg = None  if det_axes_init is not None :              self . _det_axes_init_arg = tuple ( np . asarray ( a , dtype = float ) for a in det_axes_init )  else :              self . _det_axes_init_arg = None  vecs_to_transform = [ ] if det_pos_init is None :              vecs_to_transform . append ( default_det_pos_init )  if det_axes_init is None :              vecs_to_transform . extend ( default_det_axes_init )  transformed_vecs = transform_system ( axis , default_axis , vecs_to_transform ) transformed_vecs = list ( transformed_vecs ) axis = transformed_vecs . pop ( 0 ) if det_pos_init is None :              det_pos_init = transformed_vecs . pop ( 0 )  if det_axes_init is None :              det_axes_init = ( transformed_vecs . pop ( 0 ) , transformed_vecs . pop ( 0 ) )  assert transformed_vecs == [ ] translation = np . asarray ( kwargs . pop ( <str> , ( 0 , 0 , 0 ) ) , dtype = float ) det_pos_init += translation AxisOrientedGeometry . __init__ ( self , axis ) check_bounds = kwargs . get ( <str> , True ) detector = Flat2dDetector ( dpart , axes = det_axes_init , check_bounds = check_bounds ) super ( Parallel3dAxisGeometry , self ) . __init__ ( ndim = 3 , apart = apart , detector = detector , det_pos_init = det_pos_init , translation = translation , ** kwargs ) if self . motion_partition . ndim != 1 :              raise ValueError ( <str> <str> . format ( self . motion_partition . ndim ) )   @ classmethod def frommatrix ( cls , apart , dpart , init_matrix , ** kwargs ) :          init_matrix = np . asarray ( init_matrix , dtype = float ) if init_matrix . shape not in ( ( 3 , 3 ) , ( 3 , 4 ) ) :              raise ValueError ( <str> <str> <str> . format ( init_matrix . shape ) )  trafo_matrix = init_matrix [ : , : 3 ] translation = init_matrix [ : , 3 : ] . squeeze ( ) default_axis = cls . _default_config [ <str> ] default_det_pos_init = cls . _default_config [ <str> ] default_det_axes_init = cls . _default_config [ <str> ] vecs_to_transform = ( default_det_pos_init , ) + default_det_axes_init transformed_vecs = transform_system ( default_axis , None , vecs_to_transform , matrix = trafo_matrix ) axis , det_pos , det_axis_0 , det_axis_1 = transformed_vecs if translation . size != 0 :              kwargs [ <str> ] = translation  return cls ( apart , dpart , axis , det_pos_init = det_pos , det_axes_init = [ det_axis_0 , det_axis_1 ] , ** kwargs )  @ property def det_axes_init ( self ) :          return self . detector . axes  def det_axes ( self , angle ) :          axes = self . rotation_matrix ( angle ) . dot ( self . det_axes_init . T ) return np . rollaxis ( axes , - 1 , - 2 )  def __repr__ ( self ) :          posargs = [ self . motion_partition , self . det_partition ] optargs = [ ] if not np . allclose ( self . axis , self . _default_config [ <str> ] ) :              optargs . append ( [ <str> , array_str ( self . axis ) , <str> ] )  if self . _det_pos_init_arg is not None :              optargs . append ( [ <str> , array_str ( self . _det_pos_init_arg ) , None ] )  if self . _det_axes_init_arg is not None :              optargs . append ( [ <str> , tuple ( array_str ( a ) for a in self . _det_axes_init_arg ) , None ] )  if not np . array_equal ( self . translation , ( 0 , 0 , 0 ) ) :              optargs . append ( [ <str> , array_str ( self . translation ) , <str> ] )  sig_str = signature_string ( posargs , optargs , sep = <str> ) return <str> . format ( self . __class__ . __name__ , indent ( sig_str ) )  def __getitem__ ( self , indices ) :          part = self . partition [ indices ] apart = part . byaxis [ 0 ] dpart = part . byaxis [ 1 : ] return Parallel3dAxisGeometry ( apart , dpart , axis = self . axis , det_pos_init = self . _det_pos_init_arg , det_axes_init = self . _det_axes_init_arg , translation = self . translation )  rotation_matrix = AxisOrientedGeometry . rotation_matrix  def parallel_beam_geometry ( space , num_angles = None , det_shape = None ) :      corners = space . domain . corners ( ) [ : , : 2 ] rho = np . max ( np . linalg . norm ( corners , axis = 1 ) ) min_side = min ( space . partition . cell_sides [ : 2 ] ) omega = np . pi / min_side num_px_horiz = 2 * int ( np . ceil ( rho * omega / np . pi ) ) + 1 if space . ndim == 2 :          det_min_pt = - rho det_max_pt = rho if det_shape is None :              det_shape = num_px_horiz   elif space . ndim == 3 :          num_px_vert = space . shape [ 2 ] min_h = space . domain . min_pt [ 2 ] max_h = space . domain . max_pt [ 2 ] det_min_pt = [ - rho , min_h ] det_max_pt = [ rho , max_h ] if det_shape is None :              det_shape = [ num_px_horiz , num_px_vert ]   if num_angles is None :          num_angles = int ( np . ceil ( omega * rho ) )  angle_partition = uniform_partition ( 0 , np . pi , num_angles ) det_partition = uniform_partition ( det_min_pt , det_max_pt , det_shape ) if space . ndim == 2 :          return Parallel2dGeometry ( angle_partition , det_partition )  elif space . ndim == 3 :          return Parallel3dAxisGeometry ( angle_partition , det_partition )  else :          raise ValueError ( <str> )   if __name__ == <str> :      from odl . util . testutils import run_doctests run_doctests ( )   