from __future__ import print_function , division , absolute_import import numpy as np from odl . set import Set , IntervalProd from odl . util import ( normalized_index_expression , normalized_scalar_param_list , safe_int_conv , array_str , signature_string , indent , npy_printoptions ) __all__ = ( <str> , <str> , <str> ) def sparse_meshgrid ( * x ) :      n = len ( x ) mesh = [ ] for ax , xi in enumerate ( x ) :          xi = np . asarray ( xi ) slc = [ None ] * n slc [ ax ] = slice ( None ) mesh . append ( np . ascontiguousarray ( xi [ tuple ( slc ) ] ) )  return tuple ( mesh )  class RectGrid ( Set ) :      def __init__ ( self , * coord_vectors ) :          super ( RectGrid , self ) . __init__ ( ) vecs = tuple ( np . atleast_1d ( vec ) . astype ( <str> ) for vec in coord_vectors ) for i , vec in enumerate ( vecs ) :              if len ( vec ) == 0 :                  raise ValueError ( <str> <str> . format ( i + 1 ) )  if not np . all ( np . isfinite ( vec ) ) :                  raise ValueError ( <str> <str> . format ( i + 1 ) )  if vec . ndim != 1 :                  raise ValueError ( <str> <str> . format ( i + 1 , vec . ndim ) )  sorted_vec = np . sort ( vec ) if np . any ( vec != sorted_vec ) :                  raise ValueError ( <str> <str> . format ( i + 1 ) )  if np . any ( np . diff ( vec ) == 0 ) :                  raise ValueError ( <str> <str> . format ( i + 1 ) )   self . __stride = None self . __coord_vectors = vecs self . __nondegen_byaxis = tuple ( len ( v ) > 1 for v in self . coord_vectors ) diffs = [ np . diff ( v ) for v in self . coord_vectors ] self . __is_uniform_byaxis = tuple ( ( diff . size == 0 ) or np . allclose ( diff , diff [ 0 ] ) for diff in diffs )  @ property def coord_vectors ( self ) :          return self . __coord_vectors  @ property def ndim ( self ) :          try :              return self . __ndim  except AttributeError :              ndim = len ( self . coord_vectors ) self . __ndim = ndim return ndim   @ property def shape ( self ) :          try :              return self . __shape  except AttributeError :              shape = tuple ( len ( vec ) for vec in self . coord_vectors ) self . __shape = shape return shape   @ property def size ( self ) :          return ( 0 if self . shape == ( ) else int ( np . prod ( self . shape , dtype = <str> ) ) )  def __len__ ( self ) :          return 0 if self . shape == ( ) else self . shape [ 0 ]  @ property def min_pt ( self ) :          return np . array ( [ vec [ 0 ] for vec in self . coord_vectors ] )  @ property def max_pt ( self ) :          return np . array ( [ vec [ - 1 ] for vec in self . coord_vectors ] )  @ property def nondegen_byaxis ( self ) :          return self . __nondegen_byaxis  @ property def is_uniform_byaxis ( self ) :          return self . __is_uniform_byaxis  @ property def is_uniform ( self ) :          return all ( self . is_uniform_byaxis )  def min ( self , ** kwargs ) :          out = kwargs . get ( <str> , None ) if out is not None :              out [ : ] = self . min_pt return out  else :              return self . min_pt   def max ( self , ** kwargs ) :          out = kwargs . get ( <str> , None ) if out is not None :              out [ : ] = self . max_pt return out  else :              return self . max_pt   @ property def mid_pt ( self ) :          return ( self . max_pt + self . min_pt ) / 2  @ property def stride ( self ) :          if self . __stride is None :              strd = [ ] for i in range ( self . ndim ) :                  if not self . is_uniform_byaxis [ i ] :                      strd . append ( float ( <str> ) )  elif self . nondegen_byaxis [ i ] :                      strd . append ( self . extent [ i ] / ( self . shape [ i ] - 1.0 ) )  else :                      strd . append ( 0.0 )   self . __stride = np . array ( strd )  return self . __stride . copy ( )  @ property def extent ( self ) :          return self . max_pt - self . min_pt  def convex_hull ( self ) :          return IntervalProd ( self . min ( ) , self . max ( ) )  def element ( self ) :          return self . min_pt  def approx_equals ( self , other , atol ) :          if other is self :              return True  return ( type ( other ) is type ( self ) and self . ndim == other . ndim and self . shape == other . shape and all ( np . allclose ( vec_s , vec_o , atol = atol , rtol = 0.0 ) for ( vec_s , vec_o ) in zip ( self . coord_vectors , other . coord_vectors ) ) )  def __eq__ ( self , other ) :          if other is self :              return True  return ( type ( other ) is type ( self ) and self . shape == other . shape and all ( np . array_equal ( vec_s , vec_o ) for ( vec_s , vec_o ) in zip ( self . coord_vectors , other . coord_vectors ) ) )  def __hash__ ( self ) :          coord_vec_str = tuple ( cv . tobytes ( ) for cv in self . coord_vectors ) return hash ( ( type ( self ) , coord_vec_str ) )  def approx_contains ( self , other , atol ) :          other = np . atleast_1d ( other ) return ( other . shape == ( self . ndim , ) and all ( np . any ( np . isclose ( vector , coord , atol = atol , rtol = 0.0 ) ) for vector , coord in zip ( self . coord_vectors , other ) ) )  def __contains__ ( self , other ) :          other = np . atleast_1d ( other ) if other . dtype == np . dtype ( object ) :              return False  return ( other . shape == ( self . ndim , ) and all ( coord in vector for vector , coord in zip ( self . coord_vectors , other ) ) )  def is_subgrid ( self , other , atol = 0.0 ) :          if other is self :              return True  if not isinstance ( other , RectGrid ) :              return False  if not all ( self . shape [ i ] <= other . shape [ i ] and self . min_pt [ i ] >= other . min_pt [ i ] - atol and self . max_pt [ i ] <= other . max_pt [ i ] + atol for i in range ( self . ndim ) ) :              return False  if self . size == 0 :              return True  if self . is_uniform and other . is_uniform :              minmax_contained = ( other . approx_contains ( self . min_pt , atol = atol ) and other . approx_contains ( self . max_pt , atol = atol ) ) check_idx = np . zeros ( self . ndim , dtype = int ) check_idx [ np . array ( self . shape ) >= 3 ] = 1 checkpt_contained = other . approx_contains ( self [ tuple ( check_idx ) ] , atol = atol ) return minmax_contained and checkpt_contained  else :              for vec_o , vec_s in zip ( other . coord_vectors , self . coord_vectors ) :                  vec_o_mg , vec_s_mg = sparse_meshgrid ( vec_o , vec_s ) if not np . all ( np . any ( np . isclose ( vec_s_mg , vec_o_mg , atol = atol ) , axis = 0 ) ) :                      return False   return True   def insert ( self , index , * grids ) :          index , index_in = safe_int_conv ( index ) , index if not - self . ndim <= index <= self . ndim :              raise IndexError ( <str> <str> . format ( index_in , self . ndim ) )  if index < 0 :              index += self . ndim  if len ( grids ) == 0 :              return RectGrid ( * self . coord_vectors )  elif len ( grids ) == 1 :              grid = grids [ 0 ] if not isinstance ( grid , RectGrid ) :                  raise TypeError ( <str> <str> . format ( grid ) )  new_vecs = ( self . coord_vectors [ : index ] + grid . coord_vectors + self . coord_vectors [ index : ] ) return RectGrid ( * new_vecs )  else :              return self . insert ( index , grids [ 0 ] ) . insert ( index + grids [ 0 ] . ndim , * ( grids [ 1 : ] ) )   def append ( self , * grids ) :          return self . insert ( self . ndim , * grids )  def squeeze ( self , axis = None ) :          if axis is None :              rng = range ( self . ndim )  else :              rng = list ( np . atleast_1d ( np . arange ( self . ndim ) [ axis ] ) )  new_indcs = [ i for i in range ( self . ndim ) if i not in rng or self . nondegen_byaxis [ i ] ] coord_vecs = [ self . coord_vectors [ axis ] for axis in new_indcs ] return RectGrid ( * coord_vecs )  def points ( self , order = <str> ) :          if str ( order ) . upper ( ) not in ( <str> , <str> ) :              raise ValueError ( <str> . format ( order ) )  else :              order = str ( order ) . upper ( )  axes = range ( self . ndim ) if order == <str> else reversed ( range ( self . ndim ) ) shape = self . shape if order == <str> else tuple ( reversed ( self . shape ) ) point_arr = np . empty ( ( self . size , self . ndim ) ) for i , axis in enumerate ( axes ) :              view = point_arr [ : , axis ] . reshape ( shape ) coord_shape = ( 1 , ) * i + ( - 1 , ) + ( 1 , ) * ( self . ndim - i - 1 ) view [ : ] = self . coord_vectors [ axis ] . reshape ( coord_shape )  return point_arr  def corner_grid ( self ) :          minmax_vecs = [ ] for axis in range ( self . ndim ) :              if self . shape [ axis ] == 1 :                  minmax_vecs . append ( self . coord_vectors [ axis ] [ 0 ] )  else :                  minmax_vecs . append ( ( self . coord_vectors [ axis ] [ 0 ] , self . coord_vectors [ axis ] [ - 1 ] ) )   return RectGrid ( * minmax_vecs )  def corners ( self , order = <str> ) :          return self . corner_grid ( ) . points ( order = order )  @ property def meshgrid ( self ) :          return sparse_meshgrid ( * self . coord_vectors )  def __getitem__ ( self , indices ) :          if isinstance ( indices , list ) :              if indices == [ ] :                  new_coord_vecs = [ ]  else :                  new_coord_vecs = [ self . coord_vectors [ 0 ] [ indices ] ] new_coord_vecs += self . coord_vectors [ 1 : ]  return RectGrid ( * new_coord_vecs )  indices = normalized_index_expression ( indices , self . shape , int_to_slice = False ) if all ( np . isscalar ( idx ) for idx in indices ) :              return np . fromiter ( ( v [ int ( idx ) ] for idx , v in zip ( indices , self . coord_vectors ) ) , dtype = float )  else :              new_coord_vecs = [ vec [ idx ] for idx , vec in zip ( indices , self . coord_vectors ) ] return RectGrid ( * new_coord_vecs )   def __array__ ( self , dtype = None ) :          return self . points ( ) . astype ( dtype )  def __repr__ ( self ) :          if self . is_uniform :              ctor = <str> posargs = [ self . min_pt , self . max_pt , self . shape ] posmod = [ array_str , array_str , <str> ] with npy_printoptions ( precision = 4 ) :                  inner_str = signature_string ( posargs , [ ] , mod = [ posmod , <str> ] )  return <str> . format ( ctor , inner_str )  else :              ctor = self . __class__ . __name__ posargs = self . coord_vectors posmod = array_str inner_str = signature_string ( posargs , [ ] , sep = [ <str> , <str> , <str> ] , mod = [ posmod , <str> ] ) return <str> . format ( ctor , indent ( inner_str ) )   __str__ = __repr__  def uniform_grid_fromintv ( intv_prod , shape , nodes_on_bdry = True ) :      if not isinstance ( intv_prod , IntervalProd ) :          raise TypeError ( <str> <str> . format ( intv_prod ) )  if ( np . any ( np . isinf ( intv_prod . min_pt ) ) or np . any ( np . isinf ( intv_prod . max_pt ) ) ) :          raise ValueError ( <str> <str> . format ( <str> ) )  shape = normalized_scalar_param_list ( shape , intv_prod . ndim , safe_int_conv ) if np . shape ( nodes_on_bdry ) == ( ) :          nodes_on_bdry = ( [ ( bool ( nodes_on_bdry ) , bool ( nodes_on_bdry ) ) ] * intv_prod . ndim )  elif intv_prod . ndim == 1 and len ( nodes_on_bdry ) == 2 :          nodes_on_bdry = [ nodes_on_bdry ]  elif len ( nodes_on_bdry ) != intv_prod . ndim :          raise ValueError ( <str> <str> . format ( len ( nodes_on_bdry ) , intv_prod . ndim ) )  else :          shape = tuple ( int ( n ) for n in shape )  gmin , gmax = [ ] , [ ] for n , xmin , xmax , on_bdry in zip ( shape , intv_prod . min_pt , intv_prod . max_pt , nodes_on_bdry ) :          try :              bdry_l , bdry_r = on_bdry  except TypeError :              bdry_l = bdry_r = on_bdry  if bdry_l and bdry_r :              gmin . append ( xmin ) gmax . append ( xmax )  elif bdry_l and not bdry_r :              gmin . append ( xmin ) gmax . append ( xmax - ( xmax - xmin ) / ( 2 * n - 1 ) )  elif not bdry_l and bdry_r :              gmin . append ( xmin + ( xmax - xmin ) / ( 2 * n - 1 ) ) gmax . append ( xmax )  else :              gmin . append ( xmin + ( xmax - xmin ) / ( 2 * n ) ) gmax . append ( xmax - ( xmax - xmin ) / ( 2 * n ) )   coord_vecs = [ np . linspace ( mi , ma , num , endpoint = True , dtype = np . float64 ) for mi , ma , num in zip ( gmin , gmax , shape ) ] return RectGrid ( * coord_vecs )  def uniform_grid ( min_pt , max_pt , shape , nodes_on_bdry = True ) :      return uniform_grid_fromintv ( IntervalProd ( min_pt , max_pt ) , shape , nodes_on_bdry = nodes_on_bdry )  if __name__ == <str> :      from odl . util . testutils import run_doctests run_doctests ( )   