from __future__ import print_function import inspect import importlib import odl __all__ = ( <str> , ) module_string = fun_string = class_string = string = def import_submodules ( package , name = None , recursive = True ) :      if isinstance ( package , str ) :          package = importlib . import_module ( package )  if name is None :          name = package . __name__  submodules = [ m [ 0 ] for m in inspect . getmembers ( package , inspect . ismodule ) if m [ 1 ] . __name__ . startswith ( <str> ) ] results = { } for pkgname in submodules :          full_name = name + <str> + pkgname try :              results [ full_name ] = importlib . import_module ( full_name )  except ImportError :              pass  else :              if recursive :                  results . update ( import_submodules ( full_name , full_name ) )    return results  def make_interface ( ) :      modnames = [ <str> ] + list ( import_submodules ( odl ) . keys ( ) ) for modname in modnames :          if not modname . startswith ( <str> ) :              modname = <str> + modname  shortmodname = modname . split ( <str> ) [ - 1 ] print ( <str> . format ( shortmodname , modname ) ) line = <str> * len ( shortmodname ) module = importlib . import_module ( modname ) docstring = module . __doc__ submodules = [ m [ 0 ] for m in inspect . getmembers ( module , inspect . ismodule ) if m [ 1 ] . __name__ . startswith ( <str> ) ] functions = [ m [ 0 ] for m in inspect . getmembers ( module , inspect . isfunction ) if m [ 1 ] . __module__ == modname ] classes = [ m [ 0 ] for m in inspect . getmembers ( module , inspect . isclass ) if m [ 1 ] . __module__ == modname ] docstring = <str> if docstring is None else docstring submodules = [ modname + <str> + mod for mod in submodules ] functions = [ <str> + modname + <str> + fun for fun in functions if not fun . startswith ( <str> ) ] classes = [ <str> + modname + <str> + cls for cls in classes if not cls . startswith ( <str> ) ] if len ( submodules ) > 0 :              this_mod_string = module_string . format ( <str> . join ( submodules ) )  else :              this_mod_string = <str>  if len ( functions ) > 0 :              this_fun_string = fun_string . format ( <str> . join ( functions ) )  else :              this_fun_string = <str>  if len ( classes ) > 0 :              this_class_string = class_string . format ( <str> . join ( classes ) )  else :              this_class_string = <str>  with open ( modname + <str> , <str> ) as text_file :              text_file . write ( string . format ( shortname = shortmodname , name = modname , line = line , docstring = docstring , module_string = this_mod_string , fun_string = this_fun_string , class_string = this_class_string ) )    if __name__ == <str> :      make_interface ( )   