from __future__ import print_function , division , absolute_import from multiprocessing import cpu_count import numpy as np from packaging . version import parse as parse_version import warnings try :      import pyfftw PYFFTW_AVAILABLE = True  except ImportError :      PYFFTW_AVAILABLE = False  else :      if parse_version ( pyfftw . __version__ ) < parse_version ( <str> ) :          warnings . warn ( <str> <str> , RuntimeWarning )   from odl . util import ( is_real_dtype , dtype_repr , complex_dtype , normalized_axes_tuple ) __all__ = ( <str> , <str> ) def pyfftw_call ( array_in , array_out , direction = <str> , axes = None , halfcomplex = False , ** kwargs ) :      import pickle if not array_in . flags . aligned :          raise ValueError ( <str> )  if not array_out . flags . aligned :          raise ValueError ( <str> )  if axes is None :          axes = tuple ( range ( array_in . ndim ) )  axes = normalized_axes_tuple ( axes , array_in . ndim ) direction = _pyfftw_to_local ( direction ) fftw_plan_in = kwargs . pop ( <str> , None ) planning_effort = _pyfftw_to_local ( kwargs . pop ( <str> , <str> ) ) planning_timelimit = kwargs . pop ( <str> , None ) threads = kwargs . pop ( <str> , None ) normalise_idft = kwargs . pop ( <str> , False ) wimport = kwargs . pop ( <str> , <str> ) wexport = kwargs . pop ( <str> , <str> ) array_in_copied = False if is_real_dtype ( array_in . dtype ) and not halfcomplex :          array_in = array_in . astype ( complex_dtype ( array_in . dtype ) ) array_in_copied = True  _pyfftw_check_args ( array_in , array_out , axes , halfcomplex , direction ) if wimport :          try :              with open ( wimport , <str> ) as wfile :                  wisdom = pickle . load ( wfile )   except IOError :              wisdom = [ ]  except TypeError :              wisdom = pickle . load ( wimport )  if wisdom :              pyfftw . import_wisdom ( wisdom )   planner_destroys = _pyfftw_destroys_input ( [ planning_effort ] , direction , halfcomplex , array_in . ndim ) must_copy_array_in = fftw_plan_in is None and planner_destroys if must_copy_array_in and not array_in_copied :          plan_arr_in = np . empty_like ( array_in ) flags = [ _local_to_pyfftw ( planning_effort ) , <str> ]  else :          plan_arr_in = array_in flags = [ _local_to_pyfftw ( planning_effort ) ]  if fftw_plan_in is None :          if threads is None :              if plan_arr_in . size <= 4096 :                  threads = 1  else :                  threads = cpu_count ( )   fftw_plan = pyfftw . FFTW ( plan_arr_in , array_out , direction = _local_to_pyfftw ( direction ) , flags = flags , planning_timelimit = planning_timelimit , threads = threads , axes = axes )  else :          fftw_plan = fftw_plan_in  fftw_plan ( array_in , array_out , normalise_idft = normalise_idft ) if wexport :          try :              with open ( wexport , <str> ) as wfile :                  pickle . dump ( pyfftw . export_wisdom ( ) , wfile )   except TypeError :              pickle . dump ( pyfftw . export_wisdom ( ) , wexport )   return fftw_plan  def _pyfftw_to_local ( flag ) :      return flag . lstrip ( <str> ) . lower ( )  def _local_to_pyfftw ( flag ) :      return <str> + flag . upper ( )  def _pyfftw_destroys_input ( flags , direction , halfcomplex , ndim ) :      if any ( flag in flags or _pyfftw_to_local ( flag ) in flags for flag in ( <str> , <str> , <str> , <str> ) ) :          return True  elif ( direction in ( <str> , <str> ) and halfcomplex and ndim != 1 ) :          return True  else :          return False   def _pyfftw_check_args ( arr_in , arr_out , axes , halfcomplex , direction ) :      if len ( set ( axes ) ) != len ( axes ) :          raise ValueError ( <str> )  if direction == <str> :          out_shape = list ( arr_in . shape ) if halfcomplex :              try :                  out_shape [ axes [ - 1 ] ] = arr_in . shape [ axes [ - 1 ] ] // 2 + 1  except IndexError :                  raise IndexError ( <str> <str> <str> . format ( axes [ - 1 ] , arr_in . ndim ) )   if arr_out . shape != tuple ( out_shape ) :              raise ValueError ( <str> <str> . format ( tuple ( out_shape ) , arr_out . shape ) )  if is_real_dtype ( arr_in . dtype ) :              out_dtype = complex_dtype ( arr_in . dtype )  elif halfcomplex :              raise ValueError ( <str> <str> )  else :              out_dtype = arr_in . dtype  if arr_out . dtype != out_dtype :              raise ValueError ( <str> <str> . format ( dtype_repr ( out_dtype ) , dtype_repr ( arr_out . dtype ) ) )   elif direction == <str> :          in_shape = list ( arr_out . shape ) if halfcomplex :              try :                  in_shape [ axes [ - 1 ] ] = arr_out . shape [ axes [ - 1 ] ] // 2 + 1  except IndexError as err :                  raise IndexError ( <str> <str> <str> . format ( axes [ - 1 ] , arr_out . ndim ) )   if arr_in . shape != tuple ( in_shape ) :              raise ValueError ( <str> <str> . format ( tuple ( in_shape ) , arr_in . shape ) )  if is_real_dtype ( arr_out . dtype ) :              in_dtype = complex_dtype ( arr_out . dtype )  elif halfcomplex :              raise ValueError ( <str> <str> )  else :              in_dtype = arr_out . dtype  if arr_in . dtype != in_dtype :              raise ValueError ( <str> <str> . format ( dtype_repr ( in_dtype ) , dtype_repr ( arr_in . dtype ) ) )   else :          raise RuntimeError   if __name__ == <str> :      from odl . util . testutils import run_doctests run_doctests ( skip_if = not PYFFTW_AVAILABLE )   