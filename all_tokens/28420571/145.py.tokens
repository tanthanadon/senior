from __future__ import print_function , division , absolute_import from builtins import object import numpy as np from odl . space . base_tensors import TensorSpace from odl . util import array_str , signature_string , indent __all__ = ( <str> , <str> , <str> , <str> , <str> , <str> ) class Weighting ( object ) :      def __init__ ( self , impl , exponent = 2.0 ) :          self . __impl = str ( impl ) . lower ( ) self . __exponent = float ( exponent ) if self . exponent <= 0 :              raise ValueError ( <str> <str> . format ( exponent ) )   @ property def impl ( self ) :          return self . __impl  @ property def exponent ( self ) :          return self . __exponent  def __eq__ ( self , other ) :          return ( isinstance ( other , Weighting ) and self . impl == other . impl and self . exponent == other . exponent )  def __hash__ ( self ) :          return hash ( ( type ( self ) , self . impl , self . exponent ) )  def equiv ( self , other ) :          return self == other  def inner ( self , x1 , x2 ) :          raise NotImplementedError  def norm ( self , x ) :          return float ( np . sqrt ( self . inner ( x , x ) . real ) )  def dist ( self , x1 , x2 ) :          return self . norm ( x1 - x2 )   class MatrixWeighting ( Weighting ) :      def __init__ ( self , matrix , impl , exponent = 2.0 , ** kwargs ) :          import scipy . sparse precomp_mat_pow = kwargs . pop ( <str> , False ) self . _cache_mat_pow = bool ( kwargs . pop ( <str> , True ) ) self . _cache_mat_decomp = bool ( kwargs . pop ( <str> , False ) ) super ( MatrixWeighting , self ) . __init__ ( impl = impl , exponent = exponent ) if scipy . sparse . isspmatrix ( matrix ) :              self . _matrix = matrix  else :              self . _matrix = np . asarray ( matrix ) if self . _matrix . dtype == object :                  raise ValueError ( <str> . format ( matrix ) )  elif self . _matrix . ndim != 2 :                  raise ValueError ( <str> <str> <str> . format ( matrix , self . _matrix . ndim ) )   if self . _matrix . shape [ 0 ] != self . _matrix . shape [ 1 ] :              raise ValueError ( <str> <str> . format ( self . _matrix . shape ) )  if ( scipy . sparse . isspmatrix ( self . matrix ) and self . exponent not in ( 1.0 , 2.0 , float ( <str> ) ) ) :              raise NotImplementedError ( <str> <str> )  self . _eigval = self . _eigvec = None if self . exponent in ( 1.0 , float ( <str> ) ) :              self . _mat_pow = self . matrix  elif precomp_mat_pow and self . exponent != 2.0 :              eigval , eigvec = self . matrix_decomp ( ) if self . _cache_mat_decomp :                  self . _eigval , self . _eigvec = eigval , eigvec eigval_pow = eigval ** ( 1.0 / self . exponent )  else :                  eigval_pow = eigval eigval_pow **= 1.0 / self . exponent  self . _mat_pow = ( eigval_pow * eigvec ) . dot ( eigvec . conj ( ) . T )  else :              self . _mat_pow = None   @ property def matrix ( self ) :          return self . _matrix  def is_valid ( self ) :          import scipy . sparse if scipy . sparse . isspmatrix ( self . matrix ) :              raise NotImplementedError ( <str> <str> )  elif self . _eigval is not None :              return np . all ( np . greater ( self . _eigval , 0 ) )  else :              try :                  np . linalg . cholesky ( self . matrix ) return np . array_equal ( self . matrix , self . matrix . conj ( ) . T )  except np . linalg . LinAlgError :                  return False    def matrix_decomp ( self , cache = None ) :          import scipy . linalg import scipy . sparse if scipy . sparse . isspmatrix ( self . matrix ) :              raise NotImplementedError ( <str> )  if cache is None :              cache = self . _cache_mat_decomp  if self . _eigval is None or self . _eigvec is None :              eigval , eigvec = scipy . linalg . eigh ( self . matrix ) if cache :                  self . _eigval = eigval self . _eigvec = eigvec   else :              eigval , eigvec = self . _eigval , self . _eigvec  return eigval , eigvec  def __eq__ ( self , other ) :          if other is self :              return True  return ( super ( MatrixWeighting , self ) . __eq__ ( other ) and self . matrix is getattr ( other , <str> , None ) )  def __hash__ ( self ) :          return hash ( ( super ( MatrixWeighting , self ) . __hash__ ( ) , self . matrix . tobytes ( ) ) )  def equiv ( self , other ) :          import scipy . sparse if self == other :              return True  elif self . exponent != getattr ( other , <str> , - 1 ) :              return False  elif isinstance ( other , MatrixWeighting ) :              if self . matrix . shape != other . matrix . shape :                  return False  if scipy . sparse . isspmatrix ( self . matrix ) :                  if other . matrix_issparse :                      if self . matrix . nnz != other . matrix . nnz :                          return False  else :                          return ( self . matrix != other . matrix ) . nnz == 0   else :                      return np . array_equal ( self . matrix . todense ( ) , other . matrix )   else :                  if other . matrix_issparse :                      return np . array_equal ( self . matrix , other . matrix . todense ( ) )  else :                      return np . array_equal ( self . matrix , other . matrix )    elif isinstance ( other , ArrayWeighting ) :              if scipy . sparse . isspmatrix ( self . matrix ) :                  return ( np . array_equiv ( self . matrix . diagonal ( ) , other . array ) and np . array_equal ( self . matrix . asformat ( <str> ) . offsets , np . array ( [ 0 ] ) ) )  else :                  return np . array_equal ( self . matrix , other . array * np . eye ( self . matrix . shape [ 0 ] ) )   elif isinstance ( other , ConstWeighting ) :              if scipy . sparse . isspmatrix ( self . matrix ) :                  return ( np . array_equiv ( self . matrix . diagonal ( ) , other . const ) and np . array_equal ( self . matrix . asformat ( <str> ) . offsets , np . array ( [ 0 ] ) ) )  else :                  return np . array_equal ( self . matrix , other . const * np . eye ( self . matrix . shape [ 0 ] ) )   else :              return False   @ property def repr_part ( self ) :          import scipy . sparse if scipy . sparse . isspmatrix ( self . matrix ) :              optargs = [ ( <str> , str ( self . matrix ) , <str> ) ]  else :              optargs = [ ( <str> , array_str ( self . matrix , nprint = 10 ) , <str> ) ]  optargs . append ( ( <str> , self . exponent , 2.0 ) ) return signature_string ( [ ] , optargs , mod = [ [ ] , [ <str> , <str> ] ] )  def __repr__ ( self ) :          if self . matrix_issparse :              posargs = [ <str> <str> . format ( self . matrix . shape , self . matrix . format , self . matrix . nnz ) ]  else :              posargs = [ array_str ( self . matrix , nprint = 10 ) ]  optargs = [ ( <str> , self . exponent , 2.0 ) ] inner_str = signature_string ( posargs , optargs , sep = <str> , mod = [ <str> , <str> ] ) return <str> . format ( self . __class__ . __name__ , indent ( inner_str ) )  def __str__ ( self ) :          return repr ( self )   class ArrayWeighting ( Weighting ) :      def __init__ ( self , array , impl , exponent = 2.0 ) :          super ( ArrayWeighting , self ) . __init__ ( impl = impl , exponent = exponent ) array_attrs = ( <str> , <str> , <str> ) if ( all ( hasattr ( array , attr ) for attr in array_attrs ) and not isinstance ( array , TensorSpace ) ) :              self . __array = array  else :              raise TypeError ( <str> <str> . format ( array ) )   @ property def array ( self ) :          return self . __array  def is_valid ( self ) :          return np . all ( np . greater ( self . array , 0 ) )  def __eq__ ( self , other ) :          if other is self :              return True  return ( super ( ArrayWeighting , self ) . __eq__ ( other ) and self . array is getattr ( other , <str> , None ) )  def __hash__ ( self ) :          return hash ( ( super ( ArrayWeighting , self ) . __hash__ ( ) , self . array . tobytes ( ) ) )  def equiv ( self , other ) :          if self == other :              return True  elif ( not isinstance ( other , Weighting ) or self . exponent != other . exponent ) :              return False  elif isinstance ( other , MatrixWeighting ) :              return other . equiv ( self )  elif isinstance ( other , ConstWeighting ) :              return np . array_equiv ( self . array , other . const )  else :              return np . array_equal ( self . array , other . array )   @ property def repr_part ( self ) :          optargs = [ ( <str> , array_str ( self . array , nprint = 10 ) , <str> ) , ( <str> , self . exponent , 2.0 ) ] return signature_string ( [ ] , optargs , sep = <str> , mod = [ [ ] , [ <str> , <str> ] ] )  def __repr__ ( self ) :          posargs = [ array_str ( self . array ) ] optargs = [ ( <str> , self . exponent , 2.0 ) ] inner_str = signature_string ( posargs , optargs , sep = <str> , mod = [ <str> , <str> ] ) return <str> . format ( self . __class__ . __name__ , indent ( inner_str ) )  def __str__ ( self ) :          return repr ( self )   class ConstWeighting ( Weighting ) :      def __init__ ( self , const , impl , exponent = 2.0 ) :          super ( ConstWeighting , self ) . __init__ ( impl = impl , exponent = exponent ) self . __const = float ( const ) if self . const <= 0 :              raise ValueError ( <str> <str> . format ( const ) )  if not np . isfinite ( self . const ) :              raise ValueError ( <str> . format ( const ) )   @ property def const ( self ) :          return self . __const  def __eq__ ( self , other ) :          if other is self :              return True  return ( super ( ConstWeighting , self ) . __eq__ ( other ) and self . const == getattr ( other , <str> , None ) )  def __hash__ ( self ) :          return hash ( ( super ( ConstWeighting , self ) . __hash__ ( ) , self . const ) )  def equiv ( self , other ) :          if isinstance ( other , ConstWeighting ) :              return self == other  elif isinstance ( other , ( ArrayWeighting , MatrixWeighting ) ) :              return other . equiv ( self )  else :              return False   @ property def repr_part ( self ) :          optargs = [ ( <str> , self . const , 1.0 ) , ( <str> , self . exponent , 2.0 ) ] return signature_string ( [ ] , optargs , mod = <str> )  def __repr__ ( self ) :          posargs = [ self . const ] optargs = [ ( <str> , self . exponent , 2.0 ) ] return <str> . format ( self . __class__ . __name__ , signature_string ( posargs , optargs ) )  def __str__ ( self ) :          return repr ( self )   class CustomInner ( Weighting ) :      def __init__ ( self , inner , impl ) :          super ( CustomInner , self ) . __init__ ( impl = impl , exponent = 2.0 ) if not callable ( inner ) :              raise TypeError ( <str> <str> . format ( inner ) )  self . __inner = inner  @ property def inner ( self ) :          return self . __inner  def __eq__ ( self , other ) :          return ( super ( CustomInner , self ) . __eq__ ( other ) and self . inner == other . inner )  def __hash__ ( self ) :          return hash ( ( super ( CustomInner , self ) . __hash__ ( ) , self . inner ) )  @ property def repr_part ( self ) :          optargs = [ ( <str> , self . inner , <str> ) ] return signature_string ( [ ] , optargs , mod = <str> )  def __repr__ ( self ) :          posargs = [ self . inner ] optargs = [ ] inner_str = signature_string ( posargs , optargs , mod = <str> ) return <str> . format ( self . __class__ . __name__ , inner_str )   class CustomNorm ( Weighting ) :      def __init__ ( self , norm , impl ) :          super ( CustomNorm , self ) . __init__ ( impl = impl , exponent = 1.0 ) if not callable ( norm ) :              raise TypeError ( <str> <str> . format ( norm ) )  self . __norm = norm  def inner ( self , x1 , x2 ) :          raise NotImplementedError ( <str> )  @ property def norm ( self ) :          return self . __norm  def __eq__ ( self , other ) :          return ( super ( CustomNorm , self ) . __eq__ ( other ) and self . norm == other . norm )  def __hash__ ( self ) :          return hash ( ( super ( CustomNorm , self ) . __hash__ ( ) , self . norm ) )  @ property def repr_part ( self ) :          optargs = [ ( <str> , self . norm , <str> ) , ( <str> , self . exponent , 2.0 ) ] return signature_string ( [ ] , optargs , mod = [ [ ] , [ <str> , <str> ] ] )  def __repr__ ( self ) :          posargs = [ self . norm ] optargs = [ ( <str> , self . exponent , 2.0 ) ] inner_str = signature_string ( posargs , optargs , mod = [ <str> , <str> ] ) return <str> . format ( self . __class__ . __name__ , inner_str )   class CustomDist ( Weighting ) :      def __init__ ( self , dist , impl ) :          super ( CustomDist , self ) . __init__ ( impl = impl , exponent = 1.0 ) if not callable ( dist ) :              raise TypeError ( <str> <str> . format ( dist ) )  self . __dist = dist  @ property def dist ( self ) :          return self . __dist  def inner ( self , x1 , x2 ) :          raise NotImplementedError ( <str> )  def norm ( self , x ) :          raise NotImplementedError ( <str> )  def __eq__ ( self , other ) :          return ( super ( CustomDist , self ) . __eq__ ( other ) and self . dist == other . dist )  def __hash__ ( self ) :          return hash ( ( super ( CustomDist , self ) . __hash__ ( ) , self . dist ) )  @ property def repr_part ( self ) :          optargs = [ ( <str> , self . dist , <str> ) ] return signature_string ( [ ] , optargs , mod = [ <str> , <str> ] )  def __repr__ ( self ) :          posargs = [ self . dist ] optargs = [ ] inner_str = signature_string ( posargs , optargs , mod = [ <str> , <str> ] ) return <str> . format ( self . __class__ . __name__ , inner_str )   if __name__ == <str> :      from odl . util . testutils import run_doctests run_doctests ( )   