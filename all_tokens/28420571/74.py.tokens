from __future__ import division , print_function import numpy as np import pytest import scipy . special import odl from odl . solvers . functional . functional import FunctionalDefaultConvexConjugate from odl . util . testutils import ( all_almost_equal , noise_element , simple_fixture , skip_if_no_largescale ) pytestmark = skip_if_no_largescale stepsize = simple_fixture ( <str> , [ 0.1 , 1.0 , 10.0 ] ) linear_offset = simple_fixture ( <str> , [ False , True ] ) quadratic_offset = simple_fixture ( <str> , [ False , True ] ) dual = simple_fixture ( <str> , [ False , True ] ) func_params = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] func_ids = [ <str> . format ( p ) for p in func_params ] @ pytest . fixture ( scope = <str> , ids = func_ids , params = func_params ) def functional ( request , linear_offset , quadratic_offset , dual ) :      name = request . param . strip ( ) space = odl . uniform_discr ( 0 , 1 , 2 ) if name == <str> :          func = odl . solvers . L1Norm ( space )  elif name == <str> :          func = odl . solvers . L2Norm ( space )  elif name == <str> :          func = odl . solvers . L2NormSquared ( space )  elif name == <str> :          func = odl . solvers . KullbackLeibler ( space )  elif name == <str> :          func = odl . solvers . KullbackLeiblerCrossEntropy ( space )  elif name == <str> :          func = odl . solvers . ConstantFunctional ( space , constant = 2 )  elif name . startswith ( <str> ) :          exponent = float ( name . split ( <str> ) [ 1 ] ) space = odl . ProductSpace ( space , 2 ) func = odl . solvers . GroupL1Norm ( space , exponent = exponent )  elif name . startswith ( <str> ) :          outer_exp = float ( name . split ( <str> ) [ 1 ] ) singular_vector_exp = float ( name . split ( <str> ) [ 2 ] ) space = odl . ProductSpace ( odl . ProductSpace ( space , 2 ) , 3 ) func = odl . solvers . NuclearNorm ( space , outer_exp = outer_exp , singular_vector_exp = singular_vector_exp )  elif name == <str> :          func = odl . solvers . QuadraticForm ( operator = odl . IdentityOperator ( space ) , vector = space . one ( ) , constant = 0.623 )  elif name == <str> :          func = odl . solvers . QuadraticForm ( vector = space . one ( ) , constant = 0.623 )  elif name == <str> :          func = odl . solvers . Huber ( space , gamma = 0.162 )  else :          assert False  if quadratic_offset :          if linear_offset :              g = noise_element ( space ) if name . startswith ( <str> ) :                  g = np . abs ( g )   else :              g = None  quadratic_coeff = 1.32 func = odl . solvers . FunctionalQuadraticPerturb ( func , quadratic_coeff = quadratic_coeff , linear_term = g )  elif linear_offset :          g = noise_element ( space ) if name . startswith ( <str> ) :              g = np . abs ( g )  func = func . translated ( g )  if dual :          func = func . convex_conj  return func  EPS = 1e-6 def proximal_objective ( functional , x , y ) :      return functional ( y ) + ( 1.0 / 2.0 ) * ( x - y ) . norm ( ) ** 2  def test_proximal_defintion ( functional , stepsize ) :      if isinstance ( functional , FunctionalDefaultConvexConjugate ) :          pytest . skip ( <str> ) return  if ( isinstance ( functional , odl . solvers . FunctionalQuadraticPerturb ) and functional . quadratic_coeff != 0 ) :          pytest . skip ( <str> ) return  if isinstance ( functional , odl . solvers . QuadraticForm ) :          pytest . skip ( <str> ) return  if ( isinstance ( functional , odl . solvers . FunctionalTranslation ) and isinstance ( functional . functional , odl . solvers . QuadraticForm ) ) :          pytest . skip ( <str> ) return  if ( isinstance ( functional , odl . solvers . FunctionalQuadraticPerturb ) and isinstance ( functional . functional , odl . solvers . QuadraticForm ) and functional . functional . operator is not None ) :          pytest . skip ( <str> ) return  proximal = functional . proximal ( stepsize ) assert proximal . domain == functional . domain assert proximal . range == functional . domain for _ in range ( 100 ) :          x = noise_element ( proximal . domain ) * 10 prox_x = proximal ( x ) f_prox_x = proximal_objective ( stepsize * functional , x , prox_x ) y = noise_element ( proximal . domain ) f_y = proximal_objective ( stepsize * functional , x , y ) if not f_prox_x <= f_y + EPS :              print ( repr ( functional ) , x , y , prox_x , f_prox_x , f_y )  assert f_prox_x <= f_y + EPS   def convex_conj_objective ( functional , x , y ) :      return x . inner ( y ) - functional ( x )  def func_convex_conj_has_call ( functional ) :      f_cconj = functional . convex_conj if isinstance ( f_cconj , FunctionalDefaultConvexConjugate ) :          return False  elif ( isinstance ( f_cconj , odl . solvers . FunctionalTranslation ) and isinstance ( f_cconj . functional , FunctionalDefaultConvexConjugate ) ) :          return False  return True  def test_convex_conj_defintion ( functional ) :      if isinstance ( functional , FunctionalDefaultConvexConjugate ) :          pytest . skip ( <str> ) return  if not func_convex_conj_has_call ( functional ) :          pytest . skip ( <str> ) return  f_convex_conj = functional . convex_conj for _ in range ( 100 ) :          y = noise_element ( functional . domain ) f_convex_conj_y = f_convex_conj ( y ) x = noise_element ( functional . domain ) lhs = x . inner ( y ) - functional ( x ) if not lhs <= f_convex_conj_y + EPS :              print ( repr ( functional ) , repr ( f_convex_conj ) , x , y , lhs , f_convex_conj_y )  assert lhs <= f_convex_conj_y + EPS   def test_proximal_convex_conj_kl_cross_entropy_solving_opt_problem ( ) :      space = odl . uniform_discr ( 0 , 1 , 10 ) g = space . element ( np . arange ( 10 , 0 , - 1 ) ) a = space . element ( np . arange ( 4 , 14 , 1 ) ) id_op = odl . IdentityOperator ( space ) lin_ops = [ id_op , id_op ] lam_kl = 2.3 kl_ce = odl . solvers . KullbackLeiblerCrossEntropy ( space , prior = g ) g_funcs = [ lam_kl * kl_ce , 0.5 * odl . solvers . L2NormSquared ( space ) . translated ( a ) ] f = odl . solvers . ZeroFunctional ( space ) x = space . zero ( ) odl . solvers . douglas_rachford_pd ( x , f , g_funcs , lin_ops , tau = 2.1 , sigma = [ 0.4 , 0.4 ] , niter = 100 ) x_verify = lam_kl * scipy . special . lambertw ( ( g / lam_kl ) * np . exp ( a / lam_kl ) ) assert all_almost_equal ( x , x_verify , ndigits = 6 )  if __name__ == <str> :      odl . util . test_file ( __file__ , [ <str> ] )   