 from __future__ import print_function , division , absolute_import from builtins import object import numpy as np from odl . diagnostics . examples import samples from odl . operator import power_method_opnorm from odl . util . testutils import FailCounter __all__ = ( <str> , ) class OperatorTest ( object ) :      def __init__ ( self , operator , operator_norm = None , verbose = True , tol = 1e-5 ) :          self . operator = operator self . verbose = False if operator_norm is None :              self . operator_norm = self . norm ( )  else :              self . operator_norm = float ( operator_norm )  self . verbose = bool ( verbose ) self . tol = float ( tol )  def log ( self , message ) :          if self . verbose :              print ( message )   def norm ( self ) :          self . log ( <str> ) operator_norm = max ( power_method_opnorm ( self . operator , maxiter = 2 , xstart = x ) for name , x in samples ( self . operator . domain ) if name != <str> ) self . log ( <str> . format ( operator_norm ) ) self . operator_norm = operator_norm return operator_norm  def self_adjoint ( self ) :          left_inner_vals = [ ] right_inner_vals = [ ] with FailCounter ( test_name = <str> , err_msg = <str> , logger = self . log ) as counter :              for [ name_x , x ] , [ name_y , y ] in samples ( self . operator . domain , self . operator . range ) :                  x_norm = x . norm ( ) y_norm = y . norm ( ) l_inner = self . operator ( x ) . inner ( y ) r_inner = x . inner ( self . operator ( y ) ) denom = self . operator_norm * x_norm * y_norm error = 0 if denom == 0 else abs ( l_inner - r_inner ) / denom if error > self . tol :                      counter . fail ( <str> <str> . format ( name_x , name_y , error ) )  left_inner_vals . append ( l_inner ) right_inner_vals . append ( r_inner )   scale = np . polyfit ( left_inner_vals , right_inner_vals , 1 ) [ 0 ] self . log ( <str> ) self . log ( <str> . format ( scale ) )  def _adjoint_definition ( self ) :          left_inner_vals = [ ] right_inner_vals = [ ] with FailCounter ( test_name = <str> , err_msg = <str> , logger = self . log ) as counter :              for [ name_x , x ] , [ name_y , y ] in samples ( self . operator . domain , self . operator . range ) :                  x_norm = x . norm ( ) y_norm = y . norm ( ) l_inner = self . operator ( x ) . inner ( y ) r_inner = x . inner ( self . operator . adjoint ( y ) ) denom = self . operator_norm * x_norm * y_norm error = 0 if denom == 0 else abs ( l_inner - r_inner ) / denom if error > self . tol :                      counter . fail ( <str> <str> . format ( name_x , name_y , error ) )  left_inner_vals . append ( l_inner ) right_inner_vals . append ( r_inner )   scale = np . polyfit ( left_inner_vals , right_inner_vals , 1 ) [ 0 ] self . log ( <str> ) self . log ( <str> . format ( scale ) )  def _adjoint_of_adjoint ( self ) :          try :              self . operator . adjoint . adjoint  except AttributeError :              print ( <str> ) return  if self . operator . adjoint . adjoint is self . operator :              self . log ( <str> ) return  with FailCounter ( test_name = <str> , err_msg = <str> , logger = self . log ) as counter :              for [ name_x , x ] in self . operator . domain . examples :                  opx = self . operator ( x ) op_adj_adj_x = self . operator . adjoint . adjoint ( x ) denom = self . operator_norm * x . norm ( ) if denom == 0 :                      error = 0  else :                      error = ( opx - op_adj_adj_x ) . norm ( ) / denom  if error > self . tol :                      counter . fail ( <str> <str> . format ( name_x , error ) )     def adjoint ( self ) :          try :              self . operator . adjoint  except NotImplementedError :              print ( <str> ) return  self . log ( <str> ) domain_range_ok = True if self . operator . domain != self . operator . adjoint . range :              print ( <str> ) domain_range_ok = False  if self . operator . range != self . operator . adjoint . domain :              print ( <str> ) domain_range_ok = False  if domain_range_ok :              self . log ( <str> )  else :              print ( <str> ) return  self . _adjoint_definition ( ) self . _adjoint_of_adjoint ( )  def _derivative_convergence ( self ) :          with FailCounter ( test_name = <str> <str> , err_msg = <str> , logger = self . log ) as counter :              for [ name_x , x ] , [ name_dx , dx ] in samples ( self . operator . domain , self . operator . domain ) :                  deriv = self . operator . derivative ( x ) derivdx = deriv ( dx ) opx = self . operator ( x ) c = 1e-4 derivative_ok = False minerror = float ( <str> ) while c > 1e-14 :                      exact_step = self . operator ( x + dx * c ) - opx expected_step = c * derivdx err = ( exact_step - expected_step ) . norm ( ) / c if err < 10 * self . tol :                          derivative_ok = True break  else :                          minerror = min ( minerror , err )  c /= 10.0  if not derivative_ok :                      counter . fail ( <str> <str> . format ( name_x , name_dx , minerror ) )     def derivative ( self ) :          self . log ( <str> ) try :              deriv = self . operator . derivative ( self . operator . domain . zero ( ) ) if not deriv . is_linear :                  print ( <str> ) return   except NotImplementedError :              print ( <str> ) return  if self . operator . is_linear and deriv is self . operator :              self . log ( <str> ) return  self . _derivative_convergence ( )  def _scale_invariance ( self ) :          with FailCounter ( test_name = <str> , err_msg = <str> , logger = self . log ) as counter :              for [ name_x , x ] , [ _ , scale ] in samples ( self . operator . domain , self . operator . domain . field ) :                  opx = self . operator ( x ) scaled_opx = self . operator ( scale * x ) denom = self . operator_norm * scale * x . norm ( ) error = ( 0 if denom == 0 else ( scaled_opx - opx * scale ) . norm ( ) / denom ) if error > self . tol :                      counter . fail ( <str> <str> . format ( name_x , scale , error ) )     def _addition_invariance ( self ) :          with FailCounter ( test_name = <str> , err_msg = <str> <str> , logger = self . log ) as counter :              for [ name_x , x ] , [ name_y , y ] in samples ( self . operator . domain , self . operator . domain ) :                  opx = self . operator ( x ) opy = self . operator ( y ) opxy = self . operator ( x + y ) denom = self . operator_norm * ( x . norm ( ) + y . norm ( ) ) error = ( 0 if denom == 0 else ( opxy - opx - opy ) . norm ( ) / denom ) if error > self . tol :                      counter . fail ( <str> <str> . format ( name_x , name_y , error ) )     def linear ( self ) :          if not self . operator . is_linear :              print ( <str> ) return  self . log ( <str> ) result = self . operator ( self . operator . domain . zero ( ) ) result_norm = result . norm ( ) if result_norm != 0.0 :              print ( <str> . format ( result_norm ) )  self . _scale_invariance ( ) self . _addition_invariance ( )  def run_tests ( self ) :          print ( <str> ) print ( <str> . format ( self . operator ) ) self . norm ( ) if self . operator . is_linear :              self . linear ( ) self . adjoint ( )  else :              self . derivative ( )   def __str__ ( self ) :          return <str> . format ( self . __class__ . __name__ , self . operator )  def __repr__ ( self ) :          return <str> . format ( self . __class__ . __name__ , self . operator )   if __name__ == <str> :      import odl space = odl . uniform_discr ( [ 0 , 0 ] , [ 1 , 1 ] , [ 3 , 3 ] ) I = odl . IdentityOperator ( space ) OperatorTest ( I , verbose = False ) . run_tests ( ) op = odl . PowerOperator ( space , 4 ) OperatorTest ( op ) . run_tests ( )   