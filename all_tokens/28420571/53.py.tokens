from __future__ import division import pytest import odl from odl . solvers import forward_backward_pd from odl . util . testutils import all_almost_equal , noise_element HIGH_ACCURACY = 8 LOW_ACCURACY = 4 def test_forward_backward_input_handling ( ) :      space1 = odl . uniform_discr ( 0 , 1 , 10 ) lin_ops = [ odl . ZeroOperator ( space1 ) , odl . ZeroOperator ( space1 ) ] g = [ odl . solvers . ZeroFunctional ( space1 ) , odl . solvers . ZeroFunctional ( space1 ) ] f = odl . solvers . ZeroFunctional ( space1 ) h = odl . solvers . ZeroFunctional ( space1 ) x0 = noise_element ( space1 ) x = x0 . copy ( ) niter = 3 forward_backward_pd ( x , f , g , lin_ops , h , tau = 1.0 , sigma = [ 1.0 , 1.0 ] , niter = niter ) assert x == x0 with pytest . raises ( ValueError ) :          forward_backward_pd ( x , f , g , lin_ops , h , tau = 1.0 , sigma = [ 1.0 ] , niter = niter )  g_too_many = [ odl . solvers . ZeroFunctional ( space1 ) , odl . solvers . ZeroFunctional ( space1 ) , odl . solvers . ZeroFunctional ( space1 ) ] with pytest . raises ( ValueError ) :          forward_backward_pd ( x , f , g_too_many , lin_ops , h , tau = 1.0 , sigma = [ 1.0 , 1.0 ] , niter = niter )  space2 = odl . uniform_discr ( 1 , 2 , 10 ) x = noise_element ( space2 ) with pytest . raises ( ValueError ) :          forward_backward_pd ( x , f , g , lin_ops , h , tau = 1.0 , sigma = [ 1.0 , 1.0 ] , niter = niter )   def test_forward_backward_basic ( ) :      space = odl . rn ( 10 ) lin_ops = [ odl . ZeroOperator ( space ) ] g = [ odl . solvers . ZeroFunctional ( space ) ] f = odl . solvers . ZeroFunctional ( space ) h = odl . solvers . L2NormSquared ( space ) x = noise_element ( space ) x_global_min = space . zero ( ) forward_backward_pd ( x , f , g , lin_ops , h , tau = 0.5 , sigma = [ 1.0 ] , niter = 10 ) assert all_almost_equal ( x , x_global_min , ndigits = HIGH_ACCURACY )  def test_forward_backward_with_lin_ops ( ) :      space = odl . rn ( 10 ) alpha = 0.1 b = noise_element ( space ) lin_ops = [ alpha * odl . IdentityOperator ( space ) ] g = [ odl . solvers . L2NormSquared ( space ) ] f = odl . solvers . ZeroFunctional ( space ) h = odl . solvers . L2NormSquared ( space ) . translated ( b ) x = noise_element ( space ) x_global_min = b / ( 1 + alpha ** 2 ) forward_backward_pd ( x , f , g , lin_ops , h , tau = 0.5 , sigma = [ 1.0 ] , niter = 20 ) assert all_almost_equal ( x , x_global_min , ndigits = LOW_ACCURACY )  def test_forward_backward_with_li ( ) :      upper_lim = - 1 lower_lim = - 3 space = odl . rn ( 1 ) lin_op = odl . IdentityOperator ( space ) lin_ops = [ lin_op ] g = [ odl . solvers . IndicatorBox ( space , lower = lower_lim , upper = upper_lim ) ] f = odl . solvers . ZeroFunctional ( space ) h = odl . solvers . ZeroFunctional ( space ) l = [ 0.5 * odl . solvers . L2NormSquared ( space ) ] x = space . element ( 10 ) forward_backward_pd ( x , f , g , lin_ops , h , tau = 0.5 , sigma = [ 1.0 ] , niter = 20 , l = l ) assert lower_lim - 10 ** ( - LOW_ACCURACY ) <= x [ 0 ] assert x [ 0 ] <= upper_lim + 10 ** ( - LOW_ACCURACY )  def test_forward_backward_with_li_and_h ( ) :      upper_lim = - 1 lower_lim = - 3 space = odl . rn ( 1 ) lin_ops = [ odl . IdentityOperator ( space ) ] g = [ odl . solvers . IndicatorBox ( space , lower = lower_lim , upper = upper_lim ) ] f = odl . solvers . ZeroFunctional ( space ) h = 0.5 * odl . solvers . L2NormSquared ( space ) l = [ 0.5 * odl . solvers . L2NormSquared ( space ) ] x = space . element ( 10 ) forward_backward_pd ( x , f , g , lin_ops , h , tau = 0.5 , sigma = [ 1.0 ] , niter = 20 , l = l ) expected_result = - 0.5 assert x [ 0 ] == pytest . approx ( expected_result , rel = 10 ** - LOW_ACCURACY )  if __name__ == <str> :      odl . util . test_file ( __file__ )   