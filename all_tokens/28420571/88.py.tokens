from __future__ import print_function , division , absolute_import from builtins import object import numpy as np from odl . discr import RectPartition from odl . tomo . util import perpendicular_vector , is_inside_bounds from odl . util import indent , signature_string , array_str from odl . util . npy_compat import moveaxis __all__ = ( <str> , <str> , <str> , <str> ) class Detector ( object ) :      def __init__ ( self , partition , space_ndim = None , check_bounds = True ) :          if not isinstance ( partition , RectPartition ) :              raise TypeError ( <str> <str> . format ( partition ) )  if space_ndim is None :              self . __space_ndim = partition . ndim + 1  else :              self . __space_ndim = int ( space_ndim ) if self . space_ndim <= 0 :                  raise ValueError ( <str> <str> . format ( space_ndim ) )   self . __partition = partition self . __check_bounds = bool ( check_bounds )  @ property def partition ( self ) :          return self . __partition  @ property def check_bounds ( self ) :          return self . __check_bounds  @ property def ndim ( self ) :          return self . partition . ndim  @ property def space_ndim ( self ) :          return self . __space_ndim  @ property def params ( self ) :          return self . partition . set  @ property def grid ( self ) :          return self . partition . grid  @ property def shape ( self ) :          return self . partition . shape  @ property def size ( self ) :          return self . partition . size  def surface ( self , param ) :          raise NotImplementedError ( <str> )  def surface_deriv ( self , param ) :          raise NotImplementedError ( <str> )  def surface_normal ( self , param ) :          if self . ndim == 1 and self . space_ndim == 2 :              return - perpendicular_vector ( self . surface_deriv ( param ) )  elif self . ndim == 2 and self . space_ndim == 3 :              deriv = self . surface_deriv ( param ) if deriv . ndim > 2 :                  deriv = moveaxis ( deriv , - 2 , 0 )  normal = np . cross ( * deriv , axis = - 1 ) normal /= np . linalg . norm ( normal , axis = - 1 , keepdims = True ) return normal  else :              raise NotImplementedError ( <str> <str> <str> . format ( self . ndim , self . space_ndim ) )   def surface_measure ( self , param ) :          if self . ndim == 1 :              scalar_out = ( np . shape ( param ) == ( ) ) measure = np . linalg . norm ( self . surface_deriv ( param ) , axis = - 1 ) if scalar_out :                  measure = float ( measure )  return measure  elif self . ndim == 2 and self . space_ndim == 3 :              scalar_out = ( np . shape ( param ) == ( 2 , ) ) deriv = self . surface_deriv ( param ) if deriv . ndim > 2 :                  deriv = moveaxis ( deriv , - 2 , 0 )  cross = np . cross ( * deriv , axis = - 1 ) measure = np . linalg . norm ( cross , axis = - 1 ) if scalar_out :                  measure = float ( measure )  return measure  else :              raise NotImplementedError ( <str> <str> <str> . format ( self . ndim , self . space_ndim ) )    class Flat1dDetector ( Detector ) :      def __init__ ( self , partition , axis , check_bounds = True ) :          super ( Flat1dDetector , self ) . __init__ ( partition , 2 , check_bounds ) if self . ndim != 1 :              raise ValueError ( <str> <str> . format ( self . ndim ) )  if np . linalg . norm ( axis ) == 0 :              raise ValueError ( <str> )  self . __axis = np . asarray ( axis ) / np . linalg . norm ( axis )  @ property def axis ( self ) :          return self . __axis  def surface ( self , param ) :          squeeze_out = ( np . shape ( param ) == ( ) ) param = np . array ( param , dtype = float , copy = False , ndmin = 1 ) if self . check_bounds and not is_inside_bounds ( param , self . params ) :              raise ValueError ( <str> <str> . format ( param , self . params ) )  surf = np . multiply . outer ( param , self . axis ) if squeeze_out :              surf = surf . squeeze ( )  return surf  def surface_deriv ( self , param ) :          squeeze_out = ( np . shape ( param ) == ( ) ) param = np . array ( param , dtype = float , copy = False , ndmin = 1 ) if self . check_bounds and not is_inside_bounds ( param , self . params ) :              raise ValueError ( <str> <str> . format ( param , self . params ) )  if squeeze_out :              return self . axis  else :              bcast_slc = ( None , ) * param . ndim + ( slice ( None ) , ) return np . broadcast_to ( self . axis [ bcast_slc ] , param . shape + self . axis . shape )   def __repr__ ( self ) :          posargs = [ self . partition ] optargs = [ ( <str> , array_str ( self . axis ) , <str> ) ] inner_str = signature_string ( posargs , optargs , sep = <str> ) return <str> . format ( self . __class__ . __name__ , indent ( inner_str ) )  def __str__ ( self ) :          return repr ( self )   class Flat2dDetector ( Detector ) :      def __init__ ( self , partition , axes , check_bounds = True ) :          super ( Flat2dDetector , self ) . __init__ ( partition , 3 , check_bounds ) if self . ndim != 2 :              raise ValueError ( <str> <str> . format ( self . ndim ) )  axes , axes_in = np . asarray ( axes , dtype = float ) , axes if axes . shape != ( 2 , 3 ) :              raise ValueError ( <str> <str> . format ( axes_in ) )  if np . linalg . norm ( np . cross ( * axes ) ) == 0 :              raise ValueError ( <str> <str> . format ( axes_in ) )  self . __axes = axes / np . linalg . norm ( axes , axis = 1 , keepdims = True )  @ property def axes ( self ) :          return self . __axes  def surface ( self , param ) :          squeeze_out = ( np . broadcast ( * param ) . shape == ( ) ) param_in = param param = tuple ( np . array ( p , dtype = float , copy = False , ndmin = 1 ) for p in param ) if self . check_bounds and not is_inside_bounds ( param , self . params ) :              raise ValueError ( <str> <str> . format ( param_in , self . params ) )  surf = sum ( np . multiply . outer ( p , ax ) for p , ax in zip ( param , self . axes ) ) if squeeze_out :              surf = surf . squeeze ( )  return surf  def surface_deriv ( self , param ) :          squeeze_out = ( np . broadcast ( * param ) . shape == ( ) ) param_in = param param = tuple ( np . array ( p , dtype = float , copy = False , ndmin = 1 ) for p in param ) if self . check_bounds and not is_inside_bounds ( param , self . params ) :              raise ValueError ( <str> <str> . format ( param_in , self . params ) )  if squeeze_out :              return self . axes  else :              return np . broadcast_to ( self . axes , np . broadcast ( * param ) . shape + self . axes . shape )   def __repr__ ( self ) :          posargs = [ self . partition ] optargs = [ ( <str> , tuple ( array_str ( ax ) for ax in self . axes ) , None ) ] inner_str = signature_string ( posargs , optargs , sep = <str> ) return <str> . format ( self . __class__ . __name__ , indent ( inner_str ) )  def __str__ ( self ) :          return repr ( self )   class CircleSectionDetector ( Detector ) :      def __init__ ( self , partition , center , check_bounds = True ) :          super ( CircleSectionDetector , self ) . __init__ ( partition , 2 , check_bounds ) if self . ndim != 1 :              raise ValueError ( <str> <str> . format ( self . ndim ) )  self . __center = np . asarray ( center , dtype = float ) if self . center . shape != ( 2 , ) :              raise ValueError ( <str> <str> . format ( self . center . shape ) )  if np . linalg . norm ( self . center ) == 0 :              raise ValueError ( <str> )   @ property def center ( self ) :          return self . __center  @ property def radius ( self ) :          return np . linalg . norm ( self . center )  @ property def center_dir ( self ) :          return self . center / self . radius  @ property def tangent_at_0 ( self ) :          return perpendicular_vector ( self . center_dir )  def surface ( self , param ) :          squeeze_out = ( np . shape ( param ) == ( ) ) param = np . array ( param , dtype = float , copy = False , ndmin = 1 ) if self . check_bounds and not is_inside_bounds ( param , self . params ) :              raise ValueError ( <str> <str> . format ( param , self . params ) )  center_part = np . multiply . outer ( 1 - np . cos ( param ) , self . center_dir ) tangent_part = np . multiply . outer ( np . sin ( param ) , self . tangent_at_0 ) surf = self . radius * ( center_part + tangent_part ) if squeeze_out :              surf = surf . squeeze ( )  return surf  def surface_deriv ( self , param ) :          squeeze_out = ( np . shape ( param ) == ( ) ) param = np . array ( param , dtype = float , copy = False , ndmin = 1 ) if self . check_bounds and not is_inside_bounds ( param , self . params ) :              raise ValueError ( <str> <str> . format ( param , self . params ) )  center_part = np . multiply . outer ( np . sin ( param ) , self . center_dir ) tangent_part = np . multiply . outer ( np . cos ( param ) , self . tangent_at_0 ) deriv = self . radius * ( center_part + tangent_part ) if squeeze_out :              deriv = deriv . squeeze ( )  return deriv  def surface_measure ( self , param ) :          scalar_out = ( np . shape ( param ) == ( ) ) param = np . array ( param , dtype = float , copy = False , ndmin = 1 ) if self . check_bounds and not is_inside_bounds ( param , self . params ) :              raise ValueError ( <str> <str> . format ( param , self . params ) )  if scalar_out :              return self . radius  else :              return self . radius * np . ones ( param . shape )   def __repr__ ( self ) :          posargs = [ self . partition ] optargs = [ ( <str> , array_str ( self . center ) , None ) ] inner_str = signature_string ( posargs , optargs , sep = <str> ) return <str> . format ( self . __class__ . __name__ , indent ( inner_str ) )  def __str__ ( self ) :          return repr ( self )   if __name__ == <str> :      from odl . util . testutils import run_doctests run_doctests ( )   