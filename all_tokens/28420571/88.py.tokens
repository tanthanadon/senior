from __future__ import absolute_import , division , print_function from builtins import object import numpy as np from odl . discr import RectPartition from odl . tomo . util import is_inside_bounds , perpendicular_vector from odl . tomo . util . utility import rotation_matrix_from_to from odl . util import array_str , indent , signature_string __all__ = ( <str> , <str> , <str> , <str> , <str> , <str> ) class Detector ( object ) :      def __init__ ( self , partition , space_ndim = None , check_bounds = True ) :          if not isinstance ( partition , RectPartition ) :              raise TypeError ( <str> <str> . format ( partition ) )  if space_ndim is None :              self . __space_ndim = partition . ndim + 1  else :              self . __space_ndim = int ( space_ndim ) if self . space_ndim <= 0 :                  raise ValueError ( <str> <str> . format ( space_ndim ) )   self . __partition = partition self . __check_bounds = bool ( check_bounds )  @ property def partition ( self ) :          return self . __partition  @ property def check_bounds ( self ) :          return self . __check_bounds  @ property def ndim ( self ) :          return self . partition . ndim  @ property def space_ndim ( self ) :          return self . __space_ndim  @ property def params ( self ) :          return self . partition . set  @ property def grid ( self ) :          return self . partition . grid  @ property def shape ( self ) :          return self . partition . shape  @ property def size ( self ) :          return self . partition . size  def surface ( self , param ) :          raise NotImplementedError ( <str> )  def surface_deriv ( self , param ) :          raise NotImplementedError ( <str> )  def surface_normal ( self , param ) :          if self . ndim == 1 and self . space_ndim == 2 :              return - perpendicular_vector ( self . surface_deriv ( param ) )  elif self . ndim == 2 and self . space_ndim == 3 :              deriv = self . surface_deriv ( param ) if deriv . ndim > 2 :                  deriv = np . moveaxis ( deriv , - 2 , 0 )  normal = np . cross ( * deriv , axis = - 1 ) normal /= np . linalg . norm ( normal , axis = - 1 , keepdims = True ) return normal  else :              raise NotImplementedError ( <str> <str> <str> . format ( self . ndim , self . space_ndim ) )   def surface_measure ( self , param ) :          if self . ndim == 1 :              scalar_out = ( np . shape ( param ) == ( ) ) measure = np . linalg . norm ( self . surface_deriv ( param ) , axis = - 1 ) if scalar_out :                  measure = float ( measure )  return measure  elif self . ndim == 2 and self . space_ndim == 3 :              scalar_out = ( np . shape ( param ) == ( 2 , ) ) deriv = self . surface_deriv ( param ) if deriv . ndim > 2 :                  deriv = np . moveaxis ( deriv , - 2 , 0 )  cross = np . cross ( * deriv , axis = - 1 ) measure = np . linalg . norm ( cross , axis = - 1 ) if scalar_out :                  measure = float ( measure )  return measure  else :              raise NotImplementedError ( <str> <str> <str> . format ( self . ndim , self . space_ndim ) )    class Flat1dDetector ( Detector ) :      def __init__ ( self , partition , axis , check_bounds = True ) :          super ( Flat1dDetector , self ) . __init__ ( partition , 2 , check_bounds ) if self . ndim != 1 :              raise ValueError ( <str> <str> . format ( self . ndim ) )  if np . linalg . norm ( axis ) == 0 :              raise ValueError ( <str> )  self . __axis = np . asarray ( axis ) / np . linalg . norm ( axis )  @ property def axis ( self ) :          return self . __axis  def surface ( self , param ) :          squeeze_out = ( np . shape ( param ) == ( ) ) param = np . array ( param , dtype = float , copy = False , ndmin = 1 ) if self . check_bounds and not is_inside_bounds ( param , self . params ) :              raise ValueError ( <str> <str> . format ( param , self . params ) )  surf = np . multiply . outer ( param , self . axis ) if squeeze_out :              surf = surf . squeeze ( )  return surf  def surface_deriv ( self , param ) :          squeeze_out = ( np . shape ( param ) == ( ) ) param = np . array ( param , dtype = float , copy = False , ndmin = 1 ) if self . check_bounds and not is_inside_bounds ( param , self . params ) :              raise ValueError ( <str> <str> . format ( param , self . params ) )  if squeeze_out :              return self . axis  else :              bcast_slc = ( None , ) * param . ndim + ( slice ( None ) , ) return np . broadcast_to ( self . axis [ bcast_slc ] , param . shape + self . axis . shape )   def __repr__ ( self ) :          posargs = [ self . partition ] optargs = [ ( <str> , array_str ( self . axis ) , <str> ) ] inner_str = signature_string ( posargs , optargs , sep = <str> ) return <str> . format ( self . __class__ . __name__ , indent ( inner_str ) )  def __str__ ( self ) :          return repr ( self )   class Flat2dDetector ( Detector ) :      def __init__ ( self , partition , axes , check_bounds = True ) :          super ( Flat2dDetector , self ) . __init__ ( partition , 3 , check_bounds ) if self . ndim != 2 :              raise ValueError ( <str> <str> . format ( self . ndim ) )  axes , axes_in = np . asarray ( axes , dtype = float ) , axes if axes . shape != ( 2 , 3 ) :              raise ValueError ( <str> <str> . format ( axes_in ) )  if np . linalg . norm ( np . cross ( * axes ) ) == 0 :              raise ValueError ( <str> <str> . format ( axes_in ) )  self . __axes = axes / np . linalg . norm ( axes , axis = 1 , keepdims = True )  @ property def axes ( self ) :          return self . __axes  def surface ( self , param ) :          squeeze_out = ( np . broadcast ( * param ) . shape == ( ) ) param_in = param param = tuple ( np . array ( p , dtype = float , copy = False , ndmin = 1 ) for p in param ) if self . check_bounds and not is_inside_bounds ( param , self . params ) :              raise ValueError ( <str> <str> . format ( param_in , self . params ) )  surf = sum ( np . multiply . outer ( p , ax ) for p , ax in zip ( param , self . axes ) ) if squeeze_out :              surf = surf . squeeze ( )  return surf  def surface_deriv ( self , param ) :          squeeze_out = ( np . broadcast ( * param ) . shape == ( ) ) param_in = param param = tuple ( np . array ( p , dtype = float , copy = False , ndmin = 1 ) for p in param ) if self . check_bounds and not is_inside_bounds ( param , self . params ) :              raise ValueError ( <str> <str> . format ( param_in , self . params ) )  if squeeze_out :              return self . axes  else :              return np . broadcast_to ( self . axes , np . broadcast ( * param ) . shape + self . axes . shape )   def __repr__ ( self ) :          posargs = [ self . partition ] optargs = [ ( <str> , tuple ( array_str ( ax ) for ax in self . axes ) , None ) ] inner_str = signature_string ( posargs , optargs , sep = <str> ) return <str> . format ( self . __class__ . __name__ , indent ( inner_str ) )  def __str__ ( self ) :          return repr ( self )   class CircularDetector ( Detector ) :      def __init__ ( self , partition , axis , radius , check_bounds = True ) :          super ( CircularDetector , self ) . __init__ ( partition , 2 , check_bounds ) if self . ndim != 1 :              raise ValueError ( <str> <str> . format ( self . ndim ) )  if np . linalg . norm ( axis ) == 0 :              raise ValueError ( <str> )  self . __axis = np . asarray ( axis ) / np . linalg . norm ( axis ) self . __radius = float ( radius ) if self . __radius <= 0 :              raise ValueError ( <str> )  sin = self . __axis [ 0 ] cos = - self . __axis [ 1 ] self . __rotation_matrix = np . array ( [ [ cos , - sin ] , [ sin , cos ] ] ) self . __translation = ( - self . __radius * np . matmul ( self . __rotation_matrix , ( 1 , 0 ) ) )  @ property def axis ( self ) :          return self . __axis  @ property def radius ( self ) :          return self . __radius  @ property def rotation_matrix ( self ) :          return self . __rotation_matrix  @ property def translation ( self ) :          return self . __translation  def surface ( self , param ) :          squeeze_out = ( np . shape ( param ) == ( ) ) param = np . array ( param , dtype = float , copy = False , ndmin = 1 ) if self . check_bounds and not is_inside_bounds ( param , self . params ) :              raise ValueError ( <str> <str> . format ( param , self . params ) )  surf = np . empty ( param . shape + ( 2 , ) ) surf [ ... , 0 ] = np . cos ( param ) surf [ ... , 1 ] = - np . sin ( param ) surf *= self . radius surf = np . matmul ( surf , np . transpose ( self . rotation_matrix ) ) surf += self . translation if squeeze_out :              surf = surf . squeeze ( )  return surf  def surface_deriv ( self , param ) :          squeeze_out = ( np . shape ( param ) == ( ) ) param = np . array ( param , dtype = float , copy = False , ndmin = 1 ) if self . check_bounds and not is_inside_bounds ( param , self . params ) :              raise ValueError ( <str> <str> . format ( param , self . params ) )  deriv = np . empty ( param . shape + ( 2 , ) ) deriv [ ... , 0 ] = - np . sin ( param ) deriv [ ... , 1 ] = - np . cos ( param ) deriv *= self . radius deriv = np . matmul ( deriv , np . transpose ( self . rotation_matrix ) ) if squeeze_out :              deriv = deriv . squeeze ( )  return deriv  def surface_measure ( self , param ) :          scalar_out = ( np . shape ( param ) == ( ) ) param = np . array ( param , dtype = float , copy = False , ndmin = 1 ) if self . check_bounds and not is_inside_bounds ( param , self . params ) :              raise ValueError ( <str> <str> . format ( param , self . params ) )  if scalar_out :              return self . radius  else :              return self . radius * np . ones ( param . shape )   def __repr__ ( self ) :          posargs = [ self . partition ] optargs = [ ( <str> , array_str ( self . center ) , <str> ) ] inner_str = signature_string ( posargs , optargs , sep = <str> ) return <str> . format ( self . __class__ . __name__ , indent ( inner_str ) )  def __str__ ( self ) :          return repr ( self )   class CylindricalDetector ( Detector ) :      def __init__ ( self , partition , axes , radius , check_bounds = True ) :          super ( CylindricalDetector , self ) . __init__ ( partition , 3 , check_bounds ) if self . ndim != 2 :              raise ValueError ( <str> <str> . format ( self . ndim ) )  axes , axes_in = np . asarray ( axes , dtype = float ) , axes if axes . shape != ( 2 , 3 ) :              raise ValueError ( <str> <str> . format ( axes_in ) )  if np . linalg . norm ( np . cross ( * axes ) ) == 0 :              raise ValueError ( <str> <str> . format ( axes_in ) )  if np . linalg . norm ( np . dot ( * axes ) ) != 0 :              raise ValueError ( <str> <str> . format ( axes_in ) )  self . __axes = axes / np . linalg . norm ( axes , axis = 1 , keepdims = True ) self . __radius = float ( radius ) if self . __radius <= 0 :              raise ValueError ( <str> )  initial_axes = np . array ( [ [ 0 , - 1 , 0 ] , [ 0 , 0 , 1 ] ] ) r1 = rotation_matrix_from_to ( initial_axes [ 0 ] , axes [ 0 ] ) r2 = rotation_matrix_from_to ( np . matmul ( r1 , initial_axes [ 1 ] ) , axes [ 1 ] ) self . __rotation_matrix = np . matmul ( r2 , r1 ) self . __translation = ( - self . __radius * np . matmul ( self . __rotation_matrix , ( 1 , 0 , 0 ) ) )  @ property def axes ( self ) :          return self . __axes  @ property def radius ( self ) :          return self . __radius  @ property def rotation_matrix ( self ) :          return self . __rotation_matrix  @ property def translation ( self ) :          return self . __translation  def surface ( self , param ) :          squeeze_out = ( np . broadcast ( * param ) . shape == ( ) ) param_in = param param = tuple ( np . array ( p , dtype = float , copy = False , ndmin = 1 ) for p in param ) if self . check_bounds and not is_inside_bounds ( param , self . params ) :              raise ValueError ( <str> <str> . format ( param_in , self . params ) )  surf = np . empty ( param [ 0 ] . shape + ( 3 , ) ) surf [ ... , 0 ] = self . radius * np . cos ( param [ 0 ] ) surf [ ... , 1 ] = self . radius * ( - np . sin ( param [ 0 ] ) ) surf [ ... , 2 ] = param [ 1 ] surf = np . matmul ( surf , np . transpose ( self . rotation_matrix ) ) surf += self . translation if squeeze_out :              surf = surf . squeeze ( )  return surf  def surface_deriv ( self , param ) :          squeeze_out = ( np . broadcast ( * param ) . shape == ( ) ) param_in = param param = tuple ( np . array ( p , dtype = float , copy = False , ndmin = 1 ) for p in param ) if self . check_bounds and not is_inside_bounds ( param , self . params ) :              raise ValueError ( <str> <str> . format ( param_in , self . params ) )  deriv_phi = np . empty ( param [ 0 ] . shape + ( 3 , ) ) deriv_phi [ ... , 0 ] = - np . sin ( param [ 0 ] ) deriv_phi [ ... , 1 ] = - np . cos ( param [ 0 ] ) deriv_phi [ ... , 2 ] = 0 deriv_phi *= self . radius deriv_h = np . broadcast_to ( ( 0 , 0 , 1 ) , np . broadcast ( * param ) . shape + ( 3 , ) ) deriv = np . stack ( ( deriv_phi , deriv_h ) , axis = - 2 ) deriv = np . matmul ( deriv , np . transpose ( self . rotation_matrix ) ) if squeeze_out :              deriv = deriv . squeeze ( )  return deriv  def __repr__ ( self ) :          posargs = [ self . partition ] optargs = [ ( <str> , array_str ( self . center ) , <str> ) ] inner_str = signature_string ( posargs , optargs , sep = <str> ) return <str> . format ( self . __class__ . __name__ , indent ( inner_str ) )  def __str__ ( self ) :          return repr ( self )   class SphericalDetector ( Detector ) :      def __init__ ( self , partition , axes , radius , check_bounds = True ) :          super ( SphericalDetector , self ) . __init__ ( partition , 3 , check_bounds ) if self . ndim != 2 :              raise ValueError ( <str> <str> . format ( self . ndim ) )  axes , axes_in = np . asarray ( axes , dtype = float ) , axes if axes . shape != ( 2 , 3 ) :              raise ValueError ( <str> <str> . format ( axes_in ) )  if np . linalg . norm ( np . cross ( * axes ) ) == 0 :              raise ValueError ( <str> <str> . format ( axes_in ) )  if np . linalg . norm ( np . dot ( * axes ) ) != 0 :              raise ValueError ( <str> <str> . format ( axes_in ) )  self . __axes = axes / np . linalg . norm ( axes , axis = 1 , keepdims = True ) self . __radius = float ( radius ) if self . __radius <= 0 :              raise ValueError ( <str> )  initial_axes = np . array ( [ [ 0 , - 1 , 0 ] , [ 0 , 0 , 1 ] ] ) r1 = rotation_matrix_from_to ( initial_axes [ 0 ] , axes [ 0 ] ) r2 = rotation_matrix_from_to ( np . matmul ( r1 , initial_axes [ 1 ] ) , axes [ 1 ] ) self . __rotation_matrix = np . matmul ( r2 , r1 ) self . __translation = ( - self . __radius * np . matmul ( self . __rotation_matrix , ( 1 , 0 , 0 ) ) )  @ property def axes ( self ) :          return self . __axes  @ property def radius ( self ) :          return self . __radius  @ property def rotation_matrix ( self ) :          return self . __rotation_matrix  @ property def translation ( self ) :          return self . __translation  def surface ( self , param ) :          squeeze_out = ( np . broadcast ( * param ) . shape == ( ) ) param_in = param param = tuple ( np . array ( p , dtype = float , copy = False , ndmin = 1 ) for p in param ) if self . check_bounds and not is_inside_bounds ( param , self . params ) :              raise ValueError ( <str> <str> . format ( param_in , self . params ) )  surf = np . empty ( param [ 0 ] . shape + ( 3 , ) ) surf [ ... , 0 ] = np . cos ( param [ 0 ] ) * np . cos ( param [ 1 ] ) surf [ ... , 1 ] = - np . sin ( param [ 0 ] ) * np . cos ( param [ 1 ] ) surf [ ... , 2 ] = np . sin ( param [ 1 ] ) surf *= self . radius surf = np . matmul ( surf , np . transpose ( self . rotation_matrix ) ) surf += self . translation if squeeze_out :              surf = surf . squeeze ( )  return surf  def surface_deriv ( self , param ) :          squeeze_out = ( np . broadcast ( * param ) . shape == ( ) ) param_in = param param = tuple ( np . array ( p , dtype = float , copy = False , ndmin = 1 ) for p in param ) if self . check_bounds and not is_inside_bounds ( param , self . params ) :              raise ValueError ( <str> <str> . format ( param_in , self . params ) )  deriv_phi = np . empty ( param [ 0 ] . shape + ( 3 , ) ) deriv_phi [ ... , 0 ] = - np . sin ( param [ 0 ] ) * np . cos ( param [ 1 ] ) deriv_phi [ ... , 1 ] = - np . cos ( param [ 0 ] ) * np . cos ( param [ 1 ] ) deriv_phi [ ... , 2 ] = 0 deriv_phi *= self . radius deriv_theta = np . empty ( param [ 0 ] . shape + ( 3 , ) ) deriv_theta [ ... , 0 ] = - np . cos ( param [ 0 ] ) * np . sin ( param [ 1 ] ) deriv_theta [ ... , 1 ] = np . sin ( param [ 0 ] ) * np . sin ( param [ 1 ] ) deriv_theta [ ... , 2 ] = np . cos ( param [ 1 ] ) deriv_theta *= self . radius deriv = np . stack ( ( deriv_phi , deriv_theta ) , axis = - 2 ) deriv = np . matmul ( deriv , np . transpose ( self . rotation_matrix ) ) if squeeze_out :              deriv = deriv . squeeze ( )  return deriv  def __repr__ ( self ) :          posargs = [ self . partition ] optargs = [ ( <str> , array_str ( self . center ) , <str> ) ] inner_str = signature_string ( posargs , optargs , sep = <str> ) return <str> . format ( self . __class__ . __name__ , indent ( inner_str ) )  def __str__ ( self ) :          return repr ( self )   if __name__ == <str> :      from odl . util . testutils import run_doctests run_doctests ( )   