from __future__ import print_function , division , absolute_import from builtins import object import inspect from numbers import Number , Integral import sys from odl . set import LinearSpace , Set , Field from odl . set . space import LinearSpaceElement from odl . util import cache_arguments __all__ = ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) def _default_call_out_of_place ( op , x , ** kwargs ) :      out = op . range . element ( ) result = op . _call_in_place ( x , out , ** kwargs ) if result is not None and result is not out :          raise ValueError ( <str> <str> <str> <str> )  return out  def _default_call_in_place ( op , x , out , ** kwargs ) :      out . assign ( op . range . element ( op . _call_out_of_place ( x , ** kwargs ) ) )  def _function_signature ( func ) :      if sys . version_info . major > 2 :          return func . __name__ + str ( inspect . signature ( func ) )  spec = inspect . getargspec ( func ) posargs = spec . args defaults = spec . defaults if spec . defaults is not None else [ ] varargs = spec . varargs kwargs = spec . keywords deflen = 0 if defaults is None else len ( defaults ) nodeflen = 0 if posargs is None else len ( posargs ) - deflen args = [ <str> . format ( arg ) for arg in posargs [ : nodeflen ] ] args . extend ( <str> . format ( arg , dval ) for arg , dval in zip ( posargs [ nodeflen : ] , defaults ) ) if varargs :          args . append ( <str> . format ( varargs ) )  if kwargs :          args . append ( <str> . format ( kwargs ) )  argstr = <str> . join ( args ) return <str> . format ( func . __name__ , argstr )  @ cache_arguments def _dispatch_call_args ( cls = None , bound_call = None , unbound_call = None , attr = <str> ) :      py3 = ( sys . version_info . major > 2 ) specs = [ <str> , <str> , <str> ] if py3 :          specs += [ <str> ]  spec_msg = <str> spec_msg += <str> . join ( specs ) spec_msg += <str> if sum ( arg is not None for arg in ( cls , bound_call , unbound_call ) ) != 1 :          raise ValueError ( <str> )  if cls is not None :          for parent in cls . mro ( ) :              call = parent . __dict__ . get ( attr , None ) if call is not None :                  break   if isinstance ( call , staticmethod ) :              raise TypeError ( <str> <str> . format ( cls . __name__ , attr ) + spec_msg )  elif isinstance ( call , classmethod ) :              raise TypeError ( <str> <str> . format ( cls . __name__ , attr ) + spec_msg )   elif bound_call is not None :          call = bound_call if not inspect . ismethod ( call ) :              raise TypeError ( <str> . format ( call ) )   else :          call = unbound_call  if py3 :          spec = inspect . getfullargspec ( call ) kw_only = spec . kwonlyargs kw_only_defaults = spec . kwonlydefaults  else :          spec = inspect . getargspec ( call ) kw_only = ( ) kw_only_defaults = { }  signature = _function_signature ( call ) pos_args = spec . args if unbound_call is not None :          pos_args . insert ( 0 , <str> )  pos_defaults = spec . defaults varargs = spec . varargs if varargs is not None :          raise ValueError ( <str> <str> . format ( signature ) + spec_msg )  if len ( pos_args ) not in ( 2 , 3 ) :          raise ValueError ( <str> . format ( signature ) + spec_msg )  true_pos_args = pos_args [ 1 : ] if len ( true_pos_args ) == 1 :          if <str> in true_pos_args :              raise ValueError ( <str> <str> <str> . format ( signature ) + spec_msg )  else :              if <str> not in kw_only :                  has_out = out_optional = False  elif kw_only_defaults [ <str> ] is not None :                  raise ValueError ( <str> <str> <str> . format ( signature , kw_only_defaults [ <str> ] ) + spec_msg )  else :                  has_out = True out_optional = True    elif len ( true_pos_args ) == 2 :          if true_pos_args [ 0 ] == <str> :              py3_txt = <str> if py3 else <str> raise ValueError ( <str> <str> . format ( signature ) + py3_txt + spec_msg )  elif true_pos_args [ 1 ] != <str> :              raise ValueError ( <str> <str> <str> . format ( signature , true_pos_args [ 1 ] ) + spec_msg )  else :              has_out = True out_optional = bool ( pos_defaults ) if pos_defaults and pos_defaults [ - 1 ] is not None :                  raise ValueError ( <str> <str> <str> . format ( signature , pos_defaults [ - 1 ] ) + spec_msg )    else :          raise ValueError ( <str> <str> . format ( signature ) + spec_msg )  return has_out , out_optional , spec  class Operator ( object ) :      <str> def __new__ ( cls , * args , ** kwargs ) :          call_has_out , call_out_optional , _ = _dispatch_call_args ( cls ) cls . _call_has_out = call_has_out cls . _call_out_optional = call_out_optional if not call_has_out :              cls . _call_in_place = _default_call_in_place cls . _call_out_of_place = cls . _call  elif call_out_optional :              cls . _call_in_place = cls . _call_out_of_place = cls . _call  else :              cls . _call_in_place = cls . _call cls . _call_out_of_place = _default_call_out_of_place  return object . __new__ ( cls )  def __init__ ( self , domain , range , linear = False ) :          if not isinstance ( domain , Set ) :              raise TypeError ( <str> <str> . format ( domain ) )  if not isinstance ( range , Set ) :              raise TypeError ( <str> <str> . format ( range ) )  self . __domain = domain self . __range = range self . __is_linear = bool ( linear ) self . __is_functional = isinstance ( range , Field ) if ( self . is_functional and self . _call_has_out and not self . _call_out_optional ) :              raise ValueError ( <str> <str> )  if self . is_linear :              if not isinstance ( domain , ( LinearSpace , Field ) ) :                  raise TypeError ( <str> <str> . format ( domain ) )  if not isinstance ( range , ( LinearSpace , Field ) ) :                  raise TypeError ( <str> <str> . format ( range ) )    def _call ( self , x , out = None , ** kwargs ) :          raise NotImplementedError ( <str> <str> <str> <str> . format ( self ) )  @ property def domain ( self ) :          return self . __domain  @ property def range ( self ) :          return self . __range  @ property def is_linear ( self ) :          return self . __is_linear  @ property def is_functional ( self ) :          return self . __is_functional  @ property def adjoint ( self ) :          raise OpNotImplementedError ( <str> <str> <str> . format ( self ) )  def derivative ( self , point ) :          if self . is_linear :              return self  else :              raise OpNotImplementedError ( <str> <str> <str> . format ( self ) )   @ property def inverse ( self ) :          raise OpNotImplementedError ( <str> <str> . format ( self ) )  def __call__ ( self , x , out = None , ** kwargs ) :          if x not in self . domain :              try :                  x = self . domain . element ( x )  except ( TypeError , ValueError ) :                  raise OpDomainError ( <str> <str> . format ( x , self . domain ) )   if out is not None :              if out not in self . range :                  raise OpRangeError ( <str> <str> <str> . format ( out , self . range , self ) )  if self . is_functional :                  raise TypeError ( <str> <str> )  result = self . _call_in_place ( x , out = out , ** kwargs ) if result is not None and result is not out :                  raise ValueError ( <str> <str> <str> <str> )   else :              out = self . _call_out_of_place ( x , ** kwargs ) if out not in self . range :                  try :                      out = self . range . element ( out )  except ( TypeError , ValueError ) :                      raise OpRangeError ( <str> <str> . format ( out , self . range ) )    return out  def norm ( self , estimate = False , ** kwargs ) :          if not estimate :              raise NotImplementedError ( <str> <str> <str> )  else :              norm = getattr ( self , <str> , None ) if norm is not None :                  return norm  else :                  from odl . operator . oputils import power_method_opnorm self . __norm = power_method_opnorm ( self , ** kwargs ) return self . __norm    def __add__ ( self , other ) :          if other in self . range :              return OperatorVectorSum ( self , other )  elif other in self . range . field :              constant_vector = other * self . range . one ( ) return OperatorVectorSum ( self , constant_vector )  elif isinstance ( other , Operator ) :              return OperatorSum ( self , other )  else :              return NotImplemented   def __radd__ ( self , other ) :          return self + other  def __sub__ ( self , other ) :          return self + ( - 1 ) * other  def __rsub__ ( self , other ) :          return ( - 1 ) * self + other  def __mul__ ( self , other ) :          if isinstance ( other , Operator ) :              return OperatorComp ( self , other )  elif isinstance ( other , Number ) :              if self . is_linear :                  return other * self  else :                  return OperatorRightScalarMult ( self , other )   elif isinstance ( other , LinearSpaceElement ) and other in self . domain :              return OperatorRightVectorMult ( self , other . copy ( ) )  else :              return NotImplemented   def __matmul__ ( self , other ) :          return self . __mul__ ( other )  def __rmul__ ( self , other ) :          if isinstance ( other , Operator ) :              return OperatorComp ( other , self )  elif isinstance ( other , Number ) :              return OperatorLeftScalarMult ( self , other )  elif other in self . range :              return OperatorLeftVectorMult ( self , other . copy ( ) )  elif ( isinstance ( other , LinearSpaceElement ) and other . space . field == self . range ) :              return FunctionalLeftVectorMult ( self , other . copy ( ) )  else :              return NotImplemented   def __rmatmul__ ( self , other ) :          return self . __rmul__ ( other )  def __pow__ ( self , n ) :          if isinstance ( n , Integral ) and n > 0 :              op = self while n > 1 :                  op = OperatorComp ( self , op ) n -= 1  return op  else :              return NotImplemented   def __truediv__ ( self , other ) :          if isinstance ( other , Number ) :              return self * ( 1.0 / other )  else :              return NotImplemented   __div__ = __truediv__ def __neg__ ( self ) :          return - 1 * self  def __pos__ ( self ) :          return self  def __repr__ ( self ) :          return <str> . format ( self . __class__ . __name__ , self . domain , self . range )  def __str__ ( self ) :          return self . __class__ . __name__  __array_priority__ = 2000000.0  class OperatorSum ( Operator ) :      def __init__ ( self , left , right , tmp_ran = None , tmp_dom = None ) :          if left . range != right . range :              raise OpTypeError ( <str> <str> . format ( left . range , right . range ) )  if not isinstance ( left . range , ( LinearSpace , Field ) ) :              raise OpTypeError ( <str> <str> . format ( left . range ) )  if left . domain != right . domain :              raise OpTypeError ( <str> <str> . format ( left . domain , right . domain ) )  if tmp_ran is not None and tmp_ran not in left . range :              raise OpRangeError ( <str> <str> . format ( tmp_ran , left . range ) )  if tmp_dom is not None and tmp_dom not in left . domain :              raise OpDomainError ( <str> <str> <str> . format ( tmp_dom , left . domain ) )  super ( OperatorSum , self ) . __init__ ( left . domain , left . range , linear = left . is_linear and right . is_linear ) self . __left = left self . __right = right self . __tmp_ran = tmp_ran self . __tmp_dom = tmp_dom  @ property def left ( self ) :          return self . __left  @ property def right ( self ) :          return self . __right  def _call ( self , x , out = None ) :          if out is None :              return self . left ( x ) + self . right ( x )  else :              tmp = ( self . __tmp_ran if self . __tmp_ran is not None else self . range . element ( ) ) self . left ( x , out = tmp ) self . right ( x , out = out ) out += tmp   def derivative ( self , x ) :          if self . is_linear :              return self  else :              return OperatorSum ( self . left . derivative ( x ) , self . right . derivative ( x ) , self . __tmp_dom , self . __tmp_ran )   @ property def adjoint ( self ) :          if not self . is_linear :              raise OpNotImplementedError ( <str> )  return OperatorSum ( self . left . adjoint , self . right . adjoint , self . __tmp_dom , self . __tmp_ran )  def __repr__ ( self ) :          return <str> . format ( self . __class__ . __name__ , self . left , self . right )  def __str__ ( self ) :          return <str> . format ( self . left , self . right )   class OperatorVectorSum ( Operator ) :      def __init__ ( self , operator , vector ) :          if not isinstance ( operator , Operator ) :              raise TypeError ( <str> <str> . format ( operator ) )  if not isinstance ( operator . range , LinearSpace ) :              raise TypeError ( <str> <str> . format ( operator . range ) )  super ( OperatorVectorSum , self ) . __init__ ( operator . domain , operator . range ) self . __operator = operator self . __vector = operator . range . element ( vector )  @ property def operator ( self ) :          return self . __operator  @ property def vector ( self ) :          return self . __vector  def _call ( self , x , out = None ) :          if out is None :              out = self . operator ( x )  else :              self . operator ( x , out = out )  out += self . vector return out  def derivative ( self , point ) :          return self . operator . derivative ( point )  def __repr__ ( self ) :          return <str> . format ( self . __class__ . __name__ , self . operator , self . vector )  def __str__ ( self ) :          return <str> . format ( self . left , self . right )   class OperatorComp ( Operator ) :      def __init__ ( self , left , right , tmp = None ) :          if right . range != left . domain :              raise OpTypeError ( <str> <str> <str> <str> . format ( right . range , right , left . domain , left ) )  if tmp is not None and tmp not in left . domain :              raise OpDomainError ( <str> <str> <str> . format ( tmp , left . domain ) )  super ( OperatorComp , self ) . __init__ ( right . domain , left . range , linear = left . is_linear and right . is_linear ) self . __left = left self . __right = right self . __tmp = tmp  @ property def left ( self ) :          return self . __left  @ property def right ( self ) :          return self . __right  def _call ( self , x , out = None ) :          if out is None :              return self . left ( self . right ( x ) )  else :              tmp = ( self . __tmp if self . __tmp is not None else self . right . range . element ( ) ) self . right ( x , out = tmp ) return self . left ( tmp , out = out )   @ property def inverse ( self ) :          return OperatorComp ( self . right . inverse , self . left . inverse , self . __tmp )  def derivative ( self , x ) :          if self . is_linear :              return self  else :              if self . left . is_linear :                  left_deriv = self . left  else :                  left_deriv = self . left . derivative ( self . right ( x ) )  right_deriv = self . right . derivative ( x ) return OperatorComp ( left_deriv , right_deriv , self . __tmp )   @ property def adjoint ( self ) :          if not self . is_linear :              raise OpNotImplementedError ( <str> )  return OperatorComp ( self . right . adjoint , self . left . adjoint , self . __tmp )  def __repr__ ( self ) :          return <str> . format ( self . __class__ . __name__ , self . left , self . right )  def __str__ ( self ) :          return <str> . format ( self . left , self . right )   class OperatorPointwiseProduct ( Operator ) :      def __init__ ( self , left , right ) :          if left . range != right . range :              raise OpTypeError ( <str> <str> . format ( left . range , right . range ) )  if not isinstance ( left . range , ( LinearSpace , Field ) ) :              raise OpTypeError ( <str> <str> . format ( left . range ) )  if left . domain != right . domain :              raise OpTypeError ( <str> <str> . format ( left . domain , right . domain ) )  super ( OperatorPointwiseProduct , self ) . __init__ ( left . domain , left . range , linear = False ) self . __left = left self . __right = right  @ property def left ( self ) :          return self . __left  @ property def right ( self ) :          return self . __right  def _call ( self , x , out = None ) :          if out is None :              return self . left ( x ) * self . right ( x )  else :              tmp = self . right . range . element ( ) self . left ( x , out = tmp ) self . right ( x , out = out ) out *= tmp   def derivative ( self , x ) :          if self . is_linear :              return self  else :              left = self . right ( x ) * self . left . derivative ( x ) right = self . left ( x ) * self . right . derivative ( x ) return left + right   def __repr__ ( self ) :          return <str> . format ( self . __class__ . __name__ , self . left , self . right )  def __str__ ( self ) :          return repr ( self )   class OperatorLeftScalarMult ( Operator ) :      def __init__ ( self , operator , scalar ) :          if not isinstance ( operator . range , ( LinearSpace , Field ) ) :              raise OpTypeError ( <str> <str> . format ( operator . range ) )  if scalar not in operator . range . field :              raise TypeError ( <str> <str> <str> . format ( scalar , operator . range . field , operator . range ) )  if isinstance ( operator , OperatorLeftScalarMult ) :              scalar = scalar * operator . scalar operator = operator . operator  super ( OperatorLeftScalarMult , self ) . __init__ ( operator . domain , operator . range , linear = operator . is_linear ) self . __operator = operator self . __scalar = scalar  @ property def operator ( self ) :          return self . __operator  @ property def scalar ( self ) :          return self . __scalar  def _call ( self , x , out = None ) :          if out is None :              return self . scalar * self . operator ( x )  else :              self . operator ( x , out = out ) out *= self . scalar   @ property def inverse ( self ) :          if self . scalar == 0.0 :              raise ZeroDivisionError ( <str> . format ( self ) )  return self . operator . inverse * ( 1.0 / self . scalar )  def derivative ( self , x ) :          if self . is_linear :              return self  else :              return self . scalar * self . operator . derivative ( x )   @ property def adjoint ( self ) :          if not self . is_linear :              raise OpNotImplementedError ( <str> )  return self . scalar . conjugate ( ) * self . operator . adjoint  def __repr__ ( self ) :          return <str> . format ( self . __class__ . __name__ , self . operator , self . scalar )  def __str__ ( self ) :          return <str> . format ( self . scalar , self . operator )   class OperatorRightScalarMult ( Operator ) :      def __init__ ( self , operator , scalar , tmp = None ) :          if not isinstance ( operator . domain , ( LinearSpace , Field ) ) :              raise OpTypeError ( <str> <str> . format ( operator . domain ) )  if scalar not in operator . domain . field :              raise TypeError ( <str> <str> <str> . format ( scalar , operator . domain . field , operator . domain ) )  if tmp is not None and tmp not in operator . domain :              raise OpDomainError ( <str> <str> <str> . format ( tmp , operator . domain ) )  if isinstance ( operator , OperatorRightScalarMult ) :              scalar = scalar * operator . scalar operator = operator . operator  super ( OperatorRightScalarMult , self ) . __init__ ( operator . domain , operator . range , operator . is_linear ) self . __operator = operator self . __scalar = scalar self . __tmp = tmp  @ property def operator ( self ) :          return self . __operator  @ property def scalar ( self ) :          return self . __scalar  def _call ( self , x , out = None ) :          if out is None :              return self . operator ( self . scalar * x )  else :              if self . __tmp is not None :                  tmp = self . __tmp  else :                  tmp = self . domain . element ( )  tmp . lincomb ( self . scalar , x ) self . operator ( tmp , out = out )   def __mul__ ( self , other ) :          if other in self . range . field :              return OperatorRightScalarMult ( self . operator , self . scalar * other , self . __tmp )  else :              return super ( OperatorRightScalarMult , self ) . __rmul__ ( other )   @ property def inverse ( self ) :          if self . scalar == 0.0 :              raise ZeroDivisionError ( <str> . format ( self ) )  return ( 1.0 / self . scalar ) * self . operator . inverse  def derivative ( self , x ) :          return self . scalar * self . operator . derivative ( self . scalar * x )  @ property def adjoint ( self ) :          if not self . is_linear :              raise OpNotImplementedError ( <str> )  return self . operator . adjoint * self . scalar . conjugate ( )  def __repr__ ( self ) :          return <str> . format ( self . __class__ . __name__ , self . operator , self . scalar )  def __str__ ( self ) :          return <str> . format ( self . operator , self . scalar )   class FunctionalLeftVectorMult ( Operator ) :      def __init__ ( self , functional , vector ) :          if not isinstance ( vector , LinearSpaceElement ) :              raise TypeError ( <str> <str> . format ( vector ) )  if functional . range != vector . space . field :              raise OpTypeError ( <str> <str> . format ( functional . range , vector . space . field ) )  super ( FunctionalLeftVectorMult , self ) . __init__ ( functional . domain , vector . space , linear = functional . is_linear ) self . __functional = functional self . __vector = vector  @ property def functional ( self ) :          return self . __functional  @ property def vector ( self ) :          return self . __vector  def _call ( self , x , out = None ) :          if out is None :              return self . vector * self . functional ( x )  else :              scalar = self . functional ( x ) out . lincomb ( scalar , self . vector )   def derivative ( self , x ) :          if self . is_linear :              return self  else :              return FunctionalLeftVectorMult ( self . functional . derivative ( x ) , self . vector )   @ property def adjoint ( self ) :          if not self . is_linear :              raise OpNotImplementedError ( <str> )  return OperatorComp ( self . functional . adjoint , self . vector . T )  def __repr__ ( self ) :          return <str> . format ( self . __class__ . __name__ , self . functional , self . vector )  def __str__ ( self ) :          return <str> . format ( self . vector , self . functional )   class OperatorLeftVectorMult ( Operator ) :      def __init__ ( self , operator , vector ) :          if vector not in operator . range :              raise OpRangeError ( <str> <str> . format ( vector , operator . range ) )  super ( OperatorLeftVectorMult , self ) . __init__ ( operator . domain , operator . range , linear = operator . is_linear ) self . __operator = operator self . __vector = vector  @ property def operator ( self ) :          return self . __operator  @ property def vector ( self ) :          return self . __vector  def _call ( self , x , out = None ) :          if out is None :              return self . operator ( x ) * self . vector  else :              self . operator ( x , out = out ) out *= self . vector   @ property def inverse ( self ) :          return self . operator . inverse * ( 1.0 / self . vector )  def derivative ( self , x ) :          if self . is_linear :              return self  else :              return self . vector * self . operator . derivative ( x )   @ property def adjoint ( self ) :          if not self . is_linear :              raise OpNotImplementedError ( <str> )  if self . vector . space . is_real :              return self . operator . adjoint * self . vector  else :              return self . operator . adjoint * self . vector . conj ( )   def __repr__ ( self ) :          return <str> . format ( self . __class__ . __name__ , self . operator , self . vector )  def __str__ ( self ) :          return <str> . format ( self . vector , self . operator )   class OperatorRightVectorMult ( Operator ) :      def __init__ ( self , operator , vector ) :          if not isinstance ( operator , Operator ) :              raise TypeError ( <str> <str> . format ( operator ) )  if vector not in operator . domain :              raise OpDomainError ( <str> <str> . format ( vector . space , operator . domain ) )  super ( OperatorRightVectorMult , self ) . __init__ ( operator . domain , operator . range , linear = operator . is_linear ) self . __operator = operator self . __vector = vector  @ property def operator ( self ) :          return self . __operator  @ property def vector ( self ) :          return self . __vector  def _call ( self , x , out = None ) :          if out is None :              return self . operator ( x * self . vector )  else :              tmp = self . domain . element ( ) x . multiply ( self . vector , out = tmp ) self . operator ( tmp , out = out )   @ property def inverse ( self ) :          return ( 1.0 / self . vector ) * self . operator . inverse  def derivative ( self , x ) :          if self . is_linear :              return self  else :              return self . operator . derivative ( self . vector * x ) * self . vector   @ property def adjoint ( self ) :          if not self . is_linear :              raise OpNotImplementedError ( <str> )  if self . vector . space . is_real :              return self . vector * self . operator . adjoint  else :              return self . vector . conj ( ) * self . operator . adjoint   def __repr__ ( self ) :          return <str> . format ( self . __class__ . __name__ , self . operator , self . vector )  def __str__ ( self ) :          return <str> . format ( self . operator , self . vector )   class OpTypeError ( TypeError ) :       class OpDomainError ( OpTypeError ) :       class OpRangeError ( OpTypeError ) :       class OpNotImplementedError ( NotImplementedError ) :       if __name__ == <str> :      from odl . util . testutils import run_doctests run_doctests ( )   