import numpy as np import odl U = odl . uniform_discr ( min_pt = [ - 20 , - 20 ] , max_pt = [ 20 , 20 ] , shape = [ 100 , 100 ] , dtype = <str> ) geometry = odl . tomo . parallel_beam_geometry ( U ) A = odl . tomo . RayTransform ( U , geometry ) phantom = odl . phantom . tgv_phantom ( U ) phantom . show ( title = <str> ) data = A ( phantom ) data += odl . phantom . white_noise ( A . range ) * np . mean ( data ) * 0.1 data . show ( title = <str> ) G = odl . Gradient ( U , method = <str> , pad_mode = <str> ) V = G . range Dx = odl . PartialDerivative ( U , 0 , method = <str> , pad_mode = <str> ) Dy = odl . PartialDerivative ( U , 1 , method = <str> , pad_mode = <str> ) E = odl . operator . ProductSpaceOperator ( [ [ Dx , 0 ] , [ 0 , Dy ] , [ 0.5 * Dy , 0.5 * Dx ] , [ 0.5 * Dy , 0.5 * Dx ] ] ) W = E . range domain = odl . ProductSpace ( U , V ) op = odl . BroadcastOperator ( A * odl . ComponentProjection ( domain , 0 ) , odl . ReductionOperator ( G , odl . ScalingOperator ( V , - 1 ) ) , E * odl . ComponentProjection ( domain , 1 ) ) f = odl . solvers . ZeroFunctional ( domain ) l2_norm = odl . solvers . L2NormSquared ( A . range ) . translated ( data ) alpha = 4e-1 beta = 1 l1_norm_1 = alpha * odl . solvers . L1Norm ( V ) l1_norm_2 = alpha * beta * odl . solvers . L1Norm ( W ) g = odl . solvers . SeparableSum ( l2_norm , l1_norm_1 , l1_norm_2 ) op_norm = 1.1 * odl . power_method_opnorm ( op ) niter = 300 tau = 1.0 / op_norm sigma = 1.0 / op_norm callback = ( odl . solvers . CallbackPrintIteration ( ) & odl . solvers . CallbackShow ( step = 10 , indices = 0 ) ) x = op . domain . zero ( ) odl . solvers . pdhg ( x , f , g , op , niter = niter , tau = tau , sigma = sigma , callback = callback ) x [ 0 ] . show ( title = <str> ) x [ 1 ] . show ( title = <str> , force_show = True )  