from __future__ import print_function , division , absolute_import import numpy as np from odl . solvers . util import ConstantLineSearch from odl . solvers . iterative . iterative import conjugate_gradient __all__ = ( <str> , <str> , <str> ) def _bfgs_direction ( s , y , x , hessinv_estimate = None ) :      assert len ( s ) == len ( y ) r = x . copy ( ) alphas = np . zeros ( len ( s ) ) rhos = np . zeros ( len ( s ) ) for i in reversed ( range ( len ( s ) ) ) :          rhos [ i ] = 1.0 / y [ i ] . inner ( s [ i ] ) alphas [ i ] = rhos [ i ] * ( s [ i ] . inner ( r ) ) r . lincomb ( 1 , r , - alphas [ i ] , y [ i ] )  if hessinv_estimate is not None :          r = hessinv_estimate ( r )  for i in range ( len ( s ) ) :          beta = rhos [ i ] * ( y [ i ] . inner ( r ) ) r . lincomb ( 1 , r , alphas [ i ] - beta , s [ i ] )  return r  def _broydens_direction ( s , y , x , hessinv_estimate = None , impl = <str> ) :      assert len ( s ) == len ( y ) if hessinv_estimate is not None :          r = hessinv_estimate ( x )  else :          r = x . copy ( )  for i in range ( len ( s ) ) :          if impl == <str> :              r . lincomb ( 1 , r , y [ i ] . inner ( r ) , s [ i ] )  elif impl == <str> :              r . lincomb ( 1 , r , y [ i ] . inner ( x ) , s [ i ] )  else :              raise RuntimeError ( <str> )   return r  def newtons_method ( f , x , line_search = 1.0 , maxiter = 1000 , tol = 1e-16 , cg_iter = None , callback = None ) :      grad = f . gradient if x not in grad . domain :          raise TypeError ( <str> <str> . format ( x , grad . domain ) )  if not callable ( line_search ) :          line_search = ConstantLineSearch ( line_search )  if cg_iter is None :          cg_iter = grad . domain . size  for _ in range ( maxiter ) :          search_direction = x . space . zero ( ) hessian = grad . derivative ( x ) deriv_in_point = grad ( x ) try :              hessian_inverse = hessian . inverse  except NotImplementedError :              conjugate_gradient ( hessian , search_direction , - deriv_in_point , cg_iter )  else :              hessian_inverse ( - deriv_in_point , out = search_direction )  dir_deriv = search_direction . inner ( deriv_in_point ) if np . abs ( dir_deriv ) <= tol :              return  step_length = line_search ( x , search_direction , dir_deriv ) x += step_length * search_direction if callback is not None :              callback ( x )    def bfgs_method ( f , x , line_search = 1.0 , maxiter = 1000 , tol = 1e-15 , num_store = None , hessinv_estimate = None , callback = None ) :      grad = f . gradient if x not in grad . domain :          raise TypeError ( <str> <str> . format ( x , grad . domain ) )  if not callable ( line_search ) :          line_search = ConstantLineSearch ( line_search )  ys = [ ] ss = [ ] grad_x = grad ( x ) for i in range ( maxiter ) :          search_dir = - _bfgs_direction ( ss , ys , grad_x , hessinv_estimate ) dir_deriv = search_dir . inner ( grad_x ) if np . abs ( dir_deriv ) == 0 :              return  step = line_search ( x , direction = search_dir , dir_derivative = dir_deriv ) x_update = search_dir x_update *= step x += x_update grad_x , grad_diff = grad ( x ) , grad_x grad_diff . lincomb ( - 1 , grad_diff , 1 , grad_x ) y_inner_s = grad_diff . inner ( x_update ) if np . abs ( y_inner_s ) < tol :              if grad_x . norm ( ) < tol :                  return  else :                  ys = [ ] ss = [ ] continue   ys . append ( grad_diff ) ss . append ( x_update ) if num_store is not None :              ss = ss [ - num_store : ] ys = ys [ - num_store : ]  if callback is not None :              callback ( x )    def broydens_method ( f , x , line_search = 1.0 , impl = <str> , maxiter = 1000 , tol = 1e-15 , hessinv_estimate = None , callback = None ) :      grad = f . gradient if x not in grad . domain :          raise TypeError ( <str> <str> . format ( x , grad . domain ) )  if not callable ( line_search ) :          line_search = ConstantLineSearch ( line_search )  ss = [ ] ys = [ ] grad_x = grad ( x ) for i in range ( maxiter ) :          search_dir = - _broydens_direction ( ss , ys , grad_x , hessinv_estimate , impl ) dir_deriv = search_dir . inner ( grad_x ) if np . abs ( dir_deriv ) == 0 :              return  step = line_search ( x , search_dir , dir_deriv ) x_update = step * search_dir x += x_update grad_x , grad_x_old = grad ( x ) , grad_x delta_grad = grad_x - grad_x_old v = _broydens_direction ( ss , ys , delta_grad , hessinv_estimate , impl ) if impl == <str> :              divisor = x_update . inner ( v ) if np . abs ( divisor ) < tol :                  if grad_x . norm ( ) < tol :                      return  else :                      ys = [ ] ss = [ ] continue   u = ( x_update - v ) / divisor ss . append ( u ) ys . append ( x_update )  elif impl == <str> :              divisor = delta_grad . inner ( delta_grad ) if np . abs ( divisor ) < tol :                  if grad_x . norm ( ) < tol :                      return  else :                      ys = [ ] ss = [ ] continue   u = ( x_update - v ) / divisor ss . append ( u ) ys . append ( delta_grad )  if callback is not None :              callback ( x )    if __name__ == <str> :      from odl . util . testutils import run_doctests run_doctests ( )   