from __future__ import division , print_function import os import odl . contrib . solvers . spdhg as spdhg import odl . contrib . datasets . images as images import matplotlib . pyplot as plt import matplotlib import numpy as np from scipy . ndimage . filters import gaussian_filter import odl import brewer2mpl folder_out = <str> filename = <str> nepoch = 100 niter_target = 2000 subfolder = <str> . format ( nepoch ) nvoxelx = 250 filename = <str> . format ( filename , nvoxelx , nvoxelx ) folder_main = <str> . format ( folder_out , filename ) if not os . path . exists ( folder_main ) :      os . makedirs ( folder_main )  folder_today = <str> . format ( folder_main , subfolder ) if not os . path . exists ( folder_today ) :      os . makedirs ( folder_today )  folder_npy = <str> . format ( folder_today ) if not os . path . exists ( folder_npy ) :      os . makedirs ( folder_npy )  X = odl . uniform_discr ( min_pt = [ - 1 , - 1 ] , max_pt = [ 1 , 1 ] , shape = [ nvoxelx , nvoxelx ] , dtype = <str> ) geometry = odl . tomo . parallel_beam_geometry ( X , num_angles = 200 , det_shape = 250 ) G = odl . BroadcastOperator ( * [ odl . tomo . RayTransform ( X , gi , impl = <str> ) for gi in geometry ] ) Y = G . range groundtruth = X . element ( images . brain_phantom ( shape = X . shape ) ) clim = [ 0 , 1 ] tol_norm = 1.05 file_data = <str> . format ( folder_main ) if not os . path . exists ( file_data ) :      sinogram = G ( groundtruth ) support = X . element ( groundtruth . ufuncs . greater ( 0 ) ) factors = - G ( 0.005 / X . cell_sides [ 0 ] * support ) factors . ufuncs . exp ( out = factors ) counts_observed = ( factors * sinogram ) . ufuncs . sum ( ) counts_desired = 3e+6 counts_background = 2e+6 factors *= counts_desired / counts_observed sinogram_support = sinogram . ufuncs . greater ( 0 ) smoothed_support = Y . element ( [ gaussian_filter ( sino_support , sigma = [ 1 , 2 / X . cell_sides [ 0 ] ] ) for sino_support in sinogram_support ] ) background = 10 * smoothed_support + 10 background *= counts_background / background . ufuncs . sum ( ) data = odl . phantom . poisson_noise ( factors * sinogram + background , seed = 1807 ) arr = np . empty ( 3 , dtype = object ) arr [ 0 ] = data arr [ 1 ] = factors arr [ 2 ] = background np . save ( file_data , arr ) spdhg . save_image ( groundtruth , <str> , folder_main , 1 , clim = clim ) fig2 = plt . figure ( 2 ) fig2 . clf ( ) i = 0 plt . plot ( ( sinogram [ i ] ) . asarray ( ) [ 0 ] , label = <str> ) plt . plot ( ( factors [ i ] * sinogram [ i ] ) . asarray ( ) [ 0 ] , label = <str> ) plt . plot ( data [ i ] . asarray ( ) [ 0 ] , label = <str> ) plt . plot ( background [ i ] . asarray ( ) [ 0 ] , label = <str> ) plt . legend ( ) fig2 . savefig ( <str> . format ( folder_main ) , bbox_inches = <str> )  else :      ( data , factors , background ) = np . load ( file_data )  f = odl . solvers . SeparableSum ( * [ spdhg . KullbackLeiblerSmooth ( Yi , yi , ri ) for Yi , yi , ri in zip ( Y , data , background ) ] ) g = spdhg . TotalVariationNonNegative ( X , alpha = 5e-2 , strong_convexity = 5e-1 ) g . prox_options [ <str> ] = 20 A = odl . BroadcastOperator ( * [ fi * Gi for fi , Gi in zip ( factors , G ) ] ) obj_fun = f * A + g rho = 0.99 mu_i = [ fi . convex_conj . strong_convexity for fi in f ] mu_f = np . min ( mu_i ) mu_g = g . strong_convexity file_target = <str> . format ( folder_main ) if not os . path . exists ( file_target ) :      file_normA = <str> . format ( folder_main , 1 ) if not os . path . exists ( file_normA ) :          normA = [ tol_norm * A . norm ( estimate = True ) ] np . save ( file_normA , normA )  else :          normA = np . load ( file_normA )  kappa = np . sqrt ( 1 + normA [ 0 ] ** 2 / ( mu_g * mu_f ) / rho ** 2 ) sigma = 1 / ( ( kappa - 1 ) * mu_f ) tau = 1 / ( ( kappa - 1 ) * mu_g ) theta = 1 - 2 / ( 1 + kappa ) x_opt , y_opt = X . zero ( ) , Y . zero ( ) callback = ( odl . solvers . CallbackPrintIteration ( step = 10 , end = <str> ) & odl . solvers . CallbackPrintTiming ( step = 10 , cumulative = True ) ) g . prox_options [ <str> ] = None odl . solvers . pdhg ( x_opt , f , g , A , tau , sigma , niter_target , y = y_opt , theta = theta , callback = callback ) subx_opt = - A . adjoint ( y_opt ) suby_opt = A ( x_opt ) obj_opt = obj_fun ( x_opt ) np . save ( file_target , ( x_opt , y_opt , subx_opt , suby_opt , obj_opt ) ) spdhg . save_image ( x_opt , <str> , folder_main , 1 , clim = clim ) spdhg . save_signal ( y_opt [ 0 ] , <str> , folder_main , 2 ) spdhg . save_image ( subx_opt , <str> , folder_main , 3 ) spdhg . save_signal ( suby_opt [ 0 ] , <str> , folder_main , 4 )  else :      ( x_opt , y_opt , subx_opt , suby_opt , obj_opt ) = np . load ( file_target )  dist_x = 1 / 2 * odl . solvers . L2NormSquared ( X ) . translated ( x_opt ) dist_y = 1 / 2 * odl . solvers . L2NormSquared ( Y ) . translated ( y_opt ) class CallbackStore ( odl . solvers . Callback ) :      def __init__ ( self , alg , iter_save , iter_plot ) :          self . iter_save = iter_save self . iter_plot = iter_plot self . iter = 0 self . alg = alg self . out = [ ]  def __call__ ( self , x , ** kwargs ) :          if self . iter in self . iter_save :              obj = obj_fun ( x [ 0 ] ) dx = dist_x ( x [ 0 ] ) dy = dist_y ( x [ 1 ] ) d = dx + dy self . out . append ( { <str> : obj , <str> : self . iter , <str> : d , <str> : dx , <str> : dy } )  if self . iter in self . iter_plot :              fname = <str> . format ( self . alg , self . iter ) spdhg . save_image ( x [ 0 ] , fname , folder_today , 1 , clim = clim )  self . iter += 1   nsub = { <str> : 1 , <str> : 10 , <str> : 50 , <str> : 10 , <str> : 50 } niter , iter_save , iter_plot = { } , { } , { } for alg in nsub . keys ( ) :      niter [ alg ] = nepoch * nsub [ alg ] iter_save [ alg ] = range ( 0 , niter [ alg ] + 1 , nsub [ alg ] ) iter_plot [ alg ] = list ( np . array ( [ 10 , 20 , 30 , 40 , 100 , 300 ] ) * nsub [ alg ] )  for alg in [ <str> , <str> , <str> , <str> , <str> ] :      print ( <str> + alg + <str> ) prob , sigma , tau , theta = [ None ] * 4 n = nsub [ alg ] ( sub2ind , ind2sub ) = spdhg . divide_1Darray_equally ( range ( len ( A ) ) , n ) np . random . seed ( 1807 ) if alg == <str> or alg [ 0 : 5 ] == <str> :          file_normA = <str> . format ( folder_main , n )  elif alg [ 0 : 7 ] == <str> :          file_normA = <str> . format ( folder_main , 1 )  if not os . path . exists ( file_normA ) :          A_subsets = [ odl . BroadcastOperator ( * [ A [ i ] for i in subset ] ) for subset in sub2ind ] normA = [ tol_norm * Ai . norm ( estimate = True ) for Ai in A_subsets ] np . save ( file_normA , normA )  else :          normA = np . load ( file_normA )  if alg == <str> :          kappa = np . sqrt ( 1 + normA [ 0 ] ** 2 / ( mu_g * mu_f ) / rho ** 2 ) prob_subset = [ 1 ] prob = [ 1 ] * Y . size sigma = [ 1 / ( ( kappa - 1 ) * mu_f ) ] * Y . size tau = 1 / ( ( kappa - 1 ) * mu_g ) theta = 1 - 2 / ( 1 + kappa )  elif alg . startswith ( <str> ) :          kappa = [ np . sqrt ( 1 + normAi ** 2 / ( mu_g * mui ) / rho ** 2 ) for normAi , mui in zip ( normA , mu_i ) ] kappa_max = max ( kappa ) prob_subset = [ 1 / n ] * n prob = [ 1 / n ] * Y . size sigma = [ 1 / ( ( kappa_max - 1 ) * mui ) for mui in mu_i ] tau = 1 / ( ( n * kappa_max + n - 2 ) * mu_g ) theta = 1 - 2 / ( n + n * kappa_max )  elif alg . startswith ( <str> ) :          prob_subset = [ 1 / n ] * n prob = [ 1 / n ] * Y . size sigma = [ rho / normA [ 0 ] ] * Y . size tau = rho / normA [ 0 ]  else :          assert False , <str>  def fun_select ( k ) :          return sub2ind [ int ( np . random . choice ( n , 1 , p = prob_subset ) ) ]  x , y = X . zero ( ) , Y . zero ( ) callback = ( odl . solvers . CallbackPrintIteration ( fmt = <str> , step = n , end = <str> ) & odl . solvers . CallbackPrintTiming ( fmt = <str> , step = n , end = <str> ) & odl . solvers . CallbackPrintTiming ( fmt = <str> , cumulative = True , step = n ) & CallbackStore ( alg , iter_save [ alg ] , iter_plot [ alg ] ) ) x , y = X . zero ( ) , Y . zero ( ) callback ( [ x , y ] ) g . prox_options [ <str> ] = None if alg . startswith ( <str> ) or alg . startswith ( <str> ) :          spdhg . spdhg ( x , f , g , A , tau , sigma , niter [ alg ] , prob = prob , y = y , fun_select = fun_select , theta = theta , callback = callback )  elif alg . startswith ( <str> ) :          spdhg . spdhg_pesquet ( x , f , g , A , tau , sigma , niter [ alg ] , y = y , fun_select = fun_select , callback = callback )  else :          assert False , <str>  out = callback . callbacks [ 1 ] . out np . save ( <str> . format ( folder_npy , alg ) , ( iter_save [ alg ] , niter [ alg ] , x , out , nsub [ alg ] , theta ) )  algs = [ <str> , <str> , <str> , <str> , <str> ] iter_save_v , niter_v , image_v , out_v , nsub_v , theta_v = { } , { } , { } , { } , { } , { } for a in algs :      ( iter_save_v [ a ] , niter_v [ a ] , image_v [ a ] , out_v [ a ] , nsub_v [ a ] , theta_v [ a ] ) = np . load ( <str> . format ( folder_npy , a ) )  epochs_save = { a : np . array ( iter_save_v [ a ] ) / np . float ( nsub_v [ a ] ) for a in algs } out_resorted = { } for a in algs :      print ( <str> + a ) out_resorted [ a ] = { } K = len ( iter_save_v [ a ] ) for meas in out_v [ a ] [ 0 ] . keys ( ) :          print ( <str> + meas ) out_resorted [ a ] [ meas ] = np . nan * np . ones ( K ) for k in range ( K ) :              out_resorted [ a ] [ meas ] [ k ] = out_v [ a ] [ k ] [ meas ]   meas = <str> print ( <str> + meas ) out_resorted [ a ] [ meas ] = np . nan * np . ones ( K ) for k in range ( K ) :          out_resorted [ a ] [ meas ] [ k ] = ( ( out_v [ a ] [ k ] [ <str> ] - obj_opt ) / ( out_v [ a ] [ 0 ] [ <str> ] - obj_opt ) )   for a in algs :      for meas in out_resorted [ a ] . keys ( ) :          for k in range ( K ) :              if out_resorted [ a ] [ meas ] [ k ] <= 0 :                  out_resorted [ a ] [ meas ] [ k ] = np . nan     fig = plt . figure ( ) for a in algs :      spdhg . save_image ( image_v [ a ] , a , folder_today , 1 , clim = clim )  markers = plt . Line2D . filled_markers all_plots = out_resorted [ algs [ 0 ] ] . keys ( ) logy_plot = all_plots for plotx in [ <str> , <str> ] :      for meas in all_plots :          print ( <str> + plotx + <str> + meas + <str> ) fig = plt . figure ( 1 ) plt . clf ( ) if plotx == <str> :              if meas in logy_plot :                  for a in algs :                      x = epochs_save [ a ] y = out_resorted [ a ] [ meas ] plt . semilogy ( x , y , linewidth = 3 , label = a )   else :                  for j , a in enumerate ( algs ) :                      x = epochs_save [ a ] y = out_resorted [ a ] [ meas ] plt . plot ( x , y , linewidth = 3 , marker = markers [ j ] , markersize = 7 , markevery = .1 , label = a )    elif plotx == <str> :              if meas in logy_plot :                  for a in algs :                      x = epochs_save [ a ] [ 1 : ] y = out_resorted [ a ] [ meas ] [ 1 : ] plt . loglog ( x , y , linewidth = 3 , label = a )   else :                  for j , a in enumerate ( algs ) :                      x = epochs_save [ a ] [ 1 : ] y = out_resorted [ a ] [ meas ] [ 1 : ] plt . semilogx ( x , y , linewidth = 3 , marker = markers [ j ] , markersize = 7 , markevery = .1 , label = a )    plt . title ( <str> . format ( meas ) ) h = plt . gca ( ) h . set_xlabel ( <str> ) plt . legend ( loc = <str> ) fig . savefig ( <str> . format ( folder_today , filename , plotx , meas ) , bbox_inches = <str> )   lwidth = 2 lwidth_help = 2 lstyle = <str> lstyle_help = <str> bmap = brewer2mpl . get_map ( <str> , <str> , 6 ) colors = bmap . mpl_colors colors . pop ( 1 ) matplotlib . rc ( <str> , usetex = True ) matplotlib . rcParams [ <str> ] = [ <str> ] fsize = 15 font = { <str> : <str> , <str> : fsize } matplotlib . rc ( <str> , ** font ) matplotlib . rc ( <str> , labelsize = fsize ) matplotlib . rc ( <str> , labelsize = fsize ) matplotlib . rc ( <str> , labelsize = fsize ) matplotlib . rc ( <str> , fontsize = fsize ) marker = ( <str> , <str> , <str> , <str> , <str> , <str> , <str> ) mevery = [ ( i / 30. , .15 ) for i in range ( 20 ) ] msize = 9 algs = [ <str> , <str> , <str> , <str> , <str> ] label = [ <str> , <str> , <str> , <str> , <str> ] fig = [ ] fig . append ( plt . figure ( 1 ) ) plt . clf ( ) xlim = [ 0 , 100 ] ylim = [ 1e-8 , 5e-1 ] meas = <str> for k , a in enumerate ( algs ) :      x = epochs_save [ a ] y = out_resorted [ a ] [ meas ] / out_resorted [ a ] [ meas ] [ 0 ] i = ( np . less_equal ( x , xlim [ 1 ] ) & np . greater_equal ( x , xlim [ 0 ] ) & np . less_equal ( y , ylim [ 1 ] ) & np . greater_equal ( y , ylim [ 0 ] ) ) plt . semilogy ( x [ i ] , y [ i ] , color = colors [ k ] , linestyle = lstyle , marker = marker [ k ] , markersize = msize , markevery = mevery [ k ] , linewidth = lwidth , label = label [ k ] )  plt . gca ( ) . set_xlabel ( <str> ) plt . gca ( ) . set_ylabel ( <str> ) plt . gca ( ) . yaxis . set_ticks ( np . logspace ( - 6 , - 2 , 3 ) ) plt . legend ( frameon = False ) fig . append ( plt . figure ( 2 ) ) plt . clf ( ) ylim = [ 1e-8 , 1 ] meas = <str> for k , a in enumerate ( algs ) :      x = epochs_save [ a ] y = out_resorted [ a ] [ meas ] i = ( np . less_equal ( x , xlim [ 1 ] ) & np . greater_equal ( x , xlim [ 0 ] ) & np . less_equal ( y , ylim [ 1 ] ) & np . greater_equal ( y , ylim [ 0 ] ) ) plt . semilogy ( x [ i ] , y [ i ] , color = colors [ k ] , linestyle = lstyle , linewidth = lwidth , marker = marker [ k ] , markersize = msize , markevery = mevery [ k ] , label = label [ k ] )  plt . gca ( ) . set_xlabel ( <str> ) plt . gca ( ) . set_ylabel ( <str> ) plt . gca ( ) . yaxis . set_ticks ( np . logspace ( - 7 , - 1 , 3 ) ) plt . legend ( frameon = False ) for i , fi in enumerate ( fig ) :      fi . savefig ( <str> . format ( folder_today , filename , i ) , bbox_inches = <str> )   