from __future__ import absolute_import , division , print_function import warnings import numpy as np from odl . discr import DiscreteLp from odl . operator import Operator from odl . space import FunctionSpace from odl . space . weighting import ConstWeighting from odl . tomo . backends import ( ASTRA_AVAILABLE , ASTRA_CUDA_AVAILABLE , ASTRA_VERSION , SKIMAGE_AVAILABLE , AstraCudaBackProjectorImpl , AstraCudaProjectorImpl , astra_cpu_back_projector , astra_cpu_forward_projector , astra_supports , astra_versions_supporting , skimage_radon_back_projector , skimage_radon_forward_projector ) from odl . tomo . geometry import ( Geometry , Parallel2dGeometry , Parallel3dAxisGeometry ) ASTRA_CPU_AVAILABLE = ASTRA_AVAILABLE _SUPPORTED_IMPL = ( <str> , <str> , <str> ) _AVAILABLE_IMPLS = [ ] if ASTRA_CPU_AVAILABLE :      _AVAILABLE_IMPLS . append ( <str> )  if ASTRA_CUDA_AVAILABLE :      _AVAILABLE_IMPLS . append ( <str> )  if SKIMAGE_AVAILABLE :      _AVAILABLE_IMPLS . append ( <str> )  __all__ = ( <str> , <str> ) class RayTransformBase ( Operator ) :      def __init__ ( self , reco_space , geometry , variant , ** kwargs ) :          variant , variant_in = str ( variant ) . lower ( ) , variant if variant not in ( <str> , <str> ) :              raise ValueError ( <str> <str> . format ( variant_in ) )  if variant == <str> :              reco_name = <str> proj_name = <str>  else :              reco_name = <str> proj_name = <str>  if not isinstance ( reco_space , DiscreteLp ) :              raise TypeError ( <str> <str> . format ( reco_name , reco_space ) )  if not isinstance ( geometry , Geometry ) :              raise TypeError ( <str> <str> . format ( geometry ) )  if not _AVAILABLE_IMPLS :              raise RuntimeError ( <str> <str> <str> )  impl = kwargs . pop ( <str> , None ) if impl is None :              if ASTRA_CUDA_AVAILABLE :                  impl = <str>  elif ASTRA_AVAILABLE :                  impl = <str> if reco_space . size >= 512 ** 2 :                      warnings . warn ( <str> <str> <str> <str> <str> , RuntimeWarning )   elif SKIMAGE_AVAILABLE :                  impl = <str> if reco_space . size >= 256 ** 2 :                      warnings . warn ( <str> <str> <str> <str> , RuntimeWarning )   else :                  raise RuntimeError ( <str> )   impl , impl_in = str ( impl ) . lower ( ) , impl if impl not in _SUPPORTED_IMPL :              raise ValueError ( <str> . format ( impl_in ) )  if impl not in _AVAILABLE_IMPLS :              raise ValueError ( <str> . format ( impl ) )  self . use_cache = kwargs . pop ( <str> , True ) if impl . startswith ( <str> ) :              if geometry . ndim > 2 and impl . endswith ( <str> ) :                  raise ValueError ( <str> <str> . format ( impl_in ) )  if ( isinstance ( geometry , Parallel3dAxisGeometry ) and not astra_supports ( <str> ) ) :                  req_ver = astra_versions_supporting ( <str> ) axis = geometry . axis mid_pt = geometry . det_params . mid_pt for i , angle in enumerate ( geometry . angles ) :                      if abs ( np . dot ( axis , geometry . det_to_src ( angle , mid_pt ) ) ) < 1e-4 :                          warnings . warn ( <str> <str> <str> <str> <str> . format ( i , geometry . det_to_src ( angle , mid_pt ) , axis , ASTRA_VERSION , req_ver ) , RuntimeWarning ) break     elif impl == <str> :              if not isinstance ( geometry , Parallel2dGeometry ) :                  raise TypeError ( <str> <str> . format ( impl ) )  mid_pt = reco_space . domain . mid_pt if not np . allclose ( mid_pt , [ 0 , 0 ] ) :                  raise ValueError ( <str> <str> . format ( reco_name , mid_pt ) )  shape = reco_space . shape if shape [ 0 ] != shape [ 1 ] :                  raise ValueError ( <str> <str> . format ( reco_name , shape ) )  extent = reco_space . domain . extent if extent [ 0 ] != extent [ 1 ] :                  raise ValueError ( <str> <str> . format ( reco_name , extent ) )   if reco_space . ndim != geometry . ndim :              raise ValueError ( <str> <str> . format ( reco_name , reco_space . ndim , geometry . ndim ) )  self . __geometry = geometry self . __impl = impl proj_space = kwargs . pop ( <str> , None ) if proj_space is None :              dtype = reco_space . dtype proj_fspace = FunctionSpace ( geometry . params , out_dtype = dtype ) if not reco_space . is_weighted :                  weighting = None  elif ( isinstance ( reco_space . weighting , ConstWeighting ) and np . isclose ( reco_space . weighting . const , reco_space . cell_volume ) ) :                  extent = float ( geometry . partition . extent . prod ( ) ) size = float ( geometry . partition . size ) weighting = extent / size  else :                  raise NotImplementedError ( <str> )  proj_tspace = reco_space . tspace_type ( geometry . partition . shape , weighting = weighting , dtype = dtype ) if geometry . motion_partition . ndim == 0 :                  angle_labels = [ ]  if geometry . motion_partition . ndim == 1 :                  angle_labels = [ <str> ]  elif geometry . motion_partition . ndim == 2 :                  angle_labels = [ <str> , <str> ]  elif geometry . motion_partition . ndim == 3 :                  angle_labels = [ <str> , <str> , <str> ]  else :                  angle_labels = None  if geometry . det_partition . ndim == 1 :                  det_labels = [ <str> ]  elif geometry . det_partition . ndim == 2 :                  det_labels = [ <str> , <str> ]  else :                  det_labels = None  if angle_labels is None or det_labels is None :                  axis_labels = None  else :                  axis_labels = angle_labels + det_labels  proj_interp = kwargs . get ( <str> , <str> ) proj_space = DiscreteLp ( proj_fspace , geometry . partition , proj_tspace , interp = proj_interp , axis_labels = axis_labels )  else :              if not isinstance ( proj_space , DiscreteLp ) :                  raise TypeError ( <str> <str> . format ( proj_name , proj_space ) )  if proj_space . shape != geometry . partition . shape :                  raise ValueError ( <str> <str> . format ( proj_name , proj_space . shape , geometry . partition . shape ) )  if proj_space . dtype != reco_space . dtype :                  raise ValueError ( <str> <str> . format ( proj_name , reco_name , proj_space . dtype , reco_space . dtype ) )   self . _adjoint = None self . _astra_wrapper = None self . _extra_kwargs = kwargs if variant == <str> :              super ( RayTransformBase , self ) . __init__ ( domain = reco_space , range = proj_space , linear = True )  elif variant == <str> :              super ( RayTransformBase , self ) . __init__ ( domain = proj_space , range = reco_space , linear = True )   @ property def impl ( self ) :          return self . __impl  @ property def geometry ( self ) :          return self . __geometry  def _call ( self , x , out = None ) :          if self . domain . is_real :              return self . _call_real ( x , out , ** self . _extra_kwargs )  elif self . domain . is_complex :              result_parts = [ self . _call_real ( x . real , getattr ( out , <str> , None ) , ** self . _extra_kwargs ) , self . _call_real ( x . imag , getattr ( out , <str> , None ) , ** self . _extra_kwargs ) , ] if out is None :                  out = self . range . element ( ) out . real = result_parts [ 0 ] out . imag = result_parts [ 1 ]  return out  else :              raise RuntimeError ( <str> . format ( self . domain ) )    class RayTransform ( RayTransformBase ) :      def __init__ ( self , domain , geometry , ** kwargs ) :          range = kwargs . pop ( <str> , None ) super ( RayTransform , self ) . __init__ ( reco_space = domain , proj_space = range , geometry = geometry , variant = <str> , ** kwargs )  def _call_real ( self , x_real , out_real , ** kwargs ) :          if self . impl . startswith ( <str> ) :              backend , data_impl = self . impl . split ( <str> ) if data_impl == <str> :                  return astra_cpu_forward_projector ( x_real , self . geometry , self . range . real_space , out_real , ** kwargs )  elif data_impl == <str> :                  if self . _astra_wrapper is None :                      astra_wrapper = AstraCudaProjectorImpl ( self . geometry , self . domain . real_space , self . range . real_space ) if self . use_cache :                          self . _astra_wrapper = astra_wrapper   else :                      astra_wrapper = self . _astra_wrapper  return astra_wrapper . call_forward ( x_real , out_real , ** kwargs )  else :                  raise RuntimeError ( <str> . format ( self . impl ) )   elif self . impl == <str> :              return skimage_radon_forward_projector ( x_real , self . geometry , self . range . real_space , out_real , ** kwargs )  else :              raise RuntimeError ( <str> . format ( self . impl ) )   @ property def adjoint ( self ) :          if self . _adjoint is not None :              return self . _adjoint  kwargs = self . _extra_kwargs . copy ( ) kwargs [ <str> ] = self . range self . _adjoint = RayBackProjection ( self . domain , self . geometry , impl = self . impl , use_cache = self . use_cache , ** kwargs ) return self . _adjoint   class RayBackProjection ( RayTransformBase ) :      def __init__ ( self , range , geometry , ** kwargs ) :          domain = kwargs . pop ( <str> , None ) super ( RayBackProjection , self ) . __init__ ( reco_space = range , proj_space = domain , geometry = geometry , variant = <str> , ** kwargs )  def _call_real ( self , x_real , out_real , ** kwargs ) :          if self . impl . startswith ( <str> ) :              backend , data_impl = self . impl . split ( <str> ) if data_impl == <str> :                  return astra_cpu_back_projector ( x_real , self . geometry , self . range . real_space , out_real , ** kwargs )  elif data_impl == <str> :                  if self . _astra_wrapper is None :                      astra_wrapper = AstraCudaBackProjectorImpl ( self . geometry , self . range . real_space , self . domain . real_space ) if self . use_cache :                          self . _astra_wrapper = astra_wrapper   else :                      astra_wrapper = self . _astra_wrapper  return astra_wrapper . call_backward ( x_real , out_real , ** kwargs )  else :                  raise RuntimeError ( <str> . format ( self . impl ) )   elif self . impl == <str> :              return skimage_radon_back_projector ( x_real , self . geometry , self . range . real_space , out_real , ** kwargs )  else :              raise RuntimeError ( <str> . format ( self . impl ) )   @ property def adjoint ( self ) :          if self . _adjoint is not None :              return self . _adjoint  kwargs = self . _extra_kwargs . copy ( ) kwargs [ <str> ] = self . domain self . _adjoint = RayTransform ( self . range , self . geometry , impl = self . impl , use_cache = self . use_cache , ** kwargs ) return self . _adjoint   if __name__ == <str> :      from odl . util . testutils import run_doctests run_doctests ( )   