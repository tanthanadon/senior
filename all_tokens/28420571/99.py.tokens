from __future__ import print_function , division , absolute_import import numpy as np import warnings from odl . util . testutils import run_doctests from odl . util . utility import is_real_dtype __all__ = ( <str> , ) def warning_free_pause ( ) :      import matplotlib . pyplot as plt with warnings . catch_warnings ( ) :          warnings . filterwarnings ( <str> , message = <str> <str> <str> ) plt . pause ( 0.0001 )   def _safe_minmax ( values ) :      isfinite = np . isfinite ( values ) if np . any ( isfinite ) :          values = values [ isfinite ]  minval = np . min ( values ) maxval = np . max ( values ) return minval , maxval  def _colorbar_ticks ( minval , maxval ) :      if not ( np . isfinite ( minval ) and np . isfinite ( maxval ) ) :          return [ 0 , 0 , 0 ]  elif minval == maxval :          return [ minval ]  else :          eps = ( maxval - minval ) / 1e5 return [ minval + eps , ( maxval + minval ) / 2. , maxval - eps ]   def _digits ( minval , maxval ) :      if minval == maxval :          return 3  else :          return min ( 10 , max ( 2 , int ( 1 + abs ( np . log10 ( maxval - minval ) ) ) ) )   def _colorbar_format ( minval , maxval ) :      if not ( np . isfinite ( minval ) and np . isfinite ( maxval ) ) :          return str ( maxval )  else :          return <str> . format ( _digits ( minval , maxval ) )   def _axes_info ( grid , npoints = 5 ) :      result = [ ] min_pt = grid . min ( ) max_pt = grid . max ( ) for axis in range ( grid . ndim ) :          xmin = min_pt [ axis ] xmax = max_pt [ axis ] points = np . linspace ( xmin , xmax , npoints ) indices = np . linspace ( 0 , grid . shape [ axis ] - 1 , npoints , dtype = int ) tick_values = grid . coord_vectors [ axis ] [ indices ] tick_values [ [ 0 , - 1 ] ] = xmin , xmax format_str = <str> + str ( _digits ( xmin , xmax ) ) + <str> tick_labels = [ format_str . format ( f ) for f in tick_values ] result += [ ( points , tick_labels ) ]  return result  def show_discrete_data ( values , grid , title = None , method = <str> , force_show = False , fig = None , ** kwargs ) :      import matplotlib . pyplot as plt args_re = [ ] args_im = [ ] dsp_kwargs = { } sub_kwargs = { } arrange_subplots = ( 121 , 122 ) axis_labels = kwargs . pop ( <str> , [ <str> , <str> ] ) values_are_complex = not is_real_dtype ( values . dtype ) figsize = kwargs . pop ( <str> , None ) saveto = kwargs . pop ( <str> , None ) interp = kwargs . pop ( <str> , <str> ) axis_fontsize = kwargs . pop ( <str> , 16 ) colorbar = kwargs . pop ( <str> , True ) update_in_place = kwargs . pop ( <str> , False ) if ( update_in_place and ( fig is None or values_are_complex or values . ndim != 2 or ( values . ndim == 2 and method not in ( <str> , <str> ) ) ) ) :          update_in_place = False  if values . ndim == 1 :          if not method :              if interp == <str> :                  method = <str> dsp_kwargs [ <str> ] = <str>  elif interp == <str> :                  method = <str>  else :                  method = <str>   if method == <str> or method == <str> or method == <str> :              args_re += [ grid . coord_vectors [ 0 ] , values . real ] args_im += [ grid . coord_vectors [ 0 ] , values . imag ]  else :              raise ValueError ( <str> <str> . format ( method ) )   elif values . ndim == 2 :          if not method :              method = <str>  if method == <str> :              args_re = [ np . rot90 ( values . real ) ] args_im = [ np . rot90 ( values . imag ) ] if values_are_complex else [ ] extent = [ grid . min ( ) [ 0 ] , grid . max ( ) [ 0 ] , grid . min ( ) [ 1 ] , grid . max ( ) [ 1 ] ] if interp == <str> :                  interpolation = <str>  elif interp == <str> :                  interpolation = <str>  else :                  interpolation = <str>  dsp_kwargs . update ( { <str> : interpolation , <str> : <str> , <str> : extent , <str> : <str> } )  elif method == <str> :              pts = grid . points ( ) args_re = [ pts [ : , 0 ] , pts [ : , 1 ] , values . ravel ( ) . real ] args_im = ( [ pts [ : , 0 ] , pts [ : , 1 ] , values . ravel ( ) . imag ] if values_are_complex else [ ] ) sub_kwargs . update ( { <str> : <str> } )  elif method in ( <str> , <str> ) :              method = <str> x , y = grid . meshgrid args_re = [ x , y , np . rot90 ( values . real ) ] args_im = ( [ x , y , np . rot90 ( values . imag ) ] if values_are_complex else [ ] ) sub_kwargs . update ( { <str> : <str> } )  else :              raise ValueError ( <str> <str> . format ( method ) )   else :          raise NotImplementedError ( <str> <str> . format ( values . ndim ) )  dsp_kwargs . update ( ** kwargs ) if fig is not None :          if not isinstance ( fig , plt . Figure ) :              raise TypeError ( <str> . format ( fig ) )  if not plt . fignum_exists ( fig . number ) :              fig = plt . figure ( figsize = figsize ) updatefig = False  else :              fig = plt . figure ( fig . number ) updatefig = True if values . ndim > 1 and not update_in_place :                  fig . clf ( )    else :          fig = plt . figure ( figsize = figsize ) updatefig = False  if values_are_complex :          if len ( fig . axes ) == 0 :              sub_re = plt . subplot ( arrange_subplots [ 0 ] , ** sub_kwargs ) sub_re . set_title ( <str> ) sub_re . set_xlabel ( axis_labels [ 0 ] , fontsize = axis_fontsize ) if values . ndim == 2 :                  sub_re . set_ylabel ( axis_labels [ 1 ] , fontsize = axis_fontsize )  else :                  sub_re . set_ylabel ( <str> )   else :              sub_re = fig . axes [ 0 ]  display_re = getattr ( sub_re , method ) csub_re = display_re ( * args_re , ** dsp_kwargs ) if method == <str> and not grid . is_uniform :              ( xpts , xlabels ) , ( ypts , ylabels ) = _axes_info ( grid ) plt . xticks ( xpts , xlabels ) plt . yticks ( ypts , ylabels )  if method == <str> and len ( fig . axes ) < 2 :              if <str> not in kwargs :                  minval_re , maxval_re = _safe_minmax ( values . real )  else :                  minval_re , maxval_re = kwargs [ <str> ]  ticks_re = _colorbar_ticks ( minval_re , maxval_re ) fmt_re = _colorbar_format ( minval_re , maxval_re ) plt . colorbar ( csub_re , orientation = <str> , ticks = ticks_re , format = fmt_re )  if len ( fig . axes ) < 3 :              sub_im = plt . subplot ( arrange_subplots [ 1 ] , ** sub_kwargs ) sub_im . set_title ( <str> ) sub_im . set_xlabel ( axis_labels [ 0 ] , fontsize = axis_fontsize ) if values . ndim == 2 :                  sub_im . set_ylabel ( axis_labels [ 1 ] , fontsize = axis_fontsize )  else :                  sub_im . set_ylabel ( <str> )   else :              sub_im = fig . axes [ 2 ]  display_im = getattr ( sub_im , method ) csub_im = display_im ( * args_im , ** dsp_kwargs ) if method == <str> and not grid . is_uniform :              ( xpts , xlabels ) , ( ypts , ylabels ) = _axes_info ( grid ) plt . xticks ( xpts , xlabels ) plt . yticks ( ypts , ylabels )  if method == <str> and len ( fig . axes ) < 4 :              if <str> not in kwargs :                  minval_im , maxval_im = _safe_minmax ( values . imag )  else :                  minval_im , maxval_im = kwargs [ <str> ]  ticks_im = _colorbar_ticks ( minval_im , maxval_im ) fmt_im = _colorbar_format ( minval_im , maxval_im ) plt . colorbar ( csub_im , orientation = <str> , ticks = ticks_im , format = fmt_im )   else :          if len ( fig . axes ) == 0 :              sub = plt . subplot ( 111 , ** sub_kwargs ) sub . set_xlabel ( axis_labels [ 0 ] , fontsize = axis_fontsize ) if values . ndim == 2 :                  sub . set_ylabel ( axis_labels [ 1 ] , fontsize = axis_fontsize )  else :                  sub . set_ylabel ( <str> )  try :                  sub . set_zlabel ( <str> )  except AttributeError :                  pass   else :              sub = fig . axes [ 0 ]  if update_in_place :              import matplotlib as mpl imgs = [ obj for obj in sub . get_children ( ) if isinstance ( obj , mpl . image . AxesImage ) ] if len ( imgs ) > 0 and updatefig :                  imgs [ 0 ] . set_data ( args_re [ 0 ] ) csub = imgs [ 0 ] if <str> not in kwargs :                      minval , maxval = _safe_minmax ( values )  else :                      minval , maxval = kwargs [ <str> ]  csub . set_clim ( minval , maxval )  else :                  display = getattr ( sub , method ) csub = display ( * args_re , ** dsp_kwargs )   else :              display = getattr ( sub , method ) csub = display ( * args_re , ** dsp_kwargs )  if method == <str> and not grid . is_uniform :              ( xpts , xlabels ) , ( ypts , ylabels ) = _axes_info ( grid ) plt . xticks ( xpts , xlabels ) plt . yticks ( ypts , ylabels )  if method == <str> and colorbar :              if <str> not in kwargs :                  minval , maxval = _safe_minmax ( values )  else :                  minval , maxval = kwargs [ <str> ]  ticks = _colorbar_ticks ( minval , maxval ) fmt = _colorbar_format ( minval , maxval ) if len ( fig . axes ) < 2 :                  plt . colorbar ( mappable = csub , ticks = ticks , format = fmt )  elif update_in_place :                  csub . colorbar . set_clim ( minval , maxval ) csub . colorbar . set_ticks ( ticks ) if <str> not in fmt :                      labels = [ fmt ] * len ( ticks )  else :                      labels = [ fmt % t for t in ticks ]  csub . colorbar . set_ticklabels ( labels ) csub . colorbar . draw_all ( )    if title is not None :          if not values_are_complex :              plt . title ( title )  fig . canvas . manager . set_window_title ( title )  if not update_in_place :          fig . tight_layout ( )  if updatefig or plt . isinteractive ( ) :          plt . show ( block = False ) if not update_in_place :              plt . draw ( ) warning_free_pause ( )  else :              try :                  sub . draw_artist ( csub ) fig . canvas . blit ( fig . bbox ) fig . canvas . update ( ) fig . canvas . flush_events ( )  except AttributeError :                  plt . draw ( ) warning_free_pause ( )    if force_show :          plt . show ( )  if saveto is not None :          fig . savefig ( saveto )  return fig  if __name__ == <str> :      run_doctests ( )   