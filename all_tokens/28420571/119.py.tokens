from __future__ import print_function , division , absolute_import from builtins import object import copy import numpy as np import os import time import warnings from odl . util import signature_string __all__ = ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) class Callback ( object ) :      def __call__ ( self , iterate ) :           def __and__ ( self , other ) :          return _CallbackAnd ( self , other )  def __mul__ ( self , other ) :          return _CallbackCompose ( self , other )  def reset ( self ) :          pass  def __repr__ ( self ) :          return <str> . format ( self . __class__ . __name__ )   class _CallbackAnd ( Callback ) :      def __init__ ( self , * callbacks ) :          callbacks = [ c if isinstance ( c , Callback ) else CallbackApply ( c ) for c in callbacks ] self . callbacks = callbacks  def __call__ ( self , result ) :          for p in self . callbacks :              p ( result )   def reset ( self ) :          for callback in self . callbacks :              callback . reset ( )   def __repr__ ( self ) :          return <str> . join ( <str> . format ( p ) for p in self . callbacks )   class _CallbackCompose ( Callback ) :      def __init__ ( self , callback , operator ) :          self . callback = callback self . operator = operator  def __call__ ( self , result ) :          self . callback ( self . operator ( result ) )  def reset ( self ) :          self . callback . reset ( )  def __repr__ ( self ) :          return <str> . format ( self . callback , self . operator )   class CallbackStore ( Callback ) :      def __init__ ( self , results = None , function = None , step = 1 ) :          self . results = [ ] if results is None else results self . function = function if function is not None :              warnings . warn ( <str> <str> <str> <str> , DeprecationWarning )  self . step = int ( step ) self . iter = 0  def __call__ ( self , result ) :          if self . iter % self . step == 0 :              if self . function :                  self . results . append ( self . function ( result ) )  else :                  self . results . append ( copy . copy ( result ) )   self . iter += 1  def reset ( self ) :          self . results = [ ] self . iter = 0  def __iter__ ( self ) :          return iter ( self . results )  def __getitem__ ( self , index ) :          return self . results [ index ]  def __len__ ( self ) :          return len ( self . results )  def __repr__ ( self ) :          optargs = [ ( <str> , self . results , [ ] ) , ( <str> , self . function , None ) , ( <str> , self . step , 1 ) ] inner_str = signature_string ( [ ] , optargs ) return <str> . format ( self . __class__ . __name__ , inner_str )   class CallbackApply ( Callback ) :      def __init__ ( self , function , step = 1 ) :          assert callable ( function ) self . function = function self . step = int ( step ) self . iter = 0  def __call__ ( self , result ) :          if self . iter % self . step == 0 :              self . function ( result )  self . iter += 1  def reset ( self ) :          self . iter = 0  def __str__ ( self ) :          return repr ( self )  def __repr__ ( self ) :          posargs = [ self . function ] optargs = [ ( <str> , self . step , 1 ) ] inner_str = signature_string ( posargs , optargs ) return <str> . format ( self . __class__ . __name__ , inner_str )   class CallbackPrintIteration ( Callback ) :      def __init__ ( self , fmt = <str> , step = 1 , ** kwargs ) :          self . fmt = str ( fmt ) self . step = int ( step ) self . iter = 0 self . kwargs = kwargs  def __call__ ( self , _ ) :          if self . iter % self . step == 0 :              print ( self . fmt . format ( self . iter ) , ** self . kwargs )  self . iter += 1  def reset ( self ) :          self . iter = 0  def __repr__ ( self ) :          optargs = [ ( <str> , self . fmt , <str> ) , ( <str> , self . step , 1 ) ] inner_str = signature_string ( [ ] , optargs ) return <str> . format ( self . __class__ . __name__ , inner_str )   class CallbackPrintTiming ( Callback ) :      def __init__ ( self , fmt = <str> , step = 1 , cumulative = False , ** kwargs ) :          self . fmt = str ( fmt ) self . step = int ( step ) self . iter = 0 self . cumulative = cumulative self . start_time = time . time ( ) self . kwargs = kwargs  def __call__ ( self , _ ) :          if self . iter % self . step == 0 :              current_time = time . time ( ) print ( self . fmt . format ( current_time - self . start_time ) , ** self . kwargs ) if not self . cumulative :                  self . start_time = current_time   self . iter += 1  def reset ( self ) :          self . start_time = time . time ( ) self . iter = 0  def __repr__ ( self ) :          optargs = [ ( <str> , self . fmt , <str> ) , ( <str> , self . step , 1 ) , ( <str> , self . cumulative , False ) ] inner_str = signature_string ( [ ] , optargs ) return <str> . format ( self . __class__ . __name__ , inner_str )   class CallbackPrint ( Callback ) :      def __init__ ( self , func = None , fmt = <str> , step = 1 , ** kwargs ) :          self . func = func if func is not None :              warnings . warn ( <str> <str> <str> , DeprecationWarning )  if func is not None and not callable ( func ) :              raise TypeError ( <str> )  self . fmt = str ( fmt ) self . step = int ( step ) self . iter = 0 self . kwargs = kwargs  def __call__ ( self , result ) :          if self . iter % self . step == 0 :              if self . func is not None :                  result = self . func ( result )  print ( self . fmt . format ( result ) , ** self . kwargs )  self . iter += 1  def reset ( self ) :          self . iter = 0  def __repr__ ( self ) :          optargs = [ ( <str> , self . func , None ) , ( <str> , self . fmt , <str> ) , ( <str> , self . step , 1 ) ] inner_str = signature_string ( [ ] , optargs ) return <str> . format ( self . __class__ . __name__ , inner_str )   class CallbackPrintNorm ( Callback ) :      def __call__ ( self , result ) :          print ( <str> . format ( result . norm ( ) ) )  def __repr__ ( self ) :          return <str> . format ( self . __class__ . __name__ )   class CallbackShow ( Callback ) :      def __init__ ( self , title = None , step = 1 , saveto = None , ** kwargs ) :          if title is None :              self . title = <str>  else :              self . title = str ( title )  self . title_formatter = self . title . format self . saveto = saveto self . saveto_formatter = getattr ( self . saveto , <str> , self . saveto ) self . step = step self . fig = kwargs . pop ( <str> , None ) self . iter = 0 self . space_of_last_x = None self . kwargs = kwargs  def __call__ ( self , x ) :          x_space = x . space update_in_place = ( self . space_of_last_x == x_space ) self . space_of_last_x = x_space if self . iter % self . step == 0 :              title = self . title_formatter ( self . iter ) if self . saveto is None :                  self . fig = x . show ( title , fig = self . fig , update_in_place = update_in_place , ** self . kwargs )  else :                  saveto = self . saveto_formatter ( self . iter ) self . fig = x . show ( title , fig = self . fig , update_in_place = update_in_place , saveto = saveto , ** self . kwargs )   self . iter += 1  def reset ( self ) :          self . iter = 0 self . fig = None self . space_of_last_x = None  def __repr__ ( self ) :          posargs = [ ] if self . title != <str> :              posargs . append ( self . title )  optargs = [ ( <str> , self . step , 1 ) , ( <str> , self . saveto , None ) ] for kwarg , value in self . kwargs . items ( ) :              optargs . append ( ( kwarg , value , None ) )  inner_str = signature_string ( posargs , optargs ) return <str> . format ( self . __class__ . __name__ , inner_str )   class CallbackSaveToDisk ( Callback ) :      def __init__ ( self , saveto , step = 1 , impl = <str> , ** kwargs ) :          self . saveto = saveto try :              self . saveto_formatter = self . saveto . format  except AttributeError :              self . saveto_formatter = self . saveto  self . step = int ( step ) self . impl = str ( impl ) . lower ( ) self . kwargs = kwargs self . iter = 0  def __call__ ( self , x ) :          if self . iter % self . step == 0 :              file_path = self . saveto_formatter ( self . iter ) folder_path = os . path . dirname ( os . path . realpath ( file_path ) ) if not os . path . exists ( folder_path ) :                  os . makedirs ( folder_path )  if self . impl == <str> :                  import pickle with open ( file_path , <str> ) as f :                      pickle . dump ( x , f , ** self . kwargs )   elif self . impl == <str> :                  np . save ( file_path , np . asarray ( x ) , ** self . kwargs )  elif self . impl == <str> :                  np . savetxt ( file_path , np . asarray ( x ) , ** self . kwargs )  else :                  raise RuntimeError ( <str> . format ( self . impl ) )   self . iter += 1  def reset ( self ) :          self . iter = 0  def __repr__ ( self ) :          posargs = [ self . saveto ] optargs = [ ( <str> , self . step , 1 ) , ( <str> , self . impl , <str> ) ] for kwarg , value in self . kwargs . items ( ) :              optargs . append ( ( kwarg , value , None ) )  inner_str = signature_string ( posargs , optargs ) return <str> . format ( self . __class__ . __name__ , inner_str )   class CallbackSleep ( Callback ) :      def __init__ ( self , seconds = 1.0 ) :          self . seconds = float ( seconds )  def __call__ ( self , x ) :          time . sleep ( self . seconds )  def __repr__ ( self ) :          optargs = [ ( <str> , self . seconds , 1.0 ) ] inner_str = signature_string ( [ ] , optargs ) return <str> . format ( self . __class__ . __name__ , inner_str )   class CallbackShowConvergence ( Callback ) :      def __init__ ( self , functional , title = <str> , logx = False , logy = False , ** kwargs ) :          self . functional = functional self . title = title self . logx = logx self . logy = logy self . kwargs = kwargs self . iter = 0 import matplotlib . pyplot as plt self . fig = plt . figure ( title ) self . ax = self . fig . add_subplot ( 111 ) self . ax . set_xlabel ( <str> ) self . ax . set_ylabel ( <str> ) self . ax . set_title ( title ) if logx :              self . ax . set_xscale ( <str> , nonposx = <str> )  if logy :              self . ax . set_yscale ( <str> , nonposy = <str> )   def __call__ ( self , x ) :          if self . logx :              it = self . iter + 1  else :              it = self . iter  self . ax . scatter ( it , self . functional ( x ) , ** self . kwargs ) self . iter += 1  def reset ( self ) :          self . iter = 0  def __repr__ ( self ) :          return <str> . format ( self . __class__ . __name__ , self . functional , self . title , self . logx , self . logy )   class CallbackPrintHardwareUsage ( Callback ) :      def __init__ ( self , step = 1 , fmt_cpu = <str> , fmt_mem = <str> , fmt_swap = <str> , ** kwargs ) :          self . step = int ( step ) self . fmt_cpu = str ( fmt_cpu ) self . fmt_mem = str ( fmt_mem ) self . fmt_swap = str ( fmt_swap ) self . iter = 0  def __call__ ( self , _ ) :          import psutil if self . iter % self . step == 0 :              if self . fmt_cpu :                  print ( self . fmt_cpu . format ( psutil . cpu_percent ( percpu = True ) ) , ** self . kwargs )  if self . fmt_mem :                  print ( self . fmt_mem . format ( psutil . virtual_memory ( ) ) , ** self . kwargs )  if self . fmt_swap :                  print ( self . fmt_swap . format ( psutil . swap_memory ( ) ) , ** self . kwargs )   self . iter += 1  def reset ( self ) :          self . iter = 0  def __repr__ ( self ) :          optargs = [ ( <str> , self . step , 1 ) , ( <str> , self . fmt_cpu , <str> ) , ( <str> , self . fmt_mem , <str> ) , ( <str> , self . fmt_swap , <str> ) ] inner_str = signature_string ( [ ] , optargs ) return <str> . format ( self . __class__ . __name__ , inner_str )   class CallbackProgressBar ( Callback ) :      def __init__ ( self , niter , step = 1 , ** kwargs ) :          self . niter = int ( niter ) self . step = int ( step ) self . kwargs = kwargs self . reset ( )  def __call__ ( self , _ ) :          if self . iter % self . step == 0 :              self . pbar . update ( self . step )  self . iter += 1  def reset ( self ) :          import tqdm self . iter = 0 self . pbar = tqdm . tqdm ( total = self . niter , ** self . kwargs )  def __repr__ ( self ) :          posargs = [ self . niter ] optargs = [ ( <str> , self . step , 1 ) ] inner_str = signature_string ( posargs , optargs ) if self . kwargs :              return <str> . format ( self . __class__ . __name__ , inner_str , self . kwargs )  else :              return <str> . format ( self . __class__ . __name__ , inner_str )    if __name__ == <str> :      from odl . util . testutils import run_doctests run_doctests ( )   