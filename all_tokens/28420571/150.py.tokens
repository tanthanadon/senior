from __future__ import print_function , division , absolute_import from future . utils import native from builtins import object import ctypes from functools import partial import numpy as np from odl . set . sets import RealNumbers , ComplexNumbers from odl . set . space import LinearSpaceTypeError from odl . space . base_tensors import TensorSpace , Tensor from odl . space . weighting import ( Weighting , ArrayWeighting , ConstWeighting , CustomInner , CustomNorm , CustomDist ) from odl . util import ( dtype_str , signature_string , is_real_dtype , is_numeric_dtype , writable_array , is_floating_dtype ) __all__ = ( <str> , ) _BLAS_DTYPES = ( np . dtype ( <str> ) , np . dtype ( <str> ) , np . dtype ( <str> ) , np . dtype ( <str> ) ) THRESHOLD_SMALL = 100 THRESHOLD_MEDIUM = 50000 class NumpyTensorSpace ( TensorSpace ) :      def __init__ ( self , shape , dtype = None , ** kwargs ) :          super ( NumpyTensorSpace , self ) . __init__ ( shape , dtype ) if self . dtype . char not in self . available_dtypes ( ) :              raise ValueError ( <str> <str> . format ( dtype_str ( dtype ) ) )  dist = kwargs . pop ( <str> , None ) norm = kwargs . pop ( <str> , None ) inner = kwargs . pop ( <str> , None ) weighting = kwargs . pop ( <str> , None ) exponent = kwargs . pop ( <str> , getattr ( weighting , <str> , 2.0 ) ) if ( not is_numeric_dtype ( self . dtype ) and any ( x is not None for x in ( dist , norm , inner , weighting ) ) ) :              raise ValueError ( <str> <str> <str> . format ( dtype ) )  if exponent != 2.0 and any ( x is not None for x in ( dist , norm , inner ) ) :              raise ValueError ( <str> <str> )  num_extra_args = sum ( a is not None for a in ( dist , norm , inner , weighting ) ) if num_extra_args > 1 :              raise ValueError ( <str> <str> )  if weighting is not None :              if isinstance ( weighting , Weighting ) :                  if weighting . impl != <str> :                      raise ValueError ( <str> <str> . format ( weighting . impl ) )  if weighting . exponent != exponent :                      raise ValueError ( <str> <str> <str> . format ( weighting . exponent , exponent ) )  self . __weighting = weighting  else :                  self . __weighting = _weighting ( weighting , exponent )  if isinstance ( self . weighting , NumpyTensorSpaceArrayWeighting ) :                  if self . weighting . array . dtype == object :                      raise ValueError ( <str> <str> . format ( weighting ) )  elif not np . can_cast ( self . weighting . array . dtype , self . dtype ) :                      raise ValueError ( <str> <str> <str> . format ( dtype_str ( self . weighting . array . dtype ) , dtype_str ( self . dtype ) ) )  if self . weighting . array . shape != self . shape :                      raise ValueError ( <str> <str> <str> . format ( self . shape , self . weighting . array . shape ) )    elif dist is not None :              self . __weighting = NumpyTensorSpaceCustomDist ( dist )  elif norm is not None :              self . __weighting = NumpyTensorSpaceCustomNorm ( norm )  elif inner is not None :              self . __weighting = NumpyTensorSpaceCustomInner ( inner )  else :              self . __weighting = NumpyTensorSpaceConstWeighting ( 1.0 , exponent )  if kwargs :              raise TypeError ( <str> . format ( kwargs ) )   @ property def impl ( self ) :          return <str>  @ property def default_order ( self ) :          return <str>  @ property def weighting ( self ) :          return self . __weighting  @ property def is_weighted ( self ) :          return not ( isinstance ( self . weighting , NumpyTensorSpaceConstWeighting ) and self . weighting . const == 1.0 )  @ property def exponent ( self ) :          return self . weighting . exponent  def element ( self , inp = None , data_ptr = None , order = None ) :          if order is not None and str ( order ) . upper ( ) not in ( <str> , <str> ) :              raise ValueError ( <str> . format ( order ) )  if inp is None and data_ptr is None :              if order is None :                  arr = np . empty ( self . shape , dtype = self . dtype , order = self . default_order )  else :                  arr = np . empty ( self . shape , dtype = self . dtype , order = order )  return self . element_type ( self , arr )  elif inp is None and data_ptr is not None :              if order is None :                  raise ValueError ( <str> <str> )  ctype_array_def = ctypes . c_byte * self . nbytes as_ctype_array = ctype_array_def . from_address ( data_ptr ) as_numpy_array = np . ctypeslib . as_array ( as_ctype_array ) arr = as_numpy_array . view ( dtype = self . dtype ) arr = arr . reshape ( self . shape , order = order ) return self . element_type ( self , arr )  elif inp is not None and data_ptr is None :              if inp in self and order is None :                  return inp  arr = np . array ( inp , copy = False , dtype = self . dtype , ndmin = self . ndim , order = order ) if not arr . flags . writeable :                  arr = arr . copy ( )  if arr . shape != self . shape :                  raise ValueError ( <str> <str> . format ( arr . shape , self . shape ) )  return self . element_type ( self , arr )  else :              raise TypeError ( <str> )   def zero ( self ) :          return self . element ( np . zeros ( self . shape , dtype = self . dtype , order = self . default_order ) )  def one ( self ) :          return self . element ( np . ones ( self . shape , dtype = self . dtype , order = self . default_order ) )  @ staticmethod def available_dtypes ( ) :          all_dtypes = [ ] for lst in np . sctypes . values ( ) :              for dtype in lst :                  if dtype not in ( np . object , np . void ) :                      all_dtypes . append ( np . dtype ( dtype ) )    all_dtypes . extend ( [ np . dtype ( <str> ) , np . dtype ( <str> ) ] ) return tuple ( sorted ( set ( all_dtypes ) ) )  @ staticmethod def default_dtype ( field = None ) :          if field is None or field == RealNumbers ( ) :              return np . dtype ( <str> )  elif field == ComplexNumbers ( ) :              return np . dtype ( <str> )  else :              raise ValueError ( <str> <str> . format ( field ) )   def _lincomb ( self , a , x1 , b , x2 , out ) :          _lincomb_impl ( a , x1 , b , x2 , out )  def _dist ( self , x1 , x2 ) :          return self . weighting . dist ( x1 , x2 )  def _norm ( self , x ) :          return self . weighting . norm ( x )  def _inner ( self , x1 , x2 ) :          return self . weighting . inner ( x1 , x2 )  def _multiply ( self , x1 , x2 , out ) :          np . multiply ( x1 . data , x2 . data , out = out . data )  def _divide ( self , x1 , x2 , out ) :          np . divide ( x1 . data , x2 . data , out = out . data )  def __eq__ ( self , other ) :          if other is self :              return True  return ( super ( NumpyTensorSpace , self ) . __eq__ ( other ) and self . weighting == other . weighting )  def __hash__ ( self ) :          return hash ( ( super ( NumpyTensorSpace , self ) . __hash__ ( ) , self . weighting ) )  @ property def byaxis ( self ) :          space = self class NpyTensorSpacebyaxis ( object ) :              def __getitem__ ( self , indices ) :                  try :                      iter ( indices )  except TypeError :                      newshape = space . shape [ indices ]  else :                      newshape = tuple ( space . shape [ i ] for i in indices )  if isinstance ( space . weighting , ArrayWeighting ) :                      new_array = np . asarray ( space . weighting . array [ indices ] ) weighting = NumpyTensorSpaceArrayWeighting ( new_array , space . weighting . exponent )  else :                      weighting = space . weighting  return type ( space ) ( newshape , space . dtype , weighting = weighting )  def __repr__ ( self ) :                  return repr ( space ) + <str>   return NpyTensorSpacebyaxis ( )  def __repr__ ( self ) :          if self . ndim == 1 :              posargs = [ self . size ]  else :              posargs = [ self . shape ]  if self . is_real :              ctor_name = <str>  elif self . is_complex :              ctor_name = <str>  else :              ctor_name = <str>  if ( ctor_name == <str> or not is_numeric_dtype ( self . dtype ) or self . dtype != self . default_dtype ( self . field ) ) :              optargs = [ ( <str> , dtype_str ( self . dtype ) , <str> ) ] if self . dtype in ( float , complex , int , bool ) :                  optmod = <str>  else :                  optmod = <str>   else :              optargs = [ ] optmod = <str>  inner_str = signature_string ( posargs , optargs , mod = [ <str> , optmod ] ) weight_str = self . weighting . repr_part if weight_str :              inner_str += <str> + weight_str  return <str> . format ( ctor_name , inner_str )  @ property def element_type ( self ) :          return NumpyTensor   class NumpyTensor ( Tensor ) :      def __init__ ( self , space , data ) :          Tensor . __init__ ( self , space ) self . __data = data  @ property def data ( self ) :          return self . __data  def asarray ( self , out = None ) :          if out is None :              return self . data  else :              out [ : ] = self . data return out   def astype ( self , dtype ) :          return self . space . astype ( dtype ) . element ( self . data . astype ( dtype ) )  @ property def data_ptr ( self ) :          return self . data . ctypes . data  def __eq__ ( self , other ) :          if other is self :              return True  elif other not in self . space :              return False  else :              return np . array_equal ( self . data , other . data )   def copy ( self ) :          return self . space . element ( self . data . copy ( ) )  def __copy__ ( self ) :          return self . copy ( )  def __getitem__ ( self , indices ) :          if isinstance ( indices , NumpyTensor ) :              indices = indices . data  arr = self . data [ indices ] if np . isscalar ( arr ) :              if self . space . field is not None :                  return self . space . field . element ( arr )  else :                  return arr   else :              if is_numeric_dtype ( self . dtype ) :                  weighting = self . space . weighting  else :                  weighting = None  space = type ( self . space ) ( arr . shape , dtype = self . dtype , exponent = self . space . exponent , weighting = weighting ) return space . element ( arr )   def __setitem__ ( self , indices , values ) :          if isinstance ( indices , type ( self ) ) :              indices = indices . data  if isinstance ( values , type ( self ) ) :              values = values . data  self . data [ indices ] = values  @ property def real ( self ) :          if self . space . is_real :              return self  elif self . space . is_complex :              real_space = self . space . astype ( self . space . real_dtype ) return real_space . element ( self . data . real )  else :              raise NotImplementedError ( <str> <str> . format ( self . dtype ) )   @ real . setter def real ( self , newreal ) :          self . real . data [ : ] = newreal  @ property def imag ( self ) :          if self . space . is_real :              return self . space . zero ( )  elif self . space . is_complex :              real_space = self . space . astype ( self . space . real_dtype ) return real_space . element ( self . data . imag )  else :              raise NotImplementedError ( <str> <str> . format ( self . dtype ) )   @ imag . setter def imag ( self , newimag ) :          if self . space . is_real :              raise ValueError ( <str> )  self . imag . data [ : ] = newimag  def conj ( self , out = None ) :          if self . space . is_real :              if out is None :                  return self  else :                  out [ : ] = self return out   if not is_numeric_dtype ( self . space . dtype ) :              raise NotImplementedError ( <str> <str> . format ( self . dtype ) )  if out is None :              return self . space . element ( self . data . conj ( ) )  else :              if out not in self . space :                  raise LinearSpaceTypeError ( <str> <str> . format ( out , self . space ) )  self . data . conj ( out . data ) return out   def __ipow__ ( self , other ) :          try :              if other == int ( other ) :                  return super ( NumpyTensor , self ) . __ipow__ ( other )   except TypeError :              pass  np . power ( self . data , other , out = self . data ) return self  def __int__ ( self ) :          return int ( self . data )  def __long__ ( self ) :          return long ( self . data )  def __float__ ( self ) :          return float ( self . data )  def __complex__ ( self ) :          if self . size != 1 :              raise TypeError ( <str> <str> )  return complex ( self . data . ravel ( ) [ 0 ] )  def __array_ufunc__ ( self , ufunc , method , * inputs , ** kwargs ) :          out_tuple = kwargs . pop ( <str> , ( ) ) if method == <str> and len ( out_tuple ) not in ( 0 , ufunc . nout ) :              raise ValueError ( <str> <str> <str> . format ( ufunc . __name__ , ufunc . nout , len ( out_tuple ) ) )  elif method != <str> and len ( out_tuple ) not in ( 0 , 1 ) :              raise ValueError ( <str> <str> . format ( ufunc . __name__ , method , len ( out_tuple ) ) )  valid_types = ( type ( self ) , type ( self . data ) , np . ndarray ) if not all ( isinstance ( o , valid_types ) or o is None for o in out_tuple ) :              return NotImplemented  out = out1 = out2 = None if len ( out_tuple ) == 1 :              out = out_tuple [ 0 ]  elif len ( out_tuple ) == 2 :              out1 = out_tuple [ 0 ] out2 = out_tuple [ 1 ]  inputs = tuple ( inp . asarray ( ) if isinstance ( inp , type ( self ) ) else inp for inp in inputs ) out_dtype = kwargs . get ( <str> , None ) if out_dtype is None :              array_kwargs = { }  else :              array_kwargs = { <str> : out_dtype }  exponent = self . space . exponent weighting = self . space . weighting class CtxNone ( object ) :              __enter__ = __exit__ = lambda * _ : None  if method == <str> :              if ufunc . nout == 1 :                  if out is None :                      out_ctx = CtxNone ( )  else :                      out_ctx = writable_array ( out , ** array_kwargs )  with out_ctx as out_arr :                      kwargs [ <str> ] = out_arr res = ufunc ( * inputs , ** kwargs )  if out is None :                      if is_floating_dtype ( res . dtype ) :                          spc_kwargs = { <str> : weighting }  else :                          spc_kwargs = { }  out_space = type ( self . space ) ( self . shape , res . dtype , ** spc_kwargs ) out = out_space . element ( res )  return out  elif ufunc . nout == 2 :                  if out1 is not None :                      out1_ctx = writable_array ( out1 , ** array_kwargs )  else :                      out1_ctx = CtxNone ( )  if out2 is not None :                      out2_ctx = writable_array ( out2 , ** array_kwargs )  else :                      out2_ctx = CtxNone ( )  with out1_ctx as out1_arr , out2_ctx as out2_arr :                      kwargs [ <str> ] = ( out1_arr , out2_arr ) res1 , res2 = ufunc ( * inputs , ** kwargs )  if out1 is None :                      out1_space = type ( self . space ) ( self . shape , res1 . dtype ) out1 = out1_space . element ( res1 )  if out2 is None :                      out2_space = type ( self . space ) ( self . shape , res2 . dtype ) out2 = out2_space . element ( res2 )  return out1 , out2  else :                  raise NotImplementedError ( <str> <str> . format ( ufunc . nout ) )   else :              if out is None :                  out_ctx = CtxNone ( )  else :                  out_ctx = writable_array ( out , ** array_kwargs )  with out_ctx as out_arr :                  if method != <str> :                      kwargs [ <str> ] = out_arr  res = getattr ( ufunc , method ) ( * inputs , ** kwargs )  if np . isscalar ( res ) or res is None :                  return res  if out is None :                  if is_floating_dtype ( res . dtype ) :                      if res . shape != self . shape :                          weighting = NumpyTensorSpaceConstWeighting ( 1.0 , exponent )  spc_kwargs = { <str> : weighting }  else :                      spc_kwargs = { }  out_space = type ( self . space ) ( res . shape , res . dtype , ** spc_kwargs ) out = out_space . element ( res )  return out    def _blas_is_applicable ( * args ) :      if any ( x . dtype != args [ 0 ] . dtype for x in args [ 1 : ] ) :          return False  elif any ( x . dtype not in _BLAS_DTYPES for x in args ) :          return False  elif not ( all ( x . flags . f_contiguous for x in args ) or all ( x . flags . c_contiguous for x in args ) ) :          return False  elif any ( x . size > np . iinfo ( <str> ) . max for x in args ) :          return False  else :          return True   def _lincomb_impl ( a , x1 , b , x2 , out ) :      import scipy . linalg size = native ( x1 . size ) if size < THRESHOLD_SMALL :          out . data [ : ] = a * x1 . data + b * x2 . data return  elif ( size < THRESHOLD_MEDIUM or not _blas_is_applicable ( x1 . data , x2 . data , out . data ) ) :          def fallback_axpy ( x1 , x2 , n , a ) :              if a != 0 :                  x2 /= a x2 += x1 x2 *= a  return x2  def fallback_scal ( a , x , n ) :              x *= a return x  def fallback_copy ( x1 , x2 , n ) :              x2 [ ... ] = x1 [ ... ] return x2  axpy , scal , copy = ( fallback_axpy , fallback_scal , fallback_copy ) x1_arr = x1 . data x2_arr = x2 . data out_arr = out . data  else :          if out . data . flags . f_contiguous :              ravel_order = <str>  else :              ravel_order = <str>  x1_arr = x1 . data . ravel ( order = ravel_order ) x2_arr = x2 . data . ravel ( order = ravel_order ) out_arr = out . data . ravel ( order = ravel_order ) axpy , scal , copy = scipy . linalg . blas . get_blas_funcs ( [ <str> , <str> , <str> ] , arrays = ( x1_arr , x2_arr , out_arr ) )  if x1 is x2 and b != 0 :          _lincomb_impl ( a + b , x1 , 0 , x1 , out )  elif out is x1 and out is x2 :          if ( a + b ) != 0 :              scal ( a + b , out_arr , size )  else :              out_arr [ : ] = 0   elif out is x1 :          if a != 1 :              scal ( a , out_arr , size )  if b != 0 :              axpy ( x2_arr , out_arr , size , b )   elif out is x2 :          if b != 1 :              scal ( b , out_arr , size )  if a != 0 :              axpy ( x1_arr , out_arr , size , a )   else :          if b == 0 :              if a == 0 :                  out_arr [ : ] = 0  else :                  copy ( x1_arr , out_arr , size ) if a != 1 :                      scal ( a , out_arr , size )    else :              if a == 0 :                  copy ( x2_arr , out_arr , size ) if b != 1 :                      scal ( b , out_arr , size )   elif a == 1 :                  copy ( x1_arr , out_arr , size ) axpy ( x2_arr , out_arr , size , b )  else :                  copy ( x2_arr , out_arr , size ) if b != 1 :                      scal ( b , out_arr , size )  axpy ( x1_arr , out_arr , size , a )     def _weighting ( weights , exponent ) :      if np . isscalar ( weights ) :          weighting = NumpyTensorSpaceConstWeighting ( weights , exponent )  elif weights is None :          weighting = NumpyTensorSpaceConstWeighting ( 1.0 , exponent )  else :          arr = np . asarray ( weights ) weighting = NumpyTensorSpaceArrayWeighting ( arr , exponent )  return weighting  def npy_weighted_inner ( weights ) :      return _weighting ( weights , exponent = 2.0 ) . inner  def npy_weighted_norm ( weights , exponent = 2.0 ) :      return _weighting ( weights , exponent = exponent ) . norm  def npy_weighted_dist ( weights , exponent = 2.0 ) :      return _weighting ( weights , exponent = exponent ) . dist  def _norm_default ( x ) :      import scipy . linalg if _blas_is_applicable ( x . data ) :          nrm2 = scipy . linalg . blas . get_blas_funcs ( <str> , dtype = x . dtype ) norm = partial ( nrm2 , n = native ( x . size ) )  else :          norm = np . linalg . norm  return norm ( x . data . ravel ( ) )  def _pnorm_default ( x , p ) :      return np . linalg . norm ( x . data . ravel ( ) , ord = p )  def _pnorm_diagweight ( x , p , w ) :      order = <str> if all ( a . flags . f_contiguous for a in ( x . data , w ) ) else <str> xp = np . abs ( x . data . ravel ( order ) ) if p == float ( <str> ) :          xp *= w . ravel ( order ) return np . max ( xp )  else :          xp = np . power ( xp , p , out = xp ) xp *= w . ravel ( order ) return np . sum ( xp ) ** ( 1 / p )   def _inner_default ( x1 , x2 ) :      order = <str> if all ( a . data . flags . f_contiguous for a in ( x1 , x2 ) ) else <str> if is_real_dtype ( x1 . dtype ) :          if x1 . size > THRESHOLD_MEDIUM :              return np . tensordot ( x1 , x2 , [ range ( x1 . ndim ) ] * 2 )  else :              return np . dot ( x1 . data . ravel ( order ) , x2 . data . ravel ( order ) )   else :          return np . vdot ( x2 . data . ravel ( order ) , x1 . data . ravel ( order ) )   class NumpyTensorSpaceArrayWeighting ( ArrayWeighting ) :      def __init__ ( self , array , exponent = 2.0 ) :          if isinstance ( array , NumpyTensor ) :              array = array . data  elif not isinstance ( array , np . ndarray ) :              array = np . asarray ( array )  super ( NumpyTensorSpaceArrayWeighting , self ) . __init__ ( array , impl = <str> , exponent = exponent )  def __hash__ ( self ) :          return hash ( ( type ( self ) , self . array . tobytes ( ) , self . exponent ) )  def inner ( self , x1 , x2 ) :          if self . exponent != 2.0 :              raise NotImplementedError ( <str> <str> <str> . format ( self . exponent ) )  else :              inner = _inner_default ( x1 * self . array , x2 ) if is_real_dtype ( x1 . dtype ) :                  return float ( inner )  else :                  return complex ( inner )    def norm ( self , x ) :          if self . exponent == 2.0 :              norm_squared = self . inner ( x , x ) . real if norm_squared < 0 :                  norm_squared = 0.0  return float ( np . sqrt ( norm_squared ) )  else :              return float ( _pnorm_diagweight ( x , self . exponent , self . array ) )    class NumpyTensorSpaceConstWeighting ( ConstWeighting ) :      def __init__ ( self , const , exponent = 2.0 ) :          super ( NumpyTensorSpaceConstWeighting , self ) . __init__ ( const , impl = <str> , exponent = exponent )  def inner ( self , x1 , x2 ) :          if self . exponent != 2.0 :              raise NotImplementedError ( <str> <str> <str> . format ( self . exponent ) )  else :              inner = self . const * _inner_default ( x1 , x2 ) if x1 . space . field is None :                  return inner  else :                  return x1 . space . field . element ( inner )    def norm ( self , x ) :          if self . exponent == 2.0 :              return float ( np . sqrt ( self . const ) * _norm_default ( x ) )  elif self . exponent == float ( <str> ) :              return float ( self . const * _pnorm_default ( x , self . exponent ) )  else :              return float ( ( self . const ** ( 1 / self . exponent ) * _pnorm_default ( x , self . exponent ) ) )   def dist ( self , x1 , x2 ) :          if self . exponent == 2.0 :              return float ( np . sqrt ( self . const ) * _norm_default ( x1 - x2 ) )  elif self . exponent == float ( <str> ) :              return float ( self . const * _pnorm_default ( x1 - x2 , self . exponent ) )  else :              return float ( ( self . const ** ( 1 / self . exponent ) * _pnorm_default ( x1 - x2 , self . exponent ) ) )    class NumpyTensorSpaceCustomInner ( CustomInner ) :      def __init__ ( self , inner ) :          super ( NumpyTensorSpaceCustomInner , self ) . __init__ ( inner , impl = <str> )   class NumpyTensorSpaceCustomNorm ( CustomNorm ) :      def __init__ ( self , norm ) :          super ( NumpyTensorSpaceCustomNorm , self ) . __init__ ( norm , impl = <str> )   class NumpyTensorSpaceCustomDist ( CustomDist ) :      def __init__ ( self , dist ) :          super ( NumpyTensorSpaceCustomDist , self ) . __init__ ( dist , impl = <str> )   if __name__ == <str> :      from odl . util . testutils import run_doctests run_doctests ( )   