from __future__ import print_function , division , absolute_import import numpy as np from odl . discr import DiscreteLp , Gradient , Divergence from odl . operator import Operator , PointwiseInner from odl . space import ProductSpace from odl . util import signature_string , indent __all__ = ( <str> , <str> , <str> ) def linear_deform ( template , displacement , out = None ) :      image_pts = template . space . points ( ) for i , vi in enumerate ( displacement ) :          image_pts [ : , i ] += vi . asarray ( ) . ravel ( )  values = template . interpolation ( image_pts . T , out = out , bounds_check = False ) return values . reshape ( template . space . shape )  class LinDeformFixedTempl ( Operator ) :      <str> def __init__ ( self , template , domain = None ) :          space = getattr ( template , <str> , None ) if not isinstance ( space , DiscreteLp ) :              raise TypeError ( <str> <str> . format ( space ) )  self . __template = template if domain is None :              domain = self . template . space . real_space . tangent_bundle  else :              if not isinstance ( domain , ProductSpace ) :                  raise TypeError ( <str> <str> . format ( domain ) )  if not domain . is_power_space :                  raise TypeError ( <str> <str> . format ( domain ) )  if not isinstance ( domain [ 0 ] , DiscreteLp ) :                  raise TypeError ( <str> <str> . format ( domain [ 0 ] ) )  if template . space . partition != domain [ 0 ] . partition :                  raise ValueError ( <str> <str> <str> . format ( template . space . partition , domain [ 0 ] . partition ) )   super ( LinDeformFixedTempl , self ) . __init__ ( domain = domain , range = self . template . space , linear = False )  @ property def template ( self ) :          return self . __template  def _call ( self , displacement , out = None ) :          return linear_deform ( self . template , displacement , out )  def derivative ( self , displacement ) :          if not self . range . is_real :              raise NotImplementedError ( <str> <str> )  displacement = self . domain . element ( displacement ) grad = Gradient ( domain = self . range , method = <str> , pad_mode = <str> ) grad_templ = grad ( self . template ) def_grad = self . domain . element ( [ linear_deform ( gf , displacement ) for gf in grad_templ ] ) return PointwiseInner ( self . domain , def_grad )  def __repr__ ( self ) :          posargs = [ self . template ] optargs = [ ( <str> , self . domain , self . template . space ) ] inner_str = signature_string ( posargs , optargs , mod = <str> , sep = <str> ) return <str> . format ( self . __class__ . __name__ , indent ( inner_str ) )   class LinDeformFixedDisp ( Operator ) :      <str> def __init__ ( self , displacement , templ_space = None ) :          space = getattr ( displacement , <str> , None ) if not isinstance ( space , ProductSpace ) :              raise TypeError ( <str> <str> . format ( space ) )  if not space . is_power_space :              raise TypeError ( <str> <str> . format ( space ) )  if not isinstance ( space [ 0 ] , DiscreteLp ) :              raise TypeError ( <str> <str> . format ( space [ 0 ] ) )  if templ_space is None :              templ_space = displacement . space [ 0 ]  else :              if not isinstance ( templ_space , DiscreteLp ) :                  raise TypeError ( <str> <str> . format ( templ_space ) )  if templ_space . partition != space [ 0 ] . partition :                  raise ValueError ( <str> <str> <str> . format ( templ_space . partition , space [ 0 ] . partition ) )   super ( LinDeformFixedDisp , self ) . __init__ ( domain = templ_space , range = templ_space , linear = True ) self . __displacement = displacement  @ property def displacement ( self ) :          return self . __displacement  def _call ( self , template , out = None ) :          return linear_deform ( template , self . displacement , out )  @ property def inverse ( self ) :          return LinDeformFixedDisp ( - self . displacement , templ_space = self . domain )  @ property def adjoint ( self ) :          div_op = Divergence ( domain = self . displacement . space , method = <str> , pad_mode = <str> ) jacobian_det = self . domain . element ( np . exp ( - div_op ( self . displacement ) ) ) return jacobian_det * self . inverse  def __repr__ ( self ) :          posargs = [ self . displacement ] optargs = [ ( <str> , self . domain , self . displacement . space [ 0 ] ) ] inner_str = signature_string ( posargs , optargs , mod = <str> , sep = <str> ) return <str> . format ( self . __class__ . __name__ , indent ( inner_str ) )   if __name__ == <str> :      from odl . util . testutils import run_doctests run_doctests ( )   