from __future__ import absolute_import , division , print_function import numpy as np from odl . discr import DiscreteLp , Divergence , Gradient from odl . discr . discr_utils import ( _all_interp_equal , _normalize_interp , per_axis_interpolator ) from odl . discr . lp_discr import DiscreteLpElement from odl . operator import Operator , PointwiseInner from odl . space import ProductSpace from odl . space . pspace import ProductSpaceElement from odl . util import indent , signature_string __all__ = ( <str> , <str> , <str> ) def linear_deform ( template , displacement , interp = <str> , out = None ) :      points = template . space . points ( ) for i , vi in enumerate ( displacement ) :          points [ : , i ] += vi . asarray ( ) . ravel ( )  templ_interpolator = per_axis_interpolator ( template , coord_vecs = template . space . grid . coord_vectors , interp = interp ) values = templ_interpolator ( points . T , out = out ) return values . reshape ( template . space . shape )  class LinDeformFixedTempl ( Operator ) :      <str> def __init__ ( self , template , domain = None , interp = <str> ) :          if not isinstance ( template , DiscreteLpElement ) :              raise TypeError ( <str> <str> . format ( template ) )  self . __template = template if domain is None :              domain = self . template . space . real_space . tangent_bundle  else :              if not isinstance ( domain , ProductSpace ) :                  raise TypeError ( <str> <str> . format ( domain ) )  if not domain . is_power_space :                  raise TypeError ( <str> <str> . format ( domain ) )  if not isinstance ( domain [ 0 ] , DiscreteLp ) :                  raise TypeError ( <str> <str> . format ( domain [ 0 ] ) )  if template . space . partition != domain [ 0 ] . partition :                  raise ValueError ( <str> <str> <str> . format ( template . space . partition , domain [ 0 ] . partition ) )   super ( LinDeformFixedTempl , self ) . __init__ ( domain = domain , range = template . space , linear = False ) self . __interp_byaxis = _normalize_interp ( interp , template . space . ndim )  @ property def template ( self ) :          return self . __template  @ property def interp_byaxis ( self ) :          return self . __interp_byaxis  @ property def interp ( self ) :          if _all_interp_equal ( self . interp_byaxis ) :              return self . interp_byaxis [ 0 ]  else :              return self . interp_byaxis   def _call ( self , displacement , out = None ) :          return linear_deform ( self . template , displacement , self . interp , out )  def derivative ( self , displacement ) :          if not self . range . is_real :              raise NotImplementedError ( <str> <str> )  displacement = self . domain . element ( displacement ) grad = Gradient ( domain = self . range , method = <str> , pad_mode = <str> ) grad_templ = grad ( self . template ) def_grad = self . domain . element ( [ linear_deform ( gf , displacement , self . interp ) for gf in grad_templ ] ) return PointwiseInner ( self . domain , def_grad )  def __repr__ ( self ) :          posargs = [ self . template ] optargs = [ ( <str> , self . domain , self . template . space . tangent_bundle ) , ( <str> , self . interp , <str> ) , ] inner_str = signature_string ( posargs , optargs , mod = <str> , sep = <str> ) return <str> . format ( self . __class__ . __name__ , indent ( inner_str ) )   class LinDeformFixedDisp ( Operator ) :      <str> def __init__ ( self , displacement , templ_space = None , interp = <str> ) :          if not isinstance ( displacement , ProductSpaceElement ) :              raise TypeError ( <str> <str> . format ( displacement ) )  if not displacement . space . is_power_space :              raise ValueError ( <str> <str> . format ( displacement . space ) )  if not isinstance ( displacement . space [ 0 ] , DiscreteLp ) :              raise ValueError ( <str> <str> . format ( displacement . space [ 0 ] ) )  self . __displacement = displacement if templ_space is None :              templ_space = displacement . space [ 0 ]  else :              if not isinstance ( templ_space , DiscreteLp ) :                  raise TypeError ( <str> <str> . format ( templ_space ) )  if templ_space . partition != displacement . space [ 0 ] . partition :                  raise ValueError ( <str> <str> <str> . format ( templ_space . partition , displacement . space [ 0 ] . partition ) )   super ( LinDeformFixedDisp , self ) . __init__ ( domain = templ_space , range = templ_space , linear = True ) self . __interp_byaxis = _normalize_interp ( interp , templ_space . ndim )  @ property def interp_byaxis ( self ) :          return self . __interp_byaxis  @ property def interp ( self ) :          if _all_interp_equal ( self . interp_byaxis ) :              return self . interp_byaxis [ 0 ]  else :              return self . interp_byaxis   @ property def displacement ( self ) :          return self . __displacement  def _call ( self , template , out = None ) :          return linear_deform ( template , self . displacement , self . interp , out )  @ property def inverse ( self ) :          return LinDeformFixedDisp ( - self . displacement , templ_space = self . domain , interp = self . interp )  @ property def adjoint ( self ) :          div_op = Divergence ( domain = self . displacement . space , method = <str> , pad_mode = <str> ) jacobian_det = self . domain . element ( np . exp ( - div_op ( self . displacement ) ) ) return jacobian_det * self . inverse  def __repr__ ( self ) :          posargs = [ self . displacement ] optargs = [ ( <str> , self . domain , self . displacement . space [ 0 ] ) , ( <str> , self . interp , <str> ) , ] inner_str = signature_string ( posargs , optargs , mod = <str> , sep = <str> ) return <str> . format ( self . __class__ . __name__ , indent ( inner_str ) )   if __name__ == <str> :      from odl . util . testutils import run_doctests run_doctests ( )   