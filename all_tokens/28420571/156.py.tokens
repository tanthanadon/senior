from __future__ import absolute_import , division , print_function from odl . set import ComplexNumbers , RealNumbers from odl . set . sets import Set from odl . space . base_tensors import Tensor , TensorSpace from odl . space . entry_points import tensor_space_impl from odl . util import ( is_complex_floating_dtype , is_numeric_dtype , is_real_floating_dtype ) __all__ = ( <str> , ) class DiscretizedSpace ( TensorSpace ) :      def __init__ ( self , fspace , tspace ) :          if not isinstance ( fspace , Set ) :              raise TypeError ( <str> <str> . format ( fspace ) )  if not isinstance ( tspace , TensorSpace ) :              raise TypeError ( <str> <str> . format ( tspace ) )  super ( DiscretizedSpace , self ) . __init__ ( tspace . shape , tspace . dtype ) self . __fspace = fspace self . __tspace = tspace  @ property def fspace ( self ) :          return self . __fspace  @ property def tspace ( self ) :          return self . __tspace  @ property def tspace_type ( self ) :          return type ( self . tspace )  def element ( self , inp = None , order = None , ** kwargs ) :          raise NotImplementedError ( <str> )  def __eq__ ( self , other ) :          if other is self :              return True  elif other is None :              return False  else :              return ( super ( DiscretizedSpace , self ) . __eq__ ( other ) and other . fspace == self . fspace and other . tspace == self . tspace )   def __hash__ ( self ) :          return hash ( ( super ( DiscretizedSpace , self ) . __hash__ ( ) , self . fspace , self . tspace ) )  @ property def domain ( self ) :          return self . fspace . domain  def zero ( self ) :          return self . element_type ( self , self . tspace . zero ( ) )  def one ( self ) :          return self . element_type ( self , self . tspace . one ( ) )  @ property def weighting ( self ) :          return self . tspace . weighting  @ property def is_weighted ( self ) :          return getattr ( self . tspace , <str> , False )  @ property def impl ( self ) :          return self . tspace . impl  def _lincomb ( self , a , x1 , b , x2 , out ) :          self . tspace . _lincomb ( a , x1 . tensor , b , x2 . tensor , out . tensor )  def _dist ( self , x1 , x2 ) :          return self . tspace . _dist ( x1 . tensor , x2 . tensor )  def _norm ( self , x ) :          return self . tspace . _norm ( x . tensor )  def _inner ( self , x1 , x2 ) :          return self . tspace . _inner ( x1 . tensor , x2 . tensor )  def _multiply ( self , x1 , x2 , out ) :          self . tspace . _multiply ( x1 . tensor , x2 . tensor , out . tensor )  def _divide ( self , x1 , x2 , out ) :          self . tspace . _divide ( x1 . tensor , x2 . tensor , out . tensor )  @ property def examples ( self ) :          for name , elem in self . fspace . examples :              yield ( name , self . element ( elem ) )   @ property def element_type ( self ) :          return DiscretizedSpaceElement   class DiscretizedSpaceElement ( Tensor ) :      def __init__ ( self , space , tensor ) :          super ( DiscretizedSpaceElement , self ) . __init__ ( space ) self . __tensor = tensor  @ property def tensor ( self ) :          return self . __tensor  @ property def dtype ( self ) :          return self . tensor . dtype  @ property def size ( self ) :          return self . tensor . size  def __len__ ( self ) :          return self . size  def copy ( self ) :          return self . space . element ( self . tensor . copy ( ) )  def asarray ( self , out = None ) :          return self . tensor . asarray ( out = out )  def astype ( self , dtype ) :          return self . space . astype ( dtype ) . element ( self . tensor . astype ( dtype ) )  def __eq__ ( self , other ) :          return ( other in self . space and self . tensor == other . tensor )  def __getitem__ ( self , indices ) :          if isinstance ( indices , type ( self ) ) :              indices = indices . tensor  return self . tensor [ indices ]  def __setitem__ ( self , indices , values ) :          if isinstance ( indices , type ( self ) ) :              indices = indices . tensor  if isinstance ( values , type ( self ) ) :              values = values . tensor  self . tensor . __setitem__ ( indices , values )  def __ipow__ ( self , p ) :          self . tensor . __ipow__ ( p ) return self   def tspace_type ( space , impl , dtype = None ) :      field_type = type ( getattr ( space , <str> , None ) ) if dtype is None :          pass  elif is_real_floating_dtype ( dtype ) :          if field_type is None or field_type == ComplexNumbers :              raise TypeError ( <str> <str> <str> . format ( dtype , field_type ) )   elif is_complex_floating_dtype ( dtype ) :          if field_type is None or field_type == RealNumbers :              raise TypeError ( <str> <str> <str> . format ( dtype , field_type ) )   elif is_numeric_dtype ( dtype ) :          if field_type == ComplexNumbers :              raise TypeError ( <str> <str> . format ( dtype , field_type ) )   try :          return tensor_space_impl ( impl )  except ValueError :          raise NotImplementedError ( <str> <str> <str> . format ( space , impl ) )   if __name__ == <str> :      from odl . util . testutils import run_doctests run_doctests ( )   