from __future__ import print_function , division , absolute_import from builtins import object from itertools import product import numpy as np from odl . operator import Operator from odl . discr . partition import RectPartition from odl . space . base_tensors import TensorSpace from odl . space import FunctionSpace from odl . util import ( is_valid_input_meshgrid , out_shape_from_array , out_shape_from_meshgrid , is_string , is_numeric_dtype , signature_string , indent , dtype_repr , writable_array ) __all__ = ( <str> , <str> , <str> , <str> , <str> ) _SUPPORTED_INTERP_SCHEMES = [ <str> , <str> ] class FunctionSpaceMapping ( Operator ) :      def __init__ ( self , map_type , fspace , partition , tspace , linear = False ) :          map_type , map_type_in = str ( map_type ) . lower ( ) , map_type if map_type not in ( <str> , <str> ) :              raise ValueError ( <str> <str> . format ( map_type_in ) )  if not isinstance ( fspace , FunctionSpace ) :              raise TypeError ( <str> <str> . format ( fspace ) )  if not isinstance ( partition , RectPartition ) :              raise TypeError ( <str> <str> . format ( partition ) )  if not isinstance ( tspace , TensorSpace ) :              raise TypeError ( <str> <str> . format ( tspace ) )  if not fspace . domain . contains_set ( partition ) :              raise ValueError ( <str> <str> <str> . format ( partition , fspace . domain , fspace ) )  if tspace . shape != partition . shape :              raise ValueError ( <str> <str> <str> . format ( tspace . shape , partition . shape ) )  domain = fspace if map_type == <str> else tspace range = tspace if map_type == <str> else fspace super ( FunctionSpaceMapping , self ) . __init__ ( domain , range , linear = linear ) self . __partition = partition if self . is_linear :              if self . domain . field is None :                  raise TypeError ( <str> <str> )  if not is_numeric_dtype ( tspace . dtype ) :                  raise TypeError ( <str> <str> <str> . format ( dtype_repr ( tspace ) ) )  if fspace . field != tspace . field :                  raise ValueError ( <str> <str> <str> . format ( fspace . field , tspace . field ) )    def __eq__ ( self , other ) :          if self is other :              return True  else :              return ( type ( other ) is type ( self ) and self . domain == other . domain and self . range == other . range and self . partition == other . partition )   def __hash__ ( self ) :          return hash ( ( type ( self ) , self . domain , self . range , self . partition ) )  @ property def partition ( self ) :          return self . __partition  @ property def grid ( self ) :          return self . partition . grid   class PointCollocation ( FunctionSpaceMapping ) :      def __init__ ( self , fspace , partition , tspace ) :          linear = getattr ( fspace , <str> , None ) is not None super ( PointCollocation , self ) . __init__ ( <str> , fspace , partition , tspace , linear )  def _call ( self , func , out = None , ** kwargs ) :          mesh = self . grid . meshgrid if out is None :              out = func ( mesh , ** kwargs )  else :              with writable_array ( out ) as out_arr :                  func ( mesh , out = out_arr , ** kwargs )   return out  def __repr__ ( self ) :          posargs = [ self . range , self . grid , self . domain ] inner_str = signature_string ( posargs , [ ] , sep = [ <str> , <str> , <str> ] , mod = [ <str> , <str> ] ) return <str> . format ( self . __class__ . __name__ , indent ( inner_str ) )   class NearestInterpolation ( FunctionSpaceMapping ) :      def __init__ ( self , fspace , partition , tspace , variant = <str> ) :          linear = getattr ( fspace , <str> , None ) is not None super ( NearestInterpolation , self ) . __init__ ( <str> , fspace , partition , tspace , linear ) self . __variant = str ( variant ) . lower ( ) if self . variant not in ( <str> , <str> ) :              raise ValueError ( <str> . format ( variant ) )   @ property def variant ( self ) :          return self . __variant  def _call ( self , x , out = None ) :          def nearest ( arg , out = None ) :              if is_valid_input_meshgrid ( arg , self . grid . ndim ) :                  input_type = <str>  else :                  input_type = <str>  interpolator = _NearestInterpolator ( self . grid . coord_vectors , x , variant = self . variant , input_type = input_type ) return interpolator ( arg , out = out )  return self . range . element ( nearest , vectorized = True )  def __repr__ ( self ) :          posargs = [ self . range , self . grid , self . domain ] optargs = [ ( <str> , self . variant , <str> ) ] inner_str = signature_string ( posargs , optargs , sep = [ <str> , <str> , <str> ] , mod = [ <str> , <str> ] ) return <str> . format ( self . __class__ . __name__ , indent ( inner_str ) )   class LinearInterpolation ( FunctionSpaceMapping ) :      def __init__ ( self , fspace , partition , tspace ) :          if getattr ( fspace , <str> , None ) is None :              raise TypeError ( <str> )  super ( LinearInterpolation , self ) . __init__ ( <str> , fspace , partition , tspace , linear = True )  def _call ( self , x , out = None ) :          def linear ( arg , out = None ) :              if is_valid_input_meshgrid ( arg , self . grid . ndim ) :                  input_type = <str>  else :                  input_type = <str>  interpolator = _LinearInterpolator ( self . grid . coord_vectors , x , input_type = input_type ) return interpolator ( arg , out = out )  return self . range . element ( linear , vectorized = True )  def __repr__ ( self ) :          posargs = [ self . range , self . grid , self . domain ] inner_str = signature_string ( posargs , [ ] , sep = [ <str> , <str> , <str> ] , mod = [ <str> , <str> ] ) return <str> . format ( self . __class__ . __name__ , indent ( inner_str ) )   class PerAxisInterpolation ( FunctionSpaceMapping ) :      def __init__ ( self , fspace , partition , tspace , schemes , nn_variants = <str> ) :          if getattr ( fspace , <str> , None ) is None :              raise TypeError ( <str> )  super ( PerAxisInterpolation , self ) . __init__ ( <str> , fspace , partition , tspace , linear = True ) schemes_in = schemes if is_string ( schemes ) :              scheme = str ( schemes ) . lower ( ) if scheme not in _SUPPORTED_INTERP_SCHEMES :                  raise ValueError ( <str> <str> . format ( schemes_in ) )  schemes = [ scheme ] * self . grid . ndim  else :              schemes = [ str ( scm ) . lower ( ) if scm is not None else None for scm in schemes ]  nn_variants_in = nn_variants if nn_variants is None :              nn_variants = [ <str> if scm == <str> else None for scm in schemes ]  else :              if is_string ( nn_variants ) :                  nn_variants = [ nn_variants if scm == <str> else None for scm in schemes ] if str ( nn_variants_in ) . lower ( ) not in ( <str> , <str> ) :                      raise ValueError ( <str> <str> . format ( nn_variants_in ) )   else :                  nn_variants = [ str ( var ) . lower ( ) if var is not None else None for var in nn_variants ]   for i in range ( self . grid . ndim ) :              if schemes [ i ] not in _SUPPORTED_INTERP_SCHEMES :                  raise ValueError ( <str> <str> . format ( schemes_in [ i ] , i ) )  if ( schemes [ i ] == <str> and nn_variants [ i ] not in ( <str> , <str> ) ) :                  raise ValueError ( <str> <str> . format ( nn_variants_in [ i ] , i ) )  elif schemes [ i ] != <str> and nn_variants [ i ] is not None :                  raise ValueError ( <str> <str> <str> . format ( i , schemes_in [ i ] ) )   self . __schemes = schemes self . __nn_variants = nn_variants  @ property def schemes ( self ) :          return self . __schemes  @ property def nn_variants ( self ) :          return self . __nn_variants  def _call ( self , x , out = None ) :          def per_axis_interp ( arg , out = None ) :              if is_valid_input_meshgrid ( arg , self . grid . ndim ) :                  input_type = <str>  else :                  input_type = <str>  interpolator = _PerAxisInterpolator ( self . grid . coord_vectors , x , schemes = self . schemes , nn_variants = self . nn_variants , input_type = input_type ) return interpolator ( arg , out = out )  return self . range . element ( per_axis_interp , vectorized = True )  def __repr__ ( self ) :          if all ( scm == self . schemes [ 0 ] for scm in self . schemes ) :              schemes = self . schemes [ 0 ]  else :              schemes = self . schemes  posargs = [ self . range , self . grid , self . domain , schemes ] nn_relevant = [ x for x in self . nn_variants if x is not None ] if not nn_relevant :              optargs = [ ]  else :              first_relevant = nn_relevant [ 0 ] if all ( var == first_relevant for var in nn_relevant ) :                  variants = first_relevant  else :                  variants = self . nn_variants  optargs = [ ( <str> , variants , <str> ) ]  inner_str = signature_string ( posargs , optargs , sep = [ <str> , <str> , <str> ] , mod = [ <str> , <str> ] ) return <str> . format ( self . __class__ . __name__ , indent ( inner_str ) )   class _Interpolator ( object ) :      def __init__ ( self , coord_vecs , values , input_type ) :          values = np . asarray ( values ) typ_ = str ( input_type ) . lower ( ) if typ_ not in ( <str> , <str> ) :              raise ValueError ( <str> <str> . format ( input_type ) )  if len ( coord_vecs ) > values . ndim :              raise ValueError ( <str> <str> . format ( len ( coord_vecs ) , values . ndim ) )  for i , p in enumerate ( coord_vecs ) :              if not np . asarray ( p ) . ndim == 1 :                  raise ValueError ( <str> <str> . format ( i ) )  if values . shape [ i ] != len ( p ) :                  raise ValueError ( <str> <str> . format ( len ( p ) , values . shape [ i ] , i ) )   self . coord_vecs = tuple ( np . asarray ( p ) for p in coord_vecs ) self . values = values self . input_type = input_type  def __call__ ( self , x , out = None ) :          ndim = len ( self . coord_vecs ) if self . input_type == <str> :              x = x . reshape ( [ ndim , - 1 ] ) out_shape = out_shape_from_array ( x )  else :              if len ( x ) != ndim :                  raise ValueError ( <str> <str> <str> . format ( len ( x ) , ndim ) )  out_shape = out_shape_from_meshgrid ( x )  if out is not None :              if not isinstance ( out , np . ndarray ) :                  raise TypeError ( <str> <str> . format ( out ) )  if out . shape != out_shape :                  raise ValueError ( <str> <str> . format ( out . shape , out_shape ) )  if out . dtype != self . values . dtype :                  raise ValueError ( <str> <str> <str> . format ( out . dtype , self . values . dtype ) )   indices , norm_distances = self . _find_indices ( x ) return self . _evaluate ( indices , norm_distances , out )  def _find_indices ( self , x ) :          index_vecs = [ ] norm_distances = [ ] for xi , cvec in zip ( x , self . coord_vecs ) :              idcs = np . searchsorted ( cvec , xi ) - 1 idcs [ idcs < 0 ] = 0 idcs [ idcs > cvec . size - 2 ] = cvec . size - 2 index_vecs . append ( idcs ) norm_distances . append ( ( xi - cvec [ idcs ] ) / ( cvec [ idcs + 1 ] - cvec [ idcs ] ) )  return index_vecs , norm_distances  def _evaluate ( self , indices , norm_distances , out = None ) :          raise NotImplementedError ( <str> )   class _NearestInterpolator ( _Interpolator ) :      def __init__ ( self , coord_vecs , values , input_type , variant ) :          super ( _NearestInterpolator , self ) . __init__ ( coord_vecs , values , input_type ) variant_ = str ( variant ) . lower ( ) if variant_ not in ( <str> , <str> ) :              raise ValueError ( <str> . format ( variant_ ) )  self . variant = variant_  def _evaluate ( self , indices , norm_distances , out = None ) :          idx_res = [ ] for i , yi in zip ( indices , norm_distances ) :              if self . variant == <str> :                  idx_res . append ( np . where ( yi <= .5 , i , i + 1 ) )  else :                  idx_res . append ( np . where ( yi < .5 , i , i + 1 ) )   idx_res = tuple ( idx_res ) if out is not None :              out [ : ] = self . values [ idx_res ] return out  else :              return self . values [ idx_res ]    def _compute_nearest_weights_edge ( idcs , ndist , variant ) :      lo = ( ndist < 0 ) hi = ( ndist > 1 ) if variant == <str> :          w_lo = np . where ( ndist <= 0.5 , 1.0 , 0.0 )  else :          w_lo = np . where ( ndist < 0.5 , 1.0 , 0.0 )  w_lo [ lo ] = 0 w_lo [ hi ] = 1 if variant == <str> :          w_hi = np . where ( ndist <= 0.5 , 0.0 , 1.0 )  else :          w_hi = np . where ( ndist < 0.5 , 0.0 , 1.0 )  w_hi [ lo ] = 1 w_hi [ hi ] = 0 edge = [ idcs , idcs + 1 ] edge [ 0 ] [ hi ] = - 1 edge [ 1 ] [ lo ] = 0 return w_lo , w_hi , edge  def _compute_linear_weights_edge ( idcs , ndist ) :      lo = np . where ( ndist < 0 ) hi = np . where ( ndist > 1 ) w_lo = ( 1 - ndist ) w_lo [ lo ] = 0 w_lo [ hi ] += 1 w_hi = np . copy ( ndist ) w_hi [ lo ] += 1 w_hi [ hi ] = 0 edge = [ idcs , idcs + 1 ] edge [ 0 ] [ hi ] = - 1 edge [ 1 ] [ lo ] = 0 return w_lo , w_hi , edge  def _create_weight_edge_lists ( indices , norm_distances , schemes , variants ) :      low_weights = [ ] high_weights = [ ] edge_indices = [ ] for i , ( idcs , yi , scm , var ) in enumerate ( zip ( indices , norm_distances , schemes , variants ) ) :          if scm == <str> :              w_lo , w_hi , edge = _compute_nearest_weights_edge ( idcs , yi , var )  elif scm == <str> :              w_lo , w_hi , edge = _compute_linear_weights_edge ( idcs , yi )  else :              raise ValueError ( <str> <str> . format ( scm , i ) )  low_weights . append ( w_lo ) high_weights . append ( w_hi ) edge_indices . append ( edge )  return low_weights , high_weights , edge_indices  class _PerAxisInterpolator ( _Interpolator ) :      def __init__ ( self , coord_vecs , values , input_type , schemes , nn_variants ) :          super ( _PerAxisInterpolator , self ) . __init__ ( coord_vecs , values , input_type ) self . schemes = schemes self . nn_variants = nn_variants  def _evaluate ( self , indices , norm_distances , out = None ) :          vslice = ( slice ( None ) , ) + ( None , ) * ( self . values . ndim - len ( indices ) ) if out is None :              out_shape = out_shape_from_meshgrid ( norm_distances ) out_dtype = self . values . dtype out = np . zeros ( out_shape , dtype = out_dtype )  else :              out [ : ] = 0.0  low_weights , high_weights , edge_indices = _create_weight_edge_lists ( indices , norm_distances , self . schemes , self . nn_variants ) for lo_hi , edge in zip ( product ( * ( [ [ <str> , <str> ] ] * len ( indices ) ) ) , product ( * edge_indices ) ) :              weight = 1.0 for lh , w_lo , w_hi in zip ( lo_hi , low_weights , high_weights ) :                  if lh == <str> :                      weight = weight * w_lo  else :                      weight = weight * w_hi   out += np . asarray ( self . values [ edge ] ) * weight [ vslice ]  return np . array ( out , copy = False , ndmin = 1 )   class _LinearInterpolator ( _PerAxisInterpolator ) :      def __init__ ( self , coord_vecs , values , input_type ) :          super ( _LinearInterpolator , self ) . __init__ ( coord_vecs , values , input_type , schemes = [ <str> ] * len ( coord_vecs ) , nn_variants = [ None ] * len ( coord_vecs ) )   if __name__ == <str> :      from odl . util . testutils import run_doctests run_doctests ( )   