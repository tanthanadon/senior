<str> import numpy as np import odl SPLIT_METHOD = <str> SPLIT_NUMBER = 20 RANDOM = True reco_space = odl . uniform_discr ( min_pt = [ - 40.0 , - 40.0 ] , max_pt = [ 40.0 , 40.0 ] , shape = [ 1024 , 1024 ] ) phantom = odl . phantom . shepp_logan ( reco_space , modified = True ) geometry = odl . tomo . parallel_beam_geometry ( reco_space ) if SPLIT_METHOD == <str> :      ns = geometry . angles . size // SPLIT_NUMBER ray_trafos = [ odl . tomo . RayTransform ( reco_space , geometry [ i * ns : ( i + 1 ) * ns ] ) for i in range ( SPLIT_NUMBER ) ]  elif SPLIT_METHOD == <str> :      ray_trafos = [ odl . tomo . RayTransform ( reco_space , geometry [ i : : SPLIT_NUMBER ] ) for i in range ( SPLIT_NUMBER ) ]  else :      raise ValueError ( <str> . format ( SPLIT_METHOD ) )  data_spaces = [ op . range for op in ray_trafos ] noisefree_data = [ op ( phantom ) for op in ray_trafos ] data = [ proj + 0.10 * np . ptp ( proj ) * odl . phantom . white_noise ( proj . space ) for proj in noisefree_data ] tv_functionals = [ ] tv_operators = [ ] tv_stepsizes = [ ] reco_shape = reco_space . shape reco_dim = len ( reco_shape ) for dim in range ( reco_dim ) :      partial_der = odl . PartialDerivative ( reco_space , dim , pad_mode = <str> ) all_points = list ( np . ndindex ( reco_shape ) ) even_pts = [ list ( p ) for p in all_points if p [ dim ] % 2 == 0 ] even_pts = np . array ( even_pts ) . T . tolist ( ) odd_pts = [ list ( p ) for p in all_points if p [ dim ] % 2 == 1 ] odd_pts = np . array ( odd_pts ) . T . tolist ( ) op1 = reco_space . cell_sides [ dim ] * odl . SamplingOperator ( reco_space , even_pts ) * partial_der op2 = reco_space . cell_sides [ dim ] * odl . SamplingOperator ( reco_space , odd_pts ) * partial_der tv_functionals += [ odl . solvers . L1Norm ( op1 . range ) , odl . solvers . L1Norm ( op2 . range ) ] tv_operators += [ op1 , op2 ] tv_stepsizes += [ 0.5 / reco_shape [ dim ] , 0.5 / reco_shape [ dim ] ]  nonneg_functional = odl . solvers . IndicatorNonnegativity ( reco_space ) nonneg_operator = odl . IdentityOperator ( reco_space ) nonneg_stepsize = 1.0 data_fit_functionals = [ 1.0 * odl . solvers . L2NormSquared ( ds ) . translated ( rhs ) for ( ds , rhs ) in zip ( data_spaces , data ) ] data_fit_stepsizes = [ 1.0 / ( 1e-6 + op ( op . adjoint ( ds . one ( ) ) ) ) for ( ds , op ) in zip ( data_spaces , ray_trafos ) ] x = reco_space . zero ( ) g = [ nonneg_functional ] + data_fit_functionals + tv_functionals L = [ nonneg_operator ] + ray_trafos + tv_operators inner_stepsizes = [ nonneg_stepsize ] + data_fit_stepsizes + tv_stepsizes odl . solvers . adupdates ( x , g , L , stepsize = 1.0 , inner_stepsizes = inner_stepsizes , niter = 5 , random = RANDOM , callback = None , callback_loop = None ) x . show ( vmin = 0.0 , vmax = 1.0 )  