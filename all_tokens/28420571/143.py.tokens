from __future__ import print_function , division , absolute_import from builtins import object import inspect import numpy as np import sys import warnings from odl . set import RealNumbers , ComplexNumbers , Set , LinearSpace from odl . set . space import LinearSpaceElement from odl . util import ( is_real_dtype , is_complex_floating_dtype , dtype_repr , dtype_str , complex_dtype , real_dtype , signature_string , is_real_floating_dtype , is_valid_input_array , is_valid_input_meshgrid , out_shape_from_array , out_shape_from_meshgrid , vectorize , writable_array ) from odl . util . utility import preload_first_arg , getargspec __all__ = ( <str> , ) def _check_out_arg ( func ) :      if sys . version_info . major > 2 :          spec = inspect . getfullargspec ( func ) kw_only = spec . kwonlyargs  else :          spec = inspect . getargspec ( func ) kw_only = ( )  if spec . varargs is not None :          raise TypeError ( <str> )  pos_args = spec . args pos_defaults = ( ) if spec . defaults is None else spec . defaults has_out = <str> in pos_args or <str> in kw_only if <str> in pos_args :          has_out = True out_is_optional = ( pos_args . index ( <str> ) >= len ( pos_args ) - len ( pos_defaults ) )  elif <str> in kw_only :          has_out = out_is_optional = True  else :          has_out = out_is_optional = False  return has_out , out_is_optional  def _default_in_place ( func , x , out , ** kwargs ) :      result = np . array ( func . _call_out_of_place ( x , ** kwargs ) , copy = False ) if result . dtype == object :          flat_results = result . ravel ( ) if is_valid_input_array ( x , func . domain . ndim ) :              scalar_out_shape = out_shape_from_array ( x )  elif is_valid_input_meshgrid ( x , func . domain . ndim ) :              scalar_out_shape = out_shape_from_meshgrid ( x )  else :              raise RuntimeError ( <str> )  bcast_results = [ np . broadcast_to ( res , scalar_out_shape ) for res in flat_results ] result = np . array ( bcast_results , dtype = func . scalar_out_dtype ) result = result . reshape ( func . out_shape + scalar_out_shape )  try :          reshaped = result . reshape ( out . shape )  except ValueError :          out [ : ] = result  else :          out [ : ] = reshaped  return out  def _default_out_of_place ( func , x , ** kwargs ) :      if is_valid_input_array ( x , func . domain . ndim ) :          scalar_out_shape = out_shape_from_array ( x )  elif is_valid_input_meshgrid ( x , func . domain . ndim ) :          scalar_out_shape = out_shape_from_meshgrid ( x )  else :          raise TypeError ( <str> <str> )  dtype = func . space . scalar_out_dtype if dtype is None :          dtype = np . result_type ( * x )  out_shape = func . out_shape + scalar_out_shape out = np . empty ( out_shape , dtype = dtype ) func . _call_in_place ( x , out = out , ** kwargs ) return out  def _fcall_out_type ( fcall ) :      if isinstance ( fcall , FunctionSpaceElement ) :          call_has_out = fcall . _call_has_out call_out_optional = fcall . _call_out_optional  elif hasattr ( fcall , <str> ) and hasattr ( fcall , <str> ) :          if fcall . nin != 1 :              raise ValueError ( <str> <str> <str> . format ( fcall . __name__ , fcall . nin ) )  if fcall . nout > 1 :              raise ValueError ( <str> <str> <str> . format ( fcall . __name__ , fcall . nout ) )  call_has_out = call_out_optional = ( fcall . nout == 1 )  elif inspect . isfunction ( fcall ) :          call_has_out , call_out_optional = _check_out_arg ( fcall )  elif callable ( fcall ) :          call_has_out , call_out_optional = _check_out_arg ( fcall . __call__ )  else :          raise TypeError ( <str> . format ( fcall ) )  return call_has_out , call_out_optional  class FunctionSpace ( LinearSpace ) :      <str> def __init__ ( self , domain , out_dtype = float ) :          if not isinstance ( domain , Set ) :              raise TypeError ( <str> <str> . format ( domain ) )  self . __domain = domain if out_dtype is None :              self . __out_dtype = None  else :              self . __out_dtype = np . dtype ( out_dtype )  if is_real_dtype ( self . out_dtype ) :              field = RealNumbers ( )  elif is_complex_floating_dtype ( self . out_dtype ) :              field = ComplexNumbers ( )  else :              field = None  super ( FunctionSpace , self ) . __init__ ( field ) if self . field == RealNumbers ( ) :              self . __real_out_dtype = self . out_dtype self . __real_space = self self . __complex_out_dtype = complex_dtype ( self . out_dtype , default = np . dtype ( object ) ) self . __complex_space = None  elif self . field == ComplexNumbers ( ) :              self . __real_out_dtype = real_dtype ( self . out_dtype ) self . __real_space = None self . __complex_out_dtype = self . out_dtype self . __complex_space = self  else :              self . __real_out_dtype = None self . __real_space = None self . __complex_out_dtype = None self . __complex_space = None   @ property def domain ( self ) :          return self . __domain  @ property def out_dtype ( self ) :          return self . __out_dtype  @ property def scalar_out_dtype ( self ) :          return getattr ( self . out_dtype , <str> , None )  @ property def real_out_dtype ( self ) :          if self . __real_out_dtype is None :              raise AttributeError ( <str> <str> . format ( dtype_repr ( self . scalar_out_dtype ) ) )  else :              return self . __real_out_dtype   @ property def complex_out_dtype ( self ) :          if self . __complex_out_dtype is None :              raise AttributeError ( <str> <str> . format ( dtype_repr ( self . scalar_out_dtype ) ) )  else :              return self . __complex_out_dtype   @ property def is_real ( self ) :          return is_real_floating_dtype ( self . scalar_out_dtype )  @ property def is_complex ( self ) :          return is_complex_floating_dtype ( self . scalar_out_dtype )  @ property def out_shape ( self ) :          return getattr ( self . out_dtype , <str> , ( ) )  @ property def tensor_valued ( self ) :          return ( self . out_shape != ( ) )  @ property def real_space ( self ) :          return self . astype ( self . real_out_dtype )  @ property def complex_space ( self ) :          return self . astype ( self . complex_out_dtype )  def element ( self , fcall = None , vectorized = True ) :          if fcall is None :              return self . zero ( )  elif fcall in self :              return fcall  elif callable ( fcall ) :              if not vectorized :                  if hasattr ( fcall , <str> ) and hasattr ( fcall , <str> ) :                      warnings . warn ( <str> <str> . format ( fcall ) , RuntimeWarning )  has_out , _ = _check_out_arg ( fcall ) if has_out :                      raise TypeError ( <str> <str> )  if self . field is not None :                      otypes = [ self . scalar_out_dtype ]  else :                      otypes = [ ]  fcall = vectorize ( otypes = otypes ) ( fcall )  return self . element_type ( self , fcall )  else :              if np . shape ( fcall ) != self . out_shape :                  raise ValueError ( <str> <str> <str> . format ( self . out_shape ) )  fcalls = np . array ( fcall , dtype = object , ndmin = 1 ) . ravel ( ) . tolist ( ) if not vectorized :                  if self . field == RealNumbers ( ) :                      otypes = [ <str> ]  elif self . field == ComplexNumbers ( ) :                      otypes = [ <str> ]  else :                      otypes = [ ]  fcalls = [ f if np . isscalar ( f ) else vectorize ( otypes = otypes ) ( f ) for f in fcalls ]  def wrapper ( x , out = None , ** kwargs ) :                  if is_valid_input_meshgrid ( x , self . domain . ndim ) :                      scalar_out_shape = out_shape_from_meshgrid ( x )  elif is_valid_input_array ( x , self . domain . ndim ) :                      scalar_out_shape = out_shape_from_array ( x )  else :                      raise RuntimeError ( <str> )  if out is None :                      results = [ ] for f in fcalls :                          if np . isscalar ( f ) :                              results . append ( f )  elif not callable ( f ) :                              raise TypeError ( <str> <str> . format ( f ) )  elif hasattr ( f , <str> ) and hasattr ( f , <str> ) :                              results . append ( f ( x , ** kwargs ) )  else :                              try :                                  has_out = <str> in getargspec ( f ) . args  except TypeError :                                  raise TypeError ( <str> <str> . format ( f ) )  else :                                  if has_out :                                      out = np . empty ( scalar_out_shape , dtype = self . scalar_out_dtype ) f ( x , out = out , ** kwargs ) results . append ( out )  else :                                      results . append ( f ( x , ** kwargs ) )     bcast_results = [ ] for res in results :                          try :                              reshaped = np . reshape ( res , scalar_out_shape )  except ValueError :                              bcast_results . append ( np . broadcast_to ( res , scalar_out_shape ) )  else :                              bcast_results . append ( reshaped )   out_arr = np . array ( bcast_results , dtype = self . scalar_out_dtype ) return out_arr . reshape ( self . out_shape + scalar_out_shape )  else :                      with writable_array ( out ) as out_arr :                          out_comps = out . reshape ( ( - 1 , ) + scalar_out_shape ) for f , out_comp in zip ( fcalls , out_comps ) :                              if np . isscalar ( f ) :                                  out_comp [ : ] = f  else :                                  has_out , _ = _fcall_out_type ( f ) if has_out :                                      f ( x , out = out_comp , ** kwargs )  else :                                      out_comp [ : ] = f ( x , ** kwargs )       return self . element_type ( self , wrapper )   def zero ( self ) :          def zero_vec ( x , out = None , ** kwargs ) :              if is_valid_input_meshgrid ( x , self . domain . ndim ) :                  scalar_out_shape = out_shape_from_meshgrid ( x )  elif is_valid_input_array ( x , self . domain . ndim ) :                  scalar_out_shape = out_shape_from_array ( x )  else :                  raise TypeError ( <str> )  out_shape = self . out_shape + scalar_out_shape if out is None :                  return np . zeros ( out_shape , dtype = self . scalar_out_dtype )  else :                  fill_value = np . zeros ( 1 , dtype = self . scalar_out_dtype ) [ 0 ] out . fill ( fill_value )   return self . element_type ( self , zero_vec )  def one ( self ) :          def one_vec ( x , out = None , ** kwargs ) :              if is_valid_input_meshgrid ( x , self . domain . ndim ) :                  scalar_out_shape = out_shape_from_meshgrid ( x )  elif is_valid_input_array ( x , self . domain . ndim ) :                  scalar_out_shape = out_shape_from_array ( x )  else :                  raise TypeError ( <str> )  out_shape = self . out_shape + scalar_out_shape if out is None :                  return np . ones ( out_shape , dtype = self . scalar_out_dtype )  else :                  fill_value = np . ones ( 1 , dtype = self . scalar_out_dtype ) [ 0 ] out . fill ( fill_value )   return self . element_type ( self , one_vec )  def __eq__ ( self , other ) :          if other is self :              return True  return ( type ( other ) is type ( self ) and self . domain == other . domain and self . out_dtype == other . out_dtype )  def __hash__ ( self ) :          return hash ( ( type ( self ) , self . domain , self . out_dtype ) )  def __contains__ ( self , other ) :          return ( isinstance ( other , self . element_type ) and other . space == self )  def _astype ( self , out_dtype ) :          return type ( self ) ( self . domain , out_dtype = out_dtype )  def astype ( self , out_dtype ) :          out_dtype = np . dtype ( out_dtype ) if out_dtype == self . out_dtype :              return self  real_dtype = getattr ( self , <str> , None ) if real_dtype is None :              return self . _astype ( out_dtype )  else :              if out_dtype == real_dtype :                  if self . __real_space is None :                      self . __real_space = self . _astype ( out_dtype )  return self . __real_space  elif out_dtype == self . complex_out_dtype :                  if self . __complex_space is None :                      self . __complex_space = self . _astype ( out_dtype )  return self . __complex_space  else :                  return self . _astype ( out_dtype )    def _lincomb ( self , a , f1 , b , f2 , out ) :          f1_copy = f1 . copy ( ) f2_copy = f2 . copy ( ) def lincomb_oop ( x , ** kwargs ) :              out = a * np . asarray ( f1_copy ( x , ** kwargs ) , dtype = self . scalar_out_dtype ) tmp = b * np . asarray ( f2_copy ( x , ** kwargs ) , dtype = self . scalar_out_dtype ) out += tmp return out  out . _call_out_of_place = lincomb_oop decorator = preload_first_arg ( out , <str> ) out . _call_in_place = decorator ( _default_in_place ) out . _call_has_out = out . _call_out_optional = False return out  def _multiply ( self , f1 , f2 , out ) :          f1_copy = f1 . copy ( ) f2_copy = f2 . copy ( ) def product_oop ( x , ** kwargs ) :              return np . asarray ( f1_copy ( x , ** kwargs ) * f2_copy ( x , ** kwargs ) , dtype = self . scalar_out_dtype )  out . _call_out_of_place = product_oop decorator = preload_first_arg ( out , <str> ) out . _call_in_place = decorator ( _default_in_place ) out . _call_has_out = out . _call_out_optional = False return out  def _divide ( self , f1 , f2 , out ) :          f1_copy = f1 . copy ( ) f2_copy = f2 . copy ( ) def quotient_oop ( x , ** kwargs ) :              return np . asarray ( f1_copy ( x , ** kwargs ) / f2_copy ( x , ** kwargs ) , dtype = self . scalar_out_dtype )  out . _call_out_of_place = quotient_oop decorator = preload_first_arg ( out , <str> ) out . _call_in_place = decorator ( _default_in_place ) out . _call_has_out = out . _call_out_optional = False return out  def _scalar_power ( self , f , p , out ) :          f_copy = f . copy ( ) def pow_posint ( x , n ) :              if isinstance ( x , np . ndarray ) :                  y = x . copy ( ) return ipow_posint ( y , n )  else :                  return x ** n   def ipow_posint ( x , n ) :              if n == 1 :                  return x  elif n % 2 == 0 :                  x *= x return ipow_posint ( x , n // 2 )  else :                  tmp = x . copy ( ) x *= x ipow_posint ( x , n // 2 ) x *= tmp return x   def power_oop ( x , ** kwargs ) :              if p == 0 :                  return self . one ( )  elif p == int ( p ) and p >= 1 :                  return np . asarray ( pow_posint ( f_copy ( x , ** kwargs ) , int ( p ) ) , dtype = self . scalar_out_dtype )  else :                  result = np . power ( f_copy ( x , ** kwargs ) , p ) return result . astype ( self . scalar_out_dtype )   out . _call_out_of_place = power_oop decorator = preload_first_arg ( out , <str> ) out . _call_in_place = decorator ( _default_in_place ) out . _call_has_out = out . _call_out_optional = False return out  def _realpart ( self , f ) :          def f_re ( x , ** kwargs ) :              result = np . asarray ( f ( x , ** kwargs ) , dtype = self . scalar_out_dtype ) return result . real  if is_real_dtype ( self . out_dtype ) :              return f  else :              return self . real_space . element ( f_re )   def _imagpart ( self , f ) :          def f_im ( x , ** kwargs ) :              result = np . asarray ( f ( x , ** kwargs ) , dtype = self . scalar_out_dtype ) return result . imag  if is_real_dtype ( self . out_dtype ) :              return self . zero ( )  else :              return self . real_space . element ( f_im )   def _conj ( self , f ) :          def f_conj ( x , ** kwargs ) :              result = np . asarray ( f ( x , ** kwargs ) , dtype = self . scalar_out_dtype ) return result . conj ( )  if is_real_dtype ( self . out_dtype ) :              return f  else :              return self . element ( f_conj )   @ property def byaxis_out ( self ) :          space = self class FspaceByaxisOut ( object ) :              def __getitem__ ( self , indices ) :                  try :                      iter ( indices )  except TypeError :                      newshape = space . out_shape [ indices ]  else :                      newshape = tuple ( space . out_shape [ int ( i ) ] for i in indices )  dtype = ( space . scalar_out_dtype , newshape ) return FunctionSpace ( space . domain , out_dtype = dtype )  def __repr__ ( self ) :                  return repr ( space ) + <str>   return FspaceByaxisOut ( )  @ property def byaxis_in ( self ) :          space = self class FspaceByaxisIn ( object ) :              def __getitem__ ( self , indices ) :                  domain = space . domain [ indices ] return FunctionSpace ( domain , out_dtype = space . out_dtype )  def __repr__ ( self ) :                  return repr ( space ) + <str>   return FspaceByaxisIn ( )  @ property def examples ( self ) :          mins = self . domain . min ( ) maxs = self . domain . max ( ) means = ( maxs + mins ) / 2.0 stds = ( maxs - mins ) / 4.0 ndim = getattr ( self . domain , <str> , 0 ) yield ( <str> , self . zero ( ) ) yield ( <str> , self . one ( ) ) def step_fun ( x ) :              return ( x [ 0 ] > means [ 0 ] )  yield ( <str> , self . element ( step_fun ) ) def cube_fun ( x ) :              result = True for points , mean , std in zip ( x , means , stds ) :                  result = np . logical_and ( result , points < mean + std ) result = np . logical_and ( result , points > mean - std )  return result  yield ( <str> , self . element ( cube_fun ) ) if ndim > 1 :              def ball_fun ( x ) :                  r = sum ( ( xi - mean ) ** 2 / std ** 2 for xi , mean , std in zip ( x , means , stds ) ) return r < 1.0  yield ( <str> , self . element ( ball_fun ) )  def gaussian_fun ( x ) :              r2 = sum ( ( xi - mean ) ** 2 / ( 2 * std ** 2 ) for xi , mean , std in zip ( x , means , stds ) ) return np . exp ( - r2 )  yield ( <str> , self . element ( gaussian_fun ) ) for axis in range ( ndim ) :              def gradient_fun ( x ) :                  return ( x [ axis ] - mins [ axis ] ) / ( maxs [ axis ] - mins [ axis ] )  yield ( <str> . format ( axis ) , self . element ( gradient_fun ) )  if ndim > 1 :              def all_gradient_fun ( x ) :                  return sum ( ( xi - xmin ) / ( xmax - xmin ) for xi , xmin , xmax in zip ( x , mins , maxs ) )  yield ( <str> , self . element ( all_gradient_fun ) )   @ property def element_type ( self ) :          return FunctionSpaceElement  def __repr__ ( self ) :          posargs = [ self . domain ] optargs = [ ( <str> , dtype_str ( self . out_dtype ) , <str> ) ] if ( self . tensor_valued or self . scalar_out_dtype in ( float , complex , int , bool ) ) :              optmod = <str>  else :              optmod = <str>  inner_str = signature_string ( posargs , optargs , mod = [ <str> , optmod ] ) return <str> . format ( self . __class__ . __name__ , inner_str )  def __str__ ( self ) :          return repr ( self )   class FunctionSpaceElement ( LinearSpaceElement ) :      def __init__ ( self , fspace , fcall ) :          super ( FunctionSpaceElement , self ) . __init__ ( fspace ) self . _call_has_out , self . _call_out_optional = _fcall_out_type ( fcall ) if not self . _call_has_out :              decorator = preload_first_arg ( self , <str> ) self . _call_in_place = decorator ( _default_in_place ) self . _call_out_of_place = fcall  elif self . _call_out_optional :              self . _call_in_place = self . _call_out_of_place = fcall  else :              decorator = preload_first_arg ( self , <str> ) self . _call_out_of_place = decorator ( _default_out_of_place ) self . _call_in_place = fcall   @ property def domain ( self ) :          return self . space . domain  @ property def out_dtype ( self ) :          return self . space . out_dtype  @ property def scalar_out_dtype ( self ) :          return self . space . scalar_out_dtype  @ property def out_shape ( self ) :          return self . space . out_shape  @ property def tensor_valued ( self ) :          return self . space . tensor_valued  def _call ( self , x , out = None , ** kwargs ) :          if out is None :              return self . _call_out_of_place ( x , ** kwargs )  else :              self . _call_in_place ( x , out = out , ** kwargs )   def __call__ ( self , x , out = None , ** kwargs ) :          bounds_check = kwargs . pop ( <str> , self . space . field is not None ) if bounds_check and not hasattr ( self . domain , <str> ) :              raise AttributeError ( <str> <str> <str> . format ( self . domain ) )  if bounds_check and not hasattr ( self . space . field , <str> ) :              raise AttributeError ( <str> <str> <str> . format ( self . space . field ) )  ndim = getattr ( self . domain , <str> , None ) if is_valid_input_meshgrid ( x , ndim ) :              scalar_in = False scalar_out_shape = out_shape_from_meshgrid ( x ) scalar_out = False if ndim == 1 :                  x = x [ 0 ] [ None , ... ]   elif is_valid_input_array ( x , ndim ) :              x = np . asarray ( x ) scalar_in = False scalar_out_shape = out_shape_from_array ( x ) scalar_out = False  elif x in self . domain :              x = np . atleast_2d ( x ) . T scalar_in = True scalar_out_shape = ( 1 , ) scalar_out = ( out is None and not self . space . tensor_valued )  else :              txt_1d = <str> if ndim == 1 else <str> raise TypeError ( <str> <str> <str> <str> <str> <str> . format ( x , txt_1d , domain = self . domain ) )  if bounds_check :              if not self . domain . contains_all ( x ) :                  raise ValueError ( <str> <str> . format ( self . domain ) )   if scalar_in :              out_shape = self . out_shape  else :              out_shape = self . out_shape + scalar_out_shape  if out is None :              if ndim == 1 :                  try :                      out = self . _call ( x , ** kwargs )  except ( TypeError , IndexError ) :                      out = self . _call ( x [ 0 ] , ** kwargs )   else :                  out = self . _call ( x , ** kwargs )  if isinstance ( out , np . ndarray ) or np . isscalar ( out ) :                  out = np . asarray ( out , dtype = self . space . scalar_out_dtype ) if scalar_in :                      out = np . squeeze ( out )  elif ndim == 1 and out . shape == ( 1 , ) + out_shape :                      out = out . reshape ( out_shape )  if out_shape != ( ) and out . shape != out_shape :                      out = np . broadcast_to ( out , out_shape ) if not out . flags . writeable :                          out = out . copy ( )    elif self . space . tensor_valued :                  results = np . array ( out ) if results . dtype == object or scalar_in :                      bcast_res = [ ] for res in results . ravel ( ) :                          if ndim == 1 :                              shp = getattr ( res , <str> , ( ) ) if shp and shp [ 0 ] == 1 :                                  res = res . reshape ( res . shape [ 1 : ] )   bcast_res . append ( np . broadcast_to ( res , scalar_out_shape ) )  out_arr = np . array ( bcast_res , dtype = self . space . scalar_out_dtype )  elif ( self . scalar_out_dtype is not None and results . dtype != self . scalar_out_dtype ) :                      raise ValueError ( <str> <str> . format ( dtype_repr ( results . dtype ) , dtype_repr ( self . space . scalar_out_dtype ) ) )  else :                      out_arr = results  out = out_arr . reshape ( out_shape )  else :                  raise RuntimeError ( <str> )   else :              if not isinstance ( out , np . ndarray ) :                  raise TypeError ( <str> <str> )  if out_shape != ( 1 , ) and out . shape != out_shape :                  raise ValueError ( <str> <str> <str> . format ( out . shape , out_shape ) )  if ( self . out_dtype is not None and out . dtype != self . scalar_out_dtype ) :                  raise ValueError ( <str> <str> . format ( out . dtype , self . out_dtype ) )  if ndim == 1 and not self . tensor_valued :                  try :                      self . _call ( x , out = out , ** kwargs )  except TypeError :                      self . _call ( x [ 0 ] , out = out , ** kwargs )   else :                  self . _call ( x , out = out , ** kwargs )   if bounds_check :              if not self . space . field . contains_all ( out ) :                  raise ValueError ( <str> <str> <str> . format ( self . space . field ) )   if scalar_out :              if self . space . field is None :                  return out . ravel ( ) [ 0 ]  else :                  return self . space . field . element ( out . ravel ( ) [ 0 ] )   else :              return out   def assign ( self , other ) :          if other not in self . space :              raise TypeError ( <str> <str> <str> . format ( other , self . space ) )  self . _call_in_place = other . _call_in_place self . _call_out_of_place = other . _call_out_of_place self . _call_has_out = other . _call_has_out self . _call_out_optional = other . _call_out_optional  def copy ( self ) :          result = self . space . element ( ) result . assign ( self ) return result  def __eq__ ( self , other ) :          if other is self :              return True  elif other not in self . space :              return False  if ( self . _call_has_out != other . _call_has_out or self . _call_out_optional != other . _call_out_optional ) :              return False  if self . _call_has_out :              funcs_equal = self . _call_in_place == other . _call_in_place  else :              funcs_equal = self . _call_out_of_place == other . _call_out_of_place  return self . space == other . space and funcs_equal  def __pow__ ( self , p ) :          out = self . space . element ( ) self . space . _scalar_power ( self , p , out = out ) return out  def __ipow__ ( self , p ) :          return self . space . _scalar_power ( self , p , out = self )  @ property def real ( self ) :          return self . space . _realpart ( self )  @ property def imag ( self ) :          return self . space . _imagpart ( self )  def conj ( self ) :          return self . space . _conj ( self )  def __str__ ( self ) :          if self . _call_has_out :              func = self . _call_in_place  else :              func = self . _call_out_of_place  fname = getattr ( func , <str> , getattr ( func , <str> , str ( func ) ) ) return <str> . format ( fname , self . domain , self . out_dtype )  def __repr__ ( self ) :          if self . _call_has_out :              func = self . _call_in_place  else :              func = self . _call_out_of_place  return <str> . format ( self . space , func )   if __name__ == <str> :      from odl . util . testutils import run_doctests run_doctests ( )   