from __future__ import absolute_import , division , print_function from future . moves . itertools import zip_longest import inspect import sys from collections import OrderedDict from contextlib import contextmanager from functools import wraps from itertools import product import numpy as np __all__ = ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , ) REPR_PRECISION = 4 TYPE_MAP_R2C = { np . dtype ( dtype ) : np . result_type ( dtype , 1j ) for dtype in np . sctypes [ <str> ] } TYPE_MAP_C2R = { cdt : np . empty ( 0 , dtype = cdt ) . real . dtype for rdt , cdt in TYPE_MAP_R2C . items ( ) } TYPE_MAP_C2R . update ( { k : k for k in TYPE_MAP_R2C . keys ( ) } ) if sys . version_info . major < 3 :      getargspec = inspect . getargspec  else :      getargspec = inspect . getfullargspec  def indent ( string , indent_str = <str> ) :      return <str> . join ( indent_str + row for row in string . splitlines ( ) )  def dedent ( string , indent_str = <str> , max_levels = None ) :      if len ( indent_str ) == 0 :          return string  lines = string . splitlines ( ) def num_indents ( line ) :          max_num = int ( np . ceil ( len ( line ) / len ( indent_str ) ) ) for i in range ( max_num ) :              if line . startswith ( indent_str ) :                  line = line [ len ( indent_str ) : ]  else :                  break   return i  num_levels = num_indents ( min ( lines , key = num_indents ) ) if max_levels is not None :          num_levels = min ( num_levels , max_levels )  dedent_len = num_levels * len ( indent_str ) return <str> . join ( line [ dedent_len : ] for line in lines )  @ contextmanager def npy_printoptions ( ** extra_opts ) :      orig_opts = np . get_printoptions ( ) try :          new_opts = orig_opts . copy ( ) new_opts . update ( extra_opts ) np . set_printoptions ( ** new_opts ) yield  finally :          np . set_printoptions ( ** orig_opts )   def array_str ( a , nprint = 6 ) :      a = np . asarray ( a ) max_shape = tuple ( n if n < nprint else nprint for n in a . shape ) with npy_printoptions ( threshold = int ( np . prod ( max_shape ) ) , edgeitems = nprint // 2 , suppress = True ) :          a_str = np . array2string ( a , separator = <str> )  return a_str  def dtype_repr ( dtype ) :      dtype = np . dtype ( dtype ) if dtype == np . dtype ( int ) :          return <str>  elif dtype == np . dtype ( float ) :          return <str>  elif dtype == np . dtype ( complex ) :          return <str>  elif dtype . shape :          return <str> . format ( dtype . base , dtype . shape )  else :          return <str> . format ( dtype )   def dtype_str ( dtype ) :      dtype = np . dtype ( dtype ) if dtype == np . dtype ( int ) :          return <str>  elif dtype == np . dtype ( float ) :          return <str>  elif dtype == np . dtype ( complex ) :          return <str>  elif dtype . shape :          return <str> . format ( dtype . base , dtype . shape )  else :          return <str> . format ( dtype )   def with_metaclass ( meta , * bases ) :      class metaclass ( meta ) :          __call__ = type . __call__ __init__ = type . __init__ def __new__ ( cls , name , this_bases , d ) :              if this_bases is None :                  return type . __new__ ( cls , name , ( ) , d )  return meta ( name , bases , d )   return metaclass ( <str> , None , { } )  def cache_arguments ( function ) :      try :          from functools import lru_cache return lru_cache ( ) ( function )  except ImportError :          return function   @ cache_arguments def is_numeric_dtype ( dtype ) :      dtype = np . dtype ( dtype ) return np . issubsctype ( getattr ( dtype , <str> , None ) , np . number )  @ cache_arguments def is_int_dtype ( dtype ) :      dtype = np . dtype ( dtype ) return np . issubsctype ( getattr ( dtype , <str> , None ) , np . integer )  @ cache_arguments def is_floating_dtype ( dtype ) :      return is_real_floating_dtype ( dtype ) or is_complex_floating_dtype ( dtype )  @ cache_arguments def is_real_dtype ( dtype ) :      return is_numeric_dtype ( dtype ) and not is_complex_floating_dtype ( dtype )  @ cache_arguments def is_real_floating_dtype ( dtype ) :      dtype = np . dtype ( dtype ) return np . issubsctype ( getattr ( dtype , <str> , None ) , np . floating )  @ cache_arguments def is_complex_floating_dtype ( dtype ) :      dtype = np . dtype ( dtype ) return np . issubsctype ( getattr ( dtype , <str> , None ) , np . complexfloating )  def real_dtype ( dtype , default = None ) :      dtype , dtype_in = np . dtype ( dtype ) , dtype if is_real_floating_dtype ( dtype ) :          return dtype  try :          real_base_dtype = TYPE_MAP_C2R [ dtype . base ]  except KeyError :          if default is not None :              return default  else :              raise ValueError ( <str> <str> . format ( dtype_repr ( dtype_in ) ) )   else :          return np . dtype ( ( real_base_dtype , dtype . shape ) )   def complex_dtype ( dtype , default = None ) :      dtype , dtype_in = np . dtype ( dtype ) , dtype if is_complex_floating_dtype ( dtype ) :          return dtype  try :          complex_base_dtype = TYPE_MAP_R2C [ dtype . base ]  except KeyError :          if default is not None :              return default  else :              raise ValueError ( <str> <str> . format ( dtype_repr ( dtype_in ) ) )   else :          return np . dtype ( ( complex_base_dtype , dtype . shape ) )   def is_string ( obj ) :      try :          obj + <str>  except TypeError :          return False  else :          return True   def nd_iterator ( shape ) :      return product ( * map ( range , shape ) )  def conj_exponent ( exp ) :      if exp == 1.0 :          return float ( <str> )  elif exp == float ( <str> ) :          return 1.0  else :          return exp / ( exp - 1.0 )   def preload_first_arg ( instance , mode ) :      def decorator ( call ) :          @ wraps ( call ) def oop_wrapper ( x , ** kwargs ) :              return call ( instance , x , ** kwargs )  @ wraps ( call ) def ip_wrapper ( x , out , ** kwargs ) :              return call ( instance , x , out , ** kwargs )  if mode == <str> :              return oop_wrapper  elif mode == <str> :              return ip_wrapper  else :              raise ValueError ( <str> . format ( mode ) )   return decorator  @ contextmanager def none_context ( * args , ** kwargs ) :      yield  @ contextmanager def writable_array ( obj , ** kwargs ) :      try :          arr = np . asarray ( obj , ** kwargs ) yield arr  finally :          obj [ : ] = arr   def signature_string ( posargs , optargs , sep = <str> , mod = <str> ) :      if is_string ( sep ) :          pos_sep = opt_sep = part_sep = sep  else :          pos_sep , opt_sep , part_sep = sep  posargs_conv , optargs_conv = signature_string_parts ( posargs , optargs , mod ) parts = [ ] if posargs_conv :          parts . append ( pos_sep . join ( argstr for argstr in posargs_conv ) )  if optargs_conv :          parts . append ( opt_sep . join ( optargs_conv ) )  return part_sep . join ( parts )  def signature_string_parts ( posargs , optargs , mod = <str> ) :      if is_string ( mod ) or callable ( mod ) :          pos_mod = opt_mod = mod  else :          pos_mod , opt_mod = mod  mods = [ ] for m , args in zip ( ( pos_mod , opt_mod ) , ( posargs , optargs ) ) :          if is_string ( m ) or callable ( m ) :              mods . append ( [ m ] * len ( args ) )  else :              if len ( m ) == 1 :                  mods . append ( m * len ( args ) )  elif len ( m ) == len ( args ) :                  mods . append ( m )  else :                  raise ValueError ( <str> <str> . format ( m , args ) )    pos_mod , opt_mod = mods precision = np . get_printoptions ( ) [ <str> ] posargs_conv = [ ] for arg , modifier in zip ( posargs , pos_mod ) :          if callable ( modifier ) :              posargs_conv . append ( modifier ( arg ) )  elif is_string ( arg ) :              if modifier :                  fmt = <str> . format ( modifier )  else :                  fmt = <str>  posargs_conv . append ( fmt . format ( arg ) )  elif np . isscalar ( arg ) and str ( arg ) in ( <str> , <str> ) :              posargs_conv . append ( <str> . format ( arg ) )  elif ( np . isscalar ( arg ) and np . array ( arg ) . real . astype ( <str> ) != arg and modifier in ( <str> , <str> , <str> ) ) :              fmt = <str> . format ( precision ) posargs_conv . append ( fmt . format ( arg ) )  else :              fmt = <str> . format ( modifier ) posargs_conv . append ( fmt . format ( arg ) )   optargs_conv = [ ] for ( name , value , default ) , modifier in zip ( optargs , opt_mod ) :          if value == default :              continue  if callable ( modifier ) :              optargs_conv . append ( <str> . format ( name , modifier ( value ) ) )  elif is_string ( value ) :              if modifier :                  fmt = <str> . format ( modifier )  else :                  fmt = <str>  value_str = fmt . format ( value ) optargs_conv . append ( <str> . format ( name , value_str ) )  elif np . isscalar ( value ) and str ( value ) in ( <str> , <str> ) :              optargs_conv . append ( <str> . format ( name , value ) )  elif ( np . isscalar ( value ) and np . array ( value ) . real . astype ( <str> ) != value and modifier in ( <str> , <str> , <str> ) ) :              fmt = <str> . format ( precision ) value_str = fmt . format ( value ) optargs_conv . append ( <str> . format ( name , value_str ) )  else :              fmt = <str> . format ( modifier ) value_str = fmt . format ( value ) optargs_conv . append ( <str> . format ( name , value_str ) )   return tuple ( posargs_conv ) , tuple ( optargs_conv )  def _separators ( strings , linewidth ) :      if len ( strings ) <= 1 :          return ( )  indent_len = 4 separators = [ ] cur_line_len = indent_len + len ( strings [ 0 ] ) + 1 if cur_line_len + 2 <= linewidth and <str> not in strings [ 0 ] :          separators . append ( <str> ) cur_line_len += 1  else :          separators . append ( <str> ) cur_line_len = indent_len  for i , s in enumerate ( strings [ 1 : - 1 ] ) :          cur_line_len += len ( s ) + 1 if <str> in s :              separators [ i ] = <str> cur_line_len = indent_len separators . append ( <str> )  elif cur_line_len + 2 <= linewidth :              separators . append ( <str> ) cur_line_len += 1  elif cur_line_len <= linewidth :              separators . append ( <str> ) cur_line_len = indent_len  else :              separators [ i ] = <str> cur_line_len = indent_len + len ( s ) + 1 if cur_line_len + 2 <= linewidth :                  separators . append ( <str> )  else :                  separators . append ( <str> )    cur_line_len += len ( strings [ - 1 ] ) if cur_line_len + 1 > linewidth or <str> in strings [ - 1 ] :          separators [ - 1 ] = <str>  return tuple ( separators )  def repr_string ( outer_string , inner_strings , allow_mixed_seps = True ) :      <str> linewidth = np . get_printoptions ( ) [ <str> ] pos_strings , opt_strings = inner_strings pos_sig_len = ( sum ( len ( pstr ) for pstr in pos_strings ) + 2 * max ( ( len ( pos_strings ) - 1 ) , 0 ) ) opt_sig_len = ( sum ( len ( pstr ) for pstr in opt_strings ) + 2 * max ( ( len ( opt_strings ) - 1 ) , 0 ) ) repr_len = len ( outer_string ) + 2 + pos_sig_len + 2 + opt_sig_len if repr_len <= linewidth and not any ( <str> in s for s in pos_strings + opt_strings ) :          fmt = <str> pos_str = <str> . join ( pos_strings ) opt_str = <str> . join ( opt_strings ) parts_sep = <str>  else :          fmt = <str> if not allow_mixed_seps :              pos_separators = [ <str> ] * ( len ( pos_strings ) - 1 )  else :              pos_separators = _separators ( pos_strings , linewidth )  if len ( pos_strings ) == 0 :              pos_str = <str>  else :              pos_str = pos_strings [ 0 ] for s , sep in zip ( pos_strings [ 1 : ] , pos_separators ) :                  pos_str = sep . join ( [ pos_str , s ] )   if not allow_mixed_seps :              opt_separators = [ <str> ] * ( len ( opt_strings ) - 1 )  else :              opt_separators = _separators ( opt_strings , linewidth )  if len ( opt_strings ) == 0 :              opt_str = <str>  else :              opt_str = opt_strings [ 0 ] for s , sep in zip ( opt_strings [ 1 : ] , opt_separators ) :                  opt_str = sep . join ( [ opt_str , s ] )   if pos_str and opt_str :              inner_len = 4 + len ( pos_str ) + 2 + len ( opt_str )  elif ( pos_str and not opt_str ) or ( opt_str and not pos_str ) :              inner_len = 4 + len ( pos_str ) + len ( opt_str )  else :              inner_len = 0  if ( not allow_mixed_seps or any ( <str> in s for s in [ pos_str , opt_str ] ) or inner_len > linewidth ) :              parts_sep = <str> pos_str = indent ( pos_str ) opt_str = indent ( opt_str )  else :              parts_sep = <str> pos_str = indent ( pos_str )   parts = [ s for s in [ pos_str , opt_str ] if s . strip ( ) ] inner_string = parts_sep . join ( parts ) return fmt . format ( outer_string , inner_string )  def attribute_repr_string ( inst_str , attr_str ) :      linewidth = np . get_printoptions ( ) [ <str> ] if ( len ( inst_str ) + 1 + len ( attr_str ) <= linewidth or <str> not in inst_str ) :          parts = [ inst_str , attr_str ]  else :          left , rest = inst_str . split ( <str> , 1 ) right , middle = rest [ : : - 1 ] . split ( <str> , 1 ) middle , right = middle [ : : - 1 ] , right [ : : - 1 ] if middle . startswith ( <str> ) and middle . endswith ( <str> ) :              new_inst_str = inst_str  else :              init_parts = [ left ] if middle :                  init_parts . append ( indent ( middle ) )  new_inst_str = <str> . join ( init_parts ) + <str> + right  parts = [ new_inst_str , attr_str ]  return <str> . join ( parts )  def method_repr_string ( inst_str , meth_str , arg_strs = None , allow_mixed_seps = True ) :      <str> linewidth = np . get_printoptions ( ) [ <str> ] if ( len ( inst_str ) + 1 + len ( meth_str ) + 1 <= linewidth or <str> not in inst_str ) :          init_parts = [ inst_str , meth_str ] meth_line_start_len = len ( inst_str ) + 1 + len ( meth_str )  else :          left , rest = inst_str . split ( <str> , 1 ) right , middle = rest [ : : - 1 ] . split ( <str> , 1 ) middle , right = middle [ : : - 1 ] , right [ : : - 1 ] if middle . startswith ( <str> ) and middle . endswith ( <str> ) :              new_inst_str = inst_str  else :              new_inst_str = <str> . join ( [ left , indent ( middle ) ] ) + <str> + right  meth_line_start_len = 1 + 1 + len ( meth_str ) init_parts = [ new_inst_str , meth_str ]  arg_str_oneline = <str> . join ( arg_strs ) if meth_line_start_len + 1 + len ( arg_str_oneline ) + 1 <= linewidth :          meth_call_str = <str> + arg_str_oneline + <str>  elif not arg_str_oneline :          meth_call_str = <str>  else :          if allow_mixed_seps :              arg_seps = _separators ( arg_strs , linewidth - 4 )  else :              arg_seps = [ <str> ] * ( len ( arg_strs ) - 1 )  full_arg_str = <str> for arg_str , sep in zip_longest ( arg_strs , arg_seps , fillvalue = <str> ) :              full_arg_str += arg_str + sep  meth_call_str = <str> + indent ( full_arg_str ) + <str>  return <str> . join ( init_parts ) + meth_call_str  def run_from_ipython ( ) :      return <str> in globals ( )  def pkg_supports ( feature , pkg_version , pkg_feat_dict ) :      from pkg_resources import parse_requirements feature = str ( feature ) pkg_version = str ( pkg_version ) supp_versions = pkg_feat_dict . get ( feature , None ) if supp_versions is None :          return False  if is_string ( supp_versions ) :          supp_versions = [ supp_versions ]  ver_specs = [ <str> + supp_ver for supp_ver in supp_versions ] ver_reqs = [ list ( parse_requirements ( ver_spec ) ) [ 0 ] for ver_spec in ver_specs ] for req in ver_reqs :          if req . specifier . contains ( pkg_version , prereleases = True ) :              return True   return False  @ contextmanager def npy_random_seed ( seed ) :      do_seed = seed is not None try :          if do_seed :              orig_rng_state = np . random . get_state ( ) np . random . seed ( seed )  yield  finally :          if do_seed :              np . random . set_state ( orig_rng_state )    def unique ( seq ) :      try :          return list ( OrderedDict . fromkeys ( seq ) )  except TypeError :          unique_values = [ ] for i in seq :              if i not in unique_values :                  unique_values . append ( i )   return unique_values   if __name__ == <str> :      from odl . util . testutils import run_doctests run_doctests ( )   