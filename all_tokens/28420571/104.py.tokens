from __future__ import absolute_import , division , print_function import os import sys import warnings from builtins import object from contextlib import contextmanager from time import time import numpy as np from future . moves . itertools import zip_longest from odl . util . utility import is_string , run_from_ipython __all__ = ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , ) def _ndigits ( a , b , default = None ) :      dtype1 = getattr ( a , <str> , object ) dtype2 = getattr ( b , <str> , object ) return min ( dtype_ndigits ( dtype1 , default ) , dtype_ndigits ( dtype2 , default ) )  def dtype_ndigits ( dtype , default = None ) :      small_dtypes = [ np . float32 , np . complex64 ] tiny_dtypes = [ np . float16 ] if dtype in tiny_dtypes :          return 1  elif dtype in small_dtypes :          return 3  else :          return default if default is not None else 5   def dtype_tol ( dtype , default = None ) :      return 10 ** - dtype_ndigits ( dtype , default )  def all_equal ( iter1 , iter2 ) :      try :          if iter1 == iter2 :              return True   except ValueError :          pass  if iter1 is None and iter2 is None :          return True  try :          it1 = iter ( iter1 ) it2 = iter ( iter2 )  except TypeError :          try :              return iter1 == iter2  except ValueError :              return False   diff_length_sentinel = object ( ) for [ ip1 , ip2 ] in zip_longest ( it1 , it2 , fillvalue = diff_length_sentinel ) :          if ip1 is diff_length_sentinel or ip2 is diff_length_sentinel :              return False  if not all_equal ( ip1 , ip2 ) :              return False   return True  def all_almost_equal_array ( v1 , v2 , ndigits ) :      return np . allclose ( v1 , v2 , rtol = 10 ** - ndigits , atol = 10 ** - ndigits , equal_nan = True )  def all_almost_equal ( iter1 , iter2 , ndigits = None ) :      try :          if iter1 is iter2 or iter1 == iter2 :              return True   except ValueError :          pass  if iter1 is None and iter2 is None :          return True  if hasattr ( iter1 , <str> ) and hasattr ( iter2 , <str> ) :          if ndigits is None :              ndigits = _ndigits ( iter1 , iter2 , None )  return all_almost_equal_array ( iter1 , iter2 , ndigits )  try :          it1 = iter ( iter1 ) it2 = iter ( iter2 )  except TypeError :          if ndigits is None :              ndigits = _ndigits ( iter1 , iter2 , None )  return np . isclose ( iter1 , iter2 , atol = 10 ** - ndigits , rtol = 10 ** - ndigits , equal_nan = True )  diff_length_sentinel = object ( ) for [ ip1 , ip2 ] in zip_longest ( it1 , it2 , fillvalue = diff_length_sentinel ) :          if ip1 is diff_length_sentinel or ip2 is diff_length_sentinel :              return False  if not all_almost_equal ( ip1 , ip2 , ndigits ) :              return False   return True  def is_subdict ( subdict , dictionary ) :      return all ( item in dictionary . items ( ) for item in subdict . items ( ) )  try :      import pytest  except ImportError :      def identity ( * args , ** kwargs ) :          if args and callable ( args [ 0 ] ) :              return args [ 0 ]  else :              return identity   skip_if_no_pyfftw = identity skip_if_no_pywavelets = identity skip_if_no_largescale = identity skip_if_no_benchmark = identity  else :      skip_if_no_pyfftw = pytest . mark . skipif ( <str> , reason = <str> , ) skip_if_no_pywavelets = pytest . mark . skipif ( <str> , reason = <str> , ) skip_if_no_largescale = pytest . mark . skipif ( <str> , reason = <str> , ) skip_if_no_benchmark = pytest . mark . skipif ( <str> , reason = <str> , )  def simple_fixture ( name , params , fmt = None ) :      import _pytest if fmt is None :          fmt_str = <str> fmt_default = <str> ids = [ ] for p in params :              if ( isinstance ( p , _pytest . mark . MarkDecorator ) and p . name == <str> ) :                  if is_string ( p . args [ 1 ] ) :                      ids . append ( fmt_str . format ( name = name , value = p . args [ 1 ] ) )  else :                      ids . append ( fmt_default . format ( name = name , value = p . args [ 1 ] ) )   else :                  if is_string ( p ) :                      ids . append ( fmt_str . format ( name = name , value = p ) )  else :                      ids . append ( fmt_default . format ( name = name , value = p ) )     else :          ids = [ fmt . format ( name = name , value = p ) for p in params ]  wrapper = pytest . fixture ( scope = <str> , ids = ids , params = params ) return wrapper ( lambda request : request . param )  def noise_array ( space ) :      from odl . space import ProductSpace if isinstance ( space , ProductSpace ) :          return np . array ( [ noise_array ( si ) for si in space ] )  else :          if space . dtype == bool :              arr = np . random . randint ( 0 , 2 , size = space . shape , dtype = bool )  elif np . issubdtype ( space . dtype , np . unsignedinteger ) :              arr = np . random . randint ( 0 , 10 , space . shape )  elif np . issubdtype ( space . dtype , np . signedinteger ) :              arr = np . random . randint ( - 10 , 10 , space . shape )  elif np . issubdtype ( space . dtype , np . floating ) :              arr = np . random . randn ( * space . shape )  elif np . issubdtype ( space . dtype , np . complexfloating ) :              arr = ( np . random . randn ( * space . shape ) + 1j * np . random . randn ( * space . shape ) ) / np . sqrt ( 2.0 )  else :              raise ValueError ( <str> . format ( space . dtype ) )  return arr . astype ( space . dtype , copy = False )   def noise_element ( space ) :      return space . element ( noise_array ( space ) )  def noise_elements ( space , n = 1 ) :      arrs = tuple ( noise_array ( space ) for _ in range ( n ) ) elems = tuple ( space . element ( arr . copy ( ) ) for arr in arrs ) if n == 1 :          return tuple ( arrs + elems )  else :          return arrs , elems   @ contextmanager def fail_counter ( test_name , err_msg = None , logger = print ) :      class _FailCounter ( object ) :          def __init__ ( self ) :              self . num_failed = 0 self . fail_strings = [ ]  def fail ( self , string = None ) :              self . num_failed += 1 if string is not None :                  self . fail_strings . append ( str ( string ) )    try :          counter = _FailCounter ( ) yield counter  finally :          if counter . num_failed == 0 :              logger ( <str> . format ( test_name ) )  else :              print ( test_name ) for fail_string in counter . fail_strings :                  print ( fail_string )  if err_msg is not None :                  print ( err_msg )  print ( <str> . format ( counter . num_failed ) )    @ contextmanager def timer ( name = None ) :      if name is None :          name = <str>  try :          tstart = time ( ) yield  finally :          time_str = <str> . format ( time ( ) - tstart ) print ( <str> . format ( name , time_str ) )   def timeit ( arg ) :      if callable ( arg ) :          def timed_function ( * args , ** kwargs ) :              with timer ( str ( arg ) ) :                  return arg ( * args , ** kwargs )   return timed_function  else :          def _timeit_helper ( func ) :              def timed_function ( * args , ** kwargs ) :                  with timer ( arg ) :                      return func ( * args , ** kwargs )   return timed_function  return _timeit_helper   class ProgressBar ( object ) :      def __init__ ( self , text = <str> , * njobs ) :          self . text = str ( text ) if len ( njobs ) == 0 :              raise ValueError ( <str> )  self . njobs = njobs self . current_progress = 0.0 self . index = 0 self . done = False self . start ( )  def start ( self ) :          sys . stdout . write ( <str> . format ( self . text , <str> * 30 ) ) sys . stdout . flush ( )  def update ( self , * indices ) :          if indices :              if len ( indices ) != len ( self . njobs ) :                  raise ValueError ( <str> )  self . index = np . ravel_multi_index ( indices , self . njobs ) + 1  else :              self . index += 1  progress = self . index / np . prod ( self . njobs ) if progress < 1.0 :              if progress > self . current_progress + 0.001 :                  sys . stdout . write ( <str> . format ( self . text , <str> * int ( 30 * progress ) , 100 * progress ) ) self . current_progress = progress   else :              if not self . done :                  sys . stdout . write ( <str> . format ( self . text , <str> * 30 ) ) self . done = True   sys . stdout . flush ( )   class ProgressRange ( object ) :      def __init__ ( self , text , n ) :          self . current = 0 self . n = n self . bar = ProgressBar ( text , n )  def __iter__ ( self ) :          return self  def __next__ ( self ) :          if self . current < self . n :              val = self . current self . current += 1 self . bar . update ( ) return val  else :              raise StopIteration ( )    def test ( arguments = None ) :      try :          import pytest  except ImportError :          raise ImportError ( <str> <str> <str> )  from . pytest_config import collect_ignore this_dir = os . path . dirname ( __file__ ) odl_root = os . path . abspath ( os . path . join ( this_dir , os . pardir , os . pardir ) ) args = [ <str> . format ( root = odl_root ) ] ignores = [ <str> . format ( file ) for file in collect_ignore ] args . extend ( ignores ) if arguments is not None :          args . extend ( arguments )  pytest . main ( args )  def run_doctests ( skip_if = False , ** kwargs ) :      from doctest import testmod , NORMALIZE_WHITESPACE , SKIP from packaging . version import parse as parse_version import odl import numpy as np optionflags = kwargs . pop ( <str> , NORMALIZE_WHITESPACE ) if skip_if :          optionflags |= SKIP  extraglobs = kwargs . pop ( <str> , { <str> : odl , <str> : np } ) if run_from_ipython ( ) :          try :              import spyder  except ImportError :              pass  else :              if parse_version ( spyder . __version__ ) < parse_version ( <str> ) :                  warnings . warn ( <str> <str> <str> <str> , RuntimeWarning )    testmod ( optionflags = optionflags , extraglobs = extraglobs , ** kwargs )  def test_file ( file , args = None ) :      try :          import pytest  except ImportError :          raise ImportError ( <str> <str> <str> )  if args is None :          args = [ ]  args . extend ( [ str ( file . replace ( <str> , <str> ) ) , <str> , <str> ] ) pytest . main ( args )  if __name__ == <str> :      run_doctests ( )   