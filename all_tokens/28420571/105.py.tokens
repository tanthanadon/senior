 from __future__ import print_function , division , absolute_import from builtins import object from copy import copy , deepcopy from odl . set import Field from odl . diagnostics . examples import samples from odl . util . testutils import FailCounter __all__ = ( <str> , ) def _approx_equal ( x , y , eps ) :      if x . space != y . space :          return False  if x is y :          return True  try :          return x . dist ( y ) <= eps  except NotImplementedError :          try :              return x == y  except NotImplementedError :              return False    class SpaceTest ( object ) :      def __init__ ( self , space , verbose = True , tol = 1e-5 ) :          self . space = space self . verbose = bool ( verbose ) self . tol = float ( tol )  def log ( self , message ) :          if self . verbose :              print ( message )   def element_method ( self ) :          with FailCounter ( test_name = <str> , logger = self . log ) as counter :              try :                  elem = self . space . element ( )  except NotImplementedError :                  counter . fail ( <str> ) return  if elem not in self . space :                  counter . fail ( <str> )    def field ( self ) :          with FailCounter ( test_name = <str> , logger = self . log ) as counter :              try :                  field = self . space . field  except NotImplementedError :                  counter . fail ( <str> ) return  if not isinstance ( field , Field ) :                  counter . fail ( <str> ) return  try :                  zero = field . element ( 0 )  except NotImplementedError :                  counter . fail ( <str> ) zero = None  if zero is not None and zero != 0 :                  counter . fail ( <str> )  if zero is not None and zero != 0.0 :                  counter . fail ( <str> )  try :                  one = field . element ( 1 )  except NotImplementedError :                  counter . fail ( <str> ) one = None  if one is not None and one != 1 :                  counter . fail ( <str> )  if one is not None and one != 1.0 :                  counter . fail ( <str> )  try :                  minus_one = field . element ( - 1 )  except NotImplementedError :                  counter . fail ( <str> ) minus_one = None  if minus_one is not None and minus_one != - 1 :                  counter . fail ( <str> )  if minus_one is not None and minus_one != - 1.0 :                  counter . fail ( <str> )    def _associativity_of_addition ( self ) :          with FailCounter ( test_name = <str> , err_msg = <str> , logger = self . log ) as counter :              for [ n_x , x ] , [ n_y , y ] , [ n_z , z ] in samples ( self . space , self . space , self . space ) :                  correct = _approx_equal ( x + ( y + z ) , ( x + y ) + z , self . tol ) if not correct :                      counter . fail ( <str> <str> . format ( n_x , n_y , n_z ) )     def _commutativity_of_addition ( self ) :          with FailCounter ( test_name = <str> , err_msg = <str> , logger = self . log ) as counter :              for [ n_x , x ] , [ n_y , y ] in samples ( self . space , self . space ) :                  correct = _approx_equal ( x + y , y + x , self . tol ) if not correct :                      counter . fail ( <str> <str> . format ( n_x , n_y ) )     def _identity_of_addition ( self ) :          try :              zero = self . space . zero ( )  except ( AttributeError , NotImplementedError ) :              print ( <str> ) return  with FailCounter ( test_name = <str> , err_msg = <str> , logger = self . log ) as counter :              for [ n_x , x ] in samples ( self . space ) :                  correct = _approx_equal ( x + zero , x , self . tol ) if not correct :                      counter . fail ( <str> . format ( n_x ) )     def _inverse_element_of_addition ( self ) :          try :              zero = self . space . zero ( )  except ( AttributeError , NotImplementedError ) :              print ( <str> ) return  with FailCounter ( test_name = <str> , err_msg = <str> , logger = self . log ) as counter :              for [ n_x , x ] in samples ( self . space ) :                  correct = _approx_equal ( x + ( - x ) , zero , self . tol ) if not correct :                      counter . fail ( <str> . format ( n_x ) )     def _commutativity_of_scalar_mult ( self ) :          with FailCounter ( test_name = <str> , err_msg = <str> , logger = self . log ) as counter :              for [ n_x , x ] , [ _ , a ] , [ _ , b ] in samples ( self . space , self . space . field , self . space . field ) :                  correct = _approx_equal ( a * ( b * x ) , ( a * b ) * x , self . tol ) if not correct :                      counter . fail ( <str> <str> . format ( n_x , a , b ) )     def _identity_of_mult ( self ) :          with FailCounter ( test_name = <str> , err_msg = <str> , logger = self . log ) as counter :              for [ n_x , x ] in samples ( self . space ) :                  correct = _approx_equal ( 1 * x , x , self . tol ) if not correct :                      counter . fail ( <str> . format ( n_x ) )     def _distributivity_of_mult_vector ( self ) :          with FailCounter ( test_name = <str> <str> , err_msg = <str> , logger = self . log ) as counter :              for [ n_x , x ] , [ n_y , y ] , [ _ , a ] in samples ( self . space , self . space , self . space . field ) :                  correct = _approx_equal ( a * ( x + y ) , a * x + a * y , self . tol ) if not correct :                      counter . fail ( <str> <str> . format ( n_x , n_y , a ) )     def _distributivity_of_mult_scalar ( self ) :          with FailCounter ( test_name = <str> <str> , err_msg = <str> , logger = self . log ) as counter :              for [ n_x , x ] , [ _ , a ] , [ _ , b ] in samples ( self . space , self . space . field , self . space . field ) :                  correct = _approx_equal ( ( a + b ) * x , a * x + b * x , self . tol ) if not correct :                      counter . fail ( <str> <str> . format ( n_x , a , b ) )     def _subtraction ( self ) :          with FailCounter ( test_name = <str> , err_msg = <str> , logger = self . log ) as counter :              for [ n_x , x ] , [ n_y , y ] in samples ( self . space , self . space ) :                  correct = ( _approx_equal ( x - y , x + ( - 1 * y ) , self . tol ) and _approx_equal ( x - y , x + ( - y ) , self . tol ) ) if not correct :                      counter . fail ( <str> <str> . format ( n_x , n_y ) )     def _division ( self ) :          with FailCounter ( test_name = <str> , err_msg = <str> , logger = self . log ) as counter :              for [ n_x , x ] , [ _ , a ] in samples ( self . space , self . space . field ) :                  if a != 0 :                      correct = _approx_equal ( x / a , x * ( 1.0 / a ) , self . tol ) if not correct :                          counter . fail ( <str> <str> . format ( n_x , a ) )      def _lincomb_aliased ( self ) :          with FailCounter ( test_name = <str> , err_msg = <str> , logger = self . log ) as counter :              for [ n_x , x_in ] , [ n_y , y ] in samples ( self . space , self . space ) :                  x = x_in . copy ( ) x . lincomb ( 1 , x , 1 , y ) correct = _approx_equal ( x , x_in + y , self . tol ) if not correct :                      counter . fail ( <str> <str> <str> . format ( n_x , n_y ) )  x = x_in . copy ( ) x . lincomb ( 1 , x , 1 , x ) correct = _approx_equal ( x , x_in + x_in , self . tol ) if not correct :                      counter . fail ( <str> <str> <str> . format ( n_x ) )     def _lincomb ( self ) :          self . log ( <str> ) self . _lincomb_aliased ( )  def linearity ( self ) :          self . log ( <str> ) self . _associativity_of_addition ( ) self . _commutativity_of_addition ( ) self . _identity_of_addition ( ) self . _inverse_element_of_addition ( ) self . _commutativity_of_scalar_mult ( ) self . _identity_of_mult ( ) self . _distributivity_of_mult_vector ( ) self . _distributivity_of_mult_scalar ( ) self . _subtraction ( ) self . _division ( ) self . _lincomb ( )  def _inner_linear_scalar ( self ) :          with FailCounter ( test_name = <str> <str> , err_msg = <str> , logger = self . log ) as counter :              for [ n_x , x ] , [ n_y , y ] , [ _ , a ] in samples ( self . space , self . space , self . space . field ) :                  error = abs ( ( a * x ) . inner ( y ) - a * x . inner ( y ) ) if error > self . tol :                      counter . fail ( <str> <str> . format ( n_x , n_y , a , error ) )     def _inner_conjugate_symmetry ( self ) :          with FailCounter ( test_name = <str> , err_msg = <str> , logger = self . log ) as counter :              for [ n_x , x ] , [ n_y , y ] in samples ( self . space , self . space ) :                  error = abs ( ( x ) . inner ( y ) - y . inner ( x ) . conjugate ( ) ) if error > self . tol :                      counter . fail ( <str> <str> . format ( n_x , n_y , error ) )     def _inner_linear_sum ( self ) :          with FailCounter ( test_name = <str> <str> , err_msg = <str> , logger = self . log ) as counter :              for [ n_x , x ] , [ n_y , y ] , [ n_z , z ] in samples ( self . space , self . space , self . space ) :                  error = abs ( ( x + y ) . inner ( z ) - ( x . inner ( z ) + y . inner ( z ) ) ) if error > self . tol :                      counter . fail ( <str> <str> . format ( n_x , n_y , n_z , error ) )     def _inner_positive ( self ) :          with FailCounter ( test_name = <str> <str> , logger = self . log ) as counter :              for [ n_x , x ] in samples ( self . space ) :                  inner = x . inner ( x ) if abs ( inner . imag ) > self . tol :                      counter . fail ( <str> <str> . format ( n_x , inner . imag ) )  if n_x == <str> and inner . real != 0 :                      counter . fail ( <str> <str> . format ( n_x , inner ) )  elif n_x != <str> and inner . real <= 0 :                      counter . fail ( <str> <str> . format ( n_x , inner ) )     def inner ( self ) :          self . log ( <str> ) try :              zero = self . space . zero ( ) zero . inner ( zero )  except NotImplementedError :              self . log ( <str> ) return  self . _inner_conjugate_symmetry ( ) self . _inner_linear_scalar ( ) self . _inner_linear_sum ( ) self . _inner_positive ( )  def _norm_positive ( self ) :          with FailCounter ( test_name = <str> , logger = self . log ) as counter :              for [ n_x , x ] in samples ( self . space ) :                  norm = x . norm ( ) if n_x == <str> and norm != 0 :                      counter . fail ( <str> <str> . format ( n_x , norm ) )  elif n_x != <str> and norm <= 0 :                      counter . fail ( <str> <str> . format ( n_x , norm ) )     def _norm_subadditive ( self ) :          with FailCounter ( test_name = <str> , err_msg = <str> , logger = self . log ) as counter :              for [ n_x , x ] , [ n_y , y ] in samples ( self . space , self . space ) :                  norm_x = x . norm ( ) norm_y = y . norm ( ) norm_xy = ( x + y ) . norm ( ) error = norm_xy - norm_x - norm_y if error > 0 :                      counter . fail ( <str> <str> . format ( n_x , n_y , error ) )     def _norm_homogeneity ( self ) :          with FailCounter ( test_name = <str> , err_msg = <str> , logger = self . log ) as counter :              for [ n_x , x ] , [ _ , a ] in samples ( self . space , self . space . field ) :                  error = abs ( ( a * x ) . norm ( ) - abs ( a ) * x . norm ( ) ) if error > self . tol :                      counter . fail ( <str> <str> . format ( n_x , a , error ) )     def _norm_inner_compatible ( self ) :          try :              zero = self . space . zero ( ) zero . inner ( zero )  except NotImplementedError :              self . log ( <str> ) return  with FailCounter ( test_name = <str> , err_msg = <str> , logger = self . log ) as counter :              for [ n_x , x ] in samples ( self . space ) :                  error = abs ( x . norm ( ) ** 2 - x . inner ( x ) ) if error > self . tol :                      counter . fail ( <str> <str> . format ( n_x , error ) )     def norm ( self ) :          self . log ( <str> ) try :              self . space . zero ( ) . norm ( )  except NotImplementedError :              self . log ( <str> ) return  self . _norm_positive ( ) self . _norm_subadditive ( ) self . _norm_homogeneity ( ) self . _norm_inner_compatible ( )  def _dist_positivity ( self ) :          with FailCounter ( test_name = <str> , logger = self . log ) as counter :              for [ n_x , x ] , [ n_y , y ] in samples ( self . space , self . space ) :                  dist = x . dist ( y ) if n_x == n_y and dist != 0 :                      counter . fail ( <str> <str> . format ( n_x , dist ) )  elif n_x != n_y and dist <= 0 :                      counter . fail ( <str> <str> . format ( n_x , n_y , dist ) )     def _dist_symmetric ( self ) :          with FailCounter ( test_name = <str> , err_msg = <str> , logger = self . log ) as counter :              for [ n_x , x ] , [ n_y , y ] in samples ( self . space , self . space ) :                  dist_1 = x . dist ( y ) dist_2 = y . dist ( x ) error = abs ( dist_1 - dist_2 ) if error > self . tol :                      counter . fail ( <str> <str> . format ( n_x , n_y , error ) )     def _dist_subtransitive ( self ) :          with FailCounter ( test_name = <str> , err_msg = <str> , logger = self . log ) as counter :              for [ n_x , x ] , [ n_y , y ] , [ n_z , z ] in samples ( self . space , self . space , self . space ) :                  dxz = x . dist ( z ) dxy = x . dist ( y ) dyz = y . dist ( z ) error = dxz - ( dxy + dyz ) if error > self . tol :                      counter . fail ( <str> <str> . format ( n_x , n_y , n_z , error ) )     def _dist_norm_compatible ( self ) :          try :              self . space . zero ( ) . norm ( )  except NotImplementedError :              self . log ( <str> ) return  with FailCounter ( test_name = <str> , err_msg = <str> , logger = self . log ) as counter :              for [ n_x , x ] , [ n_y , y ] in samples ( self . space , self . space ) :                  error = abs ( x . dist ( y ) - ( x - y ) . norm ( ) ) if error > self . tol :                      counter . fail ( <str> <str> . format ( n_x , n_y , error ) )     def dist ( self ) :          self . log ( <str> ) try :              zero = self . space . zero ( ) self . space . dist ( zero , zero )  except NotImplementedError :              self . log ( <str> ) return  self . _dist_positivity ( ) self . _dist_symmetric ( ) self . _dist_subtransitive ( ) self . _dist_norm_compatible ( )  def _multiply_zero ( self ) :          try :              zero = self . space . zero ( )  except NotImplementedError :              print ( <str> ) return  with FailCounter ( test_name = <str> , err_msg = <str> , logger = self . log ) as counter :              for [ n_x , x ] in samples ( self . space ) :                  error = ( zero * x ) . norm ( ) if error > self . tol :                      counter . fail ( <str> <str> . format ( n_x , error ) )     def _multiply_commutative ( self ) :          with FailCounter ( test_name = <str> , err_msg = <str> , logger = self . log ) as counter :              for [ n_x , x ] , [ n_y , y ] , _ in samples ( self . space , self . space , self . space ) :                  correct = _approx_equal ( x * y , y * x , self . tol ) if not correct :                      counter . fail ( <str> <str> . format ( n_x , n_y ) )     def _multiply_associative ( self ) :          with FailCounter ( test_name = <str> , err_msg = <str> , logger = self . log ) as counter :              for [ n_x , x ] , [ n_y , y ] , [ n_z , z ] in samples ( self . space , self . space , self . space ) :                  correct = _approx_equal ( x * ( y * z ) , ( x * y ) * z , self . tol ) if not correct :                      counter . fail ( <str> <str> . format ( n_x , n_y , n_z ) )     def _multiply_distributive_scalar ( self ) :          with FailCounter ( test_name = <str> <str> , err_msg = <str> , logger = self . log ) as counter :              for [ n_x , x ] , [ n_y , y ] , [ _ , a ] in samples ( self . space , self . space , self . space . field ) :                  correct = _approx_equal ( a * ( x + y ) , a * x + a * y , self . tol ) if not correct :                      counter . fail ( <str> <str> . format ( n_x , n_y , a ) )     def _multiply_distributive_vector ( self ) :          with FailCounter ( test_name = <str> <str> , err_msg = <str> , logger = self . log ) as counter :              for [ n_x , x ] , [ n_y , y ] , [ n_z , z ] in samples ( self . space , self . space , self . space ) :                  correct = _approx_equal ( x * ( y + z ) , x * y + x * z , self . tol ) if not correct :                      counter . fail ( <str> <str> . format ( n_x , n_y , n_z ) )     def multiply ( self ) :          self . log ( <str> ) try :              zero = self . space . zero ( )  except NotImplementedError :              print ( <str> ) return  try :              self . space . multiply ( zero , zero )  except NotImplementedError :              self . log ( <str> ) return  self . _multiply_zero ( ) self . _multiply_commutative ( ) self . _multiply_associative ( ) self . _multiply_distributive_scalar ( ) self . _multiply_distributive_vector ( )  def equals ( self ) :          self . log ( <str> ) if not self . space == self . space :              print ( <str> )  if self . space != self . space :              print ( <str> )  if self . space != copy ( self . space ) :              print ( <str> )  if self . space != deepcopy ( self . space ) :              print ( <str> )  with FailCounter ( test_name = <str> <str> , logger = self . log ) as counter :              for obj in [ [ 1 , 2 ] , list ( ) , tuple ( ) , dict ( ) , 5.0 ] :                  if self . space == obj :                      counter . fail ( <str> <str> . format ( obj ) )  if not self . space != obj :                      counter . fail ( <str> <str> . format ( obj ) )     def contains ( self ) :          with FailCounter ( test_name = <str> , logger = self . log ) as counter :              for [ n_x , x ] in samples ( self . space ) :                  if x not in self . space :                      counter . fail ( <str> <str> . format ( n_x ) )  if x not in self . space :                      counter . fail ( <str> <str> . format ( n_x ) )   for obj in [ [ 1 , 2 ] , list ( ) , tuple ( ) , dict ( ) , 5.0 ] :                  if obj in self . space :                      counter . fail ( <str> <str> . format ( obj ) )  if not obj not in self . space :                      counter . fail ( <str> <str> . format ( obj ) )     def element_assign ( self ) :          with FailCounter ( test_name = <str> , logger = self . log ) as counter :              for [ n_x , x ] , [ n_y , y ] in samples ( self . space , self . space ) :                  x . assign ( y ) correct = _approx_equal ( x , y , self . tol ) if not correct :                      counter . fail ( <str> <str> . format ( n_x , n_y ) )     def element_copy ( self ) :          with FailCounter ( test_name = <str> , logger = self . log ) as counter :              for [ n_x , x ] in samples ( self . space ) :                  y = x . copy ( ) correct = _approx_equal ( x , y , self . tol ) if not correct :                      counter . fail ( <str> <str> . format ( n_x ) )  y *= 2.0 correct = n_x == <str> or not _approx_equal ( x , y , self . tol ) if not correct :                      counter . fail ( <str> <str> . format ( n_x ) )     def element_set_zero ( self ) :          try :              zero = self . space . zero ( )  except NotImplementedError :              print ( <str> ) return  with FailCounter ( test_name = <str> , logger = self . log ) as counter :              for [ n_x , x ] in samples ( self . space ) :                  x . set_zero ( ) correct = _approx_equal ( x , zero , self . tol ) if not correct :                      counter . fail ( <str> <str> . format ( n_x ) )     def element_equals ( self ) :          try :              zero = self . space . zero ( )  except NotImplementedError :              print ( <str> ) return  try :              zero == zero  except NotImplementedError :              self . log ( <str> ) return  with FailCounter ( test_name = <str> , logger = self . log ) as counter :              for [ n_x , x ] , [ n_y , y ] in samples ( self . space , self . space ) :                  if n_x == n_y :                      if not x == y :                          counter . fail ( <str> <str> . format ( n_x ) )  if x != y :                          counter . fail ( <str> <str> . format ( n_x ) )   else :                      if x == y :                          counter . fail ( <str> <str> . format ( n_x , n_y ) )  if not x != y :                          counter . fail ( <str> <str> . format ( n_x , n_y ) )      def element_space ( self ) :          with FailCounter ( test_name = <str> , logger = self . log ) as counter :              for [ n_x , x ] in samples ( self . space ) :                  if x . space != self . space :                      counter . fail ( <str> . format ( n_x ) )     def element ( self ) :          self . log ( <str> ) self . element_assign ( ) self . element_copy ( ) self . element_set_zero ( ) self . element_equals ( ) self . element_space ( )  def run_tests ( self ) :          self . log ( <str> ) self . log ( <str> . format ( self . space ) ) self . field ( ) self . element_method ( ) self . linearity ( ) self . inner ( ) self . norm ( ) self . dist ( ) self . multiply ( ) self . equals ( ) self . contains ( ) self . element ( )  def __str__ ( self ) :          return <str> . format ( self . __class__ . __name__ , self . space )  def __repr__ ( self ) :          inner_str = <str> . format ( self . space ) if not self . verbose :              inner_str += <str>  if self . tol != 1e-5 :              inner_str += <str> . format ( self . tol )  return <str> . format ( self . __class__ . __name__ , inner_str )   if __name__ == <str> :      from odl import rn , uniform_discr SpaceTest ( rn ( 10 ) , verbose = False ) . run_tests ( ) SpaceTest ( uniform_discr ( [ 0 , 0 ] , [ 1 , 1 ] , [ 5 , 5 ] ) ) . run_tests ( )   