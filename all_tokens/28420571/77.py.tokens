from __future__ import absolute_import , division , print_function import warnings import numpy as np from odl . discr import DiscreteLp , DiscreteLpElement from odl . tomo . geometry import ( DivergentBeamGeometry , Flat1dDetector , Flat2dDetector , Geometry , ParallelBeamGeometry ) from odl . tomo . util . utility import euler_matrix try :      import astra  except ImportError :      ASTRA_AVAILABLE = False ASTRA_VERSION = <str>  else :      ASTRA_AVAILABLE = True  if ASTRA_AVAILABLE :      try :          ASTRA_VERSION = astra . __version__  except AttributeError :          _maj = astra . astra . version ( ) // 100 _min = astra . astra . version ( ) % 100 ASTRA_VERSION = <str> . join ( [ str ( _maj ) , str ( _min ) ] ) if ( _maj , _min ) < ( 1 , 7 ) :              warnings . warn ( <str> <str> . format ( _maj , _min ) , RuntimeWarning )    __all__ = ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , ) ASTRA_FEATURES = { <str> : None , <str> : <str> , <str> : <str> , <str> : None , <str> : <str> , <str> : None , <str> : <str> , <str> : <str> , <str> : <str> , } def astra_supports ( feature ) :      from odl . util . utility import pkg_supports return pkg_supports ( feature , ASTRA_VERSION , ASTRA_FEATURES )  def astra_versions_supporting ( feature ) :      try :          return ASTRA_FEATURES [ str ( feature ) ]  except KeyError :          raise ValueError ( <str> . format ( feature ) )   def astra_volume_geometry ( vol_space ) :      if not isinstance ( vol_space , DiscreteLp ) :          raise TypeError ( <str> <str> . format ( vol_space ) )  if not vol_space . is_uniform :          raise ValueError ( <str> )  vol_shp = vol_space . partition . shape vol_min = vol_space . partition . min_pt vol_max = vol_space . partition . max_pt if vol_space . ndim == 2 :          if ( not vol_space . partition . has_isotropic_cells and not astra_supports ( <str> ) ) :              req_ver = astra_versions_supporting ( <str> ) raise NotImplementedError ( <str> <str> . format ( req_ver ) )  vol_geom = astra . create_vol_geom ( vol_shp [ 0 ] , vol_shp [ 1 ] , vol_min [ 1 ] , vol_max [ 1 ] , - vol_max [ 0 ] , - vol_min [ 0 ] )  elif vol_space . ndim == 3 :          if ( not vol_space . partition . has_isotropic_cells and not astra_supports ( <str> ) ) :              req_ver = astra_versions_supporting ( <str> ) raise NotImplementedError ( <str> <str> . format ( req_ver ) )  vol_geom = astra . create_vol_geom ( vol_shp [ 1 ] , vol_shp [ 2 ] , vol_shp [ 0 ] , vol_min [ 2 ] , vol_max [ 2 ] , vol_min [ 1 ] , vol_max [ 1 ] , vol_min [ 0 ] , vol_max [ 0 ] )  else :          raise ValueError ( <str> <str> . format ( vol_space . ndim ) )  return vol_geom  def astra_conebeam_3d_geom_to_vec ( geometry ) :      angles = geometry . angles vectors = np . zeros ( ( angles . size , 12 ) ) vectors [ : , 0 : 3 ] = geometry . src_position ( angles ) mid_pt = geometry . det_params . mid_pt vectors [ : , 3 : 6 ] = geometry . det_point_position ( angles , mid_pt ) det_axes = np . moveaxis ( geometry . det_axes ( angles ) , - 2 , 0 ) px_sizes = geometry . det_partition . cell_sides vectors [ : , 9 : 12 ] = det_axes [ 0 ] * px_sizes [ 0 ] vectors [ : , 6 : 9 ] = det_axes [ 1 ] * px_sizes [ 1 ] newind = [ ] for i in range ( 4 ) :          newind += [ 2 + 3 * i , 1 + 3 * i , 0 + 3 * i ]  vectors = vectors [ : , newind ] return vectors  def astra_conebeam_2d_geom_to_vec ( geometry ) :      rot_minus_90 = euler_matrix ( - np . pi / 2 ) angles = geometry . angles vectors = np . zeros ( ( angles . size , 6 ) ) src_pos = geometry . src_position ( angles ) vectors [ : , 0 : 2 ] = rot_minus_90 . dot ( src_pos . T ) . T mid_pt = geometry . det_params . mid_pt centers = geometry . det_point_position ( angles , float ( mid_pt ) ) vectors [ : , 2 : 4 ] = rot_minus_90 . dot ( centers . T ) . T det_axis = rot_minus_90 . dot ( geometry . det_axis ( angles ) . T ) . T px_size = geometry . det_partition . cell_sides [ 0 ] vectors [ : , 4 : 6 ] = det_axis * px_size return vectors  def astra_parallel_3d_geom_to_vec ( geometry ) :      angles = geometry . angles mid_pt = geometry . det_params . mid_pt vectors = np . zeros ( ( angles . shape [ - 1 ] , 12 ) ) vectors [ : , 0 : 3 ] = - geometry . det_to_src ( angles , mid_pt ) vectors [ : , 3 : 6 ] = geometry . det_point_position ( angles , mid_pt ) det_axes = np . moveaxis ( geometry . det_axes ( angles ) , - 2 , 0 ) px_sizes = geometry . det_partition . cell_sides vectors [ : , 9 : 12 ] = det_axes [ 0 ] * px_sizes [ 0 ] vectors [ : , 6 : 9 ] = det_axes [ 1 ] * px_sizes [ 1 ] new_ind = [ ] for i in range ( 4 ) :          new_ind += [ 2 + 3 * i , 1 + 3 * i , 0 + 3 * i ]  vectors = vectors [ : , new_ind ] return vectors  def astra_projection_geometry ( geometry ) :      if not isinstance ( geometry , Geometry ) :          raise TypeError ( <str> <str> . format ( geometry ) )  if <str> in geometry . implementation_cache :          return geometry . implementation_cache [ <str> ]  if not geometry . det_partition . is_uniform :          raise ValueError ( <str> )  if ( isinstance ( geometry , ParallelBeamGeometry ) and isinstance ( geometry . detector , ( Flat1dDetector , Flat2dDetector ) ) and geometry . ndim == 2 ) :          det_width = geometry . det_partition . cell_sides [ 0 ] det_count = geometry . detector . size angles = geometry . angles - np . pi / 2 proj_geom = astra . create_proj_geom ( <str> , det_width , det_count , angles )  elif ( isinstance ( geometry , DivergentBeamGeometry ) and isinstance ( geometry . detector , ( Flat1dDetector , Flat2dDetector ) ) and geometry . ndim == 2 ) :          det_count = geometry . detector . size vec = astra_conebeam_2d_geom_to_vec ( geometry ) proj_geom = astra . create_proj_geom ( <str> , det_count , vec )  elif ( isinstance ( geometry , ParallelBeamGeometry ) and isinstance ( geometry . detector , ( Flat1dDetector , Flat2dDetector ) ) and geometry . ndim == 3 ) :          det_row_count = geometry . det_partition . shape [ 0 ] det_col_count = geometry . det_partition . shape [ 1 ] vec = astra_parallel_3d_geom_to_vec ( geometry ) proj_geom = astra . create_proj_geom ( <str> , det_row_count , det_col_count , vec )  elif ( isinstance ( geometry , DivergentBeamGeometry ) and isinstance ( geometry . detector , ( Flat1dDetector , Flat2dDetector ) ) and geometry . ndim == 3 ) :          det_row_count = geometry . det_partition . shape [ 0 ] det_col_count = geometry . det_partition . shape [ 1 ] vec = astra_conebeam_3d_geom_to_vec ( geometry ) proj_geom = astra . create_proj_geom ( <str> , det_row_count , det_col_count , vec )  else :          raise NotImplementedError ( <str> <str> . format ( geometry ) )  if <str> not in geometry . implementation_cache :          geometry . implementation_cache [ <str> ] = proj_geom  return proj_geom  def astra_data ( astra_geom , datatype , data = None , ndim = 2 , allow_copy = False ) :      if data is not None :          if isinstance ( data , ( DiscreteLpElement , np . ndarray ) ) :              ndim = data . ndim  else :              raise TypeError ( <str> <str> . format ( data ) )   else :          ndim = int ( ndim )  if datatype == <str> :          astra_dtype_str = <str>  elif datatype == <str> :          astra_dtype_str = <str>  else :          raise ValueError ( <str> . format ( datatype ) )  if ndim == 2 :          link = astra . data2d . link create = astra . data2d . create  elif ndim == 3 :          link = astra . data3d . link create = astra . data3d . create  else :          raise ValueError ( <str> <str> . format ( ndim ) )  if data is not None :          if allow_copy :              data_array = np . asarray ( data , dtype = <str> , order = <str> ) return link ( astra_dtype_str , astra_geom , data_array )  else :              if isinstance ( data , np . ndarray ) :                  return link ( astra_dtype_str , astra_geom , data )  elif data . tensor . impl == <str> :                  return link ( astra_dtype_str , astra_geom , data . asarray ( ) )  else :                  raise NotImplementedError ( <str> <str> <str> . format ( data ) )    else :          return create ( astra_dtype_str , astra_geom )   def astra_projector ( astra_proj_type , astra_vol_geom , astra_proj_geom , ndim ) :      if <str> not in astra_proj_geom :          raise ValueError ( <str> <str> . format ( astra_proj_geom ) )  ndim = int ( ndim ) astra_geom = astra_proj_geom [ <str> ] if ( astra_geom == <str> and not astra_supports ( <str> ) ) :          req_ver = astra_versions_supporting ( <str> ) raise ValueError ( <str> . format ( req_ver ) )  astra_proj_type = str ( astra_proj_type ) . lower ( ) if ( astra_proj_type == <str> and not astra_supports ( <str> ) ) :          req_ver = astra_versions_supporting ( <str> ) raise ValueError ( <str> . format ( req_ver ) )  if astra_geom in { <str> , <str> } :          valid_proj_types = [ <str> , <str> , <str> , <str> ] if astra_supports ( <str> ) :              valid_proj_types . append ( <str> )   elif astra_geom in { <str> , <str> } :          valid_proj_types = [ <str> , <str> , <str> ]  elif astra_geom in { <str> , <str> } :          valid_proj_types = [ <str> , <str> ]  elif astra_geom in { <str> , <str> } :          valid_proj_types = [ <str> , <str> ]  else :          raise ValueError ( <str> . format ( astra_geom ) )  if astra_proj_type not in valid_proj_types :          raise ValueError ( <str> <str> <str> . format ( astra_proj_type , valid_proj_types , astra_geom ) )  proj_cfg = { } proj_cfg [ <str> ] = astra_proj_type proj_cfg [ <str> ] = astra_vol_geom proj_cfg [ <str> ] = astra_proj_geom proj_cfg [ <str> ] = { } if ( astra_geom in ( <str> , <str> ) and astra_supports ( <str> ) ) :          proj_cfg [ <str> ] [ <str> ] = True  if ndim == 2 :          return astra . projector . create ( proj_cfg )  else :          return astra . projector3d . create ( proj_cfg )   def astra_algorithm ( direction , ndim , vol_id , sino_id , proj_id , impl ) :      if direction not in ( <str> , <str> ) :          raise ValueError ( <str> . format ( direction ) )  if ndim not in ( 2 , 3 ) :          raise ValueError ( <str> <str> . format ( ndim ) )  if impl not in ( <str> , <str> ) :          raise ValueError ( <str> <str> . format ( impl ) )  if ndim == 3 and impl == <str> :          raise NotImplementedError ( <str> )  if proj_id is None and impl == <str> :          raise ValueError ( <str> )  algo_map = { <str> : { 2 : { <str> : <str> , <str> : <str> } , 3 : { <str> : None , <str> : <str> } } , <str> : { 2 : { <str> : <str> , <str> : <str> } , 3 : { <str> : None , <str> : <str> } } } algo_cfg = { <str> : algo_map [ direction ] [ ndim ] [ impl ] , <str> : proj_id , <str> : sino_id } if direction == <str> :          algo_cfg [ <str> ] = vol_id  else :          algo_cfg [ <str> ] = vol_id  return astra . algorithm . create ( algo_cfg )  if __name__ == <str> :      from odl . util . testutils import run_doctests run_doctests ( )   