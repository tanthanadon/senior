from __future__ import print_function , division , absolute_import from numbers import Integral import numpy as np from odl . operator . operator import Operator from odl . operator . default_ops import ZeroOperator from odl . space import ProductSpace __all__ = ( <str> , <str> , <str> , <str> , <str> , <str> ) class ProductSpaceOperator ( Operator ) :      <str> def __init__ ( self , operators , domain = None , range = None ) :          import scipy . sparse if domain is not None :              if not isinstance ( domain , ProductSpace ) :                  raise TypeError ( <str> <str> . format ( domain ) )  if domain . is_weighted :                  raise NotImplementedError ( <str> )   if range is not None :              if not isinstance ( range , ProductSpace ) :                  raise TypeError ( <str> <str> . format ( range ) )  if range . is_weighted :                  raise NotImplementedError ( <str> )   if isinstance ( operators , scipy . sparse . spmatrix ) :              if not all ( isinstance ( op , Operator ) for op in operators . data ) :                  raise ValueError ( <str> <str> )  self . __ops = operators  else :              self . __ops = self . _convert_to_spmatrix ( operators )  if domain is None :              domains = [ None ] * self . __ops . shape [ 1 ]  else :              domains = domain  if range is None :              ranges = [ None ] * self . __ops . shape [ 0 ]  else :              ranges = range  for row , col , op in zip ( self . __ops . row , self . __ops . col , self . __ops . data ) :              if domains [ col ] is None :                  domains [ col ] = op . domain  elif domains [ col ] != op . domain :                  raise ValueError ( <str> <str> <str> . format ( col , domains [ col ] , op . domain ) )  if ranges [ row ] is None :                  ranges [ row ] = op . range  elif ranges [ row ] != op . range :                  raise ValueError ( <str> <str> <str> . format ( row , ranges [ row ] , op . range ) )   if domain is None :              for col , sub_domain in enumerate ( domains ) :                  if sub_domain is None :                      raise ValueError ( <str> <str> <str> . format ( col ) )   domain = ProductSpace ( * domains )  if range is None :              for row , sub_range in enumerate ( ranges ) :                  if sub_range is None :                      raise ValueError ( <str> <str> <str> . format ( row ) )   range = ProductSpace ( * ranges )  linear = all ( op . is_linear for op in self . __ops . data ) super ( ProductSpaceOperator , self ) . __init__ ( domain = domain , range = range , linear = linear )  @ staticmethod def _convert_to_spmatrix ( operators ) :          import scipy . sparse nrows = len ( operators ) ncols = None irow , icol , data = [ ] , [ ] , [ ] for i , row in enumerate ( operators ) :              try :                  iter ( row )  except TypeError :                  raise ValueError ( <str> <str> <str> . format ( operators , i , row ) )  if isinstance ( row , Operator ) :                  raise ValueError ( <str> <str> <str> . format ( i , row ) )  if ncols is None :                  ncols = len ( row )  elif len ( row ) != ncols :                  raise ValueError ( <str> <str> <str> . format ( len ( row ) , i , ncols ) )  for j , col in enumerate ( row ) :                  if col is None or col is 0 :                      pass  elif isinstance ( col , Operator ) :                      irow . append ( i ) icol . append ( j ) data . append ( col )  else :                      raise ValueError ( <str> <str> <str> . format ( col , i , j ) )    data_arr = np . empty ( len ( data ) , dtype = object ) data_arr [ : ] = data return scipy . sparse . coo_matrix ( ( data_arr , ( irow , icol ) ) , shape = ( nrows , ncols ) )  @ property def ops ( self ) :          return self . __ops  def _call ( self , x , out = None ) :          if out is None :              out = self . range . zero ( ) for i , j , op in zip ( self . ops . row , self . ops . col , self . ops . data ) :                  out [ i ] += op ( x [ j ] )   else :              has_evaluated_row = np . zeros ( len ( self . range ) , dtype = bool ) for i , j , op in zip ( self . ops . row , self . ops . col , self . ops . data ) :                  if not has_evaluated_row [ i ] :                      op ( x [ j ] , out = out [ i ] )  else :                      out [ i ] += op ( x [ j ] )  has_evaluated_row [ i ] = True  for i , evaluated in enumerate ( has_evaluated_row ) :                  if not evaluated :                      out [ i ] . set_zero ( )    return out  def derivative ( self , x ) :          import scipy . sparse if self . is_linear :              return self  deriv_ops = [ op . derivative ( x [ col ] ) for op , col in zip ( self . ops . data , self . ops . col ) ] data = np . empty ( len ( deriv_ops ) , dtype = object ) data [ : ] = deriv_ops indices = [ self . ops . row , self . ops . col ] shape = self . ops . shape deriv_matrix = scipy . sparse . coo_matrix ( ( data , indices ) , shape ) return ProductSpaceOperator ( deriv_matrix , self . domain , self . range )  @ property def adjoint ( self ) :          import scipy . sparse adjoint_ops = [ op . adjoint for op in self . ops . data ] data = np . empty ( len ( adjoint_ops ) , dtype = object ) data [ : ] = adjoint_ops indices = [ self . ops . col , self . ops . row ] shape = ( self . ops . shape [ 1 ] , self . ops . shape [ 0 ] ) adj_matrix = scipy . sparse . coo_matrix ( ( data , indices ) , shape ) return ProductSpaceOperator ( adj_matrix , self . range , self . domain )  def __getitem__ ( self , index ) :          if isinstance ( index , tuple ) :              row , col = index linear_index = np . flatnonzero ( ( self . ops . row == row ) & ( self . ops . col == col ) ) if linear_index . size == 0 :                  return 0  else :                  return self . ops . data [ int ( linear_index ) ]   else :              index = int ( index ) ops = [ None ] * len ( self . domain ) for op , col , row in zip ( self . ops . data , self . ops . col , self . ops . row ) :                  if row == index :                      ops [ col ] = op   for i in range ( len ( self . domain ) ) :                  if ops [ i ] is None :                      ops [ i ] = ZeroOperator ( self . domain [ i ] )   return ReductionOperator ( * ops )   @ property def shape ( self ) :          return self . ops . shape  def __len__ ( self ) :          return self . shape [ 0 ]  @ property def size ( self ) :          return np . prod ( self . shape , dtype = <str> )  def __repr__ ( self ) :          aslist = [ [ 0 ] * len ( self . domain ) for _ in range ( len ( self . range ) ) ] for i , j , op in zip ( self . ops . row , self . ops . col , self . ops . data ) :              aslist [ i ] [ j ] = op  return <str> . format ( self . __class__ . __name__ , aslist )   class ComponentProjection ( Operator ) :      <str> def __init__ ( self , space , index ) :          self . __index = index super ( ComponentProjection , self ) . __init__ ( space , space [ index ] , linear = True )  @ property def index ( self ) :          return self . __index  def _call ( self , x , out = None ) :          if out is None :              out = x [ self . index ] . copy ( )  else :              out . assign ( x [ self . index ] )  return out  @ property def adjoint ( self ) :          return ComponentProjectionAdjoint ( self . domain , self . index )  def __repr__ ( self ) :          return <str> . format ( self . __class__ . __name__ , self . domain , self . index )   class ComponentProjectionAdjoint ( Operator ) :      def __init__ ( self , space , index ) :          self . __index = index super ( ComponentProjectionAdjoint , self ) . __init__ ( space [ index ] , space , linear = True )  @ property def index ( self ) :          return self . __index  def _call ( self , x , out = None ) :          if out is None :              out = self . range . zero ( )  else :              out . set_zero ( )  out [ self . index ] = x return out  @ property def adjoint ( self ) :          return ComponentProjection ( self . range , self . index )  def __repr__ ( self ) :          return <str> . format ( self . __class__ . __name__ , self . range , self . index )   class BroadcastOperator ( Operator ) :      def __init__ ( self , * operators ) :          if ( len ( operators ) == 2 and isinstance ( operators [ 0 ] , Operator ) and isinstance ( operators [ 1 ] , Integral ) ) :              operators = ( operators [ 0 ] , ) * operators [ 1 ]  self . __operators = operators self . __prod_op = ProductSpaceOperator ( [ [ op ] for op in operators ] ) super ( BroadcastOperator , self ) . __init__ ( self . prod_op . domain [ 0 ] , self . prod_op . range , linear = self . prod_op . is_linear )  @ property def prod_op ( self ) :          return self . __prod_op  @ property def operators ( self ) :          return self . __operators  def __getitem__ ( self , index ) :          return self . operators [ index ]  def __len__ ( self ) :          return len ( self . operators )  @ property def size ( self ) :          return len ( self )  def _call ( self , x , out = None ) :          wrapped_x = self . prod_op . domain . element ( [ x ] , cast = False ) return self . prod_op ( wrapped_x , out = out )  def derivative ( self , x ) :          return BroadcastOperator ( * [ op . derivative ( x ) for op in self . operators ] )  @ property def adjoint ( self ) :          return ReductionOperator ( * [ op . adjoint for op in self . operators ] )  def __repr__ ( self ) :          if all ( op == self [ 0 ] for op in self ) :              return <str> . format ( self . __class__ . __name__ , self [ 0 ] , len ( self ) )  else :              op_repr = <str> . join ( repr ( op ) for op in self ) return <str> . format ( self . __class__ . __name__ , op_repr )    class ReductionOperator ( Operator ) :      def __init__ ( self , * operators ) :          if ( len ( operators ) == 2 and isinstance ( operators [ 0 ] , Operator ) and isinstance ( operators [ 1 ] , Integral ) ) :              operators = ( operators [ 0 ] , ) * operators [ 1 ]  self . __operators = operators self . __prod_op = ProductSpaceOperator ( [ operators ] ) super ( ReductionOperator , self ) . __init__ ( self . prod_op . domain , self . prod_op . range [ 0 ] , linear = self . prod_op . is_linear )  @ property def prod_op ( self ) :          return self . __prod_op  @ property def operators ( self ) :          return self . __operators  def __getitem__ ( self , index ) :          return self . operators [ index ]  def __len__ ( self ) :          return len ( self . operators )  @ property def size ( self ) :          return len ( self )  def _call ( self , x , out = None ) :          if out is None :              return self . prod_op ( x ) [ 0 ]  else :              wrapped_out = self . prod_op . range . element ( [ out ] , cast = False ) pspace_result = self . prod_op ( x , out = wrapped_out ) return pspace_result [ 0 ]   def derivative ( self , x ) :          return ReductionOperator ( * [ op . derivative ( xi ) for op , xi in zip ( self . operators , x ) ] )  @ property def adjoint ( self ) :          return BroadcastOperator ( * [ op . adjoint for op in self . operators ] )  def __repr__ ( self ) :          if all ( op == self [ 0 ] for op in self ) :              return <str> . format ( self . __class__ . __name__ , self [ 0 ] , len ( self ) )  else :              op_repr = <str> . join ( repr ( op ) for op in self ) return <str> . format ( self . __class__ . __name__ , op_repr )    class DiagonalOperator ( ProductSpaceOperator ) :      def __init__ ( self , * operators , ** kwargs ) :          import scipy . sparse if ( len ( operators ) == 2 and isinstance ( operators [ 0 ] , Operator ) and isinstance ( operators [ 1 ] , Integral ) ) :              operators = ( operators [ 0 ] , ) * operators [ 1 ]  n_ops = len ( operators ) irow = icol = np . arange ( n_ops ) data = np . empty ( n_ops , dtype = object ) data [ : ] = operators shape = ( n_ops , n_ops ) op_matrix = scipy . sparse . coo_matrix ( ( data , ( irow , icol ) ) , shape ) super ( DiagonalOperator , self ) . __init__ ( op_matrix , ** kwargs ) self . __operators = tuple ( operators )  @ property def operators ( self ) :          return self . __operators  def __getitem__ ( self , index ) :          return self . operators [ index ]  def __len__ ( self ) :          return len ( self . operators )  @ property def size ( self ) :          return len ( self )  def derivative ( self , point ) :          point = self . domain . element ( point ) derivs = [ op . derivative ( p ) for op , p in zip ( self . operators , point ) ] return DiagonalOperator ( * derivs , domain = self . domain , range = self . range )  @ property def adjoint ( self ) :          adjoints = [ op . adjoint for op in self . operators ] return DiagonalOperator ( * adjoints , domain = self . range , range = self . domain )  @ property def inverse ( self ) :          inverses = [ op . inverse for op in self . operators ] return DiagonalOperator ( * inverses , domain = self . range , range = self . domain )  def __repr__ ( self ) :          if all ( op == self [ 0 ] for op in self ) :              return <str> . format ( self . __class__ . __name__ , self [ 0 ] , len ( self ) )  else :              op_repr = <str> . join ( repr ( op ) for op in self ) return <str> . format ( self . __class__ . __name__ , op_repr )    if __name__ == <str> :      from odl . util . testutils import run_doctests run_doctests ( )   