from __future__ import print_function , division import numpy as np import odl __all__ = ( <str> , <str> , <str> , <str> , <str> , <str> ) def pdhg ( x , f , g , A , tau , sigma , niter , ** kwargs ) :      def fun_select ( k ) :          return [ 0 ]  f = odl . solvers . SeparableSum ( f ) A = odl . BroadcastOperator ( A , 1 ) y = kwargs . pop ( <str> , None ) if y is None :          y_new = None  else :          y_new = A . range . element ( [ y ] )  spdhg_generic ( x , f , g , A , tau , [ sigma ] , niter , fun_select , y = y_new , ** kwargs ) if y is not None :          y . assign ( y_new [ 0 ] )   def spdhg ( x , f , g , A , tau , sigma , niter , ** kwargs ) :      prob = kwargs . pop ( <str> , None ) if prob is None :          prob = [ 1 / len ( A ) ] * len ( A )  fun_select = kwargs . pop ( <str> , None ) if fun_select is None :          def fun_select ( x ) :              return [ int ( np . random . choice ( len ( A ) , 1 , p = prob ) ) ]   y = kwargs . pop ( <str> , None ) extra = [ 1 / p for p in prob ] spdhg_generic ( x , f , g , A , tau , sigma , niter , fun_select = fun_select , y = y , extra = extra , ** kwargs )  def pa_spdhg ( x , f , g , A , tau , sigma , niter , mu_g , ** kwargs ) :      prob = kwargs . pop ( <str> , None ) if prob is None :          prob = [ 1 / len ( A ) ] * len ( A )  fun_select = kwargs . pop ( <str> , None ) if fun_select is None :          def fun_select ( x ) :              return [ int ( np . random . choice ( len ( A ) , 1 , p = prob ) ) ]   y = kwargs . pop ( <str> , None ) extra = [ 1 / p for p in prob ] spdhg_generic ( x , f , g , A , tau , sigma , niter , fun_select = fun_select , extra = extra , mu_g = mu_g , y = y , ** kwargs )  def spdhg_generic ( x , f , g , A , tau , sigma , niter , ** kwargs ) :      callback = kwargs . pop ( <str> , None ) if callback is not None and not callable ( callback ) :          raise TypeError ( <str> <str> . format ( callback ) )  y = kwargs . pop ( <str> , None ) if y is None :          y = A . range . zero ( )  z = kwargs . pop ( <str> , None ) if z is None :          if y . norm ( ) == 0 :              z = A . domain . zero ( )  else :              z = A . adjoint ( y )   mu_g = kwargs . pop ( <str> , None ) if mu_g is None :          update_proximal_primal = False  else :          update_proximal_primal = True  theta = kwargs . pop ( <str> , 1 ) extra = kwargs . pop ( <str> , None ) if extra is None :          extra = [ 1 ] * len ( sigma )  fun_select = kwargs . pop ( <str> , None ) if fun_select is None :          def fun_select ( x ) :              return [ int ( np . random . choice ( len ( A ) , 1 , p = 1 / len ( A ) ) ) ]   z_relax = z . copy ( ) dz = A . domain . element ( ) y_old = A . range . element ( ) proximal_dual_sigma = [ fi . convex_conj . proximal ( si ) for fi , si in zip ( f , sigma ) ] proximal_primal_tau = g . proximal ( tau ) for k in range ( niter ) :          selected = fun_select ( k ) z_relax . lincomb ( 1 , x , - tau , z_relax ) proximal_primal_tau ( z_relax , out = x ) if update_proximal_primal :              theta = float ( 1 / np . sqrt ( 1 + 2 * mu_g * tau ) )  z_relax . assign ( z ) for i in selected :              y_old [ i ] . assign ( y [ i ] ) A [ i ] ( x , out = y [ i ] ) y [ i ] . lincomb ( 1 , y_old [ i ] , sigma [ i ] , y [ i ] ) proximal_dual_sigma [ i ] ( y [ i ] , out = y [ i ] ) y_old [ i ] . lincomb ( - 1 , y_old [ i ] , 1 , y [ i ] ) A [ i ] . adjoint ( y_old [ i ] , out = dz ) z += dz z_relax . lincomb ( 1 , z_relax , 1 + theta * extra [ i ] , dz )  if update_proximal_primal :              for i in range ( len ( sigma ) ) :                  sigma [ i ] /= theta  tau *= theta proximal_dual_sigma = [ fi . convex_conj . proximal ( si ) for fi , si in zip ( f , sigma ) ] proximal_primal_tau = g . proximal ( tau )  if callback is not None :              callback ( [ x , y ] )    def da_spdhg ( x , f , g , A , tau , sigma_tilde , niter , mu , ** kwargs ) :      callback = kwargs . pop ( <str> , None ) if callback is not None and not callable ( callback ) :          raise TypeError ( <str> <str> . format ( callback ) )  prob = kwargs . pop ( <str> , None ) if prob is None :          prob = [ 1 / len ( A ) ] * len ( A )  fun_select = kwargs . pop ( <str> , None ) if fun_select is None :          def fun_select ( x ) :              return [ int ( np . random . choice ( len ( A ) , 1 , p = prob ) ) ]   y = kwargs . pop ( <str> , None ) if y is None :          y = A . range . zero ( )  z = kwargs . pop ( <str> , None ) if z is None and y . norm ( ) == 0 :          z = A . domain . zero ( )  extra = kwargs . pop ( <str> , None ) if extra is None :          extra = [ 1 / p for p in prob ]  z_relax = z . copy ( ) dz = A . domain . element ( ) y_old = A . range . element ( ) prox_dual = [ fi . convex_conj . proximal for fi in f ] prox_primal = g . proximal for k in range ( niter ) :          selected = fun_select ( k ) theta = float ( 1 / np . sqrt ( 1 + 2 * sigma_tilde ) ) z_relax . lincomb ( 1 , x , - tau , z_relax ) prox_primal ( tau ) ( z_relax , out = x ) z_relax . assign ( z ) for i in selected :              sigma_i = sigma_tilde / ( mu [ i ] * ( prob [ i ] - 2 * ( 1 - prob [ i ] ) * sigma_tilde ) ) y_old [ i ] . assign ( y [ i ] ) A [ i ] ( x , out = y [ i ] ) y [ i ] . lincomb ( 1 , y_old [ i ] , sigma_i , y [ i ] ) prox_dual [ i ] ( sigma_i ) ( y [ i ] , out = y [ i ] ) y_old [ i ] . lincomb ( - 1 , y_old [ i ] , 1 , y [ i ] ) A [ i ] . adjoint ( y_old [ i ] , out = dz ) z += dz z_relax . lincomb ( 1 , z_relax , 1 + theta * extra [ i ] , dz )  sigma_tilde *= theta tau /= theta if callback is not None :              callback ( [ x , y ] )    def spdhg_pesquet ( x , f , g , A , tau , sigma , niter , ** kwargs ) :      callback = kwargs . pop ( <str> , None ) if callback is not None and not callable ( callback ) :          raise TypeError ( <str> <str> . format ( callback ) )  fun_select = kwargs . pop ( <str> , None ) if fun_select is None :          def fun_select ( x ) :              return [ int ( np . random . choice ( len ( A ) , 1 , p = 1 / len ( A ) ) ) ]   y = kwargs . pop ( <str> , None ) if y is None :          y = A . range . zero ( )  z = kwargs . pop ( <str> , None ) if z is None and y . norm ( ) == 0 :          z = A . domain . zero ( )  prox_f = [ f [ i ] . convex_conj . proximal ( sigma [ i ] ) for i in range ( len ( sigma ) ) ] prox_g = g . proximal ( tau ) x_relax = x . copy ( ) y_old = A . range . element ( ) dz = z . copy ( ) for k in range ( niter ) :          x_relax . lincomb ( - 1 , x ) x . lincomb ( 1 , x , - tau , z ) prox_g ( x , out = x ) x_relax . lincomb ( 1 , x_relax , 2 , x ) selected = fun_select ( k ) for i in selected :              y_old [ i ] . assign ( y [ i ] ) A [ i ] ( x_relax , out = y [ i ] ) y [ i ] *= sigma [ i ] y [ i ] += y_old [ i ] prox_f [ i ] ( y [ i ] , out = y [ i ] ) A [ i ] . adjoint ( y [ i ] - y_old [ i ] , out = dz ) z += dz  if callback is not None :              callback ( [ x , y ] )     