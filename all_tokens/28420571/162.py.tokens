from __future__ import print_function , division , absolute_import from builtins import object import numpy as np from odl . set . sets import Field , Set , UniversalSet __all__ = ( <str> , <str> ) class LinearSpace ( Set ) :      def __init__ ( self , field ) :          if field is None or isinstance ( field , Field ) :              self . __field = field  else :              raise TypeError ( <str> <str> . format ( field ) )   @ property def field ( self ) :          return self . __field  def element ( self , inp = None , ** kwargs ) :          raise NotImplementedError ( <str> )  @ property def examples ( self ) :          yield ( <str> , self . zero ( ) ) try :              yield ( <str> , self . one ( ) )  except NotImplementedError :              pass   def _lincomb ( self , a , x1 , b , x2 , out ) :          raise NotImplementedError ( <str> )  def _dist ( self , x1 , x2 ) :          return self . norm ( x1 - x2 )  def _norm ( self , x ) :          return float ( np . sqrt ( self . inner ( x , x ) . real ) )  def _inner ( self , x1 , x2 ) :          raise LinearSpaceNotImplementedError ( <str> . format ( self ) )  def _multiply ( self , x1 , x2 , out ) :          raise LinearSpaceNotImplementedError ( <str> . format ( self ) )  def one ( self ) :          raise LinearSpaceNotImplementedError ( <str> . format ( self ) )  def zero ( self ) :          tmp = self . element ( ) self . lincomb ( 0 , tmp , 0 , tmp , tmp ) return tmp  def __contains__ ( self , other ) :          return getattr ( other , <str> , None ) == self  def lincomb ( self , a , x1 , b = None , x2 = None , out = None ) :          if out is None :              out = self . element ( )  elif out not in self :              raise LinearSpaceTypeError ( <str> <str> . format ( out , self ) )  if self . field is not None and a not in self . field :              raise LinearSpaceTypeError ( <str> <str> <str> . format ( a , self . field , self ) )  if x1 not in self :              raise LinearSpaceTypeError ( <str> <str> . format ( x1 , self ) )  if b is None :              if x2 is not None :                  raise ValueError ( <str> )  self . _lincomb ( a , x1 , 0 , x1 , out ) return out  else :              if self . field is not None and b not in self . field :                  raise LinearSpaceTypeError ( <str> <str> <str> . format ( b , self . field , self ) )  if x2 not in self :                  raise LinearSpaceTypeError ( <str> <str> . format ( x2 , self ) )  self . _lincomb ( a , x1 , b , x2 , out )  return out  def dist ( self , x1 , x2 ) :          if x1 not in self :              raise LinearSpaceTypeError ( <str> <str> . format ( x1 , self ) )  if x2 not in self :              raise LinearSpaceTypeError ( <str> <str> . format ( x2 , self ) )  return float ( self . _dist ( x1 , x2 ) )  def norm ( self , x ) :          if x not in self :              raise LinearSpaceTypeError ( <str> <str> . format ( x , self ) )  return float ( self . _norm ( x ) )  def inner ( self , x1 , x2 ) :          if x1 not in self :              raise LinearSpaceTypeError ( <str> <str> . format ( x1 , self ) )  if x2 not in self :              raise LinearSpaceTypeError ( <str> <str> . format ( x2 , self ) )  inner = self . _inner ( x1 , x2 ) if self . field is None :              return inner  else :              return self . field . element ( self . _inner ( x1 , x2 ) )   def multiply ( self , x1 , x2 , out = None ) :          if out is None :              out = self . element ( )  if out not in self :              raise LinearSpaceTypeError ( <str> <str> . format ( out , self ) )  if x1 not in self :              raise LinearSpaceTypeError ( <str> <str> . format ( x1 , self ) )  if x2 not in self :              raise LinearSpaceTypeError ( <str> <str> . format ( x2 , self ) )  self . _multiply ( x1 , x2 , out ) return out  def divide ( self , x1 , x2 , out = None ) :          if out is None :              out = self . element ( )  if out not in self :              raise LinearSpaceTypeError ( <str> <str> . format ( out , self ) )  if x1 not in self :              raise LinearSpaceTypeError ( <str> <str> . format ( x1 , self ) )  if x2 not in self :              raise LinearSpaceTypeError ( <str> <str> . format ( x2 , self ) )  self . _divide ( x1 , x2 , out ) return out  @ property def element_type ( self ) :          return LinearSpaceElement  def __pow__ ( self , shape ) :          from odl . space import ProductSpace try :              shape = ( int ( shape ) , )  except TypeError :              shape = tuple ( shape )  pspace = self for n in shape :              pspace = ProductSpace ( pspace , n )  return pspace  def __mul__ ( self , other ) :          from odl . space import ProductSpace if not isinstance ( other , LinearSpace ) :              raise TypeError ( <str> <str> . format ( other ) )  return ProductSpace ( self , other )  def __str__ ( self ) :          return repr ( self )   class LinearSpaceElement ( object ) :      def __init__ ( self , space ) :          self . __space = space  @ property def space ( self ) :          return self . __space  def assign ( self , other ) :          return self . space . lincomb ( 1 , other , out = self )  def copy ( self ) :          result = self . space . element ( ) result . assign ( self ) return result  def lincomb ( self , a , x1 , b = None , x2 = None ) :          return self . space . lincomb ( a , x1 , b , x2 , out = self )  def set_zero ( self ) :          return self . space . lincomb ( 0 , self , 0 , self , out = self )  def __iadd__ ( self , other ) :          if self . space . field is None :              return NotImplemented  elif other in self . space :              return self . space . lincomb ( 1 , self , 1 , other , out = self )  elif isinstance ( other , LinearSpaceElement ) :              raise TypeError ( <str> <str> . format ( self , other ) )  elif other in self . space . field :              one = getattr ( self . space , <str> , None ) if one is None :                  raise TypeError ( <str> <str> . format ( self , other ) )  else :                  return self . space . lincomb ( 1 , self , other , one ( ) , out = self )   else :              try :                  other = self . space . element ( other )  except ( TypeError , ValueError ) :                  raise TypeError ( <str> <str> . format ( self , other ) )  else :                  return self . __iadd__ ( other )    def __add__ ( self , other ) :          if getattr ( other , <str> , 0 ) > self . __array_priority__ :              return other . __radd__ ( self )  elif self . space . field is None :              return NotImplemented  elif other in self . space :              tmp = self . space . element ( ) return self . space . lincomb ( 1 , self , 1 , other , out = tmp )  elif isinstance ( other , LinearSpaceElement ) :              return NotImplemented  elif other in self . space . field :              one = getattr ( self . space , <str> , None ) if one is None :                  return NotImplemented  else :                  tmp = one ( ) return self . space . lincomb ( 1 , self , other , tmp , out = tmp )   else :              try :                  other = self . space . element ( other )  except ( TypeError , ValueError ) :                  return NotImplemented  else :                  return self . __add__ ( other )    def __radd__ ( self , other ) :          if getattr ( other , <str> , 0 ) > self . __array_priority__ :              return other . __add__ ( self )  else :              return self . __add__ ( other )   def __isub__ ( self , other ) :          if self . space . field is None :              return NotImplemented  elif other in self . space :              return self . space . lincomb ( 1 , self , - 1 , other , out = self )  elif isinstance ( other , LinearSpaceElement ) :              raise TypeError ( <str> <str> . format ( self , other ) )  elif self . space . field is None :              return NotImplemented  elif other in self . space . field :              one = getattr ( self . space , <str> , None ) if one is None :                  raise TypeError ( <str> <str> . format ( self , other ) )  else :                  return self . space . lincomb ( 1 , self , - other , one ( ) , out = self )   else :              try :                  other = self . space . element ( other )  except ( TypeError , ValueError ) :                  raise TypeError ( <str> <str> . format ( self , other ) )  else :                  return self . __isub__ ( other )    def __sub__ ( self , other ) :          if getattr ( other , <str> , 0 ) > self . __array_priority__ :              return other . __rsub__ ( self )  elif self . space . field is None :              return NotImplemented  elif other in self . space :              tmp = self . space . element ( ) return self . space . lincomb ( 1 , self , - 1 , other , out = tmp )  elif isinstance ( other , LinearSpaceElement ) :              return NotImplemented  elif other in self . space . field :              one = getattr ( self . space , <str> , None ) if one is None :                  return NotImplemented  else :                  tmp = one ( ) return self . space . lincomb ( 1 , self , - other , tmp , out = tmp )   else :              try :                  other = self . space . element ( other )  except ( TypeError , ValueError ) :                  return NotImplemented  else :                  return self . __sub__ ( other )    def __rsub__ ( self , other ) :          if getattr ( other , <str> , 0 ) > self . __array_priority__ :              return other . __sub__ ( self )  elif self . space . field is None :              return NotImplemented  elif other in self . space :              tmp = self . space . element ( ) return self . space . lincomb ( 1 , other , - 1 , self , out = tmp )  elif isinstance ( other , LinearSpaceElement ) :              return NotImplemented  elif other in self . space . field :              one = getattr ( self . space , <str> , None ) if one is None :                  return NotImplemented  else :                  tmp = one ( ) self . space . lincomb ( other , tmp , out = tmp ) return self . space . lincomb ( 1 , tmp , - 1 , self , out = tmp )   else :              try :                  other = self . space . element ( other )  except ( TypeError , ValueError ) :                  return NotImplemented  else :                  return self . __rsub__ ( other )    def __imul__ ( self , other ) :          if self . space . field is None :              return NotImplemented  elif other in self . space . field :              return self . space . lincomb ( other , self , out = self )  elif other in self . space :              return self . space . multiply ( other , self , out = self )  elif isinstance ( other , LinearSpaceElement ) :              raise TypeError ( <str> <str> . format ( self , other ) )  else :              try :                  other = self . space . element ( other )  except ( TypeError , ValueError ) :                  raise TypeError ( <str> <str> . format ( self , other ) )  else :                  return self . __imul__ ( other )    def __mul__ ( self , other ) :          if getattr ( other , <str> , 0 ) > self . __array_priority__ :              return other . __rmul__ ( self )  elif self . space . field is None :              return NotImplemented  elif other in self . space . field :              tmp = self . space . element ( ) return self . space . lincomb ( other , self , out = tmp )  elif other in self . space :              tmp = self . space . element ( ) return self . space . multiply ( other , self , out = tmp )  elif isinstance ( other , LinearSpaceElement ) :              return NotImplemented  else :              try :                  other = self . space . element ( other )  except ( TypeError , ValueError ) :                  return NotImplemented  else :                  return self . __mul__ ( other )    def __rmul__ ( self , other ) :          if getattr ( other , <str> , 0 ) > self . __array_priority__ :              return other . __mul__ ( self )  else :              return self . __mul__ ( other )   def __itruediv__ ( self , other ) :          if self . space . field is None :              return NotImplemented  if other in self . space . field :              return self . space . lincomb ( 1.0 / other , self , out = self )  elif other in self . space :              return self . space . divide ( self , other , out = self )  elif isinstance ( other , LinearSpaceElement ) :              raise TypeError ( <str> <str> . format ( self , other ) )  else :              try :                  other = self . space . element ( other )  except ( TypeError , ValueError ) :                  raise TypeError ( <str> <str> . format ( self , other ) )  else :                  return self . __itruediv__ ( other )    __idiv__ = __itruediv__ def __truediv__ ( self , other ) :          if getattr ( other , <str> , 0 ) > self . __array_priority__ :              return other . __rtruediv__ ( self )  elif self . space . field is None :              return NotImplemented  elif other in self . space . field :              tmp = self . space . element ( ) return self . space . lincomb ( 1.0 / other , self , out = tmp )  elif other in self . space :              tmp = self . space . element ( ) return self . space . divide ( self , other , out = tmp )  elif isinstance ( other , LinearSpaceElement ) :              return NotImplemented  else :              try :                  other = self . space . element ( other )  except ( TypeError , ValueError ) :                  return NotImplemented  else :                  return self . __truediv__ ( other )    __div__ = __truediv__ def __rtruediv__ ( self , other ) :          if getattr ( other , <str> , 0 ) > self . __array_priority__ :              return other . __truediv__ ( self )  elif self . space . field is None :              return NotImplemented  elif other in self . space . field :              one = getattr ( self . space , <str> , None ) if one is None :                  return NotImplemented  else :                  tmp = one ( ) self . space . lincomb ( other , tmp , out = tmp ) return self . space . divide ( tmp , self , out = tmp )   elif other in self . space :              tmp = self . space . element ( ) return self . space . divide ( other , self , out = tmp )  elif isinstance ( other , LinearSpaceElement ) :              return NotImplemented  else :              try :                  other = self . space . element ( other )  except ( TypeError , ValueError ) :                  return NotImplemented  else :                  return self . __rtruediv__ ( other )    __rdiv__ = __rtruediv__ def __ipow__ ( self , p ) :          if self . space . field is None :              return NotImplemented  p , p_in = int ( p ) , p if p != p_in :              raise ValueError ( <str> . format ( p_in ) )  if p < 0 :              self **= - p self . space . divide ( self . space . one ( ) , self , out = self ) return self  elif p == 0 :              self . assign ( self . space . one ( ) ) return self  elif p == 1 :              return self  elif p % 2 == 0 :              self *= self self **= p // 2 return self  else :              tmp = self . copy ( ) for _ in range ( p - 2 ) :                  tmp *= self  self *= tmp return self   def __pow__ ( self , p ) :          if self . space . field is None :              return NotImplemented  tmp = self . copy ( ) tmp . __ipow__ ( p ) return tmp  def __neg__ ( self ) :          if self . space . field is None :              return NotImplemented  return ( - 1 ) * self  def __pos__ ( self ) :          return self . copy ( )  def __cmp__ ( self , other ) :          raise TypeError ( <str> <str> . format ( self . __class__ . __name__ , type ( other ) ) )  def __eq__ ( self , other ) :          if other is self :              return True  elif ( not isinstance ( other , LinearSpaceElement ) or other . space != self . space ) :              return False  else :              return self . space . dist ( self , other ) == 0   def __ne__ ( self , other ) :          return not self . __eq__ ( other )  __hash__ = None def __str__ ( self ) :          return repr ( self )  def __copy__ ( self ) :          return self . copy ( )  def __deepcopy__ ( self , memo ) :          return self . copy ( )  def norm ( self ) :          return self . space . norm ( self )  def dist ( self , other ) :          return self . space . dist ( self , other )  def inner ( self , other ) :          return self . space . inner ( self , other )  def multiply ( self , other , out = None ) :          return self . space . multiply ( self , other , out = out )  def divide ( self , other , out = None ) :          return self . space . divide ( self , other , out = out )  @ property def T ( self ) :          from odl . operator import InnerProductOperator return InnerProductOperator ( self . copy ( ) )  __array_priority__ = 1000000.0  class UniversalSpace ( LinearSpace ) :      def __init__ ( self ) :          super ( UniversalSpace , self ) . __init__ ( field = UniversalSet ( ) )  def element ( self , inp = None ) :          raise LinearSpaceNotImplementedError  def _lincomb ( self , a , x1 , b , x2 , out ) :          raise LinearSpaceNotImplementedError  def _dist ( self , x1 , x2 ) :          raise LinearSpaceNotImplementedError  def _norm ( self , x ) :          raise LinearSpaceNotImplementedError  def _inner ( self , x1 , x2 ) :          raise LinearSpaceNotImplementedError  def _multiply ( self , x1 , x2 , out ) :          raise LinearSpaceNotImplementedError  def _divide ( self , x1 , x2 , out ) :          raise LinearSpaceNotImplementedError  def __eq__ ( self , other ) :          return isinstance ( other , LinearSpace )  def __contains__ ( self , other ) :          return isinstance ( other , LinearSpaceElement )   class LinearSpaceTypeError ( TypeError ) :       class LinearSpaceNotImplementedError ( NotImplementedError ) :       if __name__ == <str> :      from odl . util . testutils import run_doctests run_doctests ( )   