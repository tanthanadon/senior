from __future__ import print_function , division , absolute_import import numpy as np from odl . discr import ( uniform_grid , DiscreteLp , uniform_partition_fromgrid , uniform_discr_frompartition ) from odl . set import RealNumbers from odl . util import ( fast_1d_tensor_mult , conj_exponent , is_real_dtype , is_numeric_dtype , is_real_floating_dtype , is_complex_floating_dtype , complex_dtype , dtype_repr , is_string , normalized_scalar_param_list , normalized_axes_tuple ) __all__ = ( <str> , <str> , <str> , <str> , <str> ) def reciprocal_grid ( grid , shift = True , axes = None , halfcomplex = False ) :      if axes is None :          axes = list ( range ( grid . ndim ) )  else :          try :              axes = [ int ( axes ) ]  except TypeError :              axes = list ( axes )   shift_list = normalized_scalar_param_list ( shift , length = len ( axes ) , param_conv = bool ) stride = grid . stride . copy ( ) stride [ stride == 0 ] = 1 shape = np . array ( grid . shape ) rmin = grid . min_pt . copy ( ) rmax = grid . max_pt . copy ( ) rshape = list ( shape ) shifted = np . zeros ( grid . ndim , dtype = bool ) shifted [ axes ] = shift_list rmin [ shifted ] = - np . pi / stride [ shifted ] rmax [ shifted ] = ( - rmin [ shifted ] - 2 * np . pi / ( stride [ shifted ] * shape [ shifted ] ) ) not_shifted = np . zeros ( grid . ndim , dtype = bool ) not_shifted [ axes ] = np . logical_not ( shift_list ) rmin [ not_shifted ] = ( ( - 1.0 + 1.0 / shape [ not_shifted ] ) * np . pi / stride [ not_shifted ] ) rmax [ not_shifted ] = - rmin [ not_shifted ] if halfcomplex :          rshape [ axes [ - 1 ] ] = shape [ axes [ - 1 ] ] // 2 + 1 last_odd = shape [ axes [ - 1 ] ] % 2 == 1 last_shifted = shift_list [ - 1 ] half_rstride = np . pi / ( shape [ axes [ - 1 ] ] * stride [ axes [ - 1 ] ] ) if last_odd and last_shifted :              rmax [ axes [ - 1 ] ] = - half_rstride  elif not last_odd and not last_shifted :              rmax [ axes [ - 1 ] ] = half_rstride  else :              rmax [ axes [ - 1 ] ] = 0   return uniform_grid ( rmin , rmax , rshape )  def realspace_grid ( recip_grid , x0 , axes = None , halfcomplex = False , halfcx_parity = <str> ) :      if axes is None :          axes = list ( range ( recip_grid . ndim ) )  else :          try :              axes = [ int ( axes ) ]  except TypeError :              axes = list ( axes )   rstride = recip_grid . stride rshape = recip_grid . shape irshape = list ( rshape ) if halfcomplex :          if str ( halfcx_parity ) . lower ( ) == <str> :              irshape [ axes [ - 1 ] ] = 2 * rshape [ axes [ - 1 ] ] - 2  elif str ( halfcx_parity ) . lower ( ) == <str> :              irshape [ axes [ - 1 ] ] = 2 * rshape [ axes [ - 1 ] ] - 1  else :              raise ValueError ( <str> <str> . format ( halfcx_parity ) )   irmin = np . asarray ( x0 ) irshape = np . asarray ( irshape ) irstride = np . copy ( rstride ) irstride [ axes ] = 2 * np . pi / ( irshape [ axes ] * rstride [ axes ] ) irmax = irmin + ( irshape - 1 ) * irstride return uniform_grid ( irmin , irmax , irshape )  def dft_preprocess_data ( arr , shift = True , axes = None , sign = <str> , out = None ) :      arr = np . asarray ( arr ) if not is_numeric_dtype ( arr . dtype ) :          raise ValueError ( <str> <str> . format ( dtype_repr ( arr . dtype ) ) )  elif is_real_dtype ( arr . dtype ) and not is_real_floating_dtype ( arr . dtype ) :          arr = arr . astype ( <str> )  if axes is None :          axes = list ( range ( arr . ndim ) )  else :          try :              axes = [ int ( axes ) ]  except TypeError :              axes = list ( axes )   shape = arr . shape shift_list = normalized_scalar_param_list ( shift , length = len ( axes ) , param_conv = bool ) if out is None :          if is_real_dtype ( arr . dtype ) and not all ( shift_list ) :              out = np . array ( arr , dtype = complex_dtype ( arr . dtype ) , copy = True )  else :              out = arr . copy ( )   else :          out [ : ] = arr  if is_real_dtype ( out . dtype ) and not shift :          raise ValueError ( <str> <str> )  if sign == <str> :          imag = - 1j  elif sign == <str> :          imag = 1j  else :          raise ValueError ( <str> . format ( sign ) )  def _onedim_arr ( length , shift ) :          if shift :              factor = np . ones ( length , dtype = out . dtype ) factor [ 1 : : 2 ] = - 1  else :              factor = np . arange ( length , dtype = out . dtype ) factor *= - imag * np . pi * ( 1 - 1.0 / length ) np . exp ( factor , out = factor )  return factor . astype ( out . dtype , copy = False )  onedim_arrs = [ ] for axis , shift in zip ( axes , shift_list ) :          length = shape [ axis ] onedim_arrs . append ( _onedim_arr ( length , shift ) )  fast_1d_tensor_mult ( out , onedim_arrs , axes = axes , out = out ) return out  def _interp_kernel_ft ( norm_freqs , interp ) :      ker_ft = np . sinc ( norm_freqs ) interp_ = str ( interp ) . lower ( ) if interp_ == <str> :          pass  elif interp_ == <str> :          ker_ft *= ker_ft  else :          raise ValueError ( <str> . format ( interp ) )  ker_ft /= np . sqrt ( 2 * np . pi ) return ker_ft  def dft_postprocess_data ( arr , real_grid , recip_grid , shift , axes , interp , sign = <str> , op = <str> , out = None ) :      arr = np . asarray ( arr ) if is_real_floating_dtype ( arr . dtype ) :          arr = arr . astype ( complex_dtype ( arr . dtype ) )  elif not is_complex_floating_dtype ( arr . dtype ) :          raise ValueError ( <str> <str> . format ( dtype_repr ( arr . dtype ) ) )  if out is None :          out = arr . copy ( )  elif out is not arr :          out [ : ] = arr  if axes is None :          axes = list ( range ( arr . ndim ) )  else :          try :              axes = [ int ( axes ) ]  except TypeError :              axes = list ( axes )   shift_list = normalized_scalar_param_list ( shift , length = len ( axes ) , param_conv = bool ) if sign == <str> :          imag = - 1j  elif sign == <str> :          imag = 1j  else :          raise ValueError ( <str> . format ( sign ) )  op , op_in = str ( op ) . lower ( ) , op if op not in ( <str> , <str> ) :          raise ValueError ( <str> . format ( op_in ) )  if is_string ( interp ) :          interp = [ str ( interp ) . lower ( ) ] * arr . ndim  onedim_arrs = [ ] for ax , shift , intp in zip ( axes , shift_list , interp ) :          x = real_grid . min_pt [ ax ] xi = recip_grid . coord_vectors [ ax ] onedim_arr = np . exp ( imag * x * xi ) len_dft = recip_grid . shape [ ax ] len_orig = real_grid . shape [ ax ] halfcomplex = ( len_dft < len_orig ) odd = len_orig % 2 fmin = - 0.5 if shift else - 0.5 + 1.0 / ( 2 * len_orig ) if halfcomplex :              if shift and odd :                  fmax = - 1.0 / ( 2 * len_orig )  elif not shift and not odd :                  fmax = 1.0 / ( 2 * len_orig )  else :                  fmax = 0.0   else :              if shift :                  fmax = 0.5 - 1.0 / len_orig  else :                  fmax = 0.5 - 1.0 / ( 2 * len_orig )   freqs = np . linspace ( fmin , fmax , num = len_dft ) stride = real_grid . stride [ ax ] interp_kernel = _interp_kernel_ft ( freqs , intp ) interp_kernel *= stride if op == <str> :              onedim_arr *= interp_kernel  else :              onedim_arr /= interp_kernel  onedim_arrs . append ( onedim_arr . astype ( out . dtype , copy = False ) )  fast_1d_tensor_mult ( out , onedim_arrs , axes = axes , out = out ) return out  def reciprocal_space ( space , axes = None , halfcomplex = False , shift = True , ** kwargs ) :      if not isinstance ( space , DiscreteLp ) :          raise TypeError ( <str> <str> . format ( space ) )  if axes is None :          axes = tuple ( range ( space . ndim ) )  axes = normalized_axes_tuple ( axes , space . ndim ) if not all ( space . is_uniform_byaxis [ axis ] for axis in axes ) :          raise ValueError ( <str> <str> )  if halfcomplex and space . field != RealNumbers ( ) :          raise ValueError ( <str> <str> )  exponent = kwargs . pop ( <str> , None ) if exponent is None :          exponent = conj_exponent ( space . exponent )  dtype = kwargs . pop ( <str> , None ) if dtype is None :          dtype = complex_dtype ( space . dtype )  else :          if not is_complex_floating_dtype ( dtype ) :              raise ValueError ( <str> <str> . format ( dtype_repr ( dtype ) ) )   impl = kwargs . pop ( <str> , <str> ) recip_grid = reciprocal_grid ( space . grid , shift = shift , halfcomplex = halfcomplex , axes = axes ) non_axes = [ i for i in range ( space . ndim ) if i not in axes ] min_pt = { i : space . min_pt [ i ] for i in non_axes } max_pt = { i : space . max_pt [ i ] for i in non_axes } if halfcomplex :          max_pt [ axes [ - 1 ] ] = recip_grid . max_pt [ axes [ - 1 ] ]  part = uniform_partition_fromgrid ( recip_grid , min_pt , max_pt ) axis_labels = list ( space . axis_labels ) for i in axes :          label = axis_labels [ i ] . replace ( <str> , <str> ) axis_labels [ i ] = <str> . format ( label )  recip_spc = uniform_discr_frompartition ( part , exponent = exponent , dtype = dtype , impl = impl , axis_labels = axis_labels ) return recip_spc  if __name__ == <str> :      from doctest import testmod , NORMALIZE_WHITESPACE testmod ( optionflags = NORMALIZE_WHITESPACE )   