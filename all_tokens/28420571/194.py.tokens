from __future__ import division , print_function import odl import odl . contrib . solvers . spdhg as spdhg import odl . contrib . datasets . images as images import numpy as np image_gray = images . building ( gray = True ) X = odl . uniform_discr ( [ 0 , 0 ] , image_gray . shape , image_gray . shape ) groundtruth = X . element ( image_gray ) data = odl . phantom . white_noise ( X , mean = groundtruth , stddev = 0.1 , seed = 1807 ) alpha = .12 nepoch = 100 A = odl . BroadcastOperator ( * [ odl . PartialDerivative ( X , d , pad_mode = <str> ) for d in [ 0 , 1 ] ] ) f = odl . solvers . SeparableSum ( * [ odl . solvers . L1Norm ( Yi ) for Yi in A . range ] ) g = 1 / ( 2 * alpha ) * odl . solvers . L2NormSquared ( X ) . translated ( data ) n = 2 prob = [ 1 / n ] * n S = [ [ 0 ] , [ 1 ] ] def fun_select ( k ) :      return S [ int ( np . random . choice ( n , 1 , p = prob ) ) ]  Ai_norm = [ 2 , 2 ] gamma = 0.99 sigma = [ gamma / a for a in Ai_norm ] tau = gamma / ( n * max ( Ai_norm ) ) cb = ( odl . solvers . CallbackPrintIteration ( fmt = <str> , step = n , end = <str> ) & odl . solvers . CallbackPrintTiming ( fmt = <str> , cumulative = True , step = n ) ) x = X . zero ( ) niter = 2 * nepoch spdhg . spdhg ( x , f , g , A , tau , sigma , niter , prob = prob , fun_select = fun_select , callback = cb ) data . show ( ) x . show ( )  