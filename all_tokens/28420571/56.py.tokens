from __future__ import division import numpy as np import pytest import odl from odl . operator import OpTypeError from odl . util . testutils import ( all_almost_equal , dtype_ndigits , dtype_tol , noise_element , simple_fixture ) from odl . solvers . functional . default_functionals import ( KullbackLeiblerConvexConj ) scalar = simple_fixture ( <str> , [ 0.01 , 2.7 , 10 , - 2 , - 0.2 , - 7.1 , 0 ] ) sigma = simple_fixture ( <str> , [ 0.001 , 2.7 , np . array ( 0.5 ) , 10 ] ) space_params = [ <str> , <str> , <str> ] space_ids = [ <str> . format ( p ) for p in space_params ] @ pytest . fixture ( scope = <str> , ids = space_ids , params = space_params ) def space ( request , odl_tspace_impl ) :      name = request . param . strip ( ) impl = odl_tspace_impl if name == <str> :          return odl . rn ( 10 , impl = impl )  elif name == <str> :          return odl . uniform_discr ( 0 , 1 , 7 , impl = impl )  elif name == <str> :          space = odl . uniform_discr ( 0 , 1 , 7 , impl = impl ) return odl . ProductSpace ( space , 2 )   func_params = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] func_ids = [ <str> . format ( p ) for p in func_params ] FUNCTIONALS_WITHOUT_DERIVATIVE = ( odl . solvers . functional . IndicatorLpUnitBall , odl . solvers . functional . IndicatorSimplex , odl . solvers . functional . IndicatorSumConstraint ) @ pytest . fixture ( scope = <str> , ids = func_ids , params = func_params ) def functional ( request , space ) :      name = request . param . strip ( ) if name == <str> :          func = odl . solvers . functional . L1Norm ( space )  elif name == <str> :          func = odl . solvers . functional . L2Norm ( space )  elif name == <str> :          func = odl . solvers . functional . L2NormSquared ( space )  elif name == <str> :          func = odl . solvers . functional . ConstantFunctional ( space , 2 )  elif name == <str> :          func = odl . solvers . functional . ZeroFunctional ( space )  elif name == <str> :          func = odl . solvers . functional . IndicatorLpUnitBall ( space , 1 )  elif name == <str> :          func = odl . solvers . functional . IndicatorLpUnitBall ( space , 2 )  elif name == <str> :          func = odl . solvers . functional . IndicatorLpUnitBall ( space , np . pi )  elif name == <str> :          func = odl . solvers . functional . IndicatorLpUnitBall ( space , np . inf )  elif name == <str> :          left = odl . solvers . functional . L2Norm ( space ) right = odl . solvers . functional . ConstantFunctional ( space , 2 ) func = odl . solvers . functional . FunctionalProduct ( left , right )  elif name == <str> :          dividend = odl . solvers . functional . L2Norm ( space ) divisor = odl . solvers . functional . ConstantFunctional ( space , 2 ) func = odl . solvers . functional . FunctionalQuotient ( dividend , divisor )  elif name == <str> :          func = odl . solvers . functional . KullbackLeibler ( space )  elif name == <str> :          func = odl . solvers . KullbackLeibler ( space ) . convex_conj  elif name == <str> :          func = odl . solvers . functional . KullbackLeiblerCrossEntropy ( space )  elif name == <str> :          func = odl . solvers . KullbackLeiblerCrossEntropy ( space ) . convex_conj  elif name == <str> :          func = odl . solvers . Huber ( space , gamma = 0.1 )  elif name == <str> :          if isinstance ( space , odl . ProductSpace ) :              pytest . skip ( <str> )  space = odl . ProductSpace ( space , 3 ) func = odl . solvers . GroupL1Norm ( space )  elif name == <str> :          point = noise_element ( space ) l2_squared = odl . solvers . L2NormSquared ( space ) subgrad = l2_squared . gradient ( point ) func = odl . solvers . BregmanDistance ( l2_squared , point , subgrad )  elif name == <str> :          point = noise_element ( space ) l1 = odl . solvers . L1Norm ( space ) subgrad = l1 . gradient ( point ) func = odl . solvers . BregmanDistance ( l1 , point , subgrad )  elif name == <str> :          diameter = 1.23 func = odl . solvers . IndicatorSimplex ( space , diameter )  elif name == <str> :          sum_value = 1.23 func = odl . solvers . IndicatorSumConstraint ( space , sum_value )  else :          assert False  return func  def test_derivative ( functional ) :      if isinstance ( functional , FUNCTIONALS_WITHOUT_DERIVATIVE ) :          with pytest . raises ( NotImplementedError ) :              functional . derivative ( functional . domain . zero ( ) )  return  x = noise_element ( functional . domain ) y = noise_element ( functional . domain ) if ( isinstance ( functional , odl . solvers . KullbackLeibler ) or isinstance ( functional , odl . solvers . KullbackLeiblerCrossEntropy ) ) :          x = x . ufuncs . absolute ( ) y = y . ufuncs . absolute ( )  if isinstance ( functional , KullbackLeiblerConvexConj ) :          x = x - x . ufuncs . max ( ) + 0.99 y = y - y . ufuncs . max ( ) + 0.99  step = float ( np . sqrt ( np . finfo ( functional . domain . dtype ) . eps ) ) assert all_almost_equal ( ( functional ( x + step * y ) - functional ( x ) ) / step , y . inner ( functional . gradient ( x ) ) , ndigits = 1 ) assert all_almost_equal ( functional . derivative ( x ) ( y ) , y . inner ( functional . gradient ( x ) ) )  def test_arithmetic ( ) :      space = odl . rn ( 3 ) functional = odl . solvers . L2Norm ( space ) . translated ( [ 1 , 2 , 3 ] ) functional2 = odl . solvers . L2NormSquared ( space ) operator = odl . IdentityOperator ( space ) - space . element ( [ 4 , 5 , 6 ] ) x = noise_element ( functional . domain ) y = noise_element ( functional . domain ) scalar = np . pi assert functional ( x ) == functional ( x ) assert functional ( x ) != functional2 ( x ) assert ( scalar * functional ) ( x ) == scalar * functional ( x ) assert ( scalar * ( scalar * functional ) ) ( x ) == scalar ** 2 * functional ( x ) assert ( functional * scalar ) ( x ) == functional ( scalar * x ) assert ( ( functional * scalar ) * scalar ) ( x ) == functional ( scalar ** 2 * x ) assert ( functional + functional2 ) ( x ) == functional ( x ) + functional2 ( x ) assert ( functional - functional2 ) ( x ) == functional ( x ) - functional2 ( x ) assert ( functional * operator ) ( x ) == functional ( operator ( x ) ) assert all_almost_equal ( ( y * functional ) ( x ) , y * functional ( x ) ) assert all_almost_equal ( ( y * ( y * functional ) ) ( x ) , ( y * y ) * functional ( x ) ) assert all_almost_equal ( ( functional * y ) ( x ) , functional ( y * x ) ) assert all_almost_equal ( ( ( functional * y ) * y ) ( x ) , functional ( ( y * y ) * x ) )  def test_left_scalar_mult ( space , scalar ) :      ndigits = dtype_ndigits ( space . dtype ) rtol = dtype_tol ( space . dtype ) x = noise_element ( space ) func = odl . solvers . functional . L2Norm ( space ) lmul_func = scalar * func if scalar == 0 :          assert isinstance ( scalar * func , odl . solvers . ZeroFunctional ) return  assert lmul_func ( x ) == pytest . approx ( scalar * func ( x ) , rel = rtol ) assert all_almost_equal ( lmul_func . gradient ( x ) , scalar * func . gradient ( x ) , ndigits ) p = noise_element ( space ) assert all_almost_equal ( lmul_func . derivative ( x ) ( p ) , scalar * ( func . derivative ( x ) ) ( p ) , ndigits ) pos_scalar = abs ( scalar ) neg_scalar = - pos_scalar with pytest . raises ( ValueError ) :          ( neg_scalar * func ) . convex_conj  assert all_almost_equal ( ( pos_scalar * func ) . convex_conj ( x ) , pos_scalar * func . convex_conj ( x / pos_scalar ) , ndigits ) sigma = 1.2 with pytest . raises ( ValueError ) :          ( neg_scalar * func ) . proximal ( sigma )  assert all_almost_equal ( ( pos_scalar * func ) . proximal ( sigma ) ( x ) , func . proximal ( sigma * pos_scalar ) ( x ) )  def test_right_scalar_mult ( space , scalar ) :      ndigits = dtype_ndigits ( space . dtype ) rtol = dtype_tol ( space . dtype ) x = noise_element ( space ) func = odl . solvers . functional . L2NormSquared ( space ) rmul_func = func * scalar if scalar == 0 :          assert isinstance ( rmul_func , odl . solvers . ConstantFunctional ) assert all_almost_equal ( rmul_func ( x ) , func ( space . zero ( ) ) , ndigits ) return  assert rmul_func ( x ) == pytest . approx ( func ( scalar * x ) , rel = rtol ) assert all_almost_equal ( rmul_func . gradient ( x ) , scalar * func . gradient ( scalar * x ) , ndigits ) p = noise_element ( space ) assert all_almost_equal ( rmul_func . derivative ( x ) ( p ) , scalar * func . derivative ( scalar * x ) ( p ) , ndigits ) assert all_almost_equal ( rmul_func . convex_conj ( x ) , func . convex_conj ( x / scalar ) , ndigits ) sigma = 1.2 assert all_almost_equal ( rmul_func . proximal ( sigma ) ( x ) , ( 1.0 / scalar ) * func . proximal ( sigma * scalar ** 2 ) ( x * scalar ) , ndigits ) func = odl . solvers . ZeroFunctional ( space ) assert isinstance ( func * scalar , odl . solvers . FunctionalLeftScalarMult )  def test_functional_composition ( space ) :      ndigits = dtype_ndigits ( space . dtype ) rtol = dtype_tol ( space . dtype ) func = odl . solvers . L2NormSquared ( space ) scalar = 2.1 wrong_space = odl . uniform_discr ( 1 , 2 , 10 ) op_wrong = odl . operator . ScalingOperator ( wrong_space , scalar ) with pytest . raises ( OpTypeError ) :          func * op_wrong  op = odl . operator . ScalingOperator ( space , scalar ) func_op_comp = func * op assert isinstance ( func_op_comp , odl . solvers . Functional ) x = noise_element ( space ) assert func_op_comp ( x ) == pytest . approx ( func ( op ( x ) ) , rel = rtol ) assert all_almost_equal ( func_op_comp . gradient ( x ) , ( op . adjoint * func . gradient * op ) ( x ) , ndigits ) p = noise_element ( space ) assert all_almost_equal ( func_op_comp . derivative ( x ) ( p ) , ( op . adjoint * func . gradient * op ) ( x ) . inner ( p ) , ndigits )  def test_functional_sum ( space ) :      ndigits = dtype_ndigits ( space . dtype ) rtol = dtype_tol ( space . dtype ) func1 = odl . solvers . L2NormSquared ( space ) func2 = odl . solvers . L2Norm ( space ) op = odl . operator . IdentityOperator ( space ) with pytest . raises ( OpTypeError ) :          func1 + op  wrong_space = odl . uniform_discr ( 1 , 2 , 10 ) func_wrong_domain = odl . solvers . L2Norm ( wrong_space ) with pytest . raises ( OpTypeError ) :          func1 + func_wrong_domain  func_sum = func1 + func2 x = noise_element ( space ) p = noise_element ( space ) assert func_sum ( x ) == pytest . approx ( func1 ( x ) + func2 ( x ) , rel = rtol ) assert all_almost_equal ( func_sum . gradient ( x ) , func1 . gradient ( x ) + func2 . gradient ( x ) , ndigits ) assert ( func_sum . derivative ( x ) ( p ) == pytest . approx ( func1 . gradient ( x ) . inner ( p ) + func2 . gradient ( x ) . inner ( p ) , rel = rtol ) ) with pytest . raises ( NotImplementedError ) :          func_sum . proximal  with pytest . raises ( NotImplementedError ) :          func_sum . convex_conj ( x )   def test_functional_plus_scalar ( space ) :      ndigits = dtype_ndigits ( space . dtype ) rtol = dtype_tol ( space . dtype ) func = odl . solvers . L2NormSquared ( space ) scalar = - 1.3 complex_scalar = 1j with pytest . raises ( TypeError ) :          func + complex_scalar  func_scalar_sum = func + scalar x = noise_element ( space ) p = noise_element ( space ) assert func_scalar_sum ( x ) == pytest . approx ( func ( x ) + scalar , rel = rtol ) assert all_almost_equal ( func_scalar_sum . gradient ( x ) , func . gradient ( x ) , ndigits ) assert ( func_scalar_sum . derivative ( x ) ( p ) == pytest . approx ( func . gradient ( x ) . inner ( p ) , rel = rtol ) ) sigma = 1.2 assert all_almost_equal ( func_scalar_sum . proximal ( sigma ) ( x ) , func . proximal ( sigma ) ( x ) , ndigits ) assert ( func_scalar_sum . convex_conj ( x ) == pytest . approx ( func . convex_conj ( x ) - scalar , rel = rtol ) ) assert all_almost_equal ( func_scalar_sum . convex_conj . gradient ( x ) , func . convex_conj . gradient ( x ) , ndigits )  def test_translation_of_functional ( space ) :      ndigits = dtype_ndigits ( space . dtype ) rtol = dtype_tol ( space . dtype ) translation = noise_element ( space ) test_functional = odl . solvers . L2NormSquared ( space ) translated_functional = test_functional . translated ( translation ) x = noise_element ( space ) expected_result = test_functional ( x - translation ) assert all_almost_equal ( translated_functional ( x ) , expected_result , ndigits ) expected_result = test_functional . gradient ( x - translation ) translated_gradient = translated_functional . gradient assert all_almost_equal ( translated_gradient ( x ) , expected_result , ndigits ) sigma = 1.2 expected_result = odl . solvers . proximal_translation ( test_functional . proximal , translation ) ( sigma ) ( x ) assert all_almost_equal ( translated_functional . proximal ( sigma ) ( x ) , expected_result , ndigits ) expected_result = odl . solvers . FunctionalQuadraticPerturb ( test_functional . convex_conj , linear_term = translation ) ( x ) assert all_almost_equal ( translated_functional . convex_conj ( x ) , expected_result , ndigits ) p = noise_element ( space ) expected_result = p . inner ( test_functional . gradient ( x - translation ) ) assert all_almost_equal ( translated_functional . derivative ( x ) ( p ) , expected_result , ndigits ) second_translation = noise_element ( space ) double_translated_functional = translated_functional . translated ( second_translation ) assert ( double_translated_functional ( x ) == pytest . approx ( test_functional ( x - translation - second_translation ) , rel = rtol ) )  def test_translation_proximal_stepsizes ( ) :      space = odl . rn ( 2 ) functional = odl . solvers . L2NormSquared ( space ) translation = functional . translated ( [ 0.5 , 0.5 ] ) x = space . one ( ) stepsize = space . element ( [ 0.5 , 2.0 ] ) stepsize_list = [ 0.5 , 2.0 ] stepsize_array = np . asarray ( [ 0.5 , 2.0 ] ) y = translation . convex_conj . proximal ( stepsize ) ( x ) y_list = translation . convex_conj . proximal ( stepsize_list ) ( x ) y_array = translation . convex_conj . proximal ( stepsize_array ) ( x ) expected_result = [ 0.6 , 0.0 ] assert all_almost_equal ( y , expected_result ) assert all_almost_equal ( y_list , expected_result ) assert all_almost_equal ( y_array , expected_result )  def test_multiplication_with_vector ( space ) :      ndigits = dtype_ndigits ( space . dtype ) rtol = dtype_tol ( space . dtype ) x = noise_element ( space ) y = noise_element ( space ) func = odl . solvers . L2NormSquared ( space ) wrong_space = odl . uniform_discr ( 1 , 2 , 10 ) y_other_space = noise_element ( wrong_space ) func_times_y = func * y assert isinstance ( func_times_y , odl . solvers . FunctionalRightVectorMult ) expected_result = func ( y * x ) assert func_times_y ( x ) == pytest . approx ( expected_result , rel = rtol ) expected_result = 2.0 * y * y * x assert all_almost_equal ( func_times_y . gradient ( x ) , expected_result , ndigits ) cc_func_times_y = func_times_y . convex_conj expected_result = 1.0 / 4.0 * ( x / y ) . norm ( ) ** 2 assert cc_func_times_y ( x ) == pytest . approx ( expected_result , rel = rtol ) with pytest . raises ( TypeError ) :          func * y_other_space  y_times_func = y * func assert isinstance ( y_times_func , odl . FunctionalLeftVectorMult ) expected_result = y * func ( x ) assert all_almost_equal ( y_times_func ( x ) , expected_result , ndigits ) y_other_times_func = y_other_space * func assert isinstance ( y_other_times_func , odl . FunctionalLeftVectorMult ) expected_result = y_other_space * func ( x ) assert all_almost_equal ( y_other_times_func ( x ) , expected_result , ndigits )  linear_term = simple_fixture ( <str> , [ False , True ] ) quadratic_coeff = simple_fixture ( <str> , [ 0.0 , 2.13 ] ) def test_functional_quadratic_perturb ( space , linear_term , quadratic_coeff ) :      ndigits = dtype_ndigits ( space . dtype ) rtol = dtype_tol ( space . dtype ) orig_func = odl . solvers . L2NormSquared ( space ) if linear_term :          linear_term_arg = None linear_term = space . zero ( )  else :          linear_term_arg = linear_term = noise_element ( space )  functional = odl . solvers . FunctionalQuadraticPerturb ( orig_func , quadratic_coeff = quadratic_coeff , linear_term = linear_term_arg ) x = noise_element ( space ) assert ( functional ( x ) == pytest . approx ( orig_func ( x ) + quadratic_coeff * x . inner ( x ) + x . inner ( linear_term ) , rel = rtol ) ) assert all_almost_equal ( functional . gradient ( x ) , orig_func . gradient ( x ) + 2.0 * quadratic_coeff * x + linear_term , ndigits ) sigma = 1.2 c = 1 / np . sqrt ( 2 * sigma * quadratic_coeff + 1 ) prox = orig_func . proximal ( sigma * c ** 2 ) expected_result = prox ( ( x - sigma * linear_term ) * c ** 2 ) assert all_almost_equal ( functional . proximal ( sigma ) ( x ) , expected_result , ndigits ) if quadratic_coeff == 0 :          expected = orig_func . convex_conj . translated ( linear_term ) ( x ) assert functional . convex_conj ( x ) == pytest . approx ( expected , rel = rtol )  cconj_prox = odl . solvers . proximal_convex_conj ( functional . proximal ) assert all_almost_equal ( functional . convex_conj . proximal ( sigma ) ( x ) , cconj_prox ( sigma ) ( x ) , ndigits )  def test_bregman ( functional ) :      rtol = dtype_tol ( functional . domain . dtype ) if isinstance ( functional , FUNCTIONALS_WITHOUT_DERIVATIVE ) :          with pytest . raises ( NotImplementedError ) :              functional . gradient ( functional . domain . zero ( ) )  return  y = noise_element ( functional . domain ) x = noise_element ( functional . domain ) if ( isinstance ( functional , odl . solvers . KullbackLeibler ) or isinstance ( functional , odl . solvers . KullbackLeiblerCrossEntropy ) ) :          x = x . ufuncs . absolute ( ) y = y . ufuncs . absolute ( )  if isinstance ( functional , KullbackLeiblerConvexConj ) :          x = x - x . ufuncs . max ( ) + 0.99 y = y - y . ufuncs . max ( ) + 0.99  grad = functional . gradient ( y ) quadratic_func = odl . solvers . QuadraticForm ( vector = - grad , constant = - functional ( y ) + grad . inner ( y ) ) expected_func = functional + quadratic_func assert ( functional . bregman ( y , grad ) ( x ) == pytest . approx ( expected_func ( x ) , rel = rtol ) )  if __name__ == <str> :      odl . util . test_file ( __file__ )   