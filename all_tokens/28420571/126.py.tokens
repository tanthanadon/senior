from __future__ import print_function , division , absolute_import import numpy as np from odl . operator import Operator __all__ = ( <str> , <str> ) def douglas_rachford_pd ( x , f , g , L , niter , tau = None , sigma = None , callback = None , ** kwargs ) :      <str> m = len ( L ) if not all ( isinstance ( op , Operator ) for op in L ) :          raise ValueError ( <str> )  if not all ( op . is_linear for op in L ) :          raise ValueError ( <str> )  if not all ( x in op . domain for op in L ) :          raise ValueError ( <str> )  if len ( g ) != m :          raise ValueError ( <str> )  tau , sigma = douglas_rachford_pd_stepsize ( L , tau , sigma ) if len ( sigma ) != m :          raise ValueError ( <str> )  prox_cc_g = [ gi . convex_conj . proximal for gi in g ] l = kwargs . pop ( <str> , None ) if l is not None and len ( l ) != m :          raise ValueError ( <str> <str> )  if l is not None :          prox_cc_l = [ li . convex_conj . proximal for li in l ]  lam_in = kwargs . pop ( <str> , 1.0 ) if not callable ( lam_in ) and not ( 0 < lam_in < 2 ) :          raise ValueError ( <str> )  lam = lam_in if callable ( lam_in ) else lambda _ : lam_in if kwargs :          raise TypeError ( <str> . format ( kwargs ) )  v = [ Li . range . zero ( ) for Li in L ] p1 = x . space . zero ( ) p2 = [ Li . range . zero ( ) for Li in L ] z1 = x . space . zero ( ) rans = { Li . range for Li in L } z2 = { ran : ran . zero ( ) for ran in rans } w1 = x . space . zero ( ) w2 = [ Li . range . zero ( ) for Li in L ] for k in range ( niter ) :          lam_k = lam ( k ) if len ( L ) > 0 :              L [ 0 ] . adjoint ( v [ 0 ] , out = z1 ) for Li , vi in zip ( L [ 1 : ] , v [ 1 : ] ) :                  Li . adjoint ( vi , out = p1 ) z1 += p1  z1 . lincomb ( 1 , x , - tau / 2 , z1 )  else :              z1 . assign ( x )  f . proximal ( tau ) ( z1 , out = p1 ) w1 . lincomb ( 2 , p1 , - 1 , x ) x . lincomb ( 1 , x , - lam_k , p1 ) if callback is not None :              callback ( p1 )  if k == niter - 1 :              x . assign ( p1 ) return  for i in range ( m ) :              L [ i ] ( w1 , out = p2 [ i ] ) p2 [ i ] . lincomb ( 1 , v [ i ] , sigma [ i ] / 2 , p2 [ i ] ) prox_cc_g [ i ] ( sigma [ i ] ) ( p2 [ i ] , out = p2 [ i ] ) w2 [ i ] . lincomb ( 2 , p2 [ i ] , - 1 , v [ i ] )  if len ( L ) > 0 :              L [ 0 ] . adjoint ( w2 [ 0 ] , out = p1 ) for Li , w2i in zip ( L [ 1 : ] , w2 [ 1 : ] ) :                  Li . adjoint ( w2i , out = z1 ) p1 += z1   else :              p1 . set_zero ( )  z1 . lincomb ( 1 , w1 , - tau / 2 , p1 ) x . lincomb ( 1 , x , lam_k , z1 ) p1 . lincomb ( 2 , z1 , - 1 , w1 ) for i in range ( m ) :              z2i = z2 [ L [ i ] . range ] L [ i ] ( p1 , out = z2i ) z2i . lincomb ( 1 , w2 [ i ] , sigma [ i ] / 2 , L [ i ] ( p1 ) ) if l is not None :                  prox_cc_l [ i ] ( sigma [ i ] ) ( z2i , out = z2i )  v [ i ] . lincomb ( 1 , v [ i ] , lam_k , z2i ) v [ i ] . lincomb ( 1 , v [ i ] , - lam_k , p2 [ i ] )    def _operator_norms ( L ) :      L_norms = [ ] for Li in L :          if np . isscalar ( Li ) :              L_norms . append ( float ( Li ) )  elif isinstance ( Li , Operator ) :              L_norms . append ( Li . norm ( estimate = True ) )  else :              raise TypeError ( <str> . format ( Li ) )   return L_norms  def douglas_rachford_pd_stepsize ( L , tau = None , sigma = None ) :      <str> if tau is None and sigma is None :          L_norms = _operator_norms ( L ) tau = 1 / sum ( L_norms ) sigma = [ 2.0 / ( len ( L_norms ) * tau * Li_norm ** 2 ) for Li_norm in L_norms ] return tau , tuple ( sigma )  elif tau is None :          L_norms = _operator_norms ( L ) tau = 2 / sum ( si * Li_norm ** 2 for si , Li_norm in zip ( sigma , L_norms ) ) return tau , tuple ( sigma )  elif sigma is None :          L_norms = _operator_norms ( L ) tau = float ( tau ) sigma = [ 2.0 / ( len ( L_norms ) * tau * Li_norm ** 2 ) for Li_norm in L_norms ] return tau , tuple ( sigma )  else :          return float ( tau ) , tuple ( sigma )    