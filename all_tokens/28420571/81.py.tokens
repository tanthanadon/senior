from __future__ import division import numpy as np try :      import skimage SKIMAGE_AVAILABLE = True  except ImportError :      SKIMAGE_AVAILABLE = False  from odl . discr import uniform_discr_frompartition , uniform_partition __all__ = ( <str> , <str> , <str> ) def skimage_theta ( geometry ) :      return geometry . angles * 180.0 / np . pi  def skimage_sinogram_space ( geometry , volume_space , sinogram_space ) :      padded_size = int ( np . ceil ( volume_space . shape [ 0 ] * np . sqrt ( 2 ) ) ) det_width = volume_space . domain . extent [ 0 ] * np . sqrt ( 2 ) skimage_detector_part = uniform_partition ( - det_width / 2.0 , det_width / 2.0 , padded_size ) skimage_range_part = geometry . motion_partition . insert ( 1 , skimage_detector_part ) skimage_range = uniform_discr_frompartition ( skimage_range_part , interp = sinogram_space . interp , dtype = sinogram_space . dtype ) return skimage_range  def clamped_interpolation ( skimage_range , sinogram ) :      min_x = skimage_range . domain . min ( ) [ 1 ] max_x = skimage_range . domain . max ( ) [ 1 ] def interpolation_wrapper ( x ) :          x = ( x [ 0 ] , np . maximum ( min_x , np . minimum ( max_x , x [ 1 ] ) ) ) return sinogram . interpolation ( x )  return interpolation_wrapper  def skimage_radon_forward ( volume , geometry , range , out = None ) :      from skimage . transform import radon assert volume . shape [ 0 ] == volume . shape [ 1 ] theta = skimage_theta ( geometry ) skimage_range = skimage_sinogram_space ( geometry , volume . space , range ) sino_arr = radon ( np . rot90 ( volume . asarray ( ) , 1 ) , theta = theta , circle = False ) sinogram = skimage_range . element ( sino_arr . T ) if out is None :          out = range . element ( )  out . sampling ( clamped_interpolation ( skimage_range , sinogram ) ) scale = volume . space . cell_sides [ 0 ] out *= scale return out  def skimage_radon_back_projector ( sinogram , geometry , range , out = None ) :      from skimage . transform import iradon theta = skimage_theta ( geometry ) skimage_range = skimage_sinogram_space ( geometry , range , sinogram . space ) skimage_sinogram = skimage_range . element ( ) skimage_sinogram . sampling ( clamped_interpolation ( range , sinogram ) ) if out is None :          out = range . element ( )  else :          assert out in range  backproj = iradon ( skimage_sinogram . asarray ( ) . T , theta , output_size = range . shape [ 0 ] , filter = None , circle = False ) out [ : ] = np . rot90 ( backproj , - 1 ) scaling_factor = 4.0 * float ( geometry . motion_params . length ) / ( 2 * np . pi ) proj_extent = float ( sinogram . space . partition . extent . prod ( ) ) proj_size = float ( sinogram . space . partition . size ) proj_weighting = proj_extent / proj_size scaling_factor *= ( sinogram . space . weighting . const / proj_weighting ) scaling_factor /= ( range . weighting . const / range . cell_volume ) out *= scaling_factor return out   