from __future__ import division , print_function import os import odl . contrib . solvers . spdhg as spdhg import odl . contrib . datasets . images as images import matplotlib . pyplot as plt import matplotlib import numpy as np from scipy . ndimage . filters import gaussian_filter import odl import brewer2mpl folder_out = <str> filename = <str> nepoch = 300 niter_target = 2000 subfolder = <str> . format ( nepoch ) nvoxelx = 250 filename = <str> . format ( filename , nvoxelx , nvoxelx ) folder_main = <str> . format ( folder_out , filename ) if not os . path . exists ( folder_main ) :      os . makedirs ( folder_main )  folder_today = <str> . format ( folder_main , subfolder ) if not os . path . exists ( folder_today ) :      os . makedirs ( folder_today )  folder_npy = <str> . format ( folder_today ) if not os . path . exists ( folder_npy ) :      os . makedirs ( folder_npy )  X = odl . uniform_discr ( min_pt = [ - 1 , - 1 ] , max_pt = [ 1 , 1 ] , shape = [ nvoxelx , nvoxelx ] ) geometry = odl . tomo . parallel_beam_geometry ( X , num_angles = 200 , det_shape = 250 ) G = odl . BroadcastOperator ( * [ odl . tomo . RayTransform ( X , g , impl = <str> ) for g in geometry ] ) Y = G . range groundtruth = X . element ( images . resolution_phantom ( shape = X . shape ) ) clim = [ 0 , 1 ] tol_norm = 1.05 file_data = <str> . format ( folder_main ) if not os . path . exists ( file_data ) :      sino = G ( groundtruth ) support = X . element ( groundtruth . ufuncs . greater ( 0 ) ) factors = - G ( 0.005 / X . cell_sides [ 0 ] * support ) factors . ufuncs . exp ( out = factors ) counts_observed = ( factors * sino ) . ufuncs . sum ( ) counts_desired = 5e+6 counts_background = 1e+6 factors *= counts_desired / counts_observed sino_supp = sino . ufuncs . greater ( 0 ) smooth_supp = Y . element ( [ gaussian_filter ( s , sigma = [ 1 , 2 / X . cell_sides [ 0 ] ] ) for s in sino_supp ] ) background = 10 * smooth_supp + 10 background *= counts_background / background . ufuncs . sum ( ) data = odl . phantom . poisson_noise ( factors * sino + background , seed = 1807 ) arr = np . empty ( 3 , dtype = object ) arr [ 0 ] = data arr [ 1 ] = factors arr [ 2 ] = background np . save ( file_data , arr ) spdhg . save_image ( groundtruth , <str> , folder_main , 1 , clim = clim ) fig2 = plt . figure ( 2 ) fig2 . clf ( ) i = 11 plt . plot ( ( sino [ i ] ) . asarray ( ) [ 0 ] , label = <str> ) plt . plot ( ( factors [ i ] * sino [ i ] ) . asarray ( ) [ 0 ] , label = <str> ) plt . plot ( data [ i ] . asarray ( ) [ 0 ] , label = <str> ) plt . plot ( background [ i ] . asarray ( ) [ 0 ] , label = <str> ) plt . legend ( ) fig2 . savefig ( <str> . format ( folder_main ) , bbox_inches = <str> )  else :      ( data , factors , background ) = np . load ( file_data )  f = odl . solvers . SeparableSum ( * [ odl . solvers . KullbackLeibler ( Yi , yi ) . translated ( - ri ) for Yi , yi , ri in zip ( Y , data , background ) ] ) g = spdhg . TotalVariationNonNegative ( X , alpha = 2e-1 ) g . prox_options [ <str> ] = 20 A = odl . BroadcastOperator ( * [ fi * Gi for fi , Gi in zip ( factors , G ) ] ) obj_fun = f * A + g gamma = 0.99 file_target = <str> . format ( folder_main ) if not os . path . exists ( file_target ) :      file_normA = <str> . format ( folder_main , 1 ) if not os . path . exists ( file_normA ) :          normA = [ tol_norm * A . norm ( estimate = True ) ] np . save ( file_normA , normA )  else :          normA = np . load ( file_normA )  callback = ( odl . solvers . CallbackPrintIteration ( step = 10 , end = <str> ) & odl . solvers . CallbackPrintTiming ( step = 10 , cumulative = True ) ) sigma , tau = [ gamma / normA [ 0 ] ] * 2 x_opt , y_opt = X . zero ( ) , Y . zero ( ) g . prox_options [ <str> ] = None odl . solvers . pdhg ( x_opt , f , g , A , tau , sigma , niter_target , y = y_opt , callback = callback ) subx_opt = - A . adjoint ( y_opt ) suby_opt = A ( x_opt ) spdhg . save_image ( x_opt , <str> , folder_main , 1 , clim = clim ) spdhg . save_signal ( y_opt [ 0 ] , <str> , folder_main , 2 ) spdhg . save_image ( subx_opt , <str> , folder_main , 3 ) spdhg . save_signal ( suby_opt [ 0 ] , <str> , folder_main , 4 ) obj_opt = obj_fun ( x_opt ) np . save ( file_target , ( x_opt , y_opt , subx_opt , suby_opt , obj_opt ) )  else :      ( x_opt , y_opt , subx_opt , suby_opt , obj_opt ) = np . load ( file_target )  dist_x = odl . solvers . L2NormSquared ( X ) . translated ( x_opt ) dist_y = odl . solvers . L2NormSquared ( Y ) . translated ( y_opt ) bregman_g = spdhg . bregman ( g , x_opt , subx_opt ) bregman_f = odl . solvers . SeparableSum ( * [ spdhg . bregman ( fi . convex_conj , yi , ri ) for fi , yi , ri in zip ( f , y_opt , suby_opt ) ] ) class CallbackStore ( odl . solvers . Callback ) :      def __init__ ( self , alg , iter_save , iter_plot ) :          self . iter_save = iter_save self . iter_plot = iter_plot self . iter = 0 self . alg = alg self . ergx , self . ergy = X . zero ( ) , Y . zero ( ) self . out = [ ]  def __call__ ( self , w , ** kwargs ) :          if self . iter > 0 :              k = self . iter self . ergx = 1 / k * ( ( k - 1 ) * self . ergx + w [ 0 ] ) self . ergy = 1 / k * ( ( k - 1 ) * self . ergy + w [ 1 ] )  if self . iter in self . iter_save :              obj = obj_fun ( w [ 0 ] ) breg_x = bregman_g ( w [ 0 ] ) breg_y = bregman_f ( w [ 1 ] ) breg = breg_x + breg_y breg_ex = bregman_g ( self . ergx ) breg_ey = bregman_f ( self . ergy ) breg_erg = breg_ex + breg_ey dx = dist_x ( w [ 0 ] ) dy = dist_y ( w [ 1 ] ) dist = dx + dy dex = dist_x ( self . ergx ) dey = dist_y ( self . ergy ) dist_erg = dex + dey self . out . append ( { <str> : obj , <str> : breg , <str> : breg_x , <str> : breg_y , <str> : breg_erg , <str> : breg_ex , <str> : breg_ey , <str> : dist , <str> : dx , <str> : dy , <str> : dist_erg , <str> : dex , <str> : dey , <str> : self . iter } )  if self . iter in self . iter_plot :              fname = <str> . format ( self . alg , self . iter ) spdhg . save_image ( w [ 0 ] , fname , folder_today , 1 , clim = clim )  self . iter += 1   nsub = { <str> : 1 , <str> : 10 , <str> : 50 , <str> : 200 , <str> : 10 , <str> : 50 , <str> : 200 } niter , iter_save , iter_plot = { } , { } , { } for a in nsub . keys ( ) :      niter [ a ] = nepoch * nsub [ a ] iter_save [ a ] = range ( 0 , niter [ a ] + 1 , nsub [ a ] ) iter_plot [ a ] = list ( np . array ( [ 5 , 10 , 20 , 30 , 40 , 50 , 100 , 300 ] ) * nsub [ a ] )  for alg in [ <str> , <str> , <str> , <str> , <str> ] :      print ( <str> + alg + <str> ) prob , sigma , tau = [ None ] * 3 n = nsub [ alg ] ( sub2ind , ind2sub ) = spdhg . divide_1Darray_equally ( range ( len ( A ) ) , n ) if alg == <str> or alg [ 0 : 5 ] == <str> :          file_normA = <str> . format ( folder_main , n )  elif alg [ 0 : 7 ] == <str> :          file_normA = <str> . format ( folder_main , 1 )  if not os . path . exists ( file_normA ) :          A_subsets = [ odl . BroadcastOperator ( * [ A [ i ] for i in subset ] ) for subset in sub2ind ] normA = [ tol_norm * Ai . norm ( estimate = True ) for Ai in A_subsets ] np . save ( file_normA , normA )  else :          normA = np . load ( file_normA )  np . random . seed ( 1807 ) if alg == <str> :          prob_subset = [ 1 ] * n prob = [ 1 ] * Y . size sigma = [ gamma / normA [ 0 ] ] * Y . size tau = gamma / normA [ 0 ]  elif alg . startswith ( <str> ) :          prob_subset = [ 1 / n ] * n prob = [ 1 / n ] * Y . size sigma = [ gamma / normA [ 0 ] ] * Y . size tau = gamma / normA [ 0 ]  elif alg . startswith ( <str> ) :          prob_subset = [ 1 / n ] * n prob = [ 1 / n ] * Y . size sigma = [ gamma / normA [ ind2sub [ i ] [ 0 ] ] for i in range ( Y . size ) ] tau = gamma / ( n * np . max ( normA ) )  else :          assert False , <str>  def fun_select ( k ) :          return sub2ind [ int ( np . random . choice ( n , 1 , p = prob_subset ) ) ]  callback = ( odl . solvers . CallbackPrintIteration ( fmt = <str> , step = n , end = <str> ) & odl . solvers . CallbackPrintTiming ( fmt = <str> , step = n , end = <str> ) & odl . solvers . CallbackPrintTiming ( fmt = <str> , cumulative = True , step = n ) & CallbackStore ( alg , iter_save [ alg ] , iter_plot [ alg ] ) ) x , y = X . zero ( ) , Y . zero ( ) callback ( [ x , y ] ) g . prox_options [ <str> ] = None if alg . startswith ( <str> ) or alg . startswith ( <str> ) :          spdhg . spdhg ( x , f , g , A , tau , sigma , niter [ alg ] , prob = prob , y = y , fun_select = fun_select , callback = callback )  elif alg . startswith ( <str> ) :          spdhg . spdhg_pesquet ( x , f , g , A , tau , sigma , niter [ alg ] , y = y , fun_select = fun_select , callback = callback )  else :          assert False , <str>  out = callback . callbacks [ 1 ] . out np . save ( <str> . format ( folder_npy , alg ) , ( iter_save [ alg ] , niter [ alg ] , x , out , nsub [ alg ] ) )  algs = [ <str> , <str> , <str> , <str> , <str> ] iter_save_v , niter_v , image_v , out_v , nsub_v = { } , { } , { } , { } , { } for a in algs :      ( iter_save_v [ a ] , niter_v [ a ] , image_v [ a ] , out_v [ a ] , nsub_v [ a ] ) = np . load ( <str> . format ( folder_npy , a ) )  epochs_save = { a : np . array ( iter_save_v [ a ] ) / np . float ( nsub_v [ a ] ) for a in algs } out_resorted = { } for a in algs :      print ( <str> + a ) out_resorted [ a ] = { } K = len ( iter_save_v [ a ] ) for meas in out_v [ a ] [ 0 ] . keys ( ) :          print ( <str> + meas ) out_resorted [ a ] [ meas ] = np . nan * np . ones ( K ) for k in range ( K ) :              out_resorted [ a ] [ meas ] [ k ] = out_v [ a ] [ k ] [ meas ]   meas = <str> print ( <str> + meas ) out_resorted [ a ] [ meas ] = np . nan * np . ones ( K ) for k in range ( K ) :          out_resorted [ a ] [ meas ] [ k ] = ( ( out_v [ a ] [ k ] [ <str> ] - obj_opt ) / ( out_v [ a ] [ 0 ] [ <str> ] - obj_opt ) )   for a in algs :      for meas in out_resorted [ a ] . keys ( ) :          for k in range ( K ) :              if out_resorted [ a ] [ meas ] [ k ] <= 0 :                  out_resorted [ a ] [ meas ] [ k ] = np . nan     matplotlib . rc ( <str> , usetex = False ) fig = plt . figure ( ) for a in algs :      spdhg . save_image ( image_v [ a ] , a , folder_today , 1 , clim = clim )  markers = plt . Line2D . filled_markers all_plots = out_resorted [ algs [ 0 ] ] . keys ( ) logy_plot = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] for plotx in [ <str> , <str> ] :      for meas in all_plots :          print ( <str> + plotx + <str> + meas + <str> ) fig = plt . figure ( 1 ) plt . clf ( ) if plotx == <str> :              if meas in logy_plot :                  for a in algs :                      x = epochs_save [ a ] y = out_resorted [ a ] [ meas ] plt . semilogy ( x , y , linewidth = 3 , label = a )   else :                  for j , a in enumerate ( algs ) :                      x = epochs_save [ a ] y = out_resorted [ a ] [ meas ] plt . plot ( x , y , linewidth = 3 , marker = markers [ j ] , markersize = 7 , markevery = .1 , label = a )    elif plotx == <str> :              if meas in logy_plot :                  for a in algs :                      x = epochs_save [ a ] [ 1 : ] y = out_resorted [ a ] [ meas ] [ 1 : ] plt . loglog ( x , y , linewidth = 3 , label = a )   else :                  for j , a in enumerate ( algs ) :                      x = epochs_save [ a ] [ 1 : ] y = out_resorted [ a ] [ meas ] [ 1 : ] plt . semilogx ( x , y , linewidth = 3 , marker = markers [ j ] , markersize = 7 , markevery = .1 , label = a )    plt . title ( <str> . format ( meas ) ) h = plt . gca ( ) h . set_xlabel ( <str> ) plt . legend ( loc = <str> ) fig . savefig ( <str> . format ( folder_today , filename , plotx , meas ) , bbox_inches = <str> )   lwidth = 2 lwidth_help = 2 lstyle = <str> lstyle_help = <str> bmap = brewer2mpl . get_map ( <str> , <str> , 7 ) colors = bmap . mpl_colors colors . pop ( 1 ) matplotlib . rc ( <str> , usetex = True ) matplotlib . rcParams [ <str> ] = [ <str> ] fsize = 15 font = { <str> : <str> , <str> : fsize } matplotlib . rc ( <str> , ** font ) matplotlib . rc ( <str> , labelsize = fsize ) matplotlib . rc ( <str> , labelsize = fsize ) matplotlib . rc ( <str> , labelsize = fsize ) matplotlib . rc ( <str> , fontsize = fsize ) marker = ( <str> , <str> , <str> , <str> , <str> ) mevery = [ ( i / 30. , .15 ) for i in range ( 20 ) ] msize = 9 algs = [ <str> , <str> , <str> , <str> , <str> ] label = [ <str> , <str> , <str> , <str> , <str> ] fig = [ ] fig . append ( plt . figure ( 0 ) ) plt . clf ( ) xlim = [ 1 , 300 ] ylim = [ 2e-3 , 2e+1 ] meas = <str> for k , a in enumerate ( algs [ : 3 ] ) :      x = epochs_save [ a ] y = out_resorted [ a ] [ meas ] i = ( np . less_equal ( x , xlim [ 1 ] ) & np . greater_equal ( x , xlim [ 0 ] ) & np . less_equal ( y , ylim [ 1 ] ) & np . greater_equal ( y , ylim [ 0 ] ) ) plt . loglog ( x [ i ] , y [ i ] , color = colors [ k ] , linestyle = lstyle , linewidth = lwidth , marker = markers [ k ] , markersize = msize , markevery = mevery [ k ] , label = label [ k ] )  y = 1e+2 / x i = ( np . less_equal ( x , xlim [ 1 ] ) & np . greater_equal ( x , xlim [ 0 ] ) & np . less_equal ( y , ylim [ 1 ] ) & np . greater_equal ( y , ylim [ 0 ] ) ) plt . loglog ( x [ i ] , y [ i ] , color = <str> , linestyle = lstyle_help , linewidth = lwidth_help , label = <str> ) plt . gca ( ) . set_xlabel ( <str> ) plt . gca ( ) . set_ylabel ( <str> ) plt . gca ( ) . yaxis . set_ticks ( np . logspace ( - 2 , 1 , 4 ) ) plt . legend ( frameon = False ) fig . append ( plt . figure ( 1 ) ) plt . clf ( ) ylim = [ 1e-9 , 2 ] meas = <str> for k , a in enumerate ( algs ) :      x = epochs_save [ a ] y = out_resorted [ a ] [ meas ] i = ( np . less_equal ( x , xlim [ 1 ] ) & np . greater_equal ( x , xlim [ 0 ] ) & np . less_equal ( y , ylim [ 1 ] ) & np . greater_equal ( y , ylim [ 0 ] ) ) plt . semilogy ( x [ i ] , y [ i ] , color = colors [ k ] , linestyle = lstyle , linewidth = lwidth , marker = marker [ k ] , markersize = msize , markevery = mevery [ k ] , label = label [ k ] )  plt . gca ( ) . set_xlabel ( <str> ) plt . gca ( ) . set_ylabel ( <str> ) plt . gca ( ) . yaxis . set_ticks ( np . logspace ( - 8 , 0 , 3 ) ) plt . legend ( frameon = False ) for i , fi in enumerate ( fig ) :      fi . savefig ( <str> . format ( folder_today , filename , i ) , bbox_inches = <str> )   