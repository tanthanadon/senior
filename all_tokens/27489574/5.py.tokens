import json import contextlib from requests . exceptions import HTTPError from . _2to3 import url_quote_plus , iteritems_ from . _common_util import ( JSON_INDEX_TYPE , SEARCH_INDEX_ARGS , SPECIAL_INDEX_TYPE , TEXT_INDEX_TYPE , TYPE_CONVERTERS , get_docs , response_to_json_dict ) from . document import Document from . design_document import DesignDocument from . security_document import SecurityDocument from . view import View from . index import Index , TextIndex , SpecialIndex from . query import Query from . error import CloudantArgumentError , CloudantDatabaseException from . result import Result , QueryResult from . feed import Feed , InfiniteFeed class CouchDatabase ( dict ) :      def __init__ ( self , client , database_name , fetch_limit = 100 , partitioned = False ) :          super ( CouchDatabase , self ) . __init__ ( ) self . client = client self . _database_host = client . server_url self . database_name = database_name self . _fetch_limit = fetch_limit self . _partitioned = partitioned self . result = Result ( self . all_docs )  @ property def r_session ( self ) :          return self . client . r_session  @ property def admin_party ( self ) :          return self . client . admin_party  @ property def database_url ( self ) :          return <str> . join ( ( self . _database_host , url_quote_plus ( self . database_name ) ) )  @ property def creds ( self ) :          session = self . client . session ( ) if session is None :              return None  return { <str> : self . client . basic_auth_str ( ) , <str> : session . get ( <str> ) }  def database_partition_url ( self , partition_key ) :          return <str> . join ( ( self . database_url , <str> , url_quote_plus ( partition_key ) ) )  def exists ( self ) :          resp = self . r_session . head ( self . database_url ) if resp . status_code not in [ 200 , 404 ] :              resp . raise_for_status ( )  return resp . status_code == 200  def metadata ( self ) :          resp = self . r_session . get ( self . database_url ) resp . raise_for_status ( ) return response_to_json_dict ( resp )  def partition_metadata ( self , partition_key ) :          resp = self . r_session . get ( self . database_partition_url ( partition_key ) ) resp . raise_for_status ( ) return response_to_json_dict ( resp )  def doc_count ( self ) :          return self . metadata ( ) . get ( <str> )  def create_document ( self , data , throw_on_exists = False ) :          docid = data . get ( <str> , None ) doc = None if docid and docid . startswith ( <str> ) :              doc = DesignDocument ( self , docid )  else :              doc = Document ( self , docid )  doc . update ( data ) try :              doc . create ( )  except HTTPError as error :              if error . response . status_code == 409 :                  if throw_on_exists :                      raise CloudantDatabaseException ( 409 , docid )   else :                  raise   super ( CouchDatabase , self ) . __setitem__ ( doc [ <str> ] , doc ) return doc  def new_document ( self ) :          doc = Document ( self , None ) doc . create ( ) super ( CouchDatabase , self ) . __setitem__ ( doc [ <str> ] , doc ) return doc  def design_documents ( self ) :          url = <str> . join ( ( self . database_url , <str> ) ) query = <str> resp = self . r_session . get ( url , params = query ) resp . raise_for_status ( ) data = response_to_json_dict ( resp ) return data [ <str> ]  def list_design_documents ( self ) :          url = <str> . join ( ( self . database_url , <str> ) ) query = <str> resp = self . r_session . get ( url , params = query ) resp . raise_for_status ( ) data = response_to_json_dict ( resp ) return [ x . get ( <str> ) for x in data . get ( <str> , [ ] ) ]  def get_design_document ( self , ddoc_id ) :          ddoc = DesignDocument ( self , ddoc_id ) try :              ddoc . fetch ( )  except HTTPError as error :              if error . response . status_code != 404 :                  raise   return ddoc  def get_security_document ( self ) :          sdoc = SecurityDocument ( self ) sdoc . fetch ( ) return sdoc  def get_partitioned_view_result ( self , partition_key , ddoc_id , view_name , raw_result = False , ** kwargs ) :          ddoc = DesignDocument ( self , ddoc_id ) view = View ( ddoc , view_name , partition_key = partition_key ) return self . _get_view_result ( view , raw_result , ** kwargs )  def get_view_result ( self , ddoc_id , view_name , raw_result = False , ** kwargs ) :          ddoc = DesignDocument ( self , ddoc_id ) view = View ( ddoc , view_name ) return self . _get_view_result ( view , raw_result , ** kwargs )  @ staticmethod def _get_view_result ( view , raw_result , ** kwargs ) :          if raw_result :              return view ( ** kwargs )  if kwargs :              return Result ( view , ** kwargs )  return view . result  def create ( self , throw_on_exists = False ) :          if not throw_on_exists and self . exists ( ) :              return self  resp = self . r_session . put ( self . database_url , params = { <str> : TYPE_CONVERTERS . get ( bool ) ( self . _partitioned ) } ) if resp . status_code == 201 or resp . status_code == 202 :              return self  raise CloudantDatabaseException ( resp . status_code , self . database_url , resp . text )  def delete ( self ) :          resp = self . r_session . delete ( self . database_url ) resp . raise_for_status ( )  def all_docs ( self , ** kwargs ) :          resp = get_docs ( self . r_session , <str> . join ( [ self . database_url , <str> ] ) , self . client . encoder , ** kwargs ) return response_to_json_dict ( resp )  def partitioned_all_docs ( self , partition_key , ** kwargs ) :          resp = get_docs ( self . r_session , <str> . join ( [ self . database_partition_url ( partition_key ) , <str> ] ) , self . client . encoder , ** kwargs ) return response_to_json_dict ( resp )  @ contextlib . contextmanager def custom_result ( self , ** options ) :          rslt = Result ( self . all_docs , ** options ) yield rslt del rslt  def keys ( self , remote = False ) :          if not remote :              return list ( super ( CouchDatabase , self ) . keys ( ) )  docs = self . all_docs ( ) return [ row [ <str> ] for row in docs . get ( <str> , [ ] ) ]  def changes ( self , raw_data = False , ** kwargs ) :          return Feed ( self , raw_data , ** kwargs )  def infinite_changes ( self , ** kwargs ) :          return InfiniteFeed ( self , ** kwargs )  def __getitem__ ( self , key ) :          if key in list ( self . keys ( ) ) :              return super ( CouchDatabase , self ) . __getitem__ ( key )  if key . startswith ( <str> ) :              doc = DesignDocument ( self , key )  else :              doc = Document ( self , key )  if doc . exists ( ) :              doc . fetch ( ) super ( CouchDatabase , self ) . __setitem__ ( key , doc )  else :              raise KeyError ( key )  return doc  def __contains__ ( self , key ) :          if key in list ( self . keys ( ) ) :              return True  if key . startswith ( <str> ) :              doc = DesignDocument ( self , key )  else :              doc = Document ( self , key )  return doc . exists ( )  def __iter__ ( self , remote = True ) :          if not remote :              super ( CouchDatabase , self ) . __iter__ ( )  else :              next_startkey = <str> while next_startkey is not None :                  docs = self . all_docs ( limit = self . _fetch_limit , include_docs = True , startkey = next_startkey ) . get ( <str> , [ ] ) if len ( docs ) >= self . _fetch_limit :                      next_startkey = docs [ - 1 ] [ <str> ] + <str>  else :                      next_startkey = None  for doc in docs :                      if doc [ <str> ] . startswith ( <str> ) :                          document = DesignDocument ( self , doc [ <str> ] )  else :                          document = Document ( self , doc [ <str> ] )  document . update ( doc [ <str> ] ) super ( CouchDatabase , self ) . __setitem__ ( doc [ <str> ] , document ) yield document   return   def bulk_docs ( self , docs ) :          url = <str> . join ( ( self . database_url , <str> ) ) data = { <str> : docs } headers = { <str> : <str> } resp = self . r_session . post ( url , data = json . dumps ( data , cls = self . client . encoder ) , headers = headers ) resp . raise_for_status ( ) return response_to_json_dict ( resp )  def missing_revisions ( self , doc_id , * revisions ) :          url = <str> . join ( ( self . database_url , <str> ) ) data = { doc_id : list ( revisions ) } resp = self . r_session . post ( url , headers = { <str> : <str> } , data = json . dumps ( data , cls = self . client . encoder ) ) resp . raise_for_status ( ) resp_json = response_to_json_dict ( resp ) missing_revs = resp_json [ <str> ] . get ( doc_id ) if missing_revs is None :              missing_revs = [ ]  return missing_revs  def revisions_diff ( self , doc_id , * revisions ) :          url = <str> . join ( ( self . database_url , <str> ) ) data = { doc_id : list ( revisions ) } resp = self . r_session . post ( url , headers = { <str> : <str> } , data = json . dumps ( data , cls = self . client . encoder ) ) resp . raise_for_status ( ) return response_to_json_dict ( resp )  def get_revision_limit ( self ) :          url = <str> . join ( ( self . database_url , <str> ) ) resp = self . r_session . get ( url ) resp . raise_for_status ( ) try :              ret = int ( resp . text )  except ValueError :              raise CloudantDatabaseException ( 400 , response_to_json_dict ( resp ) )  return ret  def set_revision_limit ( self , limit ) :          url = <str> . join ( ( self . database_url , <str> ) ) resp = self . r_session . put ( url , data = json . dumps ( limit , cls = self . client . encoder ) ) resp . raise_for_status ( ) return response_to_json_dict ( resp )  def view_cleanup ( self ) :          url = <str> . join ( ( self . database_url , <str> ) ) resp = self . r_session . post ( url , headers = { <str> : <str> } ) resp . raise_for_status ( ) return response_to_json_dict ( resp )  def get_list_function_result ( self , ddoc_id , list_name , view_name , ** kwargs ) :          ddoc = DesignDocument ( self , ddoc_id ) headers = { <str> : <str> } resp = get_docs ( self . r_session , <str> . join ( [ ddoc . document_url , <str> , list_name , view_name ] ) , self . client . encoder , headers , ** kwargs ) return resp . text  def get_show_function_result ( self , ddoc_id , show_name , doc_id ) :          ddoc = DesignDocument ( self , ddoc_id ) headers = { <str> : <str> } resp = get_docs ( self . r_session , <str> . join ( [ ddoc . document_url , <str> , show_name , doc_id ] ) , self . client . encoder , headers ) return resp . text  def update_handler_result ( self , ddoc_id , handler_name , doc_id = None , data = None , ** params ) :          ddoc = DesignDocument ( self , ddoc_id ) if doc_id :              resp = self . r_session . put ( <str> . join ( [ ddoc . document_url , <str> , handler_name , doc_id ] ) , params = params , data = data )  else :              resp = self . r_session . post ( <str> . join ( [ ddoc . document_url , <str> , handler_name ] ) , params = params , data = data )  resp . raise_for_status ( ) return resp . text  def get_query_indexes ( self , raw_result = False ) :          url = <str> . join ( ( self . database_url , <str> ) ) resp = self . r_session . get ( url ) resp . raise_for_status ( ) if raw_result :              return response_to_json_dict ( resp )  indexes = [ ] for data in response_to_json_dict ( resp ) . get ( <str> , [ ] ) :              if data . get ( <str> ) == JSON_INDEX_TYPE :                  indexes . append ( Index ( self , data . get ( <str> ) , data . get ( <str> ) , partitioned = data . get ( <str> , False ) , ** data . get ( <str> , { } ) ) )  elif data . get ( <str> ) == TEXT_INDEX_TYPE :                  indexes . append ( TextIndex ( self , data . get ( <str> ) , data . get ( <str> ) , partitioned = data . get ( <str> , False ) , ** data . get ( <str> , { } ) ) )  elif data . get ( <str> ) == SPECIAL_INDEX_TYPE :                  indexes . append ( SpecialIndex ( self , data . get ( <str> ) , data . get ( <str> ) , partitioned = data . get ( <str> , False ) , ** data . get ( <str> , { } ) ) )  else :                  raise CloudantDatabaseException ( 101 , data . get ( <str> ) )   return indexes  def create_query_index ( self , design_document_id = None , index_name = None , index_type = <str> , partitioned = False , ** kwargs ) :          if index_type == JSON_INDEX_TYPE :              index = Index ( self , design_document_id , index_name , partitioned = partitioned , ** kwargs )  elif index_type == TEXT_INDEX_TYPE :              index = TextIndex ( self , design_document_id , index_name , partitioned = partitioned , ** kwargs )  else :              raise CloudantArgumentError ( 103 , index_type )  index . create ( ) return index  def delete_query_index ( self , design_document_id , index_type , index_name ) :          if index_type == JSON_INDEX_TYPE :              index = Index ( self , design_document_id , index_name )  elif index_type == TEXT_INDEX_TYPE :              index = TextIndex ( self , design_document_id , index_name )  else :              raise CloudantArgumentError ( 103 , index_type )  index . delete ( )  def get_partitioned_query_result ( self , partition_key , selector , fields = None , raw_result = False , ** kwargs ) :          query = Query ( self , selector = selector , fields = fields , partition_key = partition_key ) return self . _get_query_result ( query , raw_result , ** kwargs )  def get_query_result ( self , selector , fields = None , raw_result = False , ** kwargs ) :          query = Query ( self , selector = selector , fields = fields ) return self . _get_query_result ( query , raw_result , ** kwargs )  @ staticmethod def _get_query_result ( query , raw_result , ** kwargs ) :          if raw_result :              return query ( ** kwargs )  if kwargs :              return QueryResult ( query , ** kwargs )  return query . result   class CloudantDatabase ( CouchDatabase ) :      def __init__ ( self , client , database_name , fetch_limit = 100 , partitioned = False ) :          super ( CloudantDatabase , self ) . __init__ ( client , database_name , fetch_limit = fetch_limit , partitioned = partitioned )  def security_document ( self ) :          return dict ( self . get_security_document ( ) )  @ property def security_url ( self ) :          url = <str> . join ( ( self . _database_host , <str> , <str> , <str> , self . database_name , <str> ) ) return url  def share_database ( self , username , roles = None ) :          if roles is None :              roles = [ <str> ]  valid_roles = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] doc = self . security_document ( ) data = doc . get ( <str> , { } ) perms = [ ] if all ( role in valid_roles for role in roles ) :              perms = list ( set ( roles ) )  if not perms :              raise CloudantArgumentError ( 102 , roles , valid_roles )  data [ username ] = perms doc [ <str> ] = data resp = self . r_session . put ( self . security_url , data = json . dumps ( doc , cls = self . client . encoder ) , headers = { <str> : <str> } ) resp . raise_for_status ( ) return response_to_json_dict ( resp )  def unshare_database ( self , username ) :          doc = self . security_document ( ) data = doc . get ( <str> , { } ) if username in data :              del data [ username ]  doc [ <str> ] = data resp = self . r_session . put ( self . security_url , data = json . dumps ( doc , cls = self . client . encoder ) , headers = { <str> : <str> } ) resp . raise_for_status ( ) return response_to_json_dict ( resp )  def shards ( self ) :          url = <str> . join ( ( self . database_url , <str> ) ) resp = self . r_session . get ( url ) resp . raise_for_status ( ) return response_to_json_dict ( resp )  def get_partitioned_search_result ( self , partition_key , ddoc_id , index_name , ** query_params ) :          ddoc = DesignDocument ( self , ddoc_id ) return self . _get_search_result ( <str> . join ( ( ddoc . document_partition_url ( partition_key ) , <str> , index_name ) ) , ** query_params )  def get_search_result ( self , ddoc_id , index_name , ** query_params ) :          ddoc = DesignDocument ( self , ddoc_id ) return self . _get_search_result ( <str> . join ( ( ddoc . document_url , <str> , index_name ) ) , ** query_params )  def _get_search_result ( self , query_url , ** query_params ) :          param_q = query_params . get ( <str> ) param_query = query_params . get ( <str> ) if bool ( param_q ) == bool ( param_query ) :              raise CloudantArgumentError ( 104 , query_params )  for key , val in iteritems_ ( query_params ) :              if key not in list ( SEARCH_INDEX_ARGS . keys ( ) ) :                  raise CloudantArgumentError ( 105 , key )  if not isinstance ( val , SEARCH_INDEX_ARGS [ key ] ) :                  raise CloudantArgumentError ( 106 , key , SEARCH_INDEX_ARGS [ key ] )   headers = { <str> : <str> } resp = self . r_session . post ( query_url , headers = headers , data = json . dumps ( query_params , cls = self . client . encoder ) ) resp . raise_for_status ( ) return response_to_json_dict ( resp )    