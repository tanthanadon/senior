import time import unittest import uuid import requests from cloudant . document import Document from cloudant . error import CloudantReplicatorException , CloudantClientException from cloudant . replicator import Replicator from flaky import flaky from nose . plugins . attrib import attr from requests import ConnectionError from . unit_t_db_base import UnitTestDbBase from . . import unicode_ class CloudantReplicatorExceptionTests ( unittest . TestCase ) :      def test_raise_without_code ( self ) :          with self . assertRaises ( CloudantReplicatorException ) as cm :              raise CloudantReplicatorException ( )  self . assertEqual ( cm . exception . status_code , 100 )  def test_raise_using_invalid_code ( self ) :          with self . assertRaises ( CloudantReplicatorException ) as cm :              raise CloudantReplicatorException ( <str> )  self . assertEqual ( cm . exception . status_code , 100 )  def test_raise_without_args ( self ) :          with self . assertRaises ( CloudantReplicatorException ) as cm :              raise CloudantReplicatorException ( 404 )  self . assertEqual ( cm . exception . status_code , 100 )  def test_raise_with_proper_code_and_args ( self ) :          with self . assertRaises ( CloudantReplicatorException ) as cm :              raise CloudantReplicatorException ( 404 , <str> )  self . assertEqual ( cm . exception . status_code , 404 )   @ attr ( db = [ <str> , <str> ] ) class ReplicatorTests ( UnitTestDbBase ) :      def setUp ( self ) :          super ( ReplicatorTests , self ) . setUp ( ) self . db_set_up ( ) self . test_target_dbname = self . dbname ( ) self . target_db = self . client . _DATABASE_CLASS ( self . client , self . test_target_dbname ) self . target_db . create ( ) self . replicator = Replicator ( self . client ) self . replication_ids = [ ]  def tearDown ( self ) :          self . target_db . delete ( ) del self . test_target_dbname del self . target_db for rep_id in self . replication_ids :              max_retry = 5 while True :                  try :                      self . replicator . stop_replication ( rep_id ) break  except requests . HTTPError as ex :                      max_retry -= 1 if ex . response . status_code != 409 or max_retry == 0 :                          raise     del self . replicator self . db_tear_down ( ) super ( ReplicatorTests , self ) . tearDown ( )  def test_constructor ( self ) :          self . assertIsInstance ( self . replicator , Replicator ) self . assertIsInstance ( self . replicator . database , self . client . _DATABASE_CLASS ) self . assertEqual ( self . replicator . database , self . client [ <str> ] )  def test_constructor_failure ( self ) :          repl = None try :              self . client . disconnect ( ) repl = Replicator ( self . client ) self . fail ( <str> )  except CloudantClientException as err :              self . assertEqual ( str ( err ) , <str> <str> )  finally :              self . assertIsNone ( repl ) self . client . connect ( )   def test_replication_with_generated_id ( self ) :          clone = Replicator ( self . client ) repl_id = clone . create_replication ( self . db , self . target_db ) self . replication_ids . append ( repl_id [ <str> ] )  @ flaky ( max_runs = 3 ) def test_create_replication ( self ) :          self . populate_db_with_documents ( 3 ) repl_id = <str> . format ( unicode_ ( uuid . uuid4 ( ) ) ) repl_doc = self . replicator . create_replication ( self . db , self . target_db , repl_id ) self . replication_ids . append ( repl_id ) expected_keys = [ <str> , <str> , <str> , <str> , <str> ] if self . client . admin_party or self . client . is_iam_authenticated :              expected_keys . pop ( )  self . assertTrue ( all ( x in list ( repl_doc . keys ( ) ) for x in expected_keys ) ) self . assertEqual ( repl_doc [ <str> ] , repl_id ) self . assertTrue ( repl_doc [ <str> ] . startswith ( <str> ) ) repl_doc = Document ( self . replicator . database , repl_id ) repl_doc . fetch ( ) if repl_doc . get ( <str> ) not in ( <str> , <str> ) :              changes = self . replicator . database . changes ( feed = <str> , heartbeat = 1000 ) beats = 0 for change in changes :                  if beats == 300 :                      changes . stop ( )  if not change :                      beats += 1 continue  elif change . get ( <str> ) == repl_id :                      beats = 0 repl_doc = Document ( self . replicator . database , repl_id ) repl_doc . fetch ( ) if repl_doc . get ( <str> ) in ( <str> , <str> ) :                          changes . stop ( )     self . assertEqual ( repl_doc . get ( <str> ) , <str> ) self . assertEqual ( self . db . all_docs ( ) , self . target_db . all_docs ( ) ) self . assertTrue ( all ( x in self . target_db . keys ( True ) for x in [ <str> , <str> , <str> ] ) )  def test_timeout_in_create_replication ( self ) :          self . set_up_client ( auto_connect = True , timeout = ( 30 , 5 ) ) self . db = self . client [ self . test_target_dbname ] self . target_db = self . client [ self . test_dbname ] self . replicator = Replicator ( self . client ) repl_id = <str> . format ( unicode_ ( uuid . uuid4 ( ) ) ) repl_doc = self . replicator . create_replication ( self . db , self . target_db , repl_id ) self . replication_ids . append ( repl_id ) expected_keys = [ <str> , <str> , <str> , <str> , <str> ] if self . client . admin_party or self . client . is_iam_authenticated :              expected_keys . pop ( )  self . assertTrue ( all ( x in list ( repl_doc . keys ( ) ) for x in expected_keys ) ) self . assertEqual ( repl_doc [ <str> ] , repl_id ) self . assertTrue ( repl_doc [ <str> ] . startswith ( <str> ) ) repl_doc = Document ( self . replicator . database , repl_id ) repl_doc . fetch ( ) if repl_doc . get ( <str> ) not in ( <str> , <str> ) :              with self . assertRaises ( ConnectionError ) as cm :                  changes = self . replicator . database . changes ( feed = <str> ) for change in changes :                      continue   self . assertTrue ( str ( cm . exception ) . endswith ( <str> ) )   def test_create_replication_without_a_source ( self ) :          try :              repl_doc = self . replicator . create_replication ( ) self . fail ( <str> )  except CloudantReplicatorException as err :              self . assertEqual ( str ( err ) , <str> <str> )   def test_create_replication_without_a_target ( self ) :          try :              repl_doc = self . replicator . create_replication ( self . db ) self . fail ( <str> )  except CloudantReplicatorException as err :              self . assertEqual ( str ( err ) , <str> <str> )   def test_list_replications ( self ) :          self . populate_db_with_documents ( 3 ) repl_ids = [ <str> . format ( unicode_ ( uuid . uuid4 ( ) ) ) for _ in range ( 3 ) ] repl_docs = [ self . replicator . create_replication ( self . db , self . target_db , repl_id ) for repl_id in repl_ids ] self . replication_ids . extend ( repl_ids ) replications = self . replicator . list_replications ( ) all_repl_ids = [ doc [ <str> ] for doc in replications ] match = [ repl_id for repl_id in all_repl_ids if repl_id in repl_ids ] self . assertEqual ( set ( repl_ids ) , set ( match ) )  def test_retrieve_replication_state ( self ) :          self . populate_db_with_documents ( 3 ) repl_id = <str> . format ( unicode_ ( uuid . uuid4 ( ) ) ) repl_doc = self . replicator . create_replication ( self . db , self . target_db , repl_id ) self . replication_ids . append ( repl_id ) repl_state = None valid_states = [ <str> , <str> , <str> , <str> , None ] finished = False for _ in range ( 300 ) :              repl_state = self . replicator . replication_state ( repl_id ) self . assertTrue ( repl_state in valid_states ) if repl_state in ( <str> , <str> ) :                  finished = True break  time . sleep ( 1 )  self . assertTrue ( finished )  def test_retrieve_replication_state_using_invalid_id ( self ) :          repl_id = <str> . format ( unicode_ ( uuid . uuid4 ( ) ) ) repl_state = None try :              self . replicator . replication_state ( repl_id ) self . fail ( <str> )  except CloudantReplicatorException as err :              self . assertEqual ( str ( err ) , <str> . format ( repl_id ) ) self . assertIsNone ( repl_state )   def test_stop_replication ( self ) :          self . populate_db_with_documents ( 3 ) repl_id = <str> . format ( unicode_ ( uuid . uuid4 ( ) ) ) repl_doc = self . replicator . create_replication ( self . db , self . target_db , repl_id ) max_retry = 3 while True :              try :                  max_retry -= 1 self . replicator . stop_replication ( repl_id ) break  except requests . HTTPError as err :                  self . assertEqual ( err . response . status_code , 409 ) if max_retry == 0 :                      self . fail ( <str> . format ( err ) )    try :              repl_doc . fetch ( ) self . fail ( <str> )  except requests . HTTPError as err :              self . assertEqual ( err . response . status_code , 404 )   def test_stop_replication_using_invalid_id ( self ) :          repl_id = <str> . format ( unicode_ ( uuid . uuid4 ( ) ) ) try :              self . replicator . stop_replication ( repl_id ) self . fail ( <str> )  except CloudantReplicatorException as err :              self . assertEqual ( str ( err ) , <str> . format ( repl_id ) )   def test_follow_replication ( self ) :          self . populate_db_with_documents ( 3 ) repl_id = <str> . format ( unicode_ ( uuid . uuid4 ( ) ) ) repl_doc = self . replicator . create_replication ( self . db , self . target_db , repl_id ) self . replication_ids . append ( repl_id ) valid_states = ( <str> , <str> , <str> , <str> , None ) repl_states = [ ] if <str> in self . client . features ( ) :              state_key = <str>  else :              state_key = <str>  for doc in self . replicator . follow_replication ( repl_id ) :              self . assertIn ( doc . get ( state_key ) , valid_states ) repl_states . append ( doc . get ( state_key ) )  self . assertTrue ( len ( repl_states ) > 0 ) self . assertEqual ( repl_states [ - 1 ] , <str> ) self . assertNotIn ( <str> , repl_states )   if __name__ == <str> :      unittest . main ( )   