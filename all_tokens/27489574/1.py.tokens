import uuid from requests . exceptions import HTTPError from . error import CloudantReplicatorException , CloudantClientException from . document import Document from . scheduler import Scheduler class Replicator ( object ) :      def __init__ ( self , client ) :          repl_db = <str> self . client = client try :              self . database = client [ repl_db ]  except Exception :              raise CloudantClientException ( 404 , repl_db )   def create_replication ( self , source_db = None , target_db = None , repl_id = None , ** kwargs ) :          if source_db is None :              raise CloudantReplicatorException ( 101 )  if target_db is None :              raise CloudantReplicatorException ( 102 )  data = dict ( _id = repl_id if repl_id else str ( uuid . uuid4 ( ) ) , ** kwargs ) data [ <str> ] = { <str> : source_db . database_url } if source_db . admin_party :              pass  elif source_db . client . is_iam_authenticated :              data [ <str> ] . update ( { <str> : { <str> : { <str> : source_db . client . r_session . get_api_key } } } )  else :              data [ <str> ] . update ( { <str> : { <str> : source_db . creds [ <str> ] } } )  data [ <str> ] = { <str> : target_db . database_url } if target_db . admin_party :              pass  elif target_db . client . is_iam_authenticated :              data [ <str> ] . update ( { <str> : { <str> : { <str> : target_db . client . r_session . get_api_key } } } )  else :              data [ <str> ] . update ( { <str> : { <str> : target_db . creds [ <str> ] } } )  if not data . get ( <str> ) and self . database . creds and self . database . creds . get ( <str> ) :              data [ <str> ] = self . database . creds [ <str> ]  return self . database . create_document ( data , throw_on_exists = True )  def list_replications ( self ) :          docs = self . database . all_docs ( include_docs = True ) [ <str> ] documents = [ ] for doc in docs :              if doc [ <str> ] . startswith ( <str> ) :                  continue  document = Document ( self . database , doc [ <str> ] ) document . update ( doc [ <str> ] ) documents . append ( document )  return documents  def replication_state ( self , repl_id ) :          if <str> in self . client . features ( ) :              try :                  repl_doc = Scheduler ( self . client ) . get_doc ( repl_id )  except HTTPError as err :                  raise CloudantReplicatorException ( err . response . status_code , repl_id )  state = repl_doc [ <str> ]  else :              try :                  repl_doc = self . database [ repl_id ]  except KeyError :                  raise CloudantReplicatorException ( 404 , repl_id )  repl_doc . fetch ( ) state = repl_doc . get ( <str> )  return state  def follow_replication ( self , repl_id ) :          def update_state ( ) :              if <str> in self . client . features ( ) :                  try :                      arepl_doc = Scheduler ( self . client ) . get_doc ( repl_id ) return arepl_doc , arepl_doc [ <str> ]  except HTTPError :                      return None , None   else :                  try :                      arepl_doc = self . database [ repl_id ] arepl_doc . fetch ( ) return arepl_doc , arepl_doc . get ( <str> )  except KeyError :                      return None , None    while True :              repl_doc , state = update_state ( ) if repl_doc :                  yield repl_doc  if state is not None and state in [ <str> , <str> ] :                  return  for change in self . database . changes ( ) :                  if change . get ( <str> ) == repl_id :                      repl_doc , state = update_state ( ) if repl_doc is not None :                          yield repl_doc  if state is not None and state in [ <str> , <str> ] :                          return      def stop_replication ( self , repl_id ) :          try :              repl_doc = self . database [ repl_id ]  except KeyError :              raise CloudantReplicatorException ( 404 , repl_id )  repl_doc . fetch ( ) repl_doc . delete ( )    