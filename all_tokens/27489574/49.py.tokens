import unittest import requests import os import uuid import json from cloudant . client import CouchDB , Cloudant from cloudant . design_document import DesignDocument from cloudant . error import CloudantClientException from . . import unicode_ def skip_if_not_cookie_auth ( f ) :      def wrapper ( * args ) :          if not args [ 0 ] . use_cookie_auth :              raise unittest . SkipTest ( <str> )  return f ( * args )  return wrapper  def skip_if_iam ( f ) :      def wrapper ( * args ) :          if os . environ . get ( <str> ) :              raise unittest . SkipTest ( <str> )  return f ( * args )  return wrapper  class UnitTestDbBase ( unittest . TestCase ) :      @ classmethod def setUpClass ( cls ) :          if os . environ . get ( <str> ) is None :              if os . environ . get ( <str> ) is None :                  os . environ [ <str> ] = <str>  if ( os . environ . get ( <str> ) and os . environ . get ( <str> ) == <str> ) :                  if os . environ . get ( <str> ) :                      del os . environ [ <str> ]  if os . environ . get ( <str> ) :                      del os . environ [ <str> ]  return  if os . environ . get ( <str> ) is None :                  if os . environ . get ( <str> ) == <str> :                      os . environ [ <str> ] = requests . get ( <str> . format ( os . environ [ <str> ] ) ) . json ( ) [ <str> ] [ 0 ]  os . environ [ <str> ] = <str> os . environ [ <str> ] = <str> . format ( unicode_ ( uuid . uuid4 ( ) ) ) os . environ [ <str> ] = <str> if os . environ . get ( <str> ) == <str> :                      resp = requests . put ( <str> . format ( os . environ [ <str> ] , os . environ [ <str> ] , os . environ [ <str> ] ) , data = <str> . format ( os . environ [ <str> ] ) )  else :                      resp = requests . put ( <str> . format ( os . environ [ <str> ] , os . environ [ <str> ] ) , data = <str> . format ( os . environ [ <str> ] ) )  resp . raise_for_status ( )    @ classmethod def tearDownClass ( cls ) :          if ( os . environ . get ( <str> ) is None and os . environ . get ( <str> ) is not None ) :              if os . environ . get ( <str> ) == <str> :                  resp = requests . delete ( <str> . format ( os . environ [ <str> ] . split ( <str> , 1 ) [ 0 ] , os . environ [ <str> ] , os . environ [ <str> ] , os . environ [ <str> ] . split ( <str> , 1 ) [ 1 ] , os . environ [ <str> ] , os . environ [ <str> ] ) )  else :                  resp = requests . delete ( <str> . format ( os . environ [ <str> ] . split ( <str> , 1 ) [ 0 ] , os . environ [ <str> ] , os . environ [ <str> ] , os . environ [ <str> ] . split ( <str> , 1 ) [ 1 ] , os . environ [ <str> ] ) )  del os . environ [ <str> ] del os . environ [ <str> ] resp . raise_for_status ( )   def setUp ( self ) :          self . set_up_client ( )  def set_up_client ( self , auto_connect = False , auto_renew = False , encoder = None , timeout = ( 30 , 300 ) ) :          self . user = os . environ . get ( <str> , None ) self . pwd = os . environ . get ( <str> , None ) self . use_cookie_auth = True self . iam_api_key = os . environ . get ( <str> , None ) if os . environ . get ( <str> ) is None :              self . url = os . environ [ <str> ] admin_party = False if os . environ . get ( <str> ) == <str> :                  admin_party = True  self . use_cookie_auth = False self . client = CouchDB ( self . user , self . pwd , admin_party , url = self . url , connect = auto_connect , auto_renew = auto_renew , encoder = encoder , timeout = timeout )  else :              self . account = os . environ . get ( <str> ) self . url = os . environ . get ( <str> , <str> . format ( self . account ) ) if os . environ . get ( <str> ) :                  self . use_cookie_auth = False self . client = Cloudant ( self . user , self . pwd , url = self . url , x_cloudant_user = self . account , connect = auto_connect , auto_renew = auto_renew , encoder = encoder , timeout = timeout , use_basic_auth = True , )  elif self . iam_api_key :                  self . use_cookie_auth = False self . client = Cloudant ( None , self . iam_api_key , url = self . url , x_cloudant_user = self . account , connect = auto_connect , auto_renew = auto_renew , encoder = encoder , timeout = timeout , use_iam = True , )  else :                  self . client = Cloudant ( self . user , self . pwd , url = self . url , x_cloudant_user = self . account , connect = auto_connect , auto_renew = auto_renew , encoder = encoder , timeout = timeout )    def tearDown ( self ) :          del self . client  def db_set_up ( self , partitioned = False ) :          self . client . connect ( ) self . test_dbname = self . dbname ( ) self . db = self . client . _DATABASE_CLASS ( self . client , self . test_dbname , partitioned = partitioned ) self . db . create ( )  def db_tear_down ( self ) :          self . db . delete ( ) self . client . disconnect ( ) del self . test_dbname del self . db  def dbname ( self , database_name = <str> ) :          return <str> . format ( database_name , self . _testMethodName , unicode_ ( uuid . uuid4 ( ) ) )  def populate_db_with_documents ( self , doc_count = 100 , ** kwargs ) :          off_set = kwargs . get ( <str> , 0 ) docs = [ { <str> : <str> . format ( i ) , <str> : <str> , <str> : i } for i in range ( off_set , off_set + doc_count ) ] return self . db . bulk_docs ( docs )  def populate_db_with_partitioned_documents ( self , key_count , docs_per_partition ) :          partition_keys = [ uuid . uuid4 ( ) . hex . upper ( ) [ : 8 ] for _ in range ( key_count ) ] for partition_key in partition_keys :              docs = [ ] for i in range ( docs_per_partition ) :                  docs . append ( { <str> : <str> . format ( partition_key , i ) , <str> : <str> } )  self . db . bulk_docs ( docs )  return partition_keys  def create_views ( self ) :          self . ddoc = DesignDocument ( self . db , <str> ) self . ddoc . add_view ( <str> , <str> ) self . ddoc . add_view ( <str> , <str> , <str> ) self . ddoc . add_view ( <str> , <str> ) self . ddoc . add_view ( <str> , <str> , <str> ) self . ddoc . add_view ( <str> , <str> ) self . ddoc . add_view ( <str> , <str> , <str> ) self . ddoc . add_view ( <str> , <str> ) self . ddoc . save ( ) self . view001 = self . ddoc . get_view ( <str> ) self . view002 = self . ddoc . get_view ( <str> ) self . view003 = self . ddoc . get_view ( <str> ) self . view004 = self . ddoc . get_view ( <str> ) self . view005 = self . ddoc . get_view ( <str> ) self . view006 = self . ddoc . get_view ( <str> ) self . view007 = self . ddoc . get_view ( <str> )  def create_search_index ( self ) :          self . search_ddoc = DesignDocument ( self . db , <str> ) self . search_ddoc [ <str> ] = { <str> : { <str> : <str> <str> <str> } } self . search_ddoc . save ( )  def load_security_document_data ( self ) :          self . sdoc = { <str> : { <str> : [ <str> ] , <str> : [ <str> ] } , <str> : { <str> : [ <str> , <str> ] , <str> : [ <str> ] } } self . mod_sdoc = { <str> : { <str> : [ <str> ] , <str> : [ <str> ] } , <str> : { <str> : [ <str> , <str> ] , <str> : [ <str> ] } } if os . environ . get ( <str> ) is not None :              self . sdoc = { <str> : { <str> : [ <str> , <str> ] , <str> : [ <str> ] } } self . mod_sdoc = { <str> : { <str> : [ <str> , <str> ] , <str> : [ <str> ] } }  resp = self . client . r_session . put ( <str> . join ( [ self . db . database_url , <str> ] ) , data = json . dumps ( self . sdoc ) , headers = { <str> : <str> } ) self . assertEqual ( resp . status_code , 200 )  def create_db_updates ( self ) :          self . DB_UPDATES = <str> try :              self . client . create_database ( self . DB_UPDATES , throw_on_exists = True )  except CloudantClientException :              self . delete_db_updates ( ) self . create_db_updates ( )   def delete_db_updates ( self ) :          try :              self . client . delete_database ( self . DB_UPDATES )  except CloudantClientException :              pass   def is_couchdb_1x_version ( self ) :          if os . environ . get ( <str> ) and os . environ . get ( <str> ) . startswith ( <str> ) :              return True  else :              couchdb_info = json . loads ( self . client . r_session . get ( self . client . server_url ) . text ) if couchdb_info and couchdb_info [ <str> ] . startswith ( <str> ) :                  return True  else :                  return False      