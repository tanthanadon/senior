import base64 import datetime import json import os import sys import unittest from time import sleep import mock import requests from cloudant import cloudant , cloudant_bluemix , couchdb , couchdb_admin_party from cloudant . _client_session import BasicSession , CookieSession from cloudant . client import Cloudant , CouchDB from cloudant . database import CloudantDatabase from cloudant . error import ( CloudantArgumentError , CloudantClientException , CloudantDatabaseException ) from cloudant . feed import Feed , InfiniteFeed from nose . plugins . attrib import attr from requests import ConnectTimeout , HTTPError from . unit_t_db_base import skip_if_iam , skip_if_not_cookie_auth , UnitTestDbBase from . . import bytes_ , str_ class CloudantClientExceptionTests ( unittest . TestCase ) :      def test_raise_without_code ( self ) :          with self . assertRaises ( CloudantClientException ) as cm :              raise CloudantClientException ( )  self . assertEqual ( cm . exception . status_code , 100 )  def test_raise_using_invalid_code ( self ) :          with self . assertRaises ( CloudantClientException ) as cm :              raise CloudantClientException ( <str> )  self . assertEqual ( cm . exception . status_code , 100 )  def test_raise_without_args ( self ) :          with self . assertRaises ( CloudantClientException ) as cm :              raise CloudantClientException ( 404 )  self . assertEqual ( cm . exception . status_code , 100 )  def test_raise_with_proper_code_and_args ( self ) :          with self . assertRaises ( CloudantClientException ) as cm :              raise CloudantClientException ( 404 , <str> )  self . assertEqual ( cm . exception . status_code , 404 )   class ClientTests ( UnitTestDbBase ) :      @ unittest . skipIf ( ( ( os . environ . get ( <str> ) and os . environ . get ( <str> ) == <str> ) ) , <str> ) @ attr ( db = <str> ) def test_couchdb_context_helper ( self ) :          try :              with couchdb ( self . user , self . pwd , url = self . url ) as c :                  self . assertIsInstance ( c , CouchDB ) self . assertIsInstance ( c . r_session , requests . Session )   except Exception as err :              self . fail ( <str> . format ( str ( err ) ) )   @ unittest . skipUnless ( ( ( os . environ . get ( <str> ) and os . environ . get ( <str> ) == <str> ) ) , <str> ) @ attr ( db = <str> ) def test_couchdb_admin_party_context_helper ( self ) :          try :              with couchdb_admin_party ( url = self . url ) as c :                  self . assertIsInstance ( c , CouchDB ) self . assertIsInstance ( c . r_session , requests . Session )   except Exception as err :              self . fail ( <str> . format ( str ( err ) ) )   def test_constructor_with_url ( self ) :          self . assertEqual ( self . client . server_url , self . url ) self . assertEqual ( self . client . encoder , json . JSONEncoder ) self . assertIsNone ( self . client . r_session )  def test_constructor_with_creds_removed_from_url ( self ) :          client = CouchDB ( None , None , url = <str> <str> <str> <str> ) self . assertEqual ( client . server_url , <str> <str> ) self . assertEqual ( client . _user , <str> ) self . assertEqual ( client . _auth_token , <str> <str> )  def test_connect ( self ) :          try :              self . client . connect ( ) self . assertIsInstance ( self . client . r_session , requests . Session )  finally :              self . client . disconnect ( ) self . assertIsNone ( self . client . r_session )   def test_auto_connect ( self ) :          try :              self . set_up_client ( auto_connect = True ) self . assertIsInstance ( self . client . r_session , requests . Session )  finally :              self . client . disconnect ( ) self . assertIsNone ( self . client . r_session )   def test_multiple_connect ( self ) :          try :              self . client . connect ( ) self . set_up_client ( auto_connect = True ) self . client . connect ( ) self . assertIsInstance ( self . client . r_session , requests . Session )  finally :              self . client . disconnect ( ) self . assertIsNone ( self . client . r_session )   @ skip_if_not_cookie_auth def test_auto_renew_enabled ( self ) :          try :              self . set_up_client ( auto_renew = True ) self . client . connect ( ) if os . environ . get ( <str> ) == <str> :                  self . assertIsInstance ( self . client . r_session , requests . Session )  else :                  self . assertIsInstance ( self . client . r_session , CookieSession )   finally :              self . client . disconnect ( )   @ skip_if_not_cookie_auth def test_auto_renew_enabled_with_auto_connect ( self ) :          try :              self . set_up_client ( auto_connect = True , auto_renew = True ) if os . environ . get ( <str> ) == <str> :                  self . assertIsInstance ( self . client . r_session , requests . Session )  else :                  self . assertIsInstance ( self . client . r_session , CookieSession )   finally :              self . client . disconnect ( )   @ skip_if_not_cookie_auth def test_session ( self ) :          try :              self . client . connect ( ) session = self . client . session ( ) if self . client . admin_party :                  self . assertIsNone ( session )  else :                  self . assertEqual ( session [ <str> ] [ <str> ] , self . user )   finally :              self . client . disconnect ( )   @ skip_if_not_cookie_auth def test_session_cookie ( self ) :          try :              self . client . connect ( ) if self . client . admin_party :                  self . assertIsNone ( self . client . session_cookie ( ) )  else :                  self . assertIsNotNone ( self . client . session_cookie ( ) )   finally :              self . client . disconnect ( )   @ mock . patch ( <str> ) def test_session_basic ( self , m_req ) :          m_response_ok = mock . MagicMock ( ) type ( m_response_ok ) . status_code = mock . PropertyMock ( return_value = 200 ) type ( m_response_ok ) . text = mock . PropertyMock ( return_value = <str> ) m_req . return_value = m_response_ok client = Cloudant ( <str> , <str> , url = self . url , use_basic_auth = True ) client . connect ( ) self . assertIsInstance ( client . r_session , BasicSession ) all_dbs = client . all_dbs ( ) m_req . assert_called_once_with ( <str> , self . url + <str> , allow_redirects = True , auth = ( <str> , <str> ) , timeout = None ) self . assertEquals ( all_dbs , [ <str> ] )  @ mock . patch ( <str> ) def test_session_basic_with_no_credentials ( self , m_req ) :          m_response_ok = mock . MagicMock ( ) type ( m_response_ok ) . status_code = mock . PropertyMock ( return_value = 200 ) m_req . return_value = m_response_ok client = Cloudant ( None , None , url = self . url , use_basic_auth = True ) client . connect ( ) self . assertIsInstance ( client . r_session , BasicSession ) db = client [ <str> ] m_req . assert_called_once_with ( <str> , self . url + <str> , allow_redirects = False , auth = None , timeout = None ) self . assertIsInstance ( db , CloudantDatabase )  @ mock . patch ( <str> ) def test_change_credentials_basic ( self , m_req ) :          m_response_ok = mock . MagicMock ( ) type ( m_response_ok ) . text = mock . PropertyMock ( return_value = <str> ) m_response_bad = mock . MagicMock ( ) m_response_bad . raise_for_status . side_effect = HTTPError ( <str> ) m_req . side_effect = [ m_response_bad , m_response_ok ] client = Cloudant ( <str> , <str> , url = self . url , use_basic_auth = True ) client . connect ( ) self . assertIsInstance ( client . r_session , BasicSession ) with self . assertRaises ( HTTPError ) :              client . all_dbs ( )  m_req . assert_called_with ( <str> , self . url + <str> , allow_redirects = True , auth = ( <str> , <str> ) , timeout = None ) client . change_credentials ( <str> , <str> ) all_dbs = client . all_dbs ( ) m_req . assert_called_with ( <str> , self . url + <str> , allow_redirects = True , auth = ( <str> , <str> ) , timeout = None ) self . assertEquals ( all_dbs , [ <str> ] )  @ skip_if_not_cookie_auth def test_basic_auth_str ( self ) :          try :              self . client . connect ( ) if self . client . admin_party :                  self . assertIsNone ( self . client . basic_auth_str ( ) )  else :                  expected = <str> . format ( str_ ( base64 . urlsafe_b64encode ( bytes_ ( <str> . format ( self . user , self . pwd ) ) ) ) ) self . assertEqual ( self . client . basic_auth_str ( ) , expected )   finally :              self . client . disconnect ( )   def test_all_dbs ( self ) :          dbnames = [ self . dbname ( ) for _ in range ( 3 ) ] try :              self . client . connect ( ) for dbname in dbnames :                  self . client . create_database ( dbname )  self . assertTrue ( set ( dbnames ) . issubset ( self . client . all_dbs ( ) ) )  finally :              for dbname in dbnames :                  self . client . delete_database ( dbname )  self . client . disconnect ( )   def test_create_delete_database ( self ) :          try :              self . client . connect ( ) dbname = self . dbname ( ) db = self . client . create_database ( dbname ) self . assertTrue ( db . exists ( ) ) self . assertIsNone ( self . client . delete_database ( dbname ) ) self . assertFalse ( db . exists ( ) )  finally :              self . client . disconnect ( )   def test_create_existing_database ( self ) :          dbname = self . dbname ( ) self . client . connect ( ) self . client . create_database ( dbname ) with self . assertRaises ( CloudantClientException ) as cm :              self . client . create_database ( dbname , throw_on_exists = True )  self . assertEqual ( cm . exception . status_code , 412 ) self . client . delete_database ( dbname ) self . client . disconnect ( )  def test_create_invalid_database_name ( self ) :          dbname = <str> self . client . connect ( ) with self . assertRaises ( ( CloudantDatabaseException , HTTPError ) ) as cm :              self . client . create_database ( dbname )  code = cm . exception . status_code if hasattr ( cm . exception , <str> ) else cm . exception . response . status_code self . assertEqual ( code , 400 ) self . client . disconnect ( )  @ skip_if_not_cookie_auth @ mock . patch ( <str> ) def test_create_with_server_error ( self , m_req ) :          dbname = self . dbname ( ) m_response_ok = mock . MagicMock ( ) type ( m_response_ok ) . status_code = mock . PropertyMock ( return_value = 200 ) m_response_bad = mock . MagicMock ( ) type ( m_response_bad ) . status_code = mock . PropertyMock ( return_value = 404 ) m_resp_service_error = mock . MagicMock ( ) type ( m_resp_service_error ) . status_code = mock . PropertyMock ( return_value = 500 ) type ( m_resp_service_error ) . text = mock . PropertyMock ( return_value = <str> ) m_req . side_effect = [ m_response_ok , m_response_bad , m_resp_service_error ] self . client . connect ( ) with self . assertRaises ( CloudantDatabaseException ) as cm :              self . client . create_database ( dbname )  self . assertEqual ( cm . exception . status_code , 500 ) self . assertEquals ( m_req . call_count , 3 ) m_req . assert_called_with ( <str> , <str> . join ( [ self . url , dbname ] ) , data = None , params = { <str> : <str> } , timeout = ( 30 , 300 ) )  def test_delete_non_existing_database ( self ) :          try :              self . client . connect ( ) self . client . delete_database ( <str> ) self . fail ( <str> )  except CloudantClientException as err :              self . assertEqual ( str ( err ) , <str> <str> )  finally :              self . client . disconnect ( )   def test_keys ( self ) :          dbs = [ ] try :              self . client . connect ( ) self . assertEqual ( list ( self . client . keys ( ) ) , [ ] ) for _ in range ( 10 ) :                  dbs . append ( self . client . create_database ( self . dbname ( ) ) . database_name )  self . assertTrue ( set ( dbs ) . issubset ( set ( self . client . keys ( remote = True ) ) ) ) self . assertTrue ( set ( dbs ) . issubset ( set ( self . client . all_dbs ( ) ) ) )  finally :              for db in dbs :                  self . client . delete_database ( db )  self . client . disconnect ( )   def test_get_non_existing_db_via_getitem ( self ) :          try :              self . client . connect ( ) db = self . client [ <str> ] self . fail ( <str> )  except KeyError :              pass  finally :              self . client . disconnect ( )   def test_get_db_via_getitem ( self ) :          dbname = self . dbname ( ) try :              self . client . connect ( ) self . client . create_database ( dbname ) db = self . client [ dbname ] self . assertIsInstance ( db , self . client . _DATABASE_CLASS )  finally :              self . client . delete_database ( dbname ) self . client . disconnect ( )   def test_delete_cached_db_object_via_delitem ( self ) :          dbname = self . dbname ( ) try :              self . client . connect ( ) db = self . client . create_database ( dbname ) self . assertIsNotNone ( self . client . get ( dbname ) ) del self . client [ dbname ] self . assertIsNone ( self . client . get ( dbname ) ) self . assertEqual ( self . client [ dbname ] , db )  finally :              self . client . delete_database ( dbname ) self . client . disconnect ( )   def test_delete_remote_db_via_delitem ( self ) :          dbname = self . dbname ( ) try :              self . client . connect ( ) db = self . client . create_database ( dbname ) self . assertIsNotNone ( self . client . get ( dbname ) ) self . client . __delitem__ ( dbname , remote = True ) self . assertIsNone ( self . client . get ( dbname ) ) try :                  db = self . client [ dbname ] self . fail ( <str> )  except KeyError :                  pass   finally :              self . client . disconnect ( )   def test_get_cached_db_object_via_get ( self ) :          dbname = self . dbname ( ) try :              self . client . connect ( ) self . assertIsNone ( self . client . get ( <str> ) ) db = self . client . create_database ( dbname ) self . assertEqual ( self . client . get ( dbname ) , db )  finally :              self . client . delete_database ( dbname ) self . client . disconnect ( )   def test_get_remote_db_via_get ( self ) :          dbname = self . dbname ( ) try :              self . client . connect ( ) self . assertIsNone ( self . client . get ( <str> , remote = True ) ) db = self . client . create_database ( dbname ) del self . client [ dbname ] self . assertIsNone ( self . client . get ( dbname ) ) self . assertEqual ( self . client . get ( dbname , remote = True ) , db )  finally :              self . client . delete_database ( dbname ) self . client . disconnect ( )   def test_set_non_db_value_via_setitem ( self ) :          try :              self . client . connect ( ) self . client [ <str> ] = <str> self . fail ( <str> )  except CloudantClientException as err :              self . assertEqual ( str ( err ) , <str> )  finally :              self . client . disconnect ( )   def test_local_set_db_value_via_setitem ( self ) :          try :              self . client . connect ( ) db = self . client . _DATABASE_CLASS ( self . client , <str> ) self . client [ <str> ] = db self . assertEqual ( self . client . get ( <str> ) , db ) self . assertFalse ( db . exists ( ) )  finally :              self . client . disconnect ( )   def test_create_db_via_setitem ( self ) :          dbname = self . dbname ( ) try :              self . client . connect ( ) db = self . client . _DATABASE_CLASS ( self . client , dbname ) self . client . __setitem__ ( dbname , db , remote = True ) self . assertTrue ( db . exists ( ) )  finally :              self . client . delete_database ( dbname ) self . client . disconnect ( )   def test_db_updates_feed_call ( self ) :          try :              self . client . connect ( ) db_updates = self . client . db_updates ( limit = 100 ) self . assertIs ( type ( db_updates ) , Feed ) self . assertEqual ( db_updates . _url , <str> . join ( [ self . client . server_url , <str> ] ) ) self . assertIsInstance ( db_updates . _r_session , requests . Session ) self . assertFalse ( db_updates . _raw_data ) self . assertEqual ( db_updates . _options . get ( <str> ) , 100 )  finally :              self . client . disconnect ( )    @ attr ( db = <str> ) class CloudantClientTests ( UnitTestDbBase ) :      def test_constructor_with_creds_removed_from_url ( self ) :          client = Cloudant ( None , None , url = <str> <str> <str> <str> ) self . assertEqual ( client . server_url , <str> <str> ) self . assertEqual ( client . _user , <str> ) self . assertEqual ( client . _auth_token , <str> <str> )  @ skip_if_not_cookie_auth def test_cloudant_session_login ( self ) :          self . client . connect ( ) old_cookie = self . client . session_cookie ( ) sleep ( 5 ) self . client . session_login ( ) self . assertNotEqual ( self . client . session_cookie ( ) , old_cookie )  @ skip_if_not_cookie_auth def test_cloudant_session_login_with_new_credentials ( self ) :          self . client . connect ( ) with self . assertRaises ( HTTPError ) as cm :              self . client . session_login ( <str> , <str> )  self . assertTrue ( str ( cm . exception ) . find ( <str> ) )  @ skip_if_not_cookie_auth def test_cloudant_context_helper ( self ) :          try :              with cloudant ( self . user , self . pwd , account = self . account ) as c :                  self . assertIsInstance ( c , Cloudant ) self . assertIsInstance ( c . r_session , requests . Session )   except Exception as err :              self . fail ( <str> . format ( str ( err ) ) )   @ skip_if_not_cookie_auth def test_cloudant_bluemix_context_helper_with_legacy_creds ( self ) :          instance_name = <str> vcap_services = { <str> : [ { <str> : { <str> : self . user , <str> : self . pwd , <str> : <str> . format ( self . account ) , <str> : 443 , <str> : self . url } , <str> : instance_name , } ] } try :              with cloudant_bluemix ( vcap_services , instance_name = instance_name ) as c :                  self . assertIsInstance ( c , Cloudant ) self . assertIsInstance ( c . r_session , requests . Session ) self . assertEquals ( c . session ( ) [ <str> ] [ <str> ] , self . user )   except Exception as err :              self . fail ( <str> . format ( str ( err ) ) )   @ unittest . skipUnless ( os . environ . get ( <str> ) , <str> ) def test_cloudant_bluemix_context_helper_with_iam ( self ) :          instance_name = <str> vcap_services = { <str> : [ { <str> : { <str> : self . iam_api_key , <str> : self . user , <str> : <str> . format ( self . account ) , <str> : 443 , <str> : self . url } , <str> : instance_name , } ] } try :              with cloudant_bluemix ( vcap_services , instance_name = instance_name ) as c :                  self . assertIsInstance ( c , Cloudant ) self . assertIsInstance ( c . r_session , requests . Session )   except Exception as err :              self . fail ( <str> . format ( str ( err ) ) )   def test_cloudant_bluemix_context_helper_raise_error_for_missing_iam_and_creds ( self ) :          instance_name = <str> vcap_services = { <str> : [ { <str> : { <str> : <str> . format ( self . account ) , <str> : 443 , <str> : self . url } , <str> : instance_name , } ] } try :              with cloudant_bluemix ( vcap_services , instance_name = instance_name ) as c :                  self . assertIsInstance ( c , Cloudant ) self . assertIsInstance ( c . r_session , requests . Session )   except CloudantClientException as err :              self . assertEqual ( <str> , str ( err ) )   @ skip_if_iam def test_cloudant_bluemix_dedicated_context_helper ( self ) :          instance_name = <str> service_name = <str> vcap_services = { service_name : [ { <str> : { <str> : self . user , <str> : self . pwd , <str> : <str> . format ( self . account ) , <str> : 443 , <str> : self . url } , <str> : instance_name , } ] } try :              with cloudant_bluemix ( vcap_services , instance_name = instance_name , service_name = service_name ) as c :                  self . assertIsInstance ( c , Cloudant ) self . assertIsInstance ( c . r_session , requests . Session ) self . assertEquals ( c . session ( ) [ <str> ] [ <str> ] , self . user )   except Exception as err :              self . fail ( <str> . format ( str ( err ) ) )   def test_constructor_with_account ( self ) :          del self . client self . client = Cloudant ( self . user , self . pwd , account = self . account ) self . assertEqual ( self . client . server_url , <str> . format ( self . account ) )  @ skip_if_not_cookie_auth def test_bluemix_constructor_with_legacy_creds ( self ) :          instance_name = <str> vcap_services = { <str> : [ { <str> : { <str> : self . user , <str> : self . pwd , <str> : <str> . format ( self . account ) , <str> : 443 , <str> : self . url } , <str> : instance_name } ] } c = Cloudant . bluemix ( vcap_services ) try :              c . connect ( ) self . assertIsInstance ( c , Cloudant ) self . assertIsInstance ( c . r_session , requests . Session ) self . assertEquals ( c . session ( ) [ <str> ] [ <str> ] , self . user )  except Exception as err :              self . fail ( <str> . format ( str ( err ) ) )  finally :              c . disconnect ( )   @ unittest . skipUnless ( os . environ . get ( <str> ) , <str> ) def test_bluemix_constructor_with_iam ( self ) :          instance_name = <str> vcap_services = { <str> : [ { <str> : { <str> : self . iam_api_key , <str> : self . user , <str> : <str> . format ( self . account ) , <str> : 443 } , <str> : instance_name } ] } c = Cloudant . bluemix ( vcap_services ) try :              c . connect ( ) self . assertIsInstance ( c , Cloudant ) self . assertIsInstance ( c . r_session , requests . Session )  except Exception as err :              self . fail ( <str> . format ( str ( err ) ) )  finally :              c . disconnect ( )   @ skip_if_iam def test_bluemix_constructor_specify_instance_name ( self ) :          instance_name = <str> vcap_services = { <str> : [ { <str> : { <str> : self . user , <str> : self . pwd , <str> : <str> . format ( self . account ) , <str> : 443 , <str> : self . url } , <str> : instance_name } ] } c = Cloudant . bluemix ( vcap_services , instance_name = instance_name ) try :              c . connect ( ) self . assertIsInstance ( c , Cloudant ) self . assertIsInstance ( c . r_session , requests . Session ) self . assertEquals ( c . session ( ) [ <str> ] [ <str> ] , self . user )  except Exception as err :              self . fail ( <str> . format ( str ( err ) ) )  finally :              c . disconnect ( )   @ skip_if_not_cookie_auth def test_bluemix_constructor_with_multiple_services ( self ) :          instance_name = <str> vcap_services = { <str> : [ { <str> : { <str> : <str> , <str> : <str> . format ( self . account ) , <str> : 443 , <str> : self . url } , <str> : instance_name } , { <str> : { <str> : <str> , <str> : <str> , <str> : <str> , <str> : 1234 , <str> : <str> } , <str> : <str> } ] } c = Cloudant . bluemix ( vcap_services , instance_name = instance_name ) try :              c . connect ( ) self . assertIsInstance ( c , Cloudant ) self . assertIsInstance ( c . r_session , requests . Session ) self . assertEquals ( c . session ( ) [ <str> ] [ <str> ] , self . user )  except Exception as err :              self . fail ( <str> . format ( str ( err ) ) )  finally :              c . disconnect ( )   def test_connect_headers ( self ) :          try :              self . client . connect ( ) self . assertEqual ( self . client . r_session . headers [ <str> ] , self . account ) agent = self . client . r_session . headers . get ( <str> ) ua_parts = agent . split ( <str> ) self . assertEqual ( len ( ua_parts ) , 6 ) self . assertEqual ( ua_parts [ 0 ] , <str> ) self . assertEqual ( ua_parts [ 1 ] , sys . modules [ <str> ] . __version__ ) self . assertEqual ( ua_parts [ 2 ] , <str> ) self . assertEqual ( ua_parts [ 3 ] , <str> . format ( sys . version_info [ 0 ] , sys . version_info [ 1 ] , sys . version_info [ 2 ] ) ) , self . assertEqual ( ua_parts [ 4 ] , os . uname ( ) [ 0 ] ) , self . assertEqual ( ua_parts [ 5 ] , os . uname ( ) [ 4 ] )  finally :              self . client . disconnect ( )   @ skip_if_not_cookie_auth def test_connect_timeout ( self ) :          with self . assertRaises ( ConnectTimeout ) as cm :              self . set_up_client ( auto_connect = True , timeout = .01 )  self . assertTrue ( str ( cm . exception ) . find ( <str> ) )  def test_db_updates_infinite_feed_call ( self ) :          try :              self . client . connect ( ) db_updates = self . client . infinite_db_updates ( ) self . assertIsInstance ( db_updates , InfiniteFeed ) self . assertEqual ( db_updates . _url , <str> . join ( [ self . client . server_url , <str> ] ) ) self . assertIsInstance ( db_updates . _r_session , requests . Session ) self . assertFalse ( db_updates . _raw_data ) self . assertDictEqual ( db_updates . _options , { <str> : <str> } )  finally :              self . client . disconnect ( )   @ skip_if_not_cookie_auth def test_billing_data ( self ) :          try :              self . client . connect ( ) now = datetime . datetime . now ( ) expected = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> ] year = now . year month = now . month data = self . client . bill ( year , month ) self . assertTrue ( all ( x in expected for x in data . keys ( ) ) ) del data data = self . client . bill ( ) self . assertTrue ( all ( x in expected for x in data . keys ( ) ) )  finally :              self . client . disconnect ( )   def test_set_year_without_month_for_billing_data ( self ) :          try :              self . client . connect ( ) year = 2016 with self . assertRaises ( CloudantArgumentError ) as cm :                  self . client . bill ( year )  expected = ( <str> <str> ) self . assertEqual ( str ( cm . exception ) , expected )  finally :              self . client . disconnect ( )   def test_set_month_without_year_for_billing_data ( self ) :          try :              self . client . connect ( ) month = 1 with self . assertRaises ( CloudantArgumentError ) as cm :                  self . client . bill ( None , month )  expected = ( <str> <str> ) self . assertEqual ( str ( cm . exception ) , expected )  finally :              self . client . disconnect ( )   def test_set_invalid_type_year_for_billing_data ( self ) :          try :              self . client . connect ( ) year = <str> month = 1 with self . assertRaises ( CloudantArgumentError ) as cm :                  self . client . bill ( year , month )  expected = ( <str> <str> ) self . assertEqual ( str ( cm . exception ) , expected )  finally :              self . client . disconnect ( )   def test_set_year_with_invalid_month_for_billing_data ( self ) :          try :              self . client . connect ( ) year = 2016 month = 13 with self . assertRaises ( CloudantArgumentError ) as cm :                  self . client . bill ( year , month )  expected = ( <str> <str> ) self . assertEqual ( str ( cm . exception ) , expected )  finally :              self . client . disconnect ( )   @ skip_if_not_cookie_auth def test_volume_usage_data ( self ) :          try :              self . client . connect ( ) now = datetime . datetime . now ( ) expected = [ <str> , <str> , <str> , <str> ] year = now . year month = now . month data = self . client . volume_usage ( year , month ) self . assertTrue ( all ( x in expected for x in data . keys ( ) ) ) del data data = self . client . volume_usage ( ) self . assertTrue ( all ( x in expected for x in data . keys ( ) ) )  finally :              self . client . disconnect ( )   def test_set_year_without_month_for_volume_usage_data ( self ) :          try :              self . client . connect ( ) year = 2016 with self . assertRaises ( CloudantArgumentError ) as cm :                  self . client . volume_usage ( year )  expected = ( <str> <str> ) self . assertEqual ( str ( cm . exception ) , expected )  finally :              self . client . disconnect ( )   def test_set_month_without_year_for_volume_usage_data ( self ) :          try :              self . client . connect ( ) month = 1 with self . assertRaises ( CloudantArgumentError ) as cm :                  self . client . volume_usage ( None , month )  expected = ( <str> <str> ) self . assertEqual ( str ( cm . exception ) , expected )  finally :              self . client . disconnect ( )   def test_set_invalid_type_year_for_volume_usage_data ( self ) :          try :              self . client . connect ( ) year = <str> month = 1 with self . assertRaises ( CloudantArgumentError ) as cm :                  self . client . volume_usage ( year , month )  expected = ( <str> <str> ) self . assertEqual ( str ( cm . exception ) , expected )  finally :              self . client . disconnect ( )   def test_set_year_with_invalid_month_for_volume_usage_data ( self ) :          try :              self . client . connect ( ) year = 2016 month = 13 with self . assertRaises ( CloudantArgumentError ) as cm :                  self . client . volume_usage ( year , month )  expected = ( <str> <str> ) self . assertEqual ( str ( cm . exception ) , expected )  finally :              self . client . disconnect ( )   @ skip_if_not_cookie_auth def test_requests_usage_data ( self ) :          try :              self . client . connect ( ) now = datetime . datetime . now ( ) expected = [ <str> , <str> , <str> , <str> ] year = now . year month = now . month data = self . client . requests_usage ( year , month ) self . assertTrue ( all ( x in expected for x in data . keys ( ) ) ) del data data = self . client . requests_usage ( ) self . assertTrue ( all ( x in expected for x in data . keys ( ) ) )  finally :              self . client . disconnect ( )   def test_set_year_without_month_for_requests_usage_data ( self ) :          try :              self . client . connect ( ) year = 2016 with self . assertRaises ( CloudantArgumentError ) as cm :                  self . client . requests_usage ( year )  expected = ( <str> <str> ) self . assertEqual ( str ( cm . exception ) , expected )  finally :              self . client . disconnect ( )   def test_set_month_without_year_for_requests_usage_data ( self ) :          try :              self . client . connect ( ) month = 1 with self . assertRaises ( CloudantArgumentError ) as cm :                  self . client . requests_usage ( None , month )  expected = ( <str> <str> ) self . assertEqual ( str ( cm . exception ) , expected )  finally :              self . client . disconnect ( )   def test_set_invalid_type_year_for_requests_usage_data ( self ) :          try :              self . client . connect ( ) year = <str> month = 1 with self . assertRaises ( CloudantArgumentError ) as cm :                  self . client . requests_usage ( year , month )  expected = ( <str> <str> ) self . assertEqual ( str ( cm . exception ) , expected )  finally :              self . client . disconnect ( )   def test_set_year_with_invalid_month_for_requests_usage_data ( self ) :          try :              self . client . connect ( ) year = 2016 month = 13 with self . assertRaises ( CloudantArgumentError ) as cm :                  self . client . requests_usage ( year , month )  expected = ( <str> <str> ) self . assertEqual ( str ( cm . exception ) , expected )  finally :              self . client . disconnect ( )   @ skip_if_not_cookie_auth def test_shared_databases ( self ) :          try :              self . client . connect ( ) self . assertIsInstance ( self . client . shared_databases ( ) , list )  finally :              self . client . disconnect ( )   @ skip_if_not_cookie_auth def test_generate_api_key ( self ) :          try :              self . client . connect ( ) expected = [ <str> , <str> , <str> ] api_key = self . client . generate_api_key ( ) self . assertTrue ( all ( x in expected for x in api_key . keys ( ) ) ) self . assertTrue ( api_key [ <str> ] )  finally :              self . client . disconnect ( )   @ skip_if_not_cookie_auth def test_cors_configuration ( self ) :          try :              self . client . connect ( ) expected = [ <str> , <str> , <str> ] cors = self . client . cors_configuration ( ) self . assertTrue ( all ( x in expected for x in cors . keys ( ) ) )  finally :              self . client . disconnect ( )   @ skip_if_not_cookie_auth def test_cors_origins ( self ) :          try :              self . client . connect ( ) origins = self . client . cors_origins ( ) self . assertIsInstance ( origins , list )  finally :              self . client . disconnect ( )   @ skip_if_not_cookie_auth def test_disable_cors ( self ) :          try :              self . client . connect ( ) save = self . client . cors_configuration ( ) self . assertEqual ( self . client . disable_cors ( ) , { <str> : True } ) self . client . update_cors_configuration ( save [ <str> ] , save [ <str> ] , save [ <str> ] , True )  finally :              self . client . disconnect ( )   @ skip_if_not_cookie_auth def test_update_cors_configuration ( self ) :          try :              self . client . connect ( ) save = self . client . cors_configuration ( ) result = self . client . update_cors_configuration ( True , True , [ <str> ] , True ) self . assertEqual ( result , { <str> : True } ) updated_cors = self . client . cors_configuration ( ) self . assertTrue ( updated_cors [ <str> ] ) self . assertTrue ( updated_cors [ <str> ] ) expected = [ <str> ] self . assertTrue ( all ( x in expected for x in updated_cors [ <str> ] ) ) result = self . client . update_cors_configuration ( True , True , [ <str> ] ) self . assertEqual ( result , { <str> : True } ) del updated_cors updated_cors = self . client . cors_configuration ( ) self . assertTrue ( updated_cors [ <str> ] ) self . assertTrue ( updated_cors [ <str> ] ) expected . append ( <str> ) self . assertTrue ( all ( x in expected for x in updated_cors [ <str> ] ) ) self . client . update_cors_configuration ( save [ <str> ] , save [ <str> ] , save [ <str> ] , True )  finally :              self . client . disconnect ( )    if __name__ == <str> :      unittest . main ( )    