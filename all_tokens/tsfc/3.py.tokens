from functools import partial , reduce from gem . node import traversal , Memoizer from gem . gem import Failure , Sum , index_sum from gem . optimise import replace_division , unroll_indexsum from gem . refactorise import collect_monomials from gem . unconcatenate import unconcatenate from gem . coffee import optimise_monomial_sum from gem . utils import groupby import tsfc . spectral as spectral def Integrals ( expressions , quadrature_multiindex , argument_multiindices , parameters ) :      max_extent = parameters [ <str> ] if max_extent :          def predicate ( index ) :              return index . extent <= max_extent  expressions = unroll_indexsum ( expressions , predicate = predicate )  return replace_division ( [ index_sum ( e , quadrature_multiindex ) for e in expressions ] )  def flatten ( var_reps , index_cache ) :      assignments = unconcatenate ( [ ( variable , reduce ( Sum , reps ) ) for variable , reps in var_reps ] , cache = index_cache ) def group_key ( assignment ) :          variable , expression = assignment return variable . free_indices  for argument_indices , assignment_group in groupby ( assignments , group_key ) :          variables , expressions = zip ( * assignment_group ) expressions = optimise_expressions ( expressions , argument_indices ) for var , expr in zip ( variables , expressions ) :              yield ( var , expr )    finalise_options = dict ( remove_componenttensors = False ) def optimise_expressions ( expressions , argument_indices ) :      for n in traversal ( expressions ) :          if isinstance ( n , Failure ) :              return expressions   classifier = partial ( spectral . classify , set ( argument_indices ) , delta_inside = Memoizer ( spectral . _delta_inside ) ) monomial_sums = collect_monomials ( expressions , classifier ) return [ optimise_monomial_sum ( ms , argument_indices ) for ms in monomial_sums ]   