import sys import time from zope . interface import implementer from twisted . internet . interfaces import IReactorFDSet from twisted . python import log , runtime from twisted . internet import posixbase from twisted . python . runtime import platformType , platform from PyQt5 . QtCore import QSocketNotifier , QObject , QTimer , QCoreApplication from PyQt5 . QtCore import QEventLoop , pyqtSignal class TwistedSocketNotifier ( QObject ) :      activated = pyqtSignal ( int ) def __init__ ( self , parent , reactor , watcher , socketType ) :          QObject . __init__ ( self , parent ) self . reactor = reactor self . watcher = watcher fd = watcher . fileno ( ) self . notifier = QSocketNotifier ( fd , socketType , parent ) self . notifier . setEnabled ( True ) if socketType == QSocketNotifier . Read :              self . fn = self . read  else :              self . fn = self . write  self . notifier . activated . connect ( self . fn )  def shutdown ( self ) :          self . notifier . setEnabled ( False ) self . notifier . activated . disconnect ( self . fn ) self . fn = self . watcher = None self . notifier . deleteLater ( ) self . deleteLater ( )  def read ( self , fd ) :          if not self . watcher :              return  w = self . watcher def _read ( ) :              self . notifier . setEnabled ( False ) why = None try :                  why = w . doRead ( ) inRead = True  except :                  inRead = False log . err ( ) why = sys . exc_info ( ) [ 1 ]  if why :                  self . reactor . _disconnectSelectable ( w , why , inRead )  elif self . watcher :                  self . notifier . setEnabled ( True )  self . reactor . _iterate ( fromqt = True )  log . callWithLogger ( w , _read )  def write ( self , sock ) :          if not self . watcher :              return  w = self . watcher def _write ( ) :              why = None self . notifier . setEnabled ( False ) try :                  why = w . doWrite ( )  except :                  log . err ( ) why = sys . exc_info ( ) [ 1 ]  if why :                  self . reactor . _disconnectSelectable ( w , why , False )  elif self . watcher :                  self . notifier . setEnabled ( True )  self . reactor . _iterate ( fromqt = True )  log . callWithLogger ( w , _write )   @ implementer ( IReactorFDSet ) class QtReactor ( posixbase . PosixReactorBase ) :      def __init__ ( self ) :          self . _reads = { } self . _writes = { } self . _notifiers = { } self . _timer = QTimer ( ) self . _timer . setSingleShot ( True ) self . _timer . timeout . connect ( self . iterate ) if QCoreApplication . instance ( ) is None :              self . qApp = QCoreApplication ( [ ] ) self . _ownApp = True  else :              self . qApp = QCoreApplication . instance ( ) self . _ownApp = False  self . _blockApp = None posixbase . PosixReactorBase . __init__ ( self )  def _add ( self , xer , primary , type ) :          if xer not in primary :              primary [ xer ] = TwistedSocketNotifier ( None , self , xer , type )   def addReader ( self , reader ) :          self . _add ( reader , self . _reads , QSocketNotifier . Read )  def addWriter ( self , writer ) :          self . _add ( writer , self . _writes , QSocketNotifier . Write )  def _remove ( self , xer , primary ) :          if xer in primary :              notifier = primary . pop ( xer ) notifier . shutdown ( )   def removeReader ( self , reader ) :          self . _remove ( reader , self . _reads )  def removeWriter ( self , writer ) :          self . _remove ( writer , self . _writes )  def removeAll ( self ) :          rv = self . _removeAll ( self . _reads , self . _writes ) return rv  def getReaders ( self ) :          return self . _reads . keys ( )  def getWriters ( self ) :          return self . _writes . keys ( )  def callLater ( self , howlong , * args , ** kargs ) :          rval = super ( QtReactor , self ) . callLater ( howlong , * args , ** kargs ) self . reactorInvocation ( ) return rval  def reactorInvocation ( self ) :          self . _timer . stop ( ) self . _timer . setInterval ( 0 ) self . _timer . start ( )  def _iterate ( self , delay = None , fromqt = False ) :          self . runUntilCurrent ( ) self . doIteration ( delay , fromqt )  iterate = _iterate def doIteration ( self , delay = None , fromqt = False ) :          if not self . running and self . _blockApp :              self . _blockApp . quit ( )  self . _timer . stop ( ) if delay is None :              delay = 0  delay = max ( delay , 1 ) if not fromqt :              self . qApp . processEvents ( QEventLoop . AllEvents , delay * 1000 )  if self . timeout ( ) is None :              timeout = 0.1  elif self . timeout ( ) == 0 :              timeout = 0  else :              timeout = self . timeout ( )  self . _timer . setInterval ( timeout * 1000 ) self . _timer . start ( )  def runReturn ( self , installSignalHandlers = True ) :          self . startRunning ( installSignalHandlers = installSignalHandlers ) self . reactorInvocation ( )  def run ( self , installSignalHandlers = True ) :          if self . _ownApp :              self . _blockApp = self . qApp  else :              self . _blockApp = QEventLoop ( )  self . runReturn ( ) self . _blockApp . exec_ ( ) if self . running :              self . stop ( ) self . runUntilCurrent ( )    class QtEventReactor ( QtReactor ) :      def __init__ ( self , * args , ** kwargs ) :          self . _events = { } super ( QtEventReactor , self ) . __init__ ( )  def addEvent ( self , event , fd , action ) :          self . _events [ event ] = ( fd , action )  def removeEvent ( self , event ) :          if event in self . _events :              del self . _events [ event ]   def doEvents ( self ) :          handles = self . _events . keys ( ) if len ( handles ) > 0 :              val = None while val != WAIT_TIMEOUT :                  val = MsgWaitForMultipleObjects ( handles , 0 , 0 , QS_ALLINPUT | QS_ALLEVENTS ) if val >= WAIT_OBJECT_0 and val < WAIT_OBJECT_0 + len ( handles ) :                      event_id = handles [ val - WAIT_OBJECT_0 ] if event_id in self . _events :                          fd , action = self . _events [ event_id ] log . callWithLogger ( fd , self . _runAction , action , fd )   elif val == WAIT_TIMEOUT :                      pass  else :                      return     def _runAction ( self , action , fd ) :          try :              closed = getattr ( fd , action ) ( )  except :              closed = sys . exc_info ( ) [ 1 ] log . deferr ( )  if closed :              self . _disconnectSelectable ( fd , closed , action == <str> )   def timeout ( self ) :          t = super ( QtEventReactor , self ) . timeout ( ) return min ( t , 0.01 )  def iterate ( self , delay = None ) :          self . runUntilCurrent ( ) self . doEvents ( ) self . doIteration ( delay )   def posixinstall ( ) :      from twisted . internet . main import installReactor p = QtReactor ( ) installReactor ( p )  def win32install ( ) :      p = QtEventReactor ( ) from twisted . internet . main import installReactor installReactor ( p )  if runtime . platform . getType ( ) == <str> :      from win32event import CreateEvent , MsgWaitForMultipleObjects from win32event import WAIT_OBJECT_0 , WAIT_TIMEOUT , QS_ALLINPUT , QS_ALLEVENTS install = win32install  else :      install = posixinstall  __all__ = [ <str> ]  