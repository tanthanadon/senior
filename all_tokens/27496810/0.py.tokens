from __future__ import print_function import re import sys import inspect import operator import itertools import collections __version__ = <str> if sys . version >= <str> :      from inspect import getfullargspec def get_init ( cls ) :          return cls . __init__   else :      FullArgSpec = collections . namedtuple ( <str> , <str> <str> ) def getfullargspec ( f ) :          <str> return FullArgSpec . _make ( inspect . getargspec ( f ) + ( [ ] , None , { } ) )  def get_init ( cls ) :          return cls . __init__ . __func__   try :      iscoroutinefunction = inspect . iscoroutinefunction  except AttributeError :      def iscoroutinefunction ( f ) :          return False   DEF = re . compile ( <str> ) class FunctionMaker ( object ) :      _compile_count = itertools . count ( ) args = varargs = varkw = defaults = kwonlyargs = kwonlydefaults = ( ) def __init__ ( self , func = None , name = None , signature = None , defaults = None , doc = None , module = None , funcdict = None ) :          self . shortsignature = signature if func :              self . name = func . __name__ if self . name == <str> :                  self . name = <str>  self . doc = func . __doc__ self . module = func . __module__ if inspect . isfunction ( func ) :                  argspec = getfullargspec ( func ) self . annotations = getattr ( func , <str> , { } ) for a in ( <str> , <str> , <str> , <str> , <str> , <str> ) :                      setattr ( self , a , getattr ( argspec , a ) )  for i , arg in enumerate ( self . args ) :                      setattr ( self , <str> % i , arg )  allargs = list ( self . args ) allshortargs = list ( self . args ) if self . varargs :                      allargs . append ( <str> + self . varargs ) allshortargs . append ( <str> + self . varargs )  elif self . kwonlyargs :                      allargs . append ( <str> )  for a in self . kwonlyargs :                      allargs . append ( <str> % a ) allshortargs . append ( <str> % ( a , a ) )  if self . varkw :                      allargs . append ( <str> + self . varkw ) allshortargs . append ( <str> + self . varkw )  self . signature = <str> . join ( allargs ) self . shortsignature = <str> . join ( allshortargs ) self . dict = func . __dict__ . copy ( )   if name :              self . name = name  if signature is not None :              self . signature = signature  if defaults :              self . defaults = defaults  if doc :              self . doc = doc  if module :              self . module = module  if funcdict :              self . dict = funcdict  assert hasattr ( self , <str> ) if not hasattr ( self , <str> ) :              raise TypeError ( <str> % func )   def update ( self , func , ** kw ) :          <str> func . __name__ = self . name func . __doc__ = getattr ( self , <str> , None ) func . __dict__ = getattr ( self , <str> , { } ) func . __defaults__ = self . defaults func . __kwdefaults__ = self . kwonlydefaults or None func . __annotations__ = getattr ( self , <str> , None ) try :              frame = sys . _getframe ( 3 )  except AttributeError :              callermodule = <str>  else :              callermodule = frame . f_globals . get ( <str> , <str> )  func . __module__ = getattr ( self , <str> , callermodule ) func . __dict__ . update ( kw )  def make ( self , src_templ , evaldict = None , addsource = False , ** attrs ) :          <str> src = src_templ % vars ( self ) evaldict = evaldict or { } mo = DEF . search ( src ) if mo is None :              raise SyntaxError ( <str> % src )  name = mo . group ( 1 ) names = set ( [ name ] + [ arg . strip ( <str> ) for arg in self . shortsignature . split ( <str> ) ] ) for n in names :              if n in ( <str> , <str> ) :                  raise NameError ( <str> % ( n , src ) )   if not src . endswith ( <str> ) :              src += <str>  filename = <str> % ( next ( self . _compile_count ) , ) try :              code = compile ( src , filename , <str> ) exec ( code , evaldict )  except Exception :              print ( <str> , file = sys . stderr ) print ( src , file = sys . stderr ) raise  func = evaldict [ name ] if addsource :              attrs [ <str> ] = src  self . update ( func , ** attrs ) return func  @ classmethod def create ( cls , obj , body , evaldict , defaults = None , doc = None , module = None , addsource = True , ** attrs ) :          if isinstance ( obj , str ) :              name , rest = obj . strip ( ) . split ( <str> , 1 ) signature = rest [ : - 1 ] func = None  else :              name = None signature = None func = obj  self = cls ( func , name , signature , defaults , doc , module ) ibody = <str> . join ( <str> + line for line in body . splitlines ( ) ) caller = evaldict . get ( <str> ) if caller and iscoroutinefunction ( caller ) :              body = ( <str> + ibody ) . replace ( <str> , <str> )  else :              body = <str> + ibody  return self . make ( body , evaldict , addsource , ** attrs )   def decorate ( func , caller , extras = ( ) ) :      evaldict = dict ( _call_ = caller , _func_ = func ) es = <str> for i , extra in enumerate ( extras ) :          ex = <str> % i evaldict [ ex ] = extra es += ex + <str>  fun = FunctionMaker . create ( func , <str> % es , evaldict , __wrapped__ = func ) if hasattr ( func , <str> ) :          fun . __qualname__ = func . __qualname__  return fun  def decorator ( caller , _func = None ) :      if _func is not None :          return decorate ( _func , caller )  defaultargs , defaults = <str> , ( ) if inspect . isclass ( caller ) :          name = caller . __name__ . lower ( ) doc = <str> <str> % ( caller . __name__ , caller . __name__ )  elif inspect . isfunction ( caller ) :          if caller . __name__ == <str> :              name = <str>  else :              name = caller . __name__  doc = caller . __doc__ nargs = caller . __code__ . co_argcount ndefs = len ( caller . __defaults__ or ( ) ) defaultargs = <str> . join ( caller . __code__ . co_varnames [ nargs - ndefs : nargs ] ) if defaultargs :              defaultargs += <str>  defaults = caller . __defaults__  else :          name = caller . __class__ . __name__ . lower ( ) doc = caller . __call__ . __doc__  evaldict = dict ( _call = caller , _decorate_ = decorate ) dec = FunctionMaker . create ( <str> % ( name , defaultargs ) , <str> <str> % ( defaultargs , defaultargs ) , evaldict , doc = doc , module = caller . __module__ , __wrapped__ = caller ) if defaults :          dec . __defaults__ = defaults + ( None , )  return dec  try :      from contextlib import _GeneratorContextManager  except ImportError :      from contextlib import GeneratorContextManager as _GeneratorContextManager  class ContextManager ( _GeneratorContextManager ) :      def __call__ ( self , func ) :          return FunctionMaker . create ( func , <str> , dict ( _self_ = self , _func_ = func ) , __wrapped__ = func )   init = getfullargspec ( _GeneratorContextManager . __init__ ) n_args = len ( init . args ) if n_args == 2 and not init . varargs :      def __init__ ( self , g , * a , ** k ) :          return _GeneratorContextManager . __init__ ( self , g ( * a , ** k ) )  ContextManager . __init__ = __init__  elif n_args == 2 and init . varargs :      pass  elif n_args == 4 :      def __init__ ( self , g , * a , ** k ) :          return _GeneratorContextManager . __init__ ( self , g , a , k )  ContextManager . __init__ = __init__  _contextmanager = decorator ( ContextManager ) def contextmanager ( func ) :      return _contextmanager ( func )  def append ( a , vancestors ) :      add = True for j , va in enumerate ( vancestors ) :          if issubclass ( va , a ) :              add = False break  if issubclass ( a , va ) :              vancestors [ j ] = a add = False   if add :          vancestors . append ( a )   def dispatch_on ( * dispatch_args ) :      assert dispatch_args , <str> dispatch_str = <str> % <str> . join ( dispatch_args ) def check ( arguments , wrong = operator . ne , msg = <str> ) :          if wrong ( len ( arguments ) , len ( dispatch_args ) ) :              raise TypeError ( <str> % ( len ( dispatch_args ) , len ( arguments ) , msg ) )   def gen_func_dec ( func ) :          argset = set ( getfullargspec ( func ) . args ) if not set ( dispatch_args ) <= argset :              raise NameError ( <str> % dispatch_str )  typemap = { } def vancestors ( * types ) :              check ( types ) ras = [ [ ] for _ in range ( len ( dispatch_args ) ) ] for types_ in typemap :                  for t , type_ , ra in zip ( types , types_ , ras ) :                      if issubclass ( t , type_ ) and type_ not in t . mro ( ) :                          append ( type_ , ra )    return [ set ( ra ) for ra in ras ]  def ancestors ( * types ) :              check ( types ) lists = [ ] for t , vas in zip ( types , vancestors ( * types ) ) :                  n_vas = len ( vas ) if n_vas > 1 :                      raise RuntimeError ( <str> % ( t , vas ) )  elif n_vas == 1 :                      va , = vas mro = type ( <str> , ( t , va ) , { } ) . mro ( ) [ 1 : ]  else :                      mro = t . mro ( )  lists . append ( mro [ : - 1 ] )  return lists  def register ( * types ) :              check ( types ) def dec ( f ) :                  check ( getfullargspec ( f ) . args , operator . lt , <str> + f . __name__ ) typemap [ types ] = f return f  return dec  def dispatch_info ( * types ) :              check ( types ) lst = [ ] for anc in itertools . product ( * ancestors ( * types ) ) :                  lst . append ( tuple ( a . __name__ for a in anc ) )  return lst  def _dispatch ( dispatch_args , * args , ** kw ) :              types = tuple ( type ( arg ) for arg in dispatch_args ) try :                  f = typemap [ types ]  except KeyError :                  pass  else :                  return f ( * args , ** kw )  combinations = itertools . product ( * ancestors ( * types ) ) next ( combinations ) for types_ in combinations :                  f = typemap . get ( types_ ) if f is not None :                      return f ( * args , ** kw )   return func ( * args , ** kw )  return FunctionMaker . create ( func , <str> % dispatch_str , dict ( _f_ = _dispatch ) , register = register , default = func , typemap = typemap , vancestors = vancestors , ancestors = ancestors , dispatch_info = dispatch_info , __wrapped__ = func )  gen_func_dec . __name__ = <str> + dispatch_str return gen_func_dec   