import os import sys import socket import inspect import copy import json import time import traceback import platform import re try :      from collections import OrderedDict  except ImportError :      from ordereddict import OrderedDict  try :      from collections . abc import Mapping  except :      from collections import Mapping  import robot . utils . encoding robot . utils . encoding . OUTPUT_ENCODING = <str> from robot . libraries . BuiltIn import BuiltIn from robot . errors import HandlerExecutionFailed , UserKeywordExecutionFailed from robot import version from robot . parsing . populators import READERS from robot . running import EXECUTION_CONTEXTS def _is_logged ( level ) :      current = EXECUTION_CONTEXTS . current if current is None :          return True  out = current . output if out is None :          return True  return out . _xmllogger . _log_message_is_logged ( level )  def _fix_unicode ( max_length , data ) :      if sys . version_info < ( 3 , 0 , 0 ) and isinstance ( data , unicode ) :          return _truncate ( max_length , data . encode ( <str> ) )  elif sys . version_info < ( 3 , 0 , 0 ) and isinstance ( data , basestring ) :          return _truncate ( max_length , data . encode ( <str> ) )  elif sys . version_info >= ( 3 , 0 , 0 ) and isinstance ( data , str ) :          return _truncate ( max_length , data )  elif isinstance ( data , OrderedDict ) :          return OrderedDict ( ( _fix_unicode ( max_length , k ) , _fix_unicode ( max_length , data [ k ] ) ) for k in data )  elif isinstance ( data , Mapping ) :          return dict ( ( _fix_unicode ( max_length , k ) , _fix_unicode ( max_length , data [ k ] ) ) for k in data )  elif isinstance ( data , tuple ) :          return tuple ( list ( _fix_unicode ( max_length , el ) for el in data ) )  elif isinstance ( data , list ) :          return list ( _fix_unicode ( max_length , el ) for el in data )  elif data is None :          return _fix_unicode ( max_length , <str> )  else :          return _fix_unicode ( max_length , str ( data ) )   def _truncate ( max_length , s ) :      return s [ : max_length ] + <str> if len ( s ) > max_length else s  def _label_with_types ( data ) :      value_type = type ( data ) . __name__ if isinstance ( data , Mapping ) :          return ( value_type , dict ( ( k , _label_with_types ( data [ k ] ) ) for k in data ) )  elif isinstance ( data , list ) :          return ( value_type , list ( _label_with_types ( el ) for el in data ) )  elif isinstance ( data , tuple ) :          return ( value_type , tuple ( list ( _label_with_types ( el ) for el in data ) ) )  else :          return ( value_type , data )   def _extract_source_path ( source ) :      if <str> in source :          source = source [ source . index ( <str> ) + 5 : ]  if <str> in source . lower ( ) :          source = _modify_source_path_for_jar_files ( source , <str> )  elif <str> in source . lower ( ) :          source = _modify_source_path_for_jar_files ( source , <str> )  elif <str> in source . lower ( ) :          source = _modify_source_path_for_jar_files ( source , <str> )  elif source . endswith ( <str> ) :          source = source [ : - 1 ]  elif source . endswith ( <str> ) :          source = source [ : - 9 ] + <str>  return source  def _modify_source_path_for_jar_files ( source , jar_part ) :      jar_part_index = source . lower ( ) . rindex ( jar_part ) jar_extension = source [ jar_part_index : jar_part_index + 4 ] return source [ : jar_part_index ] + jar_extension  def _collect_children_paths ( suites , source ) :      child_paths = [ ] if os . path . isdir ( source ) :          cache = _prepare_names_dictionary_slow_py2 ( source ) if sys . version_info < ( 3 , 5 , 0 ) else _prepare_names_dictionary ( source ) for suite in suites :              candidates = cache [ suite ] if suite in cache else [ ] child_paths . append ( candidates . pop ( 0 ) if len ( candidates ) > 0 else None )   return child_paths  def _prepare_names_dictionary ( parent_dir ) :      d = { } with os . scandir ( parent_dir ) as iter :          for entry in iter :              entry_name = None if entry . is_file ( ) and _has_suite_extension ( entry . name ) :                  ( entry_name , _ ) = os . path . splitext ( entry . name )  elif entry . is_dir ( ) :                  entry_name = entry . name  if entry_name != None :                  formatted = _format_file_name ( entry_name ) if formatted not in d :                      d [ formatted ] = [ ]  d [ formatted ] . append ( ( entry . name , os . path . join ( parent_dir , entry . name ) ) )    fst = lambda x : x [ 0 ] snd = lambda x : x [ 1 ] return { formatted_name : list ( map ( snd , sorted ( entries , key = fst ) ) ) for ( formatted_name , entries ) in d . items ( ) }  def _prepare_names_dictionary_slow_py2 ( parent_dir ) :      d = { } for entry in os . listdir ( parent_dir ) :          entry_name = None if os . path . isfile ( os . path . join ( parent_dir , entry ) ) and _has_suite_extension ( entry ) :              ( entry_name , _ ) = os . path . splitext ( entry )  elif os . path . isdir ( os . path . join ( parent_dir , entry ) ) :              entry_name = entry  if entry_name != None :              formatted = _format_file_name ( entry_name ) if formatted not in d :                  d [ formatted ] = [ ]  d [ formatted ] . append ( ( entry , os . path . join ( parent_dir , entry ) ) )   fst = lambda x : x [ 0 ] snd = lambda x : x [ 1 ] return { formatted_name : list ( map ( snd , sorted ( entries , key = fst ) ) ) for ( formatted_name , entries ) in d . items ( ) }  def _has_suite_extension ( name ) :      valid_exts = tuple ( READERS ) ( _ , ext ) = os . path . splitext ( name ) return ext [ 1 : ] in valid_exts  def _format_file_name ( name ) :      name = name . split ( <str> , 1 ) [ - 1 ] name = name . replace ( <str> , <str> ) . strip ( ) return name . title ( ) if name . islower ( ) else name  class RedResponseMessage :      DO_START = <str> OPERATING_MODE = <str> PROTOCOL_VERSION = <str> TERMINATE = <str> INTERRUPT = <str> DISCONNECT = <str> CONTINUE = <str> PAUSE = <str> RESUME = <str> EVALUATE_CONDITION = <str> GET_VARIABLES = <str> CHANGE_VARIABLE = <str>  class AgentEventMessage :      AGENT_INITIALIZING = <str> READY_TO_START = <str> VERSION = <str> START_SUITE = <str> END_SUITE = <str> START_TEST = <str> END_TEST = <str> PRE_START_KEYWORD = <str> START_KEYWORD = <str> PRE_END_KEYWORD = <str> END_KEYWORD = <str> SHOULD_CONTINUE = <str> CONDITION_RESULT = <str> VARIABLES = <str> PAUSED = <str> RESUMED = <str> RESOURCE_IMPORT = <str> LIBRARY_IMPORT = <str> MESSAGE = <str> LOG_MESSAGE = <str> LOG_FILE = <str> REPORT_FILE = <str> OUTPUT_FILE = <str> CLOSE = <str>  class AgentMode :      RUN = <str> DEBUG = <str>  class PausingPoint :      PRE_START_KEYWORD = <str> START_KEYWORD = <str> PRE_END_KEYWORD = <str> END_KEYWORD = <str>  class TestRunnerAgent :      ROBOT_LISTENER_API_VERSION = 2 CONNECTION_SLEEP_BETWEEN_TRIALS = 2 RED_AGENT_PROTOCOL_VERSION = 3 MAX_VARIABLE_VALUE_TEXT_LENGTH = 2048 def __init__ ( self , * args ) :          if len ( args ) == 1 :              host , port , connection_timeout = <str> , int ( args [ 0 ] ) , 30  elif len ( args ) == 2 :              host , port , connection_timeout = args [ 0 ] , int ( args [ 1 ] ) , 30  else :              host , port , connection_timeout = args [ 0 ] , int ( args [ 1 ] ) , int ( args [ 2 ] )  self . _last_pause_check = time . time ( ) self . _is_connected , self . sock , self . decoder_encoder = self . _connect ( host , port , connection_timeout ) if self . _is_connected :              self . _handshake ( ) self . _built_in = BuiltIn ( )  else :              self . _mode = None   def _handshake ( self ) :          self . _send_to_server ( AgentEventMessage . AGENT_INITIALIZING ) self . _mode , wait_for_signal = self . _receive_operating_mode ( ) self . _send_version ( ) _ , response = self . _wait_for_reponse ( RedResponseMessage . PROTOCOL_VERSION ) is_correct = response [ RedResponseMessage . PROTOCOL_VERSION ] [ <str> ] error = response [ RedResponseMessage . PROTOCOL_VERSION ] [ <str> ] if is_correct and wait_for_signal :              self . _send_to_server ( AgentEventMessage . READY_TO_START ) self . _wait_for_reponse ( RedResponseMessage . DO_START )  elif not is_correct :              self . _close_connection ( ) self . _print_error_message ( error + <str> )   def _receive_operating_mode ( self ) :          _ , response = self . _wait_for_reponse ( RedResponseMessage . OPERATING_MODE ) operating_mode = response [ RedResponseMessage . OPERATING_MODE ] return operating_mode [ <str> ] . lower ( ) , operating_mode [ <str> ]  def _send_version ( self ) :          robot_version = <str> + version . get_full_version ( ) info = { <str> : <str> . join ( self . _get_command_line ( ) ) , <str> : sys . version , <str> : robot_version , <str> : self . RED_AGENT_PROTOCOL_VERSION , <str> : os . getpid ( ) } self . _send_to_server ( AgentEventMessage . VERSION , info )  def _get_command_line ( self ) :          if sys . version_info [ 0 ] > 2 or os . name != <str> :              return sys . argv  from ctypes import WINFUNCTYPE , windll , POINTER , byref , c_int from ctypes . wintypes import LPWSTR , LPCWSTR GetCommandLineW = WINFUNCTYPE ( LPWSTR ) ( ( <str> , windll . kernel32 ) ) CommandLineToArgvW = WINFUNCTYPE ( POINTER ( LPWSTR ) , LPCWSTR , POINTER ( c_int ) ) ( ( <str> , windll . shell32 ) ) argc = c_int ( 0 ) argv_unicode = CommandLineToArgvW ( GetCommandLineW ( ) , byref ( argc ) ) return [ argv_unicode [ i ] . encode ( <str> ) for i in range ( 0 , argc . value ) ]  def start_suite ( self , name , attrs ) :          attrs_copy = copy . copy ( attrs ) del attrs_copy [ <str> ] attrs_copy [ <str> ] = os . path . isdir ( attrs [ <str> ] ) attrs_copy [ <str> ] = _collect_children_paths ( attrs [ <str> ] , attrs [ <str> ] ) attrs_copy [ <str> ] = self . _is_rpa_mode ( ) self . _send_to_server ( AgentEventMessage . START_SUITE , name , attrs_copy )  def _is_rpa_mode ( self ) :          try :              return self . _built_in . _context . output . _settings [ <str> ]  except :              return False   def end_suite ( self , name , attrs ) :          attrs_copy = copy . copy ( attrs ) del attrs_copy [ <str> ] attrs_copy [ <str> ] = os . path . isdir ( attrs [ <str> ] ) self . _send_to_server ( AgentEventMessage . END_SUITE , name , attrs_copy )  def start_test ( self , name , attrs ) :          attrs_copy = copy . copy ( attrs ) del attrs_copy [ <str> ] self . _send_to_server ( AgentEventMessage . START_TEST , name , attrs_copy )  def end_test ( self , name , attrs ) :          attrs_copy = copy . copy ( attrs ) del attrs_copy [ <str> ] self . _send_to_server ( AgentEventMessage . END_TEST , name , attrs_copy )  def start_keyword ( self , name , attrs ) :          if not self . _is_connected :              return  attrs_copy = copy . copy ( attrs ) del attrs_copy [ <str> ] del attrs_copy [ <str> ] del attrs_copy [ <str> ] json_obj = self . _encode_to_json ( ( name , attrs_copy ) ) if self . _mode == AgentMode . DEBUG :              self . _send_to_server_json ( AgentEventMessage . PRE_START_KEYWORD , json_obj ) if self . _should_pause ( PausingPoint . PRE_START_KEYWORD ) :                  self . _wait_for_resume ( )   self . _send_to_server_json ( AgentEventMessage . START_KEYWORD , json_obj ) if self . _should_ask_for_pause_on_start ( ) :              if self . _should_pause ( PausingPoint . START_KEYWORD ) :                  self . _wait_for_resume ( )    def _should_ask_for_pause_on_start ( self ) :          if not self . _is_connected :              return False  elif self . _mode == AgentMode . RUN :              current_time = time . time ( ) if current_time - self . _last_pause_check > 2 :                  self . _last_pause_check = current_time return True  else :                  return False   else :              return True   def end_keyword ( self , name , attrs ) :          if not self . _is_connected :              return  attrs_copy = copy . copy ( attrs ) del attrs_copy [ <str> ] del attrs_copy [ <str> ] del attrs_copy [ <str> ] json_obj = self . _encode_to_json ( ( name , attrs_copy ) ) if self . _mode == AgentMode . DEBUG :              self . _send_to_server_json ( AgentEventMessage . PRE_END_KEYWORD , json_obj ) if self . _should_pause ( PausingPoint . PRE_END_KEYWORD ) :                  self . _wait_for_resume ( )   self . _send_to_server_json ( AgentEventMessage . END_KEYWORD , json_obj ) if self . _should_ask_for_pause_on_end ( ) :              if self . _should_pause ( PausingPoint . END_KEYWORD ) :                  self . _wait_for_resume ( )    def _should_ask_for_pause_on_end ( self ) :          return self . _is_connected and self . _mode == AgentMode . DEBUG  def _should_pause ( self , pausing_point ) :          self . _send_to_server ( AgentEventMessage . SHOULD_CONTINUE , { <str> : pausing_point } ) possible_responses = [ RedResponseMessage . CONTINUE , RedResponseMessage . PAUSE , RedResponseMessage . TERMINATE , RedResponseMessage . INTERRUPT , RedResponseMessage . DISCONNECT ] if self . _mode == AgentMode . DEBUG and pausing_point in [ PausingPoint . PRE_START_KEYWORD , PausingPoint . PRE_END_KEYWORD ] :              possible_responses . append ( RedResponseMessage . EVALUATE_CONDITION )  response_name , response = self . _wait_for_reponse ( * possible_responses ) while True :              if response_name == RedResponseMessage . TERMINATE :                  sys . exit ( )  elif response_name == RedResponseMessage . INTERRUPT :                  self . _interrupt ( ) return False  elif response_name == RedResponseMessage . DISCONNECT :                  self . _close_connection ( ) return False  elif response_name == RedResponseMessage . CONTINUE :                  return False  elif response_name == RedResponseMessage . PAUSE :                  return True  elif response_name == RedResponseMessage . EVALUATE_CONDITION :                  return self . _evaluate_condition ( response )    def _interrupt ( self ) :          import signal from robot . running import signalhandler signalhandler . STOP_SIGNAL_MONITOR ( signal . SIGINT , None )  def _evaluate_condition ( self , condition ) :          robot_version_str = robot . version . get_version ( True ) robot_version = tuple ( [ int ( num ) for num in re . split ( <str> , robot_version_str ) ] ) evaluator = self . _evaluate_condition_old_style if robot_version < ( 3 , 0 , 3 ) else self . _evaluate_condition_new_style elements = condition [ RedResponseMessage . EVALUATE_CONDITION ] keywordName , argList = elements [ 0 ] , elements [ 1 : ] return evaluator ( keywordName , argList )  def _evaluate_condition_old_style ( self , keywordName , argList ) :          try :              result = self . _built_in . run_keyword_and_return_status ( keywordName , * argList ) self . _send_to_server ( AgentEventMessage . CONDITION_RESULT , { <str> : result } ) return result  except Exception as e :              msg = <str> + str ( e ) self . _send_to_server ( AgentEventMessage . CONDITION_RESULT , { <str> : msg } ) return True   def _evaluate_condition_new_style ( self , keywordName , argList ) :          try :              self . _built_in . run_keyword ( keywordName , * argList ) self . _send_to_server ( AgentEventMessage . CONDITION_RESULT , { <str> : True } ) return True  except ( HandlerExecutionFailed , UserKeywordExecutionFailed ) as e :              self . _send_to_server ( AgentEventMessage . CONDITION_RESULT , { <str> : False } ) return False  except Exception as e :              msg = <str> + str ( e ) self . _send_to_server ( AgentEventMessage . CONDITION_RESULT , { <str> : msg } ) return True   def _wait_for_resume ( self ) :          if not self . _is_connected :              return  possible_responses = [ RedResponseMessage . RESUME , RedResponseMessage . TERMINATE , RedResponseMessage . INTERRUPT , RedResponseMessage . DISCONNECT ] if self . _mode == AgentMode . DEBUG :              possible_responses . append ( RedResponseMessage . CHANGE_VARIABLE )  self . _send_variables ( ) while True :              self . _send_to_server ( AgentEventMessage . PAUSED ) response_name , response = self . _wait_for_reponse ( * possible_responses ) if response_name == RedResponseMessage . RESUME :                  self . _send_to_server ( AgentEventMessage . RESUMED ) return  elif response_name == RedResponseMessage . TERMINATE :                  sys . exit ( )  elif response_name == RedResponseMessage . INTERRUPT :                  self . _send_to_server ( AgentEventMessage . RESUMED ) self . _interrupt ( ) return  elif response_name == RedResponseMessage . DISCONNECT :                  self . _close_connection ( ) return  elif response_name == RedResponseMessage . CHANGE_VARIABLE :                  try :                      self . _change_variable_value ( response ) self . _send_variables ( )  except ValueError as e :                      self . _print_error_message ( str ( e ) ) self . _send_variables ( str ( e ) )     def _change_variable_value ( self , response ) :          try :              arguments = response [ RedResponseMessage . CHANGE_VARIABLE ] var_name = arguments [ <str> ] scope = arguments [ <str> ] if scope not in [ <str> , <str> , <str> , <str> ] :                  raise ValueError ( <str> + var_name + <str> + str ( scope ) )  new_values = arguments [ <str> ] level = arguments [ <str> ] + 1 if <str> in arguments :                  self . _change_variable_inner_value ( var_name , level , arguments [ <str> ] , new_values )  else :                  self . _change_variable_on_top_level ( var_name , scope , level , new_values )   except Exception as e :              raise ValueError ( <str> + var_name + <str> + str ( e ) )   def _change_variable_on_top_level ( self , var_name , scope , level , new_values ) :          if scope == <str> :              name = self . _built_in . _get_var_name ( var_name ) value = self . _built_in . _get_var_value ( name , new_values ) self . _built_in . _variables . _scopes [ level ] [ name ] = value self . _built_in . _log_set_variable ( name , value )  elif scope == <str> :              self . _built_in . set_test_variable ( var_name , * new_values )  elif scope == <str> :              if level >= len ( self . _built_in . _variables . _scopes ) - len ( list ( self . _built_in . _variables . _scopes_until_suite ) ) :                  self . _built_in . set_suite_variable ( var_name , * new_values )  else :                  name = self . _built_in . _get_var_name ( var_name ) value = self . _built_in . _get_var_value ( name , new_values ) self . _built_in . _variables . _scopes [ level ] [ name ] = value self . _built_in . _variables . _variables_set . _scopes [ level - 1 ] [ name ] = value self . _built_in . _log_set_variable ( name , value )   else :              self . _built_in . set_global_variable ( var_name , * new_values )   def _change_variable_inner_value ( self , name , level , path , new_values ) :          types = { <str> : <str> , <str> : <str> , <str> : <str> } value = self . _built_in . _get_var_value ( types [ path [ - 1 ] [ 0 ] ] + <str> , new_values ) old_value = self . _built_in . _variables . _scopes [ level ] . as_dict ( ) [ name ] self . _change_inner_value ( old_value , path [ : - 1 ] , value )  def _change_inner_value ( self , object , path , value ) :          val_kind , addr = path [ 0 ] if val_kind == <str> and isinstance ( object , ( list , tuple ) ) or val_kind == <str> and isinstance ( object , Mapping ) :              if len ( path ) == 1 :                  object [ addr ] = value  else :                  self . _change_inner_value ( object [ addr ] , path [ 1 : ] , value )   else :              raise RuntimeError ( <str> + val_kind + <str> + type ( object ) . __name__ + <str> )   def _send_variables ( self , error = None ) :          vars = self . _collect_variables ( ) if error :              self . _send_to_server ( AgentEventMessage . VARIABLES , { <str> : vars , <str> : error } )  else :              self . _send_to_server ( AgentEventMessage . VARIABLES , { <str> : vars } )   def _collect_variables ( self ) :          variables = self . _built_in . _variables frames = variables . _scopes all_frames = [ ] i = 0 last_suite_index = frames . index ( variables . _suite ) test_index = frames . index ( variables . _test ) if variables . _test else - 1 for current_frame in frames :              current_frame_values = { } frame_vars = OrderedDict ( ) for variable in current_frame . store :                  value = current_frame . store [ variable ] var , _ = current_frame . store . _decorate ( variable , value ) if i == 0 :                      identified_scope = <str>  elif var in previous_frame_values and value == previous_frame_values [ var ] [ 1 ] :                      identified_scope = previous_frame_values [ var ] [ 0 ]  elif i <= last_suite_index :                      identified_scope = <str>  elif i == test_index :                      identified_scope = <str> if <str> + var [ 1 : ] in variables . _variables_set . _test else <str>  else :                      identified_scope = <str>  if inspect . ismodule ( value ) or inspect . isfunction ( value ) or inspect . isclass ( value ) :                      type_name = type ( value ) . __name__ frame_vars [ var ] = ( type_name , type_name + <str> + str ( id ( value ) ) , identified_scope )  else :                      try :                          labeled = _label_with_types ( value ) fixed = _fix_unicode ( self . MAX_VARIABLE_VALUE_TEXT_LENGTH , labeled ) if isinstance ( value , ( list , tuple , Mapping ) ) :                              frame_vars [ var ] = ( fixed [ 0 ] , fixed [ 1 ] , identified_scope )  else :                              frame_vars [ var ] = ( fixed [ 0 ] , str ( fixed [ 1 ] ) , identified_scope )   except :                          frame_vars [ var ] = ( type ( value ) . __name__ , <str> , identified_scope )   current_frame_values [ var ] = ( identified_scope , value )  all_frames . append ( frame_vars ) previous_frame_values = current_frame_values i += 1  all_frames . reverse ( ) return all_frames  def resource_import ( self , name , attributes ) :          self . _send_to_server ( AgentEventMessage . RESOURCE_IMPORT , name , attributes )  def library_import ( self , name , attributes ) :          if <str> in platform . python_implementation ( ) :              attributes [ <str> ] = self . _find_jar_source_path ( attributes [ <str> ] , name )  if attributes [ <str> ] :              attributes [ <str> ] = _extract_source_path ( attributes [ <str> ] )  self . _send_to_server ( AgentEventMessage . LIBRARY_IMPORT , name , attributes )  def _find_jar_source_path ( self , source , name ) :          try :              import org . python . core . imp as jimp if not source :                  res = name + <str> return jimp . getSyspathJavaLoader ( ) . getResource ( res ) . getPath ( )  elif <str> in source :                  res = source [ source . index ( <str> ) + 16 : ] return jimp . getSyspathJavaLoader ( ) . getResource ( res ) . getPath ( )   except :              pass  return source  def message ( self , message ) :          if message [ <str> ] in ( <str> , <str> , <str> ) :              self . _send_to_server ( AgentEventMessage . MESSAGE , message )   def log_message ( self , message ) :          if _is_logged ( message [ <str> ] ) :              message [ <str> ] = _truncate ( self . MAX_VARIABLE_VALUE_TEXT_LENGTH , message [ <str> ] ) self . _send_to_server ( AgentEventMessage . LOG_MESSAGE , message )   def log_file ( self , path ) :          self . _send_to_server ( AgentEventMessage . LOG_FILE , path )  def output_file ( self , path ) :          self . _send_to_server ( AgentEventMessage . OUTPUT_FILE , path )  def report_file ( self , path ) :          self . _send_to_server ( AgentEventMessage . REPORT_FILE , path )  def summary_file ( self , path ) :          pass  def debug_file ( self , path ) :          pass  def close ( self ) :          self . _send_to_server ( AgentEventMessage . CLOSE ) self . _close_connection ( )  def _print_error_message ( self , message ) :          sys . stderr . write ( <str> + message + <str> ) sys . stderr . flush ( )  def _connect ( self , host , port , connection_timeout ) :          trials = 1 start = time . time ( ) while int ( time . time ( ) - start ) < connection_timeout :              sock = None try :                  sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) sock . connect ( ( host , port ) ) return True , sock , MessagesDecoderEncoder ( sock )  except socket . error as e :                  print ( <str> % trials ) print ( <str> % ( host , port ) ) print ( <str> % str ( e ) ) time . sleep ( self . CONNECTION_SLEEP_BETWEEN_TRIALS )  trials += 1  return False , None , None  def _encode_to_json ( self , obj ) :          try :              if self . decoder_encoder :                  return self . decoder_encoder . _encode ( obj )   except Exception :              traceback . print_exc ( file = sys . stdout ) sys . stdout . flush ( ) raise   def _send_to_server ( self , name , * args ) :          try :              if self . decoder_encoder :                  packet = { name : args } self . decoder_encoder . dump ( packet )   except Exception :              traceback . print_exc ( file = sys . stdout ) sys . stdout . flush ( ) raise   def _send_to_server_json ( self , name , json_encoded_obj ) :          try :              if self . decoder_encoder :                  self . decoder_encoder . _write ( <str> % ( name , json_encoded_obj ) )   except Exception :              traceback . print_exc ( file = sys . stdout ) sys . stdout . flush ( ) raise   def _wait_for_reponse ( self , * expected_responses ) :          response = self . _receive_from_server ( ) response_key = next ( iter ( response ) ) while not response_key in expected_responses :              response = self . _receive_from_server ( )  return response_key , response  def _receive_from_server ( self ) :          try :              if self . decoder_encoder :                  return self . decoder_encoder . load ( )   except Exception :              traceback . print_exc ( file = sys . stdout ) sys . stdout . flush ( ) raise   def _close_connection ( self ) :          if self . _is_connected :              self . _mode = None self . _is_connected = False self . decoder_encoder . close ( ) self . decoder_encoder = None self . sock . close ( ) self . sock = None    class MessagesDecoderEncoder ( object ) :      def __init__ ( self , sock ) :          self . _string_encoder = ( lambda s : s ) if sys . version_info < ( 3 , 0 , 0 ) else ( lambda s : bytes ( s , <str> ) ) self . _string_decoder = ( lambda s : s ) if sys . version_info < ( 3 , 0 , 0 ) else ( lambda s : str ( s , <str> ) ) self . _json_encoder = json . JSONEncoder ( separators = ( <str> , <str> ) , sort_keys = True ) . encode self . _json_decoder = json . JSONDecoder ( strict = False ) . decode self . _file_to_write = sock . makefile ( <str> ) self . _file_to_read = sock . makefile ( <str> )  def _encode ( self , obj ) :          return self . _json_encoder ( obj )  def dump ( self , obj ) :          self . _write ( self . _json_encoder ( obj ) )  def _write ( self , json_encoded_obj ) :          if not self . _can_write ( ) :              return  json_string = json_encoded_obj + <str> self . _file_to_write . write ( self . _string_encoder ( json_string ) ) self . _file_to_write . flush ( )  def load ( self ) :          if not self . _can_read ( ) :              return  json_string = self . _file_to_read . readline ( ) ; return self . _json_decoder ( self . _string_decoder ( json_string ) )  def _can_write ( self ) :          return self . _file_to_write is not None  def _can_read ( self ) :          return self . _file_to_read is not None  def close ( self ) :          if self . _can_write ( ) :              self . _file_to_write . close ( )  if self . _can_read ( ) :              self . _file_to_read . close ( )      