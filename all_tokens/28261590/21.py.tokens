import warnings warnings . simplefilter ( action = <str> , category = RuntimeWarning ) warnings . simplefilter ( action = <str> , category = PendingDeprecationWarning ) import argparse from hicmatrix import HiCMatrix as hm from hicexplorer . _version import __version__ import logging log = logging . getLogger ( __name__ ) import numpy as np from scipy . sparse import csr_matrix , save_npz , lil_matrix def parse_arguments ( args = None ) :      parser = argparse . ArgumentParser ( formatter_class = argparse . RawDescriptionHelpFormatter , add_help = False , description = ) parserRequired = parser . add_argument_group ( <str> ) parserRequired . add_argument ( <str> , <str> , help = <str> , required = True ) parserRequired . add_argument ( <str> , <str> , help = <str> , required = True ) parserMutuallyExclusiveGroup = parser . add_mutually_exclusive_group ( required = True ) parserMutuallyExclusiveGroup . add_argument ( <str> , <str> , help = <str> , nargs = 2 , type = int ) parserMutuallyExclusiveGroup . add_argument ( <str> , <str> , help = <str> , nargs = 2 , type = int ) parserRequired . add_argument ( <str> , <str> , help = <str> , required = True ) parserOpt = parser . add_argument_group ( <str> ) parserOpt . add_argument ( <str> , <str> , action = <str> , help = <str> ) parserOpt . add_argument ( <str> , <str> , help = <str> <str> , choices = [ <str> , <str> , <str> ] , default = <str> ) parserOpt . add_argument ( <str> , action = <str> , version = <str> . format ( __version__ ) ) return parser  def calculateViewpointRange ( pHiCMatrix , pViewpoint , pRange , pCoordinatesToBinMapping ) :      start_out_of_range = False end_out_of_range = False max_length = pHiCMatrix . getBinPos ( pHiCMatrix . getChrBinRange ( pViewpoint [ 0 ] ) [ 1 ] - 1 ) [ 2 ] if pCoordinatesToBinMapping == <str> :          region_start = int ( pViewpoint [ 1 ] ) - pRange [ 0 ] region_end = int ( pViewpoint [ 1 ] ) + pRange [ 1 ]  elif pCoordinatesToBinMapping == <str> :          region_start = int ( pViewpoint [ 2 ] ) - pRange [ 0 ] region_end = int ( pViewpoint [ 2 ] ) + pRange [ 1 ]  elif pCoordinatesToBinMapping == <str> :          viewpoint_center_value = int ( float ( pViewpoint [ 1 ] ) + ( ( float ( pViewpoint [ 2 ] ) - float ( pViewpoint [ 1 ] ) ) / 2 ) ) region_start = viewpoint_center_value - pRange [ 0 ] region_end = viewpoint_center_value + pRange [ 1 ]  if region_start < 0 :          region_start = 0 start_out_of_range = True  if region_end > max_length :          region_end = max_length - 1 end_out_of_range = True  return region_start , region_end , start_out_of_range , end_out_of_range  def getBinIndices ( pHiCMatrix , pViewpoint ) :      return pHiCMatrix . getRegionBinRange ( pViewpoint [ 0 ] , pViewpoint [ 1 ] , pViewpoint [ 2 ] )  def calculateViewpointRangeBins ( pHiCMatrix , pViewpoint , pRange , pCoordinatesToBinMapping ) :      start_out_of_range = False end_out_of_range = False if pCoordinatesToBinMapping == <str> :          viewpoint_index = getBinIndices ( pHiCMatrix , pViewpoint ) [ 0 ]  elif pCoordinatesToBinMapping == <str> :          viewpoint_index = getBinIndices ( pHiCMatrix , pViewpoint ) [ 1 ]  else :          viewpoint_center_value = int ( float ( pViewpoint [ 1 ] ) + ( ( float ( pViewpoint [ 2 ] ) - float ( pViewpoint [ 1 ] ) ) / 2 ) ) viewpoint_center = [ pViewpoint [ 0 ] , viewpoint_center_value , viewpoint_center_value ] viewpoint_index = getBinIndices ( pHiCMatrix , viewpoint_center ) [ 1 ]  first_bin , last_bin = pHiCMatrix . getChrBinRange ( pViewpoint [ 0 ] ) start = viewpoint_index - pRange [ 0 ] end = viewpoint_index + pRange [ 1 ] if start < first_bin :          start = first_bin start_out_of_range = True  if end > last_bin :          end = last_bin end_out_of_range = True  return start , end , start_out_of_range , end_out_of_range  def main ( args = None ) :      args = parse_arguments ( ) . parse_args ( args ) hic_ma = hm . hiCMatrix ( pMatrixFile = args . matrix ) indices_values = [ ] with open ( args . regions , <str> ) as file :          for line in file . readlines ( ) :              _line = line . strip ( ) . split ( <str> ) if len ( line ) == 0 :                  continue  if len ( _line ) == 2 :                  chrom , start = _line [ 0 ] , _line [ 1 ] viewpoint = ( chrom , start , start )  elif len ( _line ) >= 3 :                  chrom , start , end = _line [ 0 ] , _line [ 1 ] , _line [ 2 ] viewpoint = ( chrom , start , end )  if args . range :                  start_range_genomic , end_range_genomic , start_out , end_out = calculateViewpointRange ( hic_ma , viewpoint , args . range , args . coordinatesToBinMapping ) start_bin , end_bin = getBinIndices ( hic_ma , ( chrom , start_range_genomic , end_range_genomic ) )  else :                  start_bin , end_bin , start_out , end_out = calculateViewpointRangeBins ( hic_ma , viewpoint , args . rangeInBins , args . coordinatesToBinMapping )  indices_values . append ( [ start_bin , end_bin , start_out , end_out ] )   if args . range :          dimensions_new_matrix = ( args . range [ 0 ] // hic_ma . getBinSize ( ) ) + ( args . range [ 1 ] // hic_ma . getBinSize ( ) )  elif args . rangeInBins :          dimensions_new_matrix = args . rangeInBins [ 0 ] + args . rangeInBins [ 1 ]  summed_matrix = lil_matrix ( ( dimensions_new_matrix , dimensions_new_matrix ) , dtype = np . float32 ) count_matrix = np . zeros ( shape = ( dimensions_new_matrix , dimensions_new_matrix ) ) for start , end , start_out , end_out in indices_values :          _start = 0 _end = summed_matrix . shape [ 1 ] orig_matrix_length = end - start if start_out :              _start = _end - orig_matrix_length  if end_out :              _end = start + orig_matrix_length  count_matrix [ _start : _end , _start : _end ] += 1 summed_matrix [ _start : _end , _start : _end ] += hic_ma . matrix [ start : end , start : end ]  summed_matrix /= count_matrix summed_matrix = np . array ( summed_matrix ) data = summed_matrix [ np . nonzero ( summed_matrix ) ] row = np . nonzero ( summed_matrix ) [ 0 ] col = np . nonzero ( summed_matrix ) [ 1 ] summed_matrix = csr_matrix ( ( data , ( row , col ) ) , shape = ( dimensions_new_matrix , dimensions_new_matrix ) ) save_npz ( args . outFileName , summed_matrix )   