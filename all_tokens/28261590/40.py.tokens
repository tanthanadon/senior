import argparse import sys import errno import os import math from multiprocessing import Process , Queue import time import logging log = logging . getLogger ( __name__ ) import numpy as np import matplotlib matplotlib . use ( <str> ) import matplotlib . pyplot as plt import matplotlib . gridspec as gridspec from intervaltree import IntervalTree , Interval import hicmatrix . HiCMatrix as hm from hicexplorer import utilities from hicexplorer . _version import __version__ from . lib import Viewpoint def parse_arguments ( args = None ) :      parser = argparse . ArgumentParser ( add_help = False , formatter_class = argparse . RawDescriptionHelpFormatter , description = ) parserRequired = parser . add_argument_group ( <str> ) parserRequired . add_argument ( <str> , <str> , help = <str> , required = True , nargs = <str> ) parserRequired . add_argument ( <str> , <str> , help = <str> , nargs = <str> ) parserOpt = parser . add_argument_group ( <str> ) parserOpt . add_argument ( <str> , <str> , help = <str> , required = False , default = <str> ) parserOpt . add_argument ( <str> , <str> , help = <str> , required = False , default = <str> ) parserOpt . add_argument ( <str> , <str> , help = <str> , required = False ) parserOpt . add_argument ( <str> , <str> , help = <str> , required = False , default = <str> ) parserOpt . add_argument ( <str> , <str> , help = <str> , default = <str> ) parserOpt . add_argument ( <str> , <str> , help = <str> , required = False , action = <str> ) parserOpt . add_argument ( <str> , <str> , help = <str> , required = False , default = 4 , type = int ) parserOpt . add_argument ( <str> , <str> , action = <str> , help = <str> ) parserOpt . add_argument ( <str> , action = <str> , version = <str> . format ( __version__ ) ) return parser  def filter_scores_target_list ( pScoresDictionary , pTargetList = None , pTargetIntervalTree = None ) :      accepted_scores = { } same_target_dict = { } target_regions_intervaltree = None if pTargetList is not None :          target_regions = utilities . readBed ( pTargetList ) if len ( target_regions ) == 0 :              return accepted_scores  hicmatrix = hm . hiCMatrix ( ) target_regions_intervaltree = hicmatrix . intervalListToIntervalTree ( target_regions ) [ 0 ]  elif pTargetIntervalTree is not None :          target_regions_intervaltree = pTargetIntervalTree  else :          log . error ( <str> ) exit ( 1 )  for key in pScoresDictionary :          chromosome = pScoresDictionary [ key ] [ 0 ] start = int ( pScoresDictionary [ key ] [ 1 ] ) end = int ( pScoresDictionary [ key ] [ 2 ] ) if chromosome in target_regions_intervaltree :              target_interval = target_regions_intervaltree [ chromosome ] [ start : end ]  else :              continue  if target_interval :              target_interval = sorted ( target_interval ) [ 0 ] if target_interval in same_target_dict :                  same_target_dict [ target_interval ] . append ( key )  else :                  same_target_dict [ target_interval ] = [ key ]    for target in same_target_dict :          values = np . array ( [ 0.0 , 0.0 , 0.0 ] ) same_target_dict [ target ] = sorted ( same_target_dict [ target ] ) for key in same_target_dict [ target ] :              values += np . array ( list ( map ( float , pScoresDictionary [ key ] [ - 3 : ] ) ) )  new_data_line = pScoresDictionary [ same_target_dict [ target ] [ 0 ] ] new_data_line [ 2 ] = pScoresDictionary [ same_target_dict [ target ] [ - 1 ] ] [ 2 ] new_data_line [ - 5 ] = pScoresDictionary [ same_target_dict [ target ] [ - 1 ] ] [ - 5 ] new_data_line [ - 3 ] = values [ 0 ] new_data_line [ - 2 ] = values [ 1 ] new_data_line [ - 1 ] = values [ 2 ] accepted_scores [ same_target_dict [ target ] [ 0 ] ] = new_data_line  return accepted_scores  def write ( pOutFileName , pHeader , pNeighborhoods , pInteractionLines ) :      with open ( pOutFileName , <str> ) as file :          file . write ( <str> . format ( __version__ ) ) file . write ( pHeader ) file . write ( <str> ) file . write ( <str> ) if pNeighborhoods is not None :              for data in pNeighborhoods :                  new_line = <str> . join ( pInteractionLines [ data ] [ : 6 ] ) new_line += <str> + format ( pNeighborhoods [ data ] [ - 1 ] , <str> ) new_line += <str> file . write ( new_line )     def run_target_list_compilation ( pInteractionFilesList , pTargetList , pArgs , pViewpointObj , pQueue = None ) :      outfile_names = [ ] target_regions_intervaltree = None if pArgs . batchMode and len ( pTargetList ) == 1 :          target_regions = utilities . readBed ( pTargetList [ 0 ] ) hicmatrix = hm . hiCMatrix ( ) target_regions_intervaltree = hicmatrix . intervalListToIntervalTree ( target_regions ) [ 0 ]  for i , interactionFile in enumerate ( pInteractionFilesList ) :          for sample in interactionFile :              if pArgs . interactionFileFolder != <str> :                  absolute_sample_path = pArgs . interactionFileFolder + <str> + sample  else :                  absolute_sample_path = sample  header , interaction_data , interaction_file_data = pViewpointObj . readInteractionFileForAggregateStatistics ( absolute_sample_path ) log . debug ( <str> . format ( len ( pTargetList ) ) ) if pArgs . batchMode and len ( pTargetList ) > 1 :                  if pArgs . targetFileFolder != <str> :                      target_file = pArgs . targetFileFolder + <str> + pTargetList [ i ]  else :                      target_file = pTargetList [ i ]   elif pArgs . batchMode and len ( pTargetList ) == 1 :                  target_file = None  else :                  target_file = pTargetList [ i ]  accepted_scores = filter_scores_target_list ( interaction_file_data , pTargetList = target_file , pTargetIntervalTree = target_regions_intervaltree ) if len ( accepted_scores ) == 0 :                  if pArgs . batchMode :                      with open ( <str> , <str> ) as errorlog :                          errorlog . write ( <str> . format ( interactionFile [ 0 ] , interactionFile [ 1 ] ) )   else :                      log . info ( <str> )   outFileName = <str> . join ( sample . split ( <str> ) [ - 1 ] . split ( <str> ) [ : - 1 ] ) + <str> + pArgs . outFileNameSuffix if pArgs . batchMode :                  outfile_names . append ( outFileName )  if pArgs . outputFolder != <str> :                  outFileName = pArgs . outputFolder + <str> + outFileName  write ( outFileName , header , accepted_scores , interaction_file_data )   if pQueue is None :          return  pQueue . put ( outfile_names ) return  def call_multi_core ( pInteractionFilesList , pTargetFileList , pFunctionName , pArgs , pViewpointObj ) :      outfile_names = [ None ] * pArgs . threads interactionFilesPerThread = len ( pInteractionFilesList ) // pArgs . threads all_data_collected = False queue = [ None ] * pArgs . threads process = [ None ] * pArgs . threads thread_done = [ False ] * pArgs . threads for i in range ( pArgs . threads ) :          if i < pArgs . threads - 1 :              interactionFileListThread = pInteractionFilesList [ i * interactionFilesPerThread : ( i + 1 ) * interactionFilesPerThread ] targetFileListThread = pTargetFileList [ i * interactionFilesPerThread : ( i + 1 ) * interactionFilesPerThread ]  else :              interactionFileListThread = pInteractionFilesList [ i * interactionFilesPerThread : ] targetFileListThread = pTargetFileList [ i * interactionFilesPerThread : ]  queue [ i ] = Queue ( ) process [ i ] = Process ( target = pFunctionName , kwargs = dict ( pInteractionFilesList = interactionFileListThread , pTargetList = targetFileListThread , pArgs = pArgs , pViewpointObj = pViewpointObj , pQueue = queue [ i ] ) ) process [ i ] . start ( )  while not all_data_collected :          for i in range ( pArgs . threads ) :              if queue [ i ] is not None and not queue [ i ] . empty ( ) :                  background_data_thread = queue [ i ] . get ( ) outfile_names [ i ] = background_data_thread queue [ i ] = None process [ i ] . join ( ) process [ i ] . terminate ( ) process [ i ] = None thread_done [ i ] = True   all_data_collected = True for thread in thread_done :              if not thread :                  all_data_collected = False   time . sleep ( 1 )  outfile_names = [ item for sublist in outfile_names for item in sublist ] return outfile_names  def main ( args = None ) :      args = parse_arguments ( ) . parse_args ( args ) viewpointObj = Viewpoint ( ) outfile_names = [ ] if not os . path . exists ( args . outputFolder ) :          try :              os . makedirs ( args . outputFolder )  except OSError as exc :              if exc . errno != errno . EEXIST :                  raise    interactionFileList = [ ] targetFileList = [ ] if args . batchMode :          with open ( args . interactionFile [ 0 ] , <str> ) as interactionFile :              file_ = True while file_ :                  file_ = interactionFile . readline ( ) . strip ( ) file2_ = interactionFile . readline ( ) . strip ( ) if file_ != <str> and file2_ != <str> :                      interactionFileList . append ( ( file_ , file2_ ) )    if len ( args . targetFile ) == 1 and args . targetFileFolder :              with open ( args . targetFile [ 0 ] , <str> ) as targetFile :                  file_ = True while file_ :                      file_ = targetFile . readline ( ) . strip ( ) if file_ != <str> :                          targetFileList . append ( file_ )     else :              targetFileList = args . targetFile  outfile_names = call_multi_core ( interactionFileList , targetFileList , run_target_list_compilation , args , viewpointObj )  else :          targetFileList = args . targetFile if len ( args . interactionFile ) % 2 == 0 :              i = 0 while i < len ( args . interactionFile ) :                  interactionFileList . append ( ( args . interactionFile [ i ] , args . interactionFile [ i + 1 ] ) ) i += 2   else :              log . error ( <str> . format ( len ( args . interactionFile ) ) ) exit ( 1 )  run_target_list_compilation ( interactionFileList , targetFileList , args , viewpointObj )  if args . batchMode :          with open ( args . writeFileNamesToFile , <str> ) as nameListFile :              nameListFile . write ( <str> . join ( outfile_names ) )     