import warnings warnings . simplefilter ( action = <str> , category = RuntimeWarning ) warnings . simplefilter ( action = <str> , category = PendingDeprecationWarning ) import argparse import numpy as np from past . builtins import zip import logging log = logging . getLogger ( __name__ ) from hicmatrix import HiCMatrix as hm from hicexplorer . reduceMatrix import reduce_matrix from hicexplorer . _version import __version__ def parse_arguments ( args = None ) :      parser = argparse . ArgumentParser ( formatter_class = argparse . ArgumentDefaultsHelpFormatter , add_help = False , description = <str> <str> <str> <str> <str> <str> <str> <str> <str> <str> ) parserRequired = parser . add_argument_group ( <str> ) parserRequired . add_argument ( <str> , <str> , help = <str> , metavar = <str> , required = True ) parserRequired . add_argument ( <str> , <str> , help = <str> <str> <str> , required = True ) parserRequired . add_argument ( <str> , <str> , help = <str> , metavar = <str> , type = int , required = True ) parserOpt = parser . add_argument_group ( <str> ) parserOpt . add_argument ( <str> , help = <str> <str> , action = <str> ) parserOpt . add_argument ( <str> , <str> , action = <str> , help = <str> ) parserOpt . add_argument ( <str> , action = <str> , version = <str> . format ( __version__ ) ) return parser  def remove_nans_if_needed ( hic ) :      if hic . nan_bins is not None and len ( hic . nan_bins ) :          hic . maskBins ( hic . nan_bins ) hic . orig_bin_ids = [ ] hic . orig_cut_intervals = [ ] hic . correction_factors = None log . warning ( <str> <str> <str> )  return hic  def running_window_merge ( hic_matrix , num_bins ) :      hic_matrix = remove_nans_if_needed ( hic_matrix ) if num_bins == 1 :          return hic_matrix  assert num_bins % 2 == 1 , <str> half_num_bins = int ( ( num_bins - 1 ) / 2 ) from scipy . sparse import coo_matrix , dia_matrix , triu M = hic_matrix . matrix . shape [ 0 ] ma = triu ( hic_matrix . matrix , k = 0 , format = <str> ) row = ma . row col = ma . col data = ma . data idx_list = [ ] for i in range ( num_bins ) :          for j in range ( num_bins ) :              idx_list . append ( ( j - half_num_bins , i - half_num_bins ) )   new_row = row new_col = col new_data = data for idx_pair in idx_list :          if idx_pair == ( 0 , 0 ) :              continue  new_row = np . concatenate ( [ new_row , row + idx_pair [ 0 ] ] ) new_col = np . concatenate ( [ new_col , col + idx_pair [ 1 ] ] ) new_data = np . concatenate ( [ new_data , data ] )  keep = ( ( new_row > - 1 ) & ( new_col > - 1 ) & ( new_row < M ) & ( new_col < M ) ) new_data = new_data [ keep ] new_row = new_row [ keep ] new_col = new_col [ keep ] new_ma = coo_matrix ( ( new_data , ( new_row , new_col ) ) , shape = ( M , M ) ) new_ma = triu ( new_ma , k = 0 ) dia = dia_matrix ( ( [ new_ma . diagonal ( ) ] , [ 0 ] ) , shape = new_ma . shape ) new_ma = new_ma + new_ma . T - dia hic_matrix . matrix = new_ma hic_matrix . nan_bins = np . flatnonzero ( hic_matrix . matrix . sum ( 0 ) . A == 0 ) hic_matrix . matrix . eliminate_zeros ( ) return hic_matrix  def merge_bins ( hic , num_bins ) :      hic = remove_nans_if_needed ( hic ) ref_name_list , start_list , end_list , coverage_list = zip ( * hic . cut_intervals ) new_bins = [ ] bins_to_merge = [ ] prev_ref = ref_name_list [ 0 ] idx_start = 0 new_start = start_list [ 0 ] count = 0 for idx , ref in enumerate ( ref_name_list ) :          if ( count > 0 and count % num_bins == 0 ) or ref != prev_ref :              if count < num_bins / 2 :                  log . debug ( <str> . format ( prev_ref , count ) )  else :                  coverage = np . mean ( coverage_list [ idx_start : idx ] ) new_bins . append ( ( ref_name_list [ idx_start ] , new_start , end_list [ idx - 1 ] , coverage ) ) bins_to_merge . append ( list ( range ( idx_start , idx ) ) )  idx_start = idx new_start = start_list [ idx ] count = 0  prev_ref = ref count += 1  coverage = np . mean ( coverage_list [ idx_start : ] ) new_bins . append ( ( ref , new_start , end_list [ idx ] , coverage ) ) bins_to_merge . append ( list ( range ( idx_start , idx + 1 ) ) ) hic . matrix = reduce_matrix ( hic . matrix , bins_to_merge , diagonal = True ) hic . matrix . eliminate_zeros ( ) hic . setCutIntervals ( new_bins ) hic . nan_bins = np . flatnonzero ( hic . matrix . sum ( 0 ) . A == 0 ) return hic  def main ( args = None ) :      args = parse_arguments ( ) . parse_args ( args ) hic = hm . hiCMatrix ( args . matrix ) if args . runningWindow :          merged_matrix = running_window_merge ( hic , args . numBins )  else :          merged_matrix = merge_bins ( hic , args . numBins )  merged_matrix . save ( args . outFileName )   