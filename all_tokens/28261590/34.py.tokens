import warnings warnings . simplefilter ( action = <str> , category = RuntimeWarning ) warnings . simplefilter ( action = <str> , category = PendingDeprecationWarning ) import sys import numpy as np import argparse from matplotlib import use as mplt_use mplt_use ( <str> ) from unidecode import unidecode import cooler import logging log = logging . getLogger ( __name__ ) def readBed ( pBedFile ) :      viewpoints = [ ] with open ( pBedFile , <str> ) as file :          for line in file . readlines ( ) :              if line . startswith ( <str> ) :                  continue  _line = line . strip ( ) . split ( <str> ) if len ( line ) == 0 :                  continue  chrom , start , end = _line [ : 3 ] viewpoints . append ( ( chrom , start , end ) )   return viewpoints  def writableFile ( string ) :      try :          open ( string , <str> ) . close ( )  except IOError :          msg = <str> . format ( string ) log . debug ( msg ) raise argparse . ArgumentTypeError ( msg )  return string  def remove_outliers ( data , max_deviation = 3.5 ) :      median = np . median ( data ) b_value = 1.4826 mad = b_value * np . median ( np . abs ( data - median ) ) if mad > 0 :          deviation = abs ( data - median ) / mad data = data [ deviation <= max_deviation ]  return data  def convertNansToZeros ( ma ) :      nan_elements = np . flatnonzero ( np . isnan ( ma . data ) ) if len ( nan_elements ) > 0 :          ma . data [ nan_elements ] = 0.0  return ma  def convertInfsToZeros ( ma ) :      inf_elements = np . flatnonzero ( np . isinf ( ma . data ) ) if len ( inf_elements ) > 0 :          ma . data [ inf_elements ] = 0  return ma  def convertInfsToZeros_ArrayFloat ( pArray ) :      nan_elements = np . flatnonzero ( np . isnan ( pArray ) ) if len ( nan_elements ) > 0 :          pArray [ nan_elements ] = 0.0  inf_elements = np . flatnonzero ( np . isinf ( pArray ) ) if len ( inf_elements ) > 0 :          pArray [ inf_elements ] = 0.0  return pArray  def convertNansToOnes ( pArray ) :      nan_elements = np . flatnonzero ( np . isnan ( pArray ) ) if len ( nan_elements ) > 0 :          pArray [ nan_elements ] = 1.0  return pArray  def myAverage ( valuesArray , avgType = <str> ) :      valuesArray = valuesArray [ np . logical_not ( np . isnan ( valuesArray ) ) ] if avgType == <str> :          mean = np . mean ( valuesArray )  else :          mean = np . median ( valuesArray )  return mean  def enlarge_bins ( bin_intervals ) :      <str> chr_start = True for idx in range ( len ( bin_intervals ) - 1 ) :          chrom , start , end , extra = bin_intervals [ idx ] chrom_next , start_next , end_next , extra_next = bin_intervals [ idx + 1 ] if chr_start is True :              start = 0 chr_start = False bin_intervals [ idx ] = ( chrom , start , end , extra )  if chrom == chrom_next and end != start_next :              middle = start_next - int ( ( start_next - end ) / 2 ) bin_intervals [ idx ] = ( chrom , start , middle , extra ) bin_intervals [ idx + 1 ] = ( chrom , middle , end_next , extra_next )  if chrom != chrom_next :              chr_start = True   chrom , start , end , extra = bin_intervals [ - 1 ] bin_intervals [ - 1 ] = ( chrom , start , end , extra ) return bin_intervals  def genomicRegion ( string ) :      region = <str> . join ( string . split ( ) ) if region == <str> :          return None  if sys . version_info [ 0 ] == 2 :          region = region . translate ( None , <str> ) . replace ( <str> , <str> )  if sys . version_info [ 0 ] == 3 :          region = region . translate ( str . maketrans ( <str> , <str> , <str> ) ) . replace ( <str> , <str> )  if len ( region ) == 0 :          raise argparse . ArgumentTypeError ( <str> . format ( string ) )  return region  def getUserRegion ( chromSizes , regionString , max_chunk_size = 1e6 ) :      region = regionString . split ( <str> ) chrom = region [ 0 ] chromSizes = dict ( chromSizes ) try :          chromSizes [ chrom ]  except KeyError :          raise NameError ( <str> <str> % ( chrom , list ( chromSizes ) ) )  try :          regionStart = int ( region [ 1 ] )  except IndexError :          regionStart = 0  try :          regionEnd = int ( region [ 2 ] ) if int ( region [ 2 ] ) <= chromSizes [ chrom ] else chromSizes [ chrom ]  except IndexError :          regionEnd = chromSizes [ chrom ]  if regionStart > regionEnd or regionStart < 0 :          raise NameError ( <str> <str> % ( regionString ) )  try :          tilesize = int ( region [ 3 ] )  except IndexError :          tilesize = None  chromSizes = [ ( chrom , regionEnd ) ] if tilesize :          regionStart -= regionStart % tilesize regionEnd += tilesize - ( regionEnd % tilesize )  chunkSize = int ( regionEnd - regionStart ) if chunkSize > max_chunk_size :          chunkSize = max_chunk_size if tilesize and tilesize < chunkSize :              chunkSize -= chunkSize % tilesize   return ( chromSizes , regionStart , regionEnd , int ( chunkSize ) )  def expected_interactions_in_distance ( pLength_chromosome , pChromosome_count , pSubmatrix ) :      expected_interactions = np . zeros ( pSubmatrix . shape [ 0 ] ) row , col = pSubmatrix . nonzero ( ) distance = np . absolute ( row - col ) for i , distance_ in enumerate ( distance ) :          expected_interactions [ distance_ ] += pSubmatrix . data [ i ]  count_times_i = np . arange ( float ( len ( expected_interactions ) ) ) pChromosome_count = np . int ( pChromosome_count ) pLength_chromosome = np . int ( pLength_chromosome ) count_times_i *= pChromosome_count count_times_i -= pLength_chromosome count_times_i *= np . int ( - 1 ) expected_interactions /= count_times_i return expected_interactions  def expected_interactions_non_zero ( pSubmatrix ) :      expected_interactions = np . zeros ( pSubmatrix . shape [ 0 ] ) row , col = pSubmatrix . nonzero ( ) distance = np . absolute ( row - col ) occurences = np . zeros ( pSubmatrix . shape [ 0 ] ) for i , distance_ in enumerate ( distance ) :          expected_interactions [ distance_ ] += pSubmatrix . data [ i ] occurences [ distance_ ] += 1  expected_interactions /= occurences mask = np . isnan ( expected_interactions ) expected_interactions [ mask ] = 0 mask = np . isinf ( expected_interactions ) expected_interactions [ mask ] = 0 return expected_interactions  def expected_interactions ( pSubmatrix ) :      expected_interactions = np . zeros ( pSubmatrix . shape [ 0 ] ) row , col = pSubmatrix . nonzero ( ) distance = np . absolute ( row - col ) occurrences = np . arange ( pSubmatrix . shape [ 0 ] + 1 , 1 , - 1 ) for i , distance_ in enumerate ( distance ) :          expected_interactions [ distance_ ] += pSubmatrix . data [ i ]  expected_interactions /= occurrences mask = np . isnan ( expected_interactions ) expected_interactions [ mask ] = 0 mask = np . isinf ( expected_interactions ) expected_interactions [ mask ] = 0 return expected_interactions  def obs_exp_matrix_lieberman ( pSubmatrix , pLength_chromosome , pChromosome_count ) :      expected_interactions_in_distance_ = expected_interactions_in_distance ( pLength_chromosome , pChromosome_count , pSubmatrix ) row , col = pSubmatrix . nonzero ( ) distance = np . ceil ( np . absolute ( row - col ) / 2 ) . astype ( np . int32 ) if len ( pSubmatrix . data ) > 0 :          data_type = type ( pSubmatrix . data [ 0 ] ) expected = expected_interactions_in_distance_ [ distance ] pSubmatrix . data = pSubmatrix . data . astype ( np . float32 ) pSubmatrix . data /= expected pSubmatrix . data = convertInfsToZeros_ArrayFloat ( pSubmatrix . data ) . astype ( data_type )  return pSubmatrix  def obs_exp_matrix_norm ( pSubmatrix ) :      expected_interactions_in_distance = expected_interactions_non_zero ( pSubmatrix ) row_sums = np . array ( pSubmatrix . sum ( axis = 1 ) . T ) . flatten ( ) total_interactions = pSubmatrix . sum ( ) row , col = pSubmatrix . nonzero ( ) pSubmatrix . data = pSubmatrix . data . astype ( np . float32 ) for i in range ( len ( row ) ) :          expected = expected_interactions_in_distance [ np . absolute ( row [ i ] - col [ i ] ) ] expected *= row_sums [ row [ i ] ] * row_sums [ col [ i ] ] / total_interactions pSubmatrix . data [ i ] /= expected  mask = np . isnan ( pSubmatrix . data ) pSubmatrix . data [ mask ] = 0 mask = np . isinf ( pSubmatrix . data ) pSubmatrix . data [ mask ] = 0 pSubmatrix . eliminate_zeros ( ) return pSubmatrix  def obs_exp_matrix_non_zero ( pSubmatrix ) :      expected_interactions_in_distance_ = expected_interactions_non_zero ( pSubmatrix ) row , col = pSubmatrix . nonzero ( ) distance = np . ceil ( np . absolute ( row - col ) / 2 ) . astype ( np . int32 ) if len ( pSubmatrix . data ) > 0 :          data_type = type ( pSubmatrix . data [ 0 ] ) expected = expected_interactions_in_distance_ [ distance ] pSubmatrix . data = pSubmatrix . data . astype ( np . float32 ) pSubmatrix . data /= expected pSubmatrix . data = convertInfsToZeros_ArrayFloat ( pSubmatrix . data ) . astype ( data_type )  return pSubmatrix  def obs_exp_matrix ( pSubmatrix ) :      expected_interactions_in_distance_ = expected_interactions ( pSubmatrix ) row , col = pSubmatrix . nonzero ( ) distance = np . ceil ( np . absolute ( row - col ) / 2 ) . astype ( np . int32 ) if len ( pSubmatrix . data ) > 0 :          data_type = type ( pSubmatrix . data [ 0 ] ) expected = expected_interactions_in_distance_ [ distance ] pSubmatrix . data = pSubmatrix . data . astype ( np . float32 ) pSubmatrix . data /= expected pSubmatrix . data = convertInfsToZeros_ArrayFloat ( pSubmatrix . data ) . astype ( data_type )  return pSubmatrix  def toString ( s ) :      if isinstance ( s , str ) :          return s  if isinstance ( s , bytes ) :          if sys . version_info [ 0 ] == 2 :              return str ( s )  return s . decode ( <str> )  if isinstance ( s , list ) :          return [ toString ( x ) for x in s ]  if isinstance ( s , np . ndarray ) :          return s . astype ( str )  return s  def toBytes ( s ) :      if sys . version_info [ 0 ] == 2 :          return s  if isinstance ( s , bytes ) :          return s  if isinstance ( s , str ) :          return bytes ( s , <str> )  if isinstance ( s , list ) :          return [ toBytes ( x ) for x in s ]  return s  def check_chrom_str_bytes ( pIteratableObj , pObj ) :      if isinstance ( pObj , list ) and len ( pObj ) > 0 :          type_ = type ( pObj [ 0 ] )  else :          type_ = type ( pObj )  if not isinstance ( type ( next ( iter ( pIteratableObj ) ) ) , type_ ) :          if type ( next ( iter ( pIteratableObj ) ) ) is str :              pObj = toString ( pObj )  elif type ( next ( iter ( pIteratableObj ) ) ) in [ bytes , np . bytes_ ] :              pObj = toBytes ( pObj )   return pObj  def change_chrom_names ( chrom ) :      chrom = toString ( chrom ) if chrom . startswith ( <str> ) :          chrom = chrom [ 3 : ]  else :          chrom = <str> + chrom  return chrom  def opener ( filename ) :      import gzip f = open ( filename , <str> ) if f . read ( 2 ) == <str> :          f . seek ( 0 ) return gzip . GzipFile ( fileobj = f )  else :          f . seek ( 0 ) return f   def remove_non_ascii ( pText ) :      return unidecode ( pText )  def check_cooler ( pFileName ) :      if pFileName . endswith ( <str> ) or cooler . fileops . is_cooler ( pFileName ) or <str> in pFileName :          return True  return False  def in_units ( pBasePosition ) :      pBasePosition = float ( pBasePosition ) if pBasePosition > 1.5e6 :          labels = <str> . format ( pBasePosition / 1e6 ) labels += <str>  elif pBasePosition > 1500 :          labels = <str> . format ( pBasePosition / 1e3 ) labels += <str>  else :          labels = <str> . format ( ( pBasePosition ) ) labels += <str>  return labels   