import warnings warnings . simplefilter ( action = <str> , category = RuntimeWarning ) warnings . simplefilter ( action = <str> , category = PendingDeprecationWarning ) import os . path import numpy as np import pandas as pd import argparse from hicmatrix import HiCMatrix from hicexplorer . _version import __version__ import matplotlib matplotlib . use ( <str> ) import matplotlib . pyplot as plt from collections import OrderedDict from past . builtins import zip from scipy . sparse import triu import logging log = logging . getLogger ( __name__ ) def parse_arguments ( args = None ) :      parser = argparse . ArgumentParser ( add_help = False , description = <str> <str> <str> ) parserRequired = parser . add_argument_group ( <str> ) parserRequired . add_argument ( <str> , <str> , help = <str> , nargs = <str> , required = True ) parserRequired . add_argument ( <str> , <str> , help = <str> <str> <str> <str> <str> , type = argparse . FileType ( <str> ) , metavar = <str> , required = True ) parserOpt = parser . add_argument_group ( <str> ) parserOpt . add_argument ( <str> , help = <str> <str> <str> , nargs = <str> ) parserOpt . add_argument ( <str> , <str> , help = <str> , action = <str> ) parserOpt . add_argument ( <str> , help = <str> <str> , metavar = <str> , type = int , default = int ( 3e6 ) ) parserOpt . add_argument ( <str> , help = <str> <str> , action = <str> ) parserOpt . add_argument ( <str> , help = <str> <str> , nargs = <str> ) parserOpt . add_argument ( <str> , help = <str> , type = argparse . FileType ( <str> ) , ) parserOpt . add_argument ( <str> , help = <str> <str> , nargs = 2 , type = float ) parserOpt . add_argument ( <str> , <str> , action = <str> , help = <str> ) parserOpt . add_argument ( <str> , action = <str> , version = <str> . format ( __version__ ) ) return parser  def compute_distance_mean ( hicmat , maxdepth = None , perchr = False ) :      binsize = hicmat . getBinSize ( ) if maxdepth :          if maxdepth < binsize :              exit ( <str> . format ( binsize ) )  max_depth_in_bins = int ( float ( maxdepth * 1.5 ) / binsize ) hicmat . matrix = triu ( hicmat . matrix , k = 0 , format = <str> ) - triu ( hicmat . matrix , k = max_depth_in_bins , format = <str> )  else :          hicmat . matrix = triu ( hicmat . matrix , k = 0 , format = <str> )  hicmat . matrix . eliminate_zeros ( ) chr_submatrix = OrderedDict ( ) cut_intervals = OrderedDict ( ) chrom_sizes = OrderedDict ( ) chrom_range = OrderedDict ( ) if perchr :          for chrname in hicmat . getChrNames ( ) :              chr_range = hicmat . getChrBinRange ( chrname ) chr_submatrix [ chrname ] = hicmat . matrix [ chr_range [ 0 ] : chr_range [ 1 ] , chr_range [ 0 ] : chr_range [ 1 ] ] . tocoo ( ) cut_intervals [ chrname ] = [ hicmat . cut_intervals [ x ] for x in range ( chr_range [ 0 ] , chr_range [ 1 ] ) ] chrom_sizes [ chrname ] = [ chr_submatrix [ chrname ] . shape [ 0 ] ] chrom_range [ chrname ] = ( chr_range [ 0 ] , chr_range [ 1 ] )   else :          chr_submatrix [ <str> ] = hicmat . matrix . tocoo ( ) cut_intervals [ <str> ] = hicmat . cut_intervals chrom_sizes [ <str> ] = np . array ( [ v [ 1 ] - v [ 0 ] for k , v in hicmat . chrBinBoundaries . items ( ) ] ) chrom_range [ <str> ] = ( 0 , hicmat . matrix . shape [ 0 ] )  mean_dict = { } for chrname , submatrix in chr_submatrix . items ( ) :          log . info ( <str> . format ( chrname ) ) dist_list , chrom_list = hicmat . getDistList ( submatrix . row , submatrix . col , HiCMatrix . hiCMatrix . fit_cut_intervals ( cut_intervals [ chrname ] ) ) dist_list [ dist_list == - 1 ] = - binsize dist_list = ( np . array ( dist_list ) . astype ( float ) / binsize ) . astype ( int ) + 1 sum_counts = np . bincount ( dist_list , weights = submatrix . data ) distance_len = np . bincount ( dist_list ) mat_size = submatrix . shape [ 0 ] mu = { } zero_value_bins = [ ] for bin_dist_plus_one , sum_value in enumerate ( sum_counts ) :              if maxdepth and bin_dist_plus_one == 0 :                  mu [ bin_dist_plus_one ] = np . nan continue  if bin_dist_plus_one == 0 :                  total_intra = mat_size ** 2 - sum ( [ size ** 2 for size in chrom_sizes [ chrname ] ] ) diagonal_length = total_intra / 2  else :                  diagonal_length = sum ( [ size - ( bin_dist_plus_one - 1 ) for size in chrom_sizes [ chrname ] if size > ( bin_dist_plus_one - 1 ) ] )  diagonal_length = max ( diagonal_length , distance_len [ bin_dist_plus_one ] ) if diagonal_length == 0 :                  mu [ bin_dist_plus_one ] = np . nan  else :                  mu [ bin_dist_plus_one ] = np . float64 ( sum_value ) / diagonal_length if sum_value == 0 :                      zero_value_bins . append ( bin_dist_plus_one ) log . info ( <str> . format ( bin_dist_plus_one , diagonal_length ) )  if len ( zero_value_bins ) > 10 :                      diff = np . diff ( zero_value_bins ) if len ( diff [ diff == 1 ] ) > 10 :                          log . info ( <str> . format ( chrname ) ) break    if np . isnan ( sum_value ) :                  log . info ( <str> . format ( ( bin_dist_plus_one - 1 ) * binsize ) )   if maxdepth is None :              maxdepth = np . inf  mean_dict [ chrname ] = OrderedDict ( [ ( ( k - 1 ) * binsize , v ) for k , v in mu . items ( ) if k > 0 and ( k - 1 ) * binsize <= maxdepth ] )  return mean_dict  def main ( args = None ) :      args = parse_arguments ( ) . parse_args ( args ) mean_dict = OrderedDict ( ) matrix_sum = { } if args . labels is None :          labels = OrderedDict ( [ ( x , os . path . basename ( x ) ) for x in args . matrices ] )  else :          labels = OrderedDict ( zip ( args . matrices , args . labels ) )  chroms = set ( ) for matrix_file in args . matrices :          hic_ma = HiCMatrix . hiCMatrix ( matrix_file ) matrix_sum [ matrix_file ] = hic_ma . matrix . sum ( ) if args . chromosomeExclude is None :              args . chromosomeExclude = [ ]  chrtokeep = [ x for x in list ( hic_ma . interval_trees ) if x not in args . chromosomeExclude ] hic_ma . keepOnlyTheseChr ( chrtokeep ) mean_dict [ matrix_file ] = compute_distance_mean ( hic_ma , maxdepth = args . maxdepth , perchr = args . perchr ) chroms = chroms . union ( [ k for k in list ( mean_dict [ matrix_file ] ) if len ( mean_dict [ matrix_file ] [ k ] ) > 1 ] )  min_sum = min ( matrix_sum . values ( ) ) scale_factor = dict ( [ ( matrix_file , float ( min_sum ) / mat_sum ) for matrix_file , mat_sum in matrix_sum . items ( ) ] ) log . info ( <str> . format ( scale_factor ) ) if len ( args . matrices ) > 1 and args . perchr :          max_cols = 4 num_rows = int ( np . ceil ( float ( len ( chroms ) ) / max_cols ) ) num_cols = min ( len ( chroms ) , max_cols )  else :          num_cols = num_rows = 1  if args . plotsize is None :          width = 6 height = 4  else :          width , height = args . plotsize  fig = plt . figure ( figsize = ( width * num_cols , height * num_rows ) ) axs = np . empty ( ( num_rows , num_cols ) , dtype = <str> ) for matrix_file in args . matrices :          idx = 0 for chrom , mean_values in mean_dict [ matrix_file ] . items ( ) :              if len ( mean_values ) <= 1 :                  log . debug ( <str> . format ( matrix_file , chrom ) ) continue  x , y = zip ( * [ ( k , v ) for k , v in mean_values . items ( ) if v > 0 ] ) if len ( x ) <= 1 :                  log . debug ( <str> . format ( matrix_file , chrom ) ) continue  if args . perchr and len ( args . matrices ) == 1 :                  col = 0 row = 0  else :                  col = idx % num_cols row = idx // num_cols  if axs [ row , col ] is None :                  ax = plt . subplot2grid ( ( num_rows , num_cols ) , ( row , col ) ) ax . set_xlabel ( <str> ) ax . set_ylabel ( <str> ) try :                      ax . set_yscale ( <str> ) ax . set_xscale ( <str> )  except ValueError :                      continue   else :                  ax = axs [ row , col ]  y = np . array ( y ) * scale_factor [ matrix_file ] if args . perchr and len ( args . matrices ) > 1 :                  label = labels [ matrix_file ] ax . set_title ( chrom )  elif args . perchr :                  label = chrom  else :                  label = labels [ matrix_file ]  ax . plot ( x , y , label = label ) axs [ row , col ] = ax idx += 1 if args . outFileData is not None :                  x_vals = np . stack ( x ) . T y_vals = np . stack ( y ) . T table_to_export = pd . DataFrame ( { <str> : labels [ matrix_file ] , <str> : chrom , <str> : x_vals , <str> : y_vals } ) table_to_export . to_csv ( args . outFileData , sep = <str> )    for ax in axs . reshape ( - 1 ) :          if ax is None :              continue  ax . legend ( prop = { <str> : <str> } ) ax . set_xlim ( 0 , args . maxdepth ) handles , labels = ax . get_legend_handles_labels ( ) lgd = ax . legend ( handles , labels , loc = <str> , bbox_to_anchor = ( 1 , 0.5 ) )  plt . tight_layout ( ) plt . savefig ( args . plotFile . name , bbox_inches = <str> , bbox_extra_artists = ( lgd , ) ) plt . close ( fig )   