import numpy as np import argparse import pandas as pd import matplotlib matplotlib . use ( <str> ) import matplotlib . pyplot as plt from scipy . sparse import dia_matrix import logging log = logging . getLogger ( __name__ ) from hicmatrix import HiCMatrix as hm from hicexplorer . _version import __version__ def parse_arguments ( ) :      parser = argparse . ArgumentParser ( add_help = False , description = ) parserRequired = parser . add_argument_group ( <str> ) parserRequired . add_argument ( <str> , <str> , help = <str> , nargs = <str> , required = True ) parserRequired . add_argument ( <str> , help = <str> <str> <str> <str> <str> , required = True ) parserRequired . add_argument ( <str> , <str> , help = <str> <str> , required = True ) parserOpt = parser . add_argument_group ( <str> ) parserOpt . add_argument ( <str> , <str> , help = <str> , default = 30 , type = int ) parserOpt . add_argument ( <str> , help = <str> , default = 0 , type = float ) parserOpt . add_argument ( <str> , help = <str> <str> , default = None ) parserOpt . add_argument ( <str> , action = <str> , help = <str> ) parserOpt . add_argument ( <str> , action = <str> , version = <str> . format ( __version__ ) ) return parser  def count_interactions ( obs_exp , pc1 , quantiles_number ) :      <str> <str> chromosomes = pc1 [ <str> ] . unique ( ) normalised_sum_per_quantile = np . zeros ( ( quantiles_number , quantiles_number ) ) for chrom in chromosomes :          pc1_chr = pc1 . loc [ pc1 [ <str> ] == chrom ] . reset_index ( drop = True ) chr_range = obs_exp . getChrBinRange ( chrom ) chr_submatrix = obs_exp . matrix [ chr_range [ 0 ] : chr_range [ 1 ] , chr_range [ 0 ] : chr_range [ 1 ] ] chr_submatrix = chr_submatrix . todense ( ) np . fill_diagonal ( chr_submatrix , 0 ) for qi in range ( 0 , quantiles_number ) :              row_indices = pc1_chr . loc [ pc1_chr [ <str> ] == qi ] . index for qj in range ( 0 , quantiles_number ) :                  col_indices = pc1_chr . loc [ pc1_chr [ <str> ] == qj ] . index data = chr_submatrix [ row_indices , : ] [ : , col_indices ] if data . shape [ 0 ] * data . shape [ 1 ] != 0 :                      normalised_sum_per_quantile [ qi , qj ] += ( np . sum ( data ) / ( data . shape [ 0 ] * data . shape [ 1 ] ) )     return normalised_sum_per_quantile  def within_vs_between_compartments ( normalised_sum_per_quantile , quantiles_number ) :      within_to_between = [ ] for q in range ( 1 , quantiles_number ) :          within_comps = normalised_sum_per_quantile [ 0 : q , 0 : q ] . sum ( ) + normalised_sum_per_quantile [ quantiles_number - q : quantiles_number , quantiles_number - q : quantiles_number ] . sum ( ) between_comps = normalised_sum_per_quantile [ 0 : q , quantiles_number - q : quantiles_number ] . sum ( ) + normalised_sum_per_quantile [ quantiles_number - q : quantiles_number , 0 : q ] . sum ( ) within_to_between . append ( within_comps / between_comps )  return within_to_between  def plot_polarization_ratio ( polarization_ratio , plotName , labels , number_of_quantiles ) :      for i , r in enumerate ( polarization_ratio ) :          plt . plot ( r , marker = <str> , label = labels [ i ] )  plt . axhline ( 1 , c = <str> , ls = <str> , lw = 1 ) plt . axvline ( number_of_quantiles / 2 , c = <str> , ls = <str> , lw = 1 ) plt . legend ( loc = <str> ) plt . xlabel ( <str> ) plt . ylabel ( <str> ) plt . title ( <str> ) plt . savefig ( plotName )  def main ( args = None ) :      args = parse_arguments ( ) . parse_args ( args ) pc1_bedgraph = pd . read_table ( args . pca , header = None , sep = <str> ) pc1 = pd . DataFrame ( pc1_bedgraph . values , columns = [ <str> , <str> , <str> , <str> ] ) if args . outliers != 0 :          quantile = [ args . outliers / 100 , ( 100 - args . outliers ) / 100 ] q0 , qn = np . nanquantile ( pc1 [ <str> ] . values . astype ( float ) , quantile ) q_bins = np . linspace ( q0 , qn , args . quantile )  else :          quantile = [ j / ( args . quantile - 1 ) for j in range ( 0 , args . quantile ) ] q_bins = np . nanquantile ( pc1 [ <str> ] . values . astype ( float ) , quantile )  pc1 [ <str> ] = np . searchsorted ( q_bins , pc1 [ <str> ] . values . astype ( float ) ) polarization_ratio = [ ] output_matrices = [ ] labels = [ ] for matrix in args . obsexp_matrices :          obs_exp = hm . hiCMatrix ( matrix ) name = <str> . join ( matrix . split ( <str> ) [ - 1 ] . split ( <str> ) [ 0 : - 1 ] ) labels . append ( name ) normalised_sum_per_quantile = count_interactions ( obs_exp , pc1 , args . quantile ) if args . outputMatrix :              output_matrices . append ( normalised_sum_per_quantile )  polarization_ratio . append ( within_vs_between_compartments ( normalised_sum_per_quantile , args . quantile ) )  if args . outputMatrix :          np . savez ( args . outputMatrix , [ matrix for matrix in output_matrices ] )  plot_polarization_ratio ( polarization_ratio , args . outputFileName , labels , args . quantile )   