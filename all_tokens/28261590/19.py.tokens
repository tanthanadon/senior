import logging from collections import OrderedDict from mpl_toolkits . axes_grid1 import make_axes_locatable import matplotlib . gridspec as gridspec import matplotlib . cm as cm import matplotlib . pyplot as plt from matplotlib . colors import LogNorm import matplotlib import argparse from past . builtins import zip import pyBigWig import numpy as np from hicexplorer . _version import __version__ from hicexplorer . utilities import check_cooler from hicexplorer . utilities import check_chrom_str_bytes from hicexplorer . utilities import remove_non_ascii from hicexplorer . utilities import change_chrom_names from hicexplorer . utilities import enlarge_bins from hicexplorer . utilities import toString , toBytes from hicexplorer . utilities import writableFile from hicmatrix import HiCMatrix import warnings warnings . simplefilter ( action = <str> , category = RuntimeWarning ) warnings . simplefilter ( action = <str> , category = PendingDeprecationWarning ) matplotlib . use ( <str> ) log = logging . getLogger ( __name__ ) def parse_arguments ( args = None ) :      parser = argparse . ArgumentParser ( add_help = False , description = <str> ) parserRequired = parser . add_argument_group ( <str> ) parserRequired . add_argument ( <str> , <str> , help = <str> , required = True ) parserRequired . add_argument ( <str> , <str> , help = <str> , type = writableFile , required = True ) parserOpt = parser . add_argument_group ( <str> ) parserOpt . add_argument ( <str> , <str> , help = <str> ) parserOpt . add_argument ( <str> , <str> , help = <str> ) parserOpt . add_argument ( <str> , help = <str> <str> <str> , action = <str> ) parserOpt . add_argument ( <str> , help = <str> <str> <str> , action = <str> ) parserOpt . add_argument ( <str> , help = <str> <str> <str> , nargs = <str> ) parserOpt . add_argument ( <str> , help = <str> <str> <str> <str> ) parserOpt . add_argument ( <str> , help = <str> <str> <str> ) parserOpt . add_argument ( <str> , help = <str> , action = <str> ) parserOpt . add_argument ( <str> , help = <str> , action = <str> ) parserOpt . add_argument ( <str> , help = <str> <str> <str> , default = <str> ) parserOpt . add_argument ( <str> , help = <str> , type = float , default = None ) parserOpt . add_argument ( <str> , help = <str> , type = float , default = None ) parserOpt . add_argument ( <str> , help = <str> <str> , type = int , default = 72 ) parserOpt . add_argument ( <str> , help = <str> <str> <str> , type = str , default = None , nargs = <str> ) parserOpt . add_argument ( <str> , help = <str> , action = <str> ) parserOpt . add_argument ( <str> , help = <str> , type = float , default = None ) parserOpt . add_argument ( <str> , help = <str> , type = float , default = None ) parserOpt . add_argument ( <str> , help = <str> , action = <str> ) parserOpt . add_argument ( <str> , help = <str> , type = float , default = 1.0 ) parserOpt . add_argument ( <str> , help = <str> , type = float , default = 10 ) parserOpt . add_argument ( <str> , help = <str> , type = float , default = 0 ) parserOpt . add_argument ( <str> , help = <str> , type = float , default = 0 ) parserOpt . add_argument ( <str> , help = <str> <str> , type = str , default = None ) parserOpt . add_argument ( <str> , <str> , action = <str> , help = <str> ) parserOpt . add_argument ( <str> , action = <str> , version = <str> . format ( __version__ ) ) parserOpt . add_argument ( <str> , help = argparse . SUPPRESS , action = <str> ) return parser  def relabel_ticks ( pXTicks ) :      if pXTicks [ - 1 ] > 1.5e6 :          labels = [ <str> . format ( x / 1e6 ) for x in pXTicks ] labels [ - 2 ] += <str>  elif pXTicks [ - 1 ] > 1500 :          labels = [ <str> . format ( x / 1e3 ) for x in pXTicks ] labels [ - 2 ] += <str>  else :          labels = [ <str> . format ( ( x ) ) for x in pXTicks ] labels [ - 2 ] += <str>  return labels  def plotHeatmap ( ma , chrBinBoundaries , fig , position , args , cmap , xlabel = None , ylabel = None , start_pos = None , start_pos2 = None , pNorm = None , pAxis = None , pBigwig = None , pLoops = None , pHiCMatrix = None ) :      log . debug ( <str> ) if ma . shape [ 0 ] < 5 :          chr_names = <str> . join ( [ toString ( x ) for x in chrBinBoundaries . keys ( ) ] ) log . info ( <str> . format ( chr_names , ma . shape ) ) return  if pAxis is not None :          axHeat2 = pAxis  else :          axHeat2 = fig . add_axes ( position )  if args . title :          axHeat2 . set_title ( toString ( args . title ) )  if start_pos2 is None :          start_pos2 = start_pos  xmesh , ymesh = np . meshgrid ( start_pos , start_pos2 ) img3 = axHeat2 . pcolormesh ( xmesh . T , ymesh . T , ma , vmin = args . vMin , vmax = args . vMax , cmap = cmap , norm = pNorm ) img3 . set_rasterized ( True ) if args . region :          xtick_lables = relabel_ticks ( axHeat2 . get_xticks ( ) ) axHeat2 . get_xaxis ( ) . set_tick_params ( which = <str> , bottom = <str> , direction = <str> ) axHeat2 . set_xticklabels ( xtick_lables , size = <str> , rotation = args . rotationX ) ytick_lables = relabel_ticks ( axHeat2 . get_yticks ( ) ) axHeat2 . get_yaxis ( ) . set_tick_params ( which = <str> , bottom = <str> , direction = <str> ) axHeat2 . set_yticklabels ( ytick_lables , size = <str> ) xticks = [ xtick_lables ] log . debug ( <str> )  else :          pos = 0 ticks = [ ] for chr_size in chrBinBoundaries . values ( ) :              ticks . append ( pos ) pos += chr_size  labels = list ( chrBinBoundaries ) axHeat2 . set_xticks ( ticks ) axHeat2 . set_yticks ( ticks ) labels = toString ( labels ) xticks = [ labels , ticks ] if len ( labels ) > 20 :              log . debug ( <str> ) axHeat2 . set_xticklabels ( labels , rotation = args . rotationX , fontsize = args . fontsize ) axHeat2 . set_yticklabels ( labels , rotation = args . rotationY , fontsize = args . fontsize )  else :              log . debug ( <str> ) axHeat2 . set_xticklabels ( labels , rotation = args . rotationX , fontsize = args . fontsize ) axHeat2 . set_yticklabels ( labels , rotation = args . rotationY , fontsize = args . fontsize )   if pBigwig is None :          divider = make_axes_locatable ( axHeat2 ) cax = divider . append_axes ( <str> , size = <str> , pad = 0.09 )  else :          cax = pBigwig [ <str> ]  cbar = fig . colorbar ( img3 , cax = cax ) cbar . solids . set_edgecolor ( <str> ) if args . scoreName :          cbar . ax . set_ylabel ( args . scoreName , size = 8 )  if ylabel is not None :          ylabel = toString ( ylabel ) axHeat2 . set_ylabel ( ylabel , fontsize = args . fontsize )  if xlabel is not None :          xlabel = toString ( xlabel ) axHeat2 . set_xlabel ( xlabel , fontsize = args . fontsize )  if pLoops :          log . debug ( <str> ) plotLongRangeContacts ( axHeat2 , pLoops , pHiCMatrix , args . region , args . chromosomeOrder )  axHeat2 . invert_yaxis ( ) if pBigwig :          axHeat2 . xaxis . set_label_position ( <str> ) axHeat2 . xaxis . tick_top ( ) axis_bigwig = [ ] vertical_flip = [ ] if args . bigwigAdditionalVerticalAxis :              axis_bigwig . append ( [ pBigwig [ <str> ] ] ) axis_bigwig . append ( [ pBigwig [ <str> ] ] ) vertical_flip = [ False , True ]  else :              axis_bigwig . append ( pBigwig [ <str> ] ) vertical_flip = [ None , None ]  for i , _axis in enumerate ( axis_bigwig ) :              if args . region :                  log . debug ( <str> ) plotBigwig ( _axis , pBigwig [ <str> ] . bigwig , pChromosomeSizes = chrBinBoundaries , pRegion = pBigwig [ <str> ] . region , pXticks = xticks , pFlipBigwigSign = args . flipBigwigSign , pScaleFactorBigwig = args . scaleFactorBigwig , pVertical = vertical_flip [ i ] , pValueMin = args . vMinBigwig , pValueMax = args . vMaxBigwig )  else :                  log . debug ( <str> ) plotBigwig ( _axis , pBigwig [ <str> ] . bigwig , pXticks = xticks , pChromosomeSizes = chrBinBoundaries , pFlipBigwigSign = args . flipBigwigSign , pScaleFactorBigwig = args . scaleFactorBigwig , pVertical = vertical_flip [ i ] , pValueMin = args . vMinBigwig , pValueMax = args . vMaxBigwig )     def translate_region ( region_string ) :      region_string = region_string . replace ( <str> , <str> ) region_string = region_string . replace ( <str> , <str> ) region_string = region_string . replace ( <str> , <str> ) region_string = region_string . replace ( <str> , <str> ) fields = region_string . split ( <str> ) chrom = fields [ 0 ] try :          region_start = int ( fields [ 1 ] )  except IndexError :          region_start = 0  try :          region_end = int ( fields [ 2 ] )  except IndexError :          region_end = 1e15  return chrom , region_start , region_end  def plotPerChr ( hic_matrix , cmap , args , pBigwig ) :      from math import ceil chromosomes = hic_matrix . getChrNames ( ) chrom_per_row = 5 num_rows = int ( ceil ( float ( len ( chromosomes ) ) / chrom_per_row ) ) num_cols = min ( chrom_per_row , len ( chromosomes ) ) width_ratios = [ 1.0 ] * num_cols + [ 0.05 ] grids = gridspec . GridSpec ( num_rows , num_cols + 1 , width_ratios = width_ratios , height_ratios = [ 1 ] * num_rows ) fig_height = 6 * num_rows fig_width = sum ( ( np . array ( width_ratios ) + 0.05 ) * 6 ) fig = plt . figure ( figsize = ( fig_width , fig_height ) , dpi = args . dpi ) chrom , start , end , _ = zip ( * hic_matrix . cut_intervals ) for idx , chrname in enumerate ( chromosomes ) :          log . debug ( <str> . format ( chrname ) ) bigwig_info = None row = idx // chrom_per_row col = idx % chrom_per_row if pBigwig :              bigwig_info = { <str> : args , <str> : None , <str> : None , <str> : hic_matrix . nan_bins } number_of_rows_plot = len ( args . bigwig ) bigwig_heights = [ 0.07 ] * number_of_rows_plot bigwig_height_ratio = 0.95 - ( 0.07 * number_of_rows_plot ) if bigwig_height_ratio < 0.4 :                  bigwig_height_ratio = 0.4 _ratio = 0.6 / len ( number_of_rows_plot ) bigwig_heights = [ _ratio ] * number_of_rows_plot  if args . bigwigAdditionalVerticalAxis :                  gs = gridspec . GridSpecFromSubplotSpec ( 1 + len ( args . bigwig ) , 3 , height_ratios = [ 0.90 , 0.1 ] , width_ratios = [ 0.15 , 0.82 , 0.03 ] , subplot_spec = grids [ row , col ] , wspace = 0.1 , hspace = 0.1 ) bigwig_vertical_axis = plt . subplot ( gs [ 0 , 0 ] ) axis = plt . subplot ( gs [ 0 , 1 ] ) ax2 = plt . subplot ( gs [ 1 , 1 ] ) ax3 = plt . subplot ( gs [ 0 , 2 ] ) bigwig_info [ <str> ] = ax2 bigwig_info [ <str> ] = ax3 bigwig_info [ <str> ] = bigwig_vertical_axis  else :                  gs = gridspec . GridSpecFromSubplotSpec ( 1 + len ( args . bigwig ) , 2 , height_ratios = [ 0.95 - ( 0.07 * number_of_rows_plot ) , * bigwig_heights ] , width_ratios = [ 0.97 , 0.03 ] , subplot_spec = grids [ row , col ] , wspace = 0.1 , hspace = 0.1 ) axis = plt . subplot ( gs [ 0 , 0 ] ) ax2_list = [ ] for i in range ( len ( args . bigwig ) ) :                      ax2_list . append ( plt . subplot ( gs [ 1 + i , 0 ] ) )  ax3 = plt . subplot ( gs [ 0 , 1 ] ) bigwig_info [ <str> ] = ax2_list bigwig_info [ <str> ] = ax3   else :              axis = plt . subplot ( grids [ row , col ] ) axis . set_title ( toString ( chrname ) )  chrom_range = hic_matrix . getChrBinRange ( chrname ) matrix = np . asarray ( hic_matrix . matrix [ chrom_range [ 0 ] : chrom_range [ 1 ] , chrom_range [ 0 ] : chrom_range [ 1 ] ] . todense ( ) . astype ( float ) ) norm = None if args . log or args . log1p :              mask = matrix == 0 mask_nan = np . isnan ( matrix ) mask_inf = np . isinf ( matrix ) log . debug ( <str> . format ( np . isnan ( matrix ) . any ( ) ) ) log . debug ( <str> . format ( np . isinf ( matrix ) . any ( ) ) ) try :                  matrix [ mask ] = np . nanmin ( matrix [ mask == False ] ) matrix [ mask_nan ] = np . nanmin ( matrix [ mask_nan == False ] ) matrix [ mask_inf ] = np . nanmin ( matrix [ mask_inf == False ] )  except Exception :                  log . debug ( <str> )  log . debug ( <str> . format ( np . isnan ( matrix ) . any ( ) ) ) log . debug ( <str> . format ( np . isinf ( matrix ) . any ( ) ) )  if args . log1p :              matrix += 1 norm = LogNorm ( )  elif args . log :              norm = LogNorm ( )  chr_bin_boundary = OrderedDict ( ) chr_bin_boundary [ chrname ] = hic_matrix . get_chromosome_sizes ( ) [ chrname ] args . region = toString ( chrname ) chrom , region_start , region_end , idx1 , start_pos1 , chrom2 , region_start2 , region_end2 , idx2 , start_pos2 = getRegion ( args , hic_matrix ) plotHeatmap ( matrix , chr_bin_boundary , fig , None , args , cmap , xlabel = chrname , ylabel = chrname , start_pos = start_pos1 , start_pos2 = start_pos2 , pNorm = norm , pAxis = axis , pBigwig = bigwig_info )  return fig  def getRegion ( args , ma ) :      chrom = region_start = region_end = idx1 = start_pos1 = chrom2 = region_start2 = region_end2 = idx2 = start_pos2 = None chrom , region_start , region_end = translate_region ( args . region ) chrom = check_chrom_str_bytes ( ma . interval_trees , chrom ) if chrom not in list ( ma . interval_trees ) :          chrom = change_chrom_names ( chrom ) chrom = check_chrom_str_bytes ( ma . interval_trees , chrom ) if chrom not in list ( ma . interval_trees ) :              exit ( <str> . format ( change_chrom_names ( chrom ) ) )   args . region = [ chrom , region_start , region_end ] is_cooler = check_cooler ( args . matrix ) if is_cooler :          idx1 , start_pos1 = zip ( * [ ( idx , x [ 1 ] ) for idx , x in enumerate ( ma . cut_intervals ) if x [ 0 ] == chrom and ( ( x [ 1 ] >= region_start and x [ 2 ] < region_end ) or ( x [ 1 ] < region_end and x [ 2 ] < region_end and x [ 2 ] > region_start ) or ( x [ 1 ] > region_start and x [ 1 ] < region_end ) ) ] )  else :          idx1 , start_pos1 = zip ( * [ ( idx , x [ 1 ] ) for idx , x in enumerate ( ma . cut_intervals ) if x [ 0 ] == chrom and x [ 1 ] >= region_start and x [ 2 ] < region_end ] )  if hasattr ( args , <str> ) and args . region2 :          chrom2 , region_start2 , region_end2 = translate_region ( args . region2 ) chrom2 = check_chrom_str_bytes ( ma . interval_trees , chrom2 ) if chrom2 not in list ( ma . interval_trees ) :              chrom2 = change_chrom_names ( chrom2 ) chrom2 = check_chrom_str_bytes ( ma . interval_trees , chrom2 ) if chrom2 not in list ( ma . interval_trees ) :                  exit ( <str> . format ( change_chrom_names ( chrom2 ) ) )   if is_cooler :              idx2 , start_pos2 = zip ( * [ ( idx , x [ 1 ] ) for idx , x in enumerate ( ma . cut_intervals ) if x [ 0 ] == chrom2 and ( ( x [ 1 ] >= region_start2 and x [ 2 ] < region_end2 ) or ( x [ 1 ] < region_end2 and x [ 2 ] < region_end2 and x [ 2 ] > region_start2 ) or ( x [ 1 ] > region_start2 and x [ 1 ] < region_end2 ) ) ] )  else :              idx2 , start_pos2 = zip ( * [ ( idx , x [ 1 ] ) for idx , x in enumerate ( ma . cut_intervals ) if x [ 0 ] == chrom2 and x [ 1 ] >= region_start2 and x [ 2 ] < region_end2 ] )   else :          idx2 = idx1 chrom2 = chrom start_pos2 = start_pos1  return chrom , region_start , region_end , idx1 , start_pos1 , chrom2 , region_start2 , region_end2 , idx2 , start_pos2  def main ( args = None ) :      args = parse_arguments ( ) . parse_args ( args ) if args . title :          args . title = remove_non_ascii ( args . title )  chrom = None start_pos1 = None chrom2 = None start_pos2 = None if args . perChromosome and args . region :          log . error ( <str> <str> <str> <str> ) exit ( 1 )  if args . bigwig is not None and len ( args . bigwig ) > 1 and args . bigwigAdditionalVerticalAxis :          log . error ( <str> )  is_cooler = check_cooler ( args . matrix ) log . info ( <str> . format ( is_cooler ) ) open_cooler_chromosome_order = True if args . chromosomeOrder is not None and len ( args . chromosomeOrder ) > 1 :          open_cooler_chromosome_order = False  if is_cooler and not args . region2 and open_cooler_chromosome_order :          log . debug ( <str> ) regionsToRetrieve = None if args . region :              regionsToRetrieve = [ ] regionsToRetrieve . append ( args . region )  if args . chromosomeOrder :              args . region = None args . region2 = None regionsToRetrieve = args . chromosomeOrder  ma = HiCMatrix . hiCMatrix ( args . matrix , pChrnameList = regionsToRetrieve ) log . debug ( <str> . format ( ma . matrix . shape ) ) if args . clearMaskedBins :              ma . maskBins ( ma . nan_bins ) new_intervals = enlarge_bins ( ma . cut_intervals ) ma . setCutIntervals ( new_intervals )  if args . region :              chrom , region_start , region_end , idx1 , start_pos1 , chrom2 , region_start2 , region_end2 , idx2 , start_pos2 = getRegion ( args , ma )  matrix = np . asarray ( ma . matrix . todense ( ) . astype ( float ) ) matrix_length = len ( matrix [ 0 ] ) log . debug ( <str> . format ( matrix_length ) )  else :          ma = HiCMatrix . hiCMatrix ( args . matrix ) if args . clearMaskedBins :              ma . maskBins ( ma . nan_bins ) new_intervals = enlarge_bins ( ma . cut_intervals ) ma . setCutIntervals ( new_intervals )  if args . chromosomeOrder :              args . region = None args . region2 = None valid_chromosomes = [ ] invalid_chromosomes = [ ] log . debug ( <str> . format ( args . chromosomeOrder ) ) log . debug ( <str> . format ( ma . chrBinBoundaries ) ) args . chromosomeOrder = toBytes ( args . chromosomeOrder ) for chrom in toString ( args . chromosomeOrder ) :                  if chrom in ma . chrBinBoundaries :                      valid_chromosomes . append ( chrom )  else :                      invalid_chromosomes . append ( chrom )   if len ( invalid_chromosomes ) > 0 :                  log . warning ( <str> <str> ) log . warning ( <str> . join ( invalid_chromosomes ) )  ma . reorderChromosomes ( valid_chromosomes ) chrom = None  log . info ( <str> . format ( ma . matrix . data . min ( ) , ma . matrix . data . max ( ) ) ) if args . region :              chrom , region_start , region_end , idx1 , start_pos1 , chrom2 , region_start2 , region_end2 , idx2 , start_pos2 = getRegion ( args , ma ) matrix = np . asarray ( ma . matrix [ idx1 , : ] [ : , idx2 ] . todense ( ) . astype ( float ) )  else :              log . debug ( <str> ) matrix = np . asarray ( ma . getMatrix ( ) . astype ( float ) )   matrix_length = len ( matrix [ 0 ] ) log . debug ( <str> . format ( matrix_length ) ) for matrix_ in matrix :          if not matrix_length == len ( matrix_ ) :              log . error ( <str> . format ( matrix_length , len ( matrix_ ) ) )   cmap = cm . get_cmap ( args . colorMap ) log . debug ( <str> ) cmap . set_bad ( <str> ) bigwig_info = None if args . bigwig :          bigwig_info = { <str> : args , <str> : None , <str> : None , <str> : ma . nan_bins }  if args . perChromosome :          log . debug ( <str> ) fig = plotPerChr ( ma , cmap , args , pBigwig = bigwig_info )  else :          norm = None if args . log or args . log1p :              mask = matrix == 0 try :                  matrix [ mask ] = np . nanmin ( matrix [ mask == False ] )  except ValueError :                  log . info ( <str> . format ( np . finfo ( float ) . tiny ) ) matrix [ mask ] = np . finfo ( float ) . tiny  if np . isnan ( matrix ) . any ( ) or np . isinf ( matrix ) . any ( ) :                  log . debug ( <str> . format ( np . isnan ( matrix ) . any ( ) ) ) log . debug ( <str> . format ( np . isinf ( matrix ) . any ( ) ) ) mask_nan = np . isnan ( matrix ) mask_inf = np . isinf ( matrix ) matrix [ mask_nan ] = np . nanmin ( matrix [ mask_nan == False ] ) matrix [ mask_inf ] = np . nanmin ( matrix [ mask_inf == False ] )   log . debug ( <str> . format ( np . isnan ( matrix ) . any ( ) ) ) log . debug ( <str> . format ( np . isinf ( matrix ) . any ( ) ) ) if args . log1p :              matrix += 1 norm = LogNorm ( )  elif args . log :              norm = LogNorm ( )  if args . bigwig :              fig_height = 8.5  else :              fig_height = 7  height = 4.8 / fig_height fig_width = 8 width = 5.0 / fig_width left_margin = ( 1.0 - width ) * 0.5 fig = plt . figure ( figsize = ( fig_width , fig_height ) , dpi = args . dpi ) if args . bigwig :              number_of_rows_plot = len ( args . bigwig ) bigwig_heights = [ 0.07 ] * number_of_rows_plot bigwig_height_ratio = 0.95 - ( 0.07 * number_of_rows_plot ) if bigwig_height_ratio < 0.4 :                  bigwig_height_ratio = 0.4 _ratio = 0.6 / len ( number_of_rows_plot ) bigwig_heights = [ _ratio ] * number_of_rows_plot  if args . bigwigAdditionalVerticalAxis :                  gs = gridspec . GridSpec ( 1 + len ( args . bigwig ) , 3 , height_ratios = [ 0.90 , 0.1 ] , width_ratios = [ 0.15 , 0.82 , 0.03 ] ) gs . update ( hspace = 0.05 , wspace = 0.05 ) bigwig_vertical_axis = plt . subplot ( gs [ 0 , 0 ] ) ax1 = plt . subplot ( gs [ 0 , 1 ] ) ax2 = plt . subplot ( gs [ 1 , 1 ] ) ax3 = plt . subplot ( gs [ 0 , 2 ] ) bigwig_info [ <str> ] = ax2 bigwig_info [ <str> ] = ax3 bigwig_info [ <str> ] = bigwig_vertical_axis  else :                  gs = gridspec . GridSpec ( 1 + len ( args . bigwig ) , 2 , height_ratios = [ 0.95 - ( 0.07 * number_of_rows_plot ) , * bigwig_heights ] , width_ratios = [ 0.97 , 0.03 ] ) gs . update ( hspace = 0.05 , wspace = 0.05 ) ax1 = plt . subplot ( gs [ 0 , 0 ] ) ax2_list = [ ] for i in range ( len ( args . bigwig ) ) :                      ax2_list . append ( plt . subplot ( gs [ 1 + i , 0 ] ) )  ax3 = plt . subplot ( gs [ 0 , 1 ] ) bigwig_info [ <str> ] = ax2_list bigwig_info [ <str> ] = ax3   else :              ax1 = None  bottom = 1.3 / fig_height if start_pos1 is None :              start_pos1 = make_start_pos_array ( ma )  position = [ left_margin , bottom , width , height ] log . debug ( <str> . format ( chrom , chrom2 ) ) plotHeatmap ( matrix , ma . get_chromosome_sizes ( ) , fig , position , args , cmap , xlabel = chrom , ylabel = chrom2 , start_pos = start_pos1 , start_pos2 = start_pos2 , pNorm = norm , pAxis = ax1 , pBigwig = bigwig_info , pLoops = args . loops , pHiCMatrix = ma )  if not args . disable_tight_layout :          if args . perChromosome or args . bigwig :              try :                  plt . tight_layout ( )  except UserWarning :                  log . info ( <str> )  except ValueError :                  log . info ( <str> )    plt . savefig ( args . outFileName , dpi = args . dpi ) plt . close ( fig )  def make_start_pos_array ( ma ) :      chrom_sizes = ma . get_chromosome_sizes ( ) prev_chrom = ma . cut_intervals [ 0 ] [ 0 ] prev_chroms_sum = 0 start_pos = [ ] for ( chrom , start , end , _ ) in ma . cut_intervals :          if chrom != prev_chrom :              prev_chroms_sum += chrom_sizes [ prev_chrom ] prev_chrom = chrom  start_pos . append ( start + prev_chroms_sum )  return start_pos  def plotBigwig ( pAxis , pNameOfBigwigList , pChromosomeSizes = None , pRegion = None , pXticks = None , pFlipBigwigSign = None , pScaleFactorBigwig = None , pVertical = False , pValueMin = None , pValueMax = None ) :      log . debug ( <str> ) for file in pNameOfBigwigList :          file_format = file . split ( <str> ) [ - 1 ] if file_format != <str> and file_format != <str> :              log . error ( <str> ) exit ( 1 )   if file_format == <str> or file_format == <str> :          for i , bigwigFile in enumerate ( pNameOfBigwigList ) :              x_values = [ ] bigwig_scores = [ ] pAxis [ i ] . set_frame_on ( False ) if pVertical :                  pAxis [ i ] . yaxis . set_visible ( False )  else :                  pAxis [ i ] . xaxis . set_visible ( False )  bw = pyBigWig . open ( bigwigFile ) bigwig_scores = [ ] if pRegion :                  chrom , region_start , region_end = pRegion region_end = min ( region_end , pChromosomeSizes [ chrom ] ) chrom = check_chrom_str_bytes ( bw . chroms ( ) , chrom ) if chrom not in list ( bw . chroms ( ) . keys ( ) ) :                      chrom = change_chrom_names ( chrom ) if chrom not in list ( bw . chroms ( ) . keys ( ) ) :                          log . info ( <str> . format ( chrom ) ) return   bigwig_end = min ( bw . chroms ( ) [ chrom ] , region_end ) num_bins = min ( 1000 , int ( bigwig_end - region_start ) / 10 ) scores_per_bin = np . array ( bw . stats ( chrom , region_start , bigwig_end , nBins = num_bins ) ) . astype ( float ) if scores_per_bin is None :                      log . info ( <str> . format ( chrom ) ) return  _x_vals = np . linspace ( region_start , region_end , num_bins ) assert len ( _x_vals ) == len ( scores_per_bin ) x_values . extend ( _x_vals ) bigwig_scores . extend ( scores_per_bin ) if pVertical :                      pAxis [ i ] . set_ylim ( region_start , region_end )  else :                      pAxis [ i ] . set_xlim ( region_start , region_end )   elif pChromosomeSizes :                  chrom_length_sum = 0 for chrom in pChromosomeSizes :                      chrom_ = check_chrom_str_bytes ( bw . chroms ( ) , chrom ) if chrom_ not in list ( bw . chroms ( ) . keys ( ) ) :                          log . info ( <str> . format ( chrom ) ) return  chunk_size = min ( 1e5 , pChromosomeSizes [ chrom ] ) num_bins = int ( pChromosomeSizes [ chrom ] / chunk_size ) scores_per_bin = np . array ( bw . stats ( chrom_ , 0 , pChromosomeSizes [ chrom ] , nBins = num_bins ) ) . astype ( float ) if scores_per_bin is None :                          log . info ( <str> . format ( chrom ) ) return  _x_vals = np . linspace ( chrom_length_sum , chrom_length_sum + pChromosomeSizes [ chrom ] , num_bins ) assert len ( _x_vals ) == len ( scores_per_bin ) x_values . extend ( _x_vals ) bigwig_scores . extend ( scores_per_bin ) chrom_length_sum += pChromosomeSizes [ chrom ]  if pVertical :                      pAxis [ i ] . set_ylim ( 0 , chrom_length_sum )  else :                      pAxis [ i ] . set_xlim ( 0 , chrom_length_sum )   log . debug ( <str> . format ( len ( bigwig_scores ) ) ) bigwig_scores = np . array ( bigwig_scores ) if pFlipBigwigSign :                  log . info ( <str> ) bigwig_scores *= - 1  if pScaleFactorBigwig is not None and pScaleFactorBigwig != 1.0 :                  log . info ( <str> ) bigwig_scores *= pScaleFactorBigwig  if pValueMin is not None or pValueMax is not None :                  bigwig_scores = bigwig_scores . clip ( pValueMin , pValueMax )  if x_values is not None and bigwig_scores is not None :                  if pVertical :                      pAxis [ i ] . fill_between ( np . flip ( bigwig_scores , 0 ) , x_values , edgecolor = <str> )  else :                      pAxis [ i ] . fill_between ( x_values , 0 , bigwig_scores , edgecolor = <str> )      def plotLongRangeContacts ( pAxis , pNameOfLongRangeContactsFile , pHiCMatrix , pRegion , pChromosomeOrder ) :      x_list = [ ] y_list = [ ] log . debug ( <str> . format ( pRegion ) ) with open ( pNameOfLongRangeContactsFile , <str> ) as file :          for line in file . readlines ( ) :              line = toString ( line ) fields = line . strip ( ) . split ( <str> ) try :                  chrom_X , start_X , end_X = fields [ 0 : 3 ] chrom_Y , start_Y , end_Y = fields [ 3 : 6 ] if pRegion is not None and ( chrom_X != pRegion [ 0 ] or chrom_Y != pRegion [ 0 ] ) :                      continue  elif pChromosomeOrder is not None and ( chrom_X not in pChromosomeOrder or chrom_Y not in pChromosomeOrder ) :                      continue  x = int ( start_X ) y = int ( start_Y ) x_list . append ( x ) y_list . append ( y )  except Exception :                  pass   if pRegion is not None and ( int ( pRegion [ 1 ] ) != 0 and int ( pRegion [ 2 ] ) != 1e15 ) :              pAxis . set_xlim ( int ( pRegion [ 1 ] ) , int ( pRegion [ 2 ] ) ) pAxis . set_ylim ( int ( pRegion [ 1 ] ) , int ( pRegion [ 2 ] ) )  pAxis . plot ( x_list , y_list , <str> , lw = 2 , markerfacecolor = <str> , markeredgecolor = <str> )    