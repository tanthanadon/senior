import warnings import sys warnings . simplefilter ( action = <str> , category = RuntimeWarning ) warnings . simplefilter ( action = <str> , category = PendingDeprecationWarning ) import argparse from past . builtins import zip from scipy . sparse import lil_matrix from hicexplorer . iterativeCorrection import iterativeCorrection from hicmatrix import HiCMatrix as hm from hicexplorer . _version import __version__ from hicexplorer . utilities import toString from hicexplorer . utilities import convertNansToZeros , convertInfsToZeros from hicexplorer . utilities import check_cooler from krbalancing import * from matplotlib import use import matplotlib . pyplot as plt import matplotlib . gridspec as gridspec from matplotlib . ticker import MultipleLocator , FormatStrFormatter import numpy as np debug = 0 import logging log = logging . getLogger ( __name__ ) def parse_arguments ( args = None ) :      parser = argparse . ArgumentParser ( formatter_class = argparse . RawTextHelpFormatter , conflict_handler = <str> , description = ) parser . add_argument ( <str> , action = <str> , version = <str> . format ( __version__ ) ) subparsers = parser . add_subparsers ( title = <str> , dest = <str> , metavar = <str> , help = ) plot_mode = subparsers . add_parser ( <str> , formatter_class = argparse . ArgumentDefaultsHelpFormatter , help = , usage = <str> <str> <str> ) plot_modeRequired = plot_mode . add_argument_group ( <str> ) plot_modeRequired . add_argument ( <str> , <str> , help = <str> , required = True ) plot_modeRequired . add_argument ( <str> , <str> , help = <str> , required = True ) plot_modeOpt = plot_mode . add_argument_group ( <str> ) plot_modeOpt . add_argument ( <str> , help = <str> <str> <str> , default = None , nargs = <str> ) plot_modeOpt . add_argument ( <str> , help = <str> , default = None , type = float ) plot_modeOpt . add_argument ( <str> , help = <str> <str> <str> , action = <str> ) plot_modeOpt . add_argument ( <str> , help = <str> , action = <str> ) subparsers . add_parser ( <str> , formatter_class = argparse . ArgumentDefaultsHelpFormatter , parents = [ correct_subparser ( ) ] , help = , usage = <str> <str> <str> <str> ) return parser  def correct_subparser ( ) :      parser = argparse . ArgumentParser ( add_help = False ) parserRequired = parser . add_argument_group ( <str> ) parserRequired . add_argument ( <str> , <str> , help = <str> , required = True ) parserRequired . add_argument ( <str> , <str> , help = <str> <str> , required = True ) parserOpt = parser . add_argument_group ( <str> ) parserOpt . add_argument ( <str> , help = <str> <str> , type = str , metavar = <str> , default = <str> ) parserOpt . add_argument ( <str> , <str> , help = <str> <str> <str> <str> <str> <str> <str> <str> <str> <str> , type = float , nargs = 2 , default = None ) parserOpt . add_argument ( <str> , <str> , help = <str> <str> , type = int , metavar = <str> , default = 500 ) parserOpt . add_argument ( <str> , help = <str> <str> <str> <str> <str> <str> , type = float ) parserOpt . add_argument ( <str> , <str> , help = <str> <str> <str> , type = float ) parserOpt . add_argument ( <str> , help = <str> <str> <str> <str> , default = None , type = float ) parserOpt . add_argument ( <str> , help = <str> <str> <str> <str> , default = None , nargs = <str> ) parserOpt . add_argument ( <str> , <str> , help = <str> <str> , action = <str> ) parserOpt . add_argument ( <str> , help = <str> <str> <str> , action = <str> ) parserOpt . add_argument ( <str> , help = <str> , action = <str> ) parserOpt . add_argument ( <str> , action = <str> , version = <str> . format ( __version__ ) ) return parser  def iterative_correction ( matrix , args ) :      corrected_matrix , correction_factors = iterativeCorrection ( matrix , M = args . iterNum , verbose = args . verbose ) return corrected_matrix , correction_factors  def fill_gaps ( hic_ma , failed_bins , fill_contiguous = False ) :      log . debug ( <str> ) mat_size = hic_ma . matrix . shape [ 0 ] fill_ma = hic_ma . matrix . copy ( ) . tolil ( ) if fill_contiguous is True :          discontinuous_failed = failed_bins consecutive_failed_idx = np . array ( [ ] )  else :          consecutive_failed_idx = np . flatnonzero ( np . diff ( failed_bins ) == 1 ) consecutive_failed_idx = np . unique ( np . sort ( np . concatenate ( [ consecutive_failed_idx , consecutive_failed_idx + 1 ] ) ) ) discontinuous_failed = [ x for idx , x in enumerate ( failed_bins ) if idx not in consecutive_failed_idx ]  log . debug ( <str> . format ( len ( discontinuous_failed ) ) ) for missing_bin in discontinuous_failed :          if 0 < missing_bin < mat_size - 1 :              fill_ma [ missing_bin , 1 : mat_size - 1 ] = ( hic_ma . matrix [ missing_bin - 1 , : mat_size - 2 ] + hic_ma . matrix [ missing_bin + 1 , 2 : ] ) / 2 fill_ma [ 1 : mat_size - 1 , missing_bin ] = ( hic_ma . matrix [ : mat_size - 2 , missing_bin - 1 ] + hic_ma . matrix [ 2 : , missing_bin + 1 ] ) / 2   for bin_a in discontinuous_failed :          for bin_b in discontinuous_failed :              if 0 < bin_a < mat_size and 0 < bin_b < mat_size :                  fill_value = np . mean ( [ hic_ma . matrix [ bin_a - 1 , bin_b - 1 ] , hic_ma . matrix [ bin_a - 1 , bin_b + 1 ] , hic_ma . matrix [ bin_a + 1 , bin_b - 1 ] , hic_ma . matrix [ bin_a + 1 , bin_b + 1 ] , ] ) fill_ma [ bin_a - 1 , bin_b ] = fill_value fill_ma [ bin_a + 1 , bin_b ] = fill_value fill_ma [ bin_a , bin_b - 1 ] = fill_value fill_ma [ bin_a , bin_b + 1 ] = fill_value    return fill_ma . tocsr ( ) , np . sort ( failed_bins [ consecutive_failed_idx ] )  class MAD ( object ) :      def __init__ ( self , points ) :          self . mad_b_value = 0.6745 if len ( points . shape ) == 1 :              points = points [ : , None ]  self . median = np . median ( points [ points > 0 ] , axis = 0 ) diff = np . sum ( ( points - self . median ) , axis = - 1 ) self . med_abs_deviation = np . median ( np . abs ( diff ) ) self . modified_z_score = self . mad_b_value * diff / self . med_abs_deviation  def get_motified_zscores ( self ) :          return self . modified_z_score  def is_outlier ( self , lower_threshold , upper_threshold ) :          return ( self . modified_z_score < lower_threshold ) | ( self . modified_z_score > upper_threshold )  def value_to_mad ( self , value ) :          log . debug ( <str> . format ( self . median ) ) diff = value - self . median log . debug ( <str> . format ( diff ) ) log . debug ( <str> . format ( self . med_abs_deviation ) ) log . debug ( <str> . format ( self . mad_b_value ) ) log . debug ( <str> . format ( self . mad_b_value * diff / self . med_abs_deviation ) ) if self . med_abs_deviation == 0.0 :              return self . mad_b_value * diff  return self . mad_b_value * diff / self . med_abs_deviation  def mad_to_value ( self , mad ) :          return ( mad * self . med_abs_deviation / self . mad_b_value ) + self . median   def plot_total_contact_dist ( hic_ma , args ) :      use ( <str> ) majorlocator = MultipleLocator ( 1 ) majorformatter = FormatStrFormatter ( <str> ) minorlocator = MultipleLocator ( 0.2 ) def plot_histogram ( row_sum_values , mad_values , ax1 , title = None ) :          if args . xMax :              ax1 . set_xlim ( ax1 . get_xlim ( ) [ 0 ] , args . xMax ) row_sum_values = row_sum_values [ row_sum_values < args . xMax ]  ax1 . set_xlabel ( <str> ) ax1 . set_ylabel ( <str> ) ax1 . patch . set_visible ( False ) dist , bin_s , __ = ax1 . hist ( row_sum_values , 100 , color = <str> ) ax2 = ax1 . twiny ( ) ax2 . set_xlabel ( <str> ) ax2 . xaxis . set_major_locator ( majorlocator ) ax2 . xaxis . set_major_formatter ( majorformatter ) ax2 . xaxis . grid ( True , which = <str> ) ax2 . xaxis . set_minor_locator ( minorlocator ) log . debug ( <str> . format ( ax1 . get_xlim ( ) ) ) log . debug ( <str> . format ( np . array ( ax1 . get_xlim ( ) ) ) ) log . debug ( <str> . format ( mad_values . value_to_mad ( np . array ( ax1 . get_xlim ( ) ) ) ) ) ax2 . set_xlim ( mad_values . value_to_mad ( np . array ( ax1 . get_xlim ( ) ) ) ) local_min = [ x for x , y in enumerate ( dist ) if 1 <= x < len ( dist ) - 1 and dist [ x - 1 ] > y < dist [ x + 1 ] ] if len ( local_min ) > 0 :              threshold = bin_s [ local_min [ 0 ] ]  else :              threshold = None  if threshold :              mad_threshold = mad_values . value_to_mad ( threshold ) ymin , ymax = ax2 . get_ylim ( ) ax2 . vlines ( mad_threshold , ymin , ymax ) if title :                  log . info ( <str> . format ( title , mad_threshold ) )  else :                  log . info ( <str> . format ( mad_threshold ) )    hic_ma . matrix = convertNansToZeros ( hic_ma . matrix ) hic_ma . matrix = convertInfsToZeros ( hic_ma . matrix ) if args . perchr :          chroms = hic_ma . getChrNames ( ) if len ( chroms ) > 30 :              log . warning ( <str> <str> <str> )  num_rows = int ( np . ceil ( float ( len ( chroms ) ) / 5 ) ) num_cols = min ( len ( chroms ) , 5 ) grids = gridspec . GridSpec ( num_rows , num_cols ) fig = plt . figure ( figsize = ( 6 * num_cols , 5 * num_rows ) ) ax = { } for plot_num , chrname in enumerate ( chroms ) :              log . info ( <str> . format ( chrname ) ) chr_range = hic_ma . getChrBinRange ( chrname ) chr_submatrix = hic_ma . matrix [ chr_range [ 0 ] : chr_range [ 1 ] , chr_range [ 0 ] : chr_range [ 1 ] ] row_sum = np . asarray ( chr_submatrix . sum ( axis = 1 ) ) . flatten ( ) row_sum = row_sum - chr_submatrix . diagonal ( ) mad = MAD ( row_sum ) modified_z_score = mad . get_motified_zscores ( ) row_sum = row_sum [ modified_z_score < 5 ] col = plot_num % num_cols row = plot_num // num_cols ax [ chrname ] = fig . add_subplot ( grids [ row , col ] ) plot_histogram ( row_sum , mad , ax [ chrname ] , title = chrname ) ax [ chrname ] . set_title ( chrname )   else :          fig = plt . figure ( ) row_sum = np . asarray ( hic_ma . matrix . sum ( axis = 1 ) ) . flatten ( ) row_sum = row_sum - hic_ma . matrix . diagonal ( ) mad = MAD ( row_sum ) modified_z_score = mad . get_motified_zscores ( ) row_sum = row_sum [ modified_z_score < 5 ] ax = fig . add_subplot ( 111 ) plot_histogram ( row_sum , mad , ax )  plt . tight_layout ( ) plt . savefig ( args . plotName ) plt . close ( )  def filter_by_zscore ( hic_ma , lower_threshold , upper_threshold , perchr = False ) :      to_remove = [ ] if perchr :          for chrname in list ( hic_ma . interval_trees ) :              chr_range = hic_ma . getChrBinRange ( chrname ) chr_submatrix = hic_ma . matrix [ chr_range [ 0 ] : chr_range [ 1 ] , chr_range [ 0 ] : chr_range [ 1 ] ] chr_submatrix . data [ np . isnan ( chr_submatrix . data ) ] = 0 row_sum = np . asarray ( chr_submatrix . sum ( axis = 1 ) ) . flatten ( ) row_sum = row_sum - chr_submatrix . diagonal ( ) mad = MAD ( row_sum ) problematic = np . flatnonzero ( mad . is_outlier ( lower_threshold , upper_threshold ) ) problematic += chr_range [ 0 ] if len ( problematic ) == 0 :                  log . warn ( <str> <str> . format ( chrname , lower_threshold , upper_threshold ) )  to_remove . extend ( problematic )   else :          row_sum = np . asarray ( hic_ma . matrix . sum ( axis = 1 ) ) . flatten ( ) row_sum = row_sum - hic_ma . matrix . diagonal ( ) mad = MAD ( row_sum ) to_remove = np . flatnonzero ( mad . is_outlier ( lower_threshold , upper_threshold ) )  return sorted ( to_remove )  def main ( args = None ) :      args = parse_arguments ( ) . parse_args ( args ) if args . verbose :          log . setLevel ( logging . INFO )  if check_cooler ( args . matrix ) and args . chromosomes is not None and len ( args . chromosomes ) == 1 :          ma = hm . hiCMatrix ( args . matrix , pChrnameList = toString ( args . chromosomes ) )  else :          ma = hm . hiCMatrix ( args . matrix ) if args . chromosomes :              ma . reorderChromosomes ( toString ( args . chromosomes ) )   if <str> in args :          if args . correctionMethod == <str> :              row_sum = np . asarray ( ma . matrix . sum ( axis = 1 ) ) . flatten ( ) log . info ( <str> . format ( sum ( row_sum == 0 ) ) ) ma . maskBins ( np . flatnonzero ( row_sum == 0 ) ) matrix_shape = ma . matrix . shape   if <str> in args :          row_sum = np . asarray ( ma . matrix . sum ( axis = 1 ) ) . flatten ( ) log . info ( <str> . format ( sum ( row_sum == 0 ) ) ) ma . maskBins ( np . flatnonzero ( row_sum == 0 ) ) matrix_shape = ma . matrix . shape  ma . matrix = convertNansToZeros ( ma . matrix ) ma . matrix = convertInfsToZeros ( ma . matrix ) ma . matrix = ma . matrix . astype ( np . float64 , copy = True ) log . debug ( <str> . format ( ma . matrix . indices . dtype ) ) log . debug ( <str> . format ( ma . matrix . data . dtype ) ) log . debug ( <str> . format ( ma . matrix . indptr . dtype ) ) if <str> in args :          plot_total_contact_dist ( ma , args ) log . info ( <str> . format ( args . plotName ) ) return  log . info ( <str> . format ( len ( ma . matrix . data ) , float ( len ( ma . matrix . data ) ) / ( ma . matrix . shape [ 0 ] ** 2 ) ) ) if args . skipDiagonal :          ma . diagflat ( value = 0 )  total_filtered_out = set ( ) if args . correctionMethod == <str> :          if not args . filterThreshold :              log . error ( <str> ) sys . exit ( 1 )  outlier_regions = filter_by_zscore ( ma , args . filterThreshold [ 0 ] , args . filterThreshold [ 1 ] , perchr = args . perchr ) pct_outlier = 100 * float ( len ( outlier_regions ) ) / ma . matrix . shape [ 0 ] ma . printchrtoremove ( outlier_regions , label = <str> <str> . format ( pct_outlier , ma . matrix . shape [ 0 ] ) , restore_masked_bins = False ) assert matrix_shape == ma . matrix . shape ma . maskBins ( outlier_regions ) total_filtered_out = set ( outlier_regions ) if args . sequencedCountCutoff and 0 < args . sequencedCountCutoff < 1 :              chrom , _ , _ , coverage = zip ( * ma . cut_intervals ) assert type ( coverage [ 0 ] ) == np . float64 failed_bins = np . flatnonzero ( np . array ( coverage ) < args . sequencedCountCutoff ) ma . printchrtoremove ( failed_bins , label = <str> , restore_masked_bins = False ) ma . maskBins ( failed_bins ) total_filtered_out = set ( failed_bins )  if args . transCutoff and 0 < args . transCutoff < 100 :              cutoff = float ( args . transCutoff ) / 100 ma . truncTrans ( high = cutoff ) pre_row_sum = np . asarray ( ma . matrix . sum ( axis = 1 ) ) . flatten ( )   correction_factors = [ ] corrected_matrix = lil_matrix ( ma . matrix . shape ) if args . perchr :          for chrname in list ( ma . interval_trees ) :              chr_range = ma . getChrBinRange ( chrname ) chr_submatrix = ma . matrix [ chr_range [ 0 ] : chr_range [ 1 ] , chr_range [ 0 ] : chr_range [ 1 ] ] if args . correctionMethod == <str> :                  _matrix , _corr_factors = iterative_correction ( chr_submatrix , args ) corrected_matrix [ chr_range [ 0 ] : chr_range [ 1 ] , chr_range [ 0 ] : chr_range [ 1 ] ] = _matrix correction_factors . append ( _corr_factors )  else :                  assert ( args . correctionMethod == <str> ) log . debug ( <str> ) kr = kr_balancing ( chr_submatrix . shape [ 0 ] , chr_submatrix . shape [ 1 ] , chr_submatrix . count_nonzero ( ) , chr_submatrix . indptr . astype ( np . int64 , copy = False ) , chr_submatrix . indices . astype ( np . int64 , copy = False ) , chr_submatrix . data . astype ( np . float64 , copy = False ) ) kr . computeKR ( ) if args . outFileName . endswith ( <str> ) :                      corrected_matrix [ chr_range [ 0 ] : chr_range [ 1 ] , chr_range [ 0 ] : chr_range [ 1 ] ] = kr . get_normalised_matrix ( True )  correction_factors . append ( kr . get_normalisation_vector ( False ) . todense ( ) )   correction_factors = np . concatenate ( correction_factors )  else :          if args . correctionMethod == <str> :              corrected_matrix , correction_factors = iterative_correction ( ma . matrix , args ) ma . setMatrixValues ( corrected_matrix )  else :              assert ( args . correctionMethod == <str> ) log . debug ( <str> ) kr = kr_balancing ( ma . matrix . shape [ 0 ] , ma . matrix . shape [ 1 ] , ma . matrix . count_nonzero ( ) , ma . matrix . indptr . astype ( np . int64 , copy = False ) , ma . matrix . indices . astype ( np . int64 , copy = False ) , ma . matrix . data . astype ( np . float64 , copy = False ) ) log . debug ( <str> ) kr . computeKR ( ) log . debug ( <str> ) correction_factors = kr . get_normalisation_vector ( False ) . todense ( ) if args . outFileName . endswith ( <str> ) :                  corrected_matrix = kr . get_normalised_matrix ( True )    if args . outFileName . endswith ( <str> ) :          ma . setMatrixValues ( corrected_matrix )  ma . setCorrectionFactors ( correction_factors ) log . debug ( <str> . format ( correction_factors [ : 10 ] ) ) if args . inflationCutoff and args . inflationCutoff > 0 and args . correctionMethod == <str> :          after_row_sum = np . asarray ( corrected_matrix . sum ( axis = 1 ) ) . flatten ( ) to_remove = np . flatnonzero ( after_row_sum / pre_row_sum >= args . inflationCutoff ) ma . printchrtoremove ( to_remove , label = <str> <str> . format ( args . inflationCutoff ) , restore_masked_bins = False ) total_filtered_out = total_filtered_out . union ( to_remove ) ma . maskBins ( to_remove )  ma . printchrtoremove ( sorted ( list ( total_filtered_out ) ) , label = <str> , restore_masked_bins = False ) ma . save ( args . outFileName , pApplyCorrection = False )   