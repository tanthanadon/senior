import warnings warnings . simplefilter ( action = <str> , category = UserWarning ) warnings . simplefilter ( action = <str> , category = RuntimeWarning ) warnings . simplefilter ( action = <str> , category = PendingDeprecationWarning ) import argparse import os import numpy as np from past . builtins import map from scipy . sparse import triu from scipy . stats import pearsonr , spearmanr from hicmatrix import HiCMatrix as hm from hicexplorer . _version import __version__ from hicexplorer . utilities import check_cooler from matplotlib import use as mplt_use mplt_use ( <str> ) import matplotlib . pyplot as plt import matplotlib . gridspec as gridspec from matplotlib . ticker import FixedLocator import logging log = logging . getLogger ( __name__ ) def parse_arguments ( args = None ) :      parser = argparse . ArgumentParser ( formatter_class = argparse . ArgumentDefaultsHelpFormatter , add_help = False , description = <str> <str> <str> <str> <str> <str> <str> <str> ) parserRequired = parser . add_argument_group ( <str> ) parserRequired . add_argument ( <str> , <str> , help = <str> <str> <str> , nargs = <str> , required = True ) parserHeatmap = parser . add_argument_group ( <str> , description = <str> ) parserHeatmap . add_argument ( <str> , <str> , default = None , help = <str> <str> , type = float ) parserHeatmap . add_argument ( <str> , <str> , default = None , help = <str> <str> , type = float ) parserHeatmap . add_argument ( <str> , default = <str> , metavar = <str> , help = <str> <str> <str> ) parserHeatmap . add_argument ( <str> , metavar = <str> , help = <str> <str> <str> <str> , choices = [ <str> , <str> , <str> , <str> , <str> ] ) parserHeatmap . add_argument ( <str> , help = <str> <str> , action = <str> , required = False ) parserOpt = parser . add_argument_group ( <str> ) parserOpt . add_argument ( <str> , help = <str> , choices = [ <str> , <str> ] , default = <str> ) parserOpt . add_argument ( <str> , help = <str> <str> <str> , action = <str> ) parserOpt . add_argument ( <str> , <str> , metavar = <str> , help = <str> <str> <str> <str> , nargs = <str> ) parserOpt . add_argument ( <str> , help = <str> <str> <str> <str> <str> ) parserOpt . add_argument ( <str> , <str> , help = <str> , required = True ) parserOpt . add_argument ( <str> , <str> , help = <str> , required = True ) parserOpt . add_argument ( <str> , help = <str> <str> , default = None , nargs = <str> ) parserOpt . add_argument ( <str> , help = <str> <str> <str> , required = False , default = 4 , type = int ) parserOpt . add_argument ( <str> , <str> , action = <str> , help = <str> ) parserOpt . add_argument ( <str> , action = <str> , version = <str> . format ( __version__ ) ) return parser  def plot_correlation ( corr_matrix , labels , plot_filename , vmax = None , vmin = None , colormap = <str> , image_format = None ) :      import scipy . cluster . hierarchy as sch num_rows = corr_matrix . shape [ 0 ] if vmax is None :          vmax = 1  if vmin is None :          vmin = 0 if corr_matrix . min ( ) >= 0 else - 1  fig = plt . figure ( figsize = ( 10.5 , 9.5 ) ) axdendro = fig . add_axes ( [ 0.02 , 0.1 , 0.1 , 0.7 ] ) axdendro . set_axis_off ( ) y_var = sch . linkage ( corr_matrix , method = <str> ) z_var = sch . dendrogram ( y_var , orientation = <str> , link_color_func = lambda k : <str> ) axdendro . set_xticks ( [ ] ) axdendro . set_yticks ( [ ] ) cmap = plt . get_cmap ( colormap ) cmap = cmap . from_list ( colormap + <str> , cmap ( [ 0.0 , 0.8 ] ) ) axmatrix = fig . add_axes ( [ 0.13 , 0.1 , 0.6 , 0.7 ] ) index = z_var [ <str> ] corr_matrix = corr_matrix [ index , : ] corr_matrix = corr_matrix [ : , index ] img_mat = axmatrix . matshow ( corr_matrix , aspect = <str> , origin = <str> , cmap = cmap , extent = ( 0 , num_rows , 0 , num_rows ) , vmax = vmax , vmin = vmin ) axmatrix . yaxis . tick_right ( ) axmatrix . set_yticks ( np . arange ( corr_matrix . shape [ 0 ] ) + 0.5 ) axmatrix . set_yticklabels ( np . array ( labels ) . astype ( <str> ) [ index ] , fontsize = 14 ) axmatrix . set_xticks ( np . arange ( corr_matrix . shape [ 0 ] ) + 0.5 ) axmatrix . set_xticklabels ( np . array ( labels ) . astype ( <str> ) [ index ] , fontsize = 14 , rotation = 45 , ha = <str> ) axcolor = fig . add_axes ( [ 0.13 , 0.065 , 0.6 , 0.02 ] ) plt . colorbar ( img_mat , cax = axcolor , orientation = <str> ) for row in range ( num_rows ) :          for col in range ( num_rows ) :              axmatrix . text ( row + 0.5 , col + 0.5 , <str> . format ( corr_matrix [ row , col ] ) , ha = <str> , va = <str> )   fig . savefig ( plot_filename , format = image_format )  def get_vectors ( mat1 , mat2 ) :      assert mat1 . shape == mat2 . shape , <str> <str> _mat = mat1 + mat2 _mat . data += 1 values1 = ( _mat - mat1 ) . data - 1 values2 = ( _mat - mat2 ) . data - 1 return values1 , values2  def main ( args = None ) :      args = parse_arguments ( ) . parse_args ( args ) if args . labels and len ( args . matrices ) != len ( args . labels ) :          log . error ( <str> ) exit ( 0 )  if not args . labels :          args . labels = map ( lambda x : os . path . basename ( x ) , args . matrices )  num_files = len ( args . matrices ) map ( lambda x : os . path . basename ( x ) , args . matrices ) results = np . zeros ( ( num_files , num_files ) , dtype = <str> ) rows , cols = np . triu_indices ( num_files ) correlation_opts = { <str> : spearmanr , <str> : pearsonr } hic_mat_list = [ ] max_value = None min_value = None all_mat = None all_nan = [ ] for i , matrix in enumerate ( args . matrices ) :          log . debug ( <str> . format ( matrix ) ) if ( check_cooler ( args . matrices [ i ] ) ) and args . chromosomes is not None and len ( args . chromosomes ) == 1 :              _mat = hm . hiCMatrix ( matrix , pChrnameList = args . chromosomes )  else :              _mat = hm . hiCMatrix ( matrix ) if args . chromosomes :                  _mat . keepOnlyTheseChr ( args . chromosomes )  _mat . filterOutInterChrCounts ( )  _mat . diagflat ( 0 ) log . debug ( <str> . format ( matrix ) ) bin_size = _mat . getBinSize ( ) all_nan = np . unique ( np . concatenate ( [ all_nan , _mat . nan_bins ] ) ) _mat = triu ( _mat . matrix , k = 0 , format = <str> ) if args . range :              min_dist , max_dist = args . range . split ( <str> ) min_dist = int ( min_dist ) max_dist = int ( max_dist ) if max_dist < bin_size :                  log . error ( <str> . format ( bin_size ) ) exit ( )  max_depth_in_bins = int ( max_dist / bin_size ) max_dist = int ( max_dist ) // bin_size min_dist = int ( min_dist ) // bin_size _mat = triu ( _mat , k = 0 , format = <str> ) - triu ( _mat , k = max_depth_in_bins , format = <str> ) _mat . eliminate_zeros ( ) _mat_coo = _mat . tocoo ( ) dist = _mat_coo . col - _mat_coo . row keep = np . flatnonzero ( ( dist <= max_dist ) & ( dist >= min_dist ) ) _mat_coo . data = _mat_coo . data [ keep ] _mat_coo . row = _mat_coo . row [ keep ] _mat_coo . col = _mat_coo . col [ keep ] _mat = _mat_coo . tocsr ( )  else :              _mat = triu ( _mat , k = 0 , format = <str> )  if args . log1p :              _mat . data = np . log1p ( _mat . data )  if all_mat is None :              all_mat = _mat  else :              all_mat = all_mat + _mat  if max_value is None or max_value < _mat . data . max ( ) :              max_value = _mat . data . max ( )  if min_value is None or min_value > _mat . data . min ( ) :              min_value = _mat . data . min ( )  hic_mat_list . append ( _mat )  rows_keep = cols_keep = np . delete ( list ( range ( all_mat . shape [ 1 ] ) ) , all_nan ) all_mat = all_mat [ rows_keep , : ] [ : , cols_keep ] big_mat = None for mat in hic_mat_list :          mat = mat [ rows_keep , : ] [ : , cols_keep ] sample_vector = ( mat + all_mat ) . data - all_mat . data if big_mat is None :              big_mat = sample_vector  else :              big_mat = np . vstack ( [ big_mat , sample_vector ] )   big_mat = np . ma . masked_invalid ( big_mat ) . T grids = gridspec . GridSpec ( num_files , num_files ) grids . update ( wspace = 0 , hspace = 0 ) fig = plt . figure ( figsize = ( 2 * num_files , 2 * num_files ) ) plt . rcParams [ <str> ] = 8.0 min_value = int ( big_mat . min ( ) ) max_value = int ( big_mat . max ( ) ) if ( min_value % 2 == 0 and max_value % 2 == 0 ) or ( min_value % 1 == 0 and max_value % 2 == 1 ) :          max_value += 1  if args . log1p :          major_locator = FixedLocator ( list ( range ( min_value , max_value , 2 ) ) ) minor_locator = FixedLocator ( list ( range ( min_value , max_value , 1 ) ) )  for index in range ( len ( rows ) ) :          row = rows [ index ] col = cols [ index ] if row == col :              results [ row , col ] = 1 ax = fig . add_subplot ( grids [ row , col ] ) ax . text ( 0.6 , 0.6 , args . labels [ row ] , verticalalignment = <str> , horizontalalignment = <str> , fontsize = 10 , fontweight = <str> , transform = ax . transAxes ) ax . set_axis_off ( ) continue  log . debug ( <str> . format ( args . matrices [ row ] , args . matrices [ col ] ) ) _mat = big_mat [ : , [ row , col ] ] _mat = _mat [ _mat . sum ( axis = 1 ) > 1 , : ] vector1 = _mat [ : , 0 ] vector2 = _mat [ : , 1 ] results [ row , col ] = correlation_opts [ args . method ] ( vector1 , vector2 ) [ 0 ] ax = fig . add_subplot ( grids [ row , col ] ) if args . log1p :              ax . xaxis . set_major_locator ( major_locator ) ax . xaxis . set_minor_locator ( minor_locator ) ax . yaxis . set_major_locator ( major_locator ) ax . yaxis . set_minor_locator ( minor_locator )  ax . text ( 0.2 , 0.8 , <str> . format ( args . method , results [ row , col ] ) , horizontalalignment = <str> , transform = ax . transAxes ) ax . get_yaxis ( ) . set_tick_params ( which = <str> , left = <str> , right = <str> , direction = <str> ) ax . get_xaxis ( ) . set_tick_params ( which = <str> , top = <str> , bottom = <str> , direction = <str> ) if col != num_files - 1 :              ax . set_yticklabels ( [ ] )  else :              ax . yaxis . tick_right ( ) ax . get_yaxis ( ) . set_tick_params ( which = <str> , left = <str> , right = <str> , direction = <str> )  if col - row == 1 :              ax . xaxis . tick_bottom ( ) ax . get_xaxis ( ) . set_tick_params ( which = <str> , top = <str> , bottom = <str> , direction = <str> )  else :              ax . set_xticklabels ( [ ] )  ax . hist2d ( vector1 , vector2 , bins = 150 , cmin = 0.1 )  fig . tight_layout ( ) log . debug ( <str> . format ( args . outFileNameScatter ) ) fig . savefig ( args . outFileNameScatter , bbox_inches = <str> ) results = results + np . triu ( results , 1 ) . T plot_correlation ( results , args . labels , args . outFileNameHeatmap , args . zMax , args . zMin , args . colorMap , image_format = args . plotFileFormat )   