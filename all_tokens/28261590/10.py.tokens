import warnings warnings . simplefilter ( action = <str> , category = RuntimeWarning ) warnings . simplefilter ( action = <str> , category = PendingDeprecationWarning ) import argparse from io import StringIO from multiprocessing import Process , Queue import time import numpy as np import cooler import matplotlib matplotlib . use ( <str> ) import matplotlib . pyplot as plt import matplotlib . patches as mpatches from scipy . stats import ranksums from hicmatrix import HiCMatrix as hm from hicexplorer . _version import __version__ from hicexplorer . utilities import toString from hicmatrix . HiCMatrix import check_cooler import logging log = logging . getLogger ( __name__ ) def parse_arguments ( args = None ) :      parser = argparse . ArgumentParser ( formatter_class = argparse . RawDescriptionHelpFormatter , add_help = False , description = ) parserRequired = parser . add_argument_group ( <str> ) parserRequired . add_argument ( <str> , <str> , help = <str> , nargs = <str> , required = True ) parserOpt = parser . add_argument_group ( <str> ) parserOpt . add_argument ( <str> , <str> , help = <str> , default = <str> ) parserOpt . add_argument ( <str> , <str> , help = <str> , default = <str> ) parserOpt . add_argument ( <str> , <str> , help = <str> , default = <str> ) parserOpt . add_argument ( <str> , <str> , help = <str> , default = 2000000 , type = int ) parserOpt . add_argument ( <str> , help = <str> , nargs = <str> ) parserOpt . add_argument ( <str> , <str> , help = <str> , required = False , default = 4 , type = int ) parserOpt . add_argument ( <str> , help = <str> <str> , type = int , default = 300 , required = False ) parserOpt . add_argument ( <str> , <str> , help = <str> , required = False , default = [ <str> , <str> , <str> , <str> , <str> , <str> ] , type = str , nargs = <str> ) parserOpt . add_argument ( <str> , <str> , action = <str> , help = <str> ) parserOpt . add_argument ( <str> , action = <str> , version = <str> . format ( __version__ ) ) return parser  def compute_relation_short_long_range ( pHiCMatrix , pChromosomes , pDistance , pIsCooler , pQueue ) :      svl_relations = [ ] sum_smaller = [ ] sum_greater = [ ] for chromosome in pChromosomes :          if pIsCooler :              hic_matrix_obj = hm . hiCMatrix ( pMatrixFile = pHiCMatrix , pChrnameList = [ chromosome ] ) max_distance = pDistance / hic_matrix_obj . getBinSize ( ) hic_matrix = hic_matrix_obj . matrix  else :              indices_chromosome = pHiCMatrix . getChrBinRange ( chromosome ) hic_matrix = pHiCMatrix . matrix [ indices_chromosome [ 0 ] : indices_chromosome [ 1 ] , indices_chromosome [ 0 ] : indices_chromosome [ 1 ] ] max_distance = pDistance / pHiCMatrix . getBinSize ( )  instances , features = hic_matrix . nonzero ( ) distances = np . absolute ( instances - features ) mask = distances <= max_distance sum_smaller_max_distance = np . sum ( hic_matrix . data [ mask ] ) sum_greater_max_distance = np . sum ( hic_matrix . data [ ~ mask ] ) svl_relation = sum_smaller_max_distance / sum_greater_max_distance if np . isinf ( svl_relation ) or np . isnan ( svl_relation ) :              continue  svl_relations . append ( svl_relation ) sum_smaller . append ( sum_smaller_max_distance ) sum_greater . append ( sum_greater_max_distance )  pQueue . put ( [ svl_relations , sum_smaller , sum_greater ] ) return  def main ( args = None ) :      args = parse_arguments ( ) . parse_args ( args ) short_v_long_range = [ ] sum_smaller = [ ] sum_greater = [ ] for matrix in args . matrices :          is_cooler = check_cooler ( matrix ) if not is_cooler :              hic_matrix = hm . hiCMatrix ( matrix )  else :              hic_matrix = matrix  if args . chromosomes is None :              if not is_cooler :                  chromosomes_list = list ( hic_matrix . chrBinBoundaries )  else :                  chromosomes_list = cooler . Cooler ( matrix ) . chromnames   else :              chromosomes_list = args . chromosomes  short_v_long_range_matrix_threads = [ None ] * args . threads sum_smaller_threads = [ None ] * args . threads sum_greater_threads = [ None ] * args . threads chromosomesListPerThread = len ( chromosomes_list ) // args . threads all_data_collected = False queue = [ None ] * args . threads process = [ None ] * args . threads thread_done = [ False ] * args . threads for i in range ( args . threads ) :              if i < args . threads - 1 :                  chromosomeListThread = chromosomes_list [ i * chromosomesListPerThread : ( i + 1 ) * chromosomesListPerThread ]  else :                  chromosomeListThread = chromosomes_list [ i * chromosomesListPerThread : ]  queue [ i ] = Queue ( ) process [ i ] = Process ( target = compute_relation_short_long_range , kwargs = dict ( pHiCMatrix = hic_matrix , pChromosomes = chromosomeListThread , pDistance = args . distance , pIsCooler = is_cooler , pQueue = queue [ i ] ) ) process [ i ] . start ( )  while not all_data_collected :              for i in range ( args . threads ) :                  if queue [ i ] is not None and not queue [ i ] . empty ( ) :                      short_v_long_range_matrix_threads [ i ] , sum_smaller_threads [ i ] , sum_greater_threads [ i ] = queue [ i ] . get ( ) queue [ i ] = None process [ i ] . join ( ) process [ i ] . terminate ( ) process [ i ] = None thread_done [ i ] = True   all_data_collected = True for thread in thread_done :                  if not thread :                      all_data_collected = False   time . sleep ( 1 )  short_v_long_range_matrix = [ item for sublist in short_v_long_range_matrix_threads for item in sublist ] sum_smaller_matrix = [ item for sublist in sum_smaller_threads for item in sublist ] sum_greater_matrix = [ item for sublist in sum_greater_threads for item in sublist ] short_v_long_range . append ( short_v_long_range_matrix ) sum_smaller . append ( sum_smaller_matrix ) sum_greater . append ( sum_greater_matrix )  log . debug ( short_v_long_range ) plt . ylabel ( <str> ) plt . tick_params ( axis = <str> , which = <str> , bottom = False , top = False , labelbottom = False ) box_plot = plt . boxplot ( short_v_long_range , patch_artist = True ) legend_handels_color = [ ] for i , patch in enumerate ( box_plot [ <str> ] ) :          patch . set_facecolor ( args . colorList [ i % len ( args . colorList ) ] ) legend_handels_color . append ( mpatches . Patch ( color = args . colorList [ i % len ( args . colorList ) ] , label = args . matrices [ i ] . split ( <str> ) [ - 1 ] ) )  plt . legend ( handles = legend_handels_color ) plt . savefig ( args . plotFileName , dpi = args . dpi ) if len ( args . matrices ) > 1 :          p_values = [ ] for i , sample in enumerate ( short_v_long_range ) :              for sample2 in short_v_long_range [ i + 1 : ] :                  statistic , significance_level = ranksums ( sample , sample2 ) p_values . append ( significance_level )   log . debug ( <str> . format ( p_values ) ) with open ( args . outFileName , <str> ) as file :              header = <str> + __version__ + <str> header += <str> header += <str> + str ( args . distance ) + <str> file . write ( header ) counter = 0 for i , matrix_0 in enumerate ( args . matrices ) :                  for j , matrix_1 in enumerate ( args . matrices [ i + 1 : ] ) :                      file . write ( matrix_0 + <str> + matrix_1 + <str> + str ( p_values [ counter ] ) + <str> ) counter += 1     with open ( args . outFileNameData , <str> ) as file :          header = <str> + __version__ + <str> header += <str> header += <str> + str ( args . distance ) + <str> matrices_names = <str> . join ( args . matrices ) header += <str> . format ( matrices_names ) header += <str> header += <str> . join ( [ <str> , <str> . format ( args . distance ) , <str> . format ( args . distance ) ] * len ( args . matrices ) ) header += <str> file . write ( header ) counter = 0 for i , chromosome in enumerate ( chromosomes_list ) :              file . write ( <str> . format ( chromosome ) ) for j , matrix in enumerate ( args . matrices ) :                  if i < len ( short_v_long_range [ j ] ) :                      file . write ( <str> . format ( short_v_long_range [ j ] [ i ] , sum_smaller [ j ] [ i ] , sum_greater [ j ] [ i ] ) )  else :                      file . write ( <str> )   file . write ( <str> )     