import warnings warnings . simplefilter ( action = <str> , category = RuntimeWarning ) warnings . simplefilter ( action = <str> , category = PendingDeprecationWarning ) from scipy . sparse import coo_matrix , dia_matrix , triu import numpy as np import time import logging log = logging . getLogger ( __name__ ) def reduce_matrix ( matrix , bins_to_merge , use_triu = True , diagonal = False ) :      if use_triu :          ma = triu ( matrix , k = 0 , format = <str> )  else :          ma = matrix . tocoo ( )  M = len ( bins_to_merge ) start_time = time . time ( ) if M == ma . shape [ 0 ] :          return matrix  num_nan = len ( np . flatnonzero ( np . isnan ( np . array ( ma . data ) ) ) ) if num_nan > 0 :          log . warning ( <str> . format ( num_nan ) )  map_ = np . zeros ( ma . shape [ 0 ] , dtype = int ) - 1 for k , v in enumerate ( bins_to_merge ) :          for x in v :              map_ [ x ] = k   new_row = np . take ( map_ , ma . row ) new_col = np . take ( map_ , ma . col ) keep = ( new_row > - 1 ) & ( new_col > - 1 ) ma . data = ma . data [ keep ] new_row = new_row [ keep ] new_col = new_col [ keep ] uniq , bin_array = np . unique ( new_row + 1j * new_col , return_inverse = True ) elapsed_time = time . time ( ) - start_time start_time = time . time ( ) log . debug ( <str> . format ( elapsed_time ) ) sum_array = np . bincount ( bin_array , weights = ma . data ) uniq , ind = np . unique ( bin_array , return_index = True ) new_row_ = new_row [ ind ] new_col_ = new_col [ ind ] result = coo_matrix ( ( sum_array , ( new_row_ , new_col_ ) ) , shape = ( M , M ) , dtype = ma . dtype ) elapsed_time = time . time ( ) - start_time log . debug ( <str> . format ( elapsed_time ) ) if use_triu :          diagmatrix = dia_matrix ( ( [ result . diagonal ( ) ] , [ 0 ] ) , shape = ( M , M ) , dtype = ma . dtype ) if diagonal is False :              diagmatrix *= 2  matrix = result + result . T - diagmatrix  else :          matrix = result  matrix . eliminate_zeros ( ) return matrix   