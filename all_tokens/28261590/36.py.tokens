import argparse import sys import os import errno from multiprocessing import Process , Queue import time import math import logging log = logging . getLogger ( __name__ ) import numpy as np import hicmatrix . HiCMatrix as hm from hicexplorer import utilities from . lib import Viewpoint from hicexplorer . _version import __version__ def parse_arguments ( args = None ) :      parser = argparse . ArgumentParser ( add_help = False , formatter_class = argparse . RawDescriptionHelpFormatter , description = ) parserRequired = parser . add_argument_group ( <str> ) parserRequired . add_argument ( <str> , <str> , help = <str> , required = True , nargs = <str> ) parserRequired . add_argument ( <str> , help = <str> <str> <str> , required = True , type = int , nargs = 2 ) parserRequired . add_argument ( <str> , <str> , help = <str> <str> , required = True ) parserRequired . add_argument ( <str> , <str> , help = <str> , required = True ) parserOpt = parser . add_argument_group ( <str> ) parserOpt . add_argument ( <str> , <str> , help = <str> , required = False , default = 4 , type = int ) parserOpt . add_argument ( <str> , help = <str> , type = int , default = 5 ) parserOpt . add_argument ( <str> , <str> , help = <str> ) parserOpt . add_argument ( <str> , <str> , help = <str> , required = False , default = 500000 , type = int ) parserOpt . add_argument ( <str> , <str> , help = <str> , required = False , default = 1 , type = int ) parserOpt . add_argument ( <str> , <str> , help = <str> , required = False , action = <str> ) parserOpt . add_argument ( <str> , <str> , help = <str> , required = False , default = <str> ) parserOpt . add_argument ( <str> , <str> , action = <str> , help = <str> ) parserOpt . add_argument ( <str> , action = <str> , version = <str> . format ( __version__ ) ) return parser  def adjustViewpointData ( pViewpointObj , pData , pBackground , pReferencePoint , pRegionStart , pRegionEnd ) :      data_viewpoint = { } data_background = { } view_point_start , _ = pViewpointObj . getReferencePointAsMatrixIndices ( pReferencePoint ) view_point_range_start , view_point_range_end = pViewpointObj . getViewpointRangeAsMatrixIndices ( pReferencePoint [ 0 ] , pRegionStart , pRegionEnd ) for i , data in zip ( range ( view_point_range_start , view_point_range_end , 1 ) , pData ) :          relative_position = i - view_point_start data_viewpoint [ relative_position ] = data  for i , data in zip ( range ( view_point_range_start , view_point_range_end , 1 ) , pBackground ) :          relative_position = i - view_point_start data_background [ relative_position ] = data  for i in data_background :          if i in data_viewpoint :              continue  else :              data_viewpoint [ i ] = 0   data = np . fromiter ( data_viewpoint . values ( ) , dtype = np . float32 ) background = list ( data_background . values ( ) ) return data , background  def compute_x_fold ( pDataList , pBackgroundList ) :      return pDataList / pBackgroundList  def compute_viewpoint ( pViewpointObj , pArgs , pQueue , pReferencePoints , pGeneList , pMatrix , pBackgroundModel , pBackgroundModelRelativeInteractions , pOutputFolder ) :      file_list = [ ] for i , referencePoint in enumerate ( pReferencePoints ) :          region_start_fixed , region_end_fixed , range_fixed = pViewpointObj . calculateViewpointRange ( referencePoint , ( pArgs . fixateRange , pArgs . fixateRange ) ) intermediate_viewpoint = pViewpointObj . computeViewpoint ( referencePoint , referencePoint [ 0 ] , region_start_fixed , region_end_fixed ) denominator_relative_interactions = np . sum ( intermediate_viewpoint ) region_start , region_end , _range = pViewpointObj . calculateViewpointRange ( referencePoint , pArgs . range ) data_list = pViewpointObj . computeViewpoint ( referencePoint , referencePoint [ 0 ] , region_start , region_end ) _backgroundModelNBinom = pViewpointObj . interactionBackgroundData ( pBackgroundModel , _range ) background_relative_interaction = pViewpointObj . interactionBackgroundData ( pBackgroundModelRelativeInteractions , _range ) . flatten ( ) data_list_relative = data_list if len ( data_list ) != len ( _backgroundModelNBinom ) :              data_list , _backgroundModelNBinom , = adjustViewpointData ( pViewpointObj , data_list , _backgroundModelNBinom , referencePoint , region_start , region_end )  if len ( data_list ) != len ( background_relative_interaction ) :              _ , background_relative_interaction = adjustViewpointData ( pViewpointObj , data_list_relative , background_relative_interaction , referencePoint , region_start , region_end )  if pArgs . averageContactBin > 0 and len ( data_list ) >= pArgs . averageContactBin :              data_list = pViewpointObj . smoothInteractionValues ( data_list , pArgs . averageContactBin )  data_list_raw = np . copy ( data_list ) data_list = pViewpointObj . computeRelativeValues ( data_list , denominator_relative_interactions ) x_fold_list = compute_x_fold ( data_list , background_relative_interaction ) p_value_list = pViewpointObj . pvalues ( _backgroundModelNBinom , data_list_raw ) region_start_range , region_end_range , _ = pViewpointObj . calculateViewpointRange ( referencePoint , ( pArgs . range [ 0 ] , pArgs . range [ 1 ] ) ) interaction_data = pViewpointObj . createInteractionFileData ( referencePoint , referencePoint [ 0 ] , region_start_range , region_end_range , data_list , data_list_raw , pGeneList [ i ] , denominator_relative_interactions ) referencePointString = <str> . join ( str ( j ) for j in referencePoint ) region_start_in_units = utilities . in_units ( region_start ) region_end_in_units = utilities . in_units ( region_end ) denominator_relative_interactions_str = <str> denominator_relative_interactions_str += str ( denominator_relative_interactions ) header_information = <str> + __version__ + <str> header_information += <str> . join ( [ pMatrix , referencePointString , str ( region_start_in_units ) , str ( region_end_in_units ) , pGeneList [ i ] , denominator_relative_interactions_str ] ) header_information += <str> matrix_name = <str> . join ( pMatrix . split ( <str> ) [ - 1 ] . split ( <str> ) [ : - 1 ] ) matrix_name = <str> . join ( [ matrix_name , referencePointString , pGeneList [ i ] ] ) file_list . append ( matrix_name + <str> ) matrix_name = pOutputFolder + <str> + matrix_name pViewpointObj . writeInteractionFile ( matrix_name , interaction_data , header_information , p_value_list , x_fold_list )  pQueue . put ( file_list ) return  def main ( args = None ) :      args = parse_arguments ( ) . parse_args ( args ) viewpointObj = Viewpoint ( ) referencePoints , gene_list = viewpointObj . readReferencePointFile ( args . referencePoints ) referencePointsPerThread = len ( referencePoints ) // args . threads queue = [ None ] * args . threads process = [ None ] * args . threads file_list = [ ] background_model = viewpointObj . readBackgroundDataFile ( args . backgroundModelFile , args . range ) background_model_mean_values = viewpointObj . readBackgroundDataFile ( args . backgroundModelFile , args . range , pMean = True ) background_sum_of_densities_dict = viewpointObj . computeSumOfDensities ( background_model , args , pXfoldMaxValue = args . xFoldMaxValueNB ) if not os . path . exists ( args . outputFolder ) :          try :              os . makedirs ( args . outputFolder )  except OSError as exc :              if exc . errno != errno . EEXIST :                  raise    for matrix in args . matrices :          hic_ma = hm . hiCMatrix ( matrix ) viewpointObj . hicMatrix = hic_ma file_list_sample = [ None ] * args . threads all_data_collected = False for i in range ( args . threads ) :              if i < args . threads - 1 :                  referencePointsThread = referencePoints [ i * referencePointsPerThread : ( i + 1 ) * referencePointsPerThread ] geneListThread = gene_list [ i * referencePointsPerThread : ( i + 1 ) * referencePointsPerThread ]  else :                  referencePointsThread = referencePoints [ i * referencePointsPerThread : ] geneListThread = gene_list [ i * referencePointsPerThread : ]  if len ( referencePointsThread ) == 0 :                  process [ i ] = None queue [ i ] = None file_list_sample [ i ] = [ ] continue  queue [ i ] = Queue ( ) process [ i ] = Process ( target = compute_viewpoint , kwargs = dict ( pViewpointObj = viewpointObj , pArgs = args , pQueue = queue [ i ] , pReferencePoints = referencePointsThread , pGeneList = geneListThread , pMatrix = matrix , pBackgroundModel = background_sum_of_densities_dict , pBackgroundModelRelativeInteractions = background_model_mean_values , pOutputFolder = args . outputFolder ) ) process [ i ] . start ( )  while not all_data_collected :              for i in range ( args . threads ) :                  if queue [ i ] is not None and not queue [ i ] . empty ( ) :                      file_list_ = queue [ i ] . get ( ) file_list_sample [ i ] = file_list_ process [ i ] . join ( ) process [ i ] . terminate ( ) process [ i ] = None   all_data_collected = True for i in range ( args . threads ) :                  if process [ i ] is not None :                      all_data_collected = False   time . sleep ( 1 )  file_list_sample = [ item for sublist in file_list_sample for item in sublist ] file_list . append ( file_list_sample )  log . debug ( <str> . format ( file_list ) ) if args . writeFileNamesToFile :          with open ( args . writeFileNamesToFile , <str> ) as file :              log . debug ( <str> . format ( len ( file_list ) ) ) if len ( file_list ) > 1 :                  for i , sample in enumerate ( file_list ) :                      for sample2 in file_list [ i + 1 : ] :                          for viewpoint , viewpoint2 in zip ( sample , sample2 ) :                              file . write ( viewpoint + <str> ) file . write ( viewpoint2 + <str> )     else :                  for viewpoint in file_list [ 0 ] :                      file . write ( viewpoint + <str> )     if args . allViewpointsList :          with open ( args . writeFileNamesToFile + <str> , <str> ) as file :              if len ( file_list ) > 1 :                  for i , sample in enumerate ( file_list [ 0 ] ) :                      file . write ( sample + <str> ) for j in range ( 1 , len ( file_list ) ) :                          file . write ( file_list [ j ] [ i ] + <str> )    else :                  for viewpoint in file_list [ 0 ] :                      file . write ( viewpoint + <str> )       