import numpy as np import logging log = logging . getLogger ( __name__ ) import copy import sys from mpl_toolkits . axes_grid1 import make_axes_locatable from scipy . stats import nbinom from scipy . special import gamma class Viewpoint ( ) :      def __init__ ( self , pHiCMatrix = None ) :          self . hicMatrix = pHiCMatrix  def readReferencePointFile ( self , pBedFile , pGene = True ) :          viewpoints = [ ] gene_list = [ ] with open ( pBedFile , <str> ) as file :              for line in file . readlines ( ) :                  _line = line . strip ( ) . split ( <str> ) if len ( line ) == 0 or len ( _line ) == 0 or line == <str> :                      continue  if len ( _line ) == 3 :                      chrom , start , end = _line [ 0 ] , _line [ 1 ] , _line [ 1 ] if pGene :                          gene_list . append ( _line [ 2 ] )   elif len ( _line ) > 3 :                      chrom , start , end = _line [ : 3 ] if pGene :                          gene_list . append ( _line [ 3 ] )   else :                      continue  viewpoints . append ( ( chrom , start , end ) )   if pGene :              return viewpoints , gene_list  else :              return viewpoints   def readInteractionFile ( self , pBedFile ) :          interaction_data = { } p_score = { } interaction_file_data = { } genomic_coordinates = { } with open ( pBedFile ) as fh :              fh . readline ( ) header = fh . readline ( ) for line in fh . readlines ( ) :                  if line . strip ( ) . startswith ( <str> ) :                      continue  _line = line . strip ( ) . split ( <str> ) interaction_data [ int ( _line [ - 5 ] ) ] = float ( _line [ - 4 ] ) p_score [ int ( _line [ - 5 ] ) ] = float ( _line [ - 3 ] ) interaction_file_data [ int ( _line [ - 5 ] ) ] = _line genomic_coordinates [ int ( _line [ - 5 ] ) ] = [ _line [ 0 ] , _line [ 1 ] , _line [ 2 ] ]   return header , interaction_data , p_score , interaction_file_data , genomic_coordinates  def readInteractionFileForAggregateStatistics ( self , pBedFile ) :          interaction_data = { } interaction_file_data = { } with open ( pBedFile ) as fh :              fh . readline ( ) header = fh . readline ( ) fh . readline ( ) for line in fh . readlines ( ) :                  if line . strip ( ) . startswith ( <str> ) :                      continue  if not line :                      continue  _line = line . strip ( ) . split ( <str> ) interaction_data [ int ( _line [ - 5 ] ) ] = np . array ( [ float ( _line [ - 4 ] ) , float ( _line [ - 3 ] ) , float ( _line [ - 1 ] ) , float ( _line [ - 2 ] ) ] ) interaction_file_data [ int ( _line [ - 5 ] ) ] = _line   return header , interaction_data , interaction_file_data  def readBackgroundDataFile ( self , pBedFile , pRange , pMean = False ) :          distance = { } with open ( pBedFile ) as fh :              _ = fh . readline ( ) for line in fh . readlines ( ) :                  _line = line . split ( <str> ) if not pMean :                      distance [ int ( _line [ 0 ] ) ] = [ float ( _line [ 1 ] ) , float ( _line [ 2 ] ) , float ( _line [ 3 ] ) ]  else :                      distance [ int ( _line [ 0 ] ) ] = [ float ( _line [ - 1 ] ) ]    max_key = max ( distance ) min_key = min ( distance ) keys = list ( distance . keys ( ) ) inc = np . absolute ( np . absolute ( keys [ 0 ] ) - np . absolute ( keys [ 1 ] ) ) if max_key < pRange [ 1 ] :              i = max_key while i < pRange [ 1 ] :                  i += inc distance [ i ] = distance [ max_key ]   if min_key > - pRange [ 0 ] :              i = min_key while i > - pRange [ 0 ] :                  i -= inc distance [ i ] = distance [ min_key ]   return distance  def writeInteractionFile ( self , pBedFile , pData , pHeader , pPValueData , pXfold ) :          with open ( ( pBedFile + <str> ) . strip ( ) , <str> ) as fh :              fh . write ( <str> . format ( pHeader ) ) for j , interaction in enumerate ( pData ) :                  fh . write ( <str> . format ( interaction [ 0 ] , interaction [ 1 ] , interaction [ 2 ] , interaction [ 3 ] , interaction [ 4 ] , interaction [ 5 ] , interaction [ 6 ] , pPValueData [ j ] , pXfold [ j ] , interaction [ 7 ] ) )   return  def computeViewpoint ( self , pReferencePoint , pChromViewpoint , pRegion_start , pRegion_end ) :          view_point_start , view_point_end = self . getReferencePointAsMatrixIndices ( pReferencePoint ) view_point_range = self . getViewpointRangeAsMatrixIndices ( pChromViewpoint , pRegion_start , pRegion_end ) view_point_range = list ( view_point_range ) view_point_range [ 1 ] += 1 elements_of_viewpoint = ( view_point_range [ 1 ] - view_point_range [ 0 ] ) data_list = np . zeros ( elements_of_viewpoint ) _view_point_start = view_point_start while _view_point_start <= view_point_end :              chrom , start , end , _ = self . hicMatrix . getBinPos ( _view_point_start ) for j , idx in zip ( range ( elements_of_viewpoint ) , range ( view_point_range [ 0 ] , view_point_range [ 1 ] , 1 ) ) :                  data_list [ j ] += self . hicMatrix . matrix [ _view_point_start , idx ]  _view_point_start += 1  elements_of_viewpoint = elements_of_viewpoint - ( view_point_end - view_point_start ) data_list_new = np . zeros ( elements_of_viewpoint ) index_before_viewpoint = view_point_start - view_point_range [ 0 ] data_list_new [ 0 : index_before_viewpoint ] = data_list [ 0 : index_before_viewpoint ] data_list_new [ index_before_viewpoint ] = np . sum ( data_list [ index_before_viewpoint : index_before_viewpoint + view_point_end - view_point_start + 1 ] ) data_list_new [ index_before_viewpoint + 1 : ] = data_list [ index_before_viewpoint + view_point_end - view_point_start + 1 : ] return data_list_new  def createInteractionFileData ( self , pReferencePoint , pChromViewpoint , pRegion_start , pRegion_end , pInteractionData , pInteractionDataRaw , pGene , pSumOfInteractions ) :          view_point_start , view_point_end = self . getReferencePointAsMatrixIndices ( pReferencePoint ) view_point_range = self . getViewpointRangeAsMatrixIndices ( pChromViewpoint , pRegion_start , pRegion_end ) view_point_range = list ( view_point_range ) view_point_range [ 1 ] += 1 interactions_list = [ ] chrom , start , _ , _ = self . hicMatrix . getBinPos ( view_point_start ) _ , _ , end , _ = self . hicMatrix . getBinPos ( view_point_end ) interaction_positions = list ( range ( view_point_range [ 0 ] , view_point_start , 1 ) ) interaction_positions . extend ( [ view_point_start ] ) interaction_positions . extend ( list ( range ( view_point_end + 1 , view_point_range [ 1 ] , 1 ) ) ) relative_position = - 1 for j , idx in zip ( range ( len ( pInteractionData ) ) , interaction_positions ) :              try :                  chrom_second , start_second , end_second , _ = self . hicMatrix . getBinPos ( idx ) if relative_position < 0 :                      relative_position = int ( start_second ) - int ( start )  else :                      relative_position = int ( end_second ) - int ( end )  interactions_list . append ( ( chrom_second , start_second , end_second , pGene , str ( pSumOfInteractions ) , relative_position , float ( pInteractionData [ j ] ) , float ( pInteractionDataRaw [ j ] ) ) )  except Exception :                  log . error ( <str> . format ( idx ) ) exit ( 1 )   return interactions_list  def getViewpointRangeAsMatrixIndices ( self , pChromViewpoint , pRegion_start , pRegion_end ) :          _range = self . hicMatrix . getRegionBinRange ( pChromViewpoint , pRegion_start , pRegion_end ) return _range  def getReferencePointAsMatrixIndices ( self , pReferencePoint ) :          if len ( pReferencePoint ) == 2 :              view_point_start , view_point_end = self . hicMatrix . getRegionBinRange ( pReferencePoint [ 0 ] , int ( pReferencePoint [ 1 ] ) , int ( pReferencePoint [ 1 ] ) )  elif len ( pReferencePoint ) == 3 :              view_point_start , view_point_end = self . hicMatrix . getRegionBinRange ( pReferencePoint [ 0 ] , int ( pReferencePoint [ 1 ] ) , int ( pReferencePoint [ 2 ] ) )  else :              log . error ( <str> . format ( pReferencePoint ) ) exit ( 1 )  return view_point_start , view_point_end  def smoothInteractionValues ( self , pData , pWindowSize ) :          window_size = np . int ( np . floor ( pWindowSize / 2 ) ) window_size_upstream = window_size if pWindowSize % 2 == 0 :              window_size_upstream -= 1  average_contacts = np . zeros ( len ( pData ) ) for i in range ( window_size_upstream , len ( pData ) - window_size ) :              start = i - window_size_upstream end = i + window_size + 1 average_contacts [ i ] = np . mean ( pData [ start : end ] )  for i in range ( window_size ) :              start = i - window_size_upstream if start < 0 :                  start = 0  end = i + window_size + 1 average_contacts [ i ] = np . mean ( pData [ start : end ] ) average_contacts [ - ( i + 1 ) ] = np . mean ( pData [ - end : ] )  return average_contacts  def computeRelativeValues ( self , pData , pDenominator = None ) :          pOutput = np . array ( pData , dtype = float ) if pDenominator :              pOutput /= pDenominator  else :              sumValue = np . sum ( pOutput ) pOutput /= sumValue  return pOutput  def calculateViewpointRange ( self , pViewpoint , pRange ) :          max_length = self . hicMatrix . getBinPos ( self . hicMatrix . getChrBinRange ( pViewpoint [ 0 ] ) [ 1 ] - 1 ) [ 2 ] bin_size = self . hicMatrix . getBinSize ( ) _range = [ pRange [ 0 ] , pRange [ 1 ] ] region_start = int ( pViewpoint [ 1 ] ) - pRange [ 0 ] if region_start < 0 :              region_start = 0 _range [ 0 ] = int ( pViewpoint [ 1 ] )  region_end = int ( pViewpoint [ 2 ] ) + pRange [ 1 ] if region_end > max_length :              region_end = max_length - 1 _range [ 1 ] = ( max_length - int ( pViewpoint [ 2 ] ) ) + bin_size  return region_start , region_end , _range  def getDataForPlotting ( self , pInteractionFile , pRange , pBackgroundModel , pResolution ) :          header , interaction_data , p_value_data , _interaction_file_data_raw , genomic_coordinates = self . readInteractionFile ( pInteractionFile ) matrix_name , viewpoint , upstream_range , downstream_range , gene , _ = header . split ( <str> ) data = [ ] p_value = [ ] data_background = None viewpoint_index_end = None if pRange :              interaction_data_keys = copy . deepcopy ( list ( interaction_data . keys ( ) ) ) for key in interaction_data_keys :                  if key >= - pRange [ 0 ] and key <= pRange [ 1 ] :                      continue  interaction_data . pop ( key , None )  if pBackgroundModel :                  background_data_keys_sorted = sorted ( pBackgroundModel ) for key in background_data_keys_sorted :                      if key >= - pRange [ 0 ] and key <= pRange [ 1 ] :                          continue  pBackgroundModel . pop ( key , None )  background_data_keys_sorted = sorted ( pBackgroundModel )   if pBackgroundModel :              viewpoint_index_start = background_data_keys_sorted . index ( 0 ) data_background = [ ] for key in background_data_keys_sorted :                  if key in interaction_data :                      if key == 0 :                          chromosome , start , end = genomic_coordinates [ key ] if np . abs ( int ( start ) - int ( end ) ) > pResolution :                              peak_width = np . abs ( int ( start ) - int ( end ) ) // pResolution viewpoint_index_end = peak_width i = 0 while i < peak_width :                                  data . append ( interaction_data [ key ] ) i += 1    else :                          data . append ( interaction_data [ key ] )  if key in p_value_data :                          if key == 0 :                              chromosome , start , end = genomic_coordinates [ key ] if np . abs ( int ( start ) - int ( end ) ) > pResolution :                                  peak_width = np . abs ( int ( start ) - int ( end ) ) // pResolution i = 0 while i < peak_width :                                      p_value . append ( p_value_data [ key ] ) i += 1    else :                              p_value . append ( p_value_data [ key ] )   if key == 0 :                          chromosome , start , end = genomic_coordinates [ key ] if np . abs ( int ( start ) - int ( end ) ) > pResolution :                              peak_width = np . abs ( int ( start ) - int ( end ) ) // pResolution i = 0 while i < peak_width :                                  data_background . append ( pBackgroundModel [ key ] [ 0 ] ) log . debug ( <str> . format ( pBackgroundModel [ key ] [ 0 ] ) ) log . debug ( <str> . format ( peak_width ) ) log . debug ( <str> . format ( data_background [ - 1 ] ) ) i += 1    else :                          data_background . append ( pBackgroundModel [ key ] [ 0 ] )    if viewpoint_index_end is None :                  viewpoint_index_end = viewpoint_index_start  else :                  viewpoint_index_end += viewpoint_index_start   else :              data = [ ] interaction_key = sorted ( interaction_data ) for key in interaction_key :                  if key == 0 :                      chromosome , start , end = genomic_coordinates [ key ] if np . abs ( int ( start ) - int ( end ) ) > pResolution :                          peak_width = np . abs ( int ( start ) - int ( end ) ) // pResolution viewpoint_index_end = peak_width i = 0 while i < peak_width :                              data . append ( interaction_data [ key ] ) i += 1    else :                      data . append ( interaction_data [ key ] )  if key in p_value_data :                      if key == 0 :                          chromosome , start , end = genomic_coordinates [ key ] if np . abs ( int ( start ) - int ( end ) ) > pResolution :                              peak_width = np . abs ( int ( start ) - int ( end ) ) // pResolution i = 0 while i < peak_width :                                  p_value . append ( p_value_data [ key ] ) i += 1    else :                          p_value . append ( p_value_data [ key ] )    viewpoint_index_start = interaction_key . index ( 0 ) if viewpoint_index_end is None :                  viewpoint_index_end = viewpoint_index_start  else :                  viewpoint_index_end += viewpoint_index_start   return header , data , data_background , p_value , viewpoint_index_start , viewpoint_index_end  def plotViewpoint ( self , pAxis , pData , pColor , pLabelName , pHighlightRegion = None , pHighlightSignificantRegion = None ) :          data_plot_label = pAxis . plot ( range ( len ( pData ) ) , pData , <str> + pColor , alpha = 0.9 , label = pLabelName , linewidth = 1 ) if pHighlightRegion :              for region in pHighlightRegion :                  pAxis . axvspan ( region [ 0 ] , region [ 1 ] , color = <str> , alpha = 0.3 )   if pHighlightSignificantRegion :              for region in pHighlightSignificantRegion :                  pAxis . axvspan ( region [ 0 ] , region [ 1 ] , color = pColor , alpha = 0.3 )   return data_plot_label  def plotBackgroundModel ( self , pAxis , pBackgroundData , pXFold = None ) :          pBackgroundData = np . array ( pBackgroundData ) data_plot_label = pAxis . plot ( range ( len ( pBackgroundData ) ) , pBackgroundData , <str> , alpha = 0.5 , label = <str> , linewidth = 1 ) if pXFold :              upper_values = pBackgroundData * pXFold lower_values = pBackgroundData pAxis . fill_between ( range ( len ( pBackgroundData ) ) , upper_values , lower_values , facecolor = <str> , alpha = 0.5 )  return data_plot_label  def plotPValue ( self , pAxis , pAxisLabel , pPValueData , pLabelText , pCmap , pFigure , pValueSignificanceLevels ) :          _z_score = np . empty ( [ 2 , len ( pPValueData ) ] ) _z_score [ : , : ] = pPValueData pAxis . xaxis . set_visible ( False ) pAxis . yaxis . set_visible ( False ) divider = make_axes_locatable ( pAxisLabel ) cax = divider . append_axes ( <str> , size = <str> , pad = 0.09 ) if pPValueData is not None :              img = pAxis . contourf ( _z_score , cmap = pCmap ) colorbar = pFigure . colorbar ( img , cax = cax , ticks = [ min ( pPValueData ) , max ( pPValueData ) ] ) colorbar . ax . set_ylabel ( <str> , size = 6 )  elif pValueSignificanceLevels :              pValueSignificanceLevels . insert ( 0 , - 1 ) pValueSignificanceLevels . append ( 1 ) img = pAxis . contourf ( _z_score , levels = pValueSignificanceLevels , colors = [ <str> , <str> , <str> , <str> ] ) colorbar = pFigure . colorbar ( img , cax = cax , ticks = [ pValueSignificanceLevels [ 1 ] , pValueSignificanceLevels [ 2 ] , pValueSignificanceLevels [ 3 ] ] ) colorbar . ax . tick_params ( labelsize = 6 ) colorbar . ax . set_ylabel ( <str> , size = 6 )  pAxisLabel . text ( 0.45 , 0 , pLabelText , size = 7 ) pAxisLabel . xaxis . set_visible ( False ) pAxisLabel . yaxis . set_visible ( False ) pAxisLabel . set_frame_on ( False )  def writePlotData ( self , pInteractionFileDataRaw , pFileName , pBackgroundModel ) :          interaction_file_data_raw_sorted = sorted ( pInteractionFileDataRaw ) with open ( pFileName + <str> , <str> ) as output_file :              output_file . write ( <str> ) if pBackgroundModel :                  output_file . write ( <str> )  else :                  output_file . write ( <str> )  for key in interaction_file_data_raw_sorted :                  _array = pInteractionFileDataRaw [ key ] output_file . write ( <str> . format ( _array [ 0 ] , _array [ 1 ] , _array [ 2 ] , _array [ 3 ] , _array [ 4 ] , _array [ 5 ] , _array [ 6 ] , _array [ 7 ] , _array [ 8 ] , _array [ 9 ] , _array [ 10 ] ) ) if pBackgroundModel :                      output_file . write ( <str> . format ( _array [ 11 ] , _array [ 12 ] ) )  else :                      output_file . write ( <str> )     def interactionBackgroundData ( self , pBackground , pRange ) :          background_model = [ ] background_data_keys_sorted = sorted ( pBackground ) for key in background_data_keys_sorted :              if key >= - pRange [ 0 ] and key <= pRange [ 1 ] :                  background_model . append ( pBackground [ key ] )   return np . array ( background_model )  def rbz_score ( self , pRelativeInteractions , pBackgroundModel , pBackgroundModelSEM ) :          _rbz_score = np . empty ( len ( pRelativeInteractions ) ) if len ( pRelativeInteractions ) != len ( pBackgroundModel ) or len ( pRelativeInteractions ) != len ( pBackgroundModelSEM ) :              log . info ( <str> + <str> . format ( len ( pRelativeInteractions ) , len ( pBackgroundModel ) , len ( pBackgroundModelSEM ) ) ) return None  _rbz_score = pRelativeInteractions - pBackgroundModel _rbz_score /= pBackgroundModelSEM mask = np . isnan ( _rbz_score ) _rbz_score [ mask ] = - 1 mask = np . isinf ( _rbz_score ) _rbz_score [ mask ] = - 1 return _rbz_score  def readRejectedFile ( self , pDifferentialHighlightFiles , pViewpointIndexStart , pViewpointIndexEnd , pResolution , pRange , pViewpoint ) :          highlight_areas_list = [ ] _ , reference_point_start , reference_point_end = pViewpoint . split ( <str> ) with open ( pDifferentialHighlightFiles ) as fh :              for line in fh . readlines ( ) :                  if line . startswith ( <str> ) :                      continue  _line = line . split ( <str> ) start = int ( _line [ 1 ] ) end = int ( _line [ 2 ] ) if int ( _line [ 4 ] ) >= - pRange [ 0 ] and int ( _line [ 4 ] ) <= pRange [ 1 ] :                      width = ( end - start ) / pResolution if int ( _line [ 4 ] ) < 0 :                          relative_position_genomic_coordinates = start - int ( reference_point_start ) viewpointIndex = pViewpointIndexStart  else :                          relative_position_genomic_coordinates = start - int ( reference_point_end ) viewpointIndex = pViewpointIndexEnd  log . debug ( <str> . format ( _line [ 4 ] ) ) log . debug ( <str> . format ( relative_position_genomic_coordinates ) ) log . debug ( <str> . format ( start , end ) ) log . debug ( <str> . format ( reference_point_start , reference_point_end ) ) relative_position = viewpointIndex + ( relative_position_genomic_coordinates / pResolution ) highlight_areas_list . append ( [ relative_position , relative_position + width ] )    if len ( highlight_areas_list ) == 0 :              return None  return highlight_areas_list  def pvalues ( self , pBackgroundModelNBinomPValues , pDataList ) :          p_value_list = [ ] for i , ( pvalue_list , pDataList ) in enumerate ( zip ( pBackgroundModelNBinomPValues , pDataList ) ) :              if len ( pvalue_list ) == 0 :                  pvalue = 1  elif int ( pDataList ) - 1 < 0 :                  pvalue = pvalue_list [ 0 ]  else :                  try :                      pvalue = 1 - pvalue_list [ int ( pDataList ) - 1 ]  except Exception :                      log . debug ( <str> . format ( i , int ( pDataList ) - 1 , len ( pvalue_list ) ) ) pvalue = 1   p_value_list . append ( pvalue )  p_value_list = np . array ( p_value_list ) p_value_list = 1 - p_value_list mask = np . isnan ( p_value_list ) p_value_list = np . array ( p_value_list ) p_value_list [ mask ] = 1.0 return p_value_list  def computeSumOfDensities ( self , pBackgroundModel , pArgs , pXfoldMaxValue = None ) :          background_nbinom = { } background_sum_of_densities_dict = { } max_value = 0 fixateRange = int ( pArgs . fixateRange ) for distance in pBackgroundModel :              max_value_distance = int ( pBackgroundModel [ distance ] [ 2 ] ) if max_value < int ( pBackgroundModel [ distance ] [ 2 ] ) :                  max_value = int ( pBackgroundModel [ distance ] [ 2 ] )  if pXfoldMaxValue is not None :                  if max_value_distance == 0 :                      max_value_distance = 1  if pXfoldMaxValue == 0 :                      pXfoldMaxValue = 1  max_value_distance *= pXfoldMaxValue  if - int ( pArgs . fixateRange ) < distance and int ( pArgs . fixateRange ) > distance :                  background_nbinom [ distance ] = ( pBackgroundModel [ distance ] [ 0 ] , pBackgroundModel [ distance ] [ 1 ] ) sum_of_densities = np . zeros ( max_value_distance ) for j in range ( max_value_distance ) :                      if j >= 1 :                          sum_of_densities [ j ] += sum_of_densities [ j - 1 ]  sum_of_densities [ j ] += pmf ( j , background_nbinom [ distance ] [ 0 ] , background_nbinom [ distance ] [ 1 ] )  background_sum_of_densities_dict [ distance ] = sum_of_densities   background_nbinom [ fixateRange ] = ( pBackgroundModel [ fixateRange ] [ 0 ] , pBackgroundModel [ fixateRange ] [ 1 ] ) sum_of_densities = np . zeros ( max_value ) for j in range ( max_value ) :              if j >= 1 :                  sum_of_densities [ j ] += sum_of_densities [ j - 1 ]  sum_of_densities [ j ] += pmf ( j , background_nbinom [ fixateRange ] [ 0 ] , background_nbinom [ fixateRange ] [ 1 ] )  background_sum_of_densities_dict [ fixateRange ] = sum_of_densities background_nbinom [ - fixateRange ] = ( pBackgroundModel [ - fixateRange ] [ 0 ] , pBackgroundModel [ - fixateRange ] [ 1 ] ) sum_of_densities = np . zeros ( max_value ) for j in range ( max_value ) :              if j >= 1 :                  sum_of_densities [ j ] += sum_of_densities [ j - 1 ]  sum_of_densities [ j ] += pmf ( j , background_nbinom [ - fixateRange ] [ 0 ] , background_nbinom [ - fixateRange ] [ 1 ] )  background_sum_of_densities_dict [ - fixateRange ] = sum_of_densities min_key = min ( background_sum_of_densities_dict ) max_key = max ( background_sum_of_densities_dict ) for key in pBackgroundModel . keys ( ) :              if key in background_sum_of_densities_dict :                  continue  if key < min_key :                  background_sum_of_densities_dict [ key ] = background_sum_of_densities_dict [ min_key ]  elif key > max_key :                  background_sum_of_densities_dict [ key ] = background_sum_of_densities_dict [ max_key ]   return background_sum_of_densities_dict  def merge_neighbors ( self , pScoresDictionary , pMergeThreshold = 1000 ) :          if pScoresDictionary is None or len ( pScoresDictionary ) == 0 :              log . debug ( <str> ) return None  key_list = list ( pScoresDictionary . keys ( ) ) merge_ids = [ ] non_merge = [ ] for i , ( key_pre , key_suc ) in enumerate ( zip ( key_list [ : - 1 ] , key_list [ 1 : ] ) ) :              if np . absolute ( int ( pScoresDictionary [ key_pre ] [ 5 ] ) - int ( pScoresDictionary [ key_suc ] [ 5 ] ) ) <= pMergeThreshold :                  if len ( merge_ids ) > 0 and merge_ids [ - 1 ] [ - 1 ] == key_pre :                      merge_ids [ - 1 ] . append ( key_suc )  else :                      merge_ids . append ( [ key_pre , key_suc ] )   else :                  if i == len ( key_list ) - 1 :                      non_merge . append ( key_suc )  if merge_ids is not None and len ( merge_ids ) > 0 and merge_ids [ - 1 ] [ - 1 ] != key_pre :                      non_merge . append ( key_pre )  elif merge_ids is not None and len ( merge_ids ) == 0 :                      non_merge . append ( key_pre )    scores_dict = { } merged_lines_dict = { } for element in merge_ids :              lines = [ ] lines . append ( pScoresDictionary [ element [ 0 ] ] ) index_maximum_element = 0 base_element = pScoresDictionary [ element [ 0 ] ] values = np . array ( list ( map ( float , base_element [ - 4 : ] ) ) ) max_value = float ( base_element [ - 1 ] ) for i , key in enumerate ( element [ 1 : ] ) :                  base_element [ - 6 ] = pScoresDictionary [ key ] [ - 6 ] values += np . array ( list ( map ( float , pScoresDictionary [ key ] [ - 4 : ] ) ) ) lines . append ( pScoresDictionary [ key ] ) if max_value < float ( pScoresDictionary [ key ] [ - 1 ] ) :                      max_value = float ( pScoresDictionary [ key ] [ - 1 ] ) index_maximum_element = i + 1   base_element = pScoresDictionary [ element [ index_maximum_element ] ] base_element [ - 4 ] = values [ 0 ] base_element [ - 3 ] = values [ 1 ] base_element [ - 2 ] = values [ 2 ] base_element [ - 1 ] = values [ 3 ] base_element [ 2 ] = pScoresDictionary [ element [ - 1 ] ] [ 2 ] base_element [ 1 ] = pScoresDictionary [ element [ 0 ] ] [ 1 ] scores_dict [ element [ index_maximum_element ] ] = base_element merged_lines_dict [ element [ index_maximum_element ] ] = lines  for key in non_merge :              scores_dict [ key ] = pScoresDictionary [ key ] merged_lines_dict [ key ] = [ pScoresDictionary [ key ] ]  return scores_dict , merged_lines_dict  def readSignificantRegionsFile ( self , pSignificantFile , pViewpointIndexStart , pViewpointIndexEnd , pResolution , pRange , pViewpoint ) :          highlight_areas_list = [ ] p_values = [ ] viewpoint_split = pViewpoint . split ( <str> ) if len ( viewpoint_split ) == 3 :              _ , reference_point_start , reference_point_end = viewpoint_split  else :              log . debug ( <str> . format ( viewpoint_split , pSignificantFile ) ) return None , None  with open ( pSignificantFile ) as fh :              for line in fh . readlines ( ) :                  if line . startswith ( <str> ) :                      continue  _line = line . split ( <str> ) start = int ( _line [ 1 ] ) end = int ( _line [ 2 ] ) if int ( _line [ 5 ] ) >= - pRange [ 0 ] and int ( _line [ 5 ] ) <= pRange [ 1 ] :                      width = ( end - start ) / pResolution if int ( _line [ 5 ] ) < 0 :                          relative_position_genomic_coordinates = start - int ( reference_point_start ) viewpointIndex = pViewpointIndexStart  else :                          relative_position_genomic_coordinates = start - int ( reference_point_end ) viewpointIndex = pViewpointIndexEnd  relative_position = viewpointIndex + ( relative_position_genomic_coordinates / pResolution ) highlight_areas_list . append ( [ relative_position , relative_position + width ] ) p_values . append ( [ int ( relative_position ) , int ( relative_position + width ) , float ( _line [ - 3 ] ) ] )    if len ( highlight_areas_list ) == 0 :              return None , None  return highlight_areas_list , p_values   def pmf ( pX , pR , pP ) :      gamma_part = ( gamma ( pX + pR ) / ( gamma ( pX + 1 ) * gamma ( pR ) ) ) probability_part = np . power ( pP , pX ) * np . power ( ( 1 - pP ) , pR ) return gamma_part * probability_part   