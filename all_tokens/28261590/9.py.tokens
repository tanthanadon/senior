import warnings warnings . simplefilter ( action = <str> , category = RuntimeWarning ) warnings . simplefilter ( action = <str> , category = PendingDeprecationWarning ) import argparse import numpy as np import matplotlib matplotlib . use ( <str> ) import matplotlib . pyplot as plt import matplotlib . gridspec as gridspec import matplotlib . cm as cm from hicmatrix import HiCMatrix as hm import hicexplorer . utilities from . utilities import toString from . utilities import check_chrom_str_bytes from hicexplorer . _version import __version__ import logging log = logging . getLogger ( __name__ ) from collections import OrderedDict def parse_arguments ( args = None ) :      parser = argparse . ArgumentParser ( add_help = False , description = <str> <str> ) parserRequired = parser . add_argument_group ( <str> ) parserRequired . add_argument ( <str> , <str> , help = <str> , required = True ) parserRequired . add_argument ( <str> , <str> , help = <str> , type = argparse . FileType ( <str> ) , required = True ) parserRequired . add_argument ( <str> , help = <str> , type = argparse . FileType ( <str> ) , required = True ) parserRequired . add_argument ( <str> , help = <str> <str> <str> , required = True ) parserOpt = parser . add_argument_group ( <str> ) parserOpt . add_argument ( <str> , help = <str> <str> , type = argparse . FileType ( <str> ) , required = False ) parserOpt . add_argument ( <str> , help = <str> <str> , default = <str> , type = int ) parserOpt . add_argument ( <str> , help = <str> <str> <str> <str> <str> , choices = [ <str> , <str> , <str> , <str> ] , default = <str> ) parserOpt . add_argument ( <str> , help = <str> , choices = [ <str> , <str> ] , default = <str> ) parserOpt . add_argument ( <str> , <str> , action = <str> , help = <str> ) parserOpt . add_argument ( <str> , action = <str> , version = <str> . format ( __version__ ) ) parserOut = parser . add_argument_group ( <str> ) parserOut . add_argument ( <str> , help = <str> <str> <str> <str> , required = False ) parserOut . add_argument ( <str> , help = <str> <str> <str> <str> <str> <str> , required = False ) parserOut . add_argument ( <str> , help = <str> <str> <str> <str> <str> , type = argparse . FileType ( <str> ) , required = False ) parserClust = parser . add_argument_group ( <str> ) parserClust . add_argument ( <str> , help = <str> <str> <str> , type = int ) parserClust . add_argument ( <str> , help = <str> <str> <str> <str> <str> , type = int ) parserClust . add_argument ( <str> , help = <str> <str> <str> <str> <str> , choices = [ <str> , <str> , <str> ] , default = <str> ) parserPlot = parser . add_argument_group ( <str> ) parserPlot . add_argument ( <str> , <str> , help = <str> , nargs = <str> ) parserPlot . add_argument ( <str> , help = <str> <str> <str> , default = <str> ) parserPlot . add_argument ( <str> , help = <str> , choices = [ <str> , <str> ] , default = <str> ) parserPlot . add_argument ( <str> , help = <str> , type = float , default = None ) parserPlot . add_argument ( <str> , help = <str> , type = float , default = None ) parserPlot . add_argument ( <str> , help = argparse . SUPPRESS , action = <str> ) parserOpt . add_argument ( <str> , help = <str> <str> , type = int , default = 300 ) return parser  def read_bed_per_chrom ( fh ) :      interval = { } for line in fh :          if line [ 0 ] == <str> :              continue  fields = line . strip ( ) . split ( ) if fields [ 0 ] not in interval :              interval [ fields [ 0 ] ] = [ ]  interval [ fields [ 0 ] ] . append ( ( int ( fields [ 1 ] ) , int ( fields [ 2 ] ) ) )  return interval  def get_outlier_indices ( data , max_deviation = 200 ) :      data = np . asarray ( data ) median = np . median ( data ) b_value = 1.4826 mad = b_value * np . median ( np . abs ( data ) ) if mad == 0 :          return None  deviation = abs ( data - median ) / mad outliers = ( deviation > max_deviation ) . any ( axis = 1 ) return outliers  def cluster_matrices ( submatrices_dict , k , method = <str> , how = <str> ) :      clustered_dict = { } for chrom in submatrices_dict :          log . info ( <str> . format ( len ( submatrices_dict [ chrom ] ) ) ) submat_vectors = [ ] shape = submatrices_dict [ chrom ] [ 0 ] . shape center_bin = ( shape [ 0 ] + 1 ) // 2 for submatrix in submatrices_dict [ chrom ] :              if how == <str> :                  submat_vectors . append ( submatrix . diagonal ( ) )  elif how == <str> :                  submat_vectors . append ( submatrix [ center_bin - 2 : center_bin + 1 , center_bin - 2 : center_bin + 1 ] . reshape ( ( 1 , 9 ) ) . mean ( ) )  else :                  submat_vectors . append ( submatrix . reshape ( ( 1 , shape [ 0 ] * shape [ 1 ] ) ) )   matrix = np . vstack ( submat_vectors ) if how == <str> :              assert matrix . shape == ( len ( submatrices_dict [ chrom ] ) , shape [ 0 ] )  elif how == <str> :              assert matrix . shape == ( len ( submatrices_dict [ chrom ] ) , 1 )  else :              assert matrix . shape == ( len ( submatrices_dict [ chrom ] ) , shape [ 0 ] * shape [ 1 ] )  out_ind = get_outlier_indices ( matrix , max_deviation = 2 ) if out_ind is not None and len ( np . flatnonzero ( out_ind ) ) > 0 :              log . info ( <str> . format ( chrom , len ( np . flatnonzero ( out_ind ) ) ) ) matrix = matrix [ np . logical_not ( out_ind ) , : ]  if np . any ( np . isnan ( matrix ) ) :              log . warning ( <str> ) matrix [ np . isnan ( matrix ) ] = 0  if method == <str> :              from scipy . cluster . vq import vq , kmeans centroids , _ = kmeans ( matrix , k ) cluster_labels , _ = vq ( matrix , centroids )  if method == <str> :              from scipy . cluster . hierarchy import fcluster , linkage Z = linkage ( matrix , method = <str> , metric = <str> ) cluster_labels = fcluster ( Z , k , criterion = <str> ) cluster_labels -= 1  clustered_dict [ chrom ] = [ ] for cluster in range ( k ) :              cluster_ids = np . flatnonzero ( cluster_labels == cluster ) clustered_dict [ chrom ] . append ( cluster_ids )   return clustered_dict  def plot_aggregated_contacts ( chrom_matrix , chrom_contact_position , cluster_ids , num_clusters , M_half , args ) :      num_chromosomes = len ( chrom_matrix ) fig = plt . figure ( figsize = ( 5.5 * num_chromosomes , 5.5 * num_clusters + 0.5 ) ) gs = gridspec . GridSpec ( num_clusters + 1 , num_chromosomes , width_ratios = [ 10 ] * len ( chrom_matrix ) , height_ratios = [ 10 ] * num_clusters + [ 0.6 ] ) gs . update ( wspace = 0.01 , hspace = 0.2 ) chrom_avg = { } chrom_cluster_len = { } for idx , chrom in enumerate ( chrom_matrix ) :          chrom_avg [ chrom ] = [ ] chrom_cluster_len [ chrom ] = [ ] for cluster_number , cluster_indices in enumerate ( cluster_ids [ chrom ] ) :              if num_clusters == 1 :                  submatrices = np . array ( chrom_matrix [ chrom ] )  else :                  submatrices = np . array ( [ chrom_matrix [ chrom ] [ x ] for x in cluster_indices ] )  chrom_cluster_len [ chrom ] . append ( len ( cluster_ids ) ) if args . avgType == <str> :                  _median = np . median ( submatrices , axis = 0 ) if _median . sum ( ) == 0 or np . isnan ( _median . sum ( ) ) :                      if np . mean ( submatrices , axis = 0 ) . sum ( ) != 0 :                          log . info ( <str> <str> )  else :                          log . info ( <str> <str> )   chrom_avg [ chrom ] . append ( _median )  else :                  chrom_avg [ chrom ] . append ( np . mean ( submatrices , axis = 0 ) )  log . info ( <str> . format ( chrom_avg [ chrom ] [ cluster_number ] . mean ( ) ) )   vmin , vmax = ( args . vMin , args . vMax ) cmap = cm . get_cmap ( args . colorMap ) log . debug ( <str> . format ( vmax , vmin ) ) for idx , chrom in enumerate ( chrom_matrix ) :          for cluster_number , cluster_indices in enumerate ( cluster_ids [ chrom ] ) :              log . info ( <str> . format ( chrom , cluster_number + 1 , len ( cluster_indices ) ) ) try :                  chrom_avg [ chrom ] [ cluster_number ] . shape [ 0 ]  except IndexError :                  continue  if chrom_avg [ chrom ] [ cluster_number ] . shape [ 0 ] == 0 :                  log . debug ( <str> . format ( chrom ) ) continue  if num_clusters == 1 :                  title = chrom  else :                  title = <str> . format ( chrom , cluster_number + 1 )  if args . plotType == <str> :                  ax = plt . subplot ( gs [ cluster_number , idx ] ) ax . set_title ( title ) img = ax . imshow ( chrom_avg [ chrom ] [ cluster_number ] , aspect = <str> , interpolation = <str> , vmax = vmax , vmin = vmin , cmap = cmap , extent = [ - M_half , M_half + 1 , - M_half , M_half + 1 ] )  else :                  from mpl_toolkits . mplot3d import Axes3D Axes3D ( fig ) ax = plt . subplot ( gs [ cluster_number , idx ] , projection = <str> ) ax . margins ( 0 ) X , Y = np . meshgrid ( range ( - M_half , M_half + 1 ) , range ( - M_half , M_half + 1 ) ) Z = chrom_avg [ chrom ] [ cluster_number ] . copy ( ) img = ax . plot_surface ( X , Y , Z , rstride = 1 , cstride = 1 , linewidth = 0 , cmap = cmap , vmax = vmax , vmin = vmin , edgecolor = <str> ) ax . set_zticklabels ( [ ] ) if vmax is not None and vmax is not None :                      ax . set_zlim ( vmin , vmax )   if args . outFilePrefixMatrix :                  if num_clusters == 1 :                      output_matrix_name = <str> . format ( file = args . outFilePrefixMatrix , chrom = chrom )  else :                      output_matrix_name = <str> . format ( file = args . outFilePrefixMatrix , chrom = chrom , id = cluster_number + 1 )  np . savetxt ( output_matrix_name , chrom_avg [ chrom ] [ cluster_number ] , <str> , delimiter = <str> )   cbar_x = plt . subplot ( gs [ - 1 , idx ] ) fig . colorbar ( img , cax = cbar_x , orientation = <str> )  if args . disable_bbox_tight :          plt . savefig ( args . outFileName . name , dpi = args . dpi )  else :          plt . savefig ( args . outFileName . name , dpi = args . dpi , bbox_inches = <str> )  plt . close ( )  def plot_diagnostic_heatmaps ( chrom_diagonals , cluster_ids , M_half , args ) :      num_chromosomes = len ( chrom_diagonals ) vmax_heat = args . vMax if vmax_heat is not None :          vmax_heat *= 5  vmin_heat = args . vMin if vmin_heat is not None :          vmin_heat *= 5  else :          vmin_heat = 0  num_plots = len ( chrom_diagonals ) fig = plt . figure ( figsize = ( num_plots * 4 , 20 ) ) gs0 = gridspec . GridSpec ( 2 , num_plots + 1 , width_ratios = [ 10 ] * num_plots + [ 0.5 ] , height_ratios = [ 1 , 5 ] , wspace = 0.1 , hspace = 0.1 ) gs_list = [ ] for idx , ( chrom_name , values ) in enumerate ( chrom_diagonals . items ( ) ) :          try :              heatmap = np . asarray ( np . vstack ( values ) )  except ValueError :              log . error ( <str> . format ( chrom_name ) ) continue  clust_len = [ ( len ( v ) ) for v in cluster_ids [ chrom_name ] ] gs_list . append ( gridspec . GridSpecFromSubplotSpec ( len ( clust_len ) , 1 , subplot_spec = gs0 [ 1 , idx ] , height_ratios = clust_len , hspace = 0.03 ) ) summary_plot_ax = plt . subplot ( gs0 [ 0 , idx ] ) summary_plot_ax . set_title ( chrom_name ) for cluster_number , cluster_indices in enumerate ( cluster_ids [ chrom_name ] ) :              heatmap_to_plot = heatmap [ cluster_indices , : ] order = np . argsort ( heatmap_to_plot [ : , M_half ] ) [ : : - 1 ] heatmap_to_plot = heatmap_to_plot [ order , : ] y_values = heatmap_to_plot . mean ( axis = 0 ) x_values = np . arange ( len ( y_values ) ) - M_half cluster_label = <str> . format ( cluster_number + 1 ) summary_plot_ax . plot ( x_values , y_values , label = cluster_label ) ax = plt . subplot ( gs_list [ - 1 ] [ cluster_number , 0 ] ) ax . set_yticks ( [ ] ) if num_chromosomes > 1 :                  ax . set_ylabel ( cluster_label )  if cluster_number < num_chromosomes - 1 :                  ax . set_xticks ( [ ] )  heat_fig = ax . imshow ( heatmap_to_plot , aspect = <str> , interpolation = <str> , cmap = cm . get_cmap ( args . colorMap ) , origin = <str> , vmax = vmax_heat , vmin = vmin_heat , extent = [ - M_half , M_half + 1 , 0 , len ( order ) ] )  summary_plot_ax . legend ( ncol = 1 , frameon = False , markerscale = 0.5 )  cbar_x = plt . subplot ( gs0 [ 1 , - 1 ] ) fig . colorbar ( heat_fig , cax = cbar_x , orientation = <str> ) file_name = args . diagnosticHeatmapFile . name log . info ( <str> . format ( file_name ) ) plt . savefig ( file_name , dpi = args . dpi , bbox_inches = <str> ) plt . close ( )  def main ( args = None ) :      args = parse_arguments ( ) . parse_args ( args ) ma = hm . hiCMatrix ( args . matrix ) ma . maskBins ( ma . nan_bins ) ma . matrix . data [ np . isnan ( ma . matrix . data ) ] = 0 bin_size = ma . getBinSize ( ) ma . maskBins ( ma . nan_bins ) ma . matrix . data = ma . matrix . data new_intervals = hicexplorer . utilities . enlarge_bins ( ma . cut_intervals ) ma . setCutIntervals ( new_intervals ) min_dist , max_dist = args . range . split ( <str> ) if args . chromosomes :          ma . keepOnlyTheseChr ( args . chromosomes )  chrom_sizes = ma . get_chromosome_sizes ( ) chrom_list = chrom_sizes . keys ( ) log . info ( <str> . format ( min_dist , max_dist ) ) min_dist = int ( min_dist ) max_dist = int ( max_dist ) assert min_dist < max_dist , <str> if args . transform == <str> :          log . info ( <str> ) ma . convert_to_zscore_matrix ( maxdepth = max_dist * 2.5 , perchr = True )  elif args . transform == <str> :          log . info ( <str> ) ma . convert_to_obs_exp_matrix ( maxdepth = max_dist * 2.5 , perchr = True )  min_dist_in_bins = int ( min_dist ) // bin_size max_dist_in_bins = int ( max_dist ) // bin_size bed_intervals = read_bed_per_chrom ( args . BED ) if args . BED2 :          bed_intervals2 = read_bed_per_chrom ( args . BED2 )  else :          bed_intervals2 = bed_intervals  M = args . numberOfBins if args . numberOfBins % 2 == 1 else args . numberOfBins + 1 M_half = int ( ( M - 1 ) // 2 ) chrom_matrix = OrderedDict ( ) chrom_total = { } chrom_diagonals = OrderedDict ( ) chrom_contact_position = { } seen = { } center_values = { } chrom_list = check_chrom_str_bytes ( bed_intervals , chrom_list ) for chrom in chrom_list :          if chrom not in bed_intervals or chrom not in bed_intervals2 :              continue  chrom_matrix [ chrom ] = [ ] chrom_total [ chrom ] = 1 chrom_diagonals [ chrom ] = [ ] chrom_contact_position [ chrom ] = [ ] center_values [ chrom ] = [ ] seen [ chrom ] = set ( ) over_1_5 = 0 empty_mat = 0 chrom_bin_range = ma . getChrBinRange ( toString ( chrom ) ) log . info ( <str> . format ( chrom ) ) counter = 0 for start , end in bed_intervals [ chrom ] :              if end > chrom_sizes [ chrom ] :                  continue  bin_id = ma . getRegionBinRange ( toString ( chrom ) , start , end ) if bin_id is None :                  continue  else :                  bin_id = bin_id [ 0 ]  for start2 , end2 in bed_intervals2 [ chrom ] :                  counter += 1 if counter % 50000 == 0 :                      log . info ( <str> . format ( counter ) )  if end2 > chrom_sizes [ chrom ] :                      continue  bin_id2 = ma . getRegionBinRange ( toString ( chrom ) , start2 , end2 ) if bin_id2 is None :                      continue  else :                      bin_id2 = bin_id2 [ 0 ]  if bin_id2 in seen [ chrom ] :                      continue  if bin_id == bin_id2 :                      continue  if min_dist_in_bins <= abs ( bin_id2 - bin_id ) <= max_dist_in_bins :                      idx1 , idx2 = sorted ( [ bin_id , bin_id2 ] ) if ( idx1 , idx2 ) in seen [ chrom ] :                          continue  seen [ chrom ] . add ( ( idx1 , idx2 ) ) if idx1 - M_half < chrom_bin_range [ 0 ] or idx2 + 1 + M_half > chrom_bin_range [ 1 ] :                          continue  try :                          mat_to_append = ma . matrix [ idx1 - M_half : idx1 + M_half + 1 , : ] [ : , idx2 - M_half : idx2 + M_half + 1 ] . todense ( ) . astype ( float )  except IndexError :                          log . info ( <str> . format ( idx1 , idx2 ) ) continue  counter += 1 if counter % 1000 == 0 :                          log . info ( <str> . format ( counter ) )  if mat_to_append . sum ( ) == 0 :                          empty_mat += 1 continue  if args . transform == <str> and mat_to_append . sum ( ) > 0 :                          mat_to_append = mat_to_append / mat_to_append . sum ( )  chrom_total [ chrom ] += 1 chrom_matrix [ chrom ] . append ( mat_to_append ) chrom_diagonals [ chrom ] . append ( mat_to_append . diagonal ( ) ) center_values [ chrom ] . append ( ma . matrix [ idx1 , idx2 ] ) chrom_contact_position [ chrom ] . append ( ( start , end , start2 , end2 ) ) if ma . matrix [ idx1 , idx2 ] > 1.5 :                          over_1_5 += 1     if len ( chrom_matrix [ chrom ] ) == 0 :              log . warn ( <str> . format ( chrom ) ) chrom_matrix . pop ( chrom , None )  log . info ( <str> . format ( over_1_5 , float ( over_1_5 ) / len ( chrom_matrix [ chrom ] ) ) ) log . info ( <str> . format ( empty_mat , float ( empty_mat ) / counter ) )  if args . kmeans is not None :          cluster_ids = cluster_matrices ( chrom_matrix , args . kmeans , method = <str> , how = args . howToCluster ) num_clusters = args . kmeans  elif args . hclust is not None :          log . info ( <str> <str> ) cluster_ids = cluster_matrices ( chrom_matrix , args . hclust , method = <str> , how = args . howToCluster ) num_clusters = args . hclust  else :          cluster_ids = { } num_clusters = 1 for chrom in chrom_list :              if chrom not in bed_intervals or chrom not in bed_intervals2 :                  continue  cluster_ids [ chrom ] = [ range ( len ( chrom_matrix [ chrom ] ) ) ]   plot_aggregated_contacts ( chrom_matrix , chrom_contact_position , cluster_ids , num_clusters , M_half , args ) if args . outFileContactPairs :          for idx , chrom in enumerate ( chrom_matrix ) :              if chrom not in bed_intervals or chrom not in bed_intervals2 :                  continue  for cluster_number , cluster_indices in enumerate ( cluster_ids [ chrom ] ) :                  center_values_to_order = np . array ( center_values [ chrom ] ) [ cluster_indices ] center_values_order = np . argsort ( center_values_to_order ) [ : : - 1 ] output_name = <str> . format ( file = args . outFileContactPairs , chrom = chrom , id = cluster_number + 1 ) with open ( output_name , <str> ) as fh :                      for cl_idx in center_values_order :                          value = center_values_to_order [ cl_idx ] start , end , start2 , end2 = chrom_contact_position [ chrom ] [ cl_idx ] fh . write ( <str> . format ( chrom , start , end , chrom , start2 , end2 , value ) )      if args . diagnosticHeatmapFile :          plot_diagnostic_heatmaps ( chrom_diagonals , cluster_ids , M_half , args )    