import warnings warnings . simplefilter ( action = <str> , category = RuntimeWarning ) warnings . simplefilter ( action = <str> , category = PendingDeprecationWarning ) import sys import argparse from hicmatrix import HiCMatrix as hm from past . builtins import zip import numpy as np from hicexplorer . utilities import toString from hicexplorer . _version import __version__ import logging log = logging . getLogger ( __name__ ) def parse_arguments ( ) :      parser = argparse . ArgumentParser ( formatter_class = argparse . RawDescriptionHelpFormatter , description = ) parser . add_argument ( <str> , <str> , help = <str> , required = True ) parser . add_argument ( <str> , help = <str> , type = argparse . FileType ( <str> ) , required = True ) parser . add_argument ( <str> , <str> , help = <str> , required = True ) parser . add_argument ( <str> , action = <str> , version = <str> . format ( __version__ ) ) return parser  def merge_tad_bins ( hic , boundary_id_list , filename ) :      from hicexplorer . reduceMatrix import reduce_matrix hic . restoreMaskedBins ( ) ref_name_list , start_list , end_list , coverage_list = zip ( * hic . cut_intervals ) new_bins = [ ] bins_to_merge = [ ] prev_ref = ref_name_list [ 0 ] idx_start = 0 new_start = start_list [ 0 ] count = 0 for idx , ref in enumerate ( ref_name_list ) :          if ( count > 0 and idx in boundary_id_list ) or ref != prev_ref :              coverage = np . mean ( coverage_list [ idx_start : idx ] ) new_bins . append ( ( ref_name_list [ idx_start ] , new_start , end_list [ idx - 1 ] , coverage ) ) bins_to_merge . append ( list ( range ( idx_start , idx ) ) ) idx_start = idx new_start = start_list [ idx ] count = 0  prev_ref = ref count += 1  if len ( bins_to_merge ) > 0 :          coverage = np . mean ( coverage_list [ idx_start : ] ) new_bins . append ( ( ref , new_start , end_list [ idx ] , coverage ) ) bins_to_merge . append ( list ( range ( idx_start , idx + 1 ) ) ) hic . correction_factors = None hic . update_matrix ( reduce_matrix ( hic . matrix , bins_to_merge , diagonal = True ) , new_bins ) hic . save ( filename )  else :          log . info ( <str> )   def get_boundary_bin_id ( hic , bed_fh ) :      line_number = 0 boundaries = set ( ) for line in bed_fh . readlines ( ) :          line_number += 1 line = toString ( line ) if line . startswith ( <str> ) or line . startswith ( <str> ) or line . startswith ( <str> ) :              continue  try :              chrom , start , end = line . strip ( ) . split ( <str> ) [ 0 : 3 ]  except Exception as detail :              msg = <str> . format ( line , detail ) log . exception ( msg ) sys . exit ( )  try :              start = int ( start ) end = int ( end )  except ValueError as detail :              msg = <str> <str> . format ( line_number , detail ) log . exception ( msg ) sys . exit ( )  assert start <= end , <str> . format ( line_number , line ) start_bin , end_bin = hic . getRegionBinRange ( chrom , start , end ) boundaries . add ( start_bin ) boundaries . add ( end_bin )  return np . sort ( list ( boundaries ) )  def main ( args = None ) :      args = parse_arguments ( ) . parse_args ( args ) hic_ma = hm . hiCMatrix ( args . matrix ) hic_ma . restoreMaskedBins ( ) boundary_id_list = get_boundary_bin_id ( hic_ma , args . domains ) log . info ( <str> ) merge_tad_bins ( hic_ma , boundary_id_list , args . outFile )   