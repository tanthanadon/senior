import argparse import sys import os import errno import math from multiprocessing import Process , Queue import time import logging log = logging . getLogger ( __name__ ) import pybedtools import numpy as np import hicmatrix . HiCMatrix as hm from hicexplorer import utilities from hicexplorer . _version import __version__ from . lib import Viewpoint def parse_arguments ( args = None ) :      parser = argparse . ArgumentParser ( add_help = False , formatter_class = argparse . RawDescriptionHelpFormatter , description = ) parserRequired = parser . add_argument_group ( <str> ) parserRequired . add_argument ( <str> , <str> , help = <str> , required = True , nargs = <str> ) parserRequired . add_argument ( <str> , <str> , help = <str> , type = float , required = True ) parserMutuallyExclusiveGroupFilter = parser . add_mutually_exclusive_group ( required = True ) parserMutuallyExclusiveGroupFilter . add_argument ( <str> , <str> , help = <str> <str> , type = float ) parserMutuallyExclusiveGroupFilter . add_argument ( <str> , <str> , help = <str> <str> <str> , type = float ) parserRequired . add_argument ( <str> , <str> , help = <str> , required = True ) parserRequired . add_argument ( <str> , help = <str> <str> , required = True , type = int , nargs = 2 ) parserOpt = parser . add_argument_group ( <str> ) parserOpt . add_argument ( <str> , <str> , help = <str> , required = False , default = <str> ) parserOpt . add_argument ( <str> , <str> , help = <str> , required = False , default = <str> ) parserOpt . add_argument ( <str> , <str> , help = <str> , required = False , default = <str> ) parserOpt . add_argument ( <str> , <str> , help = <str> , required = False , default = <str> ) parserOpt . add_argument ( <str> , <str> , help = <str> , default = <str> ) parserOpt . add_argument ( <str> , <str> , help = <str> , default = <str> ) parserOpt . add_argument ( <str> , <str> , help = <str> , required = False , action = <str> ) parserOpt . add_argument ( <str> , <str> , help = <str> , required = False , default = 4 , type = int ) parserOpt . add_argument ( <str> , <str> , help = <str> , required = False , default = 500000 , type = int ) parserOpt . add_argument ( <str> , <str> , help = <str> , required = False , default = 10 , type = int ) parserOpt . add_argument ( <str> , <str> , type = int , default = 5 , help = <str> ) parserOpt . add_argument ( <str> , <str> , help = <str> <str> , type = int , default = 1000 , required = False ) parserOpt . add_argument ( <str> , <str> , help = <str> , required = False , default = 2 , type = int ) parserOpt . add_argument ( <str> , <str> , action = <str> , help = <str> ) parserOpt . add_argument ( <str> , action = <str> , version = <str> . format ( __version__ ) ) return parser  def compute_interaction_file ( pInteractionFilesList , pArgs , pViewpointObj , pBackgroundSumOfDensities , pQueue = None ) :      outfile_names = [ ] target_outfile_names = [ ] for interactionFile in pInteractionFilesList :          target_list = [ ] sample_prefix = <str> for sample in interactionFile :              if pArgs . interactionFileFolder != <str> :                  absolute_sample_path = pArgs . interactionFileFolder + <str> + sample  else :                  absolute_sample_path = sample  data = pViewpointObj . readInteractionFileForAggregateStatistics ( absolute_sample_path ) sample_prefix += sample . split ( <str> ) [ - 1 ] . split ( <str> ) [ 0 ] sample_prefix += <str> if pArgs . xFoldBackground is not None :                  accepted_scores , merged_lines_dict = merge_neighbors_x_fold ( pArgs . xFoldBackground , data , pViewpointObj , pResolution = pArgs . resolution )  else :                  accepted_scores , merged_lines_dict = merge_neighbors_loose_p_value ( pArgs . loosePValue , data , pViewpointObj , pResolution = pArgs . resolution )  accepted_scores , target_lines = compute_new_p_values ( accepted_scores , pBackgroundSumOfDensities , pArgs . pValue , merged_lines_dict , pArgs . peakInteractionsThreshold ) if len ( accepted_scores ) == 0 :                  if pArgs . batchMode :                      with open ( <str> , <str> ) as errorlog :                          errorlog . write ( <str> . format ( interactionFile [ 0 ] , interactionFile [ 1 ] ) )   else :                      log . info ( <str> )   outFileName = <str> . join ( sample . split ( <str> ) [ - 1 ] . split ( <str> ) [ : - 1 ] ) + <str> + pArgs . outFileNameSuffix if pArgs . batchMode :                  outfile_names . append ( outFileName )  outFileName = pArgs . outputFolder + <str> + outFileName write ( outFileName , data [ 0 ] , accepted_scores ) target_list . append ( target_lines )  target_list = [ item for sublist in target_list for item in sublist ] log . debug ( <str> . format ( interactionFile ) ) sample_name = <str> . join ( interactionFile [ 0 ] . split ( <str> ) [ - 1 ] . split ( <str> ) [ 0 ] . split ( <str> ) [ 1 : ] ) target_name = sample_prefix + sample_name + <str> target_outfile_names . append ( target_name ) target_name = pArgs . targetFolder + <str> + target_name writeTargetList ( target_list , target_name , pArgs )  if pQueue is None :          return target_outfile_names  pQueue . put ( [ outfile_names , target_outfile_names ] ) return  def compute_new_p_values ( pData , pBackgroundSumOfDensities , pPValue , pMergedLinesDict , pPeakInteractionsThreshold ) :      accepted = { } accepted_lines = [ ] for key in pData :          if key in pBackgroundSumOfDensities :              if int ( float ( pData [ key ] [ - 1 ] ) ) - 1 < 0 :                  pData [ key ] [ - 3 ] = pBackgroundSumOfDensities [ key ] [ 0 ]  else :                  try :                      if int ( float ( pData [ key ] [ - 1 ] ) ) < len ( pBackgroundSumOfDensities [ key ] ) :                          pData [ key ] [ - 3 ] = 1 - pBackgroundSumOfDensities [ key ] [ int ( float ( pData [ key ] [ - 1 ] ) ) ]  else :                          pData [ key ] [ - 3 ] = 1 - pBackgroundSumOfDensities [ key ] [ - 1 ]   except Exception :                      pData [ key ] [ - 3 ] = 1 - pBackgroundSumOfDensities [ key ] [ - 1 ] log . error ( <str> . format ( int ( float ( pData [ key ] [ - 1 ] ) ) , len ( pData [ key ] ) ) )   if pData [ key ] [ - 3 ] <= pPValue :                  if float ( pData [ key ] [ - 1 ] ) >= pPeakInteractionsThreshold :                      accepted [ key ] = pData [ key ] target_content = pMergedLinesDict [ key ] [ 0 ] [ : 3 ] target_content [ 2 ] = pMergedLinesDict [ key ] [ - 1 ] [ 2 ] accepted_lines . append ( target_content )     return accepted , accepted_lines  def merge_neighbors_x_fold ( pXfold , pData , pViewpointObj , pResolution ) :      accepted = { } accepted_line = { } for key in pData [ 1 ] :          if pData [ 1 ] [ key ] [ - 1 ] < pXfold :              continue  accepted [ key ] = pData [ 1 ] [ key ] accepted_line [ key ] = pData [ 2 ] [ key ]  if accepted_line :          return pViewpointObj . merge_neighbors ( accepted_line , pMergeThreshold = pResolution )  return accepted_line , None  def merge_neighbors_loose_p_value ( pLoosePValue , pData , pViewpointObj , pResolution ) :      accepted = { } accepted_line = { } for key in pData [ 1 ] :          if pData [ 1 ] [ key ] [ 1 ] > pLoosePValue :              continue  accepted [ key ] = pData [ 1 ] [ key ] accepted_line [ key ] = pData [ 2 ] [ key ]  if accepted_line :          return pViewpointObj . merge_neighbors ( accepted_line , pMergeThreshold = pResolution )  return accepted_line , None  def write ( pOutFileName , pHeader , pInteractionLines ) :      with open ( pOutFileName , <str> ) as file :          file . write ( pHeader ) file . write ( <str> ) file . write ( <str> ) for data in pInteractionLines :              new_line = <str> . join ( pInteractionLines [ data ] [ : 6 ] ) new_line += <str> + <str> . join ( format ( float ( x ) , <str> ) for x in pInteractionLines [ data ] [ 6 : ] ) new_line += <str> file . write ( new_line )    def call_multi_core ( pInteractionFilesList , pArgs , pViewpointObj , pBackgroundSumOfDensities ) :      outfile_names = [ None ] * pArgs . threads target_list_name = [ None ] * pArgs . threads interactionFilesPerThread = len ( pInteractionFilesList ) // pArgs . threads all_data_collected = False queue = [ None ] * pArgs . threads process = [ None ] * pArgs . threads thread_done = [ False ] * pArgs . threads for i in range ( pArgs . threads ) :          if i < pArgs . threads - 1 :              interactionFileListThread = pInteractionFilesList [ i * interactionFilesPerThread : ( i + 1 ) * interactionFilesPerThread ]  else :              interactionFileListThread = pInteractionFilesList [ i * interactionFilesPerThread : ]  queue [ i ] = Queue ( ) process [ i ] = Process ( target = compute_interaction_file , kwargs = dict ( pInteractionFilesList = interactionFileListThread , pArgs = pArgs , pViewpointObj = pViewpointObj , pBackgroundSumOfDensities = pBackgroundSumOfDensities , pQueue = queue [ i ] ) ) process [ i ] . start ( )  while not all_data_collected :          for i in range ( pArgs . threads ) :              if queue [ i ] is not None and not queue [ i ] . empty ( ) :                  background_data_thread = queue [ i ] . get ( ) outfile_names [ i ] , target_list_name [ i ] = background_data_thread queue [ i ] = None process [ i ] . join ( ) process [ i ] . terminate ( ) process [ i ] = None thread_done [ i ] = True   all_data_collected = True for thread in thread_done :              if not thread :                  all_data_collected = False   time . sleep ( 1 )  outfile_names = [ item for sublist in outfile_names for item in sublist ] target_list_name = [ item for sublist in target_list_name for item in sublist ] return outfile_names , target_list_name  def writeTargetList ( pTargetList , pOutFileName , pArgs ) :      target_list_ = [ ] for line in pTargetList :          target_list_ . append ( <str> . join ( line ) )  target_set = set ( target_list_ ) pTargetList = sorted ( list ( target_set ) ) a = pybedtools . BedTool ( pTargetList ) header = <str> header += str ( __version__ ) header += <str> header += <str> . format ( pOutFileName ) if pArgs . xFoldBackground :          header += <str> header += str ( pArgs . xFoldBackground ) header += <str>  else :          header += <str> header += str ( pArgs . loosePValue ) header += <str>  header += <str> header += str ( pArgs . pValue ) header += <str> if len ( pTargetList ) == 0 :          with open ( pOutFileName , <str> ) as file :              file . write ( header )   else :          a . sort ( ) . merge ( d = pArgs . resolution ) . saveas ( pOutFileName , trackline = header )   def main ( args = None ) :      args = parse_arguments ( ) . parse_args ( args ) if not os . path . exists ( args . outputFolder ) :          try :              os . makedirs ( args . outputFolder )  except OSError as exc :              if exc . errno != errno . EEXIST :                  raise    if not os . path . exists ( args . targetFolder ) :          try :              os . makedirs ( args . targetFolder )  except OSError as exc :              if exc . errno != errno . EEXIST :                  raise    viewpointObj = Viewpoint ( ) outfile_names = [ ] interactionFileList = [ ] background_model = viewpointObj . readBackgroundDataFile ( args . backgroundModelFile , args . range ) background_sum_of_densities_dict = viewpointObj . computeSumOfDensities ( background_model , args , pXfoldMaxValue = args . xFoldMaxValueNB ) if args . batchMode :          with open ( args . interactionFile [ 0 ] , <str> ) as interactionFile :              file_ = True while file_ :                  lines = [ ] for i in range ( 0 , args . computeSampleNumber ) :                      file_ = interactionFile . readline ( ) . strip ( ) if file_ != <str> :                          lines . append ( file_ )   if len ( lines ) > 0 :                      interactionFileList . append ( lines )    log . debug ( <str> . format ( interactionFileList ) ) outfile_names , target_list_name = call_multi_core ( interactionFileList , args , viewpointObj , background_sum_of_densities_dict )  else :          i = 0 while i < len ( args . interactionFile ) :              lines = [ ] for j in range ( 0 , args . computeSampleNumber ) :                  if i < len ( args . interactionFile ) :                      lines . append ( args . interactionFile [ i ] )  i += 1  interactionFileList . append ( lines )  target_list_name = compute_interaction_file ( interactionFileList , args , viewpointObj , background_sum_of_densities_dict )  if args . batchMode :          with open ( args . writeFileNamesToFile , <str> ) as nameListFile :              nameListFile . write ( <str> . join ( outfile_names ) )  with open ( args . targetFileList , <str> ) as targetNamesFile :              targetNamesFile . write ( <str> . join ( target_list_name ) )     