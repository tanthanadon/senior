import numpy as np import argparse import pandas as pd import matplotlib import matplotlib . pyplot as plt import logging from hicmatrix import HiCMatrix as hm from hicexplorer . _version import __version__ from hicexplorer . utilities import convertNansToZeros matplotlib . use ( <str> ) log = logging . getLogger ( __name__ ) def parse_arguments ( ) :      parser = argparse . ArgumentParser ( add_help = False , description = ) parserRequired = parser . add_argument_group ( <str> ) parserRequired . add_argument ( <str> , <str> , help = <str> , nargs = <str> , required = True ) parserRequired . add_argument ( <str> , help = <str> <str> <str> <str> <str> , required = True ) parserRequired . add_argument ( <str> , <str> , help = <str> <str> , required = True ) parserOpt = parser . add_argument_group ( <str> ) parserOpt . add_argument ( <str> , <str> , help = <str> , default = 30 , type = int ) parserOpt . add_argument ( <str> , help = <str> <str> , default = 0 , type = float ) parserOpt . add_argument ( <str> , help = <str> <str> , default = None ) parserOpt . add_argument ( <str> , help = <str> <str> <str> <str> <str> <str> <str> , nargs = <str> , type = int , default = None ) parserOpt . add_argument ( <str> , action = <str> , help = <str> ) parserOpt . add_argument ( <str> , action = <str> , version = <str> . format ( __version__ ) ) return parser  def count_interactions ( obs_exp , pc1 , quantiles_number , offset ) :      <str> <str> chromosomes = pc1 [ <str> ] . unique ( ) interaction_sum = np . zeros ( ( quantiles_number , quantiles_number ) ) number_of_bins = np . zeros ( ( quantiles_number , quantiles_number ) ) for chrom in chromosomes :          pc1_chr = pc1 . loc [ pc1 [ <str> ] == chrom ] . reset_index ( drop = True ) chr_range = obs_exp . getChrBinRange ( chrom ) chr_submatrix = obs_exp . matrix [ chr_range [ 0 ] : chr_range [ 1 ] , chr_range [ 0 ] : chr_range [ 1 ] ] if offset :              for dist in offset :                  assert ( dist >= 0 ) indices = np . arange ( 0 , chr_submatrix . shape [ 0 ] - dist ) chr_submatrix [ indices , indices + dist ] = np . nan chr_submatrix [ indices + dist , indices ] = np . nan   for qi in range ( 0 , quantiles_number ) :              row_indices = pc1_chr . loc [ pc1_chr [ <str> ] == qi ] . index if row_indices . empty :                  continue  for qj in range ( 0 , quantiles_number ) :                  col_indices = pc1_chr . loc [ pc1_chr [ <str> ] == qj ] . index if col_indices . empty :                      continue  submatrix = chr_submatrix [ np . ix_ ( row_indices , col_indices ) ] submatrix = submatrix . todense ( ) submatrix = submatrix [ ~ np . isnan ( submatrix ) ] submatrix = submatrix [ ~ np . isinf ( submatrix ) ] interaction_sum [ qi , qj ] += np . sum ( submatrix ) interaction_sum [ qj , qi ] += np . sum ( submatrix ) number_of_bins [ qi , qj ] += submatrix . shape [ 1 ] number_of_bins [ qj , qi ] += submatrix . shape [ 1 ]    return interaction_sum / number_of_bins  def within_vs_between_compartments ( normalised_sum_per_quantile , quantiles_number ) :      within_to_between = [ ] for q in range ( 1 , quantiles_number ) :          within_comps = normalised_sum_per_quantile [ 0 : q , 0 : q ] . sum ( ) + normalised_sum_per_quantile [ quantiles_number - q : quantiles_number , quantiles_number - q : quantiles_number ] . sum ( ) between_comps = normalised_sum_per_quantile [ 0 : q , quantiles_number - q : quantiles_number ] . sum ( ) + normalised_sum_per_quantile [ quantiles_number - q : quantiles_number , 0 : q ] . sum ( ) within_to_between . append ( within_comps / between_comps )  return within_to_between  def plot_polarization_ratio ( polarization_ratio , plotName , labels , number_of_quantiles ) :      for i , r in enumerate ( polarization_ratio ) :          plt . plot ( r , marker = <str> , label = labels [ i ] )  plt . axhline ( 1 , c = <str> , ls = <str> , lw = 1 ) plt . axvline ( number_of_quantiles / 2 , c = <str> , ls = <str> , lw = 1 ) plt . legend ( loc = <str> ) plt . xlabel ( <str> ) plt . ylabel ( <str> ) plt . title ( <str> ) plt . savefig ( plotName )  def main ( args = None ) :      args = parse_arguments ( ) . parse_args ( args ) pc1 = pd . read_table ( args . pca , header = None , sep = <str> , dtype = { 0 : <str> , 1 : <str> , 2 : <str> , 3 : <str> } ) pc1 = pc1 . rename ( columns = { 0 : <str> , 1 : <str> , 2 : <str> , 3 : <str> } ) if args . outliers != 0 :          quantile = [ args . outliers / 100 , ( 100 - args . outliers ) / 100 ] boundaries = np . nanquantile ( pc1 [ <str> ] . values . astype ( float ) , quantile ) quantiled_bins = np . linspace ( boundaries [ 0 ] , boundaries [ 1 ] , args . quantile )  else :          quantile = [ j / ( args . quantile - 1 ) for j in range ( 0 , args . quantile ) ] quantiled_bins = np . nanquantile ( pc1 [ <str> ] . values . astype ( float ) , quantile )  pc1 [ <str> ] = np . searchsorted ( quantiled_bins , pc1 [ <str> ] . values . astype ( float ) , side = <str> ) pc1 . loc [ pc1 [ <str> ] == np . nan ] [ <str> ] = args . quantile + 1 polarization_ratio = [ ] output_matrices = [ ] labels = [ ] for matrix in args . obsexp_matrices :          obs_exp = hm . hiCMatrix ( matrix ) name = <str> . join ( matrix . split ( <str> ) [ - 1 ] . split ( <str> ) [ 0 : - 1 ] ) labels . append ( name ) normalised_sum_per_quantile = count_interactions ( obs_exp , pc1 , args . quantile , args . offset ) normalised_sum_per_quantile = np . nan_to_num ( normalised_sum_per_quantile ) if args . outputMatrix :              output_matrices . append ( normalised_sum_per_quantile )  polarization_ratio . append ( within_vs_between_compartments ( normalised_sum_per_quantile , args . quantile ) )  if args . outputMatrix :          np . savez ( args . outputMatrix , [ matrix for matrix in output_matrices ] )  plot_polarization_ratio ( polarization_ratio , args . outputFileName , labels , args . quantile )   