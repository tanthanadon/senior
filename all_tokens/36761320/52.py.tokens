from himlarcli . client import Client from himlarcli . cinder import Cinder from himlarcli . nova import Nova from himlarcli . neutron import Neutron from himlarcli . glance import Glance from keystoneclient . v3 import client as keystoneclient import keystoneauth1 . exceptions as exceptions import random import string import re class Keystone ( Client ) :      def __init__ ( self , config_path , debug = False , log = None ) :          super ( Keystone , self ) . __init__ ( config_path , debug , log ) self . client = keystoneclient . Client ( session = self . sess , region_name = self . region ) self . domain_id = None  def get_client ( self ) :          return self . client  def get_domain_id ( self ) :          if not self . domain_id :              self . logger . warning ( <str> )  return self . domain_id  def set_domain ( self , domain ) :          self . domain_id = self . __get_domain ( domain )  def get_dataporten_domain ( self ) :          domain_desc = ( <str> <str> ) domains = self . client . domains . list ( ) for domain in domains :              if domain . description == domain_desc :                  return domain   return None  def get_regions ( self ) :          return self . client . regions . list ( )  def find_regions ( self , region_name = None ) :          region_list = list ( ) regions = self . client . regions . list ( ) for region in regions :              if region_name and region_name == region . id :                  region_list . append ( region . id ) self . logger . debug ( <str> % region_name ) break  elif not region_name :                  region_list . append ( region . id )   return region_list  def get_by_id ( self , obj_type , obj_id ) :          valid_objects = [ <str> , <str> , <str> ] if obj_type not in valid_objects :              self . logger . debug ( <str> % obj_type ) return None  try :              result = getattr ( self . client , <str> % obj_type ) . get ( obj_id )  except exceptions . http . NotFound :              self . logger . debug ( <str> % ( obj_type , obj_id ) ) result = None  return result  def get_project_by_name ( self , project_name ) :          domain_id = self . get_domain_id ( ) try :              project = self . client . projects . list ( domain = domain_id , name = project_name )  except exceptions . http . NotFound :              project = dict ( )  if project :              return project [ 0 ]  return None  def get_user_projects ( self , email , domain = None , ** kwargs ) :          domain_id = self . get_domain_id ( ) user = self . get_user_by_email ( email = email , user_type = <str> ) projects = list ( ) if user :              try :                  projects = self . client . projects . list ( domain = domain_id , user = user )  except exceptions . http . NotFound :                  pass   if not projects :              self . logger . debug ( <str> % email )  project_list = list ( ) for project in projects :              for k , v in kwargs . iteritems ( ) :                  if hasattr ( project , k ) and getattr ( project , k ) == v :                      project_list . append ( project )  elif not hasattr ( project , k ) :                      self . logger . debug ( <str> % ( project . name , k ) )   if not kwargs :                  project_list . append ( project )   return project_list  def get_user_by_email ( self , email , user_type ) :          email = self . __get_uib_email ( email ) if user_type == <str> :              domain = self . domain_id  elif user_type == <str> :              domain = self . get_dataporten_domain ( )  else :              domain = None  user = None try :              users = self . client . users . list ( domain = domain , name = email ) if len ( users ) > 0 :                  user = users [ 0 ]   except exceptions . http . NotFound as e :              user = None  if not user :              self . debug_log ( <str> % ( user_type , email ) )  return user  def get_group_by_email ( self , email ) :          domain_id = self . get_domain_id ( ) email = self . __get_uib_email ( email ) self . logger . debug ( <str> % email ) group_name = self . __get_group_name ( email ) try :              group = self . client . groups . list ( domain = domain_id , name = group_name )  except exceptions . http . NotFound :              self . logger . debug ( <str> % group_name ) group = dict ( )  if group :              return group [ 0 ]  return None  def get_user_objects ( self , email , domain ) :          domain_id = self . __get_domain ( domain ) obj = dict ( ) api = self . get_user_by_email ( email = email , user_type = <str> ) if not api :              self . logger . warning ( <str> % email )  dp = self . get_user_by_email ( email = email , user_type = <str> ) if not dp :              self . logger . warning ( <str> % email )  group = self . get_group_by_email ( email ) obj [ <str> ] = api obj [ <str> ] = dp obj [ <str> ] = group if api :              projects = self . client . projects . list ( domain = domain_id , user = api )  else :              projects = [ ]  obj [ <str> ] = projects return obj  def update_user ( self , user_id , ** kwargs ) :          self . debug_log ( <str> % kwargs ) if not self . dry_run :              self . client . users . update ( user = user_id , ** kwargs )   def get_project_count ( self , domain = False ) :          projects = self . __get_projects ( self . domain_id ) return len ( projects )  def get_user_count ( self , domain = False ) :          users = self . __get_users ( domain ) return len ( users )  def get_users ( self , domain = False , ** kwargs ) :          users = self . __get_users ( domain , ** kwargs ) return users  def get_project ( self , project , domain = None ) :          self . logger . debug ( <str> ) domain = self . __get_domain ( domain ) project = self . __get_project ( project , domain = domain ) return project  def get_all_projects ( self ) :          projects = self . client . projects . list ( domain = self . domain_id ) self . debug_log ( <str> % self . domain_id ) return projects  def get_projects ( self , ** kwargs ) :          project_list = self . __get_projects ( domain_id = self . domain_id , ** kwargs ) return project_list  def is_valid_user ( self , email , domain = None ) :          email = self . __get_uib_email ( email ) group = self . get_group_by_email ( email ) return bool ( group )  def list_users ( self , domain = False , ** kwargs ) :          user_list = self . __get_users ( domain , ** kwargs ) users = list ( ) for i in user_list :              users . append ( i . name )  return users  def list_projects ( self , domain = False , ** kwargs ) :          domain_id = self . get_domain_id ( domain ) project_list = self . __get_projects ( domain_id , ** kwargs ) projects = list ( ) for i in project_list :              projects . append ( i . name )  return projects  def list_quota ( self , project , domain = None ) :          domain = self . __get_domain ( domain ) project = self . __get_project ( project , domain = domain ) compute = self . __list_compute_quota ( project ) return dict ( { <str> : compute } )  def delete_project ( self , project_name , region = None ) :          project = self . get_project_by_name ( project_name = project_name ) if not project :              self . logger . debug ( <str> , project_name ) return None  if not region :              region = self . find_regions ( )  self . __delete_instances ( project , region ) self . __delete_images ( project , region ) self . __delete_security_groups ( project , region ) self . __delete_volumes ( project , region ) self . debug_log ( <str> % project_name ) if not self . dry_run :              return self . client . projects . delete ( project )  return None  def delete_user ( self , email , user_type ) :          user = self . get_user_by_email ( email , user_type ) if not user :              self . logger . debug ( <str> , email , user_type ) return  self . debug_log ( <str> % ( email , user_type ) ) if not self . dry_run :              self . client . users . delete ( user )   def delete_group ( self , email ) :          group = self . get_group_by_email ( email ) if not group :              self . logger . debug ( <str> , email ) return  self . debug_log ( <str> % group . name ) if not self . dry_run :              self . client . groups . delete ( group )   def user_cleanup ( self , email ) :          self . delete_user ( email , <str> ) self . delete_user ( email , <str> ) self . delete_group ( email ) self . delete_project ( self . get_project_name ( email , prefix = <str> ) ) self . delete_project ( self . get_project_name ( email , prefix = <str> ) )  def rename_user ( self , new_email , old_email ) :          changes = { <str> : { } , <str> : { } , <str> : { } } api = self . get_user_by_email ( old_email , <str> ) if not api :              self . log_error ( <str> , old_email )  self . debug_log ( <str> % ( old_email , new_email ) ) if not self . dry_run :              self . client . users . update ( user = api , name = new_email . lower ( ) , email = new_email . lower ( ) )  changes [ <str> ] [ api . name ] = new_email . lower ( ) group = self . get_group_by_email ( old_email ) if not group :              self . log_error ( <str> , old_email )  new_group_name = self . __get_group_name ( self . __get_uib_email ( new_email ) ) self . debug_log ( <str> % ( group . name , new_group_name ) ) if not self . dry_run :              self . client . groups . update ( group = group , name = <str> % new_group_name )  changes [ <str> ] [ group . name ] = new_group_name self . delete_user ( old_email , <str> ) personal = self . get_project_by_name ( self . get_project_name ( old_email , prefix = <str> ) ) new_personal_name = self . get_project_name ( new_email , prefix = <str> ) if personal :              self . debug_log ( <str> % ( personal . name , new_personal_name ) ) if not self . dry_run :                  self . client . projects . update ( project = personal , admin = new_email , name = new_personal_name )  changes [ <str> ] [ personal . name ] = new_personal_name  new_demo_name = self . get_project_name ( new_email , prefix = <str> ) demo = self . get_project_by_name ( self . get_project_name ( old_email , prefix = <str> ) ) if demo :              self . debug_log ( <str> % ( demo . name , new_demo_name ) ) if not self . dry_run :                  self . client . projects . update ( project = demo , admin = new_email , name = new_demo_name )  changes [ <str> ] [ demo . name ] = new_demo_name  return changes  def reset_password ( self , email , password = None ) :          dry_run_txt = <str> if self . dry_run else <str> user = self . get_user_by_email ( email = email , user_type = <str> ) if password == None :              password = self . generate_password ( )  if not user :              self . logger . warning ( <str> , email )  self . logger . debug ( <str> , dry_run_txt , email ) if not self . dry_run :              self . client . users . update ( user , password = password )  return <str> % password  def revoke_role ( self , emails , project_name , role_name = <str> ) :          project = self . get_project_by_name ( project_name = project_name ) if not project :              self . log_error ( <str> % project_name , 1 )  role = self . __get_role ( role_name ) if not role :              self . log_error ( <str> % role_name ) return  assignments = self . __get_role_assignments ( project_id = project . id , role_id = role . id ) for email in emails :              group = self . get_group_by_email ( email = email ) if not group :                  self . log_error ( <str> % email ) continue  if group . name not in assignments :                  self . debug_log ( <str> % group . name ) continue  self . debug_log ( <str> % ( role . name , email , project_name ) ) if not self . dry_run :                  try :                      self . client . roles . revoke ( role = role , project = project , group = group )  except exceptions . base . ClientException as e :                      self . log_error ( e )     def grant_role ( self , email , project_name , role_name = <str> ) :          if not self . dry_run :              project = self . get_project_by_name ( project_name = project_name )  if not self . dry_run and not project :              self . log_error ( <str> % project_name , 1 )  if <str> in email :              group = self . __get_group ( email )  else :              group = self . get_group_by_email ( email = email )  if not group :              self . log_error ( <str> % email ) return  role = self . __get_role ( role_name ) if not role :              self . log_error ( <str> % role_name ) return  exists = None try :              if not self . dry_run :                  roles = self . client . roles . list ( project = project , group = group ) for r in roles :                      if r . name == role . name :                          exists = True continue     except exceptions . http . NotFound as e :              self . log_error ( e )  self . logger . debug ( <str> , role . name , email , project_name ) if exists :              self . log_error ( <str> % ( role . name , email , project_name ) )  elif self . dry_run :              data = { <str> : group . name , <str> : project_name , <str> : role . name } self . log_dry_run ( function = <str> , ** data )  else :              self . client . roles . grant ( role = role , project = project , group = group )   def list_roles ( self , project_name , domain = None ) :          project = self . get_project_by_name ( project_name = project_name ) roles = self . client . role_assignments . list ( project = project ) role_list = list ( ) for role in roles :              group = self . get_by_id ( <str> , role . group [ <str> ] ) if hasattr ( role , <str> ) else None role = self . client . roles . get ( role . role [ <str> ] ) if hasattr ( role , <str> ) else None if hasattr ( group , <str> ) :                  role_list . append ( dict ( { <str> : group . name , <str> : role . name } ) )  else :                  self . logger . debug ( <str> % ( role . group [ <str> ] ) )   return role_list  def update_project ( self , project_id , project_name = None , description = None , ** kwargs ) :          if self . dry_run :              data = kwargs . copy ( ) data . update ( { <str> : project_id } ) if project_name :                  data [ <str> ] = project_name  if description :                  data [ <str> ] = description  self . log_dry_run ( <str> , ** data ) return  try :              project = self . client . projects . update ( project = project_id , name = project_name , description = description , ** kwargs ) self . logger . debug ( <str> % project . name )  except exceptions . http . BadRequest as e :              self . log_error ( e ) self . log_error ( <str> % project_id )   def create_project ( self , project_name , admin = None , description = None , ** kwargs ) :          if description :              description = self . convert_ascii ( description )  parent_id = self . domain_id project_found = self . get_project_by_name ( project_name = project_name ) grant_role = True if admin and self . is_valid_user ( admin , parent_id ) else False if project_found :              self . log_error ( <str> % project_name ) return None  if self . dry_run :              data = kwargs . copy ( ) data . update ( { <str> : parent_id , <str> : project_name , <str> : description } ) self . log_dry_run ( <str> , ** data )  else :              try :                  project = self . client . projects . create ( name = project_name , domain = parent_id , parent = parent_id , enabled = True , description = description , admin = admin , ** kwargs ) self . logger . debug ( <str> % project_name )  except exceptions . http . BadRequest as e :                  self . log_error ( e ) self . log_error ( <str> % project_name ) return None   if grant_role :              self . grant_role ( project_name = project_name , email = admin )  if self . dry_run :              return data  return project  def create_user ( self , name , email , password = None , user_type = <str> , ** kwargs ) :          if not self . __validate_email ( email . lower ( ) ) :              self . log_error ( <str> % email ) return  domain = self . domain_id group_name = self . __get_group_name ( name ) username = name . lower ( ) if not password :              password = self . generate_password ( )  group = user = None try :              if not self . dry_run :                  group = self . client . groups . create ( name = group_name , domain = domain ) self . logger . debug ( <str> , group . to_dict ( ) )  else :                  self . log_dry_run ( <str> , ** { <str> : group_name } )   except exceptions . http . BadRequest as e :              self . log_error ( e ) return  except exceptions . http . Conflict as e :              self . logger . debug ( <str> , group_name )  try :              if not self . dry_run :                  user = self . client . users . create ( name = username , domain = domain , email = email . lower ( ) , type = user_type , password = password , ** kwargs ) self . logger . debug ( <str> , user . to_dict ( ) )  else :                  data = kwargs . copy ( ) data . update ( { <str> : username , <str> : email . lower ( ) , <str> : user_type } ) self . log_dry_run ( <str> , ** data )   except exceptions . http . BadRequest as e :              self . log_error ( e ) return  except exceptions . http . Conflict as e :              self . logger . debug ( <str> , name ) password = None  try :              if not self . dry_run and user and group :                  self . client . users . add_to_group ( user = user , group = group )   except exceptions . http . BadRequest as e :              self . log_error ( e ) return  if password :              print <str> % password   def provision_dataporten ( self , email , password ) :          self . logger . debug ( <str> , email ) self . create_user ( name = email , email = email , password = password ) project_name = self . get_project_name ( email ) desc = <str> % email . lower ( ) project = self . create_project ( project_name = project_name , admin = email . lower ( ) , type = <str> , description = desc )  def set_identity_provider ( self , name , remote_id , description ) :          try :              self . client . federation . identity_providers . find ( id = name ) self . debug_log ( <str> . format ( name ) ) return  except exceptions . http . NotFound :              pass  self . debug_log ( <str> . format ( name ) ) if self . dry_run :              return  self . client . federation . identity_providers . create ( id = name , enabled = True , remote_ids = [ remote_id ] , description = description )  def set_mapping ( self , mapping_id , rules ) :          try :              self . client . federation . mappings . find ( id = mapping_id ) self . debug_log ( <str> . format ( mapping_id ) ) return  except exceptions . http . NotFound :              pass  self . debug_log ( <str> . format ( mapping_id ) ) if not self . dry_run :              self . client . federation . mappings . create ( mapping_id = mapping_id , rules = rules )   def set_protocol ( self , protocol_id , provider , mapping ) :          try :              self . client . federation . protocols . find ( id = protocol_id ) self . debug_log ( <str> . format ( protocol_id ) ) return  except exceptions . http . NotFound :              pass  self . debug_log ( <str> . format ( protocol_id , provider ) ) if not self . dry_run :              self . client . federation . protocols . create ( protocol_id , identity_provider = provider , mapping = mapping )   def create_group ( self , name , description , domain ) :          self . logger . debug ( <str> % ( name ) ) domain = self . __get_domain ( domain ) project = None if not self . __get_group ( group = name , domain = domain ) :              project = self . client . groups . create ( name = name , domain = domain , description = description )  return project  @ staticmethod def generate_password ( size = 16 , chars = None ) :          if not chars :              chars = string . ascii_letters + string . digits  return <str> . join ( random . choice ( chars ) for _ in range ( size ) )  @ staticmethod def get_project_name ( email , prefix = <str> ) :          project_name = email . lower ( ) . replace ( <str> , <str> ) project_name = <str> % ( prefix , project_name ) return project_name  def __get_project ( self , project , domain = None , user = None ) :          projects = self . client . projects . list ( domain = domain , user = user ) for p in projects :              if p . name == project :                  self . logger . debug ( <str> % project ) return p   self . logger . debug ( <str> % project ) return None  def __get_user_by_email ( self , email , domain_id ) :          users = self . client . users . list ( domain = domain_id ) match = list ( ) for user in users :              if user . name == email and user . domain_id == domain_id :                  self . logger . debug ( <str> % email ) match . append ( user )   if not match :              self . logger . debug ( <str> % email )  return match  def __get_role_assignments ( self , project_id , role_id = None , rvalue = <str> , vtype = <str> ) :          include_names = True if vtype == <str> else False assignments = self . client . role_assignments . list ( project = project_id , role = role_id , include_names = include_names ) rlist = list ( ) for a in assignments :              if hasattr ( a , rvalue ) :                  value = getattr ( a , rvalue ) if vtype in value :                      rlist . append ( value [ vtype ] )    return rlist  def __get_role ( self , role_name ) :          try :              role = self . client . roles . find ( name = role_name , domain = self . domain_id )  except exceptions . http . NotFound as e :              self . logger . debug ( <str> % role_name ) role = None  return role  def __get_group ( self , group , domain = None , user = None ) :          groups = self . client . groups . list ( domain = domain , user = user ) for g in groups :              if g . name == group :                  self . logger . debug ( <str> % group ) return g   self . logger . debug ( <str> % group ) return None  def __get_domain ( self , domain ) :          try :              domain_obj = self . client . domains . find ( name = domain )  except exceptions . http . NotFound :              self . debug_log ( <str> . format ( domain ) ) domain_obj = None  return domain_obj . id if domain_obj else None  def __get_projects ( self , domain_id , ** kwargs ) :          projects = self . client . projects . list ( domain = domain_id ) self . logger . debug ( <str> % ( domain_id ) ) if kwargs :              self . logger . debug ( <str> % kwargs ) project_list = list ( ) for p in projects :                  for k , v in kwargs . iteritems ( ) :                      if hasattr ( p , k ) and getattr ( p , k ) == v :                          project_list . append ( p )    return project_list  else :              return projects   def __get_users ( self , domain = False , ** kwargs ) :          if domain :              domain_id = self . __get_domain ( domain ) users = self . client . users . list ( domain = domain_id , ** kwargs ) self . logger . debug ( <str> % domain )  else :              users = self . client . users . list ( ** kwargs )  return users  def __delete_instances ( self , project , region ) :          regions = [ region ] if not isinstance ( region , list ) else region for region in regions :              nc = self . _get_client ( Nova , region ) nc . delete_project_instances ( project , self . dry_run )   def __delete_images ( self , project , region ) :          regions = [ region ] if not isinstance ( region , list ) else region for region in regions :              gc = self . _get_client ( Glance , region ) gc . delete_private_images ( project . id )   def __delete_security_groups ( self , project , region ) :          regions = [ region ] if not isinstance ( region , list ) else region for region in regions :              nc = self . _get_client ( Neutron , region ) nc . purge_security_groups ( project )   def __delete_volumes ( self , project , region ) :          regions = [ region ] if not isinstance ( region , list ) else region for region in regions :              cc = self . _get_client ( Cinder , region ) cc . purge_project_volumes ( project . id )   def __list_compute_quota ( self , project ) :          self . novaclient = Nova ( config_path = self . config_path , debug = self . debug , log = self . logger , region = self . region ) return self . novaclient . get_quota ( project . id )  def __set_compute_quota ( self , project , quota ) :          self . novaclient = Nova ( config_path = self . config_path , debug = self . debug , log = self . logger , region = self . region ) return self . novaclient . set_quota ( project . id , quota )  @ staticmethod def get_user_org ( email ) :          if not <str> in email :              return None  domain = email . split ( <str> ) [ 1 ] if domain and <str> in domain :              return domain . split ( <str> ) [ - 2 ]  return None  @ staticmethod def __get_group_name ( email ) :          return <str> % email  @ staticmethod def __get_uib_email ( email ) :          if not email or <str> not in email or <str> not in email :              return email  ( user , domain ) = email . split ( <str> ) return <str> % ( user . title ( ) , domain )  @ staticmethod def __validate_email ( email ) :          match = <str> if re . match ( match , email ) != None :              return True  return False    