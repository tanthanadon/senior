from himlarcli . client import Client from novaclient import client as novaclient from novaclient . api_versions import APIVersion import novaclient . exceptions as exceptions from keystoneclient . v3 import client as keystoneclient import keystoneauth1 . exceptions as keyexc from datetime import date , datetime , timedelta import urllib2 import time class Nova ( Client ) :      USE_REGION = True instances = dict ( ) ksclient = None valid_objects = [ <str> , <str> ] def __init__ ( self , config_path , debug = False , log = None , region = None ) :          super ( Nova , self ) . __init__ ( config_path , debug , log , region ) version = self . get_config ( <str> , <str> ) self . debug_log ( <str> % version ) self . client = novaclient . Client ( APIVersion ( version ) , session = self . sess , region_name = self . region )  def get_keystone_client ( self ) :          if not self . ksclient :              self . ksclient = keystoneclient . Client ( session = self . sess , region_name = self . region )  return self . ksclient  def get_by_name ( self , obj_type , obj_name , is_public = None ) :          if obj_type not in self . valid_objects :              self . logger . debug ( <str> , obj_type ) return  try :              return getattr ( self . client , <str> % obj_type ) . find ( name = obj_name , is_public = is_public )  except novaclient . exceptions . NotFound :              self . logger . debug ( <str> , obj_type , obj_name )   def get_by_id ( self , obj_type , obj_id ) :          if obj_type not in self . valid_objects :              self . logger . debug ( <str> , obj_type ) return None  try :              result = getattr ( self . client , <str> % obj_type ) . get ( obj_id )  except novaclient . exceptions . NotFound :              self . logger . debug ( <str> , obj_type , obj_id ) result = None  return result  def get_keypairs ( self , user_id ) :          return self . client . keypairs . list ( user_id = user_id , marker = 0 , limit = 50 )  def create_server ( self , name , flavor , image_id , ** kwargs ) :          try :              server = self . client . servers . create ( name = name , flavor = flavor , image = image_id , ** kwargs )  except ( exceptions . Conflict , exceptions . Forbidden ) as e :              self . log_error ( e ) server = None  return server  def get_host ( self , hostname , detailed = False ) :          try :              hosts = self . client . hypervisors . search ( hostname )  except novaclient . exceptions . NotFound as e :              self . logger . warning ( <str> , e ) return None  for host in hosts :              if host . hypervisor_hostname == hostname :                  if detailed :                      return self . client . hypervisors . get ( host . id )  return host    def get_hosts ( self , detailed = True ) :          return self . client . hypervisors . list ( detailed )  def get_service ( self , host , service = <str> ) :          return self . client . services . list ( host = host , binary = service )  def enable_host ( self , name , service = <str> ) :          services = self . client . services . list ( host = name , binary = service ) for s in services :              self . client . services . enable ( s . id )  self . logger . debug ( <str> % ( service , name ) )  def disable_host ( self , name , service = <str> ) :          services = self . client . services . list ( host = name , binary = service ) for s in services :              self . client . services . disable ( s . id )  self . logger . debug ( <str> % ( service , name ) )  def move_host_aggregate ( self , hostname , aggregate , remove_from_old = True ) :          host = self . get_host ( hostname ) to_agg = self . get_aggregate ( aggregate ) if not host : return if not to_agg : return if hostname in to_agg . hosts : return if host . status != <str> :              if not self . dry_run : self . enable_host ( hostname ) enabled = True  else : enabled = False if remove_from_old :              aggregates = self . get_aggregates ( False ) for agg in aggregates :                  if hostname in agg . hosts :                      if not self . dry_run : agg . remove_host ( hostname ) self . logger . debug ( <str> , hostname , agg . name )    if not self . dry_run :              to_agg . add_host ( hostname )  self . logger . debug ( <str> , hostname , to_agg . name ) if enabled and not self . dry_run :              self . disable_host ( hostname )  return True  def get_filtered_aggregates ( self , ** kwargs ) :          aggregates = self . client . aggregates . findall ( ** kwargs ) return aggregates  def get_aggregates ( self , simple = True ) :          aggregates = self . client . aggregates . list ( ) if not simple :              return aggregates  agg_list = list ( ) for aggregate in aggregates :              agg_list . append ( aggregate . name )  return agg_list  def get_aggregate ( self , aggregate ) :          try :              aggregate = self . client . aggregates . find ( name = aggregate )  except novaclient . exceptions . NotFound as e :              self . logger . warning ( e ) return None  return aggregate  def get_aggregate_hosts ( self , aggregate , detailed = False ) :          aggregate = self . __get_aggregate ( aggregate ) hosts = list ( ) if not aggregate :              return hosts  for h in aggregate . hosts :              hosts . append ( self . get_host ( h , detailed ) )  return hosts  def update_aggregate ( self , aggregate , metadata ) :          aggregate = self . __get_aggregate ( aggregate ) return self . client . aggregates . set_metadata ( aggregate . id , metadata )  def get_instances ( self , aggregate = None , host = None , simple = False ) :          if not aggregate :              instances = self . __get_instances ( host = host )  else :              agg = self . __get_aggregate ( aggregate ) if not agg . hosts :                  self . logger . debug ( <str> % aggregate ) instances = list ( )  else :                  instances = list ( ) for h in agg . hosts :                      if host and host != h :                          self . logger . debug ( <str> % ( h , aggregate ) ) continue  self . logger . debug ( <str> % ( h , aggregate ) ) instances += self . __get_instances ( h )    host_txt = <str> % host if host else <str> self . logger . debug ( <str> % ( len ( instances ) , aggregate , host_txt ) ) if not simple :              return instances  else :              instance_list = list ( ) for i in instances :                  instance_list . append ( i . name )  return instance_list   def get_users ( self , aggregate = None , simple = False ) :          self . get_keystone_client ( ) instances = self . get_instances ( aggregate ) emails = set ( ) if simple else list ( ) for i in instances :              try :                  user = self . ksclient . users . get ( i . user_id )  except keyexc . http . NotFound :                  self . logger . error ( <str> , i . id , i . name ) continue  self . logger . debug ( <str> % ( user . name , i . name ) ) if not simple :                  emails . append ( user )  elif <str> in user . name :                  emails . add ( user . name . lower ( ) ) self . logger . debug ( <str> % user . name )   return emails  def get_all_aggregate_hosts ( self ) :          aggregates = self . client . aggregates . list ( ) hosts = dict ( ) for aggregate in aggregates :              if not hasattr ( aggregate , <str> ) :                  continue  for h in aggregate . hosts :                  hosts [ h ] = aggregate . name   return hosts  def get_availability_zones ( self ) :          az = self . client . availability_zones . list ( ) return az  def get_instance ( self , server_id ) :          return self . client . servers . get ( server = server_id )  def get_all_instances ( self , search_opts = None ) :          if not search_opts :              search_opts = { <str> : 1 }  elif <str> not in search_opts :              search_opts . update ( { <str> : 1 } )  return self . __get_all_instances ( search_opts )  def get_project_instances ( self , project_id , deleted = False ) :          search_opts = dict ( tenant_id = project_id , all_tenants = 1 ) if deleted :              search_opts [ <str> ] = 1  instances = self . __get_all_instances ( search_opts = search_opts ) self . logger . debug ( <str> % ( len ( instances ) , project_id ) ) return instances  def delete_project_instances ( self , project , dry_run = False ) :          search_opts = dict ( tenant_id = project . id , all_tenants = 1 ) instances = self . __get_all_instances ( search_opts = search_opts ) if not instances :              self . logger . debug ( <str> % project . name ) return  for i in instances :              if not dry_run :                  self . logger . debug ( <str> % ( i . name , project . name ) ) i . delete ( ) time . sleep ( 5 )  else :                  self . logger . debug ( <str> % ( i . name , project . name ) )    def get_quota ( self , project_id , detail = False ) :          result = self . client . quotas . get ( tenant_id = project_id , detail = detail ) if result :              return result . to_dict ( )  return dict ( )  def set_quota ( self , project_id , quota ) :          self . logger . debug ( <str> % quota ) self . client . quotas . update ( project_id , ** quota )  def update_quota ( self , project_id , updates ) :          dry_run_txt = <str> if self . dry_run else <str> self . logger . debug ( <str> % ( dry_run_txt , project_id , updates ) ) result = None try :              if not self . dry_run :                  result = self . client . quotas . update ( tenant_id = project_id , ** updates )   except novaclient . exceptions . NotFound as e :              self . log_error ( e )  return result  def update_quota_class ( self , class_name = <str> , updates = None ) :          if not updates :              updates = { }  return self . client . quota_classes . update ( class_name , ** updates )  def get_quota_class ( self , class_name = <str> ) :          return self . client . quota_classes . get ( class_name )  def list_users ( self ) :          instances = self . __get_instances ( ) emails = set ( ) for i in instances :              email = urllib2 . unquote ( i . user_id ) if <str> in email :                  emails . add ( email . lower ( ) ) self . logger . debug ( <str> % email )  else :                  self . logger . debug ( <str> % email )   return list ( emails )  def get_usage ( self , project_id = None , start = None , end = None ) :          if not start :              start = datetime . today ( ) - timedelta ( days = 7 )  if not end :              end = datetime . today ( )  if isinstance ( start , date ) :              start = datetime . combine ( start , datetime . min . time ( ) )  if isinstance ( end , date ) :              end = datetime . combine ( end , datetime . min . time ( ) )  if project_id :              usage = self . client . usage . get ( tenant_id = project_id , start = start , end = end )  else :              usage = self . client . usage . list ( detailed = True , start = start , end = end )  return usage  def save_states ( self ) :          instances = self . __get_all_instances ( ) if instances :              self . state . add_active ( instances ) self . state . close ( )   def get_stats ( self ) :          instances = self . __get_all_instances ( ) stats = dict ( ) stats [ <str> ] = len ( instances ) stats [ <str> ] = 0 for i in instances :              if i . status == <str> :                  stats [ <str> ] += 1   return stats  def stop_instances ( self , state = <str> ) :          self . __change_status ( <str> , state )  def start_instances ( self ) :          self . __change_status ( <str> , <str> )  def start_instances_from_state ( self ) :          instances = self . state . get_instances ( state = <str> , host = self . host ) count = 0 for i in instances :              instance = self . client . servers . get ( i [ 0 ] ) if instance . status != <str> :                  instance . start ( ) count += 1 self . logger . debug ( <str> % i [ 1 ] )  else :                  self . logger . debug ( <str> % i [ 1 ] )   print <str> % ( count )  def delete_instances ( self , state = <str> ) :          self . __change_status ( <str> , state )  def get_client ( self ) :          return self . client  def update_flavor ( self , name , spec , properties = None , public = True ) :          dry_run_txt = <str> if self . dry_run else <str> flavor = self . get_by_name ( <str> , name ) if not flavor :              self . logger . debug ( <str> , dry_run_txt , name ) if not self . dry_run :                  flavor = self . client . flavors . create ( name = name , ram = spec [ <str> ] , vcpus = spec [ <str> ] , disk = spec [ <str> ] , is_public = public )   update = False if flavor and getattr ( flavor , <str> ) != public :              update = True  for k , v in spec . iteritems ( ) :              if flavor and v != getattr ( flavor , k ) :                  update = True   if update :              self . logger . debug ( <str> , dry_run_txt , name ) if not self . dry_run :                  self . client . flavors . delete ( flavor . id ) flavor = self . client . flavors . create ( name = name , ram = spec [ <str> ] , vcpus = spec [ <str> ] , disk = spec [ <str> ] , is_public = public )   if not flavor :              return  for k , v in flavor . get_keys ( ) . iteritems ( ) :              if k not in properties :                  if not self . dry_run :                      flavor . unset_keys ( [ k ] )  self . logger . debug ( <str> , dry_run_txt , k )   update = False if not properties :              return  flavor_keys = flavor . get_keys ( ) for k , v in properties . iteritems ( ) :              if str ( v ) != flavor_keys . get ( k ) :                  self . logger . debug ( <str> , dry_run_txt , k ) if not self . dry_run :                      try :                          flavor . set_keys ( { k : v } )  except novaclient . exceptions . BadRequest as e :                          self . logger . debug ( <str> , e )      def get_flavors ( self , filters = None , sort_key = <str> , sort_dir = <str> ) :          flavors = self . client . flavors . list ( detailed = True , is_public = None , sort_key = sort_key , sort_dir = sort_dir ) flavors_filtered = list ( ) if filters :              for flavor in flavors :                  if filters in flavor . name :                      self . logger . debug ( <str> % flavor . name ) flavors_filtered . append ( flavor )  else :                      self . logger . debug ( <str> % flavor . name )   return flavors_filtered  else :              return flavors   def purge_flavors ( self , filters , flavors ) :          dry_run_txt = <str> if self . dry_run else <str> current_flavors = self . get_flavors ( filters ) for flavor in current_flavors :              if flavor . name not in flavors [ filters ] :                  if not self . dry_run :                      self . client . flavors . delete ( flavor . id )  self . logger . debug ( <str> % ( dry_run_txt , flavor . name ) )    def update_flavor_access ( self , filters , project_id , action ) :          dry_run_txt = <str> if self . dry_run else <str> if action == <str> :              action_func = <str>  else :              action_func = <str>  flavors = self . get_flavors ( filters ) for flavor in flavors :              try :                  if not self . dry_run :                      getattr ( self . client . flavor_access , action_func ) ( flavor . id , project_id )  self . logger . debug ( <str> % ( dry_run_txt , action , flavor . name ) )  except novaclient . exceptions . Conflict :                  self . logger . debug ( <str> % ( flavor . name ) )  except novaclient . exceptions . NotFound :                  self . logger . debug ( <str> % ( action , flavor . name ) )    def get_flavor_access ( self , filters ) :          flavors = self . get_flavors ( filters ) access_list = dict ( ) for flavor in flavors :              if getattr ( flavor , <str> ) :                  self . debug_log ( <str> % flavor . name ) continue  access_list [ flavor . name ] = self . client . flavor_access . list ( flavor = flavor . id )  return access_list  def __change_status ( self , action = <str> , state = <str> , instances = None ) :          if not instances :              instances = self . __get_instances ( )  count = 0 for i in instances :              if i . status == state :                  getattr ( i , action ) ( ) count += 1 self . instances [ i . name ] = i . id self . logger . debug ( <str> % ( action , i . name ) )  else :                  self . logger . debug ( <str> % ( i . name , state ) )   self . logger . debug ( <str> % ( action , count , state ) )  def __get_instances ( self , host = None ) :          search_opts = dict ( all_tenants = 1 , host = host ) instances = self . client . servers . list ( detailed = True , search_opts = search_opts ) return instances  def __get_all_instances ( self , search_opts = None ) :          if not search_opts :              search_opts = dict ( all_tenants = 1 )  try :              instances = self . client . servers . list ( detailed = True , search_opts = search_opts )  except novaclient . exceptions . ClientException as e :              self . log_error ( e ) return list ( )  return instances  def __get_aggregate ( self , aggregate ) :          aggregates = self . client . aggregates . list ( ) for a in aggregates :              if a . name == aggregate :                  return a   return None    