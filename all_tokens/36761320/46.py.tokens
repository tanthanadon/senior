import sys import os from datetime import datetime from datetime import date import ConfigParser import logging import logging . config import yaml import hashlib import functools import urllib import urllib2 from string import Template import socket def get_client ( name , options , logger , region = None ) :      if region :          client = name ( options . config , debug = options . debug , region = region , log = logger )  else :          client = name ( options . config , debug = options . debug , log = logger )  client . set_dry_run ( options . dry_run ) return client  def sys_error ( text , code = 1 ) :      sys . stderr . write ( <str> % text ) if code > 0 :          sys . exit ( code )   def check_port ( address , port , timeout = 60 , log = None ) :      sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) sock . settimeout ( timeout ) try :          sock . connect ( ( address , int ( port ) ) ) if log :              log . debug ( <str> % ( address , port ) )  sock . close ( ) return True  except socket . error , e :          if log :              log . debug ( <str> % ( address , port , e ) )  return False   def confirm_action ( question ) :      question = <str> % question answer = raw_input ( question ) if answer . lower ( ) == <str> :          return True  sys . stderr . write ( <str> ) return False  def append_to_file ( filename , text ) :      filename = get_abs_path ( filename ) f = open ( filename , <str> ) f . write ( <str> % text ) f . close ( )  def get_config ( config_path ) :      if not os . path . isfile ( config_path ) :          logging . critical ( <str> % config_path ) sys . exit ( 1 )  config = ConfigParser . ConfigParser ( ) config . read ( config_path ) return config  def get_date ( datestr , default , format = <str> ) :      if datestr :          try :              return datetime . strptime ( datestr , format ) . date ( )  except ValueError :              sys_error ( <str> % ( format , datestr ) , 1 )   else :          return default   def past_date ( datestr , format = <str> ) :      if datestr :          try :              past = datetime . strptime ( datestr , format ) . date ( ) today = date . today ( ) if past < today :                  return True   except ValueError as e :              sys_error ( e , 0 )   return False  def convert_date ( datestr , old_format , new_format = <str> ) :      return datetime . strptime ( datestr , old_format ) . strftime ( new_format )  def get_logger ( name , config , debug , log = None ) :      if log :          mylog = log  else :          try :              path = config . get ( <str> , <str> )  except ( ConfigParser . NoOptionError , ConfigParser . NoSectionError ) :              path = <str>  mylog = setup_logger ( name , debug , path )  mylog . debug ( <str> ) return mylog  def is_virtual_env ( ) :      if not hasattr ( sys , <str> ) :          print <str> sys . exit ( 1 )   def setup_logger ( name , debug , log_path = <str> , configfile = <str> ) :      if not os . path . isfile ( configfile ) :          configfile = log_path + <str> + configfile  with open ( configfile , <str> ) as stream :          try :              config = yaml . full_load ( stream )  except yaml . YAMLError as exc :              print exc   if not os . path . isabs ( config [ <str> ] [ <str> ] [ <str> ] ) :          config [ <str> ] [ <str> ] [ <str> ] = log_path + config [ <str> ] [ <str> ] [ <str> ]  if config :          try :              logging . config . dictConfig ( config )  except ValueError as e :              print e print <str> sys . exit ( 1 )   logger = logging . getLogger ( name ) logging . captureWarnings ( True ) if ( debug ) :          ch = logging . StreamHandler ( ) format = <str> formatter = logging . Formatter ( format ) ch . setFormatter ( formatter ) ch . setLevel ( logging . DEBUG ) logger . addHandler ( ch )  return logger  def get_abs_path ( file ) :      abs_path = file if not os . path . isabs ( file ) :          install_dir = os . environ . get ( <str> ) if not install_dir :              install_dir = <str>  abs_path = install_dir + <str> + file  return abs_path  def load_template ( inputfile , mapping , log = None ) :      inputfile = get_abs_path ( inputfile ) if not os . path . isfile ( inputfile ) :          if log :              log . debug ( <str> % inputfile )  return None  with open ( inputfile , <str> ) as txt :          content = txt . read ( )  template = Template ( content ) return template . substitute ( mapping )  def load_txt_file ( inputfile , log = None ) :      inputfile = get_abs_path ( inputfile ) if not os . path . isfile ( inputfile ) :          if log :              log . debug ( <str> % inputfile )  return None  with open ( inputfile , <str> ) as txt :          content = txt . read ( )  return content  def load_file ( inputfile , log = None ) :      inputfile = get_abs_path ( inputfile ) if not os . path . isfile ( inputfile ) :          if log :              log . debug ( <str> % inputfile )  return { }  with open ( inputfile , <str> ) as stream :          data = stream . read ( ) . splitlines ( )  return data  def load_region_config ( configpath , filename = <str> , region = None , log = None ) :      regionfile = get_abs_path ( <str> % ( configpath , region ) ) if os . path . isfile ( regionfile ) :          configfile = <str> % ( configpath , region )  else :          configfile = <str> % ( configpath , filename )  return load_config ( configfile , log )  def file_exists ( test_file , log = None ) :      test_file = get_abs_path ( test_file ) if not os . path . isfile ( test_file ) :          if log :              log . debug ( <str> % test_file )  return False  return True  def load_config ( configfile , log = None ) :      configfile = get_abs_path ( configfile ) if not os . path . isfile ( configfile ) :          if log :              log . debug ( <str> % configfile )  return None  with open ( configfile , <str> ) as stream :          try :              config = yaml . full_load ( stream )  except yaml . YAMLError as exc :              print ( exc ) config = None   return config  def download_file ( target , source , logger , checksum_type = None , checksum_url = None , content_length = 1000 ) :      target = get_abs_path ( target ) if not os . path . isfile ( target ) :          try :              ( filename , headers ) = urllib . urlretrieve ( source , target )  except IOError as exc :              logger . warn ( <str> % source ) sys . stderr . write ( str ( exc ) + <str> ) return None  if int ( headers [ <str> ] ) < content_length :              logger . debug ( <str> % target ) if os . path . isfile ( target ) :                  os . remove ( target )  return None   if checksum_type and checksum_url :          checksum = checksum_file ( target , checksum_type ) response = urllib2 . urlopen ( checksum_url ) checksum_all = response . read ( ) if checksum not in checksum_all :              logger . debug ( <str> % checksum ) return None  else :              logger . debug ( <str> % checksum )   return target  def checksum_file ( file_path , type = <str> , chunk_size = 65336 ) :      assert isinstance ( chunk_size , int ) and chunk_size > 0 if type == <str> :          digest = hashlib . sha256 ( )  elif type == <str> :          digest = hashlib . md5 ( )  with open ( file_path , <str> ) as f :          [ digest . update ( chunk ) for chunk in iter ( functools . partial ( f . read , chunk_size ) , <str> ) ]  return digest . hexdigest ( )   