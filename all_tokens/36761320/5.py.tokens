from himlarcli import tests as tests tests . is_virtual_env ( ) from himlarcli . keystone import Keystone from himlarcli . parser import Parser from himlarcli . printer import Printer from himlarcli . mail import Mail from himlarcli import utils import re import os import csv parser = Parser ( ) options = parser . parse_args ( ) printer = Printer ( options . format ) kc = Keystone ( options . config , debug = options . debug ) kc . set_domain ( options . domain ) kc . set_dry_run ( options . dry_run ) logger = kc . get_logger ( ) def action_rename ( ) :      if not utils . confirm_action ( <str> ) :          return  mail = Mail ( options . config , debug = options . debug ) mail . set_dry_run ( options . dry_run ) fromaddr = <str> template_file = <str> logfile = <str> subject = <str> users = kc . get_users ( domain = options . domain ) if not users :          utils . sys_error ( <str> )  mapping = load_uio_users ( options . inputfile ) for u in users :          if not re . search ( <str> , u . name ) :              continue  if u . name not in mapping :              utils . sys_error ( <str> % u . name , 0 ) continue  print <str> % u . name changes = kc . rename_user ( mapping [ u . name ] , u . name ) changes_txt = <str> changes_txt += <str> % ( u . name , mapping [ u . name ] ) changes_txt += <str> for old_p , new_p in changes [ <str> ] . iteritems ( ) :              changes_txt += <str> % ( old_p , new_p )  body_content = utils . load_template ( inputfile = template_file , mapping = { <str> : changes_txt } , log = logger ) msg = mail . get_mime_text ( subject , body_content , fromaddr ) mail . send_mail ( u . name , msg , fromaddr ) if not options . dry_run :              utils . append_to_file ( logfile , u . name )  print <str> % u . name  mail . close ( )  def action_check ( ) :      users = kc . get_users ( domain = options . domain ) if not users :          utils . sys_error ( <str> )  mapping = load_uio_users ( options . inputfile ) printer . output_dict ( { <str> : <str> } ) output = dict ( { <str> : [ ] } ) found = dict ( ) count = 0 for u in users :          if not re . search ( <str> , u . name ) :              continue  if u . name not in mapping :              output [ <str> ] . append ( u . name ) count += 1  else :              if mapping [ u . name ] in found :                  utils . sys_error ( <str> % mapping [ u . name ] , 0 ) utils . sys_error ( <str> % ( u . name , found [ mapping [ u . name ] ] , mapping [ u . name ] ) , 0 )  else :                  found [ mapping [ u . name ] ] = u . name    printer . output_dict ( output ) printer . output_dict ( { <str> : <str> , <str> : count } )  def action_notify ( ) :      if not utils . confirm_action ( <str> ) :          return  mail = utils . get_client ( Mail , options , logger , None ) fromaddr = mail . get_config ( <str> , <str> ) logfile = <str> subject = <str> users = kc . get_users ( domain = options . domain ) for u in users :          if not re . search ( <str> , u . name ) :              if <str> in u . name :                  print <str> % u . name  continue  body_content = utils . load_template ( inputfile = options . template , mapping = { } , log = logger ) msg = mail . get_mime_text ( subject , body_content , fromaddr ) mail . send_mail ( u . name , msg , fromaddr ) if not options . dry_run :              utils . append_to_file ( logfile , u . name )  print <str> % u . name  mail . close ( )  def load_uio_users ( inputfile ) :      inputfile = utils . get_abs_path ( inputfile ) if not os . path . isfile ( inputfile ) :          utils . sys_error ( <str> % inputfile ) return None  users = dict ( ) with open ( inputfile , mode = <str> ) as csv_file :          csv_reader = csv . reader ( csv_file , delimiter = <str> ) header = True for row in csv_reader :              if header :                  header = False continue  users [ row [ 0 ] ] = row [ 1 ]   return users  action = locals ( ) . get ( <str> + options . action . replace ( <str> , <str> ) ) if not action :      utils . sys_error ( <str> % options . action )  action ( )  