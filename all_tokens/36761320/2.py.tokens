from himlarcli . keystone import Keystone from himlarcli . nova import Nova from himlarcli . cinder import Cinder from himlarcli . neutron import Neutron from himlarcli . parser import Parser from himlarcli . printer import Printer from himlarcli . mail import Mail from himlarcli import utils as himutils from datetime import datetime from email . mime . text import MIMEText import re himutils . is_virtual_env ( ) parser = Parser ( ) parser . set_autocomplete ( True ) options = parser . parse_args ( ) printer = Printer ( options . format ) project_msg_file = <str> project_hpc_msg_file = <str> access_msg_file = <str> access_user_msg_file = <str> ksclient = Keystone ( options . config , debug = options . debug ) ksclient . set_dry_run ( options . dry_run ) ksclient . set_domain ( options . domain ) logger = ksclient . get_logger ( ) if hasattr ( options , <str> ) :      regions = ksclient . find_regions ( region_name = options . region )  else :      regions = ksclient . find_regions ( )  if not regions :      himutils . sys_error ( <str> )  def action_create ( ) :      if not ksclient . is_valid_user ( options . admin , options . domain ) and options . type == <str> :          himutils . sys_error ( <str> , 1 )  quota = himutils . load_config ( <str> % options . quota ) if options . quota and not quota :          himutils . sys_error ( <str> % options . quota )  test = 1 if options . type == <str> else 0 project_msg = project_msg_file if options . enddate :          try :              enddate = datetime . strptime ( options . enddate , <str> ) . date ( )  except ValueError :              himutils . sys_error ( <str> % options . enddate , 1 )   else :          enddate = None  if options . type == <str> :          project_msg = project_hpc_msg_file if not enddate :              himutils . sys_error ( <str> , 1 )   createdate = datetime . today ( ) if not options . force :          print <str> % ( options . project , ksclient . convert_ascii ( options . desc ) , options . admin . lower ( ) , options . type , str ( enddate ) , options . quota , options . rt ) if not himutils . confirm_action ( <str> ) :              himutils . sys_error ( <str> , 1 )   project = ksclient . create_project ( project_name = options . project , admin = options . admin . lower ( ) , test = test , type = options . type , description = options . desc , enddate = str ( enddate ) , createdate = createdate . isoformat ( ) , quota = options . quota , rt = options . rt ) if not ksclient . is_valid_user ( options . admin , options . domain ) :          himutils . sys_error ( <str> % options . admin , 0 )  if not project :          himutils . sys_error ( <str> % options . project , 1 )  else :          output = Keystone . get_dict ( project ) output [ <str> ] = <str> % options . project printer . output_dict ( output )  for region in regions :          novaclient = Nova ( options . config , debug = options . debug , log = logger , region = region ) cinderclient = Cinder ( options . config , debug = options . debug , log = logger , region = region ) neutronclient = Neutron ( options . config , debug = options . debug , log = logger , region = region ) cinderclient . set_dry_run ( options . dry_run ) novaclient . set_dry_run ( options . dry_run ) neutronclient . set_dry_run ( options . dry_run ) project_id = Keystone . get_attr ( project , <str> ) if quota and <str> in quota and project :              cinderclient . update_quota ( project_id = project_id , updates = quota [ <str> ] )  if quota and <str> in quota and project :              novaclient . update_quota ( project_id = project_id , updates = quota [ <str> ] )  if quota and <str> in quota and project :              neutronclient . update_quota ( project_id = project_id , updates = quota [ <str> ] )   if options . mail :          mail = Mail ( options . config , debug = options . debug ) mail . set_dry_run ( options . dry_run ) if options . rt is None :              himutils . sys_error ( <str> )  else :              mapping = dict ( project_name = options . project , admin = options . admin . lower ( ) , quota = options . quota , end_date = str ( enddate ) ) subject = <str> % options . project body_content = himutils . load_template ( inputfile = project_msg , mapping = mapping )  if not body_content :              himutils . sys_error ( <str> % options . msg )  mime = mail . rt_mail ( options . rt , subject , body_content ) mail . send_mail ( <str> , mime )   def action_grant ( ) :      for user in options . users :          if not ksclient . is_valid_user ( email = user , domain = options . domain ) :              himutils . sys_error ( <str> % user )  project = ksclient . get_project_by_name ( project_name = options . project ) if not project :              himutils . sys_error ( <str> % options . project )  if hasattr ( project , <str> ) and ( project . type == <str> or project . type == <str> ) :              himutils . sys_error ( <str> % project . type )  role = ksclient . grant_role ( project_name = options . project , email = user ) if role :              output = role . to_dict ( ) if not isinstance ( role , dict ) else role output [ <str> ] = <str> % options . project printer . output_dict ( output )   if options . mail :          mail = Mail ( options . config , debug = options . debug ) mail . set_dry_run ( options . dry_run ) if options . rt is None :              himutils . sys_error ( <str> )  else :              rt_mapping = dict ( users = <str> . join ( options . users ) ) rt_subject = <str> % options . project rt_body_content = himutils . load_template ( inputfile = access_msg_file , mapping = rt_mapping )  rt_mime = mail . rt_mail ( options . rt , rt_subject , rt_body_content ) mail . send_mail ( <str> , rt_mime ) for user in options . users :              mapping = dict ( project_name = options . project , admin = project . admin ) body_content = himutils . load_template ( inputfile = access_user_msg_file , mapping = mapping ) msg = MIMEText ( body_content , <str> ) msg [ <str> ] = <str> % options . project mail . send_mail ( user , msg , fromaddr = <str> )    def action_delete ( ) :      question = <str> % options . project if not options . force and not himutils . confirm_action ( question ) :          return  ksclient . delete_project ( options . project )  def action_list ( ) :      search_filter = dict ( ) if options . filter and options . filter != <str> :          search_filter [ <str> ] = options . filter  projects = ksclient . get_projects ( ** search_filter ) count = 0 printer . output_dict ( { <str> : <str> } ) for project in projects :          project_type = project . type if hasattr ( project , <str> ) else <str> output_project = { <str> : project . id , <str> : project . name , <str> : project_type , } count += 1 printer . output_dict ( output_project , sort = True , one_line = True )  printer . output_dict ( { <str> : <str> , <str> : count } )  def action_expired ( ) :      search_filter = dict ( ) projects = ksclient . get_projects ( ** search_filter ) count = 0 i_count = 0 printer . output_dict ( { <str> : <str> } ) for project in projects :          if not hasattr ( project , <str> ) :              continue  project_type = project . type if hasattr ( project , <str> ) else <str> if re . search ( <str> , project . enddate ) :              new_enddate = himutils . convert_date ( project . enddate , <str> ) ksclient . update_project ( project_id = project . id , enddate = new_enddate ) project . enddate = new_enddate  if project . enddate == <str> or not himutils . past_date ( project . enddate ) :              continue  output_project = { 0 : project . id , 1 : project_type , 2 : project . name , 3 : project . enddate } resources = dict ( { <str> : 0 , <str> : 0 } ) for region in regions :              nc = himutils . get_client ( Nova , options , logger , region ) instances = nc . get_project_instances ( project_id = project . id ) resources [ <str> ] = resources . get ( <str> , 0 ) + len ( instances )  output_project [ 4 ] = resources [ <str> ] i_count += int ( resources [ <str> ] ) count += 1 printer . output_dict ( output_project , sort = True , one_line = True )  printer . output_dict ( { <str> : <str> , <str> : count , <str> : i_count } )  def action_show_access ( ) :      project = ksclient . get_project_by_name ( project_name = options . project ) if not project :          himutils . sys_error ( <str> % options . project )  roles = ksclient . list_roles ( project_name = options . project ) printer . output_dict ( { <str> : <str> % options . project } ) for role in roles :          printer . output_dict ( role , sort = True , one_line = True )   def action_show_quota ( ) :      project = ksclient . get_project_by_name ( project_name = options . project ) for region in regions :          novaclient = Nova ( options . config , debug = options . debug , log = logger , region = region ) cinderclient = Cinder ( options . config , debug = options . debug , log = logger , region = region ) neutronclient = Neutron ( options . config , debug = options . debug , log = logger , region = region ) components = { <str> : novaclient , <str> : cinderclient , <str> : neutronclient } for comp , client in components . iteritems ( ) :              quota = dict ( ) if hasattr ( client , <str> ) :                  quota = getattr ( client , <str> ) ( project . id )  else :                  logger . debug ( <str> % comp ) continue  if quota :                  quota . update ( { <str> : <str> % ( comp , region ) , <str> : region } ) printer . output_dict ( quota )     def action_show ( ) :      project = ksclient . get_project_by_name ( project_name = options . project ) if not project :          himutils . sys_error ( <str> % options . project )  output_project = project . to_dict ( ) output_project [ <str> ] = <str> % project . name printer . output_dict ( output_project )  def action_instances ( ) :      project = ksclient . get_project_by_name ( project_name = options . project ) for region in regions :          novaclient = Nova ( options . config , debug = options . debug , log = logger ) instances = novaclient . get_project_instances ( project_id = project . id ) if not instances :              himutils . sys_error ( <str> % options . project )  printer . output_dict ( { <str> : <str> } ) count = 0 for i in instances :              output = { <str> : i . id , <str> : i . name , <str> : region , } count += 1 printer . output_dict ( output , sort = True , one_line = True )  printer . output_dict ( { <str> : <str> , <str> : count } )   action = locals ( ) . get ( <str> + options . action . replace ( <str> , <str> ) ) if not action :      himutils . sys_error ( <str> % options . action )  action ( )  