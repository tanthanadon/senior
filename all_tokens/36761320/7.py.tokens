from himlarcli import tests as tests tests . is_virtual_env ( ) from himlarcli . keystone import Keystone from himlarcli . cinder import Cinder from himlarcli . nova import Nova from himlarcli . parser import Parser from himlarcli . printer import Printer from himlarcli import utils as utils parser = Parser ( ) options = parser . parse_args ( ) printer = Printer ( options . format ) kc = Keystone ( options . config , debug = options . debug ) kc . set_domain ( options . domain ) kc . set_dry_run ( options . dry_run ) logger = kc . get_logger ( ) if options . region and options . region in kc . find_regions ( options . region ) :      region = options . region  else :      region = kc . get_region ( )  def action_list ( ) :      search_opts = { } if options . project :          project = project = kc . get_project ( options . project ) if not project :              utils . sys_error ( <str> . format ( options . project ) )  search_opts [ <str> ] = project . id  else :          project_id = None  cc = Cinder ( options . config , debug = options . debug , log = logger , region = region ) volumes = cc . get_volumes ( detailed = True , search_opts = search_opts ) printer . output_dict ( { <str> : <str> } ) count = { <str> : 0 , <str> : 0 } for volume in volumes :          if options . type and options . type != volume . volume_type :              continue  count = print_and_count ( volume , count )  printer . output_dict ( { <str> : <str> , <str> : count [ <str> ] , <str> : count [ <str> ] } )  def action_orphan ( ) :      question = <str> if options . purge and not utils . confirm_action ( question ) :          return  cc = utils . get_client ( Cinder , options , logger , region ) volumes = cc . get_volumes ( detailed = True ) printer . output_dict ( { <str> : <str> } ) count = { <str> : 0 , <str> : 0 } for volume in volumes :          project = kc . get_by_id ( <str> , getattr ( volume , <str> ) ) if project :              continue  count = print_and_count ( volume , count ) if options . purge :              cc . delete_volume ( volume . id , True )   printer . output_dict ( { <str> : <str> , <str> : count [ <str> ] , <str> : count [ <str> ] } )  def print_and_count ( volume , count ) :      output = { <str> : volume . id , <str> : volume . name , <str> : volume . volume_type , <str> : volume . size } count [ <str> ] += 1 count [ <str> ] += volume . size printer . output_dict ( output , one_line = True ) return count  action = locals ( ) . get ( <str> + options . action . replace ( <str> , <str> ) ) if not action :      utils . sys_error ( <str> % options . action )  action ( )  