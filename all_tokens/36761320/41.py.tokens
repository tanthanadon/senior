from himlarcli . client import Client from neutronclient . v2_0 . client import Client as neutronclient from neutronclient . common import exceptions class Neutron ( Client ) :      def __init__ ( self , config_path , debug = False , log = None , region = None ) :          super ( Neutron , self ) . __init__ ( config_path , debug , log , region ) self . logger . debug ( <str> % self . region ) self . client = neutronclient ( session = self . sess , region_name = self . region )  def get_client ( self ) :          return self . client  def create_security_group ( self , name , description = <str> ) :          secgroup = self . client . create_security_group ( body = { <str> : { <str> : name , <str> : description } } ) return secgroup  def create_security_group_rule ( self , secgroup_id , port , protocol = <str> , ethertype = <str> ) :          self . logger . debug ( <str> , port , protocol , ethertype ) self . client . create_security_group_rule ( body = { <str> : { <str> : secgroup_id , <str> : <str> , <str> : protocol , <str> : port , <str> : port , <str> : ethertype } } )  def delete_security_group ( self , secgroup_id ) :          self . debug_log ( <str> % secgroup_id ) try :              self . client . delete_security_group ( secgroup_id )  except ( exceptions . NotFound , exceptions . Conflict ) as e :              self . log_error ( e )   def create_security_port_group ( self , name , port , ipv6 = True ) :          secgroup = self . create_security_group ( name ) self . create_security_group_rule ( secgroup [ <str> ] [ <str> ] , port ) if ipv6 :              self . create_security_group_rule ( secgroup_id = secgroup [ <str> ] [ <str> ] , port = port , ethertype = <str> )  return secgroup [ <str> ]  def purge_security_groups ( self , project ) :          sec_groups = self . client . list_security_groups ( tenant_id = project . id ) for sg in sec_groups [ <str> ] :              self . delete_security_group ( sg [ <str> ] )   def list_networks ( self , retrieve_all = True ) :          network_list = list ( ) networks = self . client . list_networks ( retrieve_all = retrieve_all ) if not networks :              return list ( )  for network in networks [ <str> ] :              network_list . append ( network )  return network_list  def get_quota_class ( self , class_name = <str> ) :          self . log_error ( <str> , 0 ) return dict ( )  def update_quota_class ( self , class_name = <str> , updates = None ) :          self . log_error ( <str> , 0 ) return dict ( )  def get_quota ( self , project_id , usage = False ) :          result = self . client . show_quota ( project_id = project_id ) if <str> in result :              return result [ <str> ]  return dict ( )  def update_quota ( self , project_id , updates ) :          dry_run_txt = <str> if self . dry_run else <str> self . logger . debug ( <str> % ( dry_run_txt , project_id , updates ) ) result = None try :              if not self . dry_run :                  result = self . client . update_quota ( project_id = project_id , body = { <str> : updates } )   except exceptions . NotFound as e :              self . log_error ( e )  return result    