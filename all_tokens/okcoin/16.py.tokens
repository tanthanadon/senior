import six if six . PY3 :      from base64 import encodebytes as base64encode  else :      from base64 import encodestring as base64encode  import uuid import hashlib from . _logging import * from . _url import * from . _socket import * from . _http import * from . _exceptions import * __all__ = [ <str> , <str> ] VERSION = 13 class handshake_response ( object ) :      def __init__ ( self , status , headers , subprotocol ) :          self . status = status self . headers = headers self . subprotocol = subprotocol   def handshake ( sock , hostname , port , resource , ** options ) :      headers , key = _get_handshake_headers ( resource , hostname , port , options ) header_str = <str> . join ( headers ) send ( sock , header_str ) dump ( <str> , header_str ) status , resp = _get_resp_headers ( sock ) success , subproto = _validate ( resp , key , options . get ( <str> ) ) if not success :          raise WebSocketException ( <str> )  return handshake_response ( status , resp , subproto )  def _get_handshake_headers ( resource , host , port , options ) :      headers = [ ] headers . append ( <str> % resource ) headers . append ( <str> ) headers . append ( <str> ) if port == 80 :          hostport = host  else :          hostport = <str> % ( host , port )  if <str> in options and options [ <str> ] :          headers . append ( <str> % options [ <str> ] )  else :          headers . append ( <str> % hostport )  if <str> in options and options [ <str> ] :          headers . append ( <str> % options [ <str> ] )  else :          headers . append ( <str> % hostport )  key = _create_sec_websocket_key ( ) headers . append ( <str> % key ) headers . append ( <str> % VERSION ) subprotocols = options . get ( <str> ) if subprotocols :          headers . append ( <str> % <str> . join ( subprotocols ) )  if <str> in options :          headers . extend ( options [ <str> ] )  cookie = options . get ( <str> , None ) if cookie :          headers . append ( <str> % cookie )  headers . append ( <str> ) headers . append ( <str> ) return headers , key  def _get_resp_headers ( sock , success_status = 101 ) :      status , resp_headers = read_headers ( sock ) if status != success_status :          raise WebSocketException ( <str> % status )  return status , resp_headers  _HEADERS_TO_CHECK = { <str> : <str> , <str> : <str> , } def _validate ( headers , key , subprotocols ) :      subproto = None for k , v in _HEADERS_TO_CHECK . items ( ) :          r = headers . get ( k , None ) if not r :              return False , None  r = r . lower ( ) if v != r :              return False , None   if subprotocols :          subproto = headers . get ( <str> , None ) . lower ( ) if not subproto or subproto not in [ s . lower ( ) for s in subprotocols ] :              error ( <str> + str ( subprotocols ) ) return False , None   result = headers . get ( <str> , None ) if not result :          return False , None  result = result . lower ( ) if isinstance ( result , six . text_type ) :          result = result . encode ( <str> )  value = ( key + <str> ) . encode ( <str> ) hashed = base64encode ( hashlib . sha1 ( value ) . digest ( ) ) . strip ( ) . lower ( ) success = ( hashed == result ) if success :          return True , subproto  else :          return False , None   def _create_sec_websocket_key ( ) :      uid = uuid . uuid4 ( ) return base64encode ( uid . bytes ) . decode ( <str> ) . strip ( )   