from __future__ import absolute_import import io import json import os import uuid import yaml import zipfile from datetime import timedelta from django . conf import settings from constance import config as cconfig from django . contrib . auth . models import Group from django . contrib . auth . models import Permission from django . contrib . auth . models import User from django . core . files . base import ContentFile from django . core . files . uploadedfile import SimpleUploadedFile from django . test import TestCase from django . utils . timezone import now from guardian . shortcuts import assign_perm from guardian . shortcuts import get_objects_for_user from mock import Mock from mock import patch from delft3dworker . models import Scenario from delft3dworker . models import Version_Docker from delft3dworker . models import Scene from delft3dworker . models import Workflow from delft3dworker . models import SearchForm from delft3dworker . models import Template from delft3dworker . utils import tz_now class ScenarioTestCase ( TestCase ) :      def setUp ( self ) :          self . user_foo = User . objects . create_user ( username = <str> ) self . template = Template . objects . create ( name = <str> ) self . scenario_single = Scenario . objects . create ( name = <str> , owner = self . user_foo , template = self . template ) self . scenario_multi = Scenario . objects . create ( name = <str> , owner = self . user_foo , template = self . template ) self . scenario_A = Scenario . objects . create ( name = <str> , owner = self . user_foo , template = self . template ) self . scenario_B = Scenario . objects . create ( name = <str> , owner = self . user_foo , template = self . template )  def test_scenario_parses_input ( self ) :          single_input = { <str> : { <str> : 0.0143 } , } multi_input = { <str> : { <str> : [ 0.0143 , 0.0145 , 0.0146 ] } , } self . scenario_single . load_settings ( single_input ) self . scenario_multi . load_settings ( multi_input ) self . assertEqual ( len ( self . scenario_single . scenes_parameters ) , 1 ) self . assertEqual ( len ( self . scenario_multi . scenes_parameters ) , 3 )  def test_hash_scenes ( self ) :          single_input = { <str> : { <str> : <str> , <str> : 0.3 , <str> : 0.01 , <str> : 0.1 , <str> : <str> , <str> : False , <str> : True , <str> : 0.0143 } , } self . scenario_A . load_settings ( single_input ) self . scenario_A . createscenes ( self . user_foo ) self . scenario_B . load_settings ( single_input ) self . scenario_B . createscenes ( self . user_foo ) scene = self . scenario_B . scene_set . all ( ) [ 0 ] self . assertIn ( self . scenario_A , scene . scenario . all ( ) ) self . assertIn ( self . scenario_B , scene . scenario . all ( ) )   class ScenarioControlTestCase ( TestCase ) :      def setUp ( self ) :          self . user_foo = User . objects . create_user ( username = <str> ) self . template = Template . objects . create ( name = <str> ) self . scenario_multi = Scenario . objects . create ( name = <str> , owner = self . user_foo , template = self . template ) multi_input = { <str> : { <str> : [ 0.0143 , 0.0145 , 0.0146 ] } , } self . scenario_multi . load_settings ( multi_input ) self . scenario_multi . createscenes ( self . user_foo )  @ patch ( <str> , autospec = True ) def test_start ( self , mocked_scene_method ) :          self . scenario_multi . start ( self . user_foo ) self . assertEqual ( mocked_scene_method . call_count , 3 )  @ patch ( <str> , autospec = True ) def redo_proc ( self , mocked_scene_method ) :          self . scenario_multi . redo_proc ( self . user_foo ) self . assertEqual ( mocked_scene_method . call_count , 3 )  @ patch ( <str> , autospec = True ) def redo_postproc ( self , mocked_scene_method ) :          self . scenario_multi . redo_postproc ( self . user_foo ) self . asserEqual ( mocked_scene_method . call_count , 3 )  @ patch ( <str> , autospec = True ) def test_abort ( self , mocked_scene_method ) :          self . scenario_multi . abort ( self . user_foo ) self . assertEqual ( mocked_scene_method . call_count , 3 )  @ patch ( <str> , autospec = True ) def test_delete ( self , mocked_scene_method ) :          self . scenario_multi . delete ( self . user_foo ) self . assertEqual ( mocked_scene_method . call_count , 3 )  @ patch ( <str> , autospec = True ) def test_publish_company ( self , mocked_scene_method ) :          self . scenario_multi . publish_company ( self . user_foo ) self . assertEqual ( mocked_scene_method . call_count , 3 )  @ patch ( <str> , autospec = True ) def test_publish_world ( self , mocked_scene_method ) :          self . scenario_multi . publish_world ( self . user_foo ) self . assertEqual ( mocked_scene_method . call_count , 3 )   class SceneTestCase ( TestCase ) :      def setUp ( self ) :          self . user_a = User . objects . create_user ( username = <str> ) self . user_b = User . objects . create_user ( username = <str> ) self . user_c = User . objects . create_user ( username = <str> ) company_w = Group . objects . create ( name = <str> ) for user in [ self . user_a , self . user_b , self . user_c ] :              company_w . user_set . add ( user ) for perm in [ <str> , <str> , <str> , <str> ] :                  user . user_permissions . add ( Permission . objects . get ( codename = perm ) )   company_x = Group . objects . create ( name = <str> ) company_x . user_set . add ( self . user_a ) company_x . user_set . add ( self . user_b ) company_y = Group . objects . create ( name = <str> ) company_y . user_set . add ( self . user_c ) self . template = Template . objects . create ( name = <str> , export_options = { <str> : { <str> : [ <str> , <str> , <str> ] , } , <str> : { <str> : [ <str> ] , <str> : <str> , } , } ) self . scenario = Scenario . objects . create ( name = <str> , template = self . template ) self . scene_1 = Scene . objects . create ( name = <str> , owner = self . user_a , shared = <str> , phase = Scene . phases . fin , ) self . scene_2 = Scene . objects . create ( name = <str> , owner = self . user_a , shared = <str> , phase = Scene . phases . idle , ) self . scene_1 . scenario . set ( [ self . scenario ] ) self . scene_2 . scenario . set ( [ self . scenario ] ) assign_perm ( <str> , self . user_a , self . scene_1 ) assign_perm ( <str> , self . user_a , self . scene_1 ) assign_perm ( <str> , self . user_a , self . scene_1 ) assign_perm ( <str> , self . user_a , self . scene_1 ) assign_perm ( <str> , self . user_a , self . scene_2 ) assign_perm ( <str> , self . user_a , self . scene_2 ) assign_perm ( <str> , self . user_a , self . scene_2 ) assign_perm ( <str> , self . user_a , self . scene_2 ) self . output_dir = { <str> : [ <str> , <str> , <str> ] , <str> : [ <str> , <str> ] , <str> : [ <str> , ] , <str> : [ <str> , ] , } for folder , files in self . output_dir . items ( ) :              test_path = os . path . join ( self . scene_1 . workingdir , folder ) if not os . path . exists ( test_path ) :                  os . makedirs ( test_path )  for file in files :                  open ( os . path . join ( test_path , file ) , <str> ) . close ( )    def test_after_publishing_rights_are_revoked ( self ) :          self . assertEqual ( self . scene_1 . shared , <str> ) self . assertTrue ( self . user_a . has_perm ( <str> , self . scene_1 ) ) self . assertTrue ( self . user_a . has_perm ( <str> , self . scene_1 ) ) self . assertTrue ( self . user_a . has_perm ( <str> , self . scene_1 ) ) self . assertTrue ( self . user_a . has_perm ( <str> , self . scene_1 ) ) self . scene_1 . publish_company ( self . user_a ) self . assertEqual ( self . scene_1 . shared , <str> ) self . assertTrue ( self . user_a . has_perm ( <str> , self . scene_1 ) ) self . assertTrue ( self . user_a . has_perm ( <str> , self . scene_1 ) ) self . assertTrue ( not self . user_a . has_perm ( <str> , self . scene_1 ) ) self . assertTrue ( not self . user_a . has_perm ( <str> , self . scene_1 ) ) self . scene_1 . publish_world ( self . user_a ) self . assertEqual ( self . scene_1 . shared , <str> ) self . assertTrue ( self . user_a . has_perm ( <str> , self . scene_1 ) ) self . assertTrue ( not self . user_a . has_perm ( <str> , self . scene_1 ) ) self . assertTrue ( not self . user_a . has_perm ( <str> , self . scene_1 ) ) self . assertTrue ( not self . user_a . has_perm ( <str> , self . scene_1 ) )  def test_publish_company_and_publish_world ( self ) :          scenes = get_objects_for_user ( self . user_a , <str> , Scene . objects . all ( ) , accept_global_perms = False ) self . assertEqual ( len ( get_objects_for_user ( self . user_b , <str> , Scene . objects . all ( ) , accept_global_perms = False ) ) , 0 ) self . assertEqual ( len ( get_objects_for_user ( self . user_c , <str> , Scene . objects . all ( ) , accept_global_perms = False ) ) , 0 ) scenes [ 0 ] . publish_company ( self . user_a ) scenes [ 1 ] . publish_company ( self . user_a ) self . assertEqual ( len ( get_objects_for_user ( self . user_b , <str> , Scene . objects . all ( ) , accept_global_perms = False ) ) , 1 ) self . assertEqual ( len ( get_objects_for_user ( self . user_c , <str> , Scene . objects . all ( ) , accept_global_perms = False ) ) , 0 ) scenes [ 0 ] . publish_world ( self . user_a ) scenes [ 1 ] . publish_world ( self . user_a ) self . assertEqual ( len ( get_objects_for_user ( self . user_b , <str> , Scene . objects . all ( ) , accept_global_perms = False ) ) , 1 ) self . assertEqual ( len ( get_objects_for_user ( self . user_c , <str> , Scene . objects . all ( ) , accept_global_perms = False ) ) , 1 )  def test_publish_world ( self ) :          scenes = get_objects_for_user ( self . user_a , <str> , Scene . objects . all ( ) , accept_global_perms = False ) self . assertEqual ( len ( get_objects_for_user ( self . user_b , <str> , Scene . objects . all ( ) , accept_global_perms = False ) ) , 0 ) self . assertEqual ( len ( get_objects_for_user ( self . user_c , <str> , Scene . objects . all ( ) , accept_global_perms = False ) ) , 0 ) scenes [ 0 ] . publish_world ( self . user_a ) scenes [ 1 ] . publish_world ( self . user_a ) self . assertEqual ( len ( get_objects_for_user ( self . user_b , <str> , Scene . objects . all ( ) , accept_global_perms = False ) ) , 1 ) self . assertEqual ( len ( get_objects_for_user ( self . user_c , <str> , Scene . objects . all ( ) , accept_global_perms = False ) ) , 1 )  def test_start_scene ( self ) :          started_date = None for phase in self . scene_1 . phases :              self . scene_1 . shift_to_phase ( phase [ 0 ] ) self . scene_1 . start ( ) self . assertEqual ( self . scene_1 . phase , self . scene_1 . phases . sim_start if ( phase [ 0 ] == self . scene_1 . phases . idle ) else phase [ 0 ] ) if phase [ 0 ] < self . scene_1 . phases . idle :                  self . assertEqual ( self . scene_1 . date_started , started_date )  if phase [ 0 ] == self . scene_1 . phases . idle :                  self . assertTrue ( self . scene_1 . date_started <= now ( ) ) started_date = self . scene_1 . date_started  else :                  self . assertEqual ( self . scene_1 . date_started , started_date )    def test_abort_scene ( self ) :          for phase in self . scene_1 . phases :              self . scene_1 . shift_to_phase ( phase [ 0 ] ) self . scene_1 . abort ( ) if ( phase [ 0 ] >= self . scene_1 . phases . sim_start ) and ( phase [ 0 ] <= self . scene_1 . phases . sim_fin ) :                  self . assertEqual ( self . scene_1 . phase , self . scene_1 . phases . sim_fin )  else :                  self . assertEqual ( self . scene_1 . phase , phase [ 0 ] )    def test_export_scene ( self ) :          stream = io . BytesIO ( ) zf = zipfile . ZipFile ( stream , <str> , zipfile . ZIP_STORED , True ) files_added = self . scene_1 . export ( zf , [ ] ) self . assertFalse ( files_added ) files_added = self . scene_1 . export ( zf , [ <str> ] ) self . assertTrue ( files_added ) self . assertEqual ( len ( zf . namelist ( ) ) , 4 ) zf . close ( ) stream = io . BytesIO ( ) zf = zipfile . ZipFile ( stream , <str> , zipfile . ZIP_STORED , True ) files_added = self . scene_1 . export ( zf , [ <str> ] ) self . assertTrue ( files_added ) self . assertEqual ( len ( zf . namelist ( ) ) , 1 ) zf . close ( ) stream = io . BytesIO ( ) zf = zipfile . ZipFile ( stream , <str> , zipfile . ZIP_STORED , True ) files_added = self . scene_1 . export ( zf , [ <str> , <str> ] ) self . assertEqual ( len ( zf . namelist ( ) ) , 5 ) zf . close ( )   class ScenarioZeroPhaseTestCase ( TestCase ) :      def test_phase_00 ( self ) :          self . template = Template . objects . create ( name = <str> ) self . scenario = Scenario . objects . create ( name = <str> , template = self . template ) scene = Scene . objects . create ( name = <str> ) scene . scenario . set ( [ self . scenario ] ) scene . phase = scene . phases . new scene . update_and_phase_shift ( ) scene . phase = scene . phases . new scene . update_and_phase_shift ( ) self . assertEqual ( scene . phase , scene . phases . idle ) self . assertEqual ( scene . workflow . desired_state , <str> ) self . assertEqual ( scene . workflow . cluster_state , <str> )   class ScenarioPhasesTestCase ( TestCase ) :      def setUp ( self ) :          self . template = Template . objects . create ( name = <str> ) self . scenario = Scenario . objects . create ( name = <str> , template = self . template ) self . scene_1 = Scene . objects . create ( name = <str> ) self . scene_1 . scenario . set ( [ self . scenario ] ) self . output_dir = { <str> : [ <str> , <str> , <str> ] , <str> : [ <str> , <str> ] , <str> : [ <str> , ] , } self . data = { <str> : 0.161 , <str> : 0.0718 , <str> : 0.0272 , <str> : 0.102 , <str> : float ( <str> ) , <str> : 0.394 , <str> : 0.887 , <str> : 0.299 , <str> : 0.00785 } self . cleaned_data = { <str> : 0.161 , <str> : 0.0718 , <str> : 0.0272 , <str> : 0.102 , <str> : None , <str> : 0.394 , <str> : 0.887 , <str> : 0.299 , <str> : 0.00785 } for folder , files in self . output_dir . items ( ) :              test_path = os . path . join ( self . scene_1 . workingdir , folder ) if not os . path . exists ( test_path ) :                  os . makedirs ( test_path )  for file in files :                  open ( os . path . join ( test_path , file ) , <str> ) . close ( ) if file == <str> :                      with open ( os . path . join ( test_path , file ) , <str> ) as f :                          json . dump ( self . data , f )     self . scene_1 . info = { <str> : { <str> : <str> , <str> : [ <str> , <str> , <str> ] , <str> : [ ] , <str> : <str> } , <str> : { <str> : <str> , <str> : [ <str> , <str> , <str> ] , <str> : [ ] , <str> : <str> } , <str> : { <str> : <str> , <str> : [ <str> , <str> , <str> ] , <str> : [ ] , <str> : <str> } , <str> : { <str> : <str> , <str> : [ <str> , <str> , <str> ] , <str> : [ ] , <str> : <str> } , <str> : { <str> : <str> , <str> : [ <str> , ] , <str> : [ ] , <str> : <str> } , <str> : { <str> : <str> , <str> : [ <str> , ] , <str> : { } , <str> : <str> } , } self . scene_1 . update_and_phase_shift ( ) self . p = self . scene_1 . phases  def test_phase_new ( self ) :          self . scene_1 . phase = self . p . new self . scene_1 . save ( ) self . scene_1 . update_and_phase_shift ( ) self . assertEqual ( self . scene_1 . phase , self . p . idle )  def test_phase_idle ( self ) :          self . scene_1 . phase = self . p . idle self . scene_1 . save ( ) self . scene_1 . update_and_phase_shift ( ) self . assertEqual ( self . scene_1 . phase , self . p . idle )  def test_phase_sim_start ( self ) :          self . scene_1 . phase = self . p . sim_start self . scene_1 . save ( ) self . scene_1 . update_and_phase_shift ( ) self . assertEqual ( self . scene_1 . phase , self . p . sim_start ) self . scene_1 . workflow . cluster_state = <str> self . scene_1 . workflow . save ( ) self . scene_1 . update_and_phase_shift ( ) self . assertEqual ( self . scene_1 . phase , self . p . sim_run )  def test_phase_sim_run ( self ) :          workflow = self . scene_1 . workflow workflow . cluster_state = <str> workflow . desired_state = <str> workflow . save ( ) self . scene_1 . phase = self . p . sim_run self . scene_1 . save ( ) self . scene_1 . update_and_phase_shift ( ) self . assertEqual ( self . scene_1 . phase , self . p . sim_run ) self . assertEqual ( self . scene_1 . info [ <str> ] [ <str> ] , [ <str> , ] ) self . assertEqual ( self . scene_1 . info [ <str> ] [ <str> ] , [ <str> , ] ) self . assertEqual ( self . scene_1 . info [ <str> ] [ <str> ] , [ <str> , ] ) self . assertEqual ( self . scene_1 . info [ <str> ] [ <str> ] [ <str> ] , self . cleaned_data ) workflow . cluster_state = <str> workflow . save ( ) self . scene_1 . update_and_phase_shift ( ) self . assertEqual ( self . scene_1 . phase , self . p . sim_fin )  def test_phase_sim_fin ( self ) :          self . scene_1 . phase = self . p . sim_fin workflow = self . scene_1 . workflow workflow . cluster_state = <str> workflow . save ( ) self . scene_1 . update_and_phase_shift ( ) self . assertEqual ( self . scene_1 . phase , self . p . fin )   class WorkflowTestCase ( TestCase ) :      def setUp ( self ) :          self . run_argo_ps_dict = { <str> : <str> , <str> : <str> , <str> : { <str> : { <str> : <str> } , <str> : <str> , } } self . fin_argo_ps_dict = { <str> : <str> , <str> : <str> , <str> : { <str> : { <str> : <str> } , <str> : <str> , } } self . fail_argo_ps_dict = { <str> : <str> , <str> : <str> , <str> : { <str> : { <str> : <str> } , <str> : <str> , } } self . template = Template . objects . create ( name = <str> ) self . scenario = Scenario . objects . create ( name = <str> , template = self . template ) self . scene_1 = Scene . objects . create ( name = <str> , phase = Scene . phases . fin ) self . scene_1 . save ( ) self . scene_1 . scenario . set ( [ self . scenario ] ) yaml = self . template . yaml_template = SimpleUploadedFile ( <str> , bytes ( yaml , <str> ) ) self . template . save ( ) self . version = Version_Docker . objects . create ( versions = { <str> : [ ] } , template = self . template ) self . version . save ( ) self . version2 = Version_Docker . objects . create ( versions = { <str> : [ ] , <str> : [ <str> , <str> ] } , changelog = <str> , template = self . template ) self . version2 . save ( ) self . workflow = Workflow . objects . create ( scene = self . scene_1 , desired_state = <str> , cluster_state = <str> , version = self . version , entrypoint = <str> )  def test_is_outdated ( self ) :          self . assertTrue ( self . workflow . is_outdated ( ) )  def test_latest_version ( self ) :          self . assertEqual ( self . workflow . latest_version ( ) , self . version2 )  def test_outdated_changelog ( self ) :          self . assertEqual ( self . workflow . outdated_changelog ( ) , self . version2 . changelog )  def test_outdated_entrypoints ( self ) :          self . assertEqual ( self . workflow . outdated_entrypoints ( ) , self . version2 . versions [ <str> ] )  @ patch ( <str> , autospec = True ) @ patch ( <str> , autospec = True ) def test_update_task_result ( self , MockedAsyncResult , mocked_warn_method ) :          async_result = MockedAsyncResult . return_value self . workflow . task_uuid = uuid . UUID ( <str> ) self . workflow . task_starttime = now ( ) async_result . ready . return_value = False async_result . state = <str> async_result . result = <str> , <str> async_result . successful . return_value = False self . workflow . update_task_result ( ) self . assertEqual ( async_result . ready . call_count , 1 ) self . assertEqual ( self . workflow . task_uuid , uuid . UUID ( <str> ) ) self . workflow . task_starttime = now ( ) - timedelta ( seconds = settings . TASK_EXPIRE_TIME * 2 ) self . workflow . update_task_result ( ) self . assertEqual ( self . workflow . task_uuid , None ) self . workflow . task_uuid = uuid . UUID ( <str> ) self . workflow . task_starttime = now ( ) async_result . ready . return_value = True async_result . result = ( <str> ) , <str> async_result . state = <str> self . workflow . update_task_result ( ) self . assertEqual ( mocked_warn_method . call_count , 3 ) self . workflow . task_uuid = uuid . UUID ( <str> ) async_result . ready . return_value = True async_result . successful . return_value = True async_result . result = ( <str> ) , <str> async_result . state = <str> self . workflow . update_task_result ( ) self . assertIsNone ( self . workflow . task_uuid )  @ patch ( <str> , autospec = True ) def test_update_progress ( self , MockedAsyncResult ) :          async_result = MockedAsyncResult . return_value self . workflow . task_uuid = uuid . UUID ( <str> ) self . workflow . task_starttime = now ( ) async_result . ready . return_value = True async_result . state = <str> async_result . result = <str> , <str> async_result . successful . return_value = True self . workflow . update_task_result ( ) self . assertEqual ( self . workflow . progress , 0 ) self . workflow . task_uuid = uuid . UUID ( <str> ) async_result . ready . return_value = True async_result . successful . return_value = True async_result . result = { <str> : } async_result . state = <str> self . workflow . update_task_result ( ) self . assertEqual ( self . workflow . progress , 56.0 )  @ patch ( <str> , autospec = True ) def test_update_state_and_save ( self , mocked_error_method ) :          self . workflow . sync_cluster_state ( None ) self . assertEqual ( self . workflow . cluster_state , <str> ) self . workflow . sync_cluster_state ( self . run_argo_ps_dict ) self . assertEqual ( self . workflow . cluster_state , <str> ) self . workflow . sync_cluster_state ( self . fail_argo_ps_dict ) self . assertEqual ( self . workflow . cluster_state , <str> ) self . workflow . sync_cluster_state ( self . fin_argo_ps_dict ) self . assertEqual ( self . workflow . cluster_state , <str> ) self . assertEqual ( mocked_error_method . call_count , 1 )  @ patch ( <str> , autospec = True ) def test_create_workflow ( self , mocked_task ) :          task_uuid = uuid . UUID ( <str> ) result = Mock ( ) mocked_task . return_value = result result . id = task_uuid self . workflow . create_workflow ( ) template_model = self . workflow . scene . scenario . first ( ) . template with open ( template_model . yaml_template . path ) as f :              template = yaml . load ( f )  template [ <str> ] = { <str> : <str> . format ( self . workflow . name ) } template [ <str> ] [ <str> ] [ <str> ] = [ { <str> : <str> , <str> : str ( self . scene_1 . suid ) } , { <str> : <str> , <str> : settings . BUCKETNAME } , { <str> : <str> , <str> : str ( self . version . revision ) } , { <str> : <str> , <str> : json . dumps ( self . scene_1 . parameters ) } ] mocked_task . assert_called_once_with ( args = ( template , ) , expires = settings . TASK_EXPIRE_TIME ) self . assertEqual ( self . workflow . task_uuid , task_uuid ) self . workflow . cluster_state = <str> self . workflow . create_workflow ( ) self . workflow . create_workflow ( ) self . workflow . create_workflow ( ) self . workflow . create_workflow ( ) mocked_task . assert_called_once_with ( args = ( template , ) , expires = settings . TASK_EXPIRE_TIME )  @ patch ( <str> , autospec = True ) def test_remove_workflow ( self , mocked_task ) :          task_uuid = uuid . UUID ( <str> ) self . workflow . desired_state = <str> self . workflow . cluster_state = <str> result = Mock ( ) result . id = task_uuid mocked_task . return_value = result self . workflow . remove_workflow ( ) mocked_task . assert_called_once_with ( args = ( self . workflow . name , ) , expires = settings . TASK_EXPIRE_TIME ) self . assertEqual ( self . workflow . task_uuid , task_uuid ) self . workflow . cluster_state = <str> self . workflow . remove_workflow ( ) self . workflow . remove_workflow ( ) self . workflow . remove_workflow ( ) self . workflow . remove_workflow ( ) mocked_task . assert_called_once_with ( args = ( self . workflow . name , ) , expires = settings . TASK_EXPIRE_TIME )  @ patch ( <str> , autospec = True ) def test_update_log ( self , mocked_task ) :          task_uuid = uuid . UUID ( <str> ) self . workflow . desired_state = <str> self . workflow . cluster_state = <str> result = Mock ( ) result . id = task_uuid mocked_task . return_value = result self . workflow . update_log ( ) mocked_task . assert_called_once_with ( args = ( self . workflow . name , ) , expires = settings . TASK_EXPIRE_TIME ) self . assertEqual ( self . workflow . task_uuid , task_uuid ) self . workflow . task_uuid = None self . workflow . update_log ( ) self . assertEqual ( mocked_task . call_count , 2 ) self . workflow . cluster_state = <str> self . workflow . update_log ( ) self . assertEqual ( mocked_task . call_count , 2 )  def test_reset_scene ( self ) :          date_started = now ( ) progress = 10 info = { <str> : <str> } self . workflow . entrypoint = <str> for phase in self . scene_1 . phases :              self . scene_1 . date_started = date_started self . scene_1 . progress = progress self . scene_1 . info = info self . scene_1 . shift_to_phase ( phase [ 0 ] ) self . scene_1 . reset ( ) self . assertEqual ( self . scene_1 . phase , self . scene_1 . phases . sim_start if ( phase [ 0 ] == self . scene_1 . phases . fin ) else phase [ 0 ] ) if phase [ 0 ] == self . scene_1 . phases . fin :                  self . assertTrue ( ( tz_now ( ) - self . scene_1 . date_started ) . seconds < 10 ) self . assertEqual ( self . scene_1 . progress , 0 ) self . assertEqual ( self . scene_1 . phase , self . scene_1 . phases . sim_start ) self . assertEqual ( self . scene_1 . info , { } )  else :                  self . assertEqual ( self . scene_1 . date_started , date_started ) self . assertEqual ( self . scene_1 . progress , progress ) self . assertEqual ( self . scene_1 . phase , phase [ 0 ] ) self . assertEqual ( self . scene_1 . info , { <str> : <str> } )    def test_redo_workflow ( self ) :          result = self . scene_1 . redo ( <str> ) self . assertEqual ( self . workflow . version , self . version2 ) self . assertTrue ( result )  def test_redo_scene ( self ) :          entrypoint = <str> date_started = now ( ) progress = 10 info = { <str> : <str> } for phase in self . scene_1 . phases :              self . workflow . entrypoint = <str> self . scene_1 . date_started = date_started self . scene_1 . progress = progress self . scene_1 . info = info self . scene_1 . shift_to_phase ( phase [ 0 ] ) self . scene_1 . redo ( entrypoint ) self . assertEqual ( self . scene_1 . phase , self . scene_1 . phases . sim_start if ( phase [ 0 ] == self . scene_1 . phases . fin ) else phase [ 0 ] ) if phase [ 0 ] == self . scene_1 . phases . fin :                  self . assertEqual ( self . workflow . entrypoint , <str> ) self . assertEqual ( self . scene_1 . phase , self . scene_1 . phases . sim_start ) self . assertEqual ( self . scene_1 . info , { } )  else :                  self . assertEqual ( self . workflow . entrypoint , <str> ) self . assertEqual ( self . scene_1 . phase , phase [ 0 ] ) self . assertEqual ( self . scene_1 . info , { <str> : <str> } )     class SearchFormTestCase ( TestCase ) :      def setUp ( self ) :          self . sections_a = self . sections_b = self . templates_res = json . loads ( ) self . sections_res = json . loads ( )    