from __future__ import absolute_import from datetime import datetime , timedelta import django_filters import io import logging import zipfile from django . contrib . auth . models import Group from django . contrib . auth . models import User from django . urls import reverse_lazy from django . core . exceptions import ValidationError from django . db . models import Q from django . forms . models import model_to_dict from django . http import HttpResponse from django . shortcuts import get_object_or_404 from django . utils import timezone from django . utils . dateparse import parse_date from django . utils . decorators import method_decorator from django . utils . text import slugify from django . views . decorators . csrf import csrf_exempt from django . views . generic import CreateView from django . views . generic import DeleteView from django . views . generic import View from guardian . shortcuts import assign_perm from guardian . shortcuts import get_objects_for_user from django_filters import rest_framework as e_filters from rest_framework import filters from rest_framework import status from rest_framework import viewsets from rest_framework import permissions from rest_framework . decorators import detail_route from rest_framework . decorators import list_route from rest_framework . decorators import action from rest_framework . decorators import parser_classes from rest_framework . response import Response from rest_framework . parsers import JSONParser from rest_framework_guardian import filters as guardian_filter from delft3dworker . models import Version_Docker from delft3dworker . models import Scenario from delft3dworker . models import Scene from delft3dworker . models import Template from delft3dworker . models import SearchForm from delft3dworker . models import Workflow from delft3dworker . models import GroupUsageSummary from delft3dworker . models import UserUsageSummary from delft3dworker . permissions import ViewObjectPermissions , RedoScenePermission from delft3dworker . serializers import GroupSerializer from delft3dworker . serializers import VersionSerializer from delft3dworker . serializers import ScenarioSerializer from delft3dworker . serializers import SceneFullSerializer from delft3dworker . serializers import SceneSparseSerializer from delft3dworker . serializers import SearchFormSerializer from delft3dworker . serializers import TemplateSerializer from delft3dworker . serializers import UserSerializer from delft3dworker . utils import tz_midnight class ScenarioFilter ( e_filters . FilterSet ) :      class Meta :          model = Scenario fields = [ <str> , ]   class SceneFilter ( e_filters . FilterSet ) :      scenario = django_filters . CharFilter ( field_name = <str> ) class Meta :          model = Scene fields = [ <str> , <str> , <str> ]   class ScenarioViewSet ( viewsets . ModelViewSet ) :      serializer_class = ScenarioSerializer filter_backends = ( django_filters . rest_framework . DjangoFilterBackend , filters . SearchFilter , filters . OrderingFilter , guardian_filter . DjangoObjectPermissionsFilter , ) permission_classes = ( permissions . IsAuthenticated , ViewObjectPermissions , ) ordering = ( <str> , ) filterset_class = ScenarioFilter queryset = Scenario . objects . none ( ) def get_queryset ( self ) :          queryset = Scenario . objects . all ( ) return queryset . order_by ( <str> )  def perform_create ( self , serializer ) :          if serializer . is_valid ( ) :              instance = serializer . save ( ) instance . owner = self . request . user parameters = serializer . validated_data [ <str> ] if ( <str> in serializer . validated_data ) else None if parameters :                  parameters [ <str> ] = { <str> : [ instance . template . name ] } instance . load_settings ( parameters ) instance . createscenes ( self . request . user )  assign_perm ( <str> , self . request . user , instance ) assign_perm ( <str> , self . request . user , instance ) assign_perm ( <str> , self . request . user , instance ) assign_perm ( <str> , self . request . user , instance ) instance . save ( )   def perform_destroy ( self , instance ) :          instance . delete ( self . request . user )  @ action ( methods = [ <str> ] , detail = True ) def start ( self , request , pk = None ) :          scenario = self . get_object ( ) scenario . start ( request . user ) serializer = self . get_serializer ( scenario ) return Response ( serializer . data )  @ action ( methods = [ <str> ] , detail = True ) def stop ( self , request , pk = None ) :          scenario = self . get_object ( ) scenario . abort ( ) serializer = self . get_serializer ( scenario ) return Response ( serializer . data )  @ action ( methods = [ <str> ] , detail = True ) def publish_company ( self , request , pk = None ) :          self . get_object ( ) . publish_company ( request . user ) return Response ( { <str> : <str> } )  @ action ( methods = [ <str> ] , detail = True ) def publish_world ( self , request , pk = None ) :          self . get_object ( ) . publish_world ( request . user ) return Response ( { <str> : <str> } )   class SceneViewSet ( viewsets . ModelViewSet ) :      serializer_class = SceneSparseSerializer filter_backends = ( django_filters . rest_framework . DjangoFilterBackend , filters . SearchFilter , filters . OrderingFilter , guardian_filter . DjangoObjectPermissionsFilter , ) ordering = ( <str> , ) filterset_class = SceneFilter search_fields = ( <str> , ) permission_classes = ( permissions . IsAuthenticated , ViewObjectPermissions , ) queryset = Scene . objects . none ( ) def get_serializer_class ( self ) :          if self . action == <str> :              return SceneSparseSerializer  else :              return SceneFullSerializer   def perform_create ( self , serializer ) :          if serializer . is_valid ( ) :              instance = serializer . save ( ) instance . owner = self . request . user instance . shared = <str> instance . save ( ) assign_perm ( <str> , self . request . user , instance ) assign_perm ( <str> , self . request . user , instance ) assign_perm ( <str> , self . request . user , instance ) assign_perm ( <str> , self . request . user , instance )   def get_queryset ( self ) :          queryset = Scene . objects . all ( ) parameters = self . request . query_params . getlist ( <str> , [ ] ) template = self . request . query_params . getlist ( <str> , [ ] ) shared = self . request . query_params . getlist ( <str> , [ ] ) users = self . request . query_params . getlist ( <str> , [ ] ) outdated = self . request . query_params . get ( <str> , <str> ) created_after = self . request . query_params . get ( <str> , <str> ) created_before = self . request . query_params . get ( <str> , <str> ) started_after = self . request . query_params . get ( <str> , <str> ) started_before = self . request . query_params . get ( <str> , <str> ) temp_workaround = False if len ( parameters ) > 0 :              try :                  for parameter in parameters :                      p = parameter . split ( <str> ) p = [ val for val in p if val != <str> ] if len ( p ) == 3 :                          key , minvalue , maxvalue = p logging . info ( <str> . format ( minvalue , maxvalue , key ) ) try :                              minvalue = float ( minvalue ) maxvalue = float ( maxvalue ) wanted = [ ] for scene in queryset :                                  value = scene . parameters . get ( key , { } ) . get ( <str> , <str> ) if ( value != <str> ) and ( minvalue <= value <= maxvalue ) :                                      wanted . append ( scene . id )  postprocess_output = scene . info . get ( <str> ) if key in postprocess_output :                                      value = postprocess_output [ key ] if ( minvalue <= value <= maxvalue ) :                                          wanted . append ( scene . id )    queryset = queryset . filter ( pk__in = wanted )  except ValueError :                              pass temp_workaround = True   if temp_workaround or len ( p ) == 2 or len ( p ) > 3 :                          key = p [ 0 ] values = p [ 1 : ] wanted = [ ] queryset = queryset . filter ( parameters__icontains = key ) for value in values :                              logging . info ( <str> . format ( key ) ) for scene in queryset :                                  if scene . parameters . get ( key , { } ) . get ( <str> , <str> ) == value :                                      wanted . append ( scene . id )    queryset = queryset . filter ( pk__in = wanted )    except Exception as e :                  logging . exception ( <str> . format ( parameters , template ) ) return Scene . objects . none ( )   if len ( template ) > 0 :              queryset = queryset . filter ( scenario__template__name__in = template ) . distinct ( )  if len ( shared ) > 0 :              lookup = { <str> : <str> , <str> : <str> , <str> : <str> } wanted = [ lookup [ share ] for share in shared if share in lookup ] queryset = queryset . filter ( shared__in = wanted )  if len ( users ) > 0 :              userids = [ int ( user ) for user in users if user . isdigit ( ) ] queryset = queryset . filter ( owner__in = userids )  if outdated != <str> :              pass  if created_after != <str> :              created_after_date = parse_date ( created_after ) if created_after_date :                  dt = tz_midnight ( created_after_date ) queryset = queryset . filter ( date_created__gte = dt )   if created_before != <str> :              created_before_date = parse_date ( created_before ) if created_before_date :                  dt = tz_midnight ( created_before_date + timedelta ( days = 1 ) ) queryset = queryset . filter ( date_created__lte = dt )   if started_after != <str> :              started_after_date = parse_date ( started_after ) if started_after_date :                  dt = tz_midnight ( started_after_date ) queryset = queryset . filter ( date_started__gte = dt )   if started_before != <str> :              started_before_date = parse_date ( started_before ) if started_before_date :                  dt = tz_midnight ( started_before_date + timedelta ( days = 1 ) ) queryset = queryset . filter ( date_started__lte = dt )   return queryset . distinct ( ) . order_by ( <str> )  @ action ( detail = True , methods = [ <str> ] ) def reset ( self , request , pk = None ) :          scene = self . get_object ( ) scene . reset ( ) serializer = self . get_serializer ( scene ) return Response ( serializer . data )  @ action ( methods = [ <str> ] , detail = True ) def start ( self , request , pk = None ) :          scene = self . get_object ( ) scene . start ( ) serializer = self . get_serializer ( scene ) return Response ( serializer . data )  @ action ( methods = [ <str> ] , detail = True , permission_classes = [ permissions . IsAuthenticated , RedoScenePermission ] ) def redo ( self , request , pk = None ) :          d = request . data valid = False if isinstance ( d , dict ) :              entrypoint = d . get ( <str> , None ) if entrypoint is not None :                  scene = self . get_object ( ) valid = scene . redo ( entrypoint )   if valid :              serializer = self . get_serializer ( scene ) return Response ( serializer . data )  else :              return Response ( <str> , status = status . HTTP_400_BAD_REQUEST )   @ action ( methods = [ <str> ] , detail = True ) def stop ( self , request , pk = None ) :          scene = self . get_object ( ) scene . abort ( ) serializer = self . get_serializer ( scene ) return Response ( serializer . data )  @ action ( methods = [ <str> ] , detail = True ) def publish_company ( self , request , pk = None ) :          published = self . get_object ( ) . publish_company ( request . user ) if not published :              return Response ( { <str> : <str> } , status = status . HTTP_400_BAD_REQUEST )  return Response ( { <str> : <str> } )  @ action ( methods = [ <str> ] , detail = False ) def publish_company_all ( self , request ) :          queryset = Scene . objects . filter ( owner = self . request . user ) . filter ( suid__in = request . data . getlist ( <str> , [ ] ) ) try :              for scene in queryset :                  scene . publish_company ( request . user )   except ( ValidationError , ValueError ) as e :              return Response ( { <str> : str ( e ) } , status = status . HTTP_400_BAD_REQUEST )  return Response ( { <str> : <str> } )  @ action ( methods = [ <str> ] , detail = True ) def publish_world ( self , request , pk = None ) :          published = self . get_object ( ) . publish_world ( request . user ) if not published :              return Response ( { <str> : <str> } , status = status . HTTP_400_BAD_REQUEST )  return Response ( { <str> : <str> } )  @ action ( methods = [ <str> ] , detail = False ) def publish_world_all ( self , request ) :          queryset = Scene . objects . filter ( owner = self . request . user ) . filter ( suid__in = request . data . getlist ( <str> , [ ] ) ) try :              for scene in queryset :                  scene . publish_world ( request . user )   except ( ValidationError , ValueError ) as e :              return Response ( { <str> : str ( e ) } , status = status . HTTP_400_BAD_REQUEST )  return Response ( { <str> : <str> } )  @ action ( methods = [ <str> ] , detail = True ) def export ( self , request , pk = None ) :          options = self . request . query_params . getlist ( <str> , [ ] ) if len ( options ) == 0 :              return Response ( { <str> : <str> } , status = status . HTTP_400_BAD_REQUEST )  scene = self . get_object ( ) stream = io . BytesIO ( ) zf = zipfile . ZipFile ( stream , <str> , zipfile . ZIP_STORED , True ) files_added = scene . export ( zf , options ) zf . close ( ) if not files_added :              return Response ( { <str> : <str> } , status = status . HTTP_400_BAD_REQUEST )  resp = HttpResponse ( stream . getvalue ( ) , content_type = <str> ) resp [ <str> ] = <str> . format ( <str> . format ( slugify ( scene . name ) ) ) return resp  @ action ( methods = [ <str> ] , detail = False ) def export_all ( self , request ) :          options = self . request . query_params . getlist ( <str> , [ ] ) if len ( options ) == 0 :              return Response ( { <str> : <str> } , status = status . HTTP_400_BAD_REQUEST )  queryset = get_objects_for_user ( self . request . user , <str> , accept_global_perms = False ) . filter ( suid__in = request . query_params . getlist ( <str> , [ ] ) ) stream = io . BytesIO ( ) zf = zipfile . ZipFile ( stream , <str> , zipfile . ZIP_STORED , True ) files_added = False for scene in queryset :              files_added = scene . export ( zf , options ) or files_added  zf . close ( ) if not files_added :              return Response ( { <str> : <str> } , status = status . HTTP_400_BAD_REQUEST )  resp = HttpResponse ( stream . getvalue ( ) , content_type = <str> ) resp [ <str> ] = <str> return resp  @ action ( methods = [ <str> ] , detail = False ) def versions ( self , request ) :          return Response ( { } )   class SearchFormViewSet ( viewsets . ModelViewSet ) :      serializer_class = SearchFormSerializer permission_classes = ( permissions . IsAuthenticated , ) def get_queryset ( self ) :          return SearchForm . objects . filter ( name = <str> )   class TemplateViewSet ( viewsets . ModelViewSet ) :      serializer_class = TemplateSerializer permission_classes = ( permissions . IsAuthenticated , ViewObjectPermissions , ) def get_queryset ( self ) :          return Template . objects . all ( )   class VersionViewSet ( viewsets . ModelViewSet ) :      serializer_class = VersionSerializer permission_classes = ( permissions . IsAuthenticated , ViewObjectPermissions , ) def get_queryset ( self ) :          return Version_Docker . objects . all ( )   class UserViewSet ( viewsets . ModelViewSet ) :      serializer_class = UserSerializer queryset = User . objects . all ( ) def get_queryset ( self ) :          user = get_object_or_404 ( User , id = self . request . user . id ) wanted = [ group . name for group in user . groups . exclude ( name = <str> ) ] queryset = User . objects . filter ( groups__name__in = wanted ) return queryset  @ action ( detail = False ) def me ( self , request ) :          me = User . objects . filter ( pk = request . user . pk ) serializer = self . get_serializer ( me , many = True ) return Response ( serializer . data )   class GroupViewSet ( viewsets . ModelViewSet ) :      serializer_class = GroupSerializer queryset = Group . objects . none ( ) def get_queryset ( self ) :          user = get_object_or_404 ( User , id = self . request . user . id ) wanted = [ group . id for group in user . groups . all ( ) ] return Group . objects . filter ( pk__in = wanted )   class GroupUsageSummaryViewSet ( viewsets . ModelViewSet ) :      serializer_class = GroupSerializer queryset = Group . objects . none ( )  class UserUsageSummaryViewSet ( viewsets . ModelViewSet ) :      serializer_class = UserSerializer queryset = User . objects . none ( )   