from __future__ import absolute_import import copy import hashlib import json import logging import math import os import shutil import uuid import yaml from os . path import join from celery . result import AsyncResult from django . conf import settings from django . contrib . auth . models import Group from django . contrib . auth . models import User from django . core . files . base import ContentFile from django . db import models from django . utils . text import slugify from django . utils . timezone import now from model_utils import Choices from guardian . shortcuts import assign_perm from guardian . shortcuts import get_groups_with_perms from guardian . shortcuts import get_objects_for_user from guardian . shortcuts import remove_perm from django . contrib . postgres . fields import JSONField from delft3dworker . utils import log_progress_parser , tz_now , scan_output_files from delft3dworker . utils import merge_log_unique , merge_list_of_dict , derive_defaults_from_argo from delft3dcontainermanager . tasks import get_argo_workflows , do_argo_create , do_argo_stop from delft3dcontainermanager . tasks import do_argo_remove , get_kube_log def default_svn_version ( ) :      pass  class JSONFieldTransition ( JSONField ) :      def from_db_value ( self , value , expression , connection , context ) :              if isinstance ( value , str ) :                  return json . loads ( value )  return value   class Version_Docker ( models . Model ) :      release = models . CharField ( max_length = 256 , db_index = True ) revision = models . AutoField ( primary_key = True ) versions = JSONFieldTransition ( default = dict ) changelog = models . CharField ( max_length = 256 ) reviewed = models . BooleanField ( default = False ) template = models . ForeignKey ( <str> , related_name = <str> , on_delete = models . CASCADE ) class Meta :          ordering = [ <str> ] verbose_name = <str> verbose_name_plural = <str>  def __str__ ( self ) :          return <str> . format ( self . release , self . revision )   def parse_argo_workflow ( instance , filename ) :      template = yaml . load ( instance . yaml_template . read ( ) , Loader = yaml . FullLoader ) defaults = derive_defaults_from_argo ( template ) version = Version_Docker ( release = <str> . format ( filename ) , versions = defaults , changelog = <str> , template = instance ) version . save ( ) return join ( <str> , filename )  class Scenario ( models . Model ) :      name = models . CharField ( max_length = 256 ) template = models . ForeignKey ( <str> , blank = True , null = True , on_delete = models . CASCADE ) scenes_parameters = JSONFieldTransition ( blank = True , default = dict ) parameters = JSONFieldTransition ( blank = True , default = dict ) owner = models . ForeignKey ( User , null = True , on_delete = models . CASCADE ) state = models . CharField ( max_length = 64 , default = <str> ) progress = models . IntegerField ( default = 0 ) def load_settings ( self , settings ) :          self . parameters = settings self . scenes_parameters = [ { } ] for key , value in self . parameters . items ( ) :              self . _parse_setting ( key , value )  self . save ( )  def createscenes ( self , user ) :          for i , sceneparameters in enumerate ( self . scenes_parameters ) :              m = hashlib . sha256 ( ) m . update ( str ( sceneparameters ) . encode ( <str> ) ) phash = m . hexdigest ( ) scenes = Scene . objects . filter ( parameters_hash = phash ) clones = get_objects_for_user ( user , <str> , scenes , accept_global_perms = False ) if len ( clones ) > 0 :                  scene = clones [ 0 ] scene . scenario . add ( self )  else :                  scene = Scene ( name = <str> . format ( self . name , i + 1 ) , owner = self . owner , parameters = sceneparameters , shared = <str> , parameters_hash = phash , info = self . template . info ) scene . save ( ) scene . scenario . add ( self ) assign_perm ( <str> , self . owner , scene ) assign_perm ( <str> , self . owner , scene ) assign_perm ( <str> , self . owner , scene ) assign_perm ( <str> , self . owner , scene )   self . save ( )  def start ( self , user ) :          for scene in self . scene_set . all ( ) :              if user . has_perm ( <str> , scene ) :                  scene . start ( )   return <str>  def abort ( self , user ) :          for scene in self . scene_set . all ( ) :              if user . has_perm ( <str> , scene ) :                  scene . abort ( )   self . state = <str> return self . state  def delete ( self , user , * args , ** kwargs ) :          for scene in self . scene_set . all ( ) :              if len ( scene . scenario . all ( ) ) == 1 and user . has_perm ( <str> , scene ) :                  scene . delete ( )   super ( Scenario , self ) . delete ( * args , ** kwargs )  def publish_company ( self , user ) :          for scene in self . scene_set . all ( ) :              if user . has_perm ( <str> , scene ) :                  scene . publish_company ( user )    def publish_world ( self , user ) :          for scene in self . scene_set . all ( ) :              if user . has_perm ( <str> , scene ) :                  scene . publish_world ( user )    def _update_state_and_save ( self ) :          count = self . scene_set . all ( ) . count ( ) self . state = <str> if count > 0 :              progress = 0 for scene in self . scene_set . all ( ) :                  progress = progress + scene . progress if scene . phase != 6 :                      self . state = <str>   self . progress = progress / count self . save ( update_fields = [ <str> , <str> ] )  return self . state  def _parse_setting ( self , key , setting ) :          if not ( <str> in setting ) :              return  values = setting [ <str> ] if key == <str> :              self . name = values return  if isinstance ( values , list ) :              logging . info ( <str> . format ( key ) ) self . scenes_parameters = [ copy . copy ( p ) for p in self . scenes_parameters for _ in range ( len ( values ) ) ] i = 0 for scene in self . scenes_parameters :                  s = dict ( setting ) s [ <str> ] = values [ i % len ( values ) ] s . pop ( <str> ) scene [ key ] = s i += 1   else :              for scene in self . scenes_parameters :                  if key not in scene :                      scene [ key ] = setting     def __str__ ( self ) :          return self . name   class Scene ( models . Model ) :      name = models . CharField ( max_length = 256 ) suid = models . UUIDField ( default = uuid . uuid4 , editable = False ) scenario = models . ManyToManyField ( Scenario , blank = True ) date_created = models . DateTimeField ( default = tz_now , blank = True ) date_started = models . DateTimeField ( blank = True , null = True ) fileurl = models . CharField ( max_length = 256 ) info = JSONFieldTransition ( blank = True , default = dict ) parameters = JSONFieldTransition ( blank = True , default = dict ) state = models . CharField ( max_length = 256 , default = <str> ) progress = models . IntegerField ( default = 0 ) task_id = models . CharField ( max_length = 256 , blank = True ) workingdir = models . CharField ( max_length = 256 ) parameters_hash = models . CharField ( max_length = 64 , blank = True ) shared_choices = [ ( <str> , <str> ) , ( <str> , <str> ) , ( <str> , <str> ) ] shared = models . CharField ( max_length = 1 , choices = shared_choices ) owner = models . ForeignKey ( User , null = True , on_delete = models . CASCADE ) phases = Choices ( ( 0 , <str> , <str> ) , ( 6 , <str> , <str> ) , ( 11 , <str> , <str> ) , ( 12 , <str> , <str> ) , ( 13 , <str> , <str> ) , ( 20 , <str> , <str> ) , ( 21 , <str> , <str> ) , ( 500 , <str> , <str> ) , ( 501 , <str> , <str> ) , ( 502 , <str> , <str> ) ) REMOVE_WORKFLOW = [ phases . sim_fin , phases . stop_fin ] phase = models . PositiveSmallIntegerField ( default = phases . new , choices = phases ) def reset ( self ) :          if self . phase >= self . phases . fin :              self . shift_to_phase ( self . phases . sim_start ) self . date_started = tz_now ( ) self . progress = 0 self . info = self . scenario . first ( ) . template . info self . save ( update_fields = [ <str> , <str> , <str> ] )   def start ( self ) :          if self . phase == self . phases . idle :              self . shift_to_phase ( self . phases . sim_start ) self . date_started = tz_now ( ) self . save ( update_fields = [ <str> ] )   def redo ( self , entrypoint ) :          if entrypoint == <str> or entrypoint not in self . workflow . outdated_entrypoints ( ) :              logging . warning ( <str> ) return False  elif self . phase >= self . phases . fin and self . workflow . is_outdated :              self . workflow . entrypoint = entrypoint self . workflow . version = self . workflow . latest_version ( ) self . workflow . save ( ) self . date_started = tz_now ( ) self . shift_to_phase ( self . phases . sim_start ) self . progress = 0 self . info = self . scenario . first ( ) . template . info self . save ( ) return True  else :              return False   def abort ( self ) :          if self . phase >= self . phases . sim_start and self . phase <= self . phases . sim_fin :              self . shift_to_phase ( self . phases . stopping ) return True  else :              return False   def export ( self , zipfile , options ) :          available_options = self . scenario . first ( ) . template . export_options export_options = [ v for ( k , v ) in available_options . items ( ) if k in options ] files_added = False for root , dirs , files in os . walk ( self . workingdir ) :              for f in files :                  name , ext = os . path . splitext ( f ) for option in export_options :                      if root . endswith ( option . get ( <str> , <str> ) ) and ext in option . get ( <str> , [ ] ) :                          files_added = True abs_path = os . path . join ( root , f ) rel_path = os . path . join ( slugify ( self . name ) , os . path . relpath ( abs_path , self . workingdir ) ) zipfile . write ( abs_path , rel_path )     return files_added  def save ( self , * args , ** kwargs ) :          if self . pk is None :              self . workingdir = os . path . join ( settings . WORKER_FILEDIR , str ( self . suid ) , <str> ) self . fileurl = os . path . join ( settings . WORKER_FILEURL , str ( self . suid ) , <str> )  super ( Scene , self ) . save ( * args , ** kwargs )  def delete ( self , deletefiles = True , * args , ** kwargs ) :          self . abort ( ) if deletefiles :              self . _delete_datafolder ( )  super ( Scene , self ) . delete ( * args , ** kwargs )  def publish_company ( self , user ) :          if self . shared != <str> :              return  if self . phase != self . phases . fin :              return  remove_perm ( <str> , user , self ) remove_perm ( <str> , user , self ) groups = [ group for group in user . groups . all ( ) if ( <str> in group . name and <str> not in group . name ) ] for group in groups :              assign_perm ( <str> , group , self )  self . shared = <str> self . save ( update_fields = [ <str> ] )  def publish_world ( self , user ) :          if self . phase != self . phases . fin :              return  remove_perm ( <str> , user , self ) remove_perm ( <str> , user , self ) remove_perm ( <str> , user , self ) for group in get_groups_with_perms ( self ) :              remove_perm ( <str> , group , self )  world = Group . objects . get ( name = <str> ) assign_perm ( <str> , world , self ) self . shared = <str> self . save ( update_fields = [ <str> ] )  def update_and_phase_shift ( self ) :          if self . phase == self . phases . new :              if not hasattr ( self , <str> ) :                  workflow = Workflow . objects . create ( scene = self , name = <str> . format ( self . scenario . first ( ) . template . shortname , self . suid ) , version = self . scenario . first ( ) . template . versions . first ( ) ) workflow . save ( )  self . shift_to_phase ( self . phases . idle ) return  elif self . phase == self . phases . sim_start :              self . workflow . set_desired_state ( <str> ) if ( self . workflow . cluster_state == <str> ) :                  self . shift_to_phase ( self . phases . sim_run )  elif ( self . workflow . cluster_state in Workflow . FINISHED ) :                  self . shift_to_phase ( self . phases . sim_fin )  return  elif self . phase == self . phases . sim_run :              self . _local_scan_files ( ) self . progress = self . workflow . progress self . save ( update_fields = [ <str> ] ) if ( self . workflow . cluster_state in Workflow . FINISHED ) :                  self . shift_to_phase ( self . phases . sim_fin )  elif ( self . workflow . cluster_state == <str> ) :                  logging . error ( <str> ) self . shift_to_phase ( self . phases . sim_start )  return  elif self . phase == self . phases . stopping :              self . workflow . set_desired_state ( <str> ) if self . workflow . cluster_state == <str> :                  self . shift_to_phase ( self . phases . stop_fin )  return  elif self . phase in self . REMOVE_WORKFLOW :              self . workflow . set_desired_state ( <str> ) if ( self . workflow . cluster_state != <str> ) :                  self . progress = self . workflow . progress self . save ( update_fields = [ <str> ] )  else :                  if self . phase == self . phases . sim_fin :                      self . shift_to_phase ( self . phases . fin )  elif self . phase == self . phases . stop_fin :                      self . shift_to_phase ( self . phases . stopped )   return  else :              return   def shift_to_phase ( self , new_phase ) :          self . phase = new_phase self . save ( update_fields = [ <str> ] )  def _delete_datafolder ( self ) :          if os . path . exists ( self . workingdir ) :              try :                  shutil . rmtree ( self . workingdir )  except :                  logging . error ( <str> )    def _update_state_and_save ( self ) :          return self . state  def _local_scan_files ( self ) :          self . info = scan_output_files ( self . workingdir , self . info ) self . save ( update_fields = [ <str> ] )  def __str__ ( self ) :          return self . name   class SearchForm ( models . Model ) :      name = models . CharField ( max_length = 256 ) templates = JSONFieldTransition ( default = list ) sections = JSONFieldTransition ( default = list ) def update ( self ) :          self . templates = [ ] self . sections = [ ] for template in Template . objects . all ( ) :              self . _update_templates ( template . name , template . id , template . info ) self . _update_sections ( template . sections )  return  def _update_templates ( self , tmpl_name , tmpl_id , tmpl_info ) :          self . templates . append ( { <str> : tmpl_name , <str> : tmpl_id , <str> : tmpl_info , } )  def _update_sections ( self , tmpl_sections ) :          for tmpl_section in tmpl_sections :              matching_sections = [ section for section in self . sections if ( section [ <str> ] == tmpl_section [ <str> ] ) ] if not matching_sections :                  for variable in tmpl_section [ <str> ] :                      try :                          del variable [ <str> ]  except KeyError :                          pass  try :                          del variable [ <str> ] [ <str> ]  except KeyError :                          pass   self . sections . append ( tmpl_section )  else :                  srch_section = matching_sections [ 0 ] for tmpl_variable in tmpl_section [ <str> ] :                      matching_variables = [ variable for variable in srch_section [ <str> ] if ( variable [ <str> ] == tmpl_variable [ <str> ] ) ] if not matching_variables :                          try :                              del tmpl_variable [ <str> ]  except KeyError :                              pass  try :                              del tmpl_variable [ <str> ] [ <str> ]  except KeyError :                              pass  srch_section [ <str> ] . append ( tmpl_variable )  else :                          srch_variable = matching_variables [ 0 ] if ( srch_variable [ <str> ] == <str> and tmpl_variable [ <str> ] == <str> ) :                              tmpl_validators = tmpl_variable [ <str> ] srch_validators = srch_variable [ <str> ] if ( float ( tmpl_validators [ <str> ] ) < float ( srch_validators [ <str> ] ) ) :                                  srch_validators [ <str> ] = tmpl_validators [ <str> ]  if ( float ( tmpl_validators [ <str> ] ) > float ( srch_validators [ <str> ] ) ) :                                  srch_validators [ <str> ] = tmpl_validators [ <str> ]       self . save ( ) return  def __str__ ( self ) :          return self . name   class Template ( models . Model ) :      name = models . CharField ( max_length = 256 ) shortname = models . CharField ( max_length = 256 , default = dict ) meta = JSONFieldTransition ( blank = True , default = dict ) info = JSONFieldTransition ( blank = True , default = dict ) sections = JSONFieldTransition ( blank = True , default = dict ) visualisation = JSONFieldTransition ( blank = True , default = dict ) export_options = JSONFieldTransition ( blank = True , default = dict ) yaml_template = models . FileField ( upload_to = parse_argo_workflow , default = <str> ) def __str__ ( self ) :          return self . name  def save ( self , * args , ** kwargs ) :          if self . pk is None :              self . shortname = self . name . replace ( <str> , <str> ) . lower ( )  super ( Template , self ) . save ( * args , ** kwargs )   class Workflow ( models . Model ) :      name = models . CharField ( max_length = 256 , unique = True ) scene = models . OneToOneField ( Scene , on_delete = models . CASCADE ) version = models . ForeignKey ( Version_Docker , null = True , on_delete = models . CASCADE ) entrypoint = models . CharField ( max_length = 64 , null = True ) starttime = models . DateTimeField ( default = tz_now , blank = True ) stoptime = models . DateTimeField ( null = True , blank = True ) yaml = models . FileField ( upload_to = <str> , default = <str> ) task_uuid = models . UUIDField ( default = None , blank = True , null = True ) task_starttime = models . DateTimeField ( default = tz_now , blank = True ) WORKFLOW_STATE_CHOICES = ( ( <str> , <str> ) , ( <str> , <str> ) , ( <str> , <str> ) , ( <str> , <str> ) , ( <str> , <str> ) , ( <str> , <str> ) , ( <str> , <str> ) , ( <str> , <str> ) , ( <str> , <str> ) , ) FINISHED = [ <str> , <str> , <str> , <str> ] desired_state = models . CharField ( max_length = 16 , choices = WORKFLOW_STATE_CHOICES , default = <str> ) cluster_state = models . CharField ( max_length = 16 , choices = WORKFLOW_STATE_CHOICES , default = <str> ) progress = models . PositiveSmallIntegerField ( default = 0 ) cluster_log = models . TextField ( blank = True , default = <str> ) action_log = models . TextField ( blank = True , default = <str> ) def is_outdated ( self ) :          latest = self . latest_version ( ) if latest is not None and self . version is not None :              return latest . revision > self . version . revision  else :              return False   def latest_version ( self ) :          try :              return self . scene . scenario . first ( ) . template . versions . first ( )  except AttributeError :              return None   def outdated_changelog ( self ) :          if self . is_outdated ( ) :              return self . latest_version ( ) . changelog  else :              return <str>   def outdated_entrypoints ( self ) :          if self . is_outdated ( ) :              entrypoints = self . latest_version ( ) . versions . get ( <str> , [ ] ) return entrypoints  else :              return [ ]   def update_task_result ( self ) :          if self . task_uuid is None :              return  result = AsyncResult ( id = str ( self . task_uuid ) ) time_passed = now ( ) - self . task_starttime if result . ready ( ) :              if result . successful ( ) :                  if <str> in result . result :                      log = result . result [ <str> ] self . cluster_log = merge_log_unique ( self . cluster_log , log ) progress = log_progress_parser ( log , <str> ) if progress is not None :                          self . progress = math . ceil ( progress )   else :                      _ = result . result   else :                  error = result . result logging . warn ( <str> . format ( self , result . state , error ) )  self . task_uuid = None self . save ( update_fields = [ <str> , <str> , <str> ] )  elif time_passed . total_seconds ( ) > settings . TASK_EXPIRE_TIME :              logging . warn ( <str> . format ( time_passed . total_seconds ( ) ) ) result . revoke ( ) self . task_uuid = None self . save ( update_fields = [ <str> ] )  else :              logging . warn ( <str> . format ( self , result . state ) )   def sync_cluster_state ( self , latest_cluster_state ) :          if latest_cluster_state is None :              self . cluster_state = <str>  else :              state = latest_cluster_state [ <str> ] [ <str> ] [ <str> ] if state == <str> or state == <str> :                  logging . error ( <str> . format ( self . name ) )  self . cluster_state = state . lower ( )  self . save ( update_fields = [ <str> ] )  def fix_mismatch_or_log ( self ) :          self . fix_mismatch ( ) self . update_log ( )  def fix_mismatch ( self ) :          if self . task_uuid is not None :              return  if self . desired_state == self . cluster_state :              return  if self . desired_state == <str> :              self . create_workflow ( )  if self . desired_state == <str> :              self . stop_workflow ( )  if self . desired_state == <str> :              self . remove_workflow ( )   def set_desired_state ( self , desired_state ) :          self . desired_state = desired_state self . save ( update_fields = [ <str> ] )  def create_workflow ( self ) :          if self . cluster_state != <str> :              logging . warning ( <str> ) return  template_model = self . scene . scenario . first ( ) . template with open ( template_model . yaml_template . path ) as f :              template = yaml . load ( f , Loader = yaml . FullLoader )  template [ <str> ] = { <str> : <str> . format ( self . name ) } if self . entrypoint is not None :              template [ <str> ] [ <str> ] = self . entrypoint  v = self . version . versions [ <str> ] c = [ { <str> : <str> , <str> : str ( self . scene . suid ) } , { <str> : <str> , <str> : settings . BUCKETNAME } , { <str> : <str> , <str> : str ( self . version . revision ) } , { <str> : <str> , <str> : json . dumps ( self . scene . parameters ) } ] parameters = merge_list_of_dict ( c , v ) template [ <str> ] [ <str> ] [ <str> ] = parameters yaml_template = yaml . safe_dump ( template , encoding = <str> , allow_unicode = True ) self . yaml . save ( <str> . format ( self . name ) , ContentFile ( yaml_template ) , save = False ) result = do_argo_create . apply_async ( args = ( template , ) , expires = settings . TASK_EXPIRE_TIME ) self . task_starttime = now ( ) self . starttime = now ( ) self . action_log += <str> . format ( self . task_starttime ) self . task_uuid = result . id self . save ( update_fields = [ <str> , <str> , <str> , <str> , <str> ] )  def stop_workflow ( self ) :          result = do_argo_stop . apply_async ( args = ( self . name , ) , expires = settings . TASK_EXPIRE_TIME ) self . stoptime = now ( ) self . action_log += <str> . format ( self . stoptime ) self . save ( update_fields = [ <str> , <str> ] )  def remove_workflow ( self ) :          if self . cluster_state == <str> :              logging . warning ( <str> ) return  result = do_argo_remove . apply_async ( args = ( self . name , ) , expires = settings . TASK_EXPIRE_TIME ) self . task_starttime = now ( ) self . stoptime = now ( ) self . action_log += <str> . format ( self . stoptime ) self . task_uuid = result . id self . save ( update_fields = [ <str> , <str> , <str> , <str> ] )  def update_log ( self ) :          if self . task_uuid is not None :              return  if self . cluster_state != <str> :              return  result = get_kube_log . apply_async ( args = ( self . name , ) , expires = settings . TASK_EXPIRE_TIME ) self . task_starttime = now ( ) self . task_uuid = result . id self . save ( update_fields = [ <str> , <str> ] )  def __str__ ( self ) :          return <str> . format ( self . scene . name )   class GroupUsageSummary ( Group ) :      class Meta :          proxy = True verbose_name = <str> verbose_name_plural = <str>   class UserUsageSummary ( User ) :      class Meta :          proxy = True verbose_name = <str> verbose_name_plural = <str>    