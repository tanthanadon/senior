from celery . result import AsyncResult import logging from django . core . management import BaseCommand from json import loads from time import sleep from delft3dcontainermanager . tasks import get_argo_workflows from delft3dcontainermanager . tasks import do_argo_remove from delft3dworker . models import Workflow from delft3dworker . models import Scene from delft3dworker . models import Template class Command ( BaseCommand ) :      help = <str> def handle ( self , * args , ** options ) :          self . _update_workflow_tasks ( ) if self . _get_latest_workflows_status ( ) :              self . _update_scene_phases ( ) self . _fix_workflow_state_mismatch ( )   def _update_workflow_tasks ( self ) :          workflows_with_running_tasks = set ( Workflow . objects . exclude ( task_uuid__exact = None ) ) for workflow in workflows_with_running_tasks :              workflow . update_task_result ( )   def _get_latest_workflows_status ( self ) :          ps = get_argo_workflows . apply_async ( queue = <str> ) shortnames = tuple ( Template . objects . values_list ( <str> , flat = True ) ) checked = 0 while not ps . successful ( ) :              sleep ( 1 ) checked += 1 if checked >= 30 :                  ps . revoke ( ) return False   cluster_workflows_json = ps . result [ <str> ] cluster_workflows = loads ( cluster_workflows_json ) cluster_dict = { wf [ <str> ] [ <str> ] : wf for wf in cluster_workflows [ <str> ] } cluster_set = set ( cluster_dict . keys ( ) ) database_set = set ( Workflow . objects . all ( ) . values_list ( <str> , flat = True ) ) m_1_1 = database_set & cluster_set m_1_0 = database_set - cluster_set m_0_1 = cluster_set - database_set m_0_0 = ( ( cluster_set | database_set ) - ( cluster_set ^ database_set ) - ( cluster_set & database_set ) ) workflow_match = m_1_1 | m_1_0 for wf_name in workflow_match :              snapshot = cluster_dict [ wf_name ] if wf_name in cluster_dict else None for wf in Workflow . objects . filter ( name = wf_name ) :                  wf . sync_cluster_state ( snapshot )   workflow_mismatch = m_0_1 | m_0_0 for wf in workflow_mismatch :              if wf . startswith ( shortnames ) :                  msg = <str> . format ( wf ) self . stderr . write ( msg ) do_argo_remove . delay ( wf )   return True  def _update_scene_phases ( self ) :          for scene in Scene . objects . all ( ) . order_by ( <str> , <str> ) :              scene . update_and_phase_shift ( )   def _fix_workflow_state_mismatch ( self ) :          for workflow in Workflow . objects . all ( ) :              workflow . fix_mismatch_or_log ( )     