from celery . result import AsyncResult import logging from django . core . management import BaseCommand from time import sleep from delft3dcontainermanager . tasks import get_docker_ps from delft3dcontainermanager . tasks import do_docker_remove from delft3dworker . models import Container from delft3dworker . models import Scene class Command ( BaseCommand ) :      help = <str> def handle ( self , * args , ** options ) :          self . _update_container_tasks ( ) if self . _get_latest_docker_status ( ) :              self . _update_scene_phases ( ) self . _fix_container_state_mismatches_or_log ( )   def _update_container_tasks ( self ) :          celery_set = set ( Container . objects . exclude ( task_uuid__exact = None ) ) for container in celery_set :              container . update_task_result ( )   def _get_latest_docker_status ( self ) :          ps = get_docker_ps . apply_async ( queue = <str> ) checked = 0 while not ps . successful ( ) :              sleep ( 1 ) checked += 1 if checked >= 30 :                  ps . revoke ( ) return False   containers_docker = ps . result docker_dict = { x [ <str> ] : x for x in containers_docker } docker_set = set ( docker_dict . keys ( ) ) container_set = set ( Container . objects . exclude ( docker_id__exact = <str> ) . values_list ( <str> , flat = True ) ) m_1_1 = container_set & docker_set m_1_0 = container_set - docker_set m_0_1 = docker_set - container_set m_0_0 = ( ( docker_set | container_set ) - ( docker_set ^ container_set ) - ( docker_set & container_set ) ) container_match = m_1_1 | m_1_0 for con_id in container_match :              snapshot = docker_dict [ con_id ] if con_id in docker_dict else None for c in Container . objects . filter ( docker_id = con_id ) :                  c . update_from_docker_snapshot ( snapshot )   container_mismatch = m_0_1 | m_0_0 for container in container_mismatch :              info = docker_dict [ container ] if ( <str> in info and <str> in info [ <str> ] and <str> in info [ <str> ] [ <str> ] ) :                  type = info [ <str> ] [ <str> ] [ <str> ] choices = Container . CONTAINER_TYPE_CHOICES if type in [ choice [ 0 ] for choice in choices ] :                      msg = <str> . format ( container ) self . stderr . write ( msg ) do_docker_remove . delay ( container , force = True )   else :                  logging . info ( <str> )   return True  def _update_scene_phases ( self ) :          for scene in Scene . objects . all ( ) . order_by ( <str> , <str> ) :              scene . update_and_phase_shift ( )   def _fix_container_state_mismatches_or_log ( self ) :          for container in Container . objects . all ( ) :              container . fix_mismatch_or_log ( )     