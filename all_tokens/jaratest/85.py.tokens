import sys import xml . etree . ElementTree as etree import re import numpy as np import matplotlib . pyplot as plt import matplotlib . image as mpimg SVG_TEMPLATE = def get_svg_transform ( filename , imageSize = [ 1388 , 1040 ] ) :      tree = etree . parse ( filename ) root = tree . getroot ( ) images = root . findall ( <str> ) if len ( images ) != 2 :          raise ValueError ( <str> )  if ( images [ 0 ] . attrib [ <str> ] != <str> ) or ( images [ 0 ] . attrib [ <str> ] != <str> ) :          raise ValueError ( <str> )  if images [ 1 ] . attrib . has_key ( <str> ) :          transformString = images [ 1 ] . attrib [ <str> ] if transformString . startswith ( <str> ) :              transformValueStrings = re . findall ( <str> , transformString ) transformValues = [ float ( x ) for x in transformValueStrings ]  elif transformString . startswith ( <str> ) :              transformValueString = re . findall ( <str> , transformString ) [ 0 ] theta = - np . pi * float ( transformValueString ) / 180 transformValues = [ np . cos ( theta ) , - np . sin ( theta ) , np . sin ( theta ) , np . cos ( theta ) ]   else :          transformValues = [ 1 , 0 , 0 , 1 , 0 , 0 ]  scaleWidth = float ( images [ 1 ] . attrib [ <str> ] ) / float ( imageSize [ 0 ] ) scaleHeight = float ( images [ 1 ] . attrib [ <str> ] ) / float ( imageSize [ 1 ] ) xPos = float ( images [ 1 ] . attrib [ <str> ] ) yPos = float ( images [ 1 ] . attrib [ <str> ] ) scale = np . array ( [ [ scaleWidth ] , [ scaleHeight ] ] ) translate = np . array ( [ [ xPos ] , [ yPos ] ] ) affine = np . reshape ( transformValues [ : 4 ] , ( 2 , 2 ) , order = <str> ) return ( scale , translate , affine )  def apply_svg_transform ( scale , translate , affine , coords ) :      newCoords = scale * coords + translate newCoords = np . dot ( affine , newCoords ) return newCoords  def get_cells_coords ( filename ) :      allData = np . loadtxt ( filenameCSV , delimiter = <str> , skiprows = 1 ) coords = allData [ : , 5 : ] return coords . T  def save_svg_for_registration ( filenameSVG , filenameAtlas , filenameSlice , verbose = True ) :      import PIL atlasIm = PIL . Image . open ( filenameAtlas ) ( atlasWidth , atlasHeight ) = atlasIm . size sliceIm = PIL . Image . open ( filenameSlice ) ( sliceWidth , sliceHeight ) = sliceIm . size svgString = SVG_TEMPLATE . format ( atlasImage = filenameAtlas , sliceImage = filenameSlice , atlasWidth = atlasWidth , atlasHeight = atlasHeight , sliceWidth = sliceWidth , sliceHeight = sliceHeight ) fileSVG = open ( filenameSVG , <str> ) fileSVG . write ( svgString ) fileSVG . close ( ) if verbose :          print ( <str> . format ( filenameSVG ) )  return ( atlasIm . size , sliceIm . size )  if __name__ == <str> :      CASE = 5 if CASE == 0 :          filenameSVG = <str> tt = get_transform ( filenameSVG ) print tt  elif CASE == 1 :          pass  elif CASE == 2 :          filenameCSV = <str> coords = get_cell_coords ( filenameCSV ) print coords  elif CASE == 3 :          filenameSVG = <str> ( scale , translate , affine ) = get_svg_transform ( filenameSVG ) filenameCSV = <str> coords = get_cells_coords ( filenameCSV ) newCoords = apply_svg_transform ( scale , translate , affine , coords ) print newCoords . T filenameAtlas = <str> atlasIm = mpimg . imread ( filenameAtlas ) plt . clf ( ) plt . imshow ( atlasIm , cmap = <str> ) plt . plot ( newCoords [ 0 , : ] , newCoords [ 1 , : ] , <str> , mec = <str> , mfc = <str> ) plt . axis ( <str> ) plt . show ( )  elif CASE == 4 :          atlasImage = <str> sliceImage = <str> atlasWidth = 456 atlasHeight = 320 sliceWidth = 1388 sliceHeight = 1040 svgString = SVG_TEMPLATE . format ( atlasImage = atlasImage , sliceImage = sliceImage , atlasWidth = atlasWidth , atlasHeight = atlasHeight , sliceWidth = sliceWidth , sliceHeight = sliceHeight ) print svgString  elif CASE == 5 :          atlasImage = <str> sliceImage = <str> filenameSVG = <str> ( atlasSize , sliceSize ) = save_svg_for_registration ( filenameSVG , atlasImage , sliceImage )    