from jaratoolbox import celldatabase_quality_tuning as celldatabase from jaratoolbox import loadbehavior from jaratoolbox import settings from jaratoolbox import ephyscore import os import numpy as np from jaratoolbox import behavioranalysis from jaratoolbox import loadopenephys from jaratoolbox import spikesanalysis from jaratoolbox import extraplots from jaratoolbox import spikesorting_ISI as spikesorting import matplotlib . pyplot as plt from pylab import argsort , plot , axvline , cumsum , axhline , mean , ylabel , title , xlabel import sys import importlib mouseName = str ( sys . argv [ 1 ] ) allcellsFileName = <str> + mouseName + <str> sys . path . append ( settings . ALLCELLS_PATH ) allcells = importlib . import_module ( allcellsFileName ) numRows = 14 numCols = 6 sizeClusterPlot = 1 clusNum = 12 numTetrodes = 8 sizeRasters = ( numRows - sizeClusterPlot ) / 3 sizeHists = ( numRows - sizeClusterPlot ) / 6 SAMPLING_RATE = 30000.0 reportname = <str> outputDir = <str> soundTriggerChannel = 0 binWidth = 0.010 Frequency = 1 timeRange = [ - 0.3 , 0.7 ] tuning_timeRange = [ - 0.2 , 0.5 ] minBlockSize = 20 ephysRootDir = settings . EPHYS_PATH experimenter = <str> paradigm = <str> behaviorDir = <str> if not os . path . exists ( outputDir ) :      os . makedirs ( outputDir )  numOfCells = len ( allcells . cellDB ) subject = <str> behavSession = <str> processedDir = os . path . join ( settings . EPHYS_PATH , mouseName + <str> ) modIFilename = os . path . join ( processedDir , <str> ) modIFile = open ( modIFilename , <str> ) modIDict = { } modSigDict = { } modDirectionScoreDict = { } behavName = <str> for line in modIFile :      splitLine = line . split ( <str> ) if ( splitLine [ 0 ] == <str> ) :          behavName = splitLine [ 1 ] [ : - 1 ]  elif ( splitLine [ 0 ] == <str> ) :          modIDict [ behavName ] = [ float ( x ) for x in splitLine [ 1 ] . split ( <str> ) [ 0 : - 1 ] ]  elif ( splitLine [ 0 ] == <str> ) :          modSigDict [ behavName ] = [ float ( x ) for x in splitLine [ 1 ] . split ( <str> ) [ 0 : - 1 ] ]  elif ( splitLine [ 0 ] == <str> ) :          modDirectionScoreDict [ behavName ] = [ float ( x ) for x in splitLine [ 1 ] . split ( <str> ) [ 0 : - 1 ] ]   modIFile . close ( ) bdata = None eventOnsetTimes = None spikeTimesFromEventOnset = None indexLimitsEachTrial = None spikeTimesFromMovementOnset = None indexLimitsEachMovementTrial = None titleText = <str> badSessionList = [ ] def main ( ) :      global behavSession global subject global tetrode global cluster global tuningBehavior global tuningEphys global bdata global eventOnsetTimes global spikeTimesFromEventOnset global indexLimitsEachTrial global spikeTimesFromMovementOnset global indexLimitsEachMovementTrial global titleText print <str> for cellID in range ( 0 , numOfCells ) :          oneCell = allcells . cellDB [ cellID ] try :              if ( behavSession != oneCell . behavSession ) :                  subject = oneCell . animalName behavSession = oneCell . behavSession ephysSession = oneCell . ephysSession tuningSession = oneCell . tuningSession ephysRoot = os . path . join ( ephysRootDir , subject ) tuningBehavior = oneCell . tuningBehavior tuningEphys = oneCell . tuningSession print behavSession behaviorFilename = loadbehavior . path_to_behavior_data ( subject = subject , paradigm = paradigm , sessionstr = behavSession ) bdata = loadbehavior . FlexCategBehaviorData ( behaviorFilename ) numberOfTrials = len ( bdata [ <str> ] ) ephysDir = os . path . join ( ephysRoot , ephysSession ) eventFilename = os . path . join ( ephysDir , <str> ) events = loadopenephys . Events ( eventFilename ) eventTimes = np . array ( events . timestamps ) / SAMPLING_RATE soundOnsetEvents = ( events . eventID == 1 ) & ( events . eventChannel == soundTriggerChannel ) eventOnsetTimes = eventTimes [ soundOnsetEvents ] soundOnsetTimeBehav = bdata [ <str> ] missingTrials = behavioranalysis . find_missing_trials ( eventOnsetTimes , soundOnsetTimeBehav ) bdata . remove_trials ( missingTrials ) bdata . find_trials_each_block ( ) centerOutTimes = bdata [ <str> ] soundStartTimes = bdata [ <str> ] timeDiff = centerOutTimes - soundStartTimes if ( len ( eventOnsetTimes ) < len ( timeDiff ) ) :                      timeDiff = timeDiff [ : - 1 ] eventOnsetTimesCenter = eventOnsetTimes + timeDiff  elif ( len ( eventOnsetTimes ) > len ( timeDiff ) ) :                      eventOnsetTimesCenter = eventOnsetTimes [ : - 1 ] + timeDiff  else :                      eventOnsetTimesCenter = eventOnsetTimes + timeDiff   tetrode = oneCell . tetrode cluster = oneCell . cluster spkData = ephyscore . CellData ( oneCell ) spkTimeStamps = spkData . spikes . timestamps ( spikeTimesFromEventOnset , trialIndexForEachSpike , indexLimitsEachTrial ) = spikesanalysis . eventlocked_spiketimes ( spkTimeStamps , eventOnsetTimes , timeRange ) ( spikeTimesFromMovementOnset , movementTrialIndexForEachSpike , indexLimitsEachMovementTrial ) = spikesanalysis . eventlocked_spiketimes ( spkTimeStamps , eventOnsetTimesCenter , timeRange ) plt . clf ( ) if ( len ( spkTimeStamps ) > 0 ) :                  ax1 = plt . subplot2grid ( ( numRows , numCols ) , ( ( numRows - sizeClusterPlot ) , 0 ) , colspan = ( numCols / 3 ) ) spikesorting . plot_isi_loghist ( spkData . spikes . timestamps ) ax3 = plt . subplot2grid ( ( numRows , numCols ) , ( ( numRows - sizeClusterPlot ) , ( numCols / 3 ) * 2 ) , colspan = ( numCols / 3 ) ) spikesorting . plot_events_in_time ( spkTimeStamps ) samples = spkData . spikes . samples . astype ( float ) - 2 ** 15 samples = ( 1000.0 / spkData . spikes . gain [ 0 , 0 ] ) * samples ax2 = plt . subplot2grid ( ( numRows , numCols ) , ( ( numRows - sizeClusterPlot ) , ( numCols / 3 ) ) , colspan = ( numCols / 3 ) ) spikesorting . plot_waveforms ( samples )  ax4 = plt . subplot2grid ( ( numRows , numCols ) , ( 0 , 0 ) , colspan = ( numCols / 2 ) , rowspan = 3 * sizeRasters ) raster_tuning ( ax4 ) axvline ( x = 0 , ymin = 0 , ymax = 1 , color = <str> ) plt . gca ( ) . set_xlim ( tuning_timeRange ) ax6 = plt . subplot2grid ( ( numRows , numCols ) , ( 0 , ( numCols / 2 ) ) , colspan = ( numCols / 2 ) , rowspan = sizeRasters ) plt . setp ( ax6 . get_xticklabels ( ) , visible = False ) plt . setp ( ax6 . get_yticklabels ( ) , visible = False ) raster_sound_block_switching ( ) plt . title ( <str> ) ax7 = plt . subplot2grid ( ( numRows , numCols ) , ( sizeRasters , ( numCols / 2 ) ) , colspan = ( numCols / 2 ) , rowspan = sizeHists , sharex = ax6 ) hist_sound_block_switching ( ax7 ) ax7 . yaxis . tick_right ( ) ax7 . yaxis . set_ticks_position ( <str> ) plt . setp ( ax7 . get_xticklabels ( ) , visible = False ) plt . gca ( ) . set_xlim ( timeRange ) ax10 = plt . subplot2grid ( ( numRows , numCols ) , ( ( sizeRasters + sizeHists ) , ( numCols / 2 ) ) , colspan = ( numCols / 2 ) , rowspan = sizeRasters ) plt . setp ( ax10 . get_xticklabels ( ) , visible = False ) plt . setp ( ax10 . get_yticklabels ( ) , visible = False ) raster_sound_allFreq_switching ( ) ax11 = plt . subplot2grid ( ( numRows , numCols ) , ( ( 2 * sizeRasters + sizeHists ) , ( numCols / 2 ) ) , colspan = ( numCols / 2 ) , rowspan = sizeHists , sharex = ax10 ) hist_sound_allFreq_switching ( ax11 ) ax11 . yaxis . tick_right ( ) ax11 . yaxis . set_ticks_position ( <str> ) ax11 . set_xlabel ( <str> ) plt . gca ( ) . set_xlim ( timeRange ) modulation_index_switching ( ) plt . suptitle ( titleText ) tetrodeClusterName = <str> + str ( oneCell . tetrode ) + <str> + str ( oneCell . cluster ) plt . gcf ( ) . set_size_inches ( ( 8.5 , 11 ) ) figformat = <str> filename = reportname + <str> % ( subject , behavSession , tetrodeClusterName , figformat ) fulloutputDir = outputDir + subject + <str> fullFileName = os . path . join ( fulloutputDir , filename ) directory = os . path . dirname ( fulloutputDir ) if not os . path . exists ( directory ) :                  os . makedirs ( directory )  plt . gcf ( ) . savefig ( fullFileName , format = figformat )  except :              if ( oneCell . behavSession not in badSessionList ) :                  badSessionList . append ( oneCell . behavSession )    print <str> for badSes in badSessionList :          print badSes   def raster_sound_switching ( ) :      rightward = bdata [ <str> ] == bdata . labels [ <str> ] [ <str> ] leftward = bdata [ <str> ] == bdata . labels [ <str> ] [ <str> ] invalid = bdata [ <str> ] == bdata . labels [ <str> ] [ <str> ] correct = bdata [ <str> ] == bdata . labels [ <str> ] [ <str> ] correctRightward = rightward & correct correctLeftward = leftward & correct possibleFreq = np . unique ( bdata [ <str> ] ) Freq = possibleFreq [ Frequency ] oneFreq = bdata [ <str> ] == Freq trialsToUseRight = rightward & oneFreq trialsToUseLeft = leftward & oneFreq trialsEachCond = np . c_ [ trialsToUseLeft , trialsToUseRight ] ; colorEachCond = [ <str> , <str> ] extraplots . raster_plot ( spikeTimesFromEventOnset , indexLimitsEachTrial , timeRange , trialsEachCond = trialsEachCond , colorEachCond = colorEachCond , fillWidth = None , labels = None ) plt . title ( <str> + str ( Freq ) )  def hist_sound_switching ( ) :      rightward = bdata [ <str> ] == bdata . labels [ <str> ] [ <str> ] leftward = bdata [ <str> ] == bdata . labels [ <str> ] [ <str> ] invalid = bdata [ <str> ] == bdata . labels [ <str> ] [ <str> ] correct = bdata [ <str> ] == bdata . labels [ <str> ] [ <str> ] correctRightward = rightward & correct correctLeftward = leftward & correct possibleFreq = np . unique ( bdata [ <str> ] ) Freq = possibleFreq [ Frequency ] oneFreq = bdata [ <str> ] == Freq trialsToUseRight = rightward & oneFreq trialsToUseLeft = leftward & oneFreq trialsEachCond = np . c_ [ trialsToUseLeft , trialsToUseRight ] ; colorEachCond = [ <str> , <str> ] timeVec = np . arange ( timeRange [ 0 ] , timeRange [ - 1 ] , binWidth ) spikeCountMat = spikesanalysis . spiketimes_to_spikecounts ( spikeTimesFromEventOnset , indexLimitsEachTrial , timeVec ) smoothWinSize = 3 extraplots . plot_psth ( spikeCountMat / binWidth , smoothWinSize , timeVec , trialsEachCond = trialsEachCond , colorEachCond = colorEachCond , linestyle = None , linewidth = 2 , downsamplefactor = 1 )  def raster_movement_switching ( ) :      rightward = bdata [ <str> ] == bdata . labels [ <str> ] [ <str> ] leftward = bdata [ <str> ] == bdata . labels [ <str> ] [ <str> ] invalid = bdata [ <str> ] == bdata . labels [ <str> ] [ <str> ] correct = bdata [ <str> ] == bdata . labels [ <str> ] [ <str> ] correctRightward = rightward & correct correctLeftward = leftward & correct possibleFreq = np . unique ( bdata [ <str> ] ) Freq = possibleFreq [ Frequency ] oneFreq = bdata [ <str> ] == Freq trialsToUseRight = rightward & oneFreq trialsToUseLeft = leftward & oneFreq trialsEachCond = np . c_ [ trialsToUseLeft , trialsToUseRight ] ; colorEachCond = [ <str> , <str> ] extraplots . raster_plot ( spikeTimesFromMovementOnset , indexLimitsEachMovementTrial , timeRange , trialsEachCond = trialsEachCond , colorEachCond = colorEachCond , fillWidth = None , labels = None )  def hist_movement_switching ( ) :      rightward = bdata [ <str> ] == bdata . labels [ <str> ] [ <str> ] leftward = bdata [ <str> ] == bdata . labels [ <str> ] [ <str> ] invalid = bdata [ <str> ] == bdata . labels [ <str> ] [ <str> ] correct = bdata [ <str> ] == bdata . labels [ <str> ] [ <str> ] correctRightward = rightward & correct correctLeftward = leftward & correct possibleFreq = np . unique ( bdata [ <str> ] ) Freq = possibleFreq [ Frequency ] oneFreq = bdata [ <str> ] == Freq trialsToUseRight = rightward & oneFreq trialsToUseLeft = leftward & oneFreq trialsEachCond = np . c_ [ trialsToUseLeft , trialsToUseRight ] ; colorEachCond = [ <str> , <str> ] timeVec = np . arange ( timeRange [ 0 ] , timeRange [ - 1 ] , binWidth ) spikeCountMat = spikesanalysis . spiketimes_to_spikecounts ( spikeTimesFromMovementOnset , indexLimitsEachMovementTrial , timeVec ) smoothWinSize = 3 extraplots . plot_psth ( spikeCountMat / binWidth , smoothWinSize , timeVec , trialsEachCond = trialsEachCond , colorEachCond = colorEachCond , linestyle = None , linewidth = 2 , downsamplefactor = 1 )  def raster_sound_allFreq_switching ( ) :      rightward = bdata [ <str> ] == bdata . labels [ <str> ] [ <str> ] leftward = bdata [ <str> ] == bdata . labels [ <str> ] [ <str> ] invalid = bdata [ <str> ] == bdata . labels [ <str> ] [ <str> ] correct = bdata [ <str> ] == bdata . labels [ <str> ] [ <str> ] correctRightward = rightward & correct correctLeftward = leftward & correct possibleFreq = np . unique ( bdata [ <str> ] ) Freq = possibleFreq [ Frequency ] oneFreq = bdata [ <str> ] == Freq trialsToUseRight = rightward & oneFreq trialsToUseLeft = leftward & oneFreq lowFreq = ( ( bdata [ <str> ] == possibleFreq [ 0 ] ) & correct ) highFreq = ( ( bdata [ <str> ] == possibleFreq [ 2 ] ) & correct ) trialsEachCond = np . c_ [ lowFreq , trialsToUseRight , trialsToUseLeft , highFreq ] ; colorEachCond = [ <str> , <str> , <str> , <str> ] extraplots . raster_plot ( spikeTimesFromEventOnset , indexLimitsEachTrial , timeRange , trialsEachCond = trialsEachCond , colorEachCond = colorEachCond , fillWidth = None , labels = None )  def hist_sound_allFreq_switching ( ax ) :      rightward = bdata [ <str> ] == bdata . labels [ <str> ] [ <str> ] leftward = bdata [ <str> ] == bdata . labels [ <str> ] [ <str> ] invalid = bdata [ <str> ] == bdata . labels [ <str> ] [ <str> ] correct = bdata [ <str> ] == bdata . labels [ <str> ] [ <str> ] correctRightward = rightward & correct correctLeftward = leftward & correct possibleFreq = np . unique ( bdata [ <str> ] ) Freq = possibleFreq [ Frequency ] oneFreq = bdata [ <str> ] == Freq trialsToUseRight = rightward & oneFreq trialsToUseLeft = leftward & oneFreq lowFreq = ( ( bdata [ <str> ] == possibleFreq [ 0 ] ) & correct ) highFreq = ( ( bdata [ <str> ] == possibleFreq [ 2 ] ) & correct ) trialsEachCond = np . c_ [ lowFreq , trialsToUseRight , trialsToUseLeft , highFreq ] ; colorEachCond = [ <str> , <str> , <str> , <str> ] timeVec = np . arange ( timeRange [ 0 ] , timeRange [ - 1 ] , binWidth ) spikeCountMat = spikesanalysis . spiketimes_to_spikecounts ( spikeTimesFromEventOnset , indexLimitsEachTrial , timeVec ) smoothWinSize = 3 extraplots . plot_psth ( spikeCountMat / binWidth , smoothWinSize , timeVec , trialsEachCond = trialsEachCond , colorEachCond = colorEachCond , linestyle = None , linewidth = 2 , downsamplefactor = 1 ) ax . axvspan ( 0.0 , 0.1 , color = [ 0.8 , 0.8 , 0.8 ] , alpha = 0.5 , lw = 0 )  def raster_movement_allFreq_switching ( ) :      rightward = bdata [ <str> ] == bdata . labels [ <str> ] [ <str> ] leftward = bdata [ <str> ] == bdata . labels [ <str> ] [ <str> ] invalid = bdata [ <str> ] == bdata . labels [ <str> ] [ <str> ] correct = bdata [ <str> ] == bdata . labels [ <str> ] [ <str> ] correctRightward = rightward & correct correctLeftward = leftward & correct possibleFreq = np . unique ( bdata [ <str> ] ) Freq = possibleFreq [ Frequency ] oneFreq = bdata [ <str> ] == Freq trialsToUseRight = rightward & oneFreq trialsToUseLeft = leftward & oneFreq lowFreq = ( ( bdata [ <str> ] == possibleFreq [ 0 ] ) & correct ) highFreq = ( ( bdata [ <str> ] == possibleFreq [ 2 ] ) & correct ) trialsEachCond = np . c_ [ lowFreq , trialsToUseRight , trialsToUseLeft , highFreq ] ; colorEachCond = [ <str> , <str> , <str> , <str> ] extraplots . raster_plot ( spikeTimesFromMovementOnset , indexLimitsEachMovementTrial , timeRange , trialsEachCond = trialsEachCond , colorEachCond = colorEachCond , fillWidth = None , labels = None )  def hist_movement_allFreq_switching ( ax ) :      rightward = bdata [ <str> ] == bdata . labels [ <str> ] [ <str> ] leftward = bdata [ <str> ] == bdata . labels [ <str> ] [ <str> ] invalid = bdata [ <str> ] == bdata . labels [ <str> ] [ <str> ] correct = bdata [ <str> ] == bdata . labels [ <str> ] [ <str> ] correctRightward = rightward & correct correctLeftward = leftward & correct possibleFreq = np . unique ( bdata [ <str> ] ) Freq = possibleFreq [ Frequency ] oneFreq = bdata [ <str> ] == Freq trialsToUseRight = rightward & oneFreq trialsToUseLeft = leftward & oneFreq lowFreq = ( ( bdata [ <str> ] == possibleFreq [ 0 ] ) & correct ) highFreq = ( ( bdata [ <str> ] == possibleFreq [ 2 ] ) & correct ) trialsEachCond = np . c_ [ lowFreq , trialsToUseRight , trialsToUseLeft , highFreq ] ; colorEachCond = [ <str> , <str> , <str> , <str> ] timeVec = np . arange ( timeRange [ 0 ] , timeRange [ - 1 ] , binWidth ) spikeCountMat = spikesanalysis . spiketimes_to_spikecounts ( spikeTimesFromMovementOnset , indexLimitsEachMovementTrial , timeVec ) smoothWinSize = 3 extraplots . plot_psth ( spikeCountMat / binWidth , smoothWinSize , timeVec , trialsEachCond = trialsEachCond , colorEachCond = colorEachCond , linestyle = None , linewidth = 2 , downsamplefactor = 1 ) ax . axvline ( x = 0 , ymin = 0 , ymax = 1 , color = <str> )  def raster_movement_block_switching ( ) :      correct = bdata [ <str> ] == bdata . labels [ <str> ] [ <str> ] possibleFreq = np . unique ( bdata [ <str> ] ) Freq = possibleFreq [ Frequency ] oneFreq = bdata [ <str> ] == Freq correctOneFreq = oneFreq & correct trialsEachBlock = bdata . blocks [ <str> ] correctTrialsEachBlock = trialsEachBlock & correctOneFreq [ : , np . newaxis ] correctBlockSizes = sum ( correctTrialsEachBlock ) if ( correctBlockSizes [ - 1 ] < minBlockSize ) :          blockSizes = sum ( trialsEachBlock ) numBlocks = len ( trialsEachBlock [ 0 ] ) sumBlocks = sum ( blockSizes ) newTrialsLastBlock = np . zeros ( ( blockSizes [ - 1 ] , numBlocks ) , dtype = np . bool ) correctTrialsEachBlock [ ( sumBlocks - blockSizes [ - 1 ] ) : ] = newTrialsLastBlock  trialsEachCond = correctTrialsEachBlock ; if bdata [ <str> ] [ 0 ] == bdata . labels [ <str> ] [ <str> ] :          colorEachBlock = 4 * [ <str> , <str> ]  else :          colorEachBlock = 4 * [ <str> , <str> ]  extraplots . raster_plot ( spikeTimesFromMovementOnset , indexLimitsEachMovementTrial , timeRange , trialsEachCond = trialsEachCond , colorEachCond = colorEachBlock , fillWidth = None , labels = None )  def hist_movement_block_switching ( ) :      correct = bdata [ <str> ] == bdata . labels [ <str> ] [ <str> ] possibleFreq = np . unique ( bdata [ <str> ] ) Freq = possibleFreq [ Frequency ] oneFreq = bdata [ <str> ] == Freq correctOneFreq = oneFreq & correct trialsEachBlock = bdata . blocks [ <str> ] correctTrialsEachBlock = trialsEachBlock & correctOneFreq [ : , np . newaxis ] correctBlockSizes = sum ( correctTrialsEachBlock ) if ( correctBlockSizes [ - 1 ] < minBlockSize ) :          blockSizes = sum ( trialsEachBlock ) numBlocks = len ( trialsEachBlock [ 0 ] ) sumBlocks = sum ( blockSizes ) newTrialsLastBlock = np . zeros ( ( blockSizes [ - 1 ] , numBlocks ) , dtype = np . bool ) correctTrialsEachBlock [ ( sumBlocks - blockSizes [ - 1 ] ) : ] = newTrialsLastBlock  trialsEachCond = correctTrialsEachBlock ; if bdata [ <str> ] [ 0 ] == bdata . labels [ <str> ] [ <str> ] :          colorEachBlock = 4 * [ <str> , <str> ]  else :          colorEachBlock = 4 * [ <str> , <str> ]  timeVec = np . arange ( timeRange [ 0 ] , timeRange [ - 1 ] , binWidth ) spikeCountMat = spikesanalysis . spiketimes_to_spikecounts ( spikeTimesFromMovementOnset , indexLimitsEachMovementTrial , timeVec ) smoothWinSize = 3 extraplots . plot_psth ( spikeCountMat / binWidth , smoothWinSize , timeVec , trialsEachCond = trialsEachCond , colorEachCond = colorEachBlock , linestyle = None , linewidth = 2 , downsamplefactor = 1 )  def raster_sound_block_switching ( ) :      correct = bdata [ <str> ] == bdata . labels [ <str> ] [ <str> ] possibleFreq = np . unique ( bdata [ <str> ] ) Freq = possibleFreq [ Frequency ] oneFreq = bdata [ <str> ] == Freq correctOneFreq = oneFreq & correct trialsEachBlock = bdata . blocks [ <str> ] correctTrialsEachBlock = trialsEachBlock & correctOneFreq [ : , np . newaxis ] correctBlockSizes = sum ( correctTrialsEachBlock ) if ( correctBlockSizes [ - 1 ] < minBlockSize ) :          blockSizes = sum ( trialsEachBlock ) numBlocks = len ( trialsEachBlock [ 0 ] ) sumBlocks = sum ( blockSizes ) newTrialsLastBlock = np . zeros ( ( blockSizes [ - 1 ] , numBlocks ) , dtype = np . bool ) correctTrialsEachBlock [ ( sumBlocks - blockSizes [ - 1 ] ) : ] = newTrialsLastBlock  trialsEachCond = correctTrialsEachBlock ; if bdata [ <str> ] [ 0 ] == bdata . labels [ <str> ] [ <str> ] :          colorEachBlock = 4 * [ <str> , <str> ]  else :          colorEachBlock = 4 * [ <str> , <str> ]  extraplots . raster_plot ( spikeTimesFromEventOnset , indexLimitsEachTrial , timeRange , trialsEachCond = trialsEachCond , colorEachCond = colorEachBlock , fillWidth = None , labels = None ) plt . title ( <str> )  def hist_sound_block_switching ( ax ) :      correct = bdata [ <str> ] == bdata . labels [ <str> ] [ <str> ] possibleFreq = np . unique ( bdata [ <str> ] ) Freq = possibleFreq [ Frequency ] oneFreq = bdata [ <str> ] == Freq correctOneFreq = oneFreq & correct trialsEachBlock = bdata . blocks [ <str> ] correctTrialsEachBlock = trialsEachBlock & correctOneFreq [ : , np . newaxis ] correctBlockSizes = sum ( correctTrialsEachBlock ) if ( correctBlockSizes [ - 1 ] < minBlockSize ) :          blockSizes = sum ( trialsEachBlock ) numBlocks = len ( trialsEachBlock [ 0 ] ) sumBlocks = sum ( blockSizes ) newTrialsLastBlock = np . zeros ( ( blockSizes [ - 1 ] , numBlocks ) , dtype = np . bool ) correctTrialsEachBlock [ ( sumBlocks - blockSizes [ - 1 ] ) : ] = newTrialsLastBlock  trialsEachCond = correctTrialsEachBlock ; if bdata [ <str> ] [ 0 ] == bdata . labels [ <str> ] [ <str> ] :          colorEachBlock = 4 * [ <str> , <str> ]  else :          colorEachBlock = 4 * [ <str> , <str> ]  timeVec = np . arange ( timeRange [ 0 ] , timeRange [ - 1 ] , binWidth ) spikeCountMat = spikesanalysis . spiketimes_to_spikecounts ( spikeTimesFromEventOnset , indexLimitsEachTrial , timeVec ) smoothWinSize = 3 extraplots . plot_psth ( spikeCountMat / binWidth , smoothWinSize , timeVec , trialsEachCond = trialsEachCond , colorEachCond = colorEachBlock , linestyle = None , linewidth = 2 , downsamplefactor = 1 ) ax . axvspan ( 0.0 , 0.1 , color = [ 0.8 , 0.8 , 0.8 ] , alpha = 0.5 , lw = 0 )  def modulation_index_switching ( ) :      global titleText global modIDict global modSigDict global modDirectionScoreDict clusterNumber = ( tetrode - 1 ) * clusNum + ( cluster - 1 ) titleText = <str> + str ( round ( modIDict [ behavSession ] [ clusterNumber ] , 3 ) ) + <str> + str ( round ( modSigDict [ behavSession ] [ clusterNumber ] , 3 ) ) + <str> + str ( modDirectionScoreDict [ behavSession ] [ clusterNumber ] ) + <str>  def raster_tuning ( ax ) :      fullbehaviorDir = behaviorDir + subject + <str> behavName = subject + <str> + tuningBehavior + <str> tuningBehavFileName = os . path . join ( fullbehaviorDir , behavName ) tuning_bdata = loadbehavior . BehaviorData ( tuningBehavFileName , readmode = <str> ) freqEachTrial = tuning_bdata [ <str> ] possibleFreq = np . unique ( freqEachTrial ) numberOfTrials = len ( freqEachTrial ) sortedTrials = [ ] numTrialsEachFreq = [ ] for indf , oneFreq in enumerate ( possibleFreq ) :          indsThisFreq = np . flatnonzero ( freqEachTrial == oneFreq ) sortedTrials = np . concatenate ( ( sortedTrials , indsThisFreq ) ) numTrialsEachFreq . append ( len ( indsThisFreq ) )  sortingInds = argsort ( sortedTrials ) tuning_ephysDir = os . path . join ( settings . EPHYS_PATH , subject , tuningEphys ) tuning_eventFilename = os . path . join ( tuning_ephysDir , <str> ) tuning_ev = loadopenephys . Events ( tuning_eventFilename ) tuning_eventTimes = np . array ( tuning_ev . timestamps ) / SAMPLING_RATE tuning_evID = np . array ( tuning_ev . eventID ) tuning_eventOnsetTimes = tuning_eventTimes [ tuning_evID == 1 ] while ( numberOfTrials < len ( tuning_eventOnsetTimes ) ) :          tuning_eventOnsetTimes = tuning_eventOnsetTimes [ : - 1 ]  thisCell = celldatabase . CellInfo ( animalName = subject , ephysSession = tuningEphys , tuningSession = <str> , tetrode = tetrode , cluster = cluster , quality = 1 , depth = 0 , tuningBehavior = <str> , behavSession = tuningBehavior ) tuning_spkData = ephyscore . CellData ( thisCell ) tuning_spkTimeStamps = tuning_spkData . spikes . timestamps ( tuning_spikeTimesFromEventOnset , tuning_trialIndexForEachSpike , tuning_indexLimitsEachTrial ) = spikesanalysis . eventlocked_spiketimes ( tuning_spkTimeStamps , tuning_eventOnsetTimes , tuning_timeRange ) tuning_sortedIndexForEachSpike = sortingInds [ tuning_trialIndexForEachSpike ] plot ( tuning_spikeTimesFromEventOnset , tuning_sortedIndexForEachSpike , <str> , ms = 3 ) numTrials = cumsum ( numTrialsEachFreq ) for indf , num in enumerate ( numTrials ) :          ax . axhline ( y = num , xmin = 0 , xmax = 1 , color = <str> , zorder = 0 )  tickPositions = numTrials - mean ( numTrialsEachFreq ) / 2 tickLabels = [ <str> % ( possibleFreq [ indf ] / 1000 ) for indf in range ( len ( possibleFreq ) ) ] ax . set_yticks ( tickPositions ) ax . set_yticklabels ( tickLabels ) ax . set_ylim ( [ - 1 , numberOfTrials ] ) ylabel ( <str> . format ( numTrials [ - 1 ] ) ) xlabel ( <str> )  main ( )  