import numpy as np from taskontrol . settings import rigsettings from taskontrol . core import paramgui from PySide import QtGui from taskontrol . core import arraycontainer from taskontrol . plugins import templates reload ( templates ) from taskontrol . plugins import performancedynamicsplot from taskontrol . plugins import soundclient from taskontrol . plugins import speakercalibration import time LONGTIME = 100 class Paradigm ( templates . Paradigm2AFC ) :      def __init__ ( self , parent = None , paramfile = None , paramdictname = None ) :          super ( Paradigm , self ) . __init__ ( parent ) performancedynamicsplot . set_pg_colors ( self ) self . myPerformancePlot = performancedynamicsplot . PerformanceDynamicsPlot ( nTrials = 400 , winsize = 10 ) self . params [ <str> ] = paramgui . NumericParam ( <str> , value = 0.03 , units = <str> , group = <str> ) self . params [ <str> ] = paramgui . NumericParam ( <str> , value = 0.03 , units = <str> , group = <str> ) self . params [ <str> ] = paramgui . NumericParam ( <str> , value = 0.03 , units = <str> , group = <str> ) waterDelivery = self . params . layout_group ( <str> ) self . params [ <str> ] = paramgui . MenuParam ( <str> , [ <str> , <str> , <str> , <str> , <str> ] , value = 3 , group = <str> ) self . params [ <str> ] = paramgui . MenuParam ( <str> , [ <str> , <str> ] , value = 0 , group = <str> ) choiceParams = self . params . layout_group ( <str> ) self . params [ <str> ] = paramgui . NumericParam ( <str> , value = 0.3 , units = <str> , group = <str> ) self . params [ <str> ] = paramgui . NumericParam ( <str> , value = 0.05 , units = <str> , group = <str> ) self . params [ <str> ] = paramgui . NumericParam ( <str> , value = 0.3 , units = <str> , group = <str> , enabled = False , decimals = 3 ) self . params [ <str> ] = paramgui . NumericParam ( <str> , value = 0.1 , units = <str> , group = <str> ) self . params [ <str> ] = paramgui . NumericParam ( <str> , value = 4 , units = <str> , group = <str> ) self . params [ <str> ] = paramgui . NumericParam ( <str> , value = 0 , units = <str> , group = <str> ) self . params [ <str> ] = paramgui . NumericParam ( <str> , value = 0 , units = <str> , group = <str> ) timingParams = self . params . layout_group ( <str> ) self . params [ <str> ] = paramgui . NumericParam ( <str> , value = 300 , units = <str> , group = <str> ) self . params [ <str> ] = paramgui . MenuParam ( <str> , [ <str> , <str> , <str> ] , value = 0 , group = <str> ) switchingParams = self . params . layout_group ( <str> ) self . params [ <str> ] = paramgui . MenuParam ( <str> , [ <str> , <str> ] , value = 0 , group = <str> ) psychometricParams = self . params . layout_group ( <str> ) self . params [ <str> ] = paramgui . MenuParam ( <str> , [ <str> , <str> ] , value = 0 , group = <str> ) automationParams = self . params . layout_group ( <str> ) self . params [ <str> ] = paramgui . NumericParam ( <str> , value = 16000 , units = <str> , group = <str> ) self . params [ <str> ] = paramgui . NumericParam ( <str> , value = 7000 , units = <str> , group = <str> ) self . params [ <str> ] = paramgui . NumericParam ( <str> , value = 3000 , units = <str> , group = <str> ) self . params [ <str> ] = paramgui . NumericParam ( <str> , value = 0 , units = <str> , enabled = False , group = <str> ) self . params [ <str> ] = paramgui . MenuParam ( <str> , [ <str> , <str> ] , value = 1 , group = <str> ) self . params [ <str> ] = paramgui . NumericParam ( <str> , value = 60 , units = <str> , group = <str> ) self . params [ <str> ] = paramgui . NumericParam ( <str> , value = 0.0 , units = <str> , enabled = False , group = <str> ) self . params [ <str> ] = paramgui . NumericParam ( <str> , value = 0.0 , units = <str> , enabled = False , decimals = 4 , group = <str> ) self . params [ <str> ] = paramgui . NumericParam ( <str> , value = 0.01 , units = <str> , enabled = False , group = <str> ) soundParams = self . params . layout_group ( <str> ) self . params [ <str> ] = paramgui . NumericParam ( <str> , value = 0 , units = <str> , enabled = False , group = <str> ) self . params [ <str> ] = paramgui . NumericParam ( <str> , value = 0 , units = <str> , enabled = False , group = <str> ) reportParams = self . params . layout_group ( <str> ) self . params [ <str> ] . set_value ( <str> ) self . params [ <str> ] . set_value ( <str> ) self . centralWidget = QtGui . QWidget ( ) layoutMain = QtGui . QVBoxLayout ( ) layoutTop = QtGui . QVBoxLayout ( ) layoutBottom = QtGui . QHBoxLayout ( ) layoutCol1 = QtGui . QVBoxLayout ( ) layoutCol2 = QtGui . QVBoxLayout ( ) layoutCol3 = QtGui . QVBoxLayout ( ) layoutCol4 = QtGui . QVBoxLayout ( ) layoutMain . addLayout ( layoutTop ) layoutMain . addSpacing ( 0 ) layoutMain . addLayout ( layoutBottom ) layoutTop . addWidget ( self . mySidesPlot ) layoutTop . addWidget ( self . myPerformancePlot ) layoutBottom . addLayout ( layoutCol1 ) layoutBottom . addLayout ( layoutCol2 ) layoutBottom . addLayout ( layoutCol3 ) layoutBottom . addLayout ( layoutCol4 ) layoutCol1 . addWidget ( self . saveData ) layoutCol1 . addWidget ( self . sessionInfo ) layoutCol1 . addWidget ( self . dispatcherView ) layoutCol2 . addWidget ( self . manualControl ) layoutCol2 . addStretch ( ) layoutCol2 . addWidget ( waterDelivery ) layoutCol2 . addStretch ( ) layoutCol2 . addWidget ( choiceParams ) layoutCol2 . addStretch ( ) layoutCol3 . addWidget ( timingParams ) layoutCol3 . addStretch ( ) layoutCol3 . addWidget ( switchingParams ) layoutCol3 . addStretch ( ) layoutCol3 . addWidget ( psychometricParams ) layoutCol3 . addStretch ( ) layoutCol4 . addWidget ( automationParams ) layoutCol3 . addStretch ( ) layoutCol4 . addWidget ( soundParams ) layoutCol3 . addStretch ( ) layoutCol4 . addWidget ( reportParams ) layoutCol4 . addStretch ( ) self . centralWidget . setLayout ( layoutMain ) self . setCentralWidget ( self . centralWidget ) maxNtrials = 4000 self . results = arraycontainer . Container ( ) self . results . labels [ <str> ] = { <str> : 0 , <str> : 1 } self . results [ <str> ] = np . random . randint ( 2 , size = maxNtrials ) self . results . labels [ <str> ] = { <str> : 0 , <str> : 1 , <str> : 2 } self . results [ <str> ] = np . empty ( maxNtrials , dtype = int ) self . results . labels [ <str> ] = { <str> : 1 , <str> : 0 , <str> : 2 , <str> : 3 , <str> : 4 , <str> : 5 , <str> : 6 } self . results [ <str> ] = np . empty ( maxNtrials , dtype = int ) self . results [ <str> ] = np . zeros ( maxNtrials , dtype = <str> ) self . results [ <str> ] = np . empty ( maxNtrials , dtype = float ) self . results [ <str> ] = np . empty ( maxNtrials , dtype = float ) self . results [ <str> ] = np . empty ( maxNtrials , dtype = float ) self . results [ <str> ] = np . empty ( maxNtrials , dtype = float ) import datetime if ( datetime . datetime . now ( ) . day % 2 ) :              self . params [ <str> ] . set_string ( <str> )  else :              self . params [ <str> ] . set_string ( <str> )  self . params . from_file ( paramfile , paramdictname ) print <str> print <str> time . sleep ( 0.2 ) self . soundClient = soundclient . SoundClient ( ) punishSoundAmplitude = self . params [ <str> ] . get_value ( ) sNoise = { <str> : <str> , <str> : 0.5 , <str> : punishSoundAmplitude } self . punishSoundID = 127 self . soundClient . set_sound ( self . punishSoundID , sNoise ) self . soundClient . start ( )  def prepare_target_sound ( self , targetFrequency ) :          if self . params [ <str> ] . get_string ( ) == <str> :              possibleIntensities = self . params [ <str> ] . get_value ( ) + np . array ( [ - 20 , - 15 , - 10 , - 5 , 0 ] ) targetIntensity = possibleIntensities [ np . random . randint ( len ( possibleIntensities ) ) ]  else :              targetIntensity = self . params [ <str> ] . get_value ( )  self . params [ <str> ] . set_value ( targetIntensity ) spkCal = speakercalibration . Calibration ( rigsettings . SPEAKER_CALIBRATION ) targetAmp = spkCal . find_amplitude ( targetFrequency , targetIntensity ) . mean ( ) self . params [ <str> ] . set_value ( targetAmp ) stimDur = self . params [ <str> ] . get_value ( ) s1 = { <str> : <str> , <str> : targetFrequency , <str> : stimDur , <str> : targetAmp , <str> : 12 , <str> : 1.2 } self . soundClient . set_sound ( 1 , s1 )  def prepare_next_trial ( self , nextTrial ) :          import time TicTime = time . time ( ) if nextTrial > 0 :              self . params . update_history ( ) self . calculate_results ( nextTrial - 1 ) if self . params [ <str> ] . get_string ( ) == <str> :                  if self . results [ <str> ] [ nextTrial - 1 ] == self . results . labels [ <str> ] [ <str> ] :                      self . results [ <str> ] [ nextTrial ] = self . results [ <str> ] [ nextTrial - 1 ]   trialsPerBlock = self . params [ <str> ] . get_value ( ) nValid = self . params [ <str> ] . get_value ( ) if ( nValid > 0 ) and not ( np . mod ( nValid , trialsPerBlock ) ) :                  if self . results [ <str> ] [ nextTrial - 1 ] :                      if self . params [ <str> ] . get_string ( ) == <str> :                          newBlock = <str>  elif self . params [ <str> ] . get_string ( ) == <str> :                          newBlock = <str>  else :                          newBlock = <str>  self . params [ <str> ] . set_string ( newBlock )    self . execute_automation ( ) nextCorrectChoice = self . results [ <str> ] [ nextTrial ] highFreq = self . params [ <str> ] . get_value ( ) midFreq = self . params [ <str> ] . get_value ( ) lowFreq = self . params [ <str> ] . get_value ( ) currentBlock = self . params [ <str> ] . get_string ( ) psycurveMode = self . params [ <str> ] . get_string ( ) if psycurveMode == <str> :              if currentBlock == <str> :                  freqsLH = [ lowFreq , highFreq ]  elif currentBlock == <str> :                  freqsLH = [ lowFreq , midFreq ]  elif currentBlock == <str> :                  freqsLH = [ midFreq , highFreq ]  if nextCorrectChoice == self . results . labels [ <str> ] [ <str> ] :                  targetFrequency = freqsLH [ 0 ]  elif nextCorrectChoice == self . results . labels [ <str> ] [ <str> ] :                  targetFrequency = freqsLH [ 1 ]   elif psycurveMode == <str> :              pass  self . params [ <str> ] . set_value ( targetFrequency ) self . prepare_target_sound ( targetFrequency ) self . set_state_matrix ( nextCorrectChoice ) self . dispatcherModel . ready_to_start_trial ( ) self . mySidesPlot . update ( self . results [ <str> ] , self . results [ <str> ] , nextTrial ) self . myPerformancePlot . update ( self . results [ <str> ] , self . results . labels [ <str> ] , self . results [ <str> ] , self . results . labels [ <str> ] , nextTrial )  def set_state_matrix ( self , nextCorrectChoice ) :          self . sm . reset_transitions ( ) soundID = 1 targetDuration = self . params [ <str> ] . get_value ( ) if nextCorrectChoice == self . results . labels [ <str> ] [ <str> ] :              rewardDuration = self . params [ <str> ] . get_value ( ) stimOutput = <str> fromChoiceL = <str> fromChoiceR = <str> rewardOutput = <str> correctSidePort = <str>  elif nextCorrectChoice == self . results . labels [ <str> ] [ <str> ] :              rewardDuration = self . params [ <str> ] . get_value ( ) stimOutput = <str> fromChoiceL = <str> fromChoiceR = <str> rewardOutput = <str> correctSidePort = <str>  else :              raise ValueError ( <str> )  randNum = ( 2 * np . random . random ( 1 ) [ 0 ] - 1 ) delayToTarget = self . params [ <str> ] . get_value ( ) + self . params [ <str> ] . get_value ( ) * randNum self . params [ <str> ] . set_value ( delayToTarget ) rewardAvailability = self . params [ <str> ] . get_value ( ) punishTimeError = self . params [ <str> ] . get_value ( ) punishTimeEarly = self . params [ <str> ] . get_value ( ) outcomeMode = self . params [ <str> ] . get_string ( ) if outcomeMode == <str> :              self . sm . add_state ( name = <str> , statetimer = 0 , transitions = { <str> : <str> } ) self . sm . add_state ( name = <str> , statetimer = 1 , transitions = { <str> : <str> } ) self . sm . add_state ( name = <str> , statetimer = targetDuration , transitions = { <str> : <str> } , outputsOn = [ stimOutput ] , serialOut = soundID ) self . sm . add_state ( name = <str> , statetimer = rewardDuration , transitions = { <str> : <str> } , outputsOn = [ rewardOutput ] , outputsOff = [ stimOutput ] ) self . sm . add_state ( name = <str> , statetimer = 0 , transitions = { <str> : <str> } , outputsOff = [ rewardOutput ] )  elif outcomeMode == <str> :              self . sm . add_state ( name = <str> , statetimer = 0 , transitions = { <str> : <str> } ) self . sm . add_state ( name = <str> , statetimer = LONGTIME , transitions = { <str> : <str> , correctSidePort : <str> } ) self . sm . add_state ( name = <str> , statetimer = targetDuration , transitions = { <str> : <str> } , outputsOn = [ stimOutput ] , serialOut = soundID ) self . sm . add_state ( name = <str> , statetimer = rewardDuration , transitions = { <str> : <str> } , outputsOn = [ rewardOutput ] , outputsOff = [ stimOutput ] ) self . sm . add_state ( name = <str> , statetimer = 0 , transitions = { <str> : <str> } , outputsOff = [ rewardOutput ] )  elif outcomeMode == <str> :              self . sm . add_state ( name = <str> , statetimer = 0 , transitions = { <str> : <str> } ) self . sm . add_state ( name = <str> , statetimer = LONGTIME , transitions = { <str> : <str> } ) self . sm . add_state ( name = <str> , statetimer = targetDuration , transitions = { <str> : <str> } , outputsOn = [ stimOutput ] , serialOut = soundID ) self . sm . add_state ( name = <str> , statetimer = rewardDuration , transitions = { <str> : <str> } , outputsOn = [ rewardOutput ] , outputsOff = [ stimOutput ] ) self . sm . add_state ( name = <str> , statetimer = 0 , transitions = { <str> : <str> } , outputsOff = [ rewardOutput ] )  elif outcomeMode == <str> :              self . sm . add_state ( name = <str> , statetimer = 0 , transitions = { <str> : <str> } ) self . sm . add_state ( name = <str> , statetimer = LONGTIME , transitions = { <str> : <str> } ) self . sm . add_state ( name = <str> , statetimer = delayToTarget , transitions = { <str> : <str> , <str> : <str> } ) self . sm . add_state ( name = <str> , statetimer = targetDuration , transitions = { <str> : <str> , <str> : <str> } , serialOut = soundID ) self . sm . add_state ( name = <str> , statetimer = rewardAvailability , transitions = { <str> : <str> , <str> : <str> , <str> : <str> } , outputsOff = [ stimOutput ] ) self . sm . add_state ( name = <str> , statetimer = rewardAvailability , transitions = { <str> : <str> , <str> : <str> , <str> : <str> } , outputsOff = [ stimOutput ] ) if correctSidePort == <str> :                  self . sm . add_state ( name = <str> , statetimer = 0 , transitions = { <str> : <str> } ) self . sm . add_state ( name = <str> , statetimer = 0 , transitions = { <str> : <str> } )  elif correctSidePort == <str> :                  self . sm . add_state ( name = <str> , statetimer = 0 , transitions = { <str> : <str> } ) self . sm . add_state ( name = <str> , statetimer = 0 , transitions = { <str> : <str> } )  self . sm . add_state ( name = <str> , statetimer = punishTimeEarly , transitions = { <str> : <str> } , outputsOff = [ stimOutput ] , serialOut = self . punishSoundID ) self . sm . add_state ( name = <str> , statetimer = rewardDuration , transitions = { <str> : <str> } , outputsOn = [ rewardOutput ] ) self . sm . add_state ( name = <str> , statetimer = 0 , transitions = { <str> : <str> } , outputsOff = [ rewardOutput ] ) self . sm . add_state ( name = <str> , statetimer = punishTimeError , transitions = { <str> : <str> } ) self . sm . add_state ( name = <str> , statetimer = 0 , transitions = { <str> : <str> } )  elif outcomeMode == <str> :              self . sm . add_state ( name = <str> , statetimer = 0 , transitions = { <str> : <str> } ) self . sm . add_state ( name = <str> , statetimer = LONGTIME , transitions = { <str> : <str> } ) self . sm . add_state ( name = <str> , statetimer = delayToTarget , transitions = { <str> : <str> , <str> : <str> } ) self . sm . add_state ( name = <str> , statetimer = targetDuration , transitions = { <str> : <str> , <str> : <str> } , serialOut = soundID ) self . sm . add_state ( name = <str> , statetimer = rewardAvailability , transitions = { <str> : <str> , <str> : <str> , <str> : <str> } , outputsOff = [ stimOutput ] ) if correctSidePort == <str> :                  self . sm . add_state ( name = <str> , statetimer = 0 , transitions = { <str> : <str> } ) self . sm . add_state ( name = <str> , statetimer = 0 , transitions = { <str> : <str> } )  elif correctSidePort == <str> :                  self . sm . add_state ( name = <str> , statetimer = 0 , transitions = { <str> : <str> } ) self . sm . add_state ( name = <str> , statetimer = 0 , transitions = { <str> : <str> } )  self . sm . add_state ( name = <str> , statetimer = punishTimeEarly , transitions = { <str> : <str> } , outputsOff = [ stimOutput ] , serialOut = self . punishSoundID ) self . sm . add_state ( name = <str> , statetimer = rewardDuration , transitions = { <str> : <str> } , outputsOn = [ rewardOutput ] ) self . sm . add_state ( name = <str> , statetimer = 0 , transitions = { <str> : <str> } , outputsOff = [ rewardOutput , stimOutput ] ) self . sm . add_state ( name = <str> , statetimer = punishTimeError , transitions = { <str> : <str> } ) self . sm . add_state ( name = <str> , statetimer = 0 , transitions = { <str> : <str> } )  else :              raise TypeError ( <str> . format ( outcomeMode ) )  self . dispatcherModel . set_state_matrix ( self . sm )  def calculate_results ( self , trialIndex ) :          eventsThisTrial = self . dispatcherModel . events_one_trial ( trialIndex ) startTrialStateID = self . sm . statesNameToIndex [ <str> ] startTrialInd = np . flatnonzero ( eventsThisTrial [ : , 2 ] == startTrialStateID ) [ 0 ] self . results [ <str> ] [ trialIndex ] = eventsThisTrial [ startTrialInd , 0 ] outcomeModeID = self . params . history [ <str> ] [ trialIndex ] outcomeModeString = self . params [ <str> ] . get_items ( ) [ outcomeModeID ] lastEvent = eventsThisTrial [ - 1 , : ] if lastEvent [ 1 ] == - 1 and lastEvent [ 2 ] == 0 :              self . results [ <str> ] [ trialIndex ] = self . results . labels [ <str> ] [ <str> ] self . results [ <str> ] [ trialIndex ] = self . results . labels [ <str> ] [ <str> ]  else :              if outcomeModeString in [ <str> , <str> , <str> ] :                  self . results [ <str> ] [ trialIndex ] = self . results . labels [ <str> ] [ <str> ] self . results [ <str> ] [ trialIndex ] = self . results . labels [ <str> ] [ <str> ] self . params [ <str> ] . add ( 1 ) self . params [ <str> ] . add ( 1 ) self . results [ <str> ] [ trialIndex ] = 1  if outcomeModeString == <str> or outcomeModeString == <str> :                  if self . sm . statesNameToIndex [ <str> ] in eventsThisTrial [ : , 2 ] :                      self . results [ <str> ] [ trialIndex ] = self . results . labels [ <str> ] [ <str> ]  elif self . sm . statesNameToIndex [ <str> ] in eventsThisTrial [ : , 2 ] :                      self . results [ <str> ] [ trialIndex ] = self . results . labels [ <str> ] [ <str> ]  else :                      self . results [ <str> ] [ trialIndex ] = self . results . labels [ <str> ] [ <str> ] self . results [ <str> ] [ trialIndex ] = self . results . labels [ <str> ] [ <str> ]  if self . sm . statesNameToIndex [ <str> ] in eventsThisTrial [ : , 2 ] :                     self . results [ <str> ] [ trialIndex ] = self . results . labels [ <str> ] [ <str> ] self . params [ <str> ] . add ( 1 ) if outcomeModeString == <str> and self . sm . statesNameToIndex [ <str> ] in eventsThisTrial [ : , 2 ] :                         self . results [ <str> ] [ trialIndex ] = self . results . labels [ <str> ] [ <str> ]   else :                      if self . sm . statesNameToIndex [ <str> ] in eventsThisTrial [ : , 2 ] :                          self . results [ <str> ] [ trialIndex ] = self . results . labels [ <str> ] [ <str> ]  elif self . sm . statesNameToIndex [ <str> ] in eventsThisTrial [ : , 2 ] :                          self . results [ <str> ] [ trialIndex ] = self . results . labels [ <str> ] [ <str> ]   if self . sm . statesNameToIndex [ <str> ] in eventsThisTrial [ : , 2 ] :                 	 self . params [ <str> ] . add ( 1 ) self . results [ <str> ] [ trialIndex ] = 1     def execute_automation ( self ) :          automationMode = self . params [ <str> ] . get_string ( ) nValid = self . params [ <str> ] . get_value ( ) if automationMode == <str> :              if nValid > 0 and not nValid % 10 :                  self . params [ <str> ] . add ( 0.010 )     if __name__ == <str> :      ( app , paradigm ) = paramgui . create_app ( Paradigm )   