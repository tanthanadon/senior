import sys import os import pandas as pd import numpy as np from jaratoolbox import celldatabase reload ( celldatabase ) from jaratoolbox import ephyscore from jaratoolbox import spikesorting from jaratoolbox import spikesanalysis from jaratoolbox import settings reload ( settings ) from scipy import stats if len ( sys . argv ) == 2 :      subject = sys . argv [ 1 ]  else :      raise ValueError ( <str> )  inforec = os . path . join ( settings . INFOREC_PATH , <str> . format ( subject ) ) db = celldatabase . generate_cell_database ( inforec ) db = db [ ( db [ <str> ] < 0.05 ) | ( db [ <str> ] > 2 ) ] print ( <str> ) laserTestStatistic = np . empty ( len ( db ) ) laserPVal = np . empty ( len ( db ) ) baseRange = [ - 0.05 , - 0.04 ] binTime = baseRange [ 1 ] - baseRange [ 0 ] responseRange = [ 0 , 0 + binTime ] fullTimeRange = [ baseRange [ 0 ] , responseRange [ 1 ] ] for indRow , ( dbIndex , dbRow ) in enumerate ( db . iterrows ( ) ) :      cellObj = ephyscore . Cell ( dbRow ) try :          laserEphysData , noBehav = cellObj . load ( <str> )  except IndexError :          print <str> testStatistic = 0 pVal = 1  else :          laserEventOnsetTimes = laserEphysData [ <str> ] [ <str> ] laserSpikeTimestamps = laserEphysData [ <str> ] spikeTimesFromEventOnset , trialIndexForEachSpike , indexLimitsEachTrial = spikesanalysis . eventlocked_spiketimes ( laserSpikeTimestamps , laserEventOnsetTimes , fullTimeRange ) baseSpikeCountMat = spikesanalysis . spiketimes_to_spikecounts ( spikeTimesFromEventOnset , indexLimitsEachTrial , baseRange ) laserSpikeCountMat = spikesanalysis . spiketimes_to_spikecounts ( spikeTimesFromEventOnset , indexLimitsEachTrial , responseRange ) [ testStatistic , pVal ] = stats . ranksums ( laserSpikeCountMat , baseSpikeCountMat )  laserTestStatistic [ indRow ] = testStatistic laserPVal [ indRow ] = pVal  db [ <str> ] = laserPVal db [ <str> ] = laserTestStatistic print ( <str> ) laserTrainTestStatistic = np . empty ( len ( db ) ) laserTrainPVal = np . empty ( len ( db ) ) baseRange = [ - 0.05 , - 0.04 ] binTime = baseRange [ 1 ] - baseRange [ 0 ] responseRange = [ 0 , 0 + binTime ] fullTimeRange = [ baseRange [ 0 ] , responseRange [ 1 ] ] for indRow , ( dbIndex , dbRow ) in enumerate ( db . iterrows ( ) ) :      cellObj = ephyscore . Cell ( dbRow ) try :          laserTrainEphysData , noBehav = cellObj . load ( <str> )  except IndexError :          print <str> testStatistic = 0 pVal = 1  else :          laserTrainEventOnsetTimes = laserTrainEphysData [ <str> ] [ <str> ] laserTrainEventOnsetTimes = spikesanalysis . minimum_event_onset_diff ( laserTrainEventOnsetTimes , 0.5 ) laserTrainSpikeTimestamps = laserTrainEphysData [ <str> ] spikeTimesFromEventOnset , trialIndexForEachSpike , indexLimitsEachTrial = spikesanalysis . eventlocked_spiketimes ( laserTrainSpikeTimestamps , laserTrainEventOnsetTimes , fullTimeRange ) baseSpikeCountMat = spikesanalysis . spiketimes_to_spikecounts ( spikeTimesFromEventOnset , indexLimitsEachTrial , baseRange ) laserSpikeCountMat = spikesanalysis . spiketimes_to_spikecounts ( spikeTimesFromEventOnset , indexLimitsEachTrial , responseRange ) [ testStatistic , pVal ] = stats . ranksums ( laserSpikeCountMat , baseSpikeCountMat )  laserTrainTestStatistic [ indRow ] = testStatistic laserTrainPVal [ indRow ] = pVal  db [ <str> ] = laserTrainPVal db [ <str> ] = laserTrainTestStatistic dbFilenameNew = os . path . join ( settings . DATABASE_PATH , <str> . format ( subject ) ) celldatabase . save_hdf ( db , dbFilenameNew ) print ( <str> . format ( dbFilenameNew ) )  