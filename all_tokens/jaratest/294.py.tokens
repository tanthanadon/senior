from jaratoolbox import spikesanalysis import numpy as np from pylab import * import os import loadEphysData import loadBehaviorData import decision_discrimination_rasterplot as behaveData trialsToUse1 = behaveData . incorrectRightward trialsToUse2 = behaveData . correctLeftward eventID = 0 possibleFreq = behaveData . possibleFreq targetFreqs = behaveData . targetFrequencies SAMPLING_RATE = 30000.0 def allFreqData ( subject , ephysSession , behaviorSession , tetrodeID , FreqInd , binTime , startTime , endTime , startRange , endRange ) :      timeRange = [ startTime , endTime ] responseRange = [ startRange , endRange ] ephysData = loadEphysData . loadEphys ( subject , ephysSession , tetrodeID ) eventTimes = ephysData [ 0 ] multipleEventOnset = ephysData [ 1 ] eventChannel = ephysData [ 2 ] spkTimeStamps = ephysData [ 3 ] numberOfTrials = behaveData . numberOfTrials oneEvent = eventChannel == eventID eventOnset = multipleEventOnset * oneEvent while ( numberOfTrials < np . sum ( eventOnset ) ) :          eventOnset = eventOnset [ : - 1 ]  eventOnsetTimes = eventTimes [ eventOnset == 1 ] ( spikeTimesFromEventOnset , trialIndexForEachSpike , indexLimitsEachTrial ) = spikesanalysis . eventlocked_spiketimes ( spkTimeStamps , eventOnsetTimes , timeRange ) startTime = float ( timeRange [ 0 ] ) endTime = float ( timeRange [ 1 ] ) fullTime = endTime - startTime numberOfBins = int ( ( fullTime // binTime ) + 1 ) binTimeRanges = np . empty ( [ numberOfBins , 2 ] ) xCoordinatesPlot = np . empty ( numberOfBins ) for indBin in range ( 0 , numberOfBins ) :          xCoordinatesPlot [ indBin ] = startTime + indBin * binTime binTimeRanges [ indBin ] = np . array ( [ ( startTime + indBin * binTime ) , ( startTime + ( indBin + 1 ) * binTime ) ] )  spikeNumberInBinPerTrial = np . empty ( [ numberOfBins , numberOfTrials ] ) for i , binRange in enumerate ( binTimeRanges ) :          spikeNumberInBinPerTrial [ i ] = spikesanalysis . count_spikes_in_range ( spikeTimesFromEventOnset , indexLimitsEachTrial , binRange )  spikeMeanInBin1 = np . empty ( numberOfBins ) spikeMeanInBin2 = np . empty ( numberOfBins ) for indBin , spikeCounts in enumerate ( spikeNumberInBinPerTrial ) :          spikeMeanInBin1 [ indBin ] = np . mean ( np . append ( spikeCounts [ trialsToUse1 == 1 ] , 0 ) ) spikeMeanInBin2 [ indBin ] = np . mean ( np . append ( spikeCounts [ trialsToUse2 == 1 ] , 0 ) )  sortedTrials = [ ] numTrialsEachFreq = [ ] for indf , oneFreq in enumerate ( possibleFreq ) :          indsThisFreq = np . flatnonzero ( targetFreqs == oneFreq ) sortedTrials = np . concatenate ( ( sortedTrials , indsThisFreq ) ) numTrialsEachFreq . append ( len ( indsThisFreq ) )  sortingInds = argsort ( sortedTrials ) sortedIndexForEachSpike = sortingInds [ trialIndexForEachSpike ] nSpikes = spikesanalysis . count_spikes_in_range ( spikeTimesFromEventOnset , indexLimitsEachTrial , responseRange ) meanSpikesEachFrequency = np . empty ( len ( possibleFreq ) ) for indf , oneFreq in enumerate ( possibleFreq ) :          meanSpikesEachFrequency [ indf ] = np . mean ( nSpikes [ indf ] )  return [ spikeTimesFromEventOnset , sortedIndexForEachSpike , numTrialsEachFreq , possibleFreq , meanSpikesEachFrequency , xCoordinatesPlot , spikeMeanInBin1 , spikeMeanInBin2 ]  def allFreqCompareData ( subject , ephysSession , behaviorSession , tetrodeID , FreqInd , binTime , startTime , endTime , startRange , endRange ) :      timeRange = [ startTime , endTime ] responseRange = [ startRange , endRange ] ephysData = loadEphysData . loadEphys ( subject , ephysSession , tetrodeID ) eventTimes = ephysData [ 0 ] multipleEventOnset = ephysData [ 1 ] eventChannel = ephysData [ 2 ] spkTimeStamps = ephysData [ 3 ] numberOfTrials = behaveData . numberOfTrials oneEvent = eventChannel == eventID eventOnset = multipleEventOnset * oneEvent while ( numberOfTrials < np . sum ( eventOnset ) ) :          eventOnset = eventOnset [ : - 1 ]  eventOnsetTimes = eventTimes [ eventOnset == 1 ] eventOnsetTimesTrials1 = eventOnsetTimes [ trialsToUse1 == 1 ] eventOnsetTimesTrials2 = eventOnsetTimes [ trialsToUse2 == 1 ] ( spikeTimesFromEventOnset , trialIndexForEachSpike , indexLimitsEachTrial ) = spikesanalysis . eventlocked_spiketimes ( spkTimeStamps , eventOnsetTimes , timeRange ) ( spikeTimesFromEventOnsetTrials1 , trialIndexForEachSpikeTrials1 , indexLimitsEachTrialTrials1 ) = spikesanalysis . eventlocked_spiketimes ( spkTimeStamps , eventOnsetTimesTrials1 , timeRange ) ( spikeTimesFromEventOnsetTrials2 , trialIndexForEachSpikeTrials2 , indexLimitsEachTrialTrials2 ) = spikesanalysis . eventlocked_spiketimes ( spkTimeStamps , eventOnsetTimesTrials2 , timeRange ) startTime = float ( timeRange [ 0 ] ) endTime = float ( timeRange [ 1 ] ) fullTime = endTime - startTime numberOfBins = int ( ( fullTime // binTime ) + 1 ) binTimeRanges = np . empty ( [ numberOfBins , 2 ] ) xCoordinatesPlot = np . empty ( numberOfBins ) for indBin in range ( 0 , numberOfBins ) :          xCoordinatesPlot [ indBin ] = startTime + indBin * binTime binTimeRanges [ indBin ] = np . array ( [ ( startTime + indBin * binTime ) , ( startTime + ( indBin + 1 ) * binTime ) ] )  spikeNumberInBinPerTrial = np . empty ( [ numberOfBins , numberOfTrials ] ) for i , binRange in enumerate ( binTimeRanges ) :          spikeNumberInBinPerTrial [ i ] = spikesanalysis . count_spikes_in_range ( spikeTimesFromEventOnset , indexLimitsEachTrial , binRange )  spikeMeanInBin1 = np . empty ( numberOfBins ) spikeMeanInBin2 = np . empty ( numberOfBins ) for indBin , spikeCounts in enumerate ( spikeNumberInBinPerTrial ) :          spikeMeanInBin1 [ indBin ] = np . mean ( np . append ( spikeCounts [ trialsToUse1 == 1 ] , 0 ) ) spikeMeanInBin2 [ indBin ] = np . mean ( np . append ( spikeCounts [ trialsToUse2 == 1 ] , 0 ) )  targetFreqsTrials1 = targetFreqs [ trialsToUse1 == 1 ] targetFreqsTrials2 = targetFreqs [ trialsToUse2 == 1 ] sortedTrials1 = [ ] numTrialsEachFreq1 = [ ] for indf1 , oneFreq1 in enumerate ( possibleFreq ) :          indsThisFreq1 = np . flatnonzero ( targetFreqsTrials1 == oneFreq1 ) sortedTrials1 = np . concatenate ( ( sortedTrials1 , indsThisFreq1 ) ) numTrialsEachFreq1 . append ( len ( indsThisFreq1 ) )  sortingIndsTrials1 = argsort ( sortedTrials1 ) sortedIndexForEachSpikeTrials1 = sortingIndsTrials1 [ trialIndexForEachSpikeTrials1 ] sortedTrials2 = [ ] numTrialsEachFreq2 = [ ] for indf2 , oneFreq2 in enumerate ( possibleFreq ) :          indsThisFreq2 = np . flatnonzero ( targetFreqsTrials2 == oneFreq2 ) sortedTrials2 = np . concatenate ( ( sortedTrials2 , indsThisFreq2 ) ) numTrialsEachFreq2 . append ( len ( indsThisFreq2 ) )  sortingIndsTrials2 = argsort ( sortedTrials2 ) sortedIndexForEachSpikeTrials2 = sortingIndsTrials2 [ trialIndexForEachSpikeTrials2 ] numTrialsTrials1 = cumsum ( numTrialsEachFreq1 ) numTrialsTrials2 = cumsum ( numTrialsEachFreq2 ) tickPossibleFreq1 = np . empty ( 0 ) tickNumTrialsTrials1 = np . empty ( 0 ) tickNumTrialsEachFreq1 = np . empty ( 0 ) for indf in range ( len ( possibleFreq ) ) :          if ( numTrialsEachFreq1 [ indf ] != 0 ) :              tickPossibleFreq1 = np . append ( tickPossibleFreq1 , possibleFreq [ indf ] ) tickNumTrialsTrials1 = np . append ( tickNumTrialsTrials1 , numTrialsTrials1 [ indf ] ) tickNumTrialsEachFreq1 = np . append ( tickNumTrialsEachFreq1 , numTrialsEachFreq1 [ indf ] )   tickPossibleFreq2 = np . empty ( 0 ) tickNumTrialsTrials2 = np . empty ( 0 ) tickNumTrialsEachFreq2 = np . empty ( 0 ) for indf in range ( len ( possibleFreq ) ) :          if ( numTrialsEachFreq2 [ indf ] != 0 ) :              tickPossibleFreq2 = np . append ( tickPossibleFreq2 , possibleFreq [ indf ] ) tickNumTrialsTrials2 = np . append ( tickNumTrialsTrials2 , numTrialsTrials2 [ indf ] ) tickNumTrialsEachFreq2 = np . append ( tickNumTrialsEachFreq2 , numTrialsEachFreq2 [ indf ] )   return [ spikeTimesFromEventOnsetTrials1 , spikeTimesFromEventOnsetTrials2 , sortedIndexForEachSpikeTrials1 , sortedIndexForEachSpikeTrials2 , tickPossibleFreq1 , tickNumTrialsTrials1 , tickNumTrialsEachFreq1 , tickPossibleFreq2 , tickNumTrialsTrials2 , tickNumTrialsEachFreq2 , xCoordinatesPlot , spikeMeanInBin1 , spikeMeanInBin2 ]  def oneFreqCompareData ( subject , ephysSession , behaviorSession , tetrodeID , FreqInd , binTime , startTime , endTime , startRange , endRange ) :      timeRange = [ startTime , endTime ] responseRange = [ startRange , endRange ] ephysData = loadEphysData . loadEphys ( subject , ephysSession , tetrodeID ) eventTimes = ephysData [ 0 ] multipleEventOnset = ephysData [ 1 ] eventChannel = ephysData [ 2 ] spkTimeStamps = ephysData [ 3 ] numberOfTrials = behaveData . numberOfTrials oneFreqTrials = targetFreq == possibleFreq [ FreqInd ] trailsToUse1 = trialsToUse1 * oneFreqTrials trialsToUse2 = trialsToUse2 * oneFreqTrials oneEvent = eventChannel == eventID eventOnset = multipleEventOnset * oneEvent while ( numberOfTrials < np . sum ( eventOnset ) ) :          eventOnset = eventOnset [ : - 1 ]  eventOnsetTimes = eventTimes [ eventOnset == 1 ] eventOnsetTimesTrials1 = eventOnsetTimes [ trialsToUse1 == 1 ] eventOnsetTimesTrials2 = eventOnsetTimes [ trialsToUse2 == 1 ] ( spikeTimesFromEventOnset , trialIndexForEachSpike , indexLimitsEachTrial ) = spikesanalysis . eventlocked_spiketimes ( spkTimeStamps , eventOnsetTimes , timeRange ) ( spikeTimesFromEventOnsetTrials1 , trialIndexForEachSpikeTrials1 , indexLimitsEachTrialTrials1 ) = spikesanalysis . eventlocked_spiketimes ( spkTimeStamps , eventOnsetTimesTrials1 , timeRange ) ( spikeTimesFromEventOnsetTrials2 , trialIndexForEachSpikeTrials2 , indexLimitsEachTrialTrials2 ) = spikesanalysis . eventlocked_spiketimes ( spkTimeStamps , eventOnsetTimesTrials2 , timeRange ) startTime = float ( timeRange [ 0 ] ) endTime = float ( timeRange [ 1 ] ) fullTime = endTime - startTime numberOfBins = int ( ( fullTime // binTime ) + 1 ) binTimeRanges = np . empty ( [ numberOfBins , 2 ] ) xCoordinatesPlot = np . empty ( numberOfBins ) for indBin in range ( 0 , numberOfBins ) :          xCoordinatesPlot [ indBin ] = startTime + indBin * binTime binTimeRanges [ indBin ] = np . array ( [ ( startTime + indBin * binTime ) , ( startTime + ( indBin + 1 ) * binTime ) ] )  spikeNumberInBinPerTrial = np . empty ( [ numberOfBins , numberOfTrials ] ) for i , binRange in enumerate ( binTimeRanges ) :          spikeNumberInBinPerTrial [ i ] = spikesanalysis . count_spikes_in_range ( spikeTimesFromEventOnset , indexLimitsEachTrial , binRange )  trialsOfFreq = targetFreqs == possibleFreq [ Frequency ] trialToUseWithFreq1 = trialsToUse1 * trialsOfFreq trialToUseWithFreq2 = trialsToUse2 * trialsOfFreq spikeMeanInBin1 = np . empty ( numberOfBins ) spikeMeanInBin2 = np . empty ( numberOfBins ) for indBin , spikeCounts in enumerate ( spikeNumberInBinPerTrial ) :          spikeMeanInBin1 [ indBin ] = np . mean ( np . append ( spikeCounts [ trialToUseWithFreq1 == 1 ] , 0 ) ) spikeMeanInBin2 [ indBin ] = np . mean ( np . append ( spikeCounts [ trialToUseWithFreq2 == 1 ] , 0 ) )  targetFreqsTrials1 = targetFreqs [ trialsToUse1 == 1 ] targetFreqsTrials2 = targetFreqs [ trialsToUse2 == 1 ] sortedTrials1 = [ ] numTrialsEachFreq1 = [ ] for indf1 , oneFreq1 in enumerate ( possibleFreq ) :          indsThisFreq1 = np . flatnonzero ( targetFreqsTrials1 == oneFreq1 ) sortedTrials1 = np . concatenate ( ( sortedTrials1 , indsThisFreq1 ) ) numTrialsEachFreq1 . append ( len ( indsThisFreq1 ) )  sortingIndsTrials1 = argsort ( sortedTrials1 ) sortedIndexForEachSpikeTrials1 = sortingIndsTrials1 [ trialIndexForEachSpikeTrials1 ] sortedTrials2 = [ ] numTrialsEachFreq2 = [ ] for indf2 , oneFreq2 in enumerate ( possibleFreq ) :          indsThisFreq2 = np . flatnonzero ( targetFreqsTrials2 == oneFreq2 ) sortedTrials2 = np . concatenate ( ( sortedTrials2 , indsThisFreq2 ) ) numTrialsEachFreq2 . append ( len ( indsThisFreq2 ) )  sortingIndsTrials2 = argsort ( sortedTrials2 ) sortedIndexForEachSpikeTrials2 = sortingIndsTrials2 [ trialIndexForEachSpikeTrials2 ] numTrialsTrials1 = cumsum ( numTrialsEachFreq1 ) numTrialsTrials2 = cumsum ( numTrialsEachFreq2 ) tickPossibleFreq1 = np . empty ( 0 ) tickNumTrialsTrials1 = np . empty ( 0 ) tickNumTrialsEachFreq1 = np . empty ( 0 ) for indf in range ( len ( possibleFreq ) ) :          if ( numTrialsEachFreq1 [ indf ] != 0 ) :              tickPossibleFreq1 = np . append ( tickPossibleFreq1 , possibleFreq [ indf ] ) tickNumTrialsTrials1 = np . append ( tickNumTrialsTrials1 , numTrialsTrials1 [ indf ] ) tickNumTrialsEachFreq1 = np . append ( tickNumTrialsEachFreq1 , numTrialsEachFreq1 [ indf ] )   tickPossibleFreq2 = np . empty ( 0 ) tickNumTrialsTrials2 = np . empty ( 0 ) tickNumTrialsEachFreq2 = np . empty ( 0 ) for indf in range ( len ( possibleFreq ) ) :          if ( numTrialsEachFreq2 [ indf ] != 0 ) :              tickPossibleFreq2 = np . append ( tickPossibleFreq2 , possibleFreq [ indf ] ) tickNumTrialsTrials2 = np . append ( tickNumTrialsTrials2 , numTrialsTrials2 [ indf ] ) tickNumTrialsEachFreq2 = np . append ( tickNumTrialsEachFreq2 , numTrialsEachFreq2 [ indf ] )   return [ spikeTimesFromEventOnsetTrials1 , spikeTimesFromEventOnsetTrials2 , sortedIndexForEachSpikeTrials1 , sortedIndexForEachSpikeTrials2 , tickPossibleFreq1 , tickNumTrialsTrials1 , tickNumTrialsEachFreq1 , tickPossibleFreq2 , tickNumTrialsTrials2 , tickNumTrialsEachFreq2 , xCoordinatesPlot , spikeMeanInBin1 , spikeMeanInBin2 ]   