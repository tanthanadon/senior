from jaratoolbox import settings from jaratoolbox import extraplots import indiv_SwitchingReport as indiv import numpy as np import os import sys import importlib import glob mouseName = str ( sys . argv [ 1 ] ) allcellsFileName = <str> + mouseName + <str> sys . path . append ( settings . ALLCELLS_PATH ) allcells = importlib . import_module ( allcellsFileName ) if ( str ( sys . argv [ 2 ] ) == <str> ) :      switchBool = True  else :      switchBool = False  ephysRootDir = settings . EPHYS_PATH experimenter = <str> paradigm = <str> numOfCells = len ( allcells . cellDB ) clusNum = 12 numTetrodes = 8 qualityList = [ 1 , 6 ] minZVal = 3.0 maxISIviolation = 0.02 tmpFileName = <str> excludedTmpFileName = <str> class nestedDict ( dict ) :      def __getitem__ ( self , item ) :          try :              return super ( nestedDict , self ) . __getitem__ ( item )  except KeyError :              value = self [ item ] = type ( self ) ( ) return value    subject = allcells . cellDB [ 0 ] . animalName behavSession = <str> processedDir = os . path . join ( settings . EPHYS_PATH , subject + <str> ) maxZFilename = os . path . join ( processedDir , <str> ) minPerfFilename = os . path . join ( processedDir , <str> ) minTrialFilename = os . path . join ( processedDir , <str> ) ISIFilename = os . path . join ( processedDir , <str> ) maxZFile = open ( maxZFilename , <str> ) minPerfFile = open ( minPerfFilename , <str> ) minTrialFile = open ( minTrialFilename , <str> ) ISIFile = open ( ISIFilename , <str> ) minPerfFile . readline ( ) minPerfList = minPerfFile . read ( ) . split ( ) minTrialFile . readline ( ) minTrialFile . readline ( ) minTrialDict = { } for lineCount , line in enumerate ( minTrialFile ) :      minTrialStr = line . split ( <str> ) trialFreq = minTrialStr [ 1 ] . split ( ) minTrialDict . update ( { minTrialStr [ 0 ] [ 1 : ] : trialFreq } )  maxZDict = nestedDict ( ) behavName = <str> for line in maxZFile :      behavLine = line . split ( <str> ) freqLine = line . split ( ) if ( behavLine [ 0 ] == <str> ) :          behavName = behavLine [ 1 ] [ : - 1 ]  else :          maxZDict [ behavName ] [ freqLine [ 0 ] ] = freqLine [ 1 ] . split ( <str> ) [ 0 : - 1 ]   ISIDict = { } ephysName = <str> for line in ISIFile :      ephysLine = line . split ( <str> ) tetrodeLine = line . split ( ) tetrodeName = tetrodeLine [ 0 ] . split ( <str> ) if ( ephysLine [ 0 ] == <str> ) :          ephysName = ephysLine [ 1 ] [ : - 1 ] ISIDict . update ( { ephysName : np . full ( ( numTetrodes , clusNum ) , 1.0 ) } )  else :          ISIDict [ ephysName ] [ int ( tetrodeName [ 1 ] ) ] = tetrodeLine [ 1 : ]   ISIFile . close ( ) maxZFile . close ( ) minPerfFile . close ( ) minTrialFile . close ( ) copyToDir = <str> + tmpFileName + <str> + mouseName + <str> copyToExcludedDir = <str> + tmpFileName + <str> + mouseName + <str> + excludedTmpFileName + <str> if not os . path . exists ( copyToDir ) :      os . makedirs ( copyToDir )  if not os . path . exists ( copyToExcludedDir ) :      os . makedirs ( copyToExcludedDir )  files = glob . glob ( copyToDir + <str> ) for f in files :      os . remove ( f )  files = glob . glob ( copyToExcludedDir + <str> ) for f in files :      os . remove ( f )  ClusterDict = { } excludedClusterDict = { } behavEphysDict = { } def main ( ) :      global myft print <str> + subject + <str> if switchBool :          print <str> totalClusterNum ( ) clustersInGoodSessions ( ) responsiveCellsMiddleFreqSwitching ( ) qualityCell ( ) ISIcheck ( ) plotClusters ( )  else :          print <str> cellsPerSessionPsyCurve ( ) responsiveCellsPsyCurve ( )   def totalClusterNum ( ) :      global behavEphysDict behavSession = <str> for cellID in range ( 0 , numOfCells ) :          oneCell = allcells . cellDB [ cellID ] if ( behavSession != oneCell . behavSession ) :              behavSession = oneCell . behavSession ClusterDict [ behavSession ] = list ( ) behavEphysDict [ behavSession ] = oneCell . ephysSession  tetrode = oneCell . tetrode cluster = oneCell . cluster clusterQuality = oneCell . quality [ cluster - 1 ] ClusterDict [ behavSession ] . append ( ( tetrode , cluster , clusterQuality ) )   def showClusters ( ) :      currentCellList = [ ] for behavSession , tetClusList in ClusterDict . iteritems ( ) :          for tetClus in tetClusList :              currentCellList . append ( ( mouseName , behavSession , tetClus [ 0 ] , tetClus [ 1 ] ) )   ft = extraplots . FlipThrough ( indiv . switch_report , currentCellList ) return ft  def plotClusters ( ) :      currentCellList = [ ] totalCellCount = 0 for behavSession , tetClusList in ClusterDict . iteritems ( ) :          for tetClus in tetClusList :              tetrode = tetClus [ 0 ] cluster = tetClus [ 1 ] os . system ( <str> % ( mouseName , mouseName , behavSession , str ( tetrode ) , str ( cluster ) , tmpFileName , mouseName ) ) totalCellCount += 1   for behavSession , tetClusList in excludedClusterDict . iteritems ( ) :          for tetClus in tetClusList :              tetrode = tetClus [ 0 ] cluster = tetClus [ 1 ] os . system ( <str> % ( mouseName , mouseName , behavSession , str ( tetrode ) , str ( cluster ) , copyToExcludedDir ) )   print <str> , totalCellCount  def clustersInGoodSessions ( ) :      badSession = list ( ) for behavSession in ClusterDict :          if ( ( behavSession not in minPerfList ) or ( behavSession not in minTrialDict ) ) :              badSession . append ( behavSession )   for badSess in badSession :          del ClusterDict [ badSess ]   def responsiveCellsMiddleFreqSwitching ( ) :      global excludedClusterDict excludedClusterDict = { } badSession = list ( ) middleFreq = 1 for behavSession , tetClusList in ClusterDict . iteritems ( ) :          badTetClus = list ( ) if behavSession not in maxZDict :              if behavSession not in badSession :                  badSession . append ( behavSession )  continue  freqList = list ( ) for freq in maxZDict [ behavSession ] :              freqList . append ( int ( freq ) )  freqList . sort ( ) frequency = freqList [ middleFreq ] for tetClus in tetClusList :              clusterNumber = ( tetClus [ 0 ] - 1 ) * clusNum + ( tetClus [ 1 ] - 1 ) if ( abs ( float ( maxZDict [ behavSession ] [ str ( frequency ) ] [ clusterNumber ] ) ) < minZVal ) :                  badTetClus . append ( tetClus )   excludedClusterDict [ behavSession ] = list ( ) for tetClus in badTetClus :              tetrode = tetClus [ 0 ] cluster = tetClus [ 1 ] clusterQuality = tetClus [ 2 ] excludedClusterDict [ behavSession ] . append ( ( tetrode , cluster , clusterQuality ) ) ClusterDict [ behavSession ] . remove ( tetClus )   for badSess in badSession :          del ClusterDict [ badSess ]   def qualityCell ( ) :      global excludedClusterDict excludedClusterDict = { } for behavSession , tetClusList in ClusterDict . iteritems ( ) :          badTetClus = list ( ) for tetClus in tetClusList :              tetrode = tetClus [ 0 ] cluster = tetClus [ 1 ] clusterQuality = tetClus [ 2 ] if clusterQuality not in qualityList :                  badTetClus . append ( tetClus )   excludedClusterDict [ behavSession ] = list ( ) for tetClus in badTetClus :              tetrode = tetClus [ 0 ] cluster = tetClus [ 1 ] clusterQuality = tetClus [ 2 ] excludedClusterDict [ behavSession ] . append ( ( tetrode , cluster , clusterQuality ) ) ClusterDict [ behavSession ] . remove ( tetClus )    def ISIcheck ( ) :      global excludedClusterDict excludedClusterDict = { } badSession = list ( ) for behavSession , tetClusList in ClusterDict . iteritems ( ) :          ephysSession = behavEphysDict [ behavSession ] if ephysSession not in ISIDict :              if behavSession not in badSession :                  badSession . append ( behavSession )  continue  badTetClus = list ( ) for tetClus in tetClusList :              tetrode = tetClus [ 0 ] cluster = tetClus [ 1 ] clusterQuality = tetClus [ 2 ] if ( ISIDict [ ephysSession ] [ tetrode - 1 ] [ cluster - 1 ] > maxISIviolation ) :                  badTetClus . append ( tetClus )   excludedClusterDict [ behavSession ] = list ( ) for tetClus in badTetClus :              tetrode = tetClus [ 0 ] cluster = tetClus [ 1 ] clusterQuality = tetClus [ 2 ] excludedClusterDict [ behavSession ] . append ( ( tetrode , cluster , clusterQuality ) ) ClusterDict [ behavSession ] . remove ( tetClus )   for badSess in badSession :          del ClusterDict [ badSess ]   def cellsPerSessionPsyCurve ( ) :      cellCount = 0 midFreqCellCount = 0 bSessions = [ ] goodBSessions = [ ] for cellID in range ( 0 , numOfCells ) :          oneCell = allcells . cellDB [ cellID ] behavSession = oneCell . behavSession ephysSession = oneCell . ephysSession tetrode = oneCell . tetrode cluster = oneCell . cluster clusterQuality = oneCell . quality [ cluster - 1 ] if ( behavSession not in bSessions ) :              bSessions . append ( behavSession )  if behavSession not in minPerfList :              continue  elif behavSession not in minTrialDict :              continue  if ( behavSession not in goodBSessions ) :              goodBSessions . append ( behavSession )  if clusterQuality not in qualityList :              continue  elif behavSession not in maxZDict :              continue  elif ephysSession not in ISIDict :              continue  clusterNumber = ( tetrode - 1 ) * clusNum + ( cluster - 1 ) freqList = [ ] cellCountBool = False midFreqCellCountBool = False for freq in maxZDict [ behavSession ] :              freqList . append ( int ( freq ) )  freqList . sort ( ) for indFreq , frequency in enumerate ( freqList ) :              if ( ( abs ( float ( maxZDict [ behavSession ] [ str ( frequency ) ] [ clusterNumber ] ) ) >= minZVal ) & ( ISIDict [ ephysSession ] [ tetrode - 1 ] [ cluster - 1 ] <= maxISIviolation ) ) :                  cellCountBool = True if ( ( indFreq == ( len ( freqList ) / 2 ) ) or ( indFreq == ( ( len ( freqList ) / 2 ) + 1 ) ) ) :                      midFreqCellCountBool = True    if cellCountBool :              cellCount += 1  if midFreqCellCountBool :              midFreqCellCount += 1   print <str> , cellCount print <str> , float ( cellCount ) / len ( bSessions ) print <str> , float ( cellCount ) / len ( goodBSessions ) print <str> , midFreqCellCount print <str> , float ( midFreqCellCount ) / len ( bSessions ) print <str> , float ( midFreqCellCount ) / len ( goodBSessions ) print <str> , len ( goodBSessions ) print <str> , len ( bSessions )  def cellsPerSessionSwitching ( ) :      cellCount = 0 midFreqCellCount = 0 bSessions = [ ] goodBSessions = [ ] for cellID in range ( 0 , numOfCells ) :          oneCell = allcells . cellDB [ cellID ] behavSession = oneCell . behavSession ephysSession = oneCell . ephysSession tetrode = oneCell . tetrode cluster = oneCell . cluster clusterQuality = oneCell . quality [ cluster - 1 ] if ( behavSession not in bSessions ) :              bSessions . append ( behavSession )  if behavSession not in minPerfList :              continue  elif behavSession not in minTrialDict :              continue  if ( behavSession not in goodBSessions ) :              goodBSessions . append ( behavSession )  if clusterQuality not in qualityList :              continue  elif behavSession not in maxZDict :              continue  elif ephysSession not in ISIDict :              continue  clusterNumber = ( tetrode - 1 ) * clusNum + ( cluster - 1 ) freqList = [ ] cellCountBool = False for freq in maxZDict [ behavSession ] :              freqList . append ( int ( freq ) )  freqList . sort ( ) for indFreq , frequency in enumerate ( freqList ) :              if ( ( abs ( float ( maxZDict [ behavSession ] [ str ( frequency ) ] [ clusterNumber ] ) ) >= minZVal ) & ( ISIDict [ ephysSession ] [ tetrode - 1 ] [ cluster - 1 ] <= maxISIviolation ) ) :                  cellCountBool = True if ( indFreq == 1 ) :                      midFreqCellCount += 1    if cellCountBool :              cellCount += 1   print <str> , cellCount print <str> , float ( cellCount ) / len ( bSessions ) print <str> , float ( cellCount ) / len ( goodBSessions ) print <str> , midFreqCellCount print <str> , float ( midFreqCellCount ) / len ( bSessions ) print <str> , float ( midFreqCellCount ) / len ( goodBSessions ) print <str> , len ( goodBSessions ) print <str> , len ( bSessions )  def responsiveCellsPsyCurve ( ) :      responsiveCellCount = 0 midFreqResponsiveCellCount = 0 qualityCellCount = 0 qualityAndISICellCount = 0 bSessions = [ ] for cellID in range ( 0 , numOfCells ) :          oneCell = allcells . cellDB [ cellID ] behavSession = oneCell . behavSession ephysSession = oneCell . ephysSession tetrode = oneCell . tetrode cluster = oneCell . cluster clusterQuality = oneCell . quality [ cluster - 1 ] if ( behavSession not in bSessions ) :              bSessions . append ( behavSession )  if behavSession not in maxZDict :              continue  elif ephysSession not in ISIDict :              continue  if clusterQuality in qualityList :              qualityCellCount += 1  clusterNumber = ( tetrode - 1 ) * clusNum + ( cluster - 1 ) freqList = [ ] responsiveCellCountBool = False midFreqResponsiveCellCountBool = False qualityAndISICellCountBool = False for freq in maxZDict [ behavSession ] :              freqList . append ( int ( freq ) )  freqList . sort ( ) for indFreq , frequency in enumerate ( freqList ) :              if ( abs ( float ( maxZDict [ behavSession ] [ str ( frequency ) ] [ clusterNumber ] ) ) >= minZVal ) :                  responsiveCellCountBool = True if ( ( indFreq == ( len ( freqList ) / 2 ) ) or ( indFreq == ( ( len ( freqList ) / 2 ) + 1 ) ) ) :                      midFreqResponsiveCellCountBool = True   if ( ( ISIDict [ ephysSession ] [ tetrode - 1 ] [ cluster - 1 ] <= maxISIviolation ) and ( clusterQuality in qualityList ) ) :                  qualityAndISICellCountBool = True   if qualityAndISICellCountBool :              qualityAndISICellCount += 1  if midFreqResponsiveCellCountBool :              midFreqResponsiveCellCount += 1  if responsiveCellCountBool :              responsiveCellCount += 1   print <str> , responsiveCellCount print <str> , midFreqResponsiveCellCount print <str> , qualityCellCount print <str> , qualityAndISICellCount  def responsiveCellsSwitching ( ) :      responsiveCellCount = 0 midFreqResponsiveCellCount = 0 qualityCellCount = 0 qualityAndISICellCount = 0 bSessions = [ ] for cellID in range ( 0 , numOfCells ) :          oneCell = allcells . cellDB [ cellID ] behavSession = oneCell . behavSession ephysSession = oneCell . ephysSession tetrode = oneCell . tetrode cluster = oneCell . cluster clusterQuality = oneCell . quality [ cluster - 1 ] if ( behavSession not in bSessions ) :              bSessions . append ( behavSession )  if behavSession not in maxZDict :              continue  elif ephysSession not in ISIDict :              continue  if clusterQuality in qualityList :              qualityCellCount += 1  clusterNumber = ( tetrode - 1 ) * clusNum + ( cluster - 1 ) freqList = [ ] responsiveCellCountBool = False midFreqResponsiveCellCountBool = False qualityAndISICellCountBool = False for freq in maxZDict [ behavSession ] :              freqList . append ( int ( freq ) )  freqList . sort ( ) for indFreq , frequency in enumerate ( freqList ) :              if ( abs ( float ( maxZDict [ behavSession ] [ str ( frequency ) ] [ clusterNumber ] ) ) >= minZVal ) :                  responsiveCellCountBool = True if ( indFreq == 1 ) :                      midFreqResponsiveCellCountBool = True   if ( ( ISIDict [ ephysSession ] [ tetrode - 1 ] [ cluster - 1 ] <= maxISIviolation ) and ( clusterQuality in qualityList ) ) :                  qualityAndISICellCountBool = True   if qualityAndISICellCountBool :              qualityAndISICellCount += 1  if midFreqResponsiveCellCountBool :              midFreqResponsiveCellCount += 1  if responsiveCellCountBool :              responsiveCellCount += 1   print <str> , responsiveCellCount print <str> , midFreqResponsiveCellCount print <str> , qualityCellCount print <str> , qualityAndISICellCount  main ( )  