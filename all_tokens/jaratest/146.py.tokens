import numpy as np import os from jaratoolbox import settings class EphysSessionInfo ( object ) :       def __init__ ( self , animalName , tuningSession , ephysSession , tuningBehavior , behavSession , depth , clustersEachTetrode = { } , clusterQuality = { } , soundResponse = { } , trialsToExclude = [ ] ) :           self . animalName = animalName self . tuningSession = tuningSession self . ephysSession = ephysSession self . tuningBehavior = tuningBehavior self . behavSession = behavSession self . clustersEachTetrode = clustersEachTetrode self . clusterQuality = clusterQuality self . depth = depth self . trialsToExclude = trialsToExclude   class CellInfo ( object ) :      def __init__ ( self , animalName , tuningSession , ephysSession , tuningBehavior , behavSession , tetrode , cluster , depth , quality , trialsToExclude = [ ] ) :          self . animalName = animalName self . tuningSession = tuningSession self . ephysSession = ephysSession self . tuningBehavior = tuningBehavior self . behavSession = behavSession self . tetrode = tetrode self . cluster = cluster self . depth = depth self . quality = quality self . trialsToExclude = np . array ( trialsToExclude , dtype = int )  def get_filename ( self ) :          ephysDir = settings . EPHYS_PATH filenameOnly = <str> . format ( self . tetrode ) fullPath = os . path . join ( ephysDir , self . animalName , self . ephysSession , filenameOnly ) return fullPath  def __repr__ ( self ) :          objStrings = [ ] for key , value in sorted ( vars ( self ) . iteritems ( ) ) :              objStrings . append ( <str> % ( key , str ( value ) ) )  return <str> . join ( objStrings )  def __str__ ( self ) :          objStr = <str> % ( self . animalName , self . ephysSession , self . tetrode , self . cluster ) return objStr   class MultiUnitInfo ( object ) :      def __init__ ( self , animalName , ephysSession , behavSession , tetrode , clusters = [ ] ) :          self . animalName = animalName self . ephysSession = ephysSession self . behavSession = behavSession self . tetrode = tetrode self . clusters = clusters  def __repr__ ( self ) :          objStrings = [ ] for key , value in sorted ( vars ( self ) . iteritems ( ) ) :              objStrings . append ( <str> % ( key , str ( value ) ) )  return <str> . join ( objStrings )  def __str__ ( self ) :          objStr = <str> % ( self . animalName , self . ephysSession , self . tetrode ) return objStr   class CellDatabase ( list ) :      def __init__ ( self ) :          super ( CellDatabase , self ) . __init__ ( )  def append_session ( self , sessionInfo ) :          for tetrode in sorted ( sessionInfo . clustersEachTetrode . keys ( ) ) :              for cluster in sessionInfo . clustersEachTetrode [ tetrode ] :                  oneCell = CellInfo ( animalName = sessionInfo . animalName , tuningSession = sessionInfo . tuningSession , ephysSession = sessionInfo . ephysSession , tuningBehavior = sessionInfo . tuningBehavior , behavSession = sessionInfo . behavSession , tetrode = tetrode , cluster = cluster , quality = sessionInfo . clusterQuality [ tetrode ] , depth = sessionInfo . depth , trialsToExclude = [ ] ) for trialset in sessionInfo . trialsToExclude :                      if trialset [ 0 ] == tetrode and trialset [ 1 ] == cluster :                          oneCell . trialsToExclude = trialset [ 2 ]  else :                          print <str> . format ( oneCell )   self . append ( oneCell )    def findcell ( self , firstParam , behavSession = <str> , tetrode = - 1 , cluster = - 1 ) :          cellIndex = None if isinstance ( firstParam , str ) :               for ind , cell in enumerate ( self ) :                   if firstParam == cell . animalName :                       if behavSession == cell . behavSession :                           if tetrode == cell . tetrode :                               if cluster == cell . cluster :                                   cellIndex = ind       else :               onecell = firstParam for ind , cell in enumerate ( self ) :                   if onecell . animalName == cell . animalName :                       if onecell . behavSession == cell . behavSession :                           if onecell . tetrode == cell . tetrode :                               if onecell . cluster == cell . cluster :                                   cellIndex = ind       return cellIndex  def set_soundResponsive ( self , zScores , threshold = 3 ) :          for indcell , onecell in enumerate ( self ) :              onecell . soundResponsive = np . any ( abs ( zScores [ : , : , indcell ] ) > threshold )   def get_vector ( self , varname ) :          return np . array ( [ getattr ( onecell , varname ) for onecell in self ] )  def subset ( self , indexes ) :          subsetDB = CellDatabase ( ) if isinstance ( indexes , np . ndarray ) and indexes . dtype == bool :              indexes = np . flatnonzero ( indexes )  for ind in indexes :              subsetDB . append ( self [ ind ] )  return subsetDB  def __str__ ( self ) :          objStrings = [ ] for ind , c in enumerate ( self ) :              objStrings . append ( <str> % ( ind , c ) )  return <str> . join ( objStrings )  def save_locked_spikes ( self , outputDir , timeRange = np . array ( [ - 0.3 , 0.9 ] ) , lockTo = 1 ) :          sessionanalysis . save_data_each_cell ( self , outputDir , timeRange = timeRange , lockTo = lockTo )  def evaluate_response ( self ) :          pass   class MultiUnitDatabase ( list ) :      def __init__ ( self ) :          super ( MultiUnitDatabase , self ) . __init__ ( )  def __str__ ( self ) :          objStrings = [ ] for ind , c in enumerate ( self ) :              objStrings . append ( <str> % ( ind , c ) )  return <str> . join ( objStrings )  def save_locked_spikes ( self , outputDir , timeRange = np . array ( [ - 0.3 , 0.9 ] ) , lockTo = 1 ) :          sessionanalysis . save_data_each_mu ( self , outputDir , timeRange = timeRange , lockTo = 1 )    