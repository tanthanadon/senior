from jaratoolbox import loadbehavior from jaratoolbox import settings from jaratoolbox import ephyscore import os import numpy as np from jaratoolbox import loadopenephys from jaratoolbox import spikesanalysis from jaratoolbox import extraplots import matplotlib . pyplot as plt import sys import importlib mouseList = [ <str> , <str> ] SAMPLING_RATE = 30000.0 soundTriggerChannel = 0 binWidth = 0.030 countTimeRange = [ 0 , 0.1 ] clusNum = 12 numTetrodes = 8 qualityList = [ 1 , 6 ] minZVal = 3.0 maxISIviolation = 0.02 minFileName = <str> timeRange = [ - 0.2 , 0.8 ] ephysRootDir = settings . EPHYS_PATH outputDir = <str> experimenter = <str> paradigm = <str> class nestedDict ( dict ) :      def __getitem__ ( self , item ) :          try :              return super ( nestedDict , self ) . __getitem__ ( item )  except KeyError :              value = self [ item ] = type ( self ) ( ) return value    modIndexArray = [ ] for mouseName in mouseList :      allcellsFileName = <str> + mouseName + <str> sys . path . append ( settings . ALLCELLS_PATH ) allcells = importlib . import_module ( allcellsFileName ) numOfCells = len ( allcells . cellDB ) subject = allcells . cellDB [ 0 ] . animalName behavSession = <str> processedDir = os . path . join ( settings . EPHYS_PATH , subject + <str> ) maxZFilename = os . path . join ( processedDir , <str> ) minPerfFilename = os . path . join ( processedDir , <str> ) minTrialFilename = os . path . join ( processedDir , <str> ) ISIFilename = os . path . join ( processedDir , <str> ) maxZFile = open ( maxZFilename , <str> ) minPerfFile = open ( minPerfFilename , <str> ) minTrialFile = open ( minTrialFilename , <str> ) ISIFile = open ( ISIFilename , <str> ) minPerfFile . readline ( ) minPerfList = minPerfFile . read ( ) . split ( ) minTrialFile . readline ( ) minTrialFile . readline ( ) minTrialDict = { } for lineCount , line in enumerate ( minTrialFile ) :          minTrialStr = line . split ( <str> ) trialFreq = minTrialStr [ 1 ] . split ( ) minTrialDict . update ( { minTrialStr [ 0 ] [ 1 : ] : trialFreq } )  maxZDict = nestedDict ( ) behavName = <str> for line in maxZFile :          behavLine = line . split ( <str> ) freqLine = line . split ( ) if ( behavLine [ 0 ] == <str> ) :              behavName = behavLine [ 1 ] [ : - 1 ]  else :              maxZDict [ behavName ] [ freqLine [ 0 ] ] = freqLine [ 1 ] . split ( <str> ) [ 0 : - 1 ]   ISIDict = { } ephysName = <str> for line in ISIFile :          ephysLine = line . split ( <str> ) tetrodeLine = line . split ( ) tetrodeName = tetrodeLine [ 0 ] . split ( <str> ) if ( ephysLine [ 0 ] == <str> ) :              ephysName = ephysLine [ 1 ] [ : - 1 ] ISIDict . update ( { ephysName : np . full ( ( numTetrodes , clusNum ) , 1.0 ) } )  else :              ISIDict [ ephysName ] [ int ( tetrodeName [ 1 ] ) ] = tetrodeLine [ 1 : ]   ISIFile . close ( ) maxZFile . close ( ) minPerfFile . close ( ) minTrialFile . close ( ) for cellID in range ( 0 , numOfCells ) :          oneCell = allcells . cellDB [ cellID ] subject = oneCell . animalName behavSession = oneCell . behavSession ephysSession = oneCell . ephysSession ephysRoot = os . path . join ( ephysRootDir , subject ) tetrode = oneCell . tetrode cluster = oneCell . cluster clusterQuality = oneCell . quality [ cluster - 1 ] if clusterQuality not in qualityList :              continue  elif behavSession not in minPerfList :              continue  elif behavSession not in minTrialDict :              continue  elif behavSession not in maxZDict :              continue  elif ephysSession not in ISIDict :              continue  clusterNumber = ( tetrode - 1 ) * clusNum + ( cluster - 1 ) freqList = [ ] for freq in minTrialDict [ behavSession ] :              if ( ( abs ( float ( maxZDict [ behavSession ] [ freq ] [ clusterNumber ] ) ) >= minZVal ) & ( ISIDict [ ephysSession ] [ tetrode - 1 ] [ cluster - 1 ] <= maxISIviolation ) ) :                  freqList . append ( int ( freq ) )   if ( len ( freqList ) < 1 ) :              continue  behaviorFilename = loadbehavior . path_to_behavior_data ( subject , experimenter , paradigm , behavSession ) bdata = loadbehavior . BehaviorData ( behaviorFilename ) ephysDir = os . path . join ( ephysRoot , ephysSession ) eventFilename = os . path . join ( ephysDir , <str> ) events = loadopenephys . Events ( eventFilename ) eventTimes = np . array ( events . timestamps ) / SAMPLING_RATE soundOnsetEvents = ( events . eventID == 1 ) & ( events . eventChannel == soundTriggerChannel ) spkData = ephyscore . CellData ( oneCell ) spkTimeStamps = spkData . spikes . timestamps eventOnsetTimes = eventTimes [ soundOnsetEvents ] rightward = bdata [ <str> ] == bdata . labels [ <str> ] [ <str> ] leftward = bdata [ <str> ] == bdata . labels [ <str> ] [ <str> ] possibleFreq = np . unique ( bdata [ <str> ] ) numberOfFrequencies = len ( possibleFreq ) numberOfTrials = len ( bdata [ <str> ] ) targetFreqs = bdata [ <str> ] for Freq in freqList :                  oneFreq = targetFreqs == Freq trialsToUseRight = rightward & oneFreq trialsToUseLeft = leftward & oneFreq print <str> , subject , <str> , behavSession , <str> , oneCell . tetrode , <str> , cluster , <str> , Freq ( spikeTimesFromEventOnset , trialIndexForEachSpike , indexLimitsEachTrial ) = spikesanalysis . eventlocked_spiketimes ( spkTimeStamps , eventOnsetTimes , timeRange ) spikeCountMat = spikesanalysis . spiketimes_to_spikecounts ( spikeTimesFromEventOnset , indexLimitsEachTrial , countTimeRange ) spikeCountEachTrial = spikeCountMat . flatten ( ) spikeAvgRight = sum ( spikeCountEachTrial [ trialsToUseRight ] ) / float ( sum ( trialsToUseRight ) ) spikeAvgLeft = sum ( spikeCountEachTrial [ trialsToUseLeft ] ) / float ( sum ( trialsToUseLeft ) ) if ( ( spikeAvgRight + spikeAvgLeft ) == 0 ) :                      modIndexArray . append ( 0 )  else :                      modIndexArray . append ( ( spikeAvgRight - spikeAvgLeft ) / ( spikeAvgRight + spikeAvgLeft ) )     modIndBinVec = np . arange ( - 1 , 1 , binWidth ) binModIndexArray = np . empty ( len ( modIndBinVec ) ) for binInd in range ( len ( modIndBinVec ) - 1 ) :      binModIndexArray [ binInd ] = len ( np . where ( ( modIndexArray >= modIndBinVec [ binInd ] ) & ( modIndexArray < modIndBinVec [ binInd + 1 ] ) ) [ 0 ] )  binModIndexArray [ - 1 ] = len ( np . where ( modIndexArray >= modIndBinVec [ - 1 ] ) [ 0 ] ) print <str> , len ( modIndexArray ) plt . clf ( ) modIndBinVec plt . bar ( modIndBinVec , binModIndexArray , width = binWidth ) plt . xlabel ( <str> ) plt . ylabel ( <str> ) plt . gcf ( ) . set_size_inches ( ( 8.5 , 11 ) ) figformat = <str> filename = <str> % ( <str> , figformat ) fulloutputDir = outputDir + <str> + <str> fullFileName = os . path . join ( fulloutputDir , filename ) directory = os . path . dirname ( fulloutputDir ) if not os . path . exists ( directory ) :      os . makedirs ( directory )  print <str> % fullFileName plt . gcf ( ) . savefig ( fullFileName , format = figformat ) plt . show ( )  