from jaratoolbox import loadbehavior from jaratoolbox import settings_2 as settings from jaratoolbox import ephyscore import os import shutil import numpy as np from jaratoolbox import loadopenephys from jaratoolbox import spikesanalysis from jaratoolbox import extraplots from jaratest . lan . Ephys import celldatabase_quality_vlan as celldatabase from jaratest . lan import test022_plot2afc_given_cell_rew_change as cellplotter import matplotlib . pyplot as plt import sys import importlib subject = str ( sys . argv [ 1 ] ) allcellsFileName = <str> + subject sys . path . append ( settings . ALLCELLS_PATH ) allcells = importlib . import_module ( allcellsFileName ) numOfCells = len ( allcells . cellDB ) outputDir = <str> + subject + <str> binWidth = 0.020 clusNum = 12 numTetrodes = 8 CellInfo = celldatabase . CellInfo allCellDB = celldatabase . CellDatabase ( ) modulatedCellDB = celldatabase . CellDatabase ( ) qualityList = [ 1 , 6 ] minZVal = 3.0 minPValue = 0.05 subject = allcells . cellDB [ 0 ] . animalName behavSession = <str> processedDir = os . path . join ( outputDir , subject + <str> ) modIFilename = os . path . join ( processedDir , <str> + subject + <str> ) modSFilename = os . path . join ( processedDir , <str> + subject + <str> ) class nestedDict ( dict ) :      def __getitem__ ( self , item ) :          try :              return super ( nestedDict , self ) . __getitem__ ( item )  except KeyError :              value = self [ item ] = type ( self ) ( ) return value    modIFile = open ( modIFilename , <str> ) modSFile = open ( modSFilename , <str> ) modIDict = nestedDict ( ) modSigDict = nestedDict ( ) behavName = <str> for line in modIFile :      behavLine = line . split ( <str> ) freqLine = line . split ( ) if ( behavLine [ 0 ] == <str> ) :          behavName = behavLine [ 1 ] [ : - 1 ]  else :          modIDict [ behavName ] [ freqLine [ 0 ] ] = [ float ( x ) for x in freqLine [ 1 ] . split ( <str> ) [ 0 : - 1 ] ]   for line in modSFile :      behavLine = line . split ( <str> ) freqLine = line . split ( ) if ( behavLine [ 0 ] == <str> ) :          behavName = behavLine [ 1 ] [ : - 1 ]  else :          modSigDict [ behavName ] [ freqLine [ 0 ] ] = [ float ( x ) for x in freqLine [ 1 ] . split ( <str> ) [ 0 : - 1 ] ]   sigModIDict = { } modIFile . close ( ) modSFile . close ( ) modIndexArray = [ ] for cellID in range ( 0 , numOfCells ) :      oneCell = allcells . cellDB [ cellID ] subject = oneCell . animalName behavSession = oneCell . behavSession ephysSession = oneCell . ephysSession tetrode = oneCell . tetrode cluster = oneCell . cluster clusterQuality = oneCell . quality if clusterQuality not in qualityList :          continue  if behavSession not in modIDict :          continue  clusterNumber = ( tetrode - 1 ) * clusNum + ( cluster - 1 ) for freq in modIDict [ behavSession ] :          modIndexArray . append ( [ modIDict [ behavSession ] [ freq ] [ clusterNumber ] , modSigDict [ behavSession ] [ freq ] [ clusterNumber ] ] ) oneCell = CellInfo ( animalName = subject , ephysSession = ephysSession , tetrode = tetrode , cluster = cluster , behavSession = behavSession , quality = clusterQuality ) allCellDB . append ( oneCell ) cellName = subject + <str> + behavSession + <str> + str ( tetrode ) + <str> + str ( cluster ) if ( modSigDict [ behavSession ] [ freq ] [ clusterNumber ] <= minPValue ) :              modIndexThisCell = modIDict [ behavSession ] [ freq ] [ clusterNumber ] sigModIDict . update ( { cellName : [ cellID , freq , modIndexThisCell ] } ) modulatedCellDB . append ( oneCell )    modIndBinVec = np . arange ( - 1 , 1 , binWidth ) binModIndexArraySig = np . empty ( len ( modIndBinVec ) ) binModIndexArrayNonSig = np . empty ( len ( modIndBinVec ) ) maxMI = 0 for binInd in range ( len ( modIndBinVec ) - 1 ) :      binTotalSig = 0 binTotalNonSig = 0 for modIndSig in modIndexArray :          if ( ( modIndSig [ 0 ] >= modIndBinVec [ binInd ] ) and ( modIndSig [ 0 ] < modIndBinVec [ binInd + 1 ] ) and ( modIndSig [ 1 ] <= minPValue ) ) :              binTotalSig += 1  elif ( ( modIndSig [ 0 ] >= modIndBinVec [ binInd ] ) and ( modIndSig [ 0 ] < modIndBinVec [ binInd + 1 ] ) ) :              binTotalNonSig += 1  maxMI = max ( maxMI , abs ( modIndSig [ 0 ] ) )  binModIndexArraySig [ binInd ] = binTotalSig binModIndexArrayNonSig [ binInd ] = binTotalNonSig  binModIndexArraySig [ - 1 ] = 0 binModIndexArrayNonSig [ - 1 ] = 0 sigNum = int ( sum ( binModIndexArraySig ) ) cellNum = len ( modIndexArray ) print <str> , cellNum plt . clf ( ) plt . bar ( modIndBinVec , binModIndexArraySig , width = binWidth , color = <str> ) plt . bar ( modIndBinVec , binModIndexArrayNonSig , width = binWidth , color = <str> , bottom = binModIndexArraySig ) plt . xlim ( ( - ( maxMI + binWidth ) , maxMI + binWidth ) ) plt . xlabel ( <str> ) plt . ylabel ( <str> ) plt . title ( <str> % ( cellNum , sigNum ) ) plt . gcf ( ) . set_size_inches ( ( 8.5 , 11 ) ) figformat = <str> filename = <str> % ( subject , figformat ) fulloutputDir = processedDir fullFileName = os . path . join ( fulloutputDir , filename ) directory = os . path . dirname ( fulloutputDir ) if not os . path . exists ( directory ) :      os . makedirs ( directory )  print <str> % fullFileName plt . gcf ( ) . savefig ( fullFileName , format = figformat ) plt . show ( ) sigModI_file = open ( <str> % ( fulloutputDir , <str> ) , <str> ) for ( key , value ) in sorted ( sigModIDict . items ( ) ) :      sigModI_file . write ( <str> % key ) sigModI_file . write ( <str> % ( value [ 0 ] , value [ 1 ] , value [ 2 ] ) )  sigModI_file . close ( ) numOfModulatedCells = len ( modulatedCellDB ) for cellID in range ( 0 , numOfModulatedCells ) :      oneCell = modulatedCellDB [ cellID ] dstDir = processedDir + <str> if not os . path . exists ( dstDir ) :          os . makedirs ( dstDir )  figname = <str> . format ( oneCell . animalName , oneCell . behavSession , oneCell . tetrode , oneCell . cluster , <str> ) full_fig_path = os . path . join ( dstDir , figname ) if not os . path . exists ( full_fig_path ) :          cellplotter . plot_rew_change_per_cell ( oneCell , trialLimit = [ ] , alignment = <str> ) plt . savefig ( full_fig_path , format = <str> )  figname = <str> . format ( oneCell . animalName , oneCell . behavSession , oneCell . tetrode , oneCell . cluster , <str> , <str> ) full_fig_path = os . path . join ( dstDir , figname ) if not os . path . exists ( full_fig_path ) :          cellplotter . plot_rew_change_byblock_per_cell ( oneCell , trialLimit = [ ] , alignment = <str> , choiceSide = <str> ) plt . savefig ( full_fig_path , format = <str> )  figname = <str> . format ( oneCell . animalName , oneCell . behavSession , oneCell . tetrode , oneCell . cluster , <str> , <str> ) full_fig_path = os . path . join ( dstDir , figname ) if not os . path . exists ( full_fig_path ) :          cellplotter . plot_rew_change_byblock_per_cell ( oneCell , trialLimit = [ ] , alignment = <str> , choiceSide = <str> ) plt . savefig ( full_fig_path , format = <str> )    