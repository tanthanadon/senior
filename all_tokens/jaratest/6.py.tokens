import os import numpy as np import time from numpy import array from scipy import stats from jaratoolbox import celldatabase from jaratoolbox import spikesorting from jaratoolbox import spikesanalysis from jaratoolbox import settings from jaratoolbox import ephyscore import studyparams def calculate_ascending_base_stats ( db , frequency , toneIndex ) :      timeRange = [ - 0.1 , 0.4 ] binWidth = 0.01 responseRange = [ 0 , 0.1 ] baseRange = [ - 0.1 , 0 ] pValueResponse = np . tile ( np . nan , len ( celldb ) ) meanEvokedFR = np . tile ( np . nan , len ( celldb ) ) meanBaseFR = np . tile ( np . nan , len ( celldb ) ) pValueFR = np . tile ( np . nan , len ( celldb ) ) meanEvokedFRStd = np . tile ( np . nan , len ( celldb ) ) meanBaseFRStd = np . tile ( np . nan , len ( celldb ) ) meanEvokedFROdd = np . tile ( np . nan , len ( celldb ) ) meanBaseFROdd = np . tile ( np . nan , len ( celldb ) ) expectationIndex = np . tile ( np . nan , len ( celldb ) ) for indRow , dbRow in celldb . iterrows ( ) :          if not <str> in dbRow [ <str> ] :              print ( <str> ) continue  oneCell = ephyscore . Cell ( dbRow ) try :              ephysData , bdata = oneCell . load ( <str> )  except ValueError :              print ( <str> . format ( dbRow [ <str> ] , dbRow [ <str> ] , dbRow [ <str> ] , dbRow [ <str> ] , dbRow [ <str> ] ) ) continue  spikeTimes = ephysData [ <str> ] eventOnsetTimes = ephysData [ <str> ] [ <str> ] if len ( eventOnsetTimes ) == len ( bdata [ <str> ] ) + 1 :              eventOnsetTimes = eventOnsetTimes [ : - 1 ]  ( spikeTimesFromEventOnset , trialIndexForEachSpike , indexLimitsEachTrial ) = spikesanalysis . eventlocked_spiketimes ( spikeTimes , eventOnsetTimes , timeRange ) frequenciesEachTrial = bdata [ <str> ] arrayOfFrequencies = np . unique ( bdata [ <str> ] ) stimCondition = bdata [ <str> ] oddballs = np . flatnonzero ( stimCondition ) if frequency == <str> :              Oddball = np . array ( oddballs [ : : 2 ] ) Standard = Oddball - 2 OddballIndexLimits = indexLimitsEachTrial [ : , Oddball ] StandardIndexLimits = indexLimitsEachTrial [ : , Standard ]  elif frequency == <str> :              Oddball = np . array ( oddballs [ 1 : : 2 ] ) Standard = Oddball - 4 OddballIndexLimits = indexLimitsEachTrial [ : , Oddball ] StandardIndexLimits = indexLimitsEachTrial [ : , Standard ]  else :              Oddball = np . array ( oddballs [ 1 : : 2 ] ) + 1 Standard = Oddball - 3 OddballIndexLimits = indexLimitsEachTrial [ : , Oddball ] StandardIndexLimits = indexLimitsEachTrial [ : , Standard ]  evokedSpikeCountMatOdd = spikesanalysis . spiketimes_to_spikecounts ( spikeTimesFromEventOnset , OddballIndexLimits , responseRange ) baseSpikeCountMatOdd = spikesanalysis . spiketimes_to_spikecounts ( spikeTimesFromEventOnset , OddballIndexLimits , baseRange ) evokedSpikeCountMatStd = spikesanalysis . spiketimes_to_spikecounts ( spikeTimesFromEventOnset , StandardIndexLimits , responseRange ) baseSpikeCountMatStd = spikesanalysis . spiketimes_to_spikecounts ( spikeTimesFromEventOnset , StandardIndexLimits , baseRange ) meanEvokedFROdd [ indRow ] = np . mean ( evokedSpikeCountMatOdd ) / binWidth meanBaseFROdd [ indRow ] = np . mean ( baseSpikeCountMatOdd ) / binWidth meanEvokedFRStd [ indRow ] = np . mean ( evokedSpikeCountMatStd ) / binWidth meanBaseFRStd [ indRow ] = np . mean ( baseSpikeCountMatStd ) / binWidth evokedSpikeCountMatOddList = evokedSpikeCountMatOdd . ravel ( ) . tolist ( ) evokedSpikeCountMatStdList = evokedSpikeCountMatStd . ravel ( ) . tolist ( ) if np . sum ( evokedSpikeCountMatOddList ) != 0 or np . sum ( evokedSpikeCountMatStdList ) != 0 :              [ testStatisticUE , pValUE ] = stats . mannwhitneyu ( evokedSpikeCountMatOddList , evokedSpikeCountMatStdList ) pValueFR [ indRow ] = pValUE  if meanEvokedFRStd [ indRow ] and meanEvokedFROdd [ indRow ] != 0 :              expectationIndex [ indRow ] = ( meanEvokedFROdd [ indRow ] - meanEvokedFRStd [ indRow ] ) / ( meanEvokedFROdd [ indRow ] + meanEvokedFRStd [ indRow ] )  if frequency == <str> :              eventOnsetTimesFreqSort = eventOnsetTimes [ frequenciesEachTrial == arrayOfFrequencies [ 2 ] ]  elif frequency == <str> :              eventOnsetTimesFreqSort = eventOnsetTimes [ frequenciesEachTrial == arrayOfFrequencies [ 1 ] ]  else :              eventOnsetTimesFreqSort = eventOnsetTimes [ frequenciesEachTrial == arrayOfFrequencies [ 0 ] ]  ( spikeTimesFromEventOnsetFreqSort , trialIndexForEachSpikeFreqSort , indexLimitsEachTrialFreqSort ) = spikesanalysis . eventlocked_spiketimes ( spikeTimes , eventOnsetTimesFreqSort , timeRange ) if len ( spikeTimesFromEventOnsetFreqSort ) > 0 :              evokedSpikeCount = spikesanalysis . spiketimes_to_spikecounts ( spikeTimesFromEventOnsetFreqSort , indexLimitsEachTrialFreqSort , responseRange ) baseSpikeCount = spikesanalysis . spiketimes_to_spikecounts ( spikeTimesFromEventOnsetFreqSort , indexLimitsEachTrialFreqSort , baseRange ) meanEvokedFR [ indRow ] = np . mean ( evokedSpikeCount ) / binWidth meanBaseFR [ indRow ] = np . mean ( baseSpikeCount ) / binWidth evokedSpikeCountList = evokedSpikeCount . ravel ( ) . tolist ( ) baseSpikeCountList = baseSpikeCount . ravel ( ) . tolist ( ) if np . sum ( evokedSpikeCountList ) != 0 or np . sum ( baseSpikeCountList ) != 0 :                  [ testStatistic , pVal ] = stats . mannwhitneyu ( evokedSpikeCountList , baseSpikeCountList ) pValueResponse [ indRow ] = pVal   print ( <str> . format ( dbRow [ <str> ] , dbRow [ <str> ] , dbRow [ <str> ] , dbRow [ <str> ] , dbRow [ <str> ] , frequency ) )  celldb [ <str> + frequency + <str> ] = pValueResponse celldb [ <str> + frequency ] = meanEvokedFR celldb [ <str> + frequency ] = meanBaseFR celldb [ <str> + frequency + <str> ] = pValueFR celldb [ <str> + toneIndex + <str> ] = meanEvokedFRStd celldb [ <str> + toneIndex + <str> ] = meanBaseFRStd celldb [ <str> + toneIndex + <str> ] = meanEvokedFROdd celldb [ <str> + toneIndex + <str> ] = meanBaseFROdd celldb [ <str> + frequency ] = expectationIndex return db  def calculate_indices ( db ) :      return db  def calculate_cell_locations ( db ) :      pass  if __name__ == <str> :      startTime = time . time ( ) celldb = celldatabase . generate_cell_database_from_subjects ( studyparams . MICE_LIST , removeBadCells = True , isi = 0.05 , quality = 2 ) cellBaseStats = calculate_ascending_base_stats ( celldb , <str> , <str> ) cellBaseStats = calculate_ascending_base_stats ( celldb , <str> , <str> ) cellBaseStats = calculate_ascending_base_stats ( celldb , <str> , <str> ) dbPath = os . path . join ( settings . FIGURES_DATA_PATH , studyparams . STUDY_NAME ) dbFilename = os . path . join ( dbPath , <str> . format ( studyparams . STUDY_NAME ) ) if os . path . isdir ( dbPath ) :          celldatabase . save_hdf ( celldb , dbFilename ) print ( <str> . format ( dbFilename ) )  else :          print ( <str> . format ( dbPath ) )  print ( <str> . format ( time . time ( ) - startTime ) )   