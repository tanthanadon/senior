from jaratoolbox import loadbehavior from jaratoolbox import settings from jaratoolbox import ephyscore import os import numpy as np from jaratoolbox import loadopenephys from jaratoolbox import spikesanalysis from jaratoolbox import extraplots import matplotlib . pyplot as plt import sys import importlib import animalTetDepths subject = str ( sys . argv [ 1 ] ) allcellsFileName = <str> + subject + <str> sys . path . append ( settings . ALLCELLS_PATH ) allcells = importlib . import_module ( allcellsFileName ) numOfCells = len ( allcells . cellDB ) outputDir = <str> binWidth = 0.020 clusNum = 12 numTetrodes = 8 qualityList = [ 1 , 6 ] minZVal = 0.0 maxISIviolation = 0.02 minPValue = 0.05 inStriatumRangeCheck = True movementModulationWindow = <str> modIndFileName = <str> + <str> + movementModulationWindow subject = allcells . cellDB [ 0 ] . animalName behavSession = <str> processedDir = os . path . join ( settings . EPHYS_PATH , subject + <str> ) maxZFilename = os . path . join ( processedDir , <str> ) minPerfFilename = os . path . join ( processedDir , <str> ) minTrialFilename = os . path . join ( processedDir , <str> ) ISIFilename = os . path . join ( processedDir , <str> ) modIFilename = os . path . join ( processedDir , <str> ) nameOfmovementmodSFile = <str> + <str> + movementModulationWindow + <str> + subject + <str> nameOfmovementmodIFile = <str> + <str> + movementModulationWindow + <str> + subject + <str> movementmodIFilename = os . path . join ( processedDir , nameOfmovementmodIFile ) movementmodSFilename = os . path . join ( processedDir , nameOfmovementmodSFile ) class nestedDict ( dict ) :      def __getitem__ ( self , item ) :          try :              return super ( nestedDict , self ) . __getitem__ ( item )  except KeyError :              value = self [ item ] = type ( self ) ( ) return value    maxZFile = open ( maxZFilename , <str> ) minPerfFile = open ( minPerfFilename , <str> ) minTrialFile = open ( minTrialFilename , <str> ) ISIFile = open ( ISIFilename , <str> ) modIFile = open ( modIFilename , <str> ) movementmodIFile = open ( movementmodIFilename , <str> ) movementmodSFile = open ( movementmodSFilename , <str> ) minPerfFile . readline ( ) minPerfList = minPerfFile . read ( ) . split ( ) minTrialFile . readline ( ) minTrialFile . readline ( ) minTrialDict = { } for lineCount , line in enumerate ( minTrialFile ) :      minTrialStr = line . split ( <str> ) trialFreq = minTrialStr [ 1 ] . split ( ) minTrialDict . update ( { minTrialStr [ 0 ] [ 1 : ] : trialFreq } )  maxZDict = nestedDict ( ) behavName = <str> for line in maxZFile :      behavLine = line . split ( <str> ) freqLine = line . split ( ) if ( behavLine [ 0 ] == <str> ) :          behavName = behavLine [ 1 ] [ : - 1 ]  else :          maxZDict [ behavName ] [ freqLine [ 0 ] ] = freqLine [ 1 ] . split ( <str> ) [ 0 : - 1 ]   ISIDict = { } behavName = <str> for line in ISIFile :      if ( line . split ( <str> ) [ 0 ] == <str> ) :          behavName = line . split ( <str> ) [ 1 ] [ : - 1 ]  else :          ISIDict [ behavName ] = [ float ( x ) for x in line . split ( <str> ) [ 0 : - 1 ] ]   movementmodIDict = { } movementmodSigDict = { } behavName = <str> for line in movementmodIFile :      if ( line . split ( <str> ) [ 0 ] == <str> ) :          behavName = line . split ( <str> ) [ 1 ] [ : - 1 ]  else :          movementmodIDict [ behavName ] = [ float ( x ) for x in line . split ( <str> ) [ 0 : - 1 ] ]   for line in movementmodSFile :      if ( line . split ( <str> ) [ 0 ] == <str> ) :          behavName = line . split ( <str> ) [ 1 ] [ : - 1 ]  else :          movementmodSigDict [ behavName ] = [ float ( x ) for x in line . split ( <str> ) [ 0 : - 1 ] ]   ISIFile . close ( ) maxZFile . close ( ) minPerfFile . close ( ) minTrialFile . close ( ) modIFile . close ( ) movementmodIFile . close ( ) movementmodSFile . close ( ) modIndexArray = [ ] for cellID in range ( 0 , numOfCells ) :      oneCell = allcells . cellDB [ cellID ] subject = oneCell . animalName behavSession = oneCell . behavSession ephysSession = oneCell . ephysSession tetrode = oneCell . tetrode cluster = oneCell . cluster depth = oneCell . depth clusterQuality = oneCell . quality [ cluster - 1 ] if clusterQuality not in qualityList :          continue  elif behavSession not in minPerfList :          print <str> continue  elif behavSession not in minTrialDict :          print <str> continue  elif behavSession not in movementmodIDict :          print <str> , behavSession continue  elif behavSession not in movementmodSigDict :          print <str> , behavSession continue  elif behavSession not in ISIDict :          print <str> continue  clusterNumber = ( tetrode - 1 ) * clusNum + ( cluster - 1 ) if ( len ( minTrialDict [ behavSession ] ) >= 1 ) :          if inStriatumRangeCheck :              if ( ( ISIDict [ behavSession ] [ clusterNumber ] <= maxISIviolation ) and ( animalTetDepths . tetDB . isInStriatum ( subject , tetrode , depth ) ) ) :                  modIndexArray . append ( [ movementmodIDict [ behavSession ] [ clusterNumber ] , movementmodSigDict [ behavSession ] [ clusterNumber ] ] ) print <str> , behavSession , <str> , tetrode , <str> , cluster   else :              if ( ( ISIDict [ behavSession ] [ clusterNumber ] <= maxISIviolation ) ) :                  modIndexArray . append ( [ movementmodIDict [ behavSession ] [ clusterNumber ] , movementmodSigDict [ behavSession ] [ clusterNumber ] ] ) print <str> , behavSession , <str> , tetrode , <str> , cluster     modIndBinVec = np . arange ( - 1 , 1 , binWidth ) binModIndexArraySig = np . empty ( len ( modIndBinVec ) ) binModIndexArrayNonSig = np . empty ( len ( modIndBinVec ) ) maxMI = 0 totalSig = 0 for binInd in range ( len ( modIndBinVec ) - 1 ) :      binTotalSig = 0 binTotalNonSig = 0 for modIndSig in modIndexArray :          if ( ( modIndSig [ 0 ] >= modIndBinVec [ binInd ] ) and ( modIndSig [ 0 ] < modIndBinVec [ binInd + 1 ] ) and ( modIndSig [ 1 ] <= minPValue ) ) :              binTotalSig += 1 totalSig += 1  elif ( ( modIndSig [ 0 ] >= modIndBinVec [ binInd ] ) and ( modIndSig [ 0 ] < modIndBinVec [ binInd + 1 ] ) ) :              binTotalNonSig += 1  maxMI = max ( maxMI , abs ( modIndSig [ 0 ] ) )  binModIndexArraySig [ binInd ] = binTotalSig binModIndexArrayNonSig [ binInd ] = binTotalNonSig  binModIndexArraySig [ - 1 ] = 0 binModIndexArrayNonSig [ - 1 ] = 0 print <str> , len ( modIndexArray ) print <str> , totalSig plt . clf ( ) plt . bar ( modIndBinVec , binModIndexArraySig , width = binWidth , color = <str> ) plt . bar ( modIndBinVec , binModIndexArrayNonSig , width = binWidth , color = <str> , bottom = binModIndexArraySig ) plt . xlim ( ( - ( maxMI + binWidth ) , maxMI + binWidth ) ) plt . xlabel ( <str> ) plt . ylabel ( <str> ) plt . figtext ( .2 , .87 , <str> % ( len ( modIndexArray ) ) , fontsize = 15 ) plt . figtext ( .2 , .91 , <str> % totalSig , fontsize = 15 ) plt . gcf ( ) . set_size_inches ( ( 8.5 , 11 ) ) figformat = <str> filename = <str> % ( modIndFileName , subject , figformat ) fulloutputDir = outputDir + subject + <str> fullFileName = os . path . join ( fulloutputDir , filename ) directory = os . path . dirname ( fulloutputDir ) if not os . path . exists ( directory ) :      os . makedirs ( directory )  print <str> % fullFileName plt . gcf ( ) . savefig ( fullFileName , format = figformat )  