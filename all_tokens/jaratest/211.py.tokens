from jaratoolbox import loadbehavior from jaratoolbox import settings from jaratoolbox import ephyscore import os import numpy as np from jaratoolbox import loadopenephys from jaratoolbox import spikesanalysis from jaratoolbox import extraplots import matplotlib . pyplot as plt import sys import importlib mouseName = str ( sys . argv [ 1 ] ) allcellsFileName = <str> + mouseName + <str> sys . path . append ( settings . ALLCELLS_PATH ) allcells = importlib . import_module ( allcellsFileName ) SAMPLING_RATE = 30000.0 soundTriggerChannel = 0 binWidth = 0.020 Frequency = 1 countTimeRange = [ 0 , 0.1 ] clusNum = 12 numTetrodes = 8 qualityList = [ 1 , 6 ] minZVal = 3.0 maxISIviolation = 0.02 minFileName = <str> minPValue = 0.05 stimulusRange = [ 0.0 , 0.1 ] timeRange = [ - 0.2 , 0.8 ] ephysRootDir = settings . EPHYS_PATH outputDir = <str> experimenter = <str> paradigm = <str> numOfCells = len ( allcells . cellDB ) subject = allcells . cellDB [ 0 ] . animalName behavSession = <str> processedDir = os . path . join ( settings . EPHYS_PATH , subject + <str> ) maxZFilename = os . path . join ( processedDir , <str> ) minPerfFilename = os . path . join ( processedDir , <str> ) minTrialFilename = os . path . join ( processedDir , <str> ) ISIFilename = os . path . join ( processedDir , <str> ) class nestedDict ( dict ) :      def __getitem__ ( self , item ) :          try :              return super ( nestedDict , self ) . __getitem__ ( item )  except KeyError :              value = self [ item ] = type ( self ) ( ) return value    maxZFile = open ( maxZFilename , <str> ) minPerfFile = open ( minPerfFilename , <str> ) minTrialFile = open ( minTrialFilename , <str> ) ISIFile = open ( ISIFilename , <str> ) minPerfFile . readline ( ) minPerfList = minPerfFile . read ( ) . split ( ) minTrialFile . readline ( ) minTrialFile . readline ( ) minTrialDict = { } for lineCount , line in enumerate ( minTrialFile ) :      minTrialStr = line . split ( <str> ) trialFreq = minTrialStr [ 1 ] . split ( ) minTrialDict . update ( { minTrialStr [ 0 ] [ 1 : ] : trialFreq } )  maxZDict = nestedDict ( ) behavName = <str> for line in maxZFile :      behavLine = line . split ( <str> ) freqLine = line . split ( ) if ( behavLine [ 0 ] == <str> ) :          behavName = behavLine [ 1 ] [ : - 1 ]  else :          maxZDict [ behavName ] [ freqLine [ 0 ] ] = freqLine [ 1 ] . split ( <str> ) [ 0 : - 1 ]   ISIDict = { } ephysName = <str> for line in ISIFile :      ephysLine = line . split ( <str> ) tetrodeLine = line . split ( ) tetrodeName = tetrodeLine [ 0 ] . split ( <str> ) if ( ephysLine [ 0 ] == <str> ) :          ephysName = ephysLine [ 1 ] [ : - 1 ] ISIDict . update ( { ephysName : np . full ( ( numTetrodes , clusNum ) , 1.0 ) } )  else :          ISIDict [ ephysName ] [ int ( tetrodeName [ 1 ] ) ] = tetrodeLine [ 1 : ]   ISIFile . close ( ) maxZFile . close ( ) minPerfFile . close ( ) minTrialFile . close ( ) modIndexArray = [ ] maxMI = 0.0 for cellID in range ( 0 , numOfCells ) :      oneCell = allcells . cellDB [ cellID ] subject = oneCell . animalName behavSession = oneCell . behavSession ephysSession = oneCell . ephysSession ephysRoot = os . path . join ( ephysRootDir , subject ) tetrode = oneCell . tetrode cluster = oneCell . cluster clusterQuality = oneCell . quality [ cluster - 1 ] if clusterQuality not in qualityList :          continue  elif behavSession not in minPerfList :          continue  elif behavSession not in minTrialDict :          continue  elif behavSession not in maxZDict :          continue  elif ephysSession not in ISIDict :          continue  clusterNumber = ( tetrode - 1 ) * clusNum + ( cluster - 1 ) midFreq = minTrialDict [ behavSession ] [ 0 ] if ( ( abs ( float ( maxZDict [ behavSession ] [ midFreq ] [ clusterNumber ] ) ) < minZVal ) | ( ISIDict [ ephysSession ] [ tetrode - 1 ] [ cluster - 1 ] > maxISIviolation ) ) :          continue  print <str> , behavSession , <str> , oneCell . tetrode , <str> , cluster behaviorFilename = loadbehavior . path_to_behavior_data ( subject , experimenter , paradigm , behavSession ) bdata = loadbehavior . BehaviorData ( behaviorFilename ) ephysDir = os . path . join ( ephysRoot , ephysSession ) eventFilename = os . path . join ( ephysDir , <str> ) events = loadopenephys . Events ( eventFilename ) eventTimes = np . array ( events . timestamps ) / SAMPLING_RATE soundOnsetEvents = ( events . eventID == 1 ) & ( events . eventChannel == soundTriggerChannel ) spkData = ephyscore . CellData ( oneCell ) spkTimeStamps = spkData . spikes . timestamps eventOnsetTimes = eventTimes [ soundOnsetEvents ] rightward = bdata [ <str> ] == bdata . labels [ <str> ] [ <str> ] leftward = bdata [ <str> ] == bdata . labels [ <str> ] [ <str> ] invalid = bdata [ <str> ] == bdata . labels [ <str> ] [ <str> ] correct = bdata [ <str> ] == bdata . labels [ <str> ] [ <str> ] correctRightward = rightward & correct correctLeftward = leftward & correct possibleFreq = np . unique ( bdata [ <str> ] ) oneFreq = bdata [ <str> ] == possibleFreq [ Frequency ] trialsToUseRight = correctRightward & oneFreq trialsToUseLeft = correctLeftward & oneFreq trialsEachCond = [ trialsToUseRight , trialsToUseLeft ] ( spikeTimesFromEventOnset , trialIndexForEachSpike , indexLimitsEachTrial ) = spikesanalysis . eventlocked_spiketimes ( spkTimeStamps , eventOnsetTimes , timeRange ) spikeCountMat = spikesanalysis . spiketimes_to_spikecounts ( spikeTimesFromEventOnset , indexLimitsEachTrial , countTimeRange ) spikeCountEachTrial = spikeCountMat . flatten ( ) spikeAvgRight = sum ( spikeCountEachTrial [ trialsToUseRight ] ) / float ( sum ( trialsToUseRight ) ) spikeAvgLeft = sum ( spikeCountEachTrial [ trialsToUseLeft ] ) / float ( sum ( trialsToUseLeft ) ) if ( ( spikeAvgRight + spikeAvgLeft ) == 0 ) :          modIndexArray . append ( ( 0.0 , 1.0 ) )  else :          mod_sig = spikesanalysis . evaluate_modulation ( spikeTimesFromEventOnset , indexLimitsEachTrial , stimulusRange , trialsEachCond ) currentMI = ( spikeAvgRight - spikeAvgLeft ) / ( spikeAvgRight + spikeAvgLeft ) modIndexArray . append ( ( currentMI , mod_sig [ 1 ] ) ) maxMI = max ( maxMI , abs ( currentMI ) )   modIndBinVec = np . arange ( - 1 , 1 , binWidth ) binModIndexArraySig = np . empty ( len ( modIndBinVec ) ) binModIndexArrayNonSig = np . empty ( len ( modIndBinVec ) ) for binInd in range ( len ( modIndBinVec ) - 1 ) :      binTotalSig = 0 binTotalNonSig = 0 for modIndSig in modIndexArray :          if ( ( modIndSig [ 0 ] >= modIndBinVec [ binInd ] ) & ( modIndSig [ 0 ] < modIndBinVec [ binInd + 1 ] ) & ( modIndSig [ 1 ] <= minPValue ) ) :              binTotalSig += 1  elif ( ( modIndSig [ 0 ] >= modIndBinVec [ binInd ] ) & ( modIndSig [ 0 ] < modIndBinVec [ binInd + 1 ] ) ) :              binTotalNonSig += 1   binModIndexArraySig [ binInd ] = binTotalSig binModIndexArrayNonSig [ binInd ] = binTotalNonSig  binModIndexArraySig [ - 1 ] = 0 binModIndexArrayNonSig [ - 1 ] = 0 print <str> , len ( modIndexArray ) plt . clf ( ) plt . bar ( modIndBinVec , binModIndexArraySig , width = binWidth , color = <str> ) plt . bar ( modIndBinVec , binModIndexArrayNonSig , width = binWidth , color = <str> , bottom = binModIndexArraySig ) plt . xlim ( ( - ( maxMI + binWidth ) , maxMI + binWidth ) ) plt . xlabel ( <str> ) plt . ylabel ( <str> ) plt . gcf ( ) . set_size_inches ( ( 8.5 , 11 ) ) figformat = <str> filename = <str> % ( subject , figformat ) fulloutputDir = outputDir + subject + <str> fullFileName = os . path . join ( fulloutputDir , filename ) directory = os . path . dirname ( fulloutputDir ) if not os . path . exists ( directory ) :      os . makedirs ( directory )  print <str> % fullFileName plt . show ( )  