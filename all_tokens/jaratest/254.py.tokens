from jaratoolbox import loadbehavior from jaratoolbox import settings from jaratoolbox import ephyscore import os import numpy as np from jaratoolbox import loadopenephys from jaratoolbox import spikesanalysis from jaratoolbox import extraplots import matplotlib . pyplot as plt import sys import importlib mouseName = str ( sys . argv [ 1 ] ) allcellsFileName = <str> + mouseName sys . path . append ( settings . ALLCELLS_PATH ) allcells = importlib . import_module ( allcellsFileName ) SAMPLING_RATE = 30000.0 soundTriggerChannel = 0 Frequency = 1 countTimeRange = [ 0 , 0.1 ] clusNum = 12 numTetrodes = 8 stimulusRange = [ 0.0 , 0.1 ] timeRange = [ - 0.2 , 0.8 ] ephysRootDir = settings . EPHYS_PATH outputDir = <str> experimenter = <str> paradigm = <str> numOfCells = len ( allcells . cellDB ) subject = allcells . cellDB [ 0 ] . animalName behavSession = <str> nameOfFile = <str> finalOutputDir = outputDir + <str> + subject + <str> modIList = [ ] try :      modI_file = open ( <str> % ( finalOutputDir , nameOfFile ) , <str> ) behavName = <str> for line in modI_file :          behavLine = line . split ( <str> ) if ( behavLine [ 0 ] == <str> ) :              behavName = behavLine [ 1 ] [ : - 1 ] modIList . append ( behavName )    except :      modI_file = open ( <str> % ( finalOutputDir , nameOfFile ) , <str> )  badSessionList = [ ] behavSession = <str> maxMI = 0.0 modIDict = { } modSigDict = { } modDirectionScoreDict = { } numBlocksDict = { } print <str> for cellID in range ( 0 , numOfCells ) :      oneCell = allcells . cellDB [ cellID ] if ( oneCell . behavSession in modIList ) :          continue  if ( behavSession != oneCell . behavSession ) :          subject = oneCell . animalName behavSession = oneCell . behavSession ephysSession = oneCell . ephysSession ephysRoot = os . path . join ( ephysRootDir , subject ) print behavSession modIDict [ behavSession ] = np . zeros ( ( clusNum * numTetrodes ) , dtype = float ) modSigDict [ behavSession ] = np . ones ( ( clusNum * numTetrodes ) , dtype = float ) modDirectionScoreDict [ behavSession ] = np . zeros ( ( clusNum * numTetrodes ) , dtype = float ) behaviorFilename = loadbehavior . path_to_behavior_data ( subject , experimenter , paradigm , behavSession ) bdata = loadbehavior . BehaviorData ( behaviorFilename ) ephysDir = os . path . join ( ephysRoot , ephysSession ) eventFilename = os . path . join ( ephysDir , <str> ) events = loadopenephys . Events ( eventFilename ) eventTimes = np . array ( events . timestamps ) / SAMPLING_RATE soundOnsetEvents = ( events . eventID == 1 ) & ( events . eventChannel == soundTriggerChannel ) eventOnsetTimes = eventTimes [ soundOnsetEvents ] rightward = bdata [ <str> ] == bdata . labels [ <str> ] [ <str> ] leftward = bdata [ <str> ] == bdata . labels [ <str> ] [ <str> ] valid = ( bdata [ <str> ] == bdata . labels [ <str> ] [ <str> ] ) | ( bdata [ <str> ] == bdata . labels [ <str> ] [ <str> ] ) correct = bdata [ <str> ] == bdata . labels [ <str> ] [ <str> ] correctRightward = rightward & correct correctLeftward = leftward & correct possibleFreq = np . unique ( bdata [ <str> ] ) oneFreq = bdata [ <str> ] == possibleFreq [ Frequency ] firstTrialsExclude = 20 highBlock = bdata [ <str> ] == bdata . labels [ <str> ] [ <str> ] numTrials = len ( highBlock ) currentBlock = highBlock [ 0 ] firstTrialNum = 0 trialsToInclude = np . zeros ( ( numTrials ) , dtype = bool ) blockNumber = np . zeros ( ( numTrials ) ) curBlockNum = 0 totalBlocks = 1 for trialNum , block in enumerate ( highBlock ) :              if ( block != currentBlock ) :                  firstTrialNum = 0 currentBlock = block curBlockNum += 1 totalBlocks += 1  blockNumber [ trialNum ] = curBlockNum if ( valid [ trialNum ] & ( firstTrialNum >= firstTrialsExclude ) ) :                  trialsToInclude [ trialNum ] = True  elif ( valid [ trialNum ] ) :                  firstTrialNum += 1   minLastBlockSize = 50 lastBlock = highBlock [ - 1 ] lastBlockCount = 0 lastTrialNum = - 1 while ( highBlock [ lastTrialNum ] == lastBlock ) :              lastTrialNum -= 1 lastBlockCount -= 1  if ( sum ( valid [ lastBlockCount : ] ) < minLastBlockSize ) :              trialsToInclude [ lastTrialNum : ] = False totalBlocks -= 1  correctMiddle = correct & oneFreq trialsToUse = trialsToInclude & correctMiddle trialsToUseRight = correctRightward & trialsToUse trialsToUseLeft = correctLeftward & trialsToUse trialsEachCond = [ trialsToUseRight , trialsToUseLeft ] numBlocksDict [ behavSession ] = totalBlocks  tetrode = oneCell . tetrode cluster = oneCell . cluster clusterNumber = ( tetrode - 1 ) * clusNum + ( cluster - 1 ) spkData = ephyscore . CellData ( oneCell ) spkTimeStamps = spkData . spikes . timestamps ( spikeTimesFromEventOnset , trialIndexForEachSpike , indexLimitsEachTrial ) = spikesanalysis . eventlocked_spiketimes ( spkTimeStamps , eventOnsetTimes , timeRange ) spikeCountMat = spikesanalysis . spiketimes_to_spikecounts ( spikeTimesFromEventOnset , indexLimitsEachTrial , countTimeRange ) spikeCountEachTrial = spikeCountMat . flatten ( ) curModDirection = <str> modDirectionScore = 0 curBlockModI = sum ( spikeCountEachTrial [ ( blockNumber == 0 ) & trialsToUse ] ) / float ( sum ( ( blockNumber == 0 ) & trialsToUse ) ) for blockNum in range ( 0 , totalBlocks ) :          if ( sum ( ( blockNumber == blockNum ) & trialsToUse ) == 0 ) :              continue  blockModI = sum ( spikeCountEachTrial [ ( blockNumber == blockNum ) & trialsToUse ] ) / float ( sum ( ( blockNumber == blockNum ) & trialsToUse ) ) if ( curBlockModI > blockModI ) :              if ( curModDirection == <str> ) :                  modDirectionScore += 1  curModDirection = <str>  elif ( curBlockModI < blockModI ) :              if ( curModDirection == <str> ) :                  modDirectionScore += 1  curModDirection = <str>  curBlockModI = blockModI  spikeAvgRight = sum ( spikeCountEachTrial [ trialsToUseRight ] ) / float ( sum ( trialsToUseRight ) ) spikeAvgLeft = sum ( spikeCountEachTrial [ trialsToUseLeft ] ) / float ( sum ( trialsToUseLeft ) ) if ( ( spikeAvgRight + spikeAvgLeft ) == 0 ) :          modIDict [ behavSession ] [ clusterNumber ] = 0.0 modSigDict [ behavSession ] [ clusterNumber ] = 1.0  else :          mod_sig = spikesanalysis . evaluate_modulation ( spikeTimesFromEventOnset , indexLimitsEachTrial , stimulusRange , trialsEachCond ) currentMI = ( spikeAvgRight - spikeAvgLeft ) / ( spikeAvgRight + spikeAvgLeft ) modIDict [ behavSession ] [ clusterNumber ] = currentMI modSigDict [ behavSession ] [ clusterNumber ] = mod_sig [ 1 ]  modDirectionScoreDict [ behavSession ] [ clusterNumber ] = modDirectionScore  bSessionList = [ ] for bSession in modIDict :      if ( bSession not in badSessionList ) :          bSessionList . append ( bSession )   bSessionList . sort ( ) for bSession in bSessionList :      modI_file . write ( <str> % bSession ) modI_file . write ( <str> ) for modIInd in modIDict [ bSession ] :          modI_file . write ( <str> % modIInd )  modI_file . write ( <str> ) modI_file . write ( <str> ) for modSigInd in modSigDict [ bSession ] :          modI_file . write ( <str> % modSigInd )  modI_file . write ( <str> ) modI_file . write ( <str> ) for modDirectInd in modDirectionScoreDict [ bSession ] :          modI_file . write ( <str> % modDirectInd )  modI_file . write ( <str> )  modI_file . close ( ) print <str> for badSes in badSessionList :      print badSes  print <str>  