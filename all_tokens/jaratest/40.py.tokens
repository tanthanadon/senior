import os , sys import argparse import pdb import numpy as np from numpy import inf from scipy import optimize from scipy import stats import pandas as pd import matplotlib . pyplot as plt import matplotlib . patches as patches import matplotlib . gridspec as gridspec from jaratoolbox import celldatabase from jaratoolbox import extraplots from jaratoolbox import spikesanalysis from jaratoolbox import spikesorting from jaratoolbox import behavioranalysis from jaratoolbox import loadbehavior from jaratoolbox import loadopenephys from jaratoolbox import ephyscore reload ( loadopenephys ) from jaratoolbox import settings parser = argparse . ArgumentParser ( description = <str> ) parser . add_argument ( <str> , metavar = <str> , help = <str> ) parser . add_argument ( <str> , action = <str> , help = <str> ) parser . add_argument ( <str> , type = int , default = None , help = <str> ) parser . add_argument ( <str> , action = <str> , help = <str> ) args = parser . parse_args ( ) def noise_raster ( ephysData , gs ) :      plt . subplot ( gs [ 0 , 1 ] ) eventOnsetTimes = ephysData [ <str> ] [ <str> ] spikeTimeStamps = ephysData [ <str> ] timeRange = [ - 0.3 , 0.6 ] baseTimeRange = [ - 0.15 , - 0.05 ] trialsEachCond = [ ] spikeTimesFromEventOnset , trialIndexForEachSpike , indexLimitsEachTrial = spikesanalysis . eventlocked_spiketimes ( spikeTimeStamps , eventOnsetTimes , timeRange ) baseSpikeMat = spikesanalysis . spiketimes_to_spikecounts ( spikeTimesFromEventOnset , indexLimitsEachTrial , baseTimeRange ) base_avg = np . mean ( baseSpikeMat ) / ( baseTimeRange [ 1 ] - baseTimeRange [ 0 ] ) base_sem = stats . sem ( baseSpikeMat ) / ( baseTimeRange [ 1 ] - baseTimeRange [ 0 ] ) pRaster , hcond , zline = extraplots . raster_plot ( spikeTimesFromEventOnset , indexLimitsEachTrial , timeRange , trialsEachCond = trialsEachCond ) title = <str> . format ( round ( base_avg , 2 ) , round ( base_sem , 2 ) ) xlabel = <str> ylabel = <str> plt . title ( title , fontsize = <str> ) plt . xlabel ( xlabel ) plt . ylabel ( ylabel )  def tuning_raster ( bdata , ephysData , gs ) :      plt . subplot ( gs [ 1 , 1 ] ) freqEachTrial = bdata [ <str> ] eventOnsetTimes = ephysData [ <str> ] [ <str> ] spikeTimeStamps = ephysData [ <str> ] timeRange = [ - 0.3 , 0.6 ] baseTimeRange = [ - 0.15 , - 0.05 ] possiblefreqs = np . unique ( freqEachTrial ) freqLabels = [ round ( x / 1000 , 1 ) for x in possiblefreqs ] trialsEachCond = behavioranalysis . find_trials_each_type ( freqEachTrial , possiblefreqs ) spikeTimesFromEventOnset , trialIndexForEachSpike , indexLimitsEachTrial = spikesanalysis . eventlocked_spiketimes ( spikeTimeStamps , eventOnsetTimes , timeRange ) baseSpikeMat = spikesanalysis . spiketimes_to_spikecounts ( spikeTimesFromEventOnset , indexLimitsEachTrial , baseTimeRange ) base_avg = np . mean ( baseSpikeMat ) / ( baseTimeRange [ 1 ] - baseTimeRange [ 0 ] ) base_sem = stats . sem ( baseSpikeMat ) / ( baseTimeRange [ 1 ] - baseTimeRange [ 0 ] ) title = <str> . format ( round ( base_avg , 2 ) , round ( base_sem , 2 ) ) pRaster , hcond , zline = extraplots . raster_plot ( spikeTimesFromEventOnset , indexLimitsEachTrial , timeRange , trialsEachCond = trialsEachCond , labels = freqLabels ) xlabel = <str> ylabel = <str> plt . title ( title , fontsize = <str> ) plt . xlabel ( xlabel ) plt . ylabel ( ylabel )  def tuning_curve ( bdata , ephysData , gs ) :      plt . subplot ( gs [ 2 , 1 ] ) freqEachTrial = bdata [ <str> ] intEachTrial = bdata [ <str> ] eventOnsetTimes = ephysData [ <str> ] [ <str> ] spikeTimeStamps = ephysData [ <str> ] timeRange = [ - 0.3 , 0.6 ] soundTimeRange = [ 0.0 , 0.1 ] possiblefreqs = np . unique ( freqEachTrial ) freqLabels = [ round ( x / 1000 , 1 ) for x in possiblefreqs ] possibleInts = np . unique ( intEachTrial ) intTrialsEachCond = behavioranalysis . find_trials_each_combination ( freqEachTrial , possiblefreqs , intEachTrial , possibleInts ) spikeTimesFromEventOnset , trialIndexForEachSpike , indexLimitsEachTrial = spikesanalysis . eventlocked_spiketimes ( spikeTimeStamps , eventOnsetTimes , timeRange ) for intInd , inten in enumerate ( possibleInts ) :          line = <str> if intInd == 0 and len ( possibleInts ) > 1 :              line = <str>  curveName = str ( inten ) + <str> trialsEachCond = intTrialsEachCond [ : , : , intInd ] spikeMat = spikesanalysis . spiketimes_to_spikecounts ( spikeTimesFromEventOnset , indexLimitsEachTrial , soundTimeRange ) freq_avgs = np . empty ( len ( possiblefreqs ) ) freq_sems = np . empty ( len ( possiblefreqs ) ) for freqInd , freq in enumerate ( possiblefreqs ) :              freq_spikecounts = spikeMat [ trialsEachCond [ : , freqInd ] == True ] freq_avg = np . mean ( freq_spikecounts ) / ( soundTimeRange [ 1 ] - soundTimeRange [ 0 ] ) freq_avgs [ freqInd ] = freq_avg freq_sem = stats . sem ( freq_spikecounts ) / ( soundTimeRange [ 1 ] - soundTimeRange [ 0 ] ) freq_sems [ freqInd ] = freq_sem  xpoints = [ x for x in range ( 0 , len ( possiblefreqs ) ) ] xpointticks = [ x for x in range ( 1 , len ( possiblefreqs ) , 2 ) ] freqticks = [ freqLabels [ x ] for x in range ( 1 , len ( freqLabels ) , 2 ) ] plt . plot ( xpoints , freq_avgs , linestyle = line , color = <str> , marker = <str> , label = curveName ) plt . xticks ( xpointticks , freqticks ) plt . hold ( True )  xlabel = <str> ylabel = <str> title = <str> . format ( soundTimeRange ) plt . xlabel ( xlabel ) plt . ylabel ( ylabel ) plt . title ( title , fontsize = <str> ) plt . legend ( fontsize = <str> , loc = <str> , frameon = False , framealpha = 100 , markerscale = 0.5 ) plt . hold ( False )  def laser_tuning_raster ( cell , gs ) :      laserSessionInds = cell . get_session_inds ( <str> ) for count , sessionInd in enumerate ( laserSessionInds ) :          bdata = cell . load_behavior_by_index ( sessionInd ) ephysData = cell . load_ephys_by_index ( sessionInd ) freqEachTrial = bdata [ <str> ] laserEachTrial = bdata [ <str> ] intEachTrial = bdata [ <str> ] eventOnsetTimes = ephysData [ <str> ] [ <str> ] spikeTimeStamps = ephysData [ <str> ] timeRange = [ - 0.3 , 0.6 ] baseTimeRange = [ - 0.15 , - 0.05 ] possiblefreqs = np . unique ( freqEachTrial ) freqLabels = [ round ( x / 1000 , 1 ) for x in possiblefreqs ] possiblelaser = np . unique ( laserEachTrial ) possibleInts = np . unique ( intEachTrial ) laserOnsetTimes = ephysData [ <str> ] [ <str> ] laserOffsetTimes = ephysData [ <str> ] [ <str> ] laserDuration = laserOffsetTimes - laserOnsetTimes meanLaser = round ( laserDuration . mean ( ) , 2 ) laserEventOnsetTimes = eventOnsetTimes [ laserEachTrial == True ] if len ( laserOnsetTimes ) > len ( laserEventOnsetTimes ) :              laserStartTimes = laserOnsetTimes [ : - 1 ] - laserEventOnsetTimes  elif len ( laserEventOnsetTimes ) > len ( laserOnsetTimes ) :              laserStartTimes = laserOnsetTimes - laserEventOnsetTimes [ : - 1 ]  else :              laserStartTimes = laserOnsetTimes - laserEventOnsetTimes  laserStart = round ( laserStartTimes . mean ( ) , 2 ) laserTrialsEachCond = behavioranalysis . find_trials_each_combination ( freqEachTrial , possiblefreqs , laserEachTrial , possiblelaser ) intTrialsEachCond = behavioranalysis . find_trials_each_combination ( freqEachTrial , possiblefreqs , intEachTrial , possibleInts ) spikeTimesFromEventOnset , trialIndexForEachSpike , indexLimitsEachTrial = spikesanalysis . eventlocked_spiketimes ( spikeTimeStamps , eventOnsetTimes , timeRange ) baseSpikeMat = spikesanalysis . spiketimes_to_spikecounts ( spikeTimesFromEventOnset , indexLimitsEachTrial , baseTimeRange ) for intInd , inten in enumerate ( possibleInts ) :              for indLaser in possiblelaser :                  ax = plt . subplot ( gs [ indLaser , intInd + ( count * 2 ) + 1 ] ) if indLaser == 0 :                      title = <str> + str ( inten ) + <str>  else :                      title = <str> + str ( inten ) + <str>  trialsEachCond = laserTrialsEachCond [ : , : , indLaser ] & intTrialsEachCond [ : , : , intInd ] trialsThisIntLaser = np . all ( [ bdata [ <str> ] == indLaser , bdata [ <str> ] == inten ] , axis = 0 ) baseSpikeMatThisCond = baseSpikeMat [ trialsThisIntLaser == True ] base_avg = np . mean ( baseSpikeMatThisCond ) / ( baseTimeRange [ 1 ] - baseTimeRange [ 0 ] ) base_sem = stats . sem ( baseSpikeMatThisCond ) / ( baseTimeRange [ 1 ] - baseTimeRange [ 0 ] ) title += <str> . format ( round ( base_avg , 2 ) , round ( base_sem , 2 ) ) pRaster , hcond , zline = extraplots . raster_plot ( spikeTimesFromEventOnset , indexLimitsEachTrial , timeRange , trialsEachCond = trialsEachCond , labels = freqLabels ) if indLaser == 1 :                      laserbar = patches . Rectangle ( ( laserStart , sum ( sum ( trialsEachCond ) ) + 2 ) , meanLaser , 5 , color = <str> , clip_on = False ) ax . add_patch ( laserbar )  xlabel = <str> ylabel = <str> plt . title ( title , fontsize = <str> ) plt . xlabel ( xlabel ) plt . ylabel ( ylabel )     def laser_tuning_curve ( cell , gs ) :      laserSessionInds = cell . get_session_inds ( <str> ) for count , sessionInd in enumerate ( laserSessionInds ) :          bdata = cell . load_behavior_by_index ( sessionInd ) ephysData = cell . load_ephys_by_index ( sessionInd ) freqEachTrial = bdata [ <str> ] laserEachTrial = bdata [ <str> ] intEachTrial = bdata [ <str> ] eventOnsetTimes = ephysData [ <str> ] [ <str> ] spikeTimeStamps = ephysData [ <str> ] timeRange = [ - 0.3 , 0.6 ] soundTimeRange = [ 0.0 , 0.1 ] possiblefreqs = np . unique ( freqEachTrial ) freqLabels = [ round ( x / 1000 , 1 ) for x in possiblefreqs ] possiblelaser = np . unique ( laserEachTrial ) possibleInts = np . unique ( intEachTrial ) laserTrialsEachCond = behavioranalysis . find_trials_each_combination ( freqEachTrial , possiblefreqs , laserEachTrial , possiblelaser ) intTrialsEachCond = behavioranalysis . find_trials_each_combination ( freqEachTrial , possiblefreqs , intEachTrial , possibleInts ) spikeTimesFromEventOnset , trialIndexForEachSpike , indexLimitsEachTrial = spikesanalysis . eventlocked_spiketimes ( spikeTimeStamps , eventOnsetTimes , timeRange ) for intInd , inten in enumerate ( possibleInts ) :              plt . subplot ( gs [ 2 , intInd + ( count * 2 ) + 1 ] ) line = <str> for indLaser in possiblelaser :                  color = <str> if indLaser == 1 :                      color = <str>  laser = <str> if indLaser == 1 :                      laser = <str>  curveName = laser + str ( inten ) + <str> trialsEachCond = laserTrialsEachCond [ : , : , indLaser ] & intTrialsEachCond [ : , : , intInd ] spikeMat = spikesanalysis . spiketimes_to_spikecounts ( spikeTimesFromEventOnset , indexLimitsEachTrial , soundTimeRange ) freq_avgs = np . empty ( len ( possiblefreqs ) ) freq_sems = np . empty ( len ( possiblefreqs ) ) for freqInd , freq in enumerate ( possiblefreqs ) :                      freq_spikecounts = spikeMat [ trialsEachCond [ : , freqInd ] == True ] freq_avg = np . mean ( freq_spikecounts ) / ( soundTimeRange [ 1 ] - soundTimeRange [ 0 ] ) freq_avgs [ freqInd ] = freq_avg freq_sem = stats . sem ( freq_spikecounts ) / ( soundTimeRange [ 1 ] - soundTimeRange [ 0 ] ) freq_sems [ freqInd ] = freq_sem  xpoints = [ x for x in range ( 0 , len ( possiblefreqs ) ) ] xpointticks = [ x for x in range ( 1 , len ( possiblefreqs ) , 2 ) ] freqticks = [ freqLabels [ x ] for x in range ( 1 , len ( freqLabels ) , 2 ) ] plt . plot ( xpoints , freq_avgs , linestyle = line , color = color , marker = <str> , label = laser ) plt . xticks ( xpointticks , freqticks ) plt . hold ( True )  xlabel = <str> ylabel = <str> title = str ( inten ) + <str> . format ( soundTimeRange ) plt . xlabel ( xlabel ) plt . ylabel ( ylabel ) plt . title ( title , fontsize = <str> ) plt . legend ( fontsize = <str> , loc = <str> , frameon = False , framealpha = 100 , markerscale = 0.5 )  plt . hold ( False )   def am_raster ( bdata , ephysData , gs ) :      plt . subplot ( gs [ 1 , 1 ] ) freqEachTrial = bdata [ <str> ] eventOnsetTimes = ephysData [ <str> ] [ <str> ] spikeTimeStamps = ephysData [ <str> ] timeRange = [ - 0.3 , 0.6 ] baseTimeRange = [ - 0.15 , - 0.05 ] possiblefreqs = np . unique ( freqEachTrial ) freqLabels = [ round ( x / 1000 , 1 ) for x in possiblefreqs ] trialsEachCond = behavioranalysis . find_trials_each_type ( freqEachTrial , possiblefreqs ) spikeTimesFromEventOnset , trialIndexForEachSpike , indexLimitsEachTrial = spikesanalysis . eventlocked_spiketimes ( spikeTimeStamps , eventOnsetTimes , timeRange ) baseSpikeMat = spikesanalysis . spiketimes_to_spikecounts ( spikeTimesFromEventOnset , indexLimitsEachTrial , baseTimeRange ) base_avg = np . mean ( baseSpikeMat ) / ( baseTimeRange [ 1 ] - baseTimeRange [ 0 ] ) base_sem = stats . sem ( baseSpikeMat ) / ( baseTimeRange [ 1 ] - baseTimeRange [ 0 ] ) title = <str> . format ( round ( base_avg , 2 ) , round ( base_sem , 2 ) ) pRaster , hcond , zline = extraplots . raster_plot ( spikeTimesFromEventOnset , indexLimitsEachTrial , timeRange , trialsEachCond = trialsEachCond , labels = freqLabels ) xlabel = <str> ylabel = <str> plt . title ( title , fontsize = <str> ) plt . xlabel ( xlabel ) plt . ylabel ( ylabel )  def gaussian ( x , a , x0 , sigma , y0 ) :      return a * np . exp ( - ( x - x0 ) ** 2 / ( 2 * sigma ** 2 ) ) + y0  def plot_gaussian ( cell , gs ) :      laserTuningSessionInds = cell . get_session_inds ( <str> ) if len ( laserTuningSessionInds ) != 0 :          for sessionInd in laserTuningSessionInds :              bdata = cell . load_behavior_by_index ( sessionInd ) ephysData = cell . load_ephys_by_index ( sessionInd )   else :          return  freqEachTrial = bdata [ <str> ] laserEachTrial = bdata [ <str> ] intEachTrial = bdata [ <str> ] eventOnsetTimes = ephysData [ <str> ] [ <str> ] spikeTimeStamps = ephysData [ <str> ] timeRange = [ - 0.3 , 0.6 ] baseTimeRange = [ 0.0 , 0.1 ] alignmentRange = [ baseTimeRange [ 0 ] , timeRange [ 1 ] ] possiblefreqs = np . unique ( freqEachTrial ) freqLabels = [ round ( x / 1000 , 1 ) for x in possiblefreqs ] possiblelaser = np . unique ( laserEachTrial ) possibleInts = np . unique ( intEachTrial ) popts = [ ] Rsquareds = [ ] allLaserIntenBase = np . array ( [ ] ) allLaserIntenResp = np . empty ( ( len ( possiblelaser ) , len ( possibleInts ) , len ( possiblefreqs ) ) ) allLaserIntenRespMedian = np . empty ( ( len ( possiblelaser ) , len ( possibleInts ) , len ( possiblefreqs ) ) ) for indlaser , laser in enumerate ( possiblelaser ) :          for indinten , inten in enumerate ( possibleInts ) :              spks = np . array ( [ ] ) freqs = np . array ( [ ] ) base = np . array ( [ ] ) for indfreq , freq in enumerate ( possiblefreqs ) :                  selectinds = np . flatnonzero ( ( freqEachTrial == freq ) & ( intEachTrial == inten ) & ( laserEachTrial == laser ) ) selectedOnsetTimes = eventOnsetTimes [ selectinds ] ( spikeTimesFromEventOnset , trialIndexForEachSpike , indexLimitsEachTrial ) = spikesanalysis . eventlocked_spiketimes ( spikeTimeStamps , selectedOnsetTimes , alignmentRange ) nspkBase = spikesanalysis . spiketimes_to_spikecounts ( spikeTimesFromEventOnset , indexLimitsEachTrial , baseTimeRange ) nspkResp = spikesanalysis . spiketimes_to_spikecounts ( spikeTimesFromEventOnset , indexLimitsEachTrial , timeRange ) base = np . concatenate ( [ base , nspkBase . ravel ( ) ] ) spks = np . concatenate ( [ spks , nspkResp . ravel ( ) ] ) freqs = np . concatenate ( [ freqs , np . ones ( len ( nspkResp . ravel ( ) ) ) * freq ] ) allLaserIntenBase = np . concatenate ( [ allLaserIntenBase , nspkBase . ravel ( ) ] ) allLaserIntenResp [ indlaser , indinten , indfreq ] = np . mean ( nspkResp ) allLaserIntenRespMedian [ indlaser , indinten , indfreq ] = np . median ( nspkResp )  try :                  popt , pcov = optimize . curve_fit ( gaussian , np . log2 ( freqs ) , spks , p0 = [ 1 , np . log2 ( possiblefreqs [ 7 ] ) , 1 , allLaserIntenBase . mean ( ) ] , ) popts . append ( popt ) fittedSpks = gaussian ( np . log2 ( freqs ) , * popt ) residuals = spks - fittedSpks SSresidual = np . sum ( residuals ** 2 ) SStotal = np . sum ( ( spks - np . mean ( spks ) ) ** 2 ) Rsquared = 1 - ( SSresidual / SStotal ) Rsquareds . append ( Rsquared )  except RuntimeError :                  print <str> . format ( indIter ) popts . append ( [ np . nan , np . nan , np . nan , np . nan ] ) Rsquareds . append ( np . nan ) continue    print ( popts ) print ( Rsquareds )  def cluster_stats ( cell , gs ) :      ( timestamps , samples , recordingNumber ) = cell . load_all_spikedata ( ) plt . subplot ( gs [ 0 , 0 ] ) if timestamps is not None :          try :              spikesorting . plot_isi_loghist ( timestamps )  except :              print ( <str> )   plt . subplot ( gs [ 1 , 0 ] ) if len ( samples ) > 0 :          spikesorting . plot_waveforms ( samples )  plt . subplot ( gs [ 2 , 0 ] ) if timestamps is not None :          try :              spikesorting . plot_events_in_time ( timestamps )  except :              print ( <str> )    def generate_report ( indRow , dbRow ) :      print ( indRow ) cell = ephyscore . Cell ( dbRow ) noiseSessionInds = cell . get_session_inds ( <str> ) laserTuningSessionInds = cell . get_session_inds ( <str> ) if len ( laserTuningSessionInds ) <= 1 :          return  plt . figure ( figsize = ( 18 , 10 ) , frameon = False ) gs = gridspec . GridSpec ( 3 , 5 ) gs . update ( hspace = 0.4 ) gs . update ( wspace = 0.3 ) if args . gaussian :          plot_gaussian ( cell , gs )  cluster_stats ( cell , gs ) try :          laser_tuning_raster ( cell , gs ) laser_tuning_curve ( cell , gs )  except :          print ( <str> )  print ( <str> . format ( indRow , subject , dbRow [ <str> ] , int ( dbRow [ <str> ] ) , dbRow [ <str> ] , dbRow [ <str> ] ) ) figTitle = <str> . format ( subject , dbRow [ <str> ] , int ( dbRow [ <str> ] ) , dbRow [ <str> ] , dbRow [ <str> ] ) plt . figtext ( 0.5 , 0.95 , figTitle , ha = <str> , fontweight = <str> , fontsize = 14 ) figname = finaldir + <str> . format ( dbRow [ <str> ] , int ( dbRow [ <str> ] ) , dbRow [ <str> ] , dbRow [ <str> ] ) plt . savefig ( figname ) plt . close ( )  subject = args . subject dbpath = <str> . format ( subject ) db = pd . read_hdf ( dbpath , key = <str> ) finaldir = <str> . format ( subject ) goodCells = db . query ( <str> ) goodCells = goodCells . reset_index ( drop = True ) if args . cell :      dbRow = goodCells . loc [ args . cell ] generate_report ( args . cell , dbRow ) sys . exit ( )  if not args . analyze_all :      current = os . listdir ( finaldir ) date_list = [ ] for cell in current :          date = cell . split ( <str> ) [ 0 ] if date not in date_list :              date_list . append ( date )   newCells = goodCells for ind , cell in goodCells . iterrows ( ) :          if cell [ <str> ] in date_list :              newCells = newCells . drop ( [ ind ] )   goodCells = newCells  for indRow , dbRow in goodCells . iterrows ( ) :      generate_report ( indRow , dbRow )  sys . exit ( )  