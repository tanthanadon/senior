import os import numpy as np import matplotlib . pyplot as plt import matplotlib . gridspec as gridspec from jaratoolbox import extrafuncs from jaratoolbox import extraplots from jaratoolbox import loadbehavior from jaratoolbox import settings as settings reload ( settings ) from jaratoolbox import colorpalette EXPERIMENTER = settings . DEFAULT_EXPERIMENTER FREQCOLORS = [ colorpalette . TangoPalette [ <str> ] , colorpalette . TangoPalette [ <str> ] , colorpalette . TangoPalette [ <str> ] ] def find_trials_each_type ( parameter , parameterPossibleValues ) :      nTrials = len ( parameter ) nValues = len ( parameterPossibleValues ) trialsEachType = np . zeros ( ( nTrials , nValues ) , dtype = bool ) for indval , paramValue in enumerate ( parameterPossibleValues ) :          trialsEachType [ : , indval ] = ( parameter == paramValue )  return trialsEachType  def find_trials_each_combination ( parameter1 , parameterPossibleValues1 , parameter2 , parameterPossibleValues2 ) :      if len ( parameter1 ) != len ( parameter2 ) :          raise ValueError ( <str> )  nTrials = len ( parameter1 ) nValues1 = len ( parameterPossibleValues1 ) nValues2 = len ( parameterPossibleValues2 ) trialsEachComb = np . zeros ( ( nTrials , nValues1 , nValues2 ) , dtype = bool ) trialsEachType1 = find_trials_each_type ( parameter1 , parameterPossibleValues1 ) trialsEachType2 = find_trials_each_type ( parameter2 , parameterPossibleValues2 ) for ind2 in range ( nValues2 ) :          trialsEachComb [ : , : , ind2 ] = trialsEachType1 & trialsEachType2 [ : , ind2 ] [ : , np . newaxis ]  return trialsEachComb  def find_trials_each_type_each_block ( psyCurveParameter , psyCurveParameterPossibleValues , currentBlock , currentBlockPossibleValues , validTrials = [ ] ) :      nTrials = len ( psyCurveParameter ) nValues = len ( psyCurveParameterPossibleValues ) nBlockTypes = len ( currentBlockPossibleValues ) if ( not len ( validTrials ) ) :          validTrials = np . ones ( nTrials , dtype = bool )  trialsEachBlock = np . zeros ( ( nTrials , nBlockTypes ) , dtype = bool ) for indb , blockID in enumerate ( currentBlockPossibleValues ) :          trialsEachBlock [ : , indb ] = ( currentBlock == blockID )  trialsEachType = np . zeros ( ( nTrials , nValues , nBlockTypes ) , dtype = bool ) for indval , paramValue in enumerate ( psyCurveParameterPossibleValues ) :          trialsThisValue = ( psyCurveParameter == paramValue ) for indb in range ( nBlockTypes ) :              trialsEachType [ : , indval , indb ] = trialsThisValue & trialsEachBlock [ : , indb ] & validTrials   return trialsEachType  def load_many_sessions ( animalNames , sessions , paradigm = <str> , datesRange = None ) :      if isinstance ( animalNames , str ) :          animalNames = [ animalNames ]  if datesRange :          datesLims = [ parse_isodate ( dateStr ) for dateStr in datesRange ] allDates = [ datesLims [ 0 ] + datetime . timedelta ( n ) for n in range ( ( datesLims [ - 1 ] - datesLims [ 0 ] ) . days + 1 ) ] allSessions = [ oneDate . strftime ( <str> ) for oneDate in allDates ]  else :          allSessions = sessions  nAnimals = len ( animalNames ) if paradigm == <str> :          loadingClass = loadbehavior . FlexCategBehaviorData  else :          raise TypeError ( <str> )  readmode = <str> inds = 0 for inda , animalName in enumerate ( animalNames ) :          for indsa , thisSession in enumerate ( allSessions ) :              try :                  behavFile = loadbehavior . path_to_behavior_data ( animalName , EXPERIMENTER , paradigm , thisSession ) behavData = loadingClass ( behavFile , readmode = readmode )  except IOError :                  print thisSession + <str> continue  if inds == 0 :                  allBehavData = behavData nTrials = len ( behavData [ <str> ] ) allBehavData [ <str> ] = np . zeros ( nTrials , dtype = <str> ) allBehavData [ <str> ] = np . zeros ( nTrials , dtype = <str> )  else :                  for key , val in behavData . iteritems ( ) :                      if not allBehavData . has_key ( key ) :                          allBehavData [ key ] = val  else :                          allBehavData [ key ] = np . concatenate ( ( allBehavData [ key ] , val ) )   nTrials = len ( behavData [ <str> ] ) allBehavData [ <str> ] = np . concatenate ( ( allBehavData [ <str> ] , np . tile ( inds , nTrials ) ) ) allBehavData [ <str> ] = np . concatenate ( ( allBehavData [ <str> ] , np . tile ( inda , nTrials ) ) )  inds += 1   return allBehavData  def behavior_summary ( subjects , sessions , trialslim = [ ] , outputDir = <str> , paradigm = None , soundfreq = None ) :      if isinstance ( subjects , str ) :          subjects = [ subjects ]  if isinstance ( sessions , str ) :          sessions = [ sessions ]  nSessions = len ( sessions ) nAnimals = len ( subjects ) loadingClass = loadbehavior . FlexCategBehaviorData paradigm = <str> gs = gridspec . GridSpec ( nSessions * nAnimals , 3 ) gs . update ( hspace = 0.5 , wspace = 0.4 ) plt . clf ( ) for inds , thisSession in enumerate ( sessions ) :          for inda , animalName in enumerate ( subjects ) :              try :                  behavFile = loadbehavior . path_to_behavior_data ( animalName , EXPERIMENTER , paradigm , thisSession ) behavData = loadingClass ( behavFile , readmode = <str> )  except IOError :                  print thisSession + <str> continue  print <str> % ( animalName , thisSession ) thisAnimalPos = 3 * inda * nSessions thisPlotPos = thisAnimalPos + 3 * inds ax1 = plt . subplot ( gs [ thisPlotPos ] ) if any ( behavData [ <str> ] ) :                  ( pline , pcaps , pbars , pdots ) = plot_frequency_psycurve ( behavData , fontsize = 8 ) plt . setp ( pdots , ms = 6 ) plt . ylabel ( <str> ) nValid = behavData [ <str> ] [ - 1 ] nTrials = len ( behavData [ <str> ] ) if soundfreq is None :                      freqsToUse = [ behavData [ <str> ] [ - 1 ] , behavData [ <str> ] [ - 1 ] ]  titleStr = <str> . format ( behavData . session [ <str> ] , behavData . session [ <str> ] , behavData . session [ <str> ] ) titleStr += <str> . format ( nValid , ( nTrials - nValid ) / float ( nTrials ) ) plt . title ( titleStr , fontweight = <str> , fontsize = 8 , y = 0.95 )  else :                  behavData . find_trials_each_block ( ) if soundfreq is None :                      freqsToUse = [ behavData [ <str> ] [ - 1 ] , behavData [ <str> ] [ - 1 ] ]  plot_summary ( behavData , fontsize = 8 , soundfreq = freqsToUse )  ax2 = plt . subplot ( gs [ thisPlotPos + 1 : thisPlotPos + 3 ] ) plot_dynamics ( behavData , winsize = 40 , fontsize = 8 , soundfreq = freqsToUse ) ax1xlabel = ax1 . get_xlabel ( ) ax2xlabel = ax2 . get_xlabel ( ) ax1 . set_xlabel ( <str> ) ax2 . set_xlabel ( <str> ) if trialslim :                  plt . xlim ( trialslim )  plt . draw ( ) plt . show ( )   plt . setp ( ax1 . get_xticklabels ( ) , visible = True ) plt . setp ( ax2 . get_xticklabels ( ) , visible = True ) ax1 . set_xlabel ( ax1xlabel ) ax2 . set_xlabel ( ax2xlabel ) if len ( outputDir ) :          animalStr = <str> . join ( subjects ) sessionStr = <str> . join ( sessions ) plt . gcf ( ) . set_size_inches ( ( 8.5 , 11 ) ) figformat = <str> filename = <str> % ( animalStr , sessionStr , figformat ) fullFileName = os . path . join ( outputDir , filename ) print <str> % fullFileName plt . gcf ( ) . savefig ( fullFileName , format = figformat )   def plot_summary ( behavData , fontsize = 12 , soundfreq = None ) :      correct = behavData [ <str> ] == behavData . labels [ <str> ] [ <str> ] early = behavData [ <str> ] == behavData . labels [ <str> ] [ <str> ] if soundfreq is None :          possibleFreq = np . unique ( behavData [ <str> ] )  else :          possibleFreq = soundfreq  possibleBlockID = np . unique ( behavData [ <str> ] ) trialsEachType = find_trials_each_type_each_block ( behavData [ <str> ] , possibleFreq , behavData [ <str> ] , possibleBlockID ) validTrialsEachType = trialsEachType & behavData [ <str> ] [ : , np . newaxis , np . newaxis ] . astype ( bool ) correctTrialsEachType = validTrialsEachType & correct [ : , np . newaxis , np . newaxis ] nCorrectEachType = np . sum ( correctTrialsEachType , axis = 0 ) nValidEachType = np . sum ( validTrialsEachType , axis = 0 ) perfEachType = nCorrectEachType / nValidEachType . astype ( float ) itemsToPlot = nValidEachType . flatten ( ) > 0 perfToPlot = perfEachType . flatten ( ) [ itemsToPlot ] freqLabels = np . repeat ( possibleFreq , len ( possibleBlockID ) ) [ itemsToPlot ] nValidCounts = nValidEachType . flatten ( ) [ itemsToPlot ] xPos = [ 0 , 1 , 3 , 4 ] [ : len ( perfToPlot ) ] ax = plt . gca ( ) ax . set_xlim ( [ - 1 , 5 ] ) ax . set_ylim ( [ 0 , 100 ] ) plt . hold ( True ) hline50 = plt . axhline ( 50 , linestyle = <str> , color = <str> , zorder = - 1 ) hline75 = plt . axhline ( 75 , linestyle = <str> , color = <str> , zorder = - 1 ) hbars = plt . bar ( xPos , 100 * perfToPlot , align = <str> , fc = [ 0.8 , 0.8 , 0.8 ] , ec = <str> ) for thispos , thistext in zip ( xPos , nValidCounts ) :          plt . text ( thispos , 10 , str ( thistext ) , ha = <str> , fontsize = fontsize )  ax . set_ylabel ( <str> , fontsize = fontsize ) ax . set_xticks ( xPos ) ax . set_xticklabels ( freqLabels / 1000 ) titleStr = <str> . format ( behavData . session [ <str> ] , behavData . session [ <str> ] , behavData . session [ <str> ] ) titleStr += <str> . format ( sum ( nValidCounts ) , np . mean ( early ) ) ax . set_title ( titleStr , fontweight = <str> , fontsize = fontsize , y = 0.95 ) ax . set_xlabel ( <str> , fontsize = fontsize ) extraplots . set_ticks_fontsize ( ax , fontsize ) plt . draw ( ) plt . show ( )  def plot_frequency_psycurve ( bdata , fontsize = 12 ) :      targetFrequency = bdata [ <str> ] choice = bdata [ <str> ] valid = bdata [ <str> ] & ( choice != bdata . labels [ <str> ] [ <str> ] ) choiceRight = choice == bdata . labels [ <str> ] [ <str> ] possibleFreq = np . unique ( targetFrequency ) nFreq = len ( possibleFreq ) trialsEachFreq = find_trials_each_type ( targetFrequency , possibleFreq ) ( possibleValues , fractionHitsEachValue , ciHitsEachValue , nTrialsEachValue , nHitsEachValue ) = calculate_psychometric ( choiceRight , targetFrequency , valid ) ( pline , pcaps , pbars , pdots ) = extraplots . plot_psychometric ( 1e-3 * possibleValues , fractionHitsEachValue , ciHitsEachValue , xTickPeriod = 1 ) plt . xlabel ( <str> , fontsize = fontsize ) plt . ylabel ( <str> , fontsize = fontsize ) extraplots . set_ticks_fontsize ( plt . gca ( ) , fontsize ) return ( pline , pcaps , pbars , pdots )  def plot_dynamics ( behavData , winsize = 40 , fontsize = 12 , soundfreq = None ) :      ax = plt . gca ( ) ax . cla ( ) lineWidth = 2 if not soundfreq :          possibleFreq = np . unique ( behavData [ <str> ] )  else :          possibleFreq = soundfreq  possibleColors = FREQCOLORS + [ <str> , <str> , <str> , <str> , <str> , <str> ] colorEachFreq = dict ( zip ( possibleFreq , possibleColors ) ) behavData . find_trials_each_block ( ) nBlocks = behavData . blocks [ <str> ] trialsEachBlock = behavData . blocks [ <str> ] validEachBlock = trialsEachBlock & ( behavData [ <str> ] [ : , np . newaxis ] . astype ( bool ) ) nValidEachBlock = np . sum ( validEachBlock , axis = 0 ) lastValidEachBlock = np . cumsum ( nValidEachBlock ) firstValidEachBlock = np . concatenate ( ( [ 0 ] , lastValidEachBlock [ : - 1 ] ) ) rightChoice = behavData [ <str> ] == behavData . labels [ <str> ] [ <str> ] hPlots = [ ] plt . hold ( True ) for indb in range ( nBlocks ) :          trialsThisBlock = trialsEachBlock [ : , indb ] validThisBlock = validEachBlock [ : , indb ] for indf , thisFreq in enumerate ( possibleFreq ) :              thisColor = colorEachFreq [ thisFreq ] trialsThisFreq = ( behavData [ <str> ] == thisFreq ) choiceVecThisFreq = np . ma . masked_array ( rightChoice [ validThisBlock ] ) choiceVecThisFreq . mask = ~ trialsThisFreq [ validThisBlock ] movAvChoice = extrafuncs . moving_average_masked ( choiceVecThisFreq , winsize ) hp , = plt . plot ( range ( firstValidEachBlock [ indb ] , lastValidEachBlock [ indb ] ) , 100 * movAvChoice , lw = lineWidth , color = thisColor ) hPlots . append ( hp )   plt . ylim ( [ - 5 , 105 ] ) plt . axhline ( 50 , color = <str> , ls = <str> ) plt . ylabel ( <str> , fontsize = fontsize ) plt . xlabel ( <str> , fontsize = fontsize ) extraplots . set_ticks_fontsize ( ax , fontsize ) plt . draw ( ) plt . show ( ) return hPlots  def calculate_psychometric ( hitTrials , paramValueEachTrial , valid = None ) :      try :          from statsmodels . stats . proportion import proportion_confint useCI = True  except ImportError :          print <str> useCI = False  nTrials = len ( hitTrials ) if valid is None :          valid = ones ( nTrials , dtype = bool )  possibleValues = np . unique ( paramValueEachTrial ) nValues = len ( possibleValues ) trialsEachValue = find_trials_each_type ( paramValueEachTrial , possibleValues ) nTrialsEachValue = np . empty ( nValues , dtype = int ) nHitsEachValue = np . empty ( nValues , dtype = int ) for indv , thisValue in enumerate ( possibleValues ) :          nTrialsEachValue [ indv ] = sum ( valid & trialsEachValue [ : , indv ] ) nHitsEachValue [ indv ] = sum ( valid & hitTrials & trialsEachValue [ : , indv ] )  fractionHitsEachValue = nHitsEachValue / nTrialsEachValue . astype ( float ) if useCI :          ciHitsEachValue = np . array ( proportion_confint ( nHitsEachValue , nTrialsEachValue , method = <str> ) )  else :          ciHitsEachValue = None  return ( possibleValues , fractionHitsEachValue , ciHitsEachValue , nTrialsEachValue , nHitsEachValue )  def OLD_calculate_psychometric ( behavData , parameterName = <str> ) :      paramValues = bdata [ parameterName ] valid = bdata [ <str> ] choice = bdata [ <str> ] choiceRight = choice == bdata . labels [ <str> ] [ <str> ] possibleValues = np . unique ( paramValues ) nValues = len ( possibleValues ) trialsEachValue = find_trials_each_type ( paramValues , possibleValues ) nTrialsEachValue = np . empty ( nValues , dtype = int ) nRightwardEachValue = np . empty ( nValues , dtype = int ) for indv , thisValue in enumerate ( possibleValues ) :          nTrialsEachValue [ indv ] = sum ( valid & trialsEachValue [ : , indv ] ) nRightwardEachValue [ indv ] = sum ( valid & choiceRight & trialsEachValue [ : , indv ] )  fractionRightEachValue = nRightwardEachValue / nTrialsEachValue . astype ( float ) confintervRightEachValue = [ ] return ( possibleValues , fractionRightEachValue , confintervRightEachValue , nTrialsEachValue , nRightwardEachValue )  if __name__ == <str> :      CASE = 6 if CASE == 1 :          from jaratoolbox import loadbehavior import numpy as np experimenter = <str> paradigm = <str> subject = <str> session = <str> behavFile = loadbehavior . path_to_behavior_data ( subject , experimenter , paradigm , session ) behavData = loadbehavior . FlexCategBehaviorData ( behavFile , readmode = <str> ) behavData . find_trials_each_block ( ) plot_summary ( behavData )  elif CASE == 2 :          if 1 :              subjects = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ]  else :              subjects = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ]  sessions = <str> behavior_summary ( subjects , sessions , trialslim = [ 0 , 1200 ] , outputDir = <str> )  elif CASE == 3 :          fname = loadbehavior . path_to_behavior_data ( <str> , <str> , <str> , <str> ) bdata = loadbehavior . BehaviorData ( fname ) ( possibleFreq , pRightEach , ci , nTrialsEach , nRightwardEach ) = OLD_calculate_psychometric ( bdata , parameterName = <str> ) print pRightEach  elif CASE == 4 :          allBehavData = load_many_sessions ( [ <str> ] , sessions = [ <str> , <str> , <str> ] )  elif CASE == 5 :          param = np . array ( [ 7 , 4 , 7 , 5 , 7 , 4 , 7 , 5 , 7 , 4 , 7 , 8 , 8 , 8 ] ) possibleParam = np . unique ( param ) tet = find_trials_each_type ( param , possibleParam ) mask = param > 4 tet = tet & mask [ : , np . newaxis ] print possibleParam print tet  elif CASE == 6 :          parameter1 = np . array ( [ 1 , 2 , 1 , 2 ] ) parameter2 = np . array ( [ 4 , 4 , 5 , 6 ] ) tet = find_trials_each_combination ( parameter1 , np . unique ( parameter1 ) , parameter2 , np . unique ( parameter2 ) ) print tet    