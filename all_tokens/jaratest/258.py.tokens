import allcells_MI_test017 as allcells from jaratoolbox import loadbehavior from jaratoolbox import settings from jaratoolbox import ephyscore import os import numpy as np from jaratoolbox import loadopenephys from jaratoolbox import spikesanalysis from jaratoolbox import extraplots import matplotlib . pyplot as plt SAMPLING_RATE = 30000.0 soundTriggerChannel = 0 binWidth = 0.010 Frequency = 1 countTimeRange = [ 0 , 0.1 ] timeRange = [ - 0.2 , 0.8 ] ephysRootDir = settings . EPHYS_PATH experimenter = <str> paradigm = <str> numOfCells = len ( allcells . cellDB ) modIndexArray = np . empty ( numOfCells ) for cellID in range ( 0 , numOfCells ) :      oneCell = allcells . cellDB [ cellID ] subject = oneCell . animalName behavSession = oneCell . behavSession ephysSession = oneCell . ephysSession ephysRoot = os . path . join ( ephysRootDir , subject ) behaviorFilename = loadbehavior . path_to_behavior_data ( subject , experimenter , paradigm , behavSession ) bdata = loadbehavior . BehaviorData ( behaviorFilename ) ephysDir = os . path . join ( ephysRoot , ephysSession ) eventFilename = os . path . join ( ephysDir , <str> ) events = loadopenephys . Events ( eventFilename ) eventTimes = np . array ( events . timestamps ) / SAMPLING_RATE soundOnsetEvents = ( events . eventID == 1 ) & ( events . eventChannel == soundTriggerChannel ) spkData = ephyscore . CellData ( oneCell ) spkTimeStamps = spkData . spikes . timestamps eventOnsetTimes = eventTimes [ soundOnsetEvents ] rightward = bdata [ <str> ] == bdata . labels [ <str> ] [ <str> ] leftward = bdata [ <str> ] == bdata . labels [ <str> ] [ <str> ] invalid = bdata [ <str> ] == bdata . labels [ <str> ] [ <str> ] correct = bdata [ <str> ] == bdata . labels [ <str> ] [ <str> ] correctRightward = rightward & correct correctLeftward = leftward & correct possibleFreq = np . unique ( bdata [ <str> ] ) oneFreq = bdata [ <str> ] == possibleFreq [ Frequency ] trialsToUseRight = correctRightward & oneFreq trialsToUseLeft = correctLeftward & oneFreq trialsEachCond = np . c_ [ invalid , trialsToUseRight , trialsToUseLeft ] ; colorEachCond = [ <str> , <str> , <str> ] ( spikeTimesFromEventOnset , trialIndexForEachSpike , indexLimitsEachTrial ) = spikesanalysis . eventlocked_spiketimes ( spkTimeStamps , eventOnsetTimes , timeRange ) spikeCountMat = spikesanalysis . spiketimes_to_spikecounts ( spikeTimesFromEventOnset , indexLimitsEachTrial , countTimeRange ) spikeCountEachTrial = spikeCountMat . flatten ( ) spikeAvgRight = sum ( spikeCountEachTrial [ trialsToUseRight ] ) / float ( sum ( trialsToUseRight ) ) spikeAvgLeft = sum ( spikeCountEachTrial [ trialsToUseLeft ] ) / float ( sum ( trialsToUseLeft ) ) if ( ( spikeAvgRight + spikeAvgLeft ) == 0 ) :          modIndexArray [ cellID ] = 0  else :          modIndexArray [ cellID ] = ( spikeAvgRight - spikeAvgLeft ) / ( spikeAvgRight + spikeAvgLeft )   modIndBinVec = np . arange ( - 1 , 1 , binWidth ) binModIndexArray = np . empty ( len ( modIndBinVec ) ) for binInd in range ( len ( modIndBinVec ) - 1 ) :      binModIndexArray [ binInd ] = len ( np . where ( ( modIndexArray >= modIndBinVec [ binInd ] ) & ( modIndexArray < modIndBinVec [ binInd + 1 ] ) ) [ 0 ] )  binModIndexArray [ - 1 ] = len ( np . where ( modIndexArray >= modIndBinVec [ - 1 ] ) [ 0 ] ) plt . clf ( ) modIndBinVec plt . bar ( modIndBinVec , binModIndexArray , width = binWidth ) plt . xlabel ( <str> ) plt . ylabel ( <str> ) plt . show ( )  