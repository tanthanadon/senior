def response_curve_fit ( stimArray , responseArray , type = <str> ) :      from scipy . optimize import curve_fit maxInd = np . argmax ( responseArray ) try :          if type == <str> :              p0 = [ stimArray [ maxInd ] , responseArray [ maxInd ] , 1. , 0. ] curveFit = curve_fit ( gaussian , stimArray , responseArray , p0 = p0 , maxfev = 10000 ) [ 0 ]  elif type == <str> :              curveFit = curve_fit ( quadratic , stimArray , responseArray , p0 = p0 , maxfev = 10000 ) [ 0 ]   except RuntimeError :          print <str> . format ( type ) return None , None , None  if type == <str> :          bestFreq = 2 ** curveFit [ 0 ] fitResponseArray = gaussian ( stimArray , curveFit [ 0 ] , curveFit [ 1 ] , curveFit [ 2 ] , curveFit [ 3 ] )  elif type == <str> :          bestFreq = curveFit [ 2 ] / ( 2 * curveFit [ 1 ] ) fitResponseArray = quadratic ( stimArray , curveFit [ 0 ] , curveFit [ 1 ] , curveFit [ 2 ] )  residuals = responseArray - fitResponseArray SSresidual = np . sum ( residuals ** 2 ) SStotal = np . sum ( ( responseArray - np . mean ( responseArray ) ) ** 2 ) Rsquared = 1 - ( SSresidual / SStotal ) return curveFit , bestFreq , Rsquared  def gaussian ( x , mu , amp , sigma , offset ) :      p = [ mu , amp , sigma , offset ] return p [ 3 ] + p [ 1 ] * np . exp ( - ( ( x - p [ 0 ] ) / p [ 2 ] ) ** 2 )  def quadratic ( x , a , b , c ) :      return a * ( x ** 2 ) + b * x + c   