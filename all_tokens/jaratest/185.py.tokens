from jaratoolbox import loadopenephys from jaratoolbox import loadbehavior from jaratoolbox import spikesanalysis import numpy as np from pylab import * import os outputDir = <str> timeLabeling = <str> ephysRoot = <str> ephysSessionArray = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] subject = <str> experimenter = <str> paradigm = <str> sessionstrArray = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] responseRange = [ 0.10 , 0.40 ] timeRange = [ - 0.5 , 1 ] binTime = 0.1 nametrialsToUse = <str> Frequency = 0 eventID = 0 SAMPLING_RATE = 30000.0 for indDate , ephysSession in enumerate ( ephysSessionArray ) : 	 sessionstr = sessionstrArray [ indDate ] for tetrodeID in range ( 1 , 9 ) : 		 behaviorFilename = loadbehavior . path_to_behavior_data ( subject , experimenter , paradigm , sessionstr ) bdata = loadbehavior . BehaviorData ( behaviorFilename ) numberOfTrials = len ( bdata [ <str> ] ) targetFreqs = bdata [ <str> ] possibleFreq = np . unique ( bdata [ <str> ] ) correct = bdata [ <str> ] == bdata . labels [ <str> ] [ <str> ] incorrect = bdata [ <str> ] == bdata . labels [ <str> ] [ <str> ] rightward = bdata [ <str> ] == bdata . labels [ <str> ] [ <str> ] correctRightward = correct * rightward leftward = bdata [ <str> ] == bdata . labels [ <str> ] [ <str> ] correctLeftward = correct * leftward incorrectRightward = incorrect * rightward incorrectLeftward = incorrect * leftward trialsToUse1 = incorrectLeftward trialsToUse2 = correctRightward ephysDir = os . path . join ( ephysRoot , ephysSession ) eventFilename = os . path . join ( ephysDir , <str> ) events = loadopenephys . Events ( eventFilename ) eventTimes = np . array ( events . timestamps ) / SAMPLING_RATE multipleEventOnset = np . array ( events . eventID ) eventChannel = np . array ( events . eventChannel ) spike_filename = os . path . join ( ephysDir , <str> . format ( tetrodeID ) ) spikeData = loadopenephys . DataSpikes ( spike_filename ) spkTimeStamps = np . array ( spikeData . timestamps ) / SAMPLING_RATE oneEvent = eventChannel == eventID eventOnset = multipleEventOnset * oneEvent while ( numberOfTrials < np . sum ( eventOnset ) ) : 			 eventOnset = eventOnset [ : - 1 ]  eventOnsetTimes = eventTimes [ eventOnset == 1 ] eventOnsetTimesTrials1 = eventOnsetTimes [ trialsToUse1 == 1 ] eventOnsetTimesTrials2 = eventOnsetTimes [ trialsToUse2 == 1 ] ( spikeTimesFromEventOnset , trialIndexForEachSpike , indexLimitsEachTrial ) = spikesanalysis . eventlocked_spiketimes ( spkTimeStamps , eventOnsetTimes , timeRange ) ( spikeTimesFromEventOnsetTrials1 , trialIndexForEachSpikeTrials1 , indexLimitsEachTrialTrials1 ) = spikesanalysis . eventlocked_spiketimes ( spkTimeStamps , eventOnsetTimesTrials1 , timeRange ) ( spikeTimesFromEventOnsetTrials2 , trialIndexForEachSpikeTrials2 , indexLimitsEachTrialTrials2 ) = spikesanalysis . eventlocked_spiketimes ( spkTimeStamps , eventOnsetTimesTrials2 , timeRange ) startTime = float ( timeRange [ 0 ] ) endTime = float ( timeRange [ 1 ] ) fullTime = endTime - startTime numberOfBins = int ( ( fullTime // binTime ) + 1 ) binTimeRanges = np . empty ( [ numberOfBins , 2 ] ) xCoordinatesPlot = np . empty ( numberOfBins ) for indBin in range ( 0 , numberOfBins ) : 		     xCoordinatesPlot [ indBin ] = startTime + indBin * binTime binTimeRanges [ indBin ] = np . array ( [ ( startTime + indBin * binTime ) , ( startTime + ( indBin + 1 ) * binTime ) ] )  spikeNumberInBinPerTrial = np . empty ( [ numberOfBins , numberOfTrials ] ) for i , binRange in enumerate ( binTimeRanges ) : 		     spikeNumberInBinPerTrial [ i ] = spikesanalysis . count_spikes_in_range ( spikeTimesFromEventOnset , indexLimitsEachTrial , binRange )  spikeMeanInBin1 = np . empty ( numberOfBins ) spikeMeanInBin2 = np . empty ( numberOfBins ) for indBin , spikeCounts in enumerate ( spikeNumberInBinPerTrial ) : 		     spikeMeanInBin1 [ indBin ] = np . mean ( np . append ( spikeCounts [ trialsToUse1 == 1 ] , 0 ) ) spikeMeanInBin2 [ indBin ] = np . mean ( np . append ( spikeCounts [ trialsToUse2 == 1 ] , 0 ) )  targetFreqsTrials1 = targetFreqs [ trialsToUse1 == 1 ] targetFreqsTrials2 = targetFreqs [ trialsToUse2 == 1 ] sortedTrials1 = [ ] numTrialsEachFreq1 = [ ] for indf1 , oneFreq1 in enumerate ( possibleFreq ) : 		     indsThisFreq1 = np . flatnonzero ( targetFreqsTrials1 == oneFreq1 ) sortedTrials1 = np . concatenate ( ( sortedTrials1 , indsThisFreq1 ) ) numTrialsEachFreq1 . append ( len ( indsThisFreq1 ) )  sortingIndsTrials1 = argsort ( sortedTrials1 ) sortedIndexForEachSpikeTrials1 = sortingIndsTrials1 [ trialIndexForEachSpikeTrials1 ] sortedTrials2 = [ ] numTrialsEachFreq2 = [ ] for indf2 , oneFreq2 in enumerate ( possibleFreq ) : 		     indsThisFreq2 = np . flatnonzero ( targetFreqsTrials2 == oneFreq2 ) sortedTrials2 = np . concatenate ( ( sortedTrials2 , indsThisFreq2 ) ) numTrialsEachFreq2 . append ( len ( indsThisFreq2 ) )  sortingIndsTrials2 = argsort ( sortedTrials2 ) sortedIndexForEachSpikeTrials2 = sortingIndsTrials2 [ trialIndexForEachSpikeTrials2 ] nSpikesTrials1 = spikesanalysis . count_spikes_in_range ( spikeTimesFromEventOnsetTrials1 , indexLimitsEachTrialTrials1 , responseRange ) nSpikesTrials2 = spikesanalysis . count_spikes_in_range ( spikeTimesFromEventOnsetTrials2 , indexLimitsEachTrialTrials2 , responseRange ) standardDev1 = np . std ( nSpikesTrials1 ) standardDev2 = np . std ( nSpikesTrials2 ) numTrialsTrials1 = cumsum ( numTrialsEachFreq1 ) numTrialsTrials2 = cumsum ( numTrialsEachFreq2 ) clf ( ) rastorFreq1 = plt . subplot2grid ( ( 3 , 4 ) , ( 0 , 0 ) , colspan = 2 , rowspan = 2 ) plot ( spikeTimesFromEventOnsetTrials1 , sortedIndexForEachSpikeTrials1 , <str> , ms = 1 ) axvline ( x = 0 , ymin = 0 , ymax = 1 , color = <str> ) tickPossibleFreq1 = np . empty ( 0 ) tickNumTrialsTrials1 = np . empty ( 0 ) tickNumTrialsEachFreq1 = np . empty ( 0 ) for indf in range ( len ( possibleFreq ) ) : 			 if ( numTrialsEachFreq1 [ indf ] != 0 ) : 				 tickPossibleFreq1 = np . append ( tickPossibleFreq1 , possibleFreq [ indf ] ) tickNumTrialsTrials1 = np . append ( tickNumTrialsTrials1 , numTrialsTrials1 [ indf ] ) tickNumTrialsEachFreq1 = np . append ( tickNumTrialsEachFreq1 , numTrialsEachFreq1 [ indf ] )   tickPositions = tickNumTrialsTrials1 - mean ( tickNumTrialsEachFreq1 ) / 2 tickLabels = [ <str> % ( tickPossibleFreq1 [ indf ] / 1000.0 ) for indf in range ( len ( tickPossibleFreq1 ) ) ] rastorFreq1 . set_yticks ( tickPositions ) rastorFreq1 . set_yticklabels ( tickLabels ) ylabel ( <str> . format ( numTrialsTrials1 [ - 1 ] ) ) title ( ephysSession + <str> . format ( tetrodeID ) ) xlabel ( timeLabeling ) rastorFreq2 = plt . subplot2grid ( ( 3 , 4 ) , ( 0 , 2 ) , colspan = 2 , rowspan = 2 ) plot ( spikeTimesFromEventOnsetTrials2 , sortedIndexForEachSpikeTrials2 , <str> , ms = 1 ) axvline ( x = 0 , ymin = 0 , ymax = 1 , color = <str> ) tickPossibleFreq2 = np . empty ( 0 ) tickNumTrialsTrials2 = np . empty ( 0 ) tickNumTrialsEachFreq2 = np . empty ( 0 ) for indf in range ( len ( possibleFreq ) ) : 			 if ( numTrialsEachFreq2 [ indf ] != 0 ) : 				 tickPossibleFreq2 = np . append ( tickPossibleFreq2 , possibleFreq [ indf ] ) tickNumTrialsTrials2 = np . append ( tickNumTrialsTrials2 , numTrialsTrials2 [ indf ] ) tickNumTrialsEachFreq2 = np . append ( tickNumTrialsEachFreq2 , numTrialsEachFreq2 [ indf ] )   tickPositions = tickNumTrialsTrials2 - mean ( tickNumTrialsEachFreq2 ) / 2 tickLabels = [ <str> % ( tickPossibleFreq2 [ indf ] / 1000.0 ) for indf in range ( len ( tickPossibleFreq2 ) ) ] rastorFreq2 . set_yticks ( tickPositions ) rastorFreq2 . set_yticklabels ( tickLabels ) ylabel ( <str> . format ( numTrialsTrials2 [ - 1 ] ) ) title ( ephysSession + <str> . format ( tetrodeID ) ) xlabel ( timeLabeling ) histogram3 = plt . subplot2grid ( ( 3 , 4 ) , ( 2 , 0 ) , colspan = 2 ) bar ( xCoordinatesPlot , spikeMeanInBin1 , width = binTime ) ylabel ( <str> . format ( binTime ) ) xlabel ( timeLabeling ) histogram4 = plt . subplot2grid ( ( 3 , 4 ) , ( 2 , 2 ) , colspan = 2 ) bar ( xCoordinatesPlot , spikeMeanInBin2 , width = binTime ) ylabel ( <str> . format ( binTime ) ) xlabel ( timeLabeling ) tetrodeName = <str> + str ( tetrodeID ) plt . gcf ( ) . set_size_inches ( ( 8.5 , 11 ) ) figformat = <str> filename = <str> % ( subject , sessionstr , tetrodeName , nametrialsToUse , figformat ) fulloutputDir = outputDir + subject + <str> fullFileName = os . path . join ( fulloutputDir , filename ) print <str> % fullFileName plt . gcf ( ) . savefig ( fullFileName , format = figformat )    