import re import os from lib . python import representations from lib . python import struct_util class Pkgmap ( object ) :    ENTRY_TYPES = { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } def __init__ ( self , input , permissions = False , strip = None , basedir = <str> ) :      self . paths = set ( ) self . analyze_permissions = permissions self . entries = [ ] self . classes = None self . strip = strip self . basedir = basedir for line in input :        entry , line_to_add = self . _ParseLine ( line ) if entry . path :          entry = entry . _asdict ( ) entry [ <str> ] = os . path . join ( basedir , entry [ <str> ] ) if not entry [ <str> ] . startswith ( <str> ) :            entry [ <str> ] = <str> + entry [ <str> ]  entry = representations . PkgmapEntry ( ** entry )  self . entries . append ( entry ) if line_to_add :          self . paths . add ( line_to_add )   self . entries_by_line = struct_util . IndexNamedtuplesBy ( self . entries , <str> ) self . entries_by_type = struct_util . IndexNamedtuplesBy ( self . entries , <str> ) self . entries_by_class = struct_util . IndexNamedtuplesBy ( self . entries , <str> ) self . entries_by_path = struct_util . IndexNamedtuplesBy ( self . entries , <str> ) self . entries = sorted ( self . entries , key = lambda x : x . path )  def _ParseLine ( self , line ) :      fields = re . split ( <str> , line ) if self . strip :        strip_re = re . compile ( <str> % strip ) fields = [ re . sub ( strip_re , <str> , x ) for x in fields ]  line_to_add = None installed_path = None prototype_class = None line_type = fields [ 1 ] mode = None user = None group = None target = None if len ( fields ) < 2 :        return None  elif line_type in ( <str> , <str> , <str> ) :        line_to_add = fields [ 3 ] installed_path = fields [ 3 ] prototype_class = fields [ 2 ] if self . analyze_permissions :          line_to_add += <str> % tuple ( fields [ 4 : 7 ] )  mode , user , group = fields [ 4 : 7 ]  elif line_type in ( <str> ) :        line_to_add = fields [ 3 ] installed_path = fields [ 3 ] prototype_class = fields [ 2 ]  elif line_type in ( <str> , <str> ) :        if <str> not in fields [ 3 ] :          line_to_add = <str> % fields [ 3 ]  else :          link_from , link_to = fields [ 3 ] . split ( <str> ) installed_path = link_from line_to_add = <str> % ( link_from , link_to ) target = struct_util . ResolveSymlink ( link_from , link_to ) prototype_class = fields [ 2 ]   if line_to_add :        self . paths . add ( line_to_add )  entry = representations . PkgmapEntry ( line = line . strip ( ) , class_ = prototype_class , mode = mode , owner = user , group = group , path = installed_path , target = target , type_ = line_type , major = None , minor = None , size = None , cksum = None , modtime = None , pkgnames = [ ] ) return entry , line_to_add  def GetClasses ( self ) :      if not self . classes :        self . classes = set ( ) for entry in self . entries :          if entry [ <str> ] :            self . classes . add ( entry [ <str> ] )    return self . classes    