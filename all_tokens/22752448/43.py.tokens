import copy import datetime import logging import os import os . path import re import shutil import urllib2 from Cheetah import Template import sharedlib_utils as su import common_constants MAJOR_VERSION = <str> MINOR_VERSION = <str> PATCHLEVEL = <str> REVISION = <str> OTHER_VERSION_INFO = <str> NEW_PACKAGE = <str> NO_VERSION_CHANGE = <str> REVISION_ADDED = <str> PKG_URL_TMPL = <str> CATALOG_URL = <str> KNOWN_PKGNAME_PREFIXES = [ <str> , <str> , <str> ] SUBMITPKG_TMPL = class Error ( Exception ) :    pass  class PackageError ( Error ) :    pass  def ParsePackageFileName ( p ) :    if p . endswith ( <str> ) :      p = p [ : - 3 ]  if p . endswith ( <str> ) :      p = p [ : - 4 ]  bits = p . split ( <str> ) if len ( bits ) >= 6 :      catalogname = <str> . join ( bits [ : len ( bits ) - 4 ] ) bits = [ catalogname ] + bits [ len ( bits ) - 4 : ]  else :      catalogname = bits [ 0 ]  if len ( bits ) < 2 :      version , version_info , revision_info = None , None , None full_version_string = None  else :      version , version_info , revision_info = ParseVersionString ( bits [ 1 ] ) full_version_string = bits [ 1 ]  if len ( bits ) == 5 :      osrel , arch , vendortag = bits [ 2 : 5 ]  elif len ( bits ) == 4 :      arch , vendortag = bits [ 2 : 4 ] osrel = <str>  elif len ( bits ) == 3 :      arch = bits [ 2 ] vendortag = <str> osrel = <str>  else :      arch = <str> vendortag = <str> osrel = <str>  data = { <str> : catalogname , <str> : full_version_string , <str> : version , <str> : version_info , <str> : revision_info , <str> : osrel , <str> : arch , <str> : vendortag , } return data  def ComposeVersionString ( version , revision_info ) :    if revision_info :      version += <str> rev_lst = [ ] for key in sorted ( revision_info . keys ( ) ) :        rev_lst . append ( <str> % ( key , revision_info [ key ] ) )  version += <str> . join ( rev_lst )  return version  def ComposePackageFileName ( parsed_filename ) :    tmpl = <str> version_string = parsed_filename [ <str> ] revision_info = parsed_filename [ <str> ] version_string = ComposeVersionString ( version_string , revision_info ) new_data = copy . copy ( parsed_filename ) new_data [ <str> ] = version_string return tmpl % new_data  def ParseVersionString ( s ) :    version_bits = re . split ( <str> , s ) version_str = version_bits [ 0 ] revision_bits = version_bits [ 1 : ] revision_info = { } version_info = { } version_number_bits = version_str . split ( <str> ) version_info [ MAJOR_VERSION ] = version_number_bits [ 0 ] if len ( version_number_bits ) >= 2 :      version_info [ MINOR_VERSION ] = version_number_bits [ 1 ]  if len ( version_number_bits ) >= 3 :      version_info [ PATCHLEVEL ] = version_number_bits [ 2 ]  for version_bit in revision_bits :      if <str> in version_bit :        ( var_name , var_value ) = version_bit . split ( <str> ) revision_info [ var_name ] = var_value  else :        if not <str> in revision_info :          revision_info [ <str> ] = [ ]  revision_info [ <str> ] . append ( version_bit )   if <str> in revision_info :      revision_info [ <str> ] = tuple ( revision_info [ <str> ] )  return version_str , version_info , revision_info  def ParseRevisionInfo ( revinfo ) :    if <str> in revinfo :      rev = revinfo [ <str> ] m = re . match ( <str> , rev ) if m :        return tuple ( [ int ( x ) for x in m . groups ( ) ] )  else :        return ( )   else :      return ( )   def CompareVersions ( v1 , v2 ) :    logging . debug ( <str> , repr ( v1 ) , repr ( v2 ) ) bv1 , sv1 , ri1 = ParseVersionString ( v1 ) bv2 , sv2 , ri2 = ParseVersionString ( v2 ) vn1 = tuple ( [ int ( x ) for x in re . findall ( <str> , bv1 ) ] ) vn2 = tuple ( [ int ( x ) for x in re . findall ( <str> , bv2 ) ] ) pr1 , pr2 = ( ) , ( ) if <str> in ri1 :      pr1 = ParseRevisionInfo ( ri1 )  if <str> in ri2 :      pr2 = ParseRevisionInfo ( ri2 )  key1 = pr1 + vn1 key2 = pr2 + vn2 return cmp ( key1 , key2 )  class CatalogBasedOpencswPackage ( object ) :    catalog_downloaded = False def __init__ ( self , catalogname ) :      self . catalogname = catalogname  def IsOnTheWeb ( self ) :      url = PKG_URL_TMPL % self . catalogname logging . debug ( <str> , repr ( url ) ) package_page = urllib2 . urlopen ( url ) html = package_page . read ( ) package_not_in_mantis_pattern = <str> return html . find ( package_not_in_mantis_pattern ) >= 0  def IsNew ( self ) :      return not self . IsOnTheWeb ( )  def UpgradeType ( self , new_version_string ) :      ( new_version , new_version_info , new_revision_info ) = ParseVersionString ( new_version_string ) catalog_data = self . GetCatalogPkgData ( ) if not catalog_data :        return ( NEW_PACKAGE , <str> % new_version_string , ( None , new_version_string ) )  cat_version_info = catalog_data [ <str> ] levels = ( MAJOR_VERSION , MINOR_VERSION , PATCHLEVEL ) for level in levels :        if level in cat_version_info and level in new_version_info :          if ( cat_version_info [ level ] != new_version_info [ level ] ) :            versions = ( catalog_data [ <str> ] , new_version_string ) msg = <str> % versions return level , msg , versions    cat_rev_info = catalog_data [ <str> ] for rev_kw in new_revision_info :        if rev_kw in cat_rev_info :          if cat_rev_info [ rev_kw ] != new_revision_info [ rev_kw ] :            msg = <str> % ( rev_kw , cat_rev_info [ rev_kw ] , new_revision_info [ rev_kw ] ) versions = cat_rev_info [ rev_kw ] , new_revision_info [ rev_kw ] return REVISION , msg , versions   else :          msg = <str> % ( repr ( rev_kw ) , new_revision_info [ rev_kw ] ) return REVISION_ADDED , msg , ( None , new_revision_info [ rev_kw ] )   if ( catalog_data [ <str> ] == new_version and catalog_data [ <str> ] == new_revision_info ) :        return NO_VERSION_CHANGE , <str> , ( new_version , new_version )  return OTHER_VERSION_INFO , <str> , ( None , None )  @ classmethod def LazyDownloadCatalogData ( cls , catalog_source = None ) :      if not cls . catalog_downloaded :        cls . DownloadCatalogData ( catalog_source ) cls . catalog_downloaded = True   @ classmethod def DownloadCatalogData ( cls , catalog_source ) :      logging . debug ( <str> , repr ( CATALOG_URL ) ) if not catalog_source :        catalog_source = urllib2 . urlopen ( CATALOG_URL )  cls . catalog = { } for line in catalog_source :        if line . startswith ( <str> ) : continue if <str> in line : continue if line . startswith ( <str> ) : continue if len ( line . strip ( ) ) <= 0 : continue if <str> in line : break fields = re . split ( <str> , line ) try :          cls . catalog [ fields [ 0 ] ] = ParsePackageFileName ( fields [ 3 ] )  except IndexError , e :          print repr ( line ) print fields print e raise    @ classmethod def _GetCatalogPkgData ( cls , catalogname ) :      cls . LazyDownloadCatalogData ( ) if catalogname in cls . catalog :        return cls . catalog [ catalogname ]  else :        return None   def GetCatalogPkgData ( self ) :      return self . _GetCatalogPkgData ( self . catalogname )   class StagingDir ( object ) :    def __init__ ( self , dir_path ) :      self . dir_path = dir_path  def __repr__ ( self ) :      return <str> % repr ( self . dir_path )  def GetLatest ( self , software , architectures = common_constants . ARCHITECTURES , os_rels = common_constants . OS_RELS ) :      files = os . listdir ( self . dir_path ) package_files = [ ] for os_rel in os_rels :        for a in architectures :          glob1 = <str> % ( os_rel , a ) logging . debug ( <str> , files ) logging . debug ( <str> , glob1 ) relevant_pkgs = sorted ( shutil . fnmatch . filter ( files , glob1 ) ) logging . debug ( <str> , relevant_pkgs ) glob2 = <str> % ( software ) logging . debug ( <str> , glob2 ) relevant_pkgs = sorted ( shutil . fnmatch . filter ( relevant_pkgs , glob2 ) ) logging . debug ( <str> , relevant_pkgs ) if relevant_pkgs :            package_files . append ( relevant_pkgs [ - 1 ] )    if not package_files :        logging . warning ( <str> , repr ( software ) , repr ( self . dir_path ) )  logging . debug ( <str> , repr ( software ) , repr ( self . dir_path ) , repr ( package_files ) ) return [ os . path . join ( self . dir_path , x ) for x in package_files ]   class NewpkgMailer ( object ) :    def __init__ ( self , pkgnames , paths , release_mgr_name , release_mgr_email , sender_name , sender_email , release_cc ) :      self . sender = <str> % ( sender_name , sender_email ) self . pkgnames = pkgnames self . paths = paths if release_mgr_name :        self . release_mgr = <str> % ( release_mgr_name , release_mgr_email )  else :        self . release_mgr = <str> % ( release_mgr_email )  self . release_cc = release_cc if self . release_cc :        self . release_cc = unicode ( release_cc )   def FormatMail ( self ) :      return self . _FormatMail ( self . paths , self . pkgnames , self . sender , self . release_mgr , self . release_cc )  def _GetPkgsData ( self , paths ) :      pkgs_data = { } for p in paths :        base_file_name = os . path . split ( p ) [ 1 ] catalogname = base_file_name . split ( <str> ) [ 0 ] pkg = CatalogBasedOpencswPackage ( catalogname ) new_data = ParsePackageFileName ( base_file_name ) new_version_str = new_data [ <str> ] catalog_data = pkg . GetCatalogPkgData ( ) if catalog_data :          catalog_version_str = catalog_data [ <str> ]  else :          catalog_version_str = <str>  upgrade_type , upgrade_msg , versions = pkg . UpgradeType ( new_version_str ) pkgs_data_key = ( upgrade_type , upgrade_msg , versions ) if pkgs_data_key not in pkgs_data :          pkgs_data [ pkgs_data_key ] = [ ]  pkg . srv4path = p pkg . cat_version_str = catalog_version_str pkg . new_version_str = new_version_str pkgs_data [ pkgs_data_key ] . append ( pkg )  return pkgs_data  def _FormatMail ( self , paths , pkgnames , sender , release_mgr , release_cc ) :      pkgs_data = self . _GetPkgsData ( paths ) pkg_groups = [ ] for upgrade_type , upgrade_msg , versions in pkgs_data :        pkg_group = { } pkg_group [ <str> ] = upgrade_type pkg_group [ <str> ] = upgrade_msg pkg_group [ <str> ] = versions pkgs = pkgs_data [ ( upgrade_type , upgrade_msg , versions ) ] group_name = CatalogNameGroupName ( [ pkg . catalogname for pkg in pkgs ] ) pkg_group [ <str> ] = group_name pkg_group [ <str> ] = [ { <str> : os . path . basename ( x . srv4path ) } for x in pkgs ] pkg_groups . append ( pkg_group )  subject = <str> % ( <str> . join ( pkgnames ) ) if len ( subject ) > 50 :        subject = <str> % ( subject [ : 45 ] , )  namespace = { <str> : sender , <str> : release_mgr , <str> : release_cc , <str> : subject , <str> : datetime . datetime . now ( ) , <str> : pkg_groups , <str> : NEW_PACKAGE , <str> : NO_VERSION_CHANGE , } t = Template . Template ( SUBMITPKG_TMPL , searchList = [ namespace ] ) return unicode ( t )  def GetEditorName ( self , env ) :      editor = <str> if <str> in env :        editor = env [ <str> ]  if <str> in env :        editor = env [ <str> ]  return editor   def ParsePkginfo ( lines ) :    d = { } for line in lines :      try :        line = line . strip ( ) if not line : continue if line . startswith ( <str> ) : continue var_name , var_value = line . split ( <str> , 1 ) d [ var_name ] = var_value  except ValueError , e :        raise PackageError ( <str> % ( repr ( line ) , e ) )   return d  def PkgnameToCatName ( pkgname ) :    for prefix in KNOWN_PKGNAME_PREFIXES :      if pkgname . startswith ( prefix ) :        unused , tmp_prefix , the_rest = pkgname . partition ( prefix ) pkgname = tmp_prefix + <str> + the_rest   return <str> . join ( SplitByCase ( pkgname ) )  def SplitByCase ( s ) :    def CharType ( c ) :      if c . isalnum ( ) :        if c . isupper ( ) :          return 1  else :          return 2   else :        return 3   chartype_list = [ CharType ( x ) for x in s ] neighbors = zip ( chartype_list , chartype_list [ 1 : ] ) casechange = [ False ] + [ x != y for x , y in neighbors ] str_list = [ ( cc * <str> ) + l . lower ( ) for l , cc in zip ( s , casechange ) ] s2 = <str> . join ( str_list ) return re . findall ( <str> , s2 )  def CatalogNameGroupName ( catalogname_list ) :    catalogname_list = copy . copy ( catalogname_list ) if len ( catalogname_list ) == 1 :      return catalogname_list [ 0 ]  current_substring = su . CollectionLongestCommonSubstring ( catalogname_list ) while current_substring and not current_substring [ - 1 ] . isalnum ( ) :      current_substring = current_substring [ : - 1 ]  if len ( current_substring ) >= 2 :      return current_substring  return <str>  def PkginfoToSrv4Name ( pkginfo_dict ) :    SRV4_FN_TMPL = <str> fn_data = { } fn_data [ <str> ] = PkgnameToCatName ( pkginfo_dict [ <str> ] ) fn_data [ <str> ] = pkginfo_dict [ <str> ] fn_data [ <str> ] = <str> fn_data [ <str> ] = pkginfo_dict [ <str> ] fn_data [ <str> ] = <str> return SRV4_FN_TMPL % fn_data   