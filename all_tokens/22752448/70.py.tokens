try :    import unittest2 as unittest  except ImportError :    import unittest  import pprint import cjson import copy import cPickle import hashlib import mox import pprint import re import sqlite3 import sqlobject from lib . python import checkpkg_lib from lib . python import common_constants from lib . python import database from lib . python import models from lib . python import package_stats from lib . python import relational_util from lib . python import tag from lib . python import rest from lib . python import test_base from lib . python . testdata import neon_stats from lib . python . testdata import stubs from lib . web import releases_web class CheckpkgManager2UnitTest ( mox . MoxTestBase ) :    def testSingleTag ( self ) :      m = checkpkg_lib . CheckpkgManager2 ( <str> , [ ] , <str> , <str> , <str> ) tags = { <str> : [ tag . CheckpkgTag ( <str> , <str> , <str> ) , ] , } screen_report , tags_report = m . FormatReports ( tags , [ ] , [ ] ) expected = <str> self . assertEqual ( expected , unicode ( tags_report ) )  def testThreeTags ( self ) :      m = checkpkg_lib . CheckpkgManager2 ( <str> , [ ] , <str> , <str> , <str> ) tags = { <str> : [ tag . CheckpkgTag ( <str> , <str> , <str> ) , tag . CheckpkgTag ( <str> , <str> , <str> ) , tag . CheckpkgTag ( <str> , <str> ) , ] , } screen_report , tags_report = m . FormatReports ( tags , [ ] , [ ] ) expected = ( <str> <str> <str> <str> ) self . assertEqual ( expected , unicode ( tags_report ) )  def testGetAllTags ( self ) :      return self . mox . StubOutWithMock ( checkpkg_lib , <str> , use_mock_anything = True ) self . mox . StubOutWithMock ( checkpkg_lib , <str> , use_mock_anything = True ) checkpkg_interface_mock = self . mox . CreateMockAnything ( ) set_interface_mock = self . mox . CreateMockAnything ( ) set_interface_mock . errors = [ ] set_interface_mock . needed_files = [ ] set_interface_mock . needed_pkgs = [ ] checkpkg_interface_mock . errors = [ ] checkpkg_interface_mock . needed_files = [ checkpkg_lib . NeededFile ( <str> , <str> , <str> ) , ] checkpkg_interface_mock . needed_pkgs = [ ] self . mox . StubOutWithMock ( checkpkg_lib , <str> , use_mock_anything = True ) checkpkg_lib . IndividualCheckInterface ( <str> , <str> , <str> , <str> , catalog_mock ) . AndReturn ( checkpkg_interface_mock ) checkpkg_lib . SetCheckInterface ( <str> , <str> , <str> , <str> , catalog_mock ) . AndReturn ( set_interface_mock ) stat_obj = self . mox . CreateMockAnything ( ) data_obj = self . mox . CreateMockAnything ( ) stat_obj . data_obj = data_obj pkg_stats = copy . deepcopy ( neon_stats . pkgstats ) pkg_stats [ <str> ] = [ ] data_obj . pickle = cPickle . dumps ( pkg_stats ) checkpkg_interface_mock . ReportErrorForPkgname ( <str> , <str> , <str> ) catalog_mock . GetPkgByPath ( <str> , <str> , <str> , <str> ) . AndReturn ( [ <str> , <str> ] ) self . mox . ReplayAll ( ) m = checkpkg_lib . CheckpkgManager2 ( <str> , [ ] , <str> , <str> , <str> ) errors , messages , gar_lines = m . GetAllTags ( [ stat_obj ] ) self . mox . VerifyAll ( ) expected_messages = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , ] self . assertEquals ( expected_messages , messages ) expected_gar_lines = [ <str> , <str> , <str> , <str> ] self . assertEquals ( expected_gar_lines , gar_lines )  def test_ReportDependencies ( self ) :      m = checkpkg_lib . CheckpkgManager2 ( <str> , [ ] , <str> , <str> , <str> ) checkpkg_interface_mock = self . mox . CreateMock ( checkpkg_lib . IndividualCheckInterface ) needed_files = [ ( <str> , <str> , <str> ) , ] needed_pkgs = [ ] messenger_stub = stubs . MessengerStub ( ) declared_deps_by_pkgname = { <str> : frozenset ( [ <str> , <str> , ] ) , } checkpkg_interface_mock . GetPkgByPath ( <str> ) . AndReturn ( [ <str> , <str> ] ) checkpkg_interface_mock . ReportErrorForPkgname ( <str> , <str> , <str> ) checkpkg_interface_mock . ReportErrorForPkgname ( <str> , <str> , <str> ) checkpkg_interface_mock . ReportErrorForPkgname ( <str> , <str> , <str> ) self . mox . ReplayAll ( ) m . _ReportDependencies ( checkpkg_interface_mock , needed_files , needed_pkgs , messenger_stub , declared_deps_by_pkgname )  def test_ReportDependenciesDirProvidedBySelf ( self ) :      m = checkpkg_lib . CheckpkgManager2 ( <str> , [ ] , <str> , <str> , <str> ) checkpkg_interface_mock = self . mox . CreateMock ( checkpkg_lib . IndividualCheckInterface ) needed_files = [ ( <str> , <str> , <str> ) , ] needed_pkgs = [ ] messenger_stub = stubs . MessengerStub ( ) declared_deps_by_pkgname = { <str> : frozenset ( ) } checkpkg_interface_mock . GetPkgByPath ( <str> ) . AndReturn ( [ <str> , <str> , <str> ] ) self . mox . ReplayAll ( ) m . _ReportDependencies ( checkpkg_interface_mock , needed_files , needed_pkgs , messenger_stub , declared_deps_by_pkgname )  def testSurplusDeps ( self ) :      m = checkpkg_lib . CheckpkgManager2 ( <str> , [ ] , <str> , <str> , <str> ) potential_req_pkgs = set ( [ <str> ] ) declared_deps = set ( [ <str> , <str> ] ) expected = set ( [ <str> ] ) self . assertEquals ( expected , m . _GetSurplusDeps ( <str> , potential_req_pkgs , declared_deps ) )  def testMissingDepsFromReasonGroups ( self ) :      m = checkpkg_lib . CheckpkgManager2 ( <str> , [ ] , <str> , <str> , <str> ) reason_groups = [ [ ( <str> , <str> ) , ( <str> , <str> ) ] , [ ( <str> , <str> ) ] , ] declared_deps = set ( [ <str> ] ) expected = [ [ <str> ] ] result = m . _MissingDepsFromReasonGroups ( <str> , reason_groups , declared_deps ) self . assertEqual ( expected , result )  def testMissingDepsFromReasonGroupsTwo ( self ) :      m = checkpkg_lib . CheckpkgManager2 ( <str> , [ ] , <str> , <str> , <str> ) reason_groups = [ [ ( <str> , <str> ) , ( <str> , <str> ) ] , [ ( <str> , <str> ) ] , ] declared_deps = set ( [ ] ) expected = [ [ <str> , <str> ] , [ <str> ] ] result = m . _MissingDepsFromReasonGroups ( <str> , reason_groups , declared_deps ) self . assertEqual ( result , expected )  def testMissingDepsFromReasonGroupsSelf ( self ) :      m = checkpkg_lib . CheckpkgManager2 ( <str> , [ ] , <str> , <str> , <str> ) reason_groups = [ [ ( <str> , <str> ) , ( <str> , <str> ) ] , ] declared_deps = set ( [ ] ) expected = [ ] result = m . _MissingDepsFromReasonGroups ( <str> , reason_groups , declared_deps ) self . assertEqual ( result , expected )  def test_RemovePkgsFromMissing ( self ) :      m = checkpkg_lib . CheckpkgManager2 ( <str> , [ ] , <str> , <str> , <str> ) missing_dep_groups = [ [ <str> , <str> ] ] expected = set ( [ frozenset ( [ <str> , <str> ] ) , ] ) result = m . _RemovePkgsFromMissing ( <str> , missing_dep_groups ) self . assertEqual ( expected , result )  def testReportMissingDependenciesOne ( self ) :      m = checkpkg_lib . CheckpkgManager2 ( <str> , [ ] , <str> , <str> , <str> ) error_mgr_mock = self . mox . CreateMock ( checkpkg_lib . IndividualCheckInterface ) declared_deps = frozenset ( [ <str> ] ) req_pkgs_reasons = [ [ ( <str> , <str> ) , ( <str> , <str> ) , ] , [ ( <str> , <str> ) , ] , ] error_mgr_mock . ReportErrorForPkgname ( <str> , <str> , <str> ) self . mox . ReplayAll ( ) m . _ReportMissingDependencies ( error_mgr_mock , <str> , declared_deps , req_pkgs_reasons )  def testReportMissingDependenciesTwo ( self ) :      m = checkpkg_lib . CheckpkgManager2 ( <str> , [ ] , <str> , <str> , <str> ) error_mgr_mock = self . mox . CreateMock ( checkpkg_lib . IndividualCheckInterface ) declared_deps = frozenset ( [ ] ) req_pkgs_reasons = [ [ ( <str> , <str> ) , ( <str> , <str> ) , ] , ] error_mgr_mock . ReportErrorForPkgname ( <str> , <str> , <str> ) self . mox . ReplayAll ( ) m . _ReportMissingDependencies ( error_mgr_mock , <str> , declared_deps , req_pkgs_reasons )  def DisabledtestReportMissingDependenciesIntegration ( self ) :      m = checkpkg_lib . CheckpkgManager2 ( <str> , [ ] , <str> , <str> , <str> ) catalog_mock = self . mox . CreateMock ( checkpkg_lib . Catalog ) checkpkg_interface = checkpkg_lib . IndividualCheckInterface ( <str> , <str> , <str> , <str> , catalog_mock ) declared_deps_by_pkgname = { <str> : frozenset ( ) , } declared_deps = frozenset ( [ ] ) pkgs_providing_path = [ <str> % x for x in range ( 20 ) ] catalog_mock . GetPkgByPath ( <str> , <str> , <str> , <str> ) . AndReturn ( pkgs_providing_path ) self . mox . ReplayAll ( ) checkpkg_interface . NeedFile ( <str> , <str> ) needed_files = checkpkg_interface . needed_files needed_pkgs = checkpkg_interface . needed_pkgs messenger_stub = stubs . MessengerStub ( ) m . _ReportDependencies ( checkpkg_interface , needed_files , needed_pkgs , messenger_stub , declared_deps_by_pkgname ) self . assertEqual ( 1 , len ( checkpkg_interface . errors ) ) self . assertEqual ( <str> . join ( sorted ( pkgs_providing_path ) ) , checkpkg_interface . errors [ 0 ] . tag_info )  def testReportMissingDependenciesSurplus ( self ) :      m = checkpkg_lib . CheckpkgManager2 ( <str> , [ ] , <str> , <str> , <str> ) error_mgr_mock = self . mox . CreateMock ( checkpkg_lib . IndividualCheckInterface ) declared_deps = frozenset ( [ <str> , <str> , <str> ] ) req_pkgs_reasons = [ [ ( <str> , <str> ) , ( <str> , <str> ) , ] , [ ( <str> , <str> ) , ] , ] error_mgr_mock . ReportErrorForPkgname ( <str> , <str> , <str> ) self . mox . ReplayAll ( ) m . _ReportMissingDependencies ( error_mgr_mock , <str> , declared_deps , req_pkgs_reasons )   class CheckpkgManager2DatabaseIntegrationTest ( test_base . SqlObjectTestMixin , mox . MoxTestBase ) :    def SetUpStatsForTesting ( self , pkgstat_module ) :      for md5_sum , data in pkgstat_module . pkgstats [ 0 ] [ <str> ] . iteritems ( ) :        json = cjson . encode ( data ) content_hash = hashlib . md5 ( ) content_hash . update ( json ) models . ElfdumpInfoBlob ( md5_sum = md5_sum , json = json , content_md5_sum = content_hash . hexdigest ( ) , mime_type = <str> )  data = copy . deepcopy ( pkgstat_module . pkgstats [ 0 ] ) data [ <str> ] = None json = cjson . encode ( data ) content_hash = hashlib . md5 ( ) content_hash . update ( json ) md5_sum = pkgstat_module . pkgstats [ 0 ] [ <str> ] [ <str> ] models . Srv4FileStatsBlob ( md5_sum = md5_sum , json = json , content_md5_sum = content_hash . hexdigest ( ) , mime_type = <str> ) sqo_pkgstats , pkgstats = relational_util . StatsStructToDatabaseLevelOne ( md5_sum , False ) return sqo_pkgstats , pkgstats  def SetUpMockCalls ( self , pkgstats_module , pkg_md5_sum , pkgstats ) :      pkgstats_pruned = copy . copy ( pkgstats ) del pkgstats_pruned [ <str> ] md5_by_binary = { } for bin_path , md5_sum in pkgstats [ <str> ] :        md5_by_binary [ bin_path ] = md5_sum  self . rest_client_mock . GetBlob ( <str> , pkg_md5_sum ) . AndReturn ( pkgstats_pruned ) for bin_path , _ , _ , sonames , _ , _ , _ , _ in pkgstats [ <str> ] :        for soname in sorted ( sonames ) :          self . rest_client_mock . GetPathsAndPkgnamesByBasename ( <str> , <str> , <str> , soname ) . AndReturn ( { } )   for binary_path , md5_sum in pkgstats [ <str> ] :        data = pkgstats [ <str> ] [ md5_sum ] self . rest_client_mock . GetBlob ( <str> , md5_sum ) . AndReturn ( data )   def setUp ( self ) :      super ( CheckpkgManager2DatabaseIntegrationTest , self ) . setUp ( ) self . rest_client_mock = self . mox . CreateMock ( rest . RestClient ) self . mox . StubOutWithMock ( rest , <str> ) rest . RestClient ( pkgdb_url = mox . IsA ( str ) , releases_url = mox . IsA ( str ) ) . AndReturn ( self . rest_client_mock )   class IndividualCheckInterfaceUnitTest ( mox . MoxTestBase ) :    def setUp ( self ) :      super ( IndividualCheckInterfaceUnitTest , self ) . setUp ( ) self . rest_client_mock = self . mox . CreateMock ( rest . RestClient )  def testNeededFile ( self ) :      catalog_mock = self . mox . CreateMock ( checkpkg_lib . Catalog ) self . mox . ReplayAll ( ) ici = checkpkg_lib . IndividualCheckInterface ( <str> , <str> , <str> , <str> , catalog_mock , { } , None ) ici . NeedFile ( <str> , <str> ) self . assertEqual ( 1 , len ( ici . needed_files ) ) needed_file = ici . needed_files [ 0 ] self . assertEqual ( <str> , needed_file . pkgname ) self . assertEqual ( <str> , needed_file . full_path ) self . assertEqual ( <str> , needed_file . reason )  def testGetPkgByPathSelf ( self ) :      catalog_mock = self . mox . CreateMock ( checkpkg_lib . Catalog ) pkg_set_files = { <str> : frozenset ( [ ( <str> , <str> ) , ( <str> , <str> ) , ] ) , <str> : frozenset ( [ ( <str> , <str> ) , ] ) , } catalog_mock . GetPkgByPath ( <str> , <str> , <str> , <str> ) . AndReturn ( frozenset ( ) ) self . mox . ReplayAll ( ) ici = checkpkg_lib . IndividualCheckInterface ( <str> , <str> , <str> , <str> , catalog_mock , pkg_set_files , None ) pkgs = ici . GetPkgByPath ( <str> ) self . assertEqual ( frozenset ( [ <str> ] ) , pkgs )  def testGetPathsAndPkgnamesByBasename ( self ) :      catalog_mock = self . mox . CreateMock ( checkpkg_lib . Catalog ) pkg_set_files = { <str> : frozenset ( [ ( <str> , <str> ) , ( <str> , <str> ) , ] ) , <str> : frozenset ( [ ( <str> , <str> ) , ] ) , } in_catalog = { <str> : [ <str> ] , <str> : [ <str> ] , } expected = { <str> : [ <str> ] , <str> : [ <str> ] , } self . rest_client_mock . GetPathsAndPkgnamesByBasename ( <str> , <str> , <str> , <str> ) . AndReturn ( in_catalog ) self . mox . ReplayAll ( ) ici = checkpkg_lib . IndividualCheckInterface ( <str> , <str> , <str> , <str> , catalog_mock , pkg_set_files , self . rest_client_mock ) paths_and_pkgnames = ici . GetPathsAndPkgnamesByBasename ( <str> ) self . assertEqual ( expected , paths_and_pkgnames )  def testNeededPackage ( self ) :      catalog_mock = self . mox . CreateMock ( checkpkg_lib . Catalog ) self . mox . ReplayAll ( ) ici = checkpkg_lib . IndividualCheckInterface ( <str> , <str> , <str> , <str> , catalog_mock , { } , None ) ici . NeedPackage ( <str> , <str> ) self . assertEqual ( 1 , len ( ici . needed_pkgs ) ) needed_pkg = ici . needed_pkgs [ 0 ] self . assertEqual ( <str> , needed_pkg . pkgname ) self . assertEqual ( <str> , needed_pkg . needed_pkg ) self . assertEqual ( <str> , needed_pkg . reason )   class SetCheckInterfaceUnitTest ( mox . MoxTestBase ) :    def testNeededFile ( self ) :      catalog_mock = self . mox . CreateMock ( checkpkg_lib . Catalog ) self . mox . ReplayAll ( ) sci = checkpkg_lib . SetCheckInterface ( <str> , <str> , <str> , catalog_mock , { } , None ) sci . NeedFile ( <str> , <str> , <str> ) self . assertEqual ( 1 , len ( sci . needed_files ) ) needed_file = sci . needed_files [ 0 ] self . assertEqual ( <str> , needed_file . pkgname ) self . assertEqual ( <str> , needed_file . full_path ) self . assertEqual ( <str> , needed_file . reason )   class ExtractorsUnitTest ( unittest . TestCase ) :    def testExtractDescriptionFromGoodData ( self ) :      data = { <str> : <str> } result = <str> self . assertEqual ( result , checkpkg_lib . ExtractDescription ( data ) )  def testExtractDescriptionWithBadCatalogname ( self ) :      data = { <str> : <str> } result = <str> self . assertEqual ( result , checkpkg_lib . ExtractDescription ( data ) )  def testExtractMaintainerName ( self ) :      data = { <str> : <str> <str> <str> } result = <str> self . assertEqual ( result , checkpkg_lib . ExtractMaintainerName ( data ) )  def testPstampRegex ( self ) :      pstamp = <str> expected = { <str> : <str> , <str> : <str> , <str> : <str> } self . assertEqual ( expected , re . match ( common_constants . PSTAMP_RE , pstamp ) . groupdict ( ) )   class SliceListUnitTest ( unittest . TestCase ) :    def testOne ( self ) :      l = [ 1 , 2 , 3 , 4 , 5 ] s = 1 expected = [ [ 1 ] , [ 2 ] , [ 3 ] , [ 4 ] , [ 5 ] ] self . assertTrue ( expected , checkpkg_lib . SliceList ( l , s ) )  def testTwo ( self ) :      l = [ 1 , 2 , 3 , 4 , 5 ] s = 2 expected = [ [ 1 , 2 ] , [ 3 , 4 ] , [ 5 ] ] self . assertTrue ( expected , checkpkg_lib . SliceList ( l , s ) )   class SqliteUnitTest ( unittest . TestCase ) :    def setUp ( self ) :      self . conn = sqlite3 . connect ( <str> ) self . c = self . conn . cursor ( )  def tearDown ( self ) :      self . conn = None  def testCannotCreateTwoTables ( self ) :      self . c . execute ( <str> ) self . assertRaises ( sqlite3 . OperationalError , self . c . execute , <str> )  def testOne ( self ) :      self . c . execute ( <str> )  def testTwo ( self ) :      self . c . execute ( <str> )   class SqlobjectUnitTest ( test_base . SqlObjectTestMixin , unittest . TestCase ) :    <str> class TestModel ( sqlobject . SQLObject ) :      name = sqlobject . UnicodeCol ( length = 255 , unique = True , notNone = True )  def testOne ( self ) :      self . TestModel . createTable ( )  def testTwo ( self ) :      self . TestModel . createTable ( )   if __name__ == <str> :    unittest . main ( )   