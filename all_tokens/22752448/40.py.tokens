import os . path import re import operator import logging from lib . python import checkpkg_lib from lib . python import common_constants from lib . python import ldd_emul from lib . python import representations from lib . python import sharedlib_utils ALLOWED_ORPHAN_SONAMES = set ( [ <str> ] ) DEPRECATED_LIBRARY_LOCATIONS = ( ( <str> , <str> , <str> ) , ( <str> , <str> , <str> ) , ( <str> , <str> , <str> ) , ( <str> , <str> , <str> <str> ) , ) DLOPEN_LIB_LOCATIONS = ( <str> , ) DEPENDENCY_FILENAME_REGEXES = ( ( <str> , ( <str> , ) ) , ( <str> , ( <str> , ) ) , ( <str> , ( <str> , <str> , <str> , <str> ) ) , ( <str> , ( <str> , ) ) , ( <str> , ( <str> , ) ) , ) PREFERRED_DIRECTORY_PROVIDERS = set ( [ <str> ] ) BASE_SOLARIS_LIBRARIES = set ( [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , ] ) ALLOWED_VERSION_DEPENDENCIES = { <str> : { <str> : [ <str> , <str> , <str> , <str> ] , <str> : [ <str> , <str> , <str> , <str> ] , <str> : [ <str> , <str> , <str> , <str> ] , <str> : [ <str> , <str> , <str> , <str> ] , } , } for soname in ALLOWED_VERSION_DEPENDENCIES :    os_rels = ALLOWED_VERSION_DEPENDENCIES [ soname ] . keys ( ) assert set ( os_rels ) == set ( common_constants . OS_RELS )  del soname , os_rels def CompareLibraryVersions ( version1 , version2 ) :    version1_parts = re . findall ( <str> , version1 ) version2_parts = re . findall ( <str> , version2 ) for part1 , part2 in zip ( version1_parts , version2_parts ) :      if part1 . isdigit ( ) and part2 . isdigit ( ) :        comp_value = cmp ( int ( part1 ) , int ( part2 ) ) if comp_value != 0 :          return comp_value   elif part1 != part2 :        return None   return cmp ( len ( version1_parts ) , len ( version2_parts ) )  def ProcessSoname ( ldd_emulator , soname , path_and_pkg_by_basename , binary_info , isalist , binary_path , logger , error_mgr , pkgname , messenger ) :    logging . debug ( <str> % ( binary_info . path , soname ) ) orphan_sonames = [ ] resolved = False path_list = path_and_pkg_by_basename [ soname ] . keys ( ) runpath_tuple = ( tuple ( binary_info . runpath ) + tuple ( checkpkg_lib . SYS_DEFAULT_RUNPATH ) ) runpath_history = [ ] first_lib = None already_resolved_paths = set ( ) for runpath in runpath_tuple :      runpath = ldd_emulator . SanitizeRunpath ( runpath ) runpath_list = ldd_emulator . ExpandRunpath ( runpath , isalist , binary_path ) runpath_list = ldd_emulator . Emulate64BitSymlinks ( runpath_list ) runpath_history += runpath_list resolved_path = ldd_emulator . ResolveSoname ( runpath_list , soname , isalist , path_list , binary_path ) if resolved_path :        if resolved_path in already_resolved_paths :          continue  already_resolved_paths . add ( resolved_path ) resolved = True reason = ( <str> % ( binary_info . path , soname ) ) logger . debug ( <str> % ( soname , resolved_path , binary_info . path ) ) error_mgr . NeedFile ( pkgname , os . path . join ( resolved_path , soname ) , reason ) if not first_lib :          first_lib = ( resolved_path , soname ) for bad_path , bad_soname , msg in DEPRECATED_LIBRARY_LOCATIONS :            if resolved_path == bad_path and soname == bad_soname :              logger . debug ( <str> , bad_path , bad_soname ) error_mgr . ReportError ( pkgname , <str> , ( <str> % ( binary_info . path , resolved_path , soname ) ) ) messenger . Message ( <str> % ( binary_info . path , resolved_path , soname , msg ) )      if not resolved :      orphan_sonames . append ( ( soname , binary_info . path ) ) if path_list :        path_msg = <str> % path_list  else :        path_msg = ( <str> <str> )  if soname not in ALLOWED_ORPHAN_SONAMES :        messenger . Message ( <str> <str> % ( soname , binary_info . path , runpath_tuple , runpath_history , path_msg ) )   return orphan_sonames  def Libraries ( pkg_data , error_mgr , logger , messenger , path_and_pkg_by_basename , pkg_by_path ) :    pkgname = pkg_data [ <str> ] [ <str> ] logger . debug ( <str> , repr ( pkgname ) ) isalist = pkg_data [ <str> ] ldd_emulator = ldd_emul . LddEmulator ( ) orphan_sonames = [ ] binary_md5_by_path = dict ( pkg_data [ <str> ] ) for binary_info in pkg_data [ <str> ] :      binary_info = representations . BinaryDumpInfo . _make ( binary_info ) binary_path , binary_basename = os . path . split ( binary_info . path ) for soname in binary_info . needed_sonames :        orphan_sonames_tmp = ProcessSoname ( ldd_emulator , soname , path_and_pkg_by_basename , binary_info , isalist , binary_path , logger , error_mgr , pkgname , messenger ) orphan_sonames . extend ( orphan_sonames_tmp )  if binary_info . path not in binary_md5_by_path :        error_mgr . ReportError ( pkgname , <str> , <str> % binary_info . path ) continue  binary_md5 = binary_md5_by_path [ binary_info . path ] binary_elf_info = error_mgr . GetElfdumpInfo ( binary_md5 ) needed_libs = set ( binary_info . needed_sonames ) db_libs = set ( ) really_needed_libs = set ( ) for syminfo in binary_elf_info [ <str> ] :        if ( syminfo . soname is not None and syminfo . flags is not None ) :          really_needed_libs . add ( syminfo . soname ) if <str> in syminfo . flags :            db_libs . add ( syminfo . soname )    if really_needed_libs :        no_db_libs = really_needed_libs . difference ( db_libs )  else :        no_db_libs = needed_libs  no_db_libs . difference_update ( BASE_SOLARIS_LIBRARIES ) if no_db_libs :        no_db_libs = sorted ( no_db_libs ) messenger . Message ( <str> <str> <str> % ( <str> + binary_info . path , <str> . join ( no_db_libs ) ) ) for soname in no_db_libs :          error_mgr . ReportError ( pkgname , <str> , <str> % ( <str> + binary_info . path , soname ) )   if really_needed_libs :        unused_libs = needed_libs . difference ( really_needed_libs ) unused_libs . difference_update ( BASE_SOLARIS_LIBRARIES ) if unused_libs :          unused_libs = sorted ( unused_libs ) messenger . Message ( <str> <str> <str> <str> <str> % ( <str> + binary_info . path , <str> . join ( unused_libs ) ) )   else :        pass  osrel = pkg_data [ <str> ] [ <str> ] [ <str> ] if osrel == <str> and <str> in binary_info . path :        osrel = <str>  for version_dep in binary_elf_info [ <str> ] :        soname = version_dep [ <str> ] if not soname in ALLOWED_VERSION_DEPENDENCIES :          continue  allowed = False versions_allowed = ALLOWED_VERSION_DEPENDENCIES [ soname ] [ osrel ] for version_ref in versions_allowed :          ret = CompareLibraryVersions ( version_dep [ <str> ] , version_ref ) if ret is not None and ret <= 0 :            allowed = True break   if not allowed :          messenger . Message ( <str> <str> % ( <str> + binary_info . path , version_dep [ <str> ] , version_dep [ <str> ] ) ) error_mgr . ReportError ( pkgname , <str> , <str> % ( <str> + binary_info . path , version_dep [ <str> ] , version_dep [ <str> ] ) )    orphan_sonames = set ( orphan_sonames ) for soname , binary_path in orphan_sonames :      if soname not in ALLOWED_ORPHAN_SONAMES :        error_mgr . ReportError ( pkgname , <str> , <str> % ( soname , binary_path ) )    def ByFilename ( pkg_data , error_mgr , logger , messenger , path_and_pkg_by_basename , pkg_by_path ) :    pkgname = pkg_data [ <str> ] [ <str> ] dep_regexes = [ ( re . compile ( x ) , x , y ) for x , y in DEPENDENCY_FILENAME_REGEXES ] for regex , regex_str , dep_pkgnames in dep_regexes :      for pkgmap_entry in pkg_data [ <str> ] :        pkgmap_entry = representations . PkgmapEntry . _make ( pkgmap_entry ) if pkgmap_entry . path and regex . match ( pkgmap_entry . path ) :          reason = ( <str> % ( regex_str , repr ( pkgmap_entry . path ) ) ) for dep_pkgname in dep_pkgnames :            error_mgr . NeedPackage ( pkgname , dep_pkgname , reason )  break     def ByDirectory ( pkg_data , error_mgr , logger , messenger , path_and_pkg_by_basename , pkg_by_path ) :    pkgname = pkg_data [ <str> ] [ <str> ] req_pkgs_reasons = [ ] needed_dirs = set ( ) for pkgmap_entry in pkg_data [ <str> ] :      pkgmap_entry = representations . PkgmapEntry . _make ( pkgmap_entry ) if pkgmap_entry . path :        base_dir , dirname = os . path . split ( pkgmap_entry . path ) needed_dirs . add ( base_dir )   for needed_dir in needed_dirs :      reason_group = [ ] if pkgname not in PREFERRED_DIRECTORY_PROVIDERS :        pkgs_to_mention = [ ] preferred_mentioned = False for preferred_pkg in PREFERRED_DIRECTORY_PROVIDERS :          if preferred_pkg in pkg_by_path [ needed_dir ] :            pkgs_to_mention . append ( preferred_pkg ) preferred_mentioned = True   if not preferred_mentioned :          if not pkg_by_path [ needed_dir ] :            if needed_dir and needed_dir != <str> :              error_mgr . ReportError ( pkgname , <str> , repr ( needed_dir ) )   elif len ( pkg_by_path [ needed_dir ] ) < 5 :            pkgs_to_mention = pkg_by_path [ needed_dir ]  else :            pkgs_to_mention = pkg_by_path [ needed_dir ] [ : 5 ] + [ <str> ]   msg = ( <str> % ( pkgs_to_mention , needed_dir , pkgname ) ) for pkg_to_mention in pkgs_to_mention :          reason_group . append ( ( pkg_to_mention , msg ) )  if reason_group :          req_pkgs_reasons . append ( reason_group )   else :        error_mgr . ReportError ( pkgname , <str> , needed_dir )   return req_pkgs_reasons  def GetPathAndPkgByBasename ( error_mgr , logger , basenames , path_and_pkg_by_basename = None ) :    if not path_and_pkg_by_basename :      path_and_pkg_by_basename = { }  for basename in basenames :      path_and_pkg_by_basename [ basename ] = ( error_mgr . GetPathsAndPkgnamesByBasename ( basename ) )  return path_and_pkg_by_basename  def GetPkgByFullPath ( error_mgr , logger , paths_to_verify , pkg_by_path ) :    if not pkg_by_path :      pkg_by_path = { }  for path in paths_to_verify :      if path not in pkg_by_path :        result = error_mgr . GetPkgByPath ( path ) pkg_by_path [ path ] = result   return pkg_by_path  def SuggestLibraryPackage ( error_mgr , messenger , pkgname , catalogname , description , lib_path , lib_basename , soname , base_pkgname ) :    escaped_soname = sharedlib_utils . EscapeRegex ( soname ) escaped_basename = sharedlib_utils . EscapeRegex ( lib_basename ) messenger . SuggestGarLine ( <str> <str> % pkgname ) messenger . SuggestGarLine ( <str> % pkgname ) messenger . SuggestGarLine ( <str> % ( pkgname , catalogname ) ) messenger . SuggestGarLine ( <str> <str> % ( pkgname , escaped_basename ) ) messenger . SuggestGarLine ( <str> <str> % ( pkgname , escaped_soname ) ) messenger . SuggestGarLine ( <str> % ( pkgname , soname ) ) messenger . SuggestGarLine ( <str> % ( base_pkgname , pkgname ) ) messenger . SuggestGarLine ( <str> % pkgname )   