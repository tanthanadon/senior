import os import re import logging from lib . python import errors from lib . python import opencsw class CatalogLineParseError ( errors . Error ) :     class OpencswCatalogBuilder ( object ) :    def __init__ ( self , product_dir , catalog_dir ) :      self . product_dir = product_dir self . catalog_dir = catalog_dir  def Run ( self ) :      pkg_dirs = os . listdir ( self . product_dir ) for pkg_dir in pkg_dirs :        pkg_path = os . path . join ( self . product_dir , pkg_dir ) pkginfo_path = os . path . join ( pkg_path , <str> ) if ( os . path . isdir ( pkg_path ) and os . path . exists ( pkginfo_path ) ) :          if not self . Srv4Exists ( pkg_path ) :            pkg = None tmpdir = None try :              tmpdir = tempfile . mkdtemp ( prefix = <str> ) logging . debug ( <str> , repr ( pkg_path ) , repr ( tmpdir ) ) tmp_pkg_dir = os . path . join ( tmpdir , pkg_dir ) shutil . copytree ( pkg_path , tmp_pkg_dir , symlinks = True ) pkg = DirectoryFormatPackage ( tmp_pkg_dir ) pkg . ResetNameProperty ( ) pkg . ToSrv4 ( self . catalog_dir )  except IOError , e :              logging . warn ( <str> , pkg_path , e )  finally :              if pkg :                del ( pkg )  if os . path . exists ( tmpdir ) :                shutil . rmtree ( tmpdir )    else :            logging . warn ( <str> , pkg_path )   else :          logging . warn ( <str> , pkg_path )    def Srv4Exists ( self , pkg_dir ) :      pkg = DirectoryFormatPackage ( pkg_dir ) srv4_name = pkg . GetSrv4FileName ( ) srv4_name += <str> srv4_path = os . path . join ( self . catalog_dir , srv4_name ) result = os . path . exists ( srv4_path ) logging . debug ( <str> , pkg_dir , repr ( srv4_path ) , result ) return result   class OpencswCatalog ( object ) :    def __init__ ( self , fd ) :      self . fd = fd self . by_basename = None self . by_catalogname = None self . catalog_data = None  def _ParseCatalogLine ( self , line ) :      cline_re_str_list = [ ( <str> <str> <str> <str> <str> <str> <str> <str> <str> <str> <str> <str> <str> <str> <str> <str> <str> <str> <str> <str> <str> ) , ] cline_re_list = [ re . compile ( x ) for x in cline_re_str_list ] matched = False d = None def SplitPkgList ( pkglist ) :        if not pkglist :          pkglist = ( )  elif pkglist == <str> :          pkglist = ( )  else :          pkglist = tuple ( pkglist . split ( <str> ) )  return pkglist  for cline_re in cline_re_list :        m = cline_re . match ( line ) if m :          d = m . groupdict ( ) matched = True if not d :            raise CatalogLineParseError ( <str> % repr ( line ) )  d [ <str> ] = SplitPkgList ( d [ <str> ] ) d [ <str> ] = SplitPkgList ( d [ <str> ] )   if not matched :        raise CatalogLineParseError ( <str> % repr ( line ) )  return d  def _GetCatalogData ( self , fd ) :      catalog_data = [ ] for line in fd :        if not line . strip ( ) : continue if line . startswith ( <str> ) : continue if line . startswith ( <str> ) : continue if line . startswith ( <str> ) : continue if line . startswith ( <str> ) : break try :          parsed = self . _ParseCatalogLine ( line ) catalog_data . append ( parsed )  except CatalogLineParseError , e :          logging . debug ( <str> , repr ( line ) , e )   return catalog_data  def GetCatalogData ( self ) :      if not self . catalog_data :        self . catalog_data = self . _GetCatalogData ( self . fd )  return self . catalog_data  def GetDataByBasename ( self ) :      if not self . by_basename :        self . by_basename = { } cd = self . GetCatalogData ( ) for d in cd :          if <str> not in d :            logging . error ( <str> , d )  self . by_basename [ d [ <str> ] ] = d   return self . by_basename  def GetDataByCatalogname ( self ) :      if not self . by_catalogname :        self . by_catalogname = { } cd = self . GetCatalogData ( ) for d in cd :          if <str> not in d :            logging . error ( <str> , d )  if d [ <str> ] in self . by_catalogname :            logging . warning ( <str> , d [ <str> ] )  self . by_catalogname [ d [ <str> ] ] = d   return self . by_catalogname   class CatalogComparator ( object ) :    def GetCatalogDiff ( self , cat_a , cat_b ) :      if type ( cat_a ) == dict :        bc_a = cat_a  else :        bc_a = cat_a . GetDataByCatalogname ( )  if type ( cat_b ) == dict :        bc_b = cat_b  else :        bc_b = cat_b . GetDataByCatalogname ( )  cn_a = set ( bc_a ) cn_b = set ( bc_b ) new_catalognames = cn_b . difference ( cn_a ) removed_catalognames = cn_a . difference ( cn_b ) same_catalognames = cn_b . intersection ( cn_a ) updated_catalognames = set ( ) for catalogname in same_catalognames :        if bc_a [ catalogname ] [ <str> ] != bc_b [ catalogname ] [ <str> ] :          updated_catalognames . add ( catalogname )   new_pkgs = [ bc_b [ x ] for x in new_catalognames ] removed_pkgs = [ bc_a [ x ] for x in removed_catalognames ] def UpdateData ( _bc_a , _bc_b , catalogname ) :        a = bc_a [ x ] b = bc_b [ x ] cmp_result = opencsw . CompareVersions ( a [ <str> ] , b [ <str> ] ) if cmp_result < 0 :          direction = <str>  else :          direction = <str>  return { <str> : a , <str> : b , <str> : self . DiffType ( a , b ) , <str> : direction , }  updated_pkgs = [ UpdateData ( bc_a , bc_b , x ) for x in updated_catalognames ] return new_pkgs , removed_pkgs , updated_pkgs  def DiffType ( self , a , b ) :      va = opencsw . ParseVersionString ( a [ <str> ] ) vb = opencsw . ParseVersionString ( b [ <str> ] ) if va [ 0 ] == vb [ 0 ] :        return <str>  else :        return <str>     