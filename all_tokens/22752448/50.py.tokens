from email . mime . text import MIMEText from Cheetah import Template import cjson import datetime import dateutil . parser import logging import os import os . path import shutil import smtplib import subprocess import sys import tempfile from lib . python import configuration from lib . python . shell import ShellCommand from lib . python . rest import RestClient , GetUsernameAndPassword class FSLock ( object ) :        def __init__ ( self , dirname ) :              self . __dirname = dirname  def __enter__ ( self ) :              logging . debug ( <str> , self . __dirname ) os . mkdir ( self . __dirname ) return self  def __exit__ ( self , t , v , tb ) :              logging . debug ( <str> , self . __dirname ) os . rmdir ( self . __dirname )   class GenerateCatalog ( object ) :        def __init__ ( self , catrel , arch , osrel , catgenbin ) :              self . _catrel = catrel self . _arch = arch self . _osrel = osrel self . _catgenbin = catgenbin  def generate_catalog ( self , catalogdir ) :              logging . debug ( <str> , self . _catrel , self . _osrel , self . _arch , self . _catgenbin ) ( retval , wdc1 , wdc2 ) = ShellCommand ( [ self . _catgenbin , <str> , self . _arch , <str> , self . _catrel , <str> , self . _osrel , <str> , os . path . join ( catalogdir , <str> ) ] )   class TimestampRecord ( object ) :        def __init__ ( self , fn ) :              self . __filename = fn if os . path . exists ( self . __filename ) :                    self . __read_data ( )  else :                    self . __ts_by_catalog = { }   def __enter__ ( self ) :              return self  def __exit__ ( self , exc_type , wdc1 , wdc2 ) :              if exc_type is None :                    logging . debug ( <str> ) self . save ( )   def __read_data ( self ) :              with open ( self . __filename , <str> ) as fp :                    keyval_list = cjson . decode ( fp . read ( ) ) ts_by_ctlg = dict ( ( tuple ( x ) , y ) for x , y in keyval_list ) self . __ts_by_catalog = ts_by_ctlg   def save ( self ) :              if not self . __ts_by_catalog : return with open ( self . __filename , <str> ) as fp :                    fp . write ( cjson . encode ( self . __ts_by_catalog . items ( ) ) )   def get ( self , catrel , arch , osrel ) :              catkey = ( catrel , arch , osrel ) if self . __ts_by_catalog . has_key ( catkey ) :                    return dateutil . parser . parse ( self . __ts_by_catalog [ catkey ] [ <str> ] )  else :                    return None   def set ( self , catrel , arch , osrel , date ) :              assert date is not None catkey = ( catrel , arch , osrel ) if not catkey in self . __ts_by_catalog :                    self . __ts_by_catalog [ catkey ] = dict ( )  if isinstance ( date , datetime . datetime ) :                    self . __ts_by_catalog [ catkey ] [ <str> ] = date . replace ( microsecond = 0 ) . isoformat ( )  elif isinstance ( date , str ) :                    self . __ts_by_catalog [ catkey ] [ <str> ] = dateutil . parser . parse ( date ) . isoformat ( )  else :                    raise TypeError ( <str> % str ( type ( date ) ) )  self . __ts_by_catalog [ catkey ] [ <str> ] = list ( )  def notified ( self , catrel , arch , osrel , email ) :              catkey = ( catrel , arch , osrel ) assert <str> in self . __ts_by_catalog [ catkey ] assert type ( self . __ts_by_catalog [ catkey ] [ <str> ] ) is list self . __ts_by_catalog [ catkey ] [ <str> ] . append ( email )  def is_notified ( self , catrel , arch , osrel , email ) :              catkey = ( catrel , arch , osrel ) assert <str> in self . __ts_by_catalog [ catkey ] assert type ( self . __ts_by_catalog [ catkey ] [ <str> ] ) is list return email in self . __ts_by_catalog [ catkey ] [ <str> ]  def get_notified ( self , catrel , arch , osrel ) :              catkey = ( catrel , arch , osrel ) assert <str> in self . __ts_by_catalog [ catkey ] assert type ( self . __ts_by_catalog [ catkey ] [ <str> ] ) is list return self . __ts_by_catalog [ catkey ] [ <str> ]   class CatalogTiming ( object ) :        _epoch_start = datetime . datetime ( datetime . MINYEAR , 1 , 1 , 0 , 0 , 0 , 0 ) __list_to_dict_translation = ( ( <str> , 0 ) , ( <str> , 1 ) , ( <str> , 2 ) , ( <str> , 3 ) , ( <str> , 4 ) , ( <str> , 10 , lambda x : CatalogTiming . _epoch_start if x is None else dateutil . parser . parse ( x ) ) , ( <str> , 11 , lambda x : CatalogTiming . _epoch_start if x is None else dateutil . parser . parse ( x ) ) , ( <str> , 12 ) ) def __init__ ( self , catrel , arch , osrel ) :              self . __catrel = catrel self . __arch = arch self . __osrel = osrel self . __timing_data = self . __json_list_to_dict ( self . fetch ( ) )  def __list_to_dict_generator ( self , l ) :              for tr in self . __list_to_dict_translation :                    if len ( tr ) == 2 :                          yield ( tr [ 0 ] , l [ tr [ 1 ] ] )  elif len ( tr ) == 3 :                          yield ( tr [ 0 ] , tr [ 2 ] ( l [ tr [ 1 ] ] ) )    def __json_list_to_dict ( self , jdat ) :              return [ dict ( self . __list_to_dict_generator ( v ) ) for v in jdat ]  def fetch ( self ) :              return self . rest_client . GetCatalogTimingInformation ( self . __catrel , self . __arch , self . __osrel )  def upload_newer_than ( self , date ) :              self . __timing_data . sort ( key = lambda x : x [ <str> ] ) index = 0 for f in self . __timing_data :                    if f [ <str> ] >= date :                          break  index += 1  return self . __timing_data [ index : ]   class CheckDBCatalog ( object ) :        def __init__ ( self , catrel , arch , osrel , fn_ts , gen_catalog_bin , chkcat = <str> , cattiming_class = CatalogTiming , tsrecord_class = TimestampRecord ) :              config = configuration . GetConfig ( ) username , password = GetUsernameAndPassword ( ) self . rest_client = RestClient ( pkgdb_url = config . get ( <str> , <str> ) , releases_url = config . get ( <str> , <str> ) , username = username , password = password ) self . __catalogfgen = GenerateCatalog ( catrel , arch , osrel , gen_catalog_bin ) self . __chkcat = chkcat self . _catrel = catrel self . _arch = arch self . _osrel = osrel self . tmpdir = None self . __tsrecord_class = tsrecord_class self . __cattiming_class = cattiming_class self . __timestamp_record = tsrecord_class ( fn_ts )  def __enter__ ( self ) :              assert self . tmpdir is None self . tmpdir = tempfile . mkdtemp ( dir = <str> ) logging . debug ( <str> % self . tmpdir ) return self  def __exit__ ( self , wdc1 , wdc2 , wdc3 ) :              assert self . tmpdir is not None logging . debug ( <str> % ( self . tmpdir , ) ) shutil . rmtree ( self . tmpdir ) self . tmpdir = None  def __get_notification_address ( self , pkginfo ) :              if pkginfo [ <str> ] is not None and pkginfo [ <str> ] != <str> :                    return pkginfo [ <str> ] + <str>  else :                    return self . rest_client . GetMaintainerByMd5 ( pkginfo [ <str> ] ) [ <str> ]   def notify_broken ( self , date , addr , pkginfo ) :              logging . info ( <str> % addr ) [ logging . info ( <str> % ( p [ <str> ] , str ( date ) ) ) for p in pkginfo ]  def notify_unbroken ( self , date , addr ) :              logging . info ( <str> % addr ) logging . info ( <str> % ( str ( date ) , ) )  def fetch_db_cat ( self ) :              assert self . tmpdir is not None self . __catalogfgen . generate_catalog ( self . tmpdir )  def run_chkcat ( self ) :              assert self . tmpdir is not None logging . debug ( <str> % os . path . join ( self . tmpdir , <str> ) ) ( self . __chkcat_retval , self . stdout , self . stderr ) = ShellCommand ( [ self . __chkcat , <str> , os . path . join ( self . tmpdir , <str> ) ] , allow_error = True ) return self . __chkcat_retval in ( 0 , 1 )  def check ( self ) :              retval = False with FSLock ( <str> ) :                    self . fetch_db_cat ( ) retval = self . run_chkcat ( ) if retval :                          rightnow = datetime . datetime . now ( ) with self . __timestamp_record :                                try :                                      [ self . notify_unbroken ( rightnow , addr ) for addr in self . __timestamp_record . get_notified ( self . _catrel , self . _arch , self . _osrel ) ]  except Exception as ex :                                      logging . error ( <str> , repr ( ex ) )  self . __timestamp_record . set ( self . _catrel , self . _arch , self . _osrel , rightnow )   notifications = { } if not retval :                          lastsuccessful = self . __timestamp_record . get ( self . _catrel , self . _arch , self . _osrel ) if lastsuccessful is None :                                logging . warn ( <str> % ( self . _catrel , self . _arch , self . _osrel ) ) return retval ;  newpkgs = self . __cattiming_class ( self . _catrel , self . _arch , self . _osrel ) . upload_newer_than ( lastsuccessful ) notifications = { } for np in newpkgs :                                addr = self . __get_notification_address ( np ) notifications . setdefault ( addr , { <str> : lastsuccessful } ) notifications [ addr ] . setdefault ( <str> , [ ] ) . append ( np )  for n in notifications :                                self . notify_broken ( notifications [ n ] [ <str> ] , n , notifications [ n ] [ <str> ] , self . stdout , self . stderr )    return retval   class InformMaintainer ( object ) :        MAIL_TEMPLATE_BROKEN = <str> MAIL_TEMPLATE_OK = <str> def __init__ ( self , cat_tuple , date , addr , pkginfo , chkcat_stdout , chkcat_stderr ) :              self . _cat_tuple = cat_tuple self . _date = date self . _addr = addr self . _pkginfo = pkginfo self . _chkcat_stdout = chkcat_stdout self . _chkcat_stderr = chkcat_stderr  def _compose_mail_broken ( self , from_address ) :              namespace = { <str> : self . _pkginfo , <str> : self . _cat_tuple , <str> : self . _date , <str> : self . _chkcat_stdout } t = Template . Template ( InformMaintainer . MAIL_TEMPLATE_BROKEN , searchList = [ namespace ] ) mail = MIMEText ( unicode ( t ) ) mail [ <str> ] = from_address mail [ <str> ] = self . _addr mail [ <str> ] = <str> return mail  def _compose_mail_unbroken ( self , from_address ) :              namespace = { <str> : self . _date , } t = Template . Template ( InformMaintainer . MAIL_TEMPLATE_OK , searchList = [ namespace ] ) mail = MIMEText ( unicode ( t ) ) mail [ <str> ] = from_address mail [ <str> ] = self . _addr mail [ <str> ] = <str> return mail  def send_mail_broken ( self ) :              from_address = <str> s = smtplib . SMTP ( <str> ) try :                    s . sendmail ( from_address , [ self . _addr ] , self . _compose_mail_broken ( from_address ) . as_string ( ) ) logging . debug ( <str> )  except smtplib . SMTPRecipientsRefused , e :                    logging . error ( <str> , repr ( self . _addr ) )   def send_mail_unbroken ( self ) :              from_address = <str> s = smtplib . SMTP ( <str> ) try :                    s . sendmail ( from_address , [ self . _addr ] , self . _compose_mail_unbroken ( from_address ) . as_string ( ) ) logging . debug ( <str> )  except smtplib . SMTPRecipientsRefused , e :                    logging . error ( <str> , repr ( self . _addr ) )     