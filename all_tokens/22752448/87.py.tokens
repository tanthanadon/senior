import ConfigParser import MySQLdb import argparse import datetime import logging import os import pysvn import re import requests import shutil import subprocess import sys class InvalidSourceDirectoryContentException ( Exception ) :      def __init__ ( self , message ) :          self . message = message   class AbstractCommandMethodCallException ( Exception ) :      def __init__ ( self , message ) :          self . message = message   class SvnClientException ( Exception ) :      def __init__ ( self , message ) :          self . message = message   class DatabaseConnectionException ( Exception ) :      def __init__ ( self , message ) :          self . message = message   class DuplicatePackageException ( Exception ) :      def __init__ ( self , message ) :          self . message = message   class UpstreamUrlRetrievalFailedException ( Exception ) :      def __init__ ( self , url ) :          self . url = url   class NoUpstreamVersionFoundException ( Exception ) :      def __init__ ( self , url , regexp ) :          self . url = url self . regexp = regexp   class MissingArgumentException ( Exception ) :      def __init__ ( self , value ) :          self . parameter = value  def __str__ ( self ) :          return repr ( self . parameter )   class InvalidArgumentException ( Exception ) :      def __init__ ( self , value ) :          self . parameter = value  def __str__ ( self ) :          return repr ( self . parameter )   class CommandLineParser ( object ) :      def __init__ ( self ) :          self . optionParser = argparse . ArgumentParser ( ) self . optionParser . add_argument ( <str> , help = <str> , nargs = <str> ) self . optionParser . add_argument ( <str> , help = <str> , action = <str> , dest = <str> ) self . optionParser . add_argument ( <str> , help = <str> , action = <str> , dest = <str> ) self . optionParser . add_argument ( <str> , help = <str> , action = <str> , dest = <str> ) self . optionParser . add_argument ( <str> , help = <str> , action = <str> , dest = <str> ) self . optionParser . add_argument ( <str> , help = <str> , action = <str> , dest = <str> ) self . optionParser . add_argument ( <str> , help = <str> , action = <str> , dest = <str> ) self . optionParser . add_argument ( <str> , help = <str> , action = <str> , dest = <str> ) self . optionParser . add_argument ( <str> , help = <str> , action = <str> , dest = <str> ) self . optionParser . add_argument ( <str> , help = <str> , action = <str> , dest = <str> ) self . optionParser . add_argument ( <str> , help = <str> , action = <str> , dest = <str> ) self . optionParser . add_argument ( <str> , help = <str> , action = <str> , dest = <str> ) self . optionParser . add_argument ( <str> , help = <str> , action = <str> , dest = <str> ) self . optionParser . add_argument ( <str> , help = <str> , action = <str> , dest = <str> ) self . optionParser . add_argument ( <str> , help = <str> , action = <str> , dest = <str> ) self . optionParser . add_argument ( <str> , help = <str> , action = <str> , dest = <str> ) self . optionParser . add_argument ( <str> , help = <str> , action = <str> , dest = <str> ) self . optionParser . add_argument ( <str> , help = <str> , action = <str> , dest = <str> ) self . optionParser . add_argument ( <str> , help = <str> , action = <str> , dest = <str> ) self . optionParser . add_argument ( <str> , help = <str> , action = <str> , dest = <str> ) self . optionParser . add_argument ( <str> , help = <str> , action = <str> , dest = <str> ) self . optionParser . add_argument ( <str> , help = <str> , action = <str> , dest = <str> ) self . optionParser . add_argument ( <str> , help = <str> , action = <str> , dest = <str> )  def parse ( self ) :          self . args = self . optionParser . parse_args ( ) return self . args   class UwatchConfiguration ( object ) :      def initialize ( self , args ) :          fileParser = None if os . path . isfile ( os . path . expanduser ( <str> ) ) :              fileParser = ConfigParser . SafeConfigParser ( ) fileParser . read ( [ os . path . expanduser ( <str> ) ] ) vars = { <str> : None , <str> : None , <str> : None , <str> : None , <str> : None , } self . _database_schema = fileParser . get ( <str> , <str> , vars = vars ) self . _database_host = fileParser . get ( <str> , <str> , vars = vars ) self . _database_user = fileParser . get ( <str> , <str> , vars = vars ) self . _database_password = fileParser . get ( <str> , <str> , vars = vars ) self . _uwatch_pkg_root = fileParser . get ( <str> , <str> , vars = vars )  self . _verbose = args . verbose logging_level = logging . DEBUG if self . _verbose else logging . INFO logging . basicConfig ( level = logging_level ) if args . current_version is not None :              ver = re . split ( <str> , args . current_version ) if ver is None :                  msg = <str> % { <str> : args . current_version } raise InvalidArgumentException ( msg )  else :                  if len ( ver ) == 1 :                      self . _current_version = ver [ 0 ] self . _current_revision = <str>  else :                      self . _current_version = ver [ 1 ] self . _current_revision = ver [ 2 ] ver = re . split ( <str> , self . _current_version ) if len ( ver ) > 1 :                          msg = <str> % { <str> : args . current_version } raise InvalidArgumentException ( msg )     if args . regexp is not None :              self . _regexp = args . regexp  if args . upstream_url is not None :              self . _upstream_url = args . upstream_url  if args . target_version is not None :              self . _target_version = args . target_version  if args . target_location is not None :              self . _target_location = args . target_location  if args . source_directory is not None :              self . _source_directory = args . source_directory  if args . gar_version is not None :              self . _gar_version = args . gar_version  if args . upstream_version is not None :              self . _upstream_version = args . upstream_version  if args . gar_path is not None :              self . _gar_path = args . gar_path  if args . catalog_name is not None :              self . _catalog_name = args . catalog_name  if args . package_name is not None :              self . _package_name = args . package_name  if args . execution_date is not None :              self . _execution_date = args . execution_date  if args . database_schema is not None :              self . _database_schema = args . database_schema  if args . database_host is not None :              self . _database_host = args . database_host  if args . database_user is not None :              self . _database_user = args . database_user  if args . database_password is not None :              self . _database_password = args . database_password  if args . uwatch_deactivated is not None :              self . _uwatch_deactivated = True  else :              self . _uwatch_deactivated = False  if args . uwatch_error is not None :              self . _uwatch_error = True  else :              self . _uwatch_error = False  if args . uwatch_pkg_root is not None :              self . _uwatch_pkg_root = args . uwatch_pkg_root  if args . uwatch_output is not None :              self . _uwatch_output = args . uwatch_output  if args . gar_distfiles is not None :              self . _gar_distfiles = args . gar_distfiles   def __init__ ( self ) :          self . _verbose = None self . _uwatch_deactivated = False self . _uwatch_error = False self . _uwatch_pkg_root = None self . _current_version = None self . _current_revision = <str> self . _regexp = None self . _upstream_url = None self . _target_version = None self . _source_directory = <str> self . _target_location = <str> self . _gar_version = None self . _upstream_version = None self . _gar_path = None self . _catalog_name = None self . _package_name = None self . _execution_date = None self . _database_schema = None self . _database_host = None self . _database_user = None self . _database_password = None self . _gar_distfiles = None self . _uwatch_output = None  def getCurrentVersion ( self ) :          return self . _current_version  def getCurrentRevision ( self ) :          return self . _current_revision  def getRegexp ( self ) :          if ( self . _regexp is None ) and ( self . _gar_distfiles is not None ) :              urg = UwatchRegexGenerator ( ) auto_regex_list = urg . GenerateRegex ( self . _catalog_name , self . _gar_distfiles ) self . _regexp = auto_regex_list [ 0 ]  return self . _regexp  def getUpstreamURL ( self ) :          return self . _upstream_url  def getVerbose ( self ) :          return self . _verbose  def getSourceDirectory ( self ) :          return self . _source_directory  def getTargetLocation ( self ) :          return self . _target_location  def getTargetVersion ( self ) :          return self . _target_version  def getGarVersion ( self ) :          return self . _gar_version  def getUpstreamVersion ( self ) :          return self . _upstream_version  def getGarPath ( self ) :          if self . getUwatchPkgRoot ( ) :              return self . _gar_path . replace ( self . getUwatchPkgRoot ( ) , <str> )  else :              return self . _gar_path   def getCatalogName ( self ) :          return self . _catalog_name  def getPackageName ( self ) :          return self . _package_name  def getExecutionDate ( self ) :          return self . _execution_date  def getDatabaseSchema ( self ) :          return self . _database_schema  def getDatabaseHost ( self ) :          return self . _database_host  def getDatabaseUser ( self ) :          return self . _database_user  def getDatabasePassword ( self ) :          return self . _database_password  def getUwatchError ( self ) :          return self . _uwatch_error  def getUwatchDeactivated ( self ) :          return self . _uwatch_deactivated  def getUwatchPkgRoot ( self ) :          return self . _uwatch_pkg_root  def getGarDistfiles ( self ) :          return self . _gar_distfiles  def getUwatchOutput ( self ) :          return self . _uwatch_output   class AbstractCommand ( object ) :      def __init__ ( self , name ) :          self . config = UwatchConfiguration ( ) self . name = name  def getName ( self ) :          return self . name  def execute ( self , arguments ) :          print <str> raise AbstractCommandMethodCallException ( <str> )   class UpstreamWatchCommand ( AbstractCommand ) :      def UrlContentRetrieve ( self , url ) :          try :              response = requests . get ( url ) response . raise_for_status ( )  except ( requests . exceptions . ConnectionError , requests . exceptions . HTTPError ) as e :              print e raise UpstreamUrlRetrievalFailedException ( <str> . join ( ( url , unicode ( e ) ) ) )  else :              return response . text   def CompareVersionAndGetNewest ( self , version1 , version2 ) :          if not isinstance ( version1 , basestring ) :              print <str> print version1  if not isinstance ( version2 , basestring ) :              print <str> print version2  splittingRegExp = <str> tokens1 = re . split ( splittingRegExp , version1 ) tokens2 = re . split ( splittingRegExp , version2 ) while len ( tokens1 ) > 0 :              if len ( tokens2 ) == 0 :                  return version1  elem1 = tokens1 . pop ( 0 ) elem2 = tokens2 . pop ( 0 ) try :                  elem1 = int ( elem1 ) elem2 = int ( elem2 )  except :                  elem1 = str ( elem1 ) elem2 = str ( elem2 )  if elem1 == elem2 :                  continue  if elem1 > elem2 :                  return version1  else :                  return version2   return version1   class CheckUpstreamCommand ( UpstreamWatchCommand ) :      def __init__ ( self , name ) :          super ( CheckUpstreamCommand , self ) . __init__ ( name )  def checkArgument ( self ) :          argsValid = True if self . config . getCurrentVersion ( ) is None :              print <str> argsValid = False  if self . config . getRegexp ( ) is None :              print <str> argsValid = False  if self . config . getUpstreamURL ( ) is None :              print <str> argsValid = False  if not argsValid :              raise MissingArgumentException ( <str> )   def execute ( self , args ) :          try :              self . config . initialize ( args ) self . checkArgument ( ) url = self . config . getUpstreamURL ( ) version_finding_regex = self . config . getRegexp ( ) logging . info ( <str> , version_finding_regex , url ) content = self . UrlContentRetrieve ( url ) p = re . compile ( version_finding_regex ) matches = p . findall ( content ) logging . info ( <str> , repr ( matches ) ) if len ( matches ) == 0 :                  raise NoUpstreamVersionFoundException ( self . config . getUpstreamURL ( ) , self . config . getRegexp ( ) )  else :                  newestVersion = self . config . getCurrentVersion ( ) while len ( matches ) > 0 :                      newestVersion = self . CompareVersionAndGetNewest ( newestVersion , matches . pop ( 0 ) )   if newestVersion < > self . config . getCurrentVersion ( ) :                  print newestVersion  return True  except MissingArgumentException as instance :              print instance . parameter return False  except UpstreamUrlRetrievalFailedException as instance :              return False  except NoUpstreamVersionFoundException as instance :              return False    class GetUpstreamLatestVersionCommand ( UpstreamWatchCommand ) :      def __init__ ( self , name ) :          super ( GetUpstreamLatestVersionCommand , self ) . __init__ ( name )  def checkArgument ( self ) :          argsValid = True if self . config . getRegexp ( ) is None :              print <str> argsValid = False  if self . config . getUpstreamURL ( ) is None :              print <str> argsValid = False  if not argsValid :              raise MissingArgumentException ( <str> )   def execute ( self , args ) :          try :              self . config . initialize ( args ) self . checkArgument ( ) content = self . UrlContentRetrieve ( self . config . getUpstreamURL ( ) ) regex_str = self . config . getRegexp ( ) p = re . compile ( regex_str ) matches = p . findall ( content ) logging . info ( <str> <str> , repr ( regex_str ) ) logging . info ( <str> <str> , repr ( matches ) ) if len ( matches ) == 0 :                  raise NoUpstreamVersionFoundException ( self . config . getUpstreamURL ( ) , self . config . getRegexp ( ) )  else :                  newestVersion = matches . pop ( 0 ) while len ( matches ) > 0 :                      newestVersion = self . CompareVersionAndGetNewest ( newestVersion , matches . pop ( 0 ) )   print newestVersion return True  except MissingArgumentException as instance :              print instance . parameter return False  except UpstreamUrlRetrievalFailedException as instance :              return False  except NoUpstreamVersionFoundException as instance :              return False    class GetUpstreamVersionListCommand ( UpstreamWatchCommand ) :      def __init__ ( self , name ) :          super ( GetUpstreamVersionListCommand , self ) . __init__ ( name )  def checkArgument ( self ) :          argsValid = True if self . config . getRegexp ( ) is None :              print <str> argsValid = False  if self . config . getUpstreamURL ( ) is None :              print <str> argsValid = False  if not argsValid :              raise MissingArgumentException ( <str> )   def compareAndSortVersion ( self , a , b ) :          if self . CompareVersionAndGetNewest ( a , b ) == a :              return 1  else :              return - 1   def execute ( self , args ) :          try :              self . config . initialize ( args ) self . checkArgument ( ) content = self . UrlContentRetrieve ( self . config . getUpstreamURL ( ) ) listURL = self . config . getUpstreamURL ( ) . split ( <str> ) p = re . compile ( self . config . getRegexp ( ) ) matches = p . findall ( content ) if len ( matches ) == 0 :                  raise NoUpstreamVersionFoundException ( self . config . getUpstreamURL ( ) , self . config . getRegexp ( ) )  else :                  myList = [ ] for version in matches :                      myList . append ( version )  l = list ( set ( myList ) ) l . sort ( self . compareAndSortVersion ) for version in l :                      print version   return True  except MissingArgumentException as instance :              print instance . parameter return False  except UpstreamUrlRetrievalFailedException as instance :              return False  except NoUpstreamVersionFoundException as instance :              return False    class UpgradeToVersionCommand ( UpstreamWatchCommand ) :      def __init__ ( self , name ) :          super ( UpgradeToVersionCommand , self ) . __init__ ( name )  def checkArgument ( self ) :          argsValid = True if self . config . getCurrentVersion ( ) is None :              print <str> argsValid = False  if self . config . getTargetVersion ( ) is None :              print <str> argsValid = False  if self . config . getTargetLocation ( ) is None :              print <str> argsValid = False  if not argsValid :              raise MissingArgumentException ( <str> )   def checkWorkingDirectory ( self ) :          if not os . path . isfile ( self . config . getSourceDirectory ( ) + <str> ) :              msg = <str> % { <str> : os . path . abspath ( self . config . getSourceDirectory ( ) ) } raise InvalidSourceDirectoryContentException ( msg )  if not os . path . isdir ( self . config . getSourceDirectory ( ) + <str> ) :              msg = <str> % { <str> : os . path . abspath ( self . config . getSourceDirectory ( ) ) } raise InvalidSourceDirectoryContentException ( msg )   def getGarRelativeTargetDirectory ( self ) :          garDir = self . config . getSourceDirectory ( ) + <str> if os . path . islink ( garDir ) :              garTarget = os . path . relpath ( os . path . abspath ( os . readlink ( garDir ) ) , os . path . abspath ( targetDir ) )  else :              garTarget = None   def getGarRelativeTargetDirectory ( self ) :          garDir = self . config . getSourceDirectory ( ) + <str> if os . path . islink ( garDir ) :              garTarget = os . path . relpath ( os . path . abspath ( os . readlink ( garDir ) ) , os . path . abspath ( self . getTargetDirectory ( ) ) )  else :              garTarget = None  return garTarget  def getTargetDirectory ( self ) :          return self . config . getTargetLocation ( ) + <str> + self . config . getCurrentVersion ( ) + <str> + self . config . getTargetVersion ( )  def copySvnSourceToTarget ( self , garRelativeTarget ) :          try :              svnClient = pysvn . Client ( ) svnClient . copy ( os . path . abspath ( self . config . getSourceDirectory ( ) ) , self . getTargetDirectory ( ) ) curDir = os . getcwd ( ) os . chdir ( self . getTargetDirectory ( ) ) if garRelativeTarget :                  if os . path . islink ( <str> ) :                      os . remove ( <str> ) os . symlink ( garRelativeTarget , <str> )  else :                      print <str> return False   os . chdir ( curDir )  except pysvn . ClientError , e :              msg = <str> + e . args [ 0 ] + <str> + <str> % { <str> : os . path . abspath ( self . config . getSourceDirectory ( ) ) , <str> : self . getTargetDirectory ( ) } raise SvnClientException ( msg )   def modifyVersion ( self ) :          curDir = os . getcwd ( ) os . chdir ( self . getTargetDirectory ( ) ) lines = [ ] for line in open ( <str> , <str> ) :              m = re . match ( <str> , line ) if m is None :                  lines . append ( line )  else :                  lines . append ( <str> + self . config . getTargetVersion ( ) + <str> )   f = open ( <str> , <str> ) for element in lines :              f . write ( element )  f . close ( ) os . chdir ( curDir )  def execute ( self , args ) :          try :              self . config . initialize ( args ) self . checkArgument ( ) self . checkWorkingDirectory ( ) self . getTargetDirectory ( ) garRelativeTarget = self . getGarRelativeTargetDirectory ( ) self . copySvnSourceToTarget ( garRelativeTarget ) self . modifyVersion ( ) return True  except MissingArgumentException , instance :              print instance . parameter return False  except SvnClientException , e :              print e . message return False  except InvalidSourceDirectoryContentException , e :              print e . message return False    class ReportPackageVersionCommand ( UpstreamWatchCommand ) :      def __init__ ( self , name ) :          super ( ReportPackageVersionCommand , self ) . __init__ ( name ) self . conn = None  def openDatabaseConnection ( self ) :          try :              self . conn = MySQLdb . connect ( host = self . config . getDatabaseHost ( ) , passwd = self . config . getDatabasePassword ( ) , db = self . config . getDatabaseSchema ( ) , user = self . config . getDatabaseUser ( ) )  except MySQLdb . Error , e :              msg = <str> % ( e . args [ 0 ] , e . args [ 1 ] ) raise DatabaseConnectionException ( msg )  if self . conn is None :              msg = <str> % { <str> : self . config . getDatabaseHost ( ) , <str> : self . config . getDatabasePassword ( ) , <str> : self . config . getDatabaseSchema ( ) , <str> : self . config . getDatabaseUser ( ) } raise DatabaseConnectionException ( msg )   def closeDatabaseConnection ( self ) :          if self . conn :              self . conn . commit ( ) self . conn . close ( )  else :              msg = <str> raise DatabaseConnectionException ( msg )   def updateVersionInDatabase ( self ) :          try :              isNewlyCreatedPackage = False if self . conn is None :                  msg = <str> raise DatabaseConnectionException ( msg )  cursor = self . conn . cursor ( MySQLdb . cursors . DictCursor ) cursor . execute ( <str> , ( self . config . getCatalogName ( ) ) ) if cursor . rowcount > 1 :                  msg = self . config . getCatalogName ( ) raise DuplicatePackageException ( msg )  if cursor . rowcount == 0 :                  cursor . execute ( <str> , ( self . config . getGarPath ( ) , self . config . getCatalogName ( ) , self . config . getPackageName ( ) , self . config . getGarVersion ( ) , self . config . getExecutionDate ( ) ) ) isNewlyCreatedPackage = True if self . config . getVerbose ( ) :                      print <str> % { <str> : self . config . getCatalogName ( ) }  cursor . execute ( <str> , ( self . config . getGarPath ( ) , self . config . getCatalogName ( ) ) )  pkg = cursor . fetchone ( ) if pkg [ <str> ] == 1 :                  cursor . execute ( <str> , ( pkg [ <str> ] ) ) if self . config . getVerbose ( ) :                      print <str> % { <str> : self . config . getCatalogName ( ) }   if isNewlyCreatedPackage :                  cursor . execute ( <str> , ( pkg [ <str> ] , <str> , self . config . getGarVersion ( ) , self . config . getExecutionDate ( ) ) )  cursor . execute ( <str> , ( self . config . getExecutionDate ( ) , self . config . getGarPath ( ) , pkg [ <str> ] ) ) if self . config . getUwatchDeactivated ( ) :                  cursor . execute ( <str> , ( pkg [ <str> ] ) ) if self . config . getVerbose ( ) :                      print <str> % { <str> : self . config . getCatalogName ( ) }   else :                  cursor . execute ( <str> , ( pkg [ <str> ] ) ) if self . config . getUwatchError ( ) :                      cursor . execute ( <str> , ( pkg [ <str> ] ) ) if self . config . getVerbose ( ) :                          print <str> % { <str> : self . config . getCatalogName ( ) }   else :                      cursor . execute ( <str> , ( pkg [ <str> ] ) ) if self . config . getVerbose ( ) :                          print <str> % { <str> : self . config . getCatalogName ( ) }   if self . config . getUpstreamVersion ( ) :                      cursor . execute ( <str> , ( self . config . getExecutionDate ( ) , self . config . getGarPath ( ) , pkg [ <str> ] ) ) if self . config . getUpstreamVersion ( ) != pkg [ <str> ] :                          cursor . execute ( <str> , ( self . config . getUpstreamVersion ( ) , pkg [ <str> ] ) ) cursor . execute ( <str> , ( pkg [ <str> ] , <str> , self . config . getUpstreamVersion ( ) , self . config . getExecutionDate ( ) ) ) if self . config . getVerbose ( ) :                              print <str> % { <str> : self . config . getCatalogName ( ) , <str> : self . config . getUpstreamVersion ( ) , <str> : pkg [ <str> ] }   else :                          if self . config . getVerbose ( ) :                              print <str> % { <str> : self . config . getCatalogName ( ) , <str> : self . config . getUpstreamVersion ( ) }     if self . config . getGarVersion ( ) :                  cursor . execute ( <str> , ( self . config . getExecutionDate ( ) , pkg [ <str> ] ) ) if self . config . getGarVersion ( ) != pkg [ <str> ] :                      cursor . execute ( <str> , ( self . config . getGarVersion ( ) , pkg [ <str> ] ) ) cursor . execute ( <str> , ( pkg [ <str> ] , <str> , self . config . getGarVersion ( ) , self . config . getExecutionDate ( ) ) ) if self . config . getVerbose ( ) :                          print <str> % { <str> : self . config . getCatalogName ( ) , <str> : self . config . getGarVersion ( ) , <str> : pkg [ <str> ] }    cursor . execute ( <str> , ( self . config . getGarDistfiles ( ) , self . config . getRegexp ( ) , self . config . getUpstreamURL ( ) , self . config . getUwatchOutput ( ) , pkg [ <str> ] ) ) cursor . close ( )  except MySQLdb . Error , e :              msg = <str> % ( e . args [ 0 ] , e . args [ 1 ] ) raise DatabaseConnectionException ( msg )   def checkArgument ( self ) :          argsValid = True if self . config . getGarPath ( ) is None :              print <str> argsValid = False  if self . config . getGarDistfiles ( ) is None :              print <str> argsValid = False  if self . config . getUwatchOutput ( ) is None :              print <str> argsValid = False  if self . config . getCatalogName ( ) is None :              print <str> argsValid = False  if self . config . getPackageName ( ) is None :              print <str> argsValid = False  if self . config . getExecutionDate ( ) is None :              print <str> argsValid = False  if self . config . getGarVersion ( ) is None :              print <str> argsValid = False  if self . config . getDatabaseSchema ( ) is None :              print <str> argsValid = False  if self . config . getDatabaseHost ( ) is None :              print <str> argsValid = False  if self . config . getDatabaseUser ( ) is None :              print <str> argsValid = False  if self . config . getDatabasePassword ( ) is None :              print <str> argsValid = False  if self . config . getRegexp ( ) is None :              print <str> argsValid = False  if self . config . getUpstreamURL ( ) is None :              print <str> argsValid = False  if not argsValid :              raise MissingArgumentException ( <str> )   def execute ( self , args ) :          try :              self . config . initialize ( args ) self . checkArgument ( ) self . openDatabaseConnection ( ) self . updateVersionInDatabase ( ) self . closeDatabaseConnection ( ) return True  except MissingArgumentException as instance :              print instance . parameter return False  except InvalidArgumentException as instance :              print instance . parameter return False  except DatabaseConnectionException as instance :              print instance . message return False    class CommandProcessor ( object ) :      def __init__ ( self ) :          self . commandsByName = { } cmd = CheckUpstreamCommand ( <str> ) self . commandsByName [ cmd . getName ( ) ] = cmd cmd = GetUpstreamLatestVersionCommand ( <str> ) self . commandsByName [ cmd . getName ( ) ] = cmd cmd = GetUpstreamVersionListCommand ( <str> ) self . commandsByName [ cmd . getName ( ) ] = cmd cmd = UpgradeToVersionCommand ( <str> ) self . commandsByName [ cmd . getName ( ) ] = cmd cmd = ReportPackageVersionCommand ( <str> ) self . commandsByName [ cmd . getName ( ) ] = cmd  def execute ( self , arguments ) :          if not arguments . commands :              print <str> return 1  if self . commandsByName . has_key ( arguments . commands [ 0 ] ) :              res = self . commandsByName [ arguments . commands [ 0 ] ] . execute ( arguments ) if res :                  return 0  else :                  return 1   else :              print <str> % { <str> : arguments [ 0 ] } return 2    class UwatchRegexGenerator ( object ) :    WS_RE = re . compile ( <str> ) DIGIT_RE = re . compile ( <str> ) DIGIT_REMOVAL_RE = re . compile ( <str> ) DIGIT_MATCH_MAKE_RE_1 = <str> DIGIT_MATCH_MAKE_RE_2 = <str> DIGIT_MATCH_MAKE_RE_3 = <str> DIGIT_MATCH_MAKE_RE_4 = <str> ARCHIVE_RE = re . compile ( <str> ) def _ChooseDistfile ( self , file_list ) :      for f in file_list :        if self . ARCHIVE_RE . search ( f ) :          return f   for f in file_list :        if self . DIGIT_RE . search ( f ) :          return f    def _SeparateSoftwareName ( self , catalogname , filename ) :      assert filename parts = filename . split ( <str> ) parts_c_or_v = map ( lambda x : self . _CanBeSoftwareName ( x , catalogname ) , parts ) if False in parts_c_or_v :        i = parts_c_or_v . index ( False )  else :        i = 1  return <str> . join ( parts [ : i ] ) , <str> + <str> . join ( parts [ i : ] )  def _SeparateArchiveName ( self , filename ) :      if self . ARCHIVE_RE . search ( filename ) :        first_part = self . ARCHIVE_RE . split ( filename ) [ 0 ] archive_part = <str> . join ( self . ARCHIVE_RE . findall ( filename ) ) return first_part , archive_part  return filename , <str>  def _CanBeSoftwareName ( self , s , catalogname ) :      if s == catalogname :        return True  if re . match ( self . DIGIT_MATCH_MAKE_RE_1 , s ) :        return False  return True  def GenerateRegex ( self , catalogname , distnames ) :      dist_list = self . WS_RE . split ( distnames ) dist_file = self . _ChooseDistfile ( dist_list ) if not dist_file :        return [ ]  dist_file = dist_file . strip ( ) softwarename , rest_of_filename = self . _SeparateSoftwareName ( catalogname , dist_file ) rest_of_filename , archive_part = self . _SeparateArchiveName ( rest_of_filename ) no_numbers = self . DIGIT_REMOVAL_RE . split ( rest_of_filename ) regex_list = [ softwarename + self . DIGIT_MATCH_MAKE_RE_1 . join ( no_numbers ) + archive_part , softwarename + self . DIGIT_MATCH_MAKE_RE_2 . join ( no_numbers ) + archive_part , softwarename + self . DIGIT_MATCH_MAKE_RE_3 . join ( no_numbers ) + archive_part , softwarename + self . DIGIT_MATCH_MAKE_RE_4 . join ( no_numbers ) + archive_part , ] return regex_list   def main ( ) :      commandProcessor = CommandProcessor ( ) cliParser = CommandLineParser ( ) args = cliParser . parse ( ) return commandProcessor . execute ( args )  if __name__ == <str> :      res = main ( ) sys . exit ( res )   