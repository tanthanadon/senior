from StringIO import StringIO import anydbm import cjson import getpass import httplib import logging import os import pycurl import re import urllib import urllib2 import httplib from lib . python import retry_decorator from lib . python import configuration from lib . python import errors from lib . python import shell DEFAULT_TRIES = 5 DEFAULT_RETRY_DELAY = 10 class ArgumentError ( errors . Error ) :     class RestCommunicationError ( errors . Error ) :     class RestClient ( object ) :    def __init__ ( self , pkgdb_url , releases_url , username = None , password = None , debug = False ) :      self . pkgdb_url = pkgdb_url self . releases_url = releases_url self . username = username self . password = password self . debug = debug  def ValidateMd5 ( self , md5_sum ) :      if not re . match ( <str> , md5_sum ) :        raise ArgumentError ( <str> % md5_sum )   @ retry_decorator . Retry ( tries = DEFAULT_TRIES , exceptions = ( RestCommunicationError , httplib . BadStatusLine ) ) def GetPkgByMd5 ( self , md5_sum ) :      self . ValidateMd5 ( md5_sum ) url = self . pkgdb_url + <str> % md5_sum logging . debug ( <str> , url ) try :        data = urllib2 . urlopen ( url ) . read ( ) return cjson . decode ( data )  except urllib2 . HTTPError , e :        logging . warning ( <str> , url , e ) if e . code == 404 :          return None  else :          raise    def GetPkgstatsByMd5 ( self , md5_sum ) :      self . ValidateMd5 ( md5_sum ) return self . GetBlob ( <str> , md5_sum )  @ retry_decorator . Retry ( tries = DEFAULT_TRIES , exceptions = ( RestCommunicationError , httplib . BadStatusLine ) ) def GetCatalogData ( self , md5_sum ) :      self . ValidateMd5 ( md5_sum ) url = self . pkgdb_url + <str> % md5_sum try :        data = urllib2 . urlopen ( url ) . read ( ) return cjson . decode ( data )  except urllib2 . HTTPError as e :        logging . warning ( <str> , url , e ) raise   def GetMaintainerByMd5 ( self , md5_sum ) :      self . ValidateMd5 ( md5_sum ) pkg = self . GetPkgByMd5 ( md5_sum ) if not pkg :        pkg = { <str> : <str> }  return { <str> : pkg [ <str> ] , }  def GetCatalogList ( self ) :      url = self . releases_url + <str> data = urllib2 . urlopen ( url ) . read ( ) return cjson . decode ( data )  def GetCatalog ( self , catrel , arch , osrel ) :      if not catrel :        raise ArgumentError ( <str> )  url = ( self . pkgdb_url + <str> % ( catrel , arch , osrel ) ) logging . debug ( <str> , url ) try :        data = urllib2 . urlopen ( url ) . read ( ) return cjson . decode ( data )  except urllib2 . HTTPError as e :        logging . warning ( <str> , url , e ) return None   def Srv4ByCatalogAndCatalogname ( self , catrel , arch , osrel , catalogname ) :      url = self . pkgdb_url + ( <str> % ( catrel , arch , osrel , catalogname ) ) logging . debug ( <str> , url ) data = urllib2 . urlopen ( url ) . read ( ) return cjson . decode ( data )  def Srv4ByCatalogAndPkgname ( self , catrel , arch , osrel , pkgname ) :      url = self . pkgdb_url + ( <str> % ( catrel , arch , osrel , pkgname ) ) logging . debug ( <str> , url ) data = urllib2 . urlopen ( url ) . read ( ) return cjson . decode ( data )  def _SetAuth ( self , c ) :      if self . username :        logging . debug ( <str> , self . username ) c . setopt ( pycurl . HTTPAUTH , pycurl . HTTPAUTH_BASIC ) c . setopt ( pycurl . USERPWD , <str> % ( self . username , self . password ) )  else :        logging . debug ( <str> )  return c  def RemoveSvr4FromCatalog ( self , catrel , arch , osrel , md5_sum ) :      url = ( <str> % ( self . releases_url , catrel , arch , osrel , md5_sum ) ) logging . debug ( <str> , type ( url ) , url ) c = pycurl . Curl ( ) d = StringIO ( ) h = StringIO ( ) c . setopt ( pycurl . URL , str ( url ) ) c . setopt ( pycurl . CUSTOMREQUEST , <str> ) c . setopt ( pycurl . WRITEFUNCTION , d . write ) c . setopt ( pycurl . HEADERFUNCTION , h . write ) c . setopt ( pycurl . HTTPHEADER , [ <str> ] ) c = self . _SetAuth ( c ) if self . debug :        c . setopt ( c . VERBOSE , 1 )  c . perform ( ) http_code = c . getinfo ( pycurl . HTTP_CODE ) logging . debug ( <str> , type ( http_code ) , http_code , c . getinfo ( pycurl . EFFECTIVE_URL ) ) c . close ( ) if not ( http_code >= 200 and http_code <= 299 ) :        raise RestCommunicationError ( <str> % ( url , http_code , d . getvalue ( ) ) )   def _CurlPut ( self , url , data ) :      for key , value in data :        assert isinstance ( value , basestring ) , ( value , type ( value ) )  c = pycurl . Curl ( ) d = StringIO ( ) h = StringIO ( ) c . setopt ( pycurl . URL , str ( url ) ) c . setopt ( pycurl . CUSTOMREQUEST , <str> ) if data :        c . setopt ( pycurl . POST , 1 ) c . setopt ( pycurl . HTTPPOST , data )  else :        pass  c . setopt ( pycurl . WRITEFUNCTION , d . write ) c . setopt ( pycurl . HEADERFUNCTION , h . write ) c . setopt ( pycurl . HTTPHEADER , [ <str> ] ) c = self . _SetAuth ( c ) if self . debug :        c . setopt ( c . VERBOSE , 1 )  c . perform ( ) http_code = c . getinfo ( pycurl . HTTP_CODE ) logging . debug ( <str> , http_code , c . getinfo ( pycurl . EFFECTIVE_URL ) ) c . close ( ) if http_code >= 400 and http_code <= 599 :        if not self . debug :          logging . fatal ( <str> , http_code , d . getvalue ( ) )  raise RestCommunicationError ( <str> % ( url , http_code ) )  else :        logging . debug ( <str> , http_code , d . getvalue ( ) )  return http_code  @ retry_decorator . Retry ( tries = DEFAULT_TRIES , delay = DEFAULT_RETRY_DELAY , exceptions = ( RestCommunicationError , pycurl . error ) ) def AddSvr4ToCatalog ( self , catrel , arch , osrel , md5_sum ) :      self . ValidateMd5 ( md5_sum ) url = ( <str> % ( self . releases_url , catrel , arch , osrel , md5_sum ) ) logging . debug ( <str> , url ) return self . _CurlPut ( url , [ ] )  @ retry_decorator . Retry ( tries = DEFAULT_TRIES , delay = DEFAULT_RETRY_DELAY , exceptions = ( RestCommunicationError , pycurl . error ) ) def SaveBlob ( self , tag , md5_sum , data ) :      url = self . releases_url + <str> % ( tag , md5_sum ) logging . debug ( <str> , tag , md5_sum , url ) json_data = cjson . encode ( data ) logging . debug ( <str> , len ( json_data ) / 1024 ) return self . _CurlPut ( url , [ ( <str> , json_data ) , ( <str> , md5_sum ) , ] )  @ retry_decorator . Retry ( tries = DEFAULT_TRIES , delay = DEFAULT_RETRY_DELAY , exceptions = ( RestCommunicationError , pycurl . error ) ) def GetBlob ( self , tag , md5_sum ) :      url = self . releases_url + <str> % ( tag , md5_sum ) logging . debug ( <str> , url ) c = pycurl . Curl ( ) d = StringIO ( ) h = StringIO ( ) c . setopt ( pycurl . URL , str ( url ) ) c . setopt ( pycurl . WRITEFUNCTION , d . write ) c . setopt ( pycurl . HEADERFUNCTION , h . write ) c = self . _SetAuth ( c ) if self . debug :        c . setopt ( c . VERBOSE , 1 )  c . perform ( ) http_code = c . getinfo ( pycurl . HTTP_CODE ) logging . debug ( <str> , type ( http_code ) , http_code , c . getinfo ( pycurl . EFFECTIVE_URL ) ) c . close ( ) logging . debug ( <str> , http_code ) if http_code == 401 :        raise RestCommunicationError ( <str> . format ( http_code ) )  successful = ( http_code >= 200 and http_code <= 299 ) metadata = None if successful :        metadata = cjson . decode ( d . getvalue ( ) )  else :        logging . warning ( <str> % ( tag , md5_sum ) )  return metadata  def _HttpHeadRequest ( self , url ) :      c = pycurl . Curl ( ) d = StringIO ( ) h = StringIO ( ) c . setopt ( pycurl . URL , str ( url ) ) c . setopt ( pycurl . NOPROGRESS , 1 ) c . setopt ( pycurl . NOBODY , 1 ) c . setopt ( pycurl . HEADER , 1 ) c = self . _SetAuth ( c ) if self . debug :        c . setopt ( c . VERBOSE , 1 )  c . setopt ( pycurl . WRITEFUNCTION , d . write ) c . setopt ( pycurl . HEADERFUNCTION , h . write ) c . perform ( ) http_code = c . getinfo ( pycurl . HTTP_CODE ) c . close ( ) return http_code  @ retry_decorator . Retry ( tries = DEFAULT_TRIES , delay = DEFAULT_RETRY_DELAY , exceptions = ( RestCommunicationError , pycurl . error ) ) def BlobExists ( self , tag , md5_sum ) :      url = self . releases_url + <str> % ( tag , md5_sum ) logging . debug ( <str> % url ) http_code = self . _HttpHeadRequest ( url ) if http_code == 404 :        logging . debug ( <str> % md5_sum ) return False  elif http_code == 200 :        logging . debug ( <str> % md5_sum ) return True  else :        raise RestCommunicationError ( <str> % ( url , http_code ) )   def _RPC ( self , url , query_struct ) :      c = pycurl . Curl ( ) d = StringIO ( ) h = StringIO ( ) c . setopt ( pycurl . URL , str ( url ) ) c . setopt ( pycurl . POST , 1 ) data = [ ( <str> , cjson . encode ( query_struct ) ) , ] c . setopt ( pycurl . HTTPPOST , data ) c . setopt ( pycurl . WRITEFUNCTION , d . write ) c . setopt ( pycurl . HEADERFUNCTION , h . write ) c . setopt ( pycurl . HTTPHEADER , [ <str> ] ) c = self . _SetAuth ( c ) if self . debug :        c . setopt ( c . VERBOSE , 1 )  c . perform ( ) http_code = c . getinfo ( pycurl . HTTP_CODE ) logging . debug ( <str> , http_code , c . getinfo ( pycurl . EFFECTIVE_URL ) ) c . close ( ) if http_code >= 400 and http_code < 600 :        if not self . debug :          logging . fatal ( <str> , http_code , d . getvalue ( ) )  raise RestCommunicationError ( <str> % ( url , http_code ) )  else :        d . seek ( 0 ) display_response = d . read ( 100 ) if d . len > 100 :          display_response += <str>  logging . debug ( <str> , http_code , display_response )  return cjson . decode ( d . getvalue ( ) )  def BulkQueryStatsExistence ( self , md5_sum_list ) :      url = self . releases_url + <str> return self . _RPC ( url , md5_sum_list )  def RegisterLevelOne ( self , md5_sum ) :      self . ValidateMd5 ( md5_sum ) url = self . releases_url + <str> % md5_sum return self . _CurlPut ( url , [ ] )  def IsRegisteredLevelOne ( self , md5_sum ) :      self . ValidateMd5 ( md5_sum ) url = self . releases_url + <str> % md5_sum http_code = self . _HttpHeadRequest ( url ) if http_code == 404 :        return False  elif http_code == 200 :        return True  else :        raise RestCommunicationError ( <str> % ( url , http_code ) )   @ retry_decorator . Retry ( tries = DEFAULT_TRIES , delay = DEFAULT_RETRY_DELAY , exceptions = ( RestCommunicationError , pycurl . error ) ) def IsRegisteredLevelTwo ( self , md5_sum ) :      self . ValidateMd5 ( md5_sum ) url = self . releases_url + <str> % md5_sum http_code = self . _HttpHeadRequest ( url ) if http_code == 404 :        return False  elif http_code == 200 :        return True  else :        raise RestCommunicationError ( <str> % ( url , http_code ) )   def RegisterLevelTwo ( self , md5_sum , use_in_catalogs = True ) :      self . ValidateMd5 ( md5_sum ) url = self . releases_url + <str> % md5_sum if use_in_catalogs :        url += <str>  else :        url += <str>  return self . _CurlPut ( url , [ ] )  def GetCatalogForGenerationAsDicts ( self , catrel , arch , osrel ) :      url = ( self . pkgdb_url + <str> % ( catrel , arch , osrel ) ) logging . debug ( <str> , url ) data = urllib2 . urlopen ( url ) . read ( ) return cjson . decode ( data )  def GetBasenamesByCatalogAndDir ( self , catrel , arch , osrel , basedir ) :      url = ( self . pkgdb_url + <str> % ( catrel , arch , osrel , urllib . urlencode ( { <str> : basedir } ) ) ) data = urllib2 . urlopen ( url ) . read ( ) return cjson . decode ( data )  def GetPathsAndPkgnamesByBasename ( self , catrel , arch , osrel , basename ) :      url = ( self . pkgdb_url + <str> % ( catrel , arch , osrel , urllib . urlencode ( { <str> : basename } ) ) ) data = urllib2 . urlopen ( url ) . read ( ) return cjson . decode ( data )  def GetCatalogTimingInformation ( self , catrel , arch , osrel ) :      url = ( self . pkgdb_url + <str> % ( catrel , arch , osrel ) ) data = urllib2 . urlopen ( url ) . read ( ) return cjson . decode ( data )  def GetSrv4FileMetadataForReleases ( self , md5_sum ) :      logging . debug ( <str> , repr ( md5_sum ) ) url = self . releases_url + <str> + md5_sum + <str> c = pycurl . Curl ( ) d = StringIO ( ) h = StringIO ( ) c . setopt ( pycurl . URL , url ) c . setopt ( pycurl . WRITEFUNCTION , d . write ) c . setopt ( pycurl . HEADERFUNCTION , h . write ) c = self . _SetAuth ( c ) if self . debug :        c . setopt ( c . VERBOSE , 1 )  c . perform ( ) http_code = c . getinfo ( pycurl . HTTP_CODE ) logging . debug ( <str> , type ( http_code ) , http_code , c . getinfo ( pycurl . EFFECTIVE_URL ) ) c . close ( ) logging . debug ( <str> , http_code ) if http_code == 401 or ( http_code >= 500 and http_code < 600 ) :        raise RestCommunicationError ( <str> . format ( http_code , d . getvalue ( ) ) )  successful = ( http_code >= 200 and http_code <= 299 ) metadata = None if successful :        metadata = cjson . decode ( d . getvalue ( ) )  else :        logging . debug ( <str> % repr ( md5_sum ) )  return successful , metadata  def PostFile ( self , filename , md5_sum ) :      logging . info ( <str> % repr ( filename ) ) c = pycurl . Curl ( ) d = StringIO ( ) h = StringIO ( ) url = self . releases_url + <str> c . setopt ( pycurl . URL , url ) c . setopt ( pycurl . POST , 1 ) c = self . _SetAuth ( c ) basename = os . path . basename ( filename ) post_data = [ ( <str> , ( pycurl . FORM_FILE , filename ) ) , ( <str> , <str> ) , ( <str> , md5_sum ) , ( <str> , basename ) , ] c . setopt ( pycurl . HTTPPOST , post_data ) c . setopt ( pycurl . WRITEFUNCTION , d . write ) c . setopt ( pycurl . HEADERFUNCTION , h . write ) c . setopt ( pycurl . HTTPHEADER , [ <str> ] ) if self . debug :        c . setopt ( c . VERBOSE , 1 )  c . perform ( ) http_code = c . getinfo ( pycurl . HTTP_CODE ) c . close ( ) if self . debug :        logging . debug ( <str> ) logging . debug ( h . getvalue ( ) ) logging . debug ( <str> ) logging . debug ( d . getvalue ( ) )  logging . debug ( <str> , http_code ) if http_code == 409 :        msg = ( <str> <str> <str> <str> <str> <str> . format ( basename ) ) raise RestCommunicationError ( msg )  if http_code >= 400 and http_code < 600 :        msg = <str> . format ( url , http_code , d . getvalue ( ) ) raise RestCommunicationError ( msg )    class CachedPkgstats ( object ) :    def __init__ ( self , filename , rest_client ) :      self . filename = filename self . d = anydbm . open ( <str> % self . filename , <str> ) config = configuration . GetConfig ( ) self . rest_client = rest_client self . deps = anydbm . open ( <str> % self . filename , <str> )  def __del__ ( self ) :      self . d . close ( )  def GetPkgstats ( self , md5 ) :      pkgstats = None if str ( md5 ) in self . d :        serialized_data = self . d [ md5 ] try :          return cjson . decode ( serialized_data )  except ( TypeError , cjson . DecodeError ) as e :          logging . fatal ( <str> , md5 , e ) del self . d [ md5 ]   if not pkgstats :        pkgstats = self . rest_client . GetPkgstatsByMd5 ( md5 ) self . d [ md5 ] = cjson . encode ( pkgstats )  return pkgstats  def GetDeps ( self , md5 ) :      if str ( md5 ) in self . deps :        return cjson . decode ( self . deps [ md5 ] )  else :        data = self . rest_client . GetCatalogData ( md5 ) self . deps [ md5 ] = cjson . encode ( data ) return data    def GetUsernameAndPassword ( ) :    username = os . environ [ <str> ] password = None authfile = os . path . join ( <str> , username ) try :      with open ( authfile , <str> ) as af :        password = af . read ( ) . strip ( )   except IOError as e :      logging . debug ( <str> , authfile , e )  if password is None :      args = [ <str> , <str> , <str> , <str> , <str> , authfile ] ret_code , stdout , stderr = shell . ShellCommand ( args , allow_error = True ) if not ret_code :        password = stdout . strip ( )  else :        logging . debug ( <str> , args )   logging . debug ( <str> , username ) return username , password   