import hashlib import io import json import logging import optparse import os import sys import collections import mmap from elftools . elf . elffile import ELFFile from elftools . elf . constants import SUNW_SYMINFO_FLAGS from elftools . elf . enums import ENUM_E_MACHINE from elftools . elf . descriptions import ( describe_symbol_type , describe_symbol_bind , describe_symbol_shndx , describe_syminfo_flags ) from elftools . common . exceptions import ELFParseError from lib . python import configuration from lib . python import errors from lib . python import rest from lib . python import representations class ElfExtractor ( object ) :    sh_type2name = { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } def __init__ ( self , binary_path , debug = False ) :      self . debug = debug self . _binary_path = binary_path self . config = configuration . GetConfig ( ) username , password = rest . GetUsernameAndPassword ( ) self . rest_client = rest . RestClient ( pkgdb_url = self . config . get ( <str> , <str> ) , releases_url = self . config . get ( <str> , <str> ) , username = username , password = password ) fd = open ( self . _binary_path , <str> ) self . _mmap = mmap . mmap ( fd . fileno ( ) , 0 , access = mmap . PROT_READ ) self . _elffile = ELFFile ( self . _mmap )  def _compute_md5_sum ( self ) :      md5_hash = hashlib . md5 ( ) md5_hash . update ( self . _mmap ) return md5_hash . hexdigest ( )  def _get_sections_of_interest ( self , * names ) :      sections = { } for section in self . _elffile . iter_sections ( ) :        if section . header [ <str> ] in ElfExtractor . sh_type2name :          name = ElfExtractor . sh_type2name [ section . header [ <str> ] ] if name in names :            sections [ name ] = section    return sections  def _describe_symbol_shndx ( self , shndx ) :      if isinstance ( shndx , int ) :        try :          return self . _elffile . get_section ( shndx ) . name  except ( ELFParseError , ValueError ) :          return str ( shndx )   else :        return shndx [ 4 : ]   def _describe_symbol_boundto ( self , syminfo ) :      dynamic_section = self . _elffile . get_section_by_name ( <str> ) if syminfo [ <str> ] & SUNW_SYMINFO_FLAGS . SYMINFO_FLG_FILTER :        return dynamic_section . get_tag ( syminfo [ <str> ] ) . sunw_filter  else :        return dynamic_section . get_tag ( syminfo [ <str> ] ) . needed   def CollectBinaryElfinfo ( self ) :      md5_sum = self . _compute_md5_sum ( ) if self . rest_client . BlobExists ( <str> , md5_sum ) :        logging . debug ( <str> , self . _binary_path ) return md5_sum  sections = self . _get_sections_of_interest ( <str> , <str> , <str> , <str> ) versions_needed = [ ] if <str> in sections :        for verneed , vernaux_iter in sections [ <str> ] . iter_versions ( ) :          versions_needed . extend ( [ { <str> : vernaux [ <str> ] , <str> : verneed . name , <str> : vernaux . name } for vernaux in vernaux_iter ] )  versions_needed . sort ( key = lambda x : x [ <str> ] ) for version in versions_needed :          del version [ <str> ]   version_definitions = [ ] if <str> in sections :        for verdef , verdaux_iter in sections [ <str> ] . iter_versions ( ) :          version_name = verdaux_iter . next ( ) . name dependencies = [ x . name for x in verdaux_iter ] version_definitions . append ( { <str> : verdef [ <str> ] , <str> : version_name , <str> : dependencies } )  if version_definitions :          version_definitions . sort ( key = lambda x : x [ <str> ] ) version_definitions . pop ( 0 ) for version in version_definitions :            del version [ <str> ]    symbols = [ ] if <str> in sections :        versions_info = ( version_definitions + versions_needed ) symbol_iter = sections [ <str> ] . iter_symbols ( ) symbol_iter . next ( ) for index , sym in enumerate ( symbol_iter , start = 1 ) :          symbol = { <str> : describe_symbol_bind ( sym [ <str> ] [ <str> ] ) , <str> : self . _describe_symbol_shndx ( sym [ <str> ] ) , <str> : sym . name , <str> : None , <str> : None , <str> : None } if <str> in sections :            versym = sections [ <str> ] . get_symbol ( index ) if not versym [ <str> ] in [ <str> , <str> ] :              version = versions_info [ versym [ <str> ] - 2 ] symbol [ <str> ] = version [ <str> ] if <str> in version :                symbol [ <str> ] = version [ <str> ]    if <str> in sections :            syminfo = sections [ <str> ] . get_symbol ( index ) if ( syminfo [ <str> ] & ( SUNW_SYMINFO_FLAGS . SYMINFO_FLG_DIRECT | SUNW_SYMINFO_FLAGS . SYMINFO_FLG_DIRECTBIND | SUNW_SYMINFO_FLAGS . SYMINFO_FLG_LAZYLOAD | SUNW_SYMINFO_FLAGS . SYMINFO_FLG_FILTER ) and isinstance ( syminfo [ <str> ] , int ) ) :              symbol [ <str> ] = describe_syminfo_flags ( syminfo [ <str> ] ) symbol [ <str> ] = self . _describe_symbol_boundto ( syminfo )   symbols . append ( representations . ElfSymInfo ( ** symbol ) )  symbols . sort ( key = lambda m : m . symbol )  binary_info = { <str> : version_definitions , <str> : versions_needed , <str> : symbols } self . rest_client . SaveBlob ( <str> , md5_sum , binary_info ) return md5_sum  def CollectBinaryDumpinfo ( self ) :      binary_dump_info = { <str> : [ ] , <str> : [ ] , <str> : [ ] , <str> : None } sections = self . _get_sections_of_interest ( <str> ) if <str> in sections :        for dyn_tag in sections [ <str> ] . iter_tags ( ) :          if dyn_tag [ <str> ] == <str> :            binary_dump_info [ <str> ] . append ( dyn_tag . needed )  elif dyn_tag [ <str> ] == <str> :            binary_dump_info [ <str> ] . extend ( dyn_tag . runpath . split ( <str> ) )  elif dyn_tag [ <str> ] == <str> :            binary_dump_info [ <str> ] . extend ( dyn_tag . rpath . split ( <str> ) )  elif dyn_tag [ <str> ] == <str> :            binary_dump_info [ <str> ] = dyn_tag . soname    return binary_dump_info  def GetMachineIdOfBinary ( self ) :      e_machine = self . _elffile . header [ <str> ] if e_machine not in ENUM_E_MACHINE :        logging . warning ( <str> <str> , e_machine ) e_machine = <str>  return ENUM_E_MACHINE [ e_machine ]   if __name__ == <str> :    parser = optparse . OptionParser ( ) parser . add_option ( <str> , <str> , dest = <str> , help = <str> ) parser . add_option ( <str> , dest = <str> , action = <str> , default = False ) options , args = parser . parse_args ( ) if not options . input_file :      sys . stdout . write ( <str> ) sys . exit ( 1 )  logging_level = logging . INFO if options . debug :      logging_level = logging . DEBUG  fmt = <str> logging . basicConfig ( format = fmt , level = logging_level ) extractor = ElfExtractor ( options . input_file , debug = options . debug ) md5_sum = extractor . CollectBinaryElfinfo ( ) return_struct = { <str> : md5_sum , } print ( json . dumps ( return_struct , indent = 2 ) )   