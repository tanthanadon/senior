import collections import copy import getpass import itertools import logging import operator import os . path import pprint import progressbar import re import sqlobject import textwrap from Cheetah import Template from sqlobject import sqlbuilder from lib . python import common_constants from lib . python import configuration from lib . python import database from lib . python import errors from lib . python import models as m from lib . python import mute_progressbar from lib . python import representations from lib . python import rest from lib . python import sharedlib_utils from lib . python import tag DESCRIPTION_RE = <str> SYS_DEFAULT_RUNPATH = [ <str> , <str> , <str> , <str> , ] class CatalogDatabaseError ( errors . Error ) :     class DataError ( errors . Error ) :     class ConfigurationError ( errors . Error ) :     class InternalDataError ( errors . Error ) :     REPORT_TMPL = <str> SCREEN_ERROR_REPORT_TMPL = <str> TAG_REPORT_TMPL = <str> def ExtractDescription ( pkginfo ) :    desc_re = re . compile ( DESCRIPTION_RE ) m = re . match ( desc_re , pkginfo [ <str> ] ) return m . group ( 2 ) if m else None  def ExtractMaintainerName ( pkginfo ) :    maint_re = re . compile ( <str> ) m = re . match ( maint_re , pkginfo [ <str> ] ) return m . group ( 1 ) if m else None  def ExtractBuildUsername ( pkginfo ) :    m = re . match ( common_constants . PSTAMP_RE , pkginfo [ <str> ] ) return m . group ( <str> ) if m else None  class CatalogSpec ( collections . namedtuple ( <str> , [ <str> , <str> , <str> ] ) ) :    def __unicode__ ( self ) :      return <str> % self   class SqlobjectHelperMixin ( object ) :    def __init__ ( self ) :      super ( SqlobjectHelperMixin , self ) . __init__ ( ) self . triad_cache = { }  def GetSqlobjectTriad ( self , osrel , arch , catrel ) :      key = ( osrel , arch , catrel ) if key not in self . triad_cache :        logging . debug ( <str> , osrel , arch , catrel ) sqo_arch = m . Architecture . select ( m . Architecture . q . name == arch ) . getOne ( ) sqo_osrel = m . OsRelease . select ( m . OsRelease . q . short_name == osrel ) . getOne ( ) sqo_catrel = m . CatalogRelease . select ( m . CatalogRelease . q . name == catrel ) . getOne ( ) self . triad_cache [ key ] = sqo_osrel , sqo_arch , sqo_catrel  return self . triad_cache [ key ]   def ElfinfoBlobToStruct ( elfdump_data ) :    symbols = elfdump_data [ <str> ] for idx , symbol_as_list in enumerate ( symbols ) :      symbols [ idx ] = representations . ElfSymInfo ( * symbol_as_list )  return elfdump_data  class LazyElfinfo ( object ) :    def __init__ ( self , rest_client ) :      self . rest_client = rest_client  def __getitem__ ( self , md5_sum ) :      elfdump_data = self . rest_client . GetBlob ( <str> , md5_sum ) return ElfinfoBlobToStruct ( elfdump_data )   class CheckpkgManagerBase ( SqlobjectHelperMixin ) :    def __init__ ( self , name , sqo_pkgs_list , osrel , arch , catrel , debug = False , show_progress = False ) :      super ( CheckpkgManagerBase , self ) . __init__ ( ) self . debug = debug self . name = name self . sqo_pkgs_list = sqo_pkgs_list self . osrel = osrel self . arch = arch self . catrel = catrel self . show_progress = show_progress self . _ResetState ( ) self . individual_checks = [ ] self . set_checks = [ ] config = configuration . GetConfig ( ) username , password = rest . GetUsernameAndPassword ( ) self . rest_client = rest . RestClient ( pkgdb_url = config . get ( <str> , <str> ) , releases_url = config . get ( <str> , <str> ) , username = username , password = password )  def _ResetState ( self ) :      self . errors = [ ] self . packages = [ ]  def GetProgressBar ( self ) :      if self . show_progress and not self . debug :        return progressbar . ProgressBar ( )  else :        return mute_progressbar . MuteProgressBar ( )   def GetSqlobjectTriad ( self ) :       return super ( CheckpkgManagerBase , self ) . GetSqlobjectTriad ( self . osrel , self . arch , self . catrel )  def FormatReports ( self , errors , messages , gar_lines ) :      namespace = { <str> : self . name , <str> : errors , <str> : self . debug , <str> : textwrap , <str> : messages , <str> : gar_lines , } screen_t = Template . Template ( SCREEN_ERROR_REPORT_TMPL , searchList = [ namespace ] ) tags_report_t = Template . Template ( TAG_REPORT_TMPL , searchList = [ namespace ] ) return screen_t , tags_report_t  def SetErrorsToDict ( self , set_errors , a_dict ) :      errors = copy . copy ( a_dict ) for tag in set_errors :        if tag . pkgname :          if not tag . pkgname in errors :            errors [ tag . pkgname ] = [ ]  errors [ tag . pkgname ] . append ( tag )  else :          if <str> not in errors :            errors [ <str> ] = [ ]  errors [ <str> ] . append ( tag )   return errors  def GetOptimizedAllStats ( self , stats_obj_list ) :      logging . info ( <str> ) pkgs_data = [ ] counter = itertools . count ( ) length = len ( stats_obj_list ) pbar = self . GetProgressBar ( ) pbar . maxval = length pbar . start ( ) for stats_obj in stats_obj_list :        raw_pkg_data = self . rest_client . GetBlob ( <str> , stats_obj . md5_sum ) raw_pkg_data [ <str> ] = LazyElfinfo ( self . rest_client ) pkgs_data . append ( raw_pkg_data ) pbar . update ( counter . next ( ) )  pbar . finish ( ) return pkgs_data  def Run ( self ) :      self . _ResetState ( ) assert self . sqo_pkgs_list , <str> db_stat_objs_by_pkgname = { } for pkg in self . sqo_pkgs_list :        db_stat_objs_by_pkgname [ pkg . pkginst . pkgname ] = pkg  logging . debug ( <str> ) sqo_os_rel , sqo_arch , sqo_catrel = self . GetSqlobjectTriad ( ) overrides_by_pkgname = { } for pkgname , db_obj in db_stat_objs_by_pkgname . iteritems ( ) :        db_obj . RemoveCheckpkgResults ( sqo_os_rel , sqo_arch , sqo_catrel ) overrides_by_pkgname [ pkgname ] = list ( db_obj . GetOverridesResult ( ) )  errors , messages , gar_lines = self . GetAllTags ( self . sqo_pkgs_list ) pbar = self . GetProgressBar ( ) pbar . maxval = len ( errors ) + 1 count = itertools . count ( 1 ) logging . info ( <str> ) pbar . start ( ) for pkgname , es in errors . iteritems ( ) :        logging . debug ( <str> , pkgname ) for e in es :          if e . pkgname not in db_stat_objs_by_pkgname :            logging . debug ( <str> , e . pkgname ) continue  tag_info = e . tag_info if tag_info is not None :            if not isinstance ( tag_info , unicode ) :              tag_info = unicode ( tag_info , <str> )   error_tag_in_db = m . CheckpkgErrorTag ( srv4_file = db_stat_objs_by_pkgname [ e . pkgname ] , pkgname = e . pkgname , tag_name = e . tag_name , tag_info = tag_info , msg = e . msg , os_rel = sqo_os_rel , catrel = sqo_catrel , arch = sqo_arch ) overridden = False for override in overrides_by_pkgname [ pkgname ] :            if override . DoesApply ( error_tag_in_db ) :              logging . debug ( <str> , override , error_tag_in_db ) overridden = True break   error_tag_in_db . overridden = overridden  pbar . update ( count . next ( ) )  pbar . finish ( ) flat_error_list = reduce ( operator . add , errors . values ( ) , [ ] ) screen_report , tags_report = self . FormatReports ( errors , messages , gar_lines ) exit_code = 0 return ( exit_code , screen_report , tags_report )   NeededFile = collections . namedtuple ( <str> , <str> ) NeededPackage = collections . namedtuple ( <str> , <str> ) class CheckInterfaceBase ( object ) :    def __init__ ( self , osrel , arch , catrel , catalog , pkg_set_files , lines_dict = None , rest_client = None ) :      self . osrel = osrel self . arch = arch self . catrel = catrel self . catalog = catalog self . common_paths = { } self . pkgs_by_path_cache = { } if lines_dict :        self . lines_dict = lines_dict  else :        self . lines_dict = { }  self . needed_files = [ ] self . needed_pkgs = [ ] self . __errors = [ ] self . pkg_set_files = pkg_set_files self . pkgs_by_file = { } self . pkgs_by_basename = { } for pkgname in self . pkg_set_files :        for base_path , base_name in self . pkg_set_files [ pkgname ] :          full_path = os . path . join ( base_path , base_name ) self . pkgs_by_file . setdefault ( full_path , set ( ) ) self . pkgs_by_file [ full_path ] . add ( pkgname ) self . pkgs_by_basename . setdefault ( base_name , { } ) self . pkgs_by_basename [ base_name ] . setdefault ( base_path , set ( ) ) self . pkgs_by_basename [ base_name ] [ base_path ] . add ( pkgname )   self . rest_client = rest_client  def GetErrors ( self ) :      return self . __errors  errors = property ( GetErrors ) def AddError ( self , error ) :      self . __errors . append ( error )  def GetPathsAndPkgnamesByBasename ( self , basename ) :      paths_and_pkgs = self . rest_client . GetPathsAndPkgnamesByBasename ( self . catrel , self . arch , self . osrel , basename ) for catalog_path in paths_and_pkgs :        for pkgname in self . pkg_set_files :          if pkgname in paths_and_pkgs [ catalog_path ] :            paths_and_pkgs [ catalog_path ] . remove ( pkgname )    if basename in self . pkgs_by_basename :        for path in self . pkgs_by_basename [ basename ] :          for pkg in self . pkgs_by_basename [ basename ] [ path ] :            paths = paths_and_pkgs . setdefault ( path , [ ] ) paths . append ( pkg )    return paths_and_pkgs  def GetPkgByPath ( self , file_path ) :      key = ( file_path , self . osrel , self . arch , self . catrel ) if not key in self . pkgs_by_path_cache :        pkgs_in_catalog = self . catalog . GetPkgByPath ( file_path , self . osrel , self . arch , self . catrel ) pkgs = set ( pkgs_in_catalog . difference ( set ( self . pkg_set_files ) ) ) if file_path in self . pkgs_by_file :          for pkg in self . pkgs_by_file [ file_path ] :            pkgs . add ( pkg )   self . pkgs_by_path_cache [ key ] = pkgs  return self . pkgs_by_path_cache [ key ]  def GetPkgByPkgname ( self , pkgname ) :      return self . rest_client . Srv4ByCatalogAndPkgname ( self . catrel , self . arch , self . osrel , pkgname )  def GetInstalledPackages ( self ) :      return self . catalog . GetInstalledPackages ( self . osrel , self . arch , self . catrel )  def _GetPathsForArch ( self , arch ) :      if not arch in self . lines_dict :        base_name = <str> % arch paths = [ os . path . join ( os . path . dirname ( __file__ ) , <str> , <str> , <str> , base_name ) , os . path . join ( common_constants . OPENCSW_SHARE , <str> , base_name ) ] path_found = False for file_name in paths :          if not os . path . exists ( file_name ) :            continue  path_found = True logging . debug ( <str> , file_name ) with open ( file_name , <str> ) as f :            self . lines_dict [ arch ] = f . read ( ) . splitlines ( )  break  if not path_found :          raise DataError ( <str> % base_name )   return self . lines_dict [ arch ]  def GetCommonPaths ( self , arch ) :      if arch not in ( <str> , <str> , <str> ) :        logging . warn ( <str> , repr ( arch ) ) return [ ]  if arch == <str> :        archs = ( <str> , <str> )  else :        archs = [ arch ]  lines = [ ] for arch in archs :        lines . extend ( self . _GetPathsForArch ( arch ) )  return lines  def _NeedFile ( self , pkgname , full_path , reason ) :      self . needed_files . append ( NeededFile ( pkgname , full_path , reason ) )  def _NeedPackage ( self , pkgname , needed_pkg , reason ) :      self . needed_pkgs . append ( NeededPackage ( pkgname , needed_pkg , reason ) )  def ReportErrorForPkgname ( self , pkgname , tag_name , tag_info = None , msg = None ) :      checkpkg_tag = tag . CheckpkgTag ( pkgname , tag_name , tag_info , msg = msg ) self . AddError ( checkpkg_tag )  def GetElfdumpInfo ( self , md5_sum ) :      elfdump_data = self . rest_client . GetBlob ( <str> , md5_sum ) return ElfinfoBlobToStruct ( elfdump_data )   class IndividualCheckInterface ( CheckInterfaceBase ) :    def __init__ ( self , pkgname , osrel , arch , catrel , catalog , pkg_set_files , rest_client ) :      super ( IndividualCheckInterface , self ) . __init__ ( osrel , arch , catrel , catalog , pkg_set_files , rest_client = rest_client ) self . pkgname = pkgname  def ReportError ( self , tag_name , tag_info = None , msg = None ) :      self . ReportErrorForPkgname ( self . pkgname , tag_name , tag_info , msg = msg )  def NeedFile ( self , full_path , reason ) :      self . _NeedFile ( self . pkgname , full_path , reason )  def NeedPackage ( self , needed_pkg , reason ) :      self . _NeedPackage ( self . pkgname , needed_pkg , reason )   class SetCheckInterface ( CheckInterfaceBase ) :    def __init__ ( self , osrel , arch , catrel , catalog , pkg_set_files , rest_client ) :      super ( SetCheckInterface , self ) . __init__ ( osrel , arch , catrel , catalog , pkg_set_files , rest_client = rest_client )  def NeedFile ( self , pkgname , full_path , reason ) :      self . _NeedFile ( pkgname , full_path , reason )  def NeedPackage ( self , pkgname , needed_pkg , reason ) :      self . _NeedPackage ( pkgname , needed_pkg , reason )  def ReportError ( self , pkgname , tag_name , tag_info = None , msg = None ) :      self . ReportErrorForPkgname ( pkgname , tag_name , tag_info , msg )   class CheckpkgMessenger ( object ) :    def __init__ ( self ) :      self . messages = [ ] self . one_time_messages = { } self . gar_lines = [ ]  def Message ( self , m ) :      self . messages . append ( m )  def OneTimeMessage ( self , key , m ) :      if key not in self . one_time_messages :        self . one_time_messages [ key ] = m   def SuggestGarLine ( self , m ) :      self . gar_lines . append ( m )   class CheckpkgManager2 ( CheckpkgManagerBase ) :    def __init__ ( self , * args , ** kwargs ) :      super ( CheckpkgManager2 , self ) . __init__ ( * args , ** kwargs ) self . checks_registered = False  def _RegisterIndividualCheck ( self , function ) :      self . individual_checks . append ( function )  def _RegisterSetCheck ( self , function ) :      self . set_checks . append ( function )  def _AutoregisterChecks ( self ) :      logging . debug ( <str> ) if self . checks_registered :        logging . debug ( <str> ) return  from lib . python import package_checks checkpkg_module = package_checks members = dir ( checkpkg_module ) for member_name in members :        logging . debug ( <str> , repr ( member_name ) ) member = getattr ( checkpkg_module , member_name ) if callable ( member ) :          if member_name . startswith ( <str> ) :            logging . debug ( <str> , repr ( member_name ) ) self . _RegisterIndividualCheck ( member )  elif member_name . startswith ( <str> ) :            logging . debug ( <str> , repr ( member_name ) ) self . _RegisterSetCheck ( member )    self . checks_registered = True  def _ReportDependencies ( self , checkpkg_interface , needed_files , needed_pkgs , messenger , declared_deps_by_pkgname ) :      reasons_by_pkg_by_pkgname = { } pkgs_by_reasons_by_pkgname = { } needed_pkgs = copy . deepcopy ( needed_pkgs ) unsatisfied_needed_files = [ ] for needed_file in needed_files :        pkgname , full_path , reason = needed_file logging . debug ( <str> , pkgname , full_path , reason ) needed_pkgnames = checkpkg_interface . GetPkgByPath ( full_path ) if needed_pkgnames :          for needed_pkgname in needed_pkgnames :            needed_pkg = NeededPackage ( pkgname , needed_pkgname , reason ) logging . debug ( <str> , needed_pkg ) needed_pkgs . append ( needed_pkg )   else :          logging . warning ( <str> , full_path ) unsatisfied_needed_files . append ( needed_file )   for pkgname , needed_pkgname , reason in needed_pkgs :        reasons_by_pkg_by_pkgname . setdefault ( pkgname , { } ) reasons_by_pkg_by_pkgname [ pkgname ] . setdefault ( needed_pkgname , [ ] ) reasons_by_pkg_by_pkgname [ pkgname ] [ needed_pkgname ] . append ( reason ) pkgs_by_reasons_by_pkgname . setdefault ( pkgname , { } ) pkgs_by_reasons_by_pkgname [ pkgname ] . setdefault ( reason , [ ] ) pkgs_by_reasons_by_pkgname [ pkgname ] [ reason ] . append ( needed_pkgname )  req_pkgs_reasons_by_pkgname = { } for pkgname in pkgs_by_reasons_by_pkgname :        for reason in pkgs_by_reasons_by_pkgname [ pkgname ] :          reason_group = [ ] for needed_pkg in pkgs_by_reasons_by_pkgname [ pkgname ] [ reason ] :            reason_group . append ( ( needed_pkg , reason ) )  req_pkgs_reasons_by_pkgname . setdefault ( pkgname , [ ] ) req_pkgs_reasons_by_pkgname [ pkgname ] . append ( reason_group )   for pkgname in declared_deps_by_pkgname :        declared_deps = declared_deps_by_pkgname [ pkgname ] req_pkgs_reasons_by_pkgname . setdefault ( pkgname , [ ] ) ( missing_deps_reasons_by_pkg , surplus_deps , missing_dep_groups ) = self . _ReportMissingDependencies ( checkpkg_interface , pkgname , declared_deps , req_pkgs_reasons_by_pkgname [ pkgname ] ) namespace = { <str> : pkgname , <str> : missing_deps_reasons_by_pkg , <str> : surplus_deps , <str> : None , } t = Template . Template ( REPORT_TMPL , searchList = [ namespace ] ) report = unicode ( t ) if report . strip ( ) :          for line in report . splitlines ( ) :            messenger . Message ( line )   for missing_deps in missing_dep_groups :          alternatives = False prefix = <str> if len ( missing_deps ) > 1 :            alternatives = True prefix = <str>  if alternatives :            messenger . SuggestGarLine ( <str> )  for missing_dep in missing_deps :            messenger . SuggestGarLine ( <str> % ( prefix , pkgname , missing_dep ) )  if alternatives :            messenger . SuggestGarLine ( <str> )    for unsatisfied_file in unsatisfied_needed_files :        if unsatisfied_file . full_path == <str> :          continue  checkpkg_interface . ReportErrorForPkgname ( unsatisfied_file . pkgname , <str> , <str> % ( unsatisfied_file . full_path , unsatisfied_file . reason ) )   def _ReportMissingDependencies ( self , error_mgr , pkgname , declared_deps , req_pkgs_reasons ) :      missing_reasons_by_pkg = { } for reason_group in req_pkgs_reasons :        for pkg , reason in reason_group :          missing_reasons_by_pkg . setdefault ( pkg , [ ] ) missing_reasons_by_pkg [ pkg ] . append ( reason )   missing_dep_groups = self . _MissingDepsFromReasonGroups ( pkgname , req_pkgs_reasons , declared_deps ) missing_dep_groups = self . _RemovePkgsFromMissing ( pkgname , missing_dep_groups ) potential_req_pkgs = set ( ( x for x , y in reduce ( operator . add , req_pkgs_reasons , [ ] ) ) ) surplus_deps = self . _GetSurplusDeps ( pkgname , potential_req_pkgs , declared_deps ) missing_deps_reasons_by_pkg = [ ] missing_deps_idx = set ( ) for missing_deps in missing_dep_groups :        error_mgr . ReportErrorForPkgname ( pkgname , <str> , <str> . join ( sorted ( missing_deps ) ) ) for missing_dep in missing_deps :          item = ( missing_dep , tuple ( missing_reasons_by_pkg [ missing_dep ] ) ) if item not in missing_deps_idx :            missing_deps_reasons_by_pkg . append ( item ) missing_deps_idx . add ( item )    for surplus_dep in surplus_deps :        error_mgr . ReportErrorForPkgname ( pkgname , <str> , surplus_dep )  return missing_deps_reasons_by_pkg , surplus_deps , missing_dep_groups  def _MissingDepsFromReasonGroups ( self , for_pkgname , reason_groups , declared_deps_set ) :      missing_dep_groups = [ ] for reason_group in reason_groups :        dependency_fulfilled = False for pkgname , reason in reason_group :          if pkgname == for_pkgname or pkgname in declared_deps_set :            logging . debug ( <str> , reason , pkgname ) dependency_fulfilled = True break   if not dependency_fulfilled :          pkgnames = [ x for x , y in reason_group ] missing_dep_groups . append ( pkgnames )   return missing_dep_groups  def _GetSurplusDeps ( self , pkgname , potential_req_pkgs , declared_deps ) :      logging . debug ( <str> , pkgname , declared_deps , potential_req_pkgs ) surplus_deps = declared_deps . difference ( potential_req_pkgs ) no_report_surplus = set ( ) for sp_regex in common_constants . DO_NOT_REPORT_SURPLUS :        for maybe_surplus in surplus_deps :          if re . match ( sp_regex , maybe_surplus ) :            logging . debug ( <str> , maybe_surplus , sp_regex ) no_report_surplus . add ( maybe_surplus )    surplus_deps = surplus_deps . difference ( no_report_surplus ) if surplus_deps :        for regex_str in common_constants . DO_NOT_REPORT_SURPLUS_FOR :          if re . match ( regex_str , pkgname ) :            logging . debug ( <str> <str> , regex_str ) surplus_deps = frozenset ( ) break    return surplus_deps  def _RemovePkgsFromMissing ( self , pkgname , missing_dep_groups ) :      <str> pkgs_to_remove = set ( ) missing_deps_flat = set ( reduce ( operator . add , missing_dep_groups , [ ] ) ) for regex_str in common_constants . DO_NOT_REPORT_MISSING_RE :        regex = re . compile ( regex_str ) for dep_pkgname in missing_deps_flat :          if re . match ( regex , dep_pkgname ) :            pkgs_to_remove . add ( dep_pkgname )    if pkgname in missing_deps_flat :        pkgs_to_remove . add ( pkgname )  logging . debug ( <str> , pkgs_to_remove ) new_missing_dep_groups = set ( ) for missing_deps_group in missing_dep_groups :        new_missing_deps_group = set ( ) for dep in missing_deps_group :          if dep not in pkgs_to_remove :            new_missing_deps_group . add ( dep )   if new_missing_deps_group :          new_missing_dep_groups . add ( frozenset ( new_missing_deps_group ) )   return new_missing_dep_groups  def _ExaminedFilesByPkg ( self , pkgs_data ) :      examined_files_by_pkg = { } for pkg_data in pkgs_data :        pkgname = pkg_data [ <str> ] [ <str> ] examined_files_by_pkg . setdefault ( pkgname , set ( ) ) for entry in pkg_data [ <str> ] :          entry = representations . PkgmapEntry . _make ( entry ) if entry . path :            base_path , base_name = os . path . split ( entry . path ) examined_files_by_pkg [ pkgname ] . add ( ( base_path , base_name ) )    return examined_files_by_pkg  def GetAllTags ( self , stats_obj_list ) :      errors = { } catalog = Catalog ( ) logging . debug ( <str> ) pkgs_data = self . GetOptimizedAllStats ( stats_obj_list ) logging . debug ( <str> ) messenger = CheckpkgMessenger ( ) count = itertools . count ( ) pbar = self . GetProgressBar ( ) pbar . maxval = len ( pkgs_data ) * len ( self . individual_checks ) logging . info ( <str> ) needed_files = [ ] needed_pkgs = [ ] pbar . start ( ) declared_deps_by_pkgname = { } examined_files_by_pkg = self . _ExaminedFilesByPkg ( pkgs_data ) for pkg_data in pkgs_data :        pkgname = pkg_data [ <str> ] [ <str> ] check_interface = IndividualCheckInterface ( pkgname , self . osrel , self . arch , self . catrel , catalog , examined_files_by_pkg , rest_client = self . rest_client ) for function in self . individual_checks :          logger = logging . getLogger ( <str> % ( pkgname , function . __name__ ) ) logger . debug ( <str> , function . __name__ ) function ( pkg_data , check_interface , logger = logger , messenger = messenger ) pbar . update ( count . next ( ) )  if check_interface . errors :          errors [ pkgname ] = check_interface . errors  for needed_file in check_interface . needed_files :          assert pkgname == needed_file . pkgname , ( <str> % ( pkgname , needed_file . pkgname ) )  for needed_pkg in check_interface . needed_pkgs :          assert pkgname == needed_pkg . pkgname , ( <str> % ( pkgname , needed_pkg . pkgname ) )  needed_files . extend ( check_interface . needed_files ) needed_pkgs . extend ( check_interface . needed_pkgs ) declared_deps_by_pkgname [ pkgname ] = frozenset ( x [ 0 ] for x in pkg_data [ <str> ] )  pbar . finish ( ) logging . info ( <str> ) for function in self . set_checks :        logger = logging . getLogger ( <str> + function . __name__ ) check_interface = SetCheckInterface ( self . osrel , self . arch , self . catrel , catalog , examined_files_by_pkg , rest_client = self . rest_client ) logger . debug ( <str> , function . __name__ ) function ( pkgs_data , check_interface , logger = logger , messenger = messenger ) if check_interface . errors :          errors = self . SetErrorsToDict ( check_interface . errors , errors )  needed_files . extend ( check_interface . needed_files ) needed_pkgs . extend ( check_interface . needed_pkgs )  check_interface = SetCheckInterface ( self . osrel , self . arch , self . catrel , catalog , examined_files_by_pkg , rest_client = self . rest_client ) self . _ReportDependencies ( check_interface , needed_files , needed_pkgs , messenger , declared_deps_by_pkgname ) errors = self . SetErrorsToDict ( check_interface . errors , errors ) messages = messenger . messages + messenger . one_time_messages . values ( ) return errors , messages , messenger . gar_lines  def Run ( self ) :      self . _AutoregisterChecks ( ) return super ( CheckpkgManager2 , self ) . Run ( )   def SliceList ( l , size ) :    idxes = xrange ( 0 , len ( l ) , size ) sliced = [ l [ i : i + size ] for i in idxes ] return sliced  class Catalog ( SqlobjectHelperMixin ) :    def __init__ ( self ) :      super ( Catalog , self ) . __init__ ( ) self . pkgs_by_path_cache = { } self . logger = logging . getLogger ( <str> )  def GetInstalledPackages ( self , osrel , arch , catrel ) :      sqo_osrel , sqo_arch , sqo_catrel = self . GetSqlobjectTriad ( osrel , arch , catrel ) self . logger . debug ( <str> % ( osrel , arch , catrel ) ) oac = sqlobject . AND ( m . Srv4FileInCatalog . q . osrel == sqo_osrel , m . Srv4FileInCatalog . q . arch == sqo_arch , m . Srv4FileInCatalog . q . catrel == sqo_catrel ) join = [ sqlbuilder . INNERJOINOn ( None , m . Srv4FileStats , m . Pkginst . q . id == m . Srv4FileStats . q . pkginst ) , sqlbuilder . INNERJOINOn ( None , m . Srv4FileInCatalog , m . Srv4FileStats . q . id == m . Srv4FileInCatalog . q . srv4file ) , ] res = m . Pkginst . select ( oac , join = join ) return [ x . pkgname for x in res ]  def GetPathsAndPkgnamesByBasename ( self , basename , osrel , arch , catrel ) :      pkgs = { } sqo_osrel , sqo_arch , sqo_catrel = self . GetSqlobjectTriad ( osrel , arch , catrel ) connection = m . CswFile . _connection join = [ sqlbuilder . INNERJOINOn ( None , m . Pkginst , m . CswFile . q . pkginst == m . Pkginst . q . id ) , sqlbuilder . INNERJOINOn ( None , m . Srv4FileStats , m . CswFile . q . srv4_file == m . Srv4FileStats . q . id ) , sqlbuilder . INNERJOINOn ( None , m . Srv4FileInCatalog , m . Srv4FileStats . q . id == m . Srv4FileInCatalog . q . srv4file ) , ] where = sqlobject . AND ( m . CswFile . q . basename == basename , m . Srv4FileInCatalog . q . osrel == sqo_osrel , m . Srv4FileInCatalog . q . arch == sqo_arch , m . Srv4FileInCatalog . q . catrel == sqo_catrel , ) query = connection . sqlrepr ( sqlbuilder . Select ( [ m . CswFile . q . path , m . Pkginst . q . pkgname ] , where = where , join = join ) ) rows = connection . queryAll ( query ) pkgs = { } for row in rows :        file_path , pkginst = row pkgs . setdefault ( file_path , [ ] ) . append ( pkginst )  logging . debug ( <str> <str> , repr ( basename ) , pprint . pformat ( pkgs ) ) return pkgs  def GetPathsAndPkgnamesByBasedir ( self , basedir , osrel , arch , catrel ) :      sqo_osrel , sqo_arch , sqo_catrel = self . GetSqlobjectTriad ( osrel , arch , catrel ) connection = m . CswFile . _connection join = [ sqlbuilder . INNERJOINOn ( None , m . Pkginst , m . CswFile . q . pkginst == m . Pkginst . q . id ) , sqlbuilder . INNERJOINOn ( None , m . Srv4FileStats , m . CswFile . q . srv4_file == m . Srv4FileStats . q . id ) , sqlbuilder . INNERJOINOn ( None , m . Srv4FileInCatalog , m . Srv4FileStats . q . id == m . Srv4FileInCatalog . q . srv4file ) , ] where = sqlobject . AND ( m . CswFile . q . path == basedir , m . Srv4FileInCatalog . q . osrel == sqo_osrel , m . Srv4FileInCatalog . q . arch == sqo_arch , m . Srv4FileInCatalog . q . catrel == sqo_catrel , ) query = connection . sqlrepr ( sqlbuilder . Select ( [ m . CswFile . q . basename , m . Pkginst . q . pkgname ] , where = where , join = join ) ) rows = connection . queryAll ( query ) pkgs = { } for row in rows :        basename , pkginst = row pkgs . setdefault ( pkginst , [ ] ) . append ( basename )  return pkgs  def GetPkgByPath ( self , full_file_path , osrel , arch , catrel ) :      key = ( full_file_path , osrel , arch , catrel ) if key not in self . pkgs_by_path_cache :        file_path , basename = os . path . split ( full_file_path ) sqo_osrel , sqo_arch , sqo_catrel = self . GetSqlobjectTriad ( osrel , arch , catrel ) oac = sqlobject . AND ( m . Srv4FileInCatalog . q . osrel == sqo_osrel , m . Srv4FileInCatalog . q . arch == sqo_arch , m . Srv4FileInCatalog . q . catrel == sqo_catrel ) path_filter = sqlobject . AND ( oac , m . CswFile . q . path == file_path , m . CswFile . q . basename == basename , m . Srv4FileStats . q . registered_level_two == True ) join = [ sqlbuilder . INNERJOINOn ( None , m . Srv4FileStats , m . Pkginst . q . id == m . Srv4FileStats . q . pkginst ) , sqlbuilder . INNERJOINOn ( None , m . Srv4FileInCatalog , m . Srv4FileStats . q . id == m . Srv4FileInCatalog . q . srv4file ) , sqlbuilder . INNERJOINOn ( None , m . CswFile , m . Srv4FileStats . q . id == m . CswFile . q . srv4_file ) , ] res = m . Pkginst . select ( path_filter , join = join ) pkgs = [ x . pkgname for x in res ] self . pkgs_by_path_cache [ key ] = frozenset ( pkgs )  return self . pkgs_by_path_cache [ key ]  def CommonArchByString ( self , s ) :      return sharedlib_utils . ArchByString ( s )  def Srv4MatchesCatalog ( self , sqo_srv4 , sqo_arch ) :      cat_arch = self . CommonArchByString ( sqo_arch . name ) pkg_arch = self . CommonArchByString ( sqo_srv4 . arch . name ) ans = ( cat_arch == pkg_arch ) or ( pkg_arch == common_constants . ARCH_ALL ) if not ans :        logging . debug ( <str> , cat_arch , pkg_arch , pkg_arch , common_constants . ARCH_ALL ) filename_arch = self . CommonArchByString ( sqo_srv4 . filename_arch . name ) if filename_arch == common_constants . ARCH_ALL :          ans = True  if filename_arch != pkg_arch :          logging . warning ( <str> , sqo_srv4 , repr ( pkg_arch ) , repr ( filename_arch ) )   return ans  def GetConflictingSrv4ByCatalognameResult ( self , sqo_srv4 , catalogname , sqo_osrel , sqo_arch , sqo_catrel , trans ) :      res = m . Srv4FileStats . select ( m . Srv4FileStats . q . catalogname == catalogname , forUpdate = True , connection = trans ) . throughTo . in_catalogs . filter ( sqlobject . AND ( m . Srv4FileInCatalog . q . osrel == sqo_osrel , m . Srv4FileInCatalog . q . arch == sqo_arch , m . Srv4FileInCatalog . q . catrel == sqo_catrel , m . Srv4FileInCatalog . q . srv4file != sqo_srv4 ) ) return res  def GetConflictingSrv4ByPkgnameResult ( self , sqo_srv4 , pkgname , sqo_osrel , sqo_arch , sqo_catrel , trans ) :      pkginst = sqo_srv4 . pkginst res = m . Srv4FileStats . select ( m . Srv4FileStats . q . pkginst == pkginst , forUpdate = True , connection = trans ) . throughTo . in_catalogs . filter ( sqlobject . AND ( m . Srv4FileInCatalog . q . osrel == sqo_osrel , m . Srv4FileInCatalog . q . arch == sqo_arch , m . Srv4FileInCatalog . q . catrel == sqo_catrel , m . Srv4FileInCatalog . q . srv4file != sqo_srv4 ) ) return res  def AddSrv4ToCatalog ( self , sqo_srv4 , osrel , arch , catrel , who , trans ) :      self . logger . debug ( <str> , sqo_srv4 , osrel , arch , catrel , who ) if not who :        who = <str>  if arch not in ( <str> , <str> ) :        raise CatalogDatabaseError ( <str> % arch )  sqo_osrel , sqo_arch , sqo_catrel = self . GetSqlobjectTriad ( osrel , arch , catrel ) if not self . Srv4MatchesCatalog ( sqo_srv4 , sqo_arch ) :        raise CatalogDatabaseError ( <str> <str> % ( sqo_srv4 , osrel , arch , catrel ) )  if not sqo_srv4 . registered_level_two :        raise CatalogDatabaseError ( <str> % ( sqo_srv4 . basename , sqo_srv4 . md5_sum ) )  res = self . GetConflictingSrv4ByPkgnameResult ( sqo_srv4 , sqo_srv4 . pkginst . pkgname , sqo_osrel , sqo_arch , sqo_catrel , trans ) if res . count ( ) :        raise CatalogDatabaseError ( <str> % pkginst . pkgname )  res = self . GetConflictingSrv4ByCatalognameResult ( sqo_srv4 , sqo_srv4 . catalogname , sqo_osrel , sqo_arch , sqo_catrel , trans ) if res . count ( ) :        raise CatalogDatabaseError ( <str> % sqo_srv4 )  res = m . Srv4FileInCatalog . select ( sqlobject . AND ( m . Srv4FileInCatalog . q . osrel == sqo_osrel , m . Srv4FileInCatalog . q . arch == sqo_arch , m . Srv4FileInCatalog . q . catrel == sqo_catrel , m . Srv4FileInCatalog . q . srv4file == sqo_srv4 ) , connection = trans ) if res . count ( ) :        self . logger . debug ( <str> , sqo_srv4 , osrel , arch , catrel , res . count ( ) ) return  pkg_in_cat = m . Srv4FileInCatalog ( arch = sqo_arch , osrel = sqo_osrel , catrel = sqo_catrel , srv4file = sqo_srv4 , created_by = who , connection = trans ) self . logger . debug ( <str> , sqo_srv4 . basename , osrel , arch , catrel , pkg_in_cat )  def RemoveSrv4 ( self , sqo_srv4 , osrel , arch , catrel , trans ) :      catspec = CatalogSpec ( catrel , arch , osrel ) self . logger . debug ( <str> % ( sqo_srv4 , catspec ) ) sqo_osrel , sqo_arch , sqo_catrel = self . GetSqlobjectTriad ( osrel , arch , catrel ) try :        sqo_srv4_in_cat = m . Srv4FileInCatalog . select ( sqlobject . AND ( m . Srv4FileInCatalog . q . arch == sqo_arch , m . Srv4FileInCatalog . q . osrel == sqo_osrel , m . Srv4FileInCatalog . q . catrel == sqo_catrel , m . Srv4FileInCatalog . q . srv4file == sqo_srv4 ) , forUpdate = True , connection = trans ) . getOne ( ) sqo_srv4_in_cat . destroySelf ( ) self . logger . debug ( <str> % ( sqo_srv4 , catspec ) )  except sqlobject . main . SQLObjectNotFound as e :        self . logger . debug ( <str> , sqo_srv4 , catspec ) self . logger . warning ( e )     