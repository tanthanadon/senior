import copy import re import os . path import common_constants from lib . python import representations class Error ( Exception ) :     class DataError ( Error ) :     LEGIT_CHAR_RE = re . compile ( <str> ) SONAME_VERSION_RE = re . compile ( <str> ) BIN_MIMETYPES = ( <str> , <str> , ) class Error ( Exception ) :    pass  class ArchitectureError ( Error ) :    pass  class DataInconsistencyError ( Error ) :     def ParseLibPath ( directory ) :    arch_subdirs = ( common_constants . SPARCV8_PATHS + common_constants . SPARCV8PLUS_PATHS + common_constants . SPARCV9_PATHS + common_constants . INTEL_386_PATHS + common_constants . AMD64_PATHS ) arch_subdirs = [ x . replace ( <str> , <str> ) for x in arch_subdirs ] linkable_re = re . compile ( <str> <str> <str> % <str> . join ( arch_subdirs ) ) m = linkable_re . match ( directory ) return m . groupdict ( ) if m else False  def IsLibraryLinkable ( file_path ) :    blacklist = [ re . compile ( <str> ) , re . compile ( <str> ) , ] file_dir , file_basename = os . path . split ( file_path ) if ParseLibPath ( file_dir ) :      for regex in blacklist :        if regex . match ( file_dir ) :          return False   return True  return False  def SonameToStringWithChar ( s , c ) :    def CharType ( mychar ) :      if mychar . isalpha ( ) :        return <str>  elif mychar . isdigit ( ) :        return <str>  else :        return <str>   parts = LEGIT_CHAR_RE . findall ( s ) if <str> in parts :      parts . remove ( <str> )  prev_type = <str> new_parts = [ ] for part in parts :      first_type = CharType ( part [ 0 ] ) need_sep = False if ( first_type == prev_type and ( prev_type == <str> or prev_type == <str> ) ) :        need_sep = True  if need_sep :        new_parts . append ( c )  new_parts . append ( part ) prev_type = CharType ( part [ - 1 ] )  return <str> . join ( new_parts ) . lower ( )  def SanitizeWithChar ( s , c ) :    parts = LEGIT_CHAR_RE . findall ( s ) if <str> in parts :      parts . remove ( <str> )  return c . join ( parts ) . lower ( )  def ExtractPrefix ( path ) :    parsed = ParseLibPath ( path ) if parsed :      return parsed [ <str> ]  else :      return parsed   def MakePackageNameBySoname ( soname , path = None ) :    def AddSeparator ( d , sep ) :      <str> dc = copy . copy ( d ) if dc [ <str> ] :        if ( dc [ <str> ] [ - 1 ] . isdigit ( ) and dc [ <str> ] [ 0 ] . isdigit ( ) ) :          dc [ <str> ] = sep  else :          dc [ <str> ] = <str>   else :        dc [ <str> ] = <str>  return dc  soname_re = re . compile ( <str> <str> <str> <str> ) m = soname_re . match ( soname ) if not m :      digits = <str> . join ( re . findall ( <str> , soname ) ) alnum = <str> . join ( re . findall ( <str> , soname ) ) parsed = { <str> : alnum , <str> : digits , }  else :      parsed = m . groupdict ( )  keywords_pkgname = { } keywords_catalogname = { } for key in parsed :      if parsed [ key ] :        keywords_pkgname [ key ] = SonameToStringWithChar ( parsed [ key ] , <str> ) keywords_catalogname [ key ] = SonameToStringWithChar ( parsed [ key ] , <str> )  else :        keywords_pkgname [ key ] = <str> keywords_catalogname [ key ] = <str>   if path :      prefix = ExtractPrefix ( path )  else :      prefix = None  keywords_pkgname = AddSeparator ( keywords_pkgname , <str> ) pkgname = <str> % keywords_pkgname if prefix :      pkgname += <str> % prefix  pkgname_list = [ pkgname ] keywords_catalogname = AddSeparator ( keywords_catalogname , <str> ) catalogname = <str> % keywords_catalogname if prefix :      catalogname += <str> % prefix  catalogname_list = [ catalogname ] return pkgname_list , catalogname_list  def GetSharedLibs ( pkg_data ) :    shared_libs = [ ] for metadata in pkg_data [ <str> ] :      metadata = representations . FileMetadata ( * metadata ) if <str> in metadata . mime_type :        shared_libs . append ( metadata . path )   return shared_libs  def LongestCommonSubstring ( S , T ) :    m = len ( S ) ; n = len ( T ) L = [ [ 0 ] * ( n + 1 ) for i in xrange ( m + 1 ) ] LCS = set ( ) longest = 0 for i in xrange ( m ) :      for j in xrange ( n ) :        if S [ i ] == T [ j ] :          v = L [ i ] [ j ] + 1 L [ i + 1 ] [ j + 1 ] = v if v > longest :            longest = v LCS = set ( )  if v == longest :            LCS . add ( S [ i - v + 1 : i + 1 ] )     return LCS  def IsBinary ( file_info , check_consistency = True , allow_missing = False ) :    is_a_binary = False if <str> not in file_info :      raise DataInconsistencyError ( <str> % repr ( file_info ) )  if not file_info [ <str> ] :      if allow_missing :        return False  raise DataError ( <str> % repr ( file_info ) )  for mimetype in BIN_MIMETYPES :      if mimetype in file_info [ <str> ] :        is_a_binary = True break   if check_consistency and is_a_binary and not <str> in file_info :      raise DataInconsistencyError ( <str> <str> <str> <str> % file_info )  return is_a_binary  def ArchByString ( s ) :      if s == <str> :        return common_constants . ARCH_SPARC  elif s in ( <str> , <str> ) :        return common_constants . ARCH_i386  elif s == <str> :        return common_constants . ARCH_ALL  else :        raise ArchitectureError ( <str> % repr ( s ) )   def GetIsalist ( str_arch ) :    arch = ArchByString ( str_arch ) return common_constants . ISALISTS_BY_ARCH [ arch ]  def EscapeRegex ( s ) :    s = s . replace ( <str> , <str> ) return s  def CollectionLongestCommonSubstring ( collection ) :    current_substring = collection . pop ( ) while collection and current_substring :      substring_set = LongestCommonSubstring ( current_substring , collection . pop ( ) ) if substring_set :        current_substring = list ( substring_set ) [ 0 ]   return current_substring   