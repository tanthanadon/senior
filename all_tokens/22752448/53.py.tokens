import argparse import cPickle import datetime import dateutil . parser import jinja2 import json import logging import requests import concurrent . futures from lib . python import activity from lib . python import colors REPORT_TMPL = <str> def ConcurrentFetchResults ( catrels ) :    def Fetch ( catrel ) :      url = ( <str> <str> . format ( catrel ) ) logging . debug ( <str> , url ) return requests . get ( url ) . json ( )  results_by_catrel = { } with concurrent . futures . ThreadPoolExecutor ( max_workers = 5 ) as executor :      key_by_future = dict ( ( executor . submit ( Fetch , catrel ) , catrel ) for catrel in catrels ) csw_db_url = <str> csw_db_future = executor . submit ( lambda : requests . get ( csw_db_url ) . json ( ) ) key_by_future [ csw_db_future ] = <str> for future in concurrent . futures . as_completed ( key_by_future ) :        key = key_by_future [ future ] if future . exception ( ) is not None :          logging . warning ( <str> , key , future . exception ( ) )  else :          results_by_catrel [ key ] = future . result ( )    return results_by_catrel  def main ( ) :    parser = argparse . ArgumentParser ( ) parser . add_argument ( <str> , help = <str> ) parser . add_argument ( <str> , dest = <str> , help = <str> <str> ) parser . add_argument ( <str> , dest = <str> , help = <str> ) args = parser . parse_args ( ) catrels = [ <str> , <str> , <str> ] if args . load_from :      with open ( args . load_from , <str> ) as fd :        results_by_catrel = cPickle . load ( fd )   else :      results_by_catrel = ConcurrentFetchResults ( catrels )  if args . save_as :      with open ( args . save_as , <str> ) as fd :        cPickle . dump ( results_by_catrel , fd )   csw_db_maintainers = results_by_catrel [ <str> ] del results_by_catrel [ <str> ] pkgs = [ item for sublist in results_by_catrel . values ( ) for item in sublist ] maintainers , bad_dates = activity . Maintainers ( pkgs ) maintainers_in_unstable , _ = activity . Maintainers ( results_by_catrel [ <str> ] ) counts = { <str> : 0 , <str> : 0 , <str> : 0 , <str> : 0 , <str> : 0 , } for d in csw_db_maintainers :      username = d [ <str> ] if username in activity . MAINTAINER_STOPLIST :        continue  status = d [ <str> ] date_created = None if d [ <str> ] :        date_created = dateutil . parser . parse ( d [ <str> ] )  if username in maintainers :        maintainers [ username ] = ( maintainers [ username ] . _replace ( csw_db_status = status , date_created = date_created , fullname = d [ <str> ] ) )  else :        maintainers [ username ] = ( activity . Maintainer ( username = username , pkgs = { } , last_activity = datetime . datetime ( 1970 , 1 , 1 , 0 , 0 ) , last_activity_pkg = None , active = False , csw_db_status = status , fullname = d [ <str> ] , date_created = date_created ) )   csw_db_m_by_username = dict ( ( m [ <str> ] , m ) for m in csw_db_maintainers ) analysis_by_username = { } now = datetime . datetime . now ( ) new_maint_cutoff = now - datetime . timedelta ( days = activity . NEW_MAINTAINER_CUTOFF * 365 ) for username in maintainers :      d = { <str> : False , <str> : False , <str> : False } if ( maintainers [ username ] . date_created is not None and maintainers [ username ] . date_created > new_maint_cutoff and maintainers [ username ] . csw_db_status != <str> ) :        maintainers [ username ] = maintainers [ username ] . _replace ( active = True ) d [ <str> ] = True counts [ <str> ] += 1  if username not in csw_db_m_by_username :        d [ <str> ] = True counts [ <str> ] += 1  if maintainers [ username ] . active and maintainers [ username ] . csw_db_status != <str> :        counts [ <str> ] += 1  else :        if not d [ <str> ] :          if maintainers [ username ] . csw_db_status != <str> :            d [ <str> ] = True counts [ <str> ] += 1  else :            counts [ <str> ] += 1    analysis_by_username [ username ] = d  counts [ <str> ] = activity . INACTIVE_MAINTAINER_CUTOFF with open ( args . output , <str> ) as outfd :      template = jinja2 . Template ( REPORT_TMPL ) rendered = template . render ( maintainers = maintainers , maintainers_in_unstable = maintainers_in_unstable , analysis_by_username = analysis_by_username , counts = counts ) outfd . write ( rendered . encode ( <str> ) )  json_out = args . output if json_out . endswith ( <str> ) :      json_out = json_out [ : - 5 ] + <str>  with open ( json_out , <str> ) as outfd :      json . dump ( dict ( maintainers = maintainers , maintainers_in_unstable = maintainers_in_unstable , analysis_by_username = analysis_by_username , counts = counts ) , outfd , cls = activity . DateTimeEncoder , indent = 2 )   if __name__ == <str> :    logging . basicConfig ( level = logging . DEBUG ) main ( )   