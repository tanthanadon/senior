import datetime import dateutil . parser import logging import json from collections import namedtuple from lib . python import colors from lib . python import opencsw Maintainer = namedtuple ( <str> , [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] ) INACTIVE_MAINTAINER_CUTOFF = 2 NEW_MAINTAINER_CUTOFF = 2 STALE_PACKAGE_CUTOFF = 4 STALE_FROM_COLOR = <str> STALE_TO_COLOR = <str> MAINTAINER_STOPLIST = [ <str> , ] MAINTAINER_WHITELIST = set ( [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , ] ) def RevDeps ( pkgs ) :    revdeps = { } for entry in pkgs :      revdeps . setdefault ( entry [ <str> ] , set ( ) ) for dep in entry [ <str> ] :        revdeps . setdefault ( dep , set ( ) ) . add ( entry [ <str> ] )   return revdeps  def ByPkgname ( pkgs ) :    pkgs_by_pkgname = { } for entry in pkgs :      pkgs_by_pkgname [ entry [ <str> ] ] = entry  return pkgs_by_pkgname  def ComputeMaintainerActivity ( maintainers ) :    now = datetime . datetime . now ( ) activity_cutoff = now - datetime . timedelta ( days = INACTIVE_MAINTAINER_CUTOFF * 365 ) stale_pkg_cutoff = now - datetime . timedelta ( days = STALE_PACKAGE_CUTOFF * 365 ) for username in maintainers :      if maintainers [ username ] . last_activity < activity_cutoff :        maintainers [ username ] = maintainers [ username ] . _replace ( active = False )  pkgs = maintainers [ username ] . pkgs for catalogname in pkgs :        pkgs [ catalogname ] [ <str> ] = pkgs [ catalogname ] [ <str> ] < stale_pkg_cutoff if not maintainers [ username ] . active :          pkgs [ catalogname ] [ <str> ] = True  age = now - pkgs [ catalogname ] [ <str> ] years = <str> % ( age . days / 365.0 ) pkgs [ catalogname ] [ <str> ] = age pkgs [ catalogname ] [ <str> ] = years after_cutoff = stale_pkg_cutoff - pkgs [ catalogname ] [ <str> ] frac = after_cutoff . days / float ( 365 * 4 ) pkgs [ catalogname ] [ <str> ] = colors . IntermediateColor ( STALE_FROM_COLOR , STALE_TO_COLOR , frac )   return maintainers  def Maintainers ( pkgs ) :    bad_dates = [ ] maintainers = { } for entry in pkgs :      entry [ <str> ] = entry [ <str> ] . split ( <str> ) [ 0 ] if entry [ <str> ] in MAINTAINER_STOPLIST :        continue  parsed_fn = opencsw . ParsePackageFileName ( entry [ <str> ] ) dates_to_try = [ ] if <str> in parsed_fn [ <str> ] :        dates_to_try . append ( parsed_fn [ <str> ] [ <str> ] )  else :        logging . warning ( <str> <str> . format ( ** entry ) )  dates_to_try . append ( entry [ <str> ] ) for date_str in dates_to_try :        try :          date = dateutil . parser . parse ( date_str ) break  except ValueError as exc :          logging . warning ( exc ) logging . warning ( <str> <str> . format ( catalogname = entry [ <str> ] , maintainer = entry [ <str> ] , date = date_str ) ) bad_dates . append ( date_str ) continue   entry [ <str> ] = date maintainer = maintainers . setdefault ( entry [ <str> ] , Maintainer ( username = entry [ <str> ] , pkgs = { } , last_activity = datetime . datetime ( 1970 , 1 , 1 , 0 , 0 ) , last_activity_pkg = None , active = True , csw_db_status = None , fullname = None , date_created = None ) ) if entry [ <str> ] not in maintainer . pkgs :        maintainer . pkgs [ entry [ <str> ] ] = entry  if maintainer . last_activity < date :        maintainer = maintainer . _replace ( last_activity = date ) maintainer = maintainer . _replace ( last_activity_pkg = entry ) maintainers [ maintainer . username ] = maintainer   maintainers = ComputeMaintainerActivity ( maintainers ) return maintainers , bad_dates  class DateTimeEncoder ( json . JSONEncoder ) :    def default ( self , obj ) :      if isinstance ( obj , datetime . datetime ) :        return obj . isoformat ( )  elif isinstance ( obj , datetime . date ) :        return obj . isoformat ( )  elif isinstance ( obj , datetime . timedelta ) :        return ( datetime . datetime . min + obj ) . time ( ) . isoformat ( )  else :        return super ( DateTimeEncoder , self ) . default ( obj )     