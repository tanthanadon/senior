import copy import re import operator import os import pprint import textwrap from Cheetah import Template import logging from lib . python import checkpkg_lib from lib . python import common_constants from lib . python import configuration as c from lib . python import dependency_checks as depchecks from lib . python import opencsw from lib . python import representations from lib . python import sharedlib_utils as su from lib . python import struct_util PATHS_ALLOWED_ONLY_IN = { <str> : { <str> : [ <str> , <str> , <str> , <str> , <str> , ] , <str> : [ <str> ] } , <str> : { <str> : [ <str> ] } , <str> : { <str> : [ <str> ] } , } MAX_DESCRIPTION_LENGTH = 100 LICENSE_TMPL = <str> OBSOLETE_DEPS = { <str> : { <str> : <str> , <str> : <str> } , <str> : { <str> : <str> <str> , <str> : <str> , } , <str> : { <str> : <str> <str> , <str> : ( <str> <str> ) , } , } ARCH_RE = re . compile ( <str> ) EMAIL_RE = re . compile ( <str> ) MAX_CATALOGNAME_LENGTH = 29 MAX_PKGNAME_LENGTH = 32 ARCH_LIST = common_constants . ARCHITECTURES VERSION_RE = <str> ARCH_SPECIFIC_PKGNAMES_RE_LIST = [ re . compile ( <str> ) , ] DISCOURAGED_FILE_PATTERNS = ( ( <str> , ( <str> <str> <str> <str> ) ) , ( <str> , <str> ) , ( <str> , ( <str> <str> <str> ) ) , ( <str> , ( <str> <str> ) ) , ( <str> , ( <str> <str> ) ) , ) RPATH_PARTS = { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , } RPATH_WHITELIST = [ ( <str> <str> <str> <str> <str> <str> <str> <str> ) % RPATH_PARTS , <str> , <str> , <str> , ] SYMBOLS_CHECK_ONLY_FOR = <str> VENDORURL_RE = <str> MACHINE_ID_METADATA = common_constants . MACHINE_ID_METADATA ALLOWED_STARTING_PATHS = frozenset ( [ <str> , <str> , <str> , ] ) def RemovePackagesUnderInstallation ( paths_and_pkgs_by_soname , pkgs_to_be_installed ) :    ptbi = set ( pkgs_to_be_installed ) ppbs = paths_and_pkgs_by_soname new_ppbs = { } for soname in ppbs :      if soname not in new_ppbs :        new_ppbs [ soname ] = { }  for binary_path in ppbs [ soname ] :        for pkgname in ppbs [ soname ] [ binary_path ] :          if pkgname not in ptbi :            if binary_path not in new_ppbs [ soname ] :              new_ppbs [ soname ] [ binary_path ] = [ ]  new_ppbs [ soname ] [ binary_path ] . append ( pkgname )     return new_ppbs  def CheckDirectoryPermissions ( pkg_data , error_mgr , logger , messenger ) :    for entry in pkg_data [ <str> ] :      entry = representations . PkgmapEntry . _make ( entry ) if ( entry . type_ == <str> and entry . mode != <str> and entry . mode [ 1 ] == <str> ) :        error_mgr . ReportError ( <str> , entry . path )    def CheckNonCswPathsDirectoryPerms ( pkg_data , error_mgr , logger , messenger ) :    for entry in pkg_data [ <str> ] :      entry = representations . PkgmapEntry . _make ( entry ) if entry . owner == <str> or entry . group == <str> or entry . mode == <str> :        if entry . path . startswith ( <str> ) :          error_mgr . ReportError ( <str> , entry . path )     def CheckPerlLocal ( pkg_data , error_mgr , logger , messenger ) :    perllocal_re = re . compile ( <str> ) for entry in pkg_data [ <str> ] :      entry = representations . PkgmapEntry . _make ( entry ) if entry . path :        if re . search ( perllocal_re , entry . path ) :          error_mgr . ReportError ( <str> , entry . path )     def CheckGzippedManpages ( pkg_data , error_mgr , logger , messenger ) :    gzipman_re = re . compile ( <str> ) for entry in pkg_data [ <str> ] :      entry = representations . PkgmapEntry . _make ( entry ) if entry . path :        if re . search ( gzipman_re , entry . path ) :          error_mgr . ReportError ( <str> , entry . path , <str> <str> )     def CheckMultipleDepends ( pkg_data , error_mgr , logger , messenger ) :    new_depends = set ( ) for pkgname , desc in pkg_data [ <str> ] :      if pkgname in new_depends :        error_mgr . ReportError ( <str> , pkgname )  new_depends . add ( pkgname )   def CheckDescription ( pkg_data , error_mgr , logger , messenger ) :    pkginfo = pkg_data [ <str> ] desc = checkpkg_lib . ExtractDescription ( pkginfo ) if not desc :      error_mgr . ReportError ( <str> )  else :      if len ( desc ) > MAX_DESCRIPTION_LENGTH :        error_mgr . ReportError ( <str> , <str> % len ( desc ) )  if not desc [ 0 ] . isupper ( ) :        error_mgr . ReportError ( <str> , desc )    def CheckVendorURL ( pkg_data , error_mgr , logger , messenger ) :    vendorurl = c . WS_RE . split ( pkg_data [ <str> ] [ <str> ] ) [ 0 ] if not re . match ( VENDORURL_RE , vendorurl ) :      error_mgr . ReportError ( <str> , vendorurl , <str> )   def CheckCatalogname ( pkg_data , error_mgr , logger , messenger ) :    pkginfo = pkg_data [ <str> ] catalogname = pkginfo [ <str> ] . split ( <str> ) [ 0 ] catalogname_2 = pkg_data [ <str> ] [ <str> ] if catalogname != catalogname_2 :      error_mgr . ReportError ( <str> % ( catalogname , catalogname_2 ) )  catalogname_re = <str> if not re . match ( catalogname_re , catalogname ) :      error_mgr . ReportError ( <str> , catalogname )  if catalogname != catalogname . lower ( ) :      error_mgr . ReportError ( <str> )   def CheckSmfIntegration ( pkg_data , error_mgr , logger , messenger ) :    init_re = re . compile ( <str> ) for entry in pkg_data [ <str> ] :      entry = representations . PkgmapEntry . _make ( entry ) if not entry . path :        continue  if not re . search ( init_re , entry . path ) :        continue  if entry . class_ != <str> :        error_mgr . ReportError ( <str> , <str> % ( entry . path , entry . class_ ) ) messenger . Message ( <str> <str> <str> % ( entry . path , entry . class_ ) ) messenger . SuggestGarLine ( <str> % entry . path )  if <str> in entry . path :        messenger . Message ( <str> <str> <str> ) error_mgr . ReportError ( <str> , entry . path )    def SetCheckLibraries ( pkgs_data , error_mgr , logger , messenger ) :    needed_sonames = [ ] pkgs_to_be_installed = [ x [ <str> ] [ <str> ] for x in pkgs_data ] paths_to_verify = set ( ) pkg_by_path = { } logger . debug ( <str> ) for pkg_data in pkgs_data :      pkgname = pkg_data [ <str> ] [ <str> ] for binary_info in pkg_data [ <str> ] :        binary_info = representations . BinaryDumpInfo . _make ( binary_info ) needed_sonames . extend ( binary_info . needed_sonames )  for pkgmap_entry in pkg_data [ <str> ] :        pkgmap_entry = representations . PkgmapEntry . _make ( pkgmap_entry ) if pkgmap_entry . path :          base_dir , basename = os . path . split ( pkgmap_entry . path ) paths_to_verify . add ( base_dir ) paths_to_verify . add ( pkgmap_entry . path ) if pkgmap_entry . path not in pkg_by_path :            pkg_by_path [ pkgmap_entry . path ] = [ ]  pkg_by_path [ pkgmap_entry . path ] . append ( pkgname )    needed_sonames = sorted ( set ( needed_sonames ) ) path_and_pkg_by_basename = depchecks . GetPathAndPkgByBasename ( error_mgr , logger , needed_sonames ) path_and_pkg_by_basename = RemovePackagesUnderInstallation ( path_and_pkg_by_basename , pkgs_to_be_installed ) pkg_by_path = depchecks . GetPkgByFullPath ( error_mgr , logger , paths_to_verify , pkg_by_path ) for pkg_data in pkgs_data :      pkgname = pkg_data [ <str> ] [ <str> ] for pkgmap_entry in pkg_data [ <str> ] :        pkgmap_entry = representations . PkgmapEntry . _make ( pkgmap_entry ) if not pkgmap_entry . path : continue binary_path , basename = os . path . split ( pkgmap_entry . path ) if not binary_path . startswith ( <str> ) :          binary_path = <str> + binary_path  path_and_pkg_by_basename . setdefault ( basename , { } ) path_and_pkg_by_basename [ basename ] [ binary_path ] = [ pkgname ]   for pkg_data in pkgs_data :      pkgname = pkg_data [ <str> ] [ <str> ] declared_deps = frozenset ( x [ 0 ] for x in pkg_data [ <str> ] ) check_args = ( pkg_data , error_mgr , logger , messenger , path_and_pkg_by_basename , pkg_by_path ) depchecks . Libraries ( * check_args ) depchecks . ByFilename ( * check_args )   def SetCheckDependencies ( pkgs_data , error_mgr , logger , messenger ) :    known_pkgs = set ( error_mgr . GetInstalledPackages ( ) ) pkgs_under_check = [ x [ <str> ] [ <str> ] for x in pkgs_data ] for pkgname in pkgs_under_check :      known_pkgs . add ( pkgname )  for pkg_data in pkgs_data :      pkgname = pkg_data [ <str> ] [ <str> ] for depname , dep_desc in pkg_data [ <str> ] :        if depname not in known_pkgs :          error_mgr . ReportError ( pkgname , <str> , depname )     def CheckDependsOnSelf ( pkg_data , error_mgr , logger , messenger ) :    pkgname = pkg_data [ <str> ] [ <str> ] for depname , dep_desc in pkg_data [ <str> ] :      if depname == pkgname :        error_mgr . ReportError ( <str> )    def CheckArchitectureSanity ( pkg_data , error_mgr , logger , messenger ) :    basic_stats = pkg_data [ <str> ] pkgname = basic_stats [ <str> ] pkginfo = pkg_data [ <str> ] filename = basic_stats [ <str> ] arch = pkginfo [ <str> ] filename_re = <str> % arch if not re . search ( filename_re , filename ) :      error_mgr . ReportError ( <str> , <str> % ( arch , filename ) )   def CheckActionClasses ( pkg_data , error_mgr , logger , messenger ) :    pkginfo = pkg_data [ <str> ] pkgmap = pkg_data [ <str> ] if <str> not in pkginfo :      return  pkginfo_classes = set ( re . split ( c . WS_RE , pkginfo [ <str> ] ) ) pkgmap_classes = set ( ) for entry in pkgmap :      entry = representations . PkgmapEntry . _make ( entry ) if entry . class_ :        pkgmap_classes . add ( entry . class_ )   only_in_pkginfo = pkginfo_classes . difference ( pkgmap_classes ) only_in_pkgmap = pkgmap_classes . difference ( pkginfo_classes ) for action_class in only_in_pkginfo :      error_mgr . ReportError ( <str> , action_class )  for action_class in only_in_pkgmap :      error_mgr . ReportError ( <str> , action_class )   def CheckLicenseFile ( pkg_data , error_mgr , logger , messenger ) :    pkgmap = pkg_data [ <str> ] catalogname = pkg_data [ <str> ] [ <str> ] license_path = LICENSE_TMPL % catalogname pkgmap_entries = [ representations . PkgmapEntry . _make ( x ) for x in pkgmap ] pkgmap_paths = [ x . path for x in pkgmap_entries ] if license_path not in pkgmap_paths :      messenger . Message ( <str> <str> <str> % license_path ) error_mgr . ReportError ( <str> , license_path , <str> )   def CheckObsoleteDeps ( pkg_data , error_mgr , logger , messenger ) :    deps = frozenset ( [ x for x , y in pkg_data [ <str> ] ] ) obsolete_pkg_deps = deps . intersection ( set ( OBSOLETE_DEPS ) ) if obsolete_pkg_deps :      for obsolete_pkg in obsolete_pkg_deps :        error_mgr . ReportError ( <str> , obsolete_pkg ) msg = <str> if <str> in OBSOLETE_DEPS [ obsolete_pkg ] :          msg += <str> % OBSOLETE_DEPS [ obsolete_pkg ] [ <str> ]  if <str> in OBSOLETE_DEPS [ obsolete_pkg ] :          if msg :            msg += <str>  msg += <str> % OBSOLETE_DEPS [ obsolete_pkg ] [ <str> ]  if not msg :          msg = None  messenger . Message ( msg )    def CheckArchitectureVsContents ( pkg_data , error_mgr , logger , messenger ) :    binaries = pkg_data [ <str> ] pkginfo = pkg_data [ <str> ] pkgmap = pkg_data [ <str> ] arch = pkginfo [ <str> ] pkgname = pkg_data [ <str> ] [ <str> ] reasons_to_be_arch_specific = [ ] pkgmap_entries = [ representations . PkgmapEntry . _make ( x ) for x in pkgmap ] pkgmap_paths = [ x . path for x in pkgmap_entries ] for pkgmap_path in pkgmap_paths :      try :        if type ( pkgmap_path ) is unicode :          path_str = pkgmap_path . encode ( <str> )  else :          path_str = str ( pkgmap_path )  if re . search ( ARCH_RE , path_str ) :          reasons_to_be_arch_specific . append ( ( <str> , pkgmap_path , <str> % pkgmap_path ) )   except UnicodeDecodeError , e :        logging . warning ( e )   for binary in binaries :      reasons_to_be_arch_specific . append ( ( <str> , binary , <str> % binary ) )  for pkgname_re in ARCH_SPECIFIC_PKGNAMES_RE_LIST :      if pkgname_re . match ( pkgname ) :        reasons_to_be_arch_specific . append ( ( <str> , None , None ) )   if arch == <str> :      for tag , param , desc in reasons_to_be_arch_specific :        error_mgr . ReportError ( tag , param , desc )   elif not reasons_to_be_arch_specific :      messenger . Message ( <str> <str> <str> <str> % ( pkgname , arch ) ) messenger . SuggestGarLine ( <str> % pkgname )   def CheckFileNameSanity ( pkg_data , error_mgr , logger , messenger ) :    basic_stats = pkg_data [ <str> ] revision_info = basic_stats [ <str> ] [ <str> ] catalogname = pkg_data [ <str> ] [ <str> ] pkgname = pkg_data [ <str> ] [ <str> ] if <str> not in revision_info :      error_mgr . ReportError ( <str> )  if len ( catalogname ) > MAX_CATALOGNAME_LENGTH :      error_mgr . ReportError ( <str> )  if len ( pkgname ) > MAX_PKGNAME_LENGTH :      error_mgr . ReportError ( <str> )  if basic_stats [ <str> ] [ <str> ] == <str> :      error_mgr . ReportError ( <str> )   def CheckPkginfoSanity ( pkg_data , error_mgr , logger , messenger ) :    catalogname = pkg_data [ <str> ] [ <str> ] pkgname = pkg_data [ <str> ] [ <str> ] pkginfo = pkg_data [ <str> ] for parameter in ( <str> , <str> , <str> , <str> , <str> ) :      if parameter not in pkginfo :        error_mgr . ReportError ( <str> , parameter )   if not catalogname :      error_mgr . ReportError ( <str> )  if not pkgname :      error_mgr . ReportError ( <str> )  if not <str> in pkginfo or not pkginfo [ <str> ] :      error_mgr . ReportError ( <str> )  maintname = checkpkg_lib . ExtractMaintainerName ( pkginfo ) if not maintname :      error_mgr . ReportError ( <str> )  if not pkginfo [ <str> ] :      error_mgr . ReportError ( <str> )  if not pkginfo [ <str> ] :      error_mgr . ReportError ( <str> )  pkginfo_version = pkg_data [ <str> ] [ <str> ] [ <str> ] if pkginfo_version != pkginfo [ <str> ] :      error_mgr . ReportError ( <str> , <str> % ( pkginfo_version , pkginfo [ <str> ] ) )  if re . search ( <str> , pkginfo [ <str> ] ) :      error_mgr . ReportError ( <str> , pkginfo [ <str> ] )  if not re . match ( VERSION_RE , pkginfo [ <str> ] ) :      msg = <str> % VERSION_RE error_mgr . ReportError ( <str> , pkginfo [ <str> ] , msg )  if pkginfo [ <str> ] not in ARCH_LIST :      error_mgr . ReportError ( <str> , pkginfo [ <str> ] , <str> % ARCH_LIST )   def CheckEmail ( pkg_data , error_mgr , logger , messenger ) :    catalogname = pkg_data [ <str> ] [ <str> ] pkgname = pkg_data [ <str> ] [ <str> ] pkginfo = pkg_data [ <str> ] if not re . match ( EMAIL_RE , pkginfo [ <str> ] ) :      error_mgr . ReportError ( <str> , <str> % pkginfo [ <str> ] )   def CheckPstamp ( pkg_data , error_mgr , logger , messenger ) :    pkginfo = pkg_data [ <str> ] if <str> in pkginfo :      if not re . match ( common_constants . PSTAMP_RE , pkginfo [ <str> ] ) :        msg = ( <str> <str> % repr ( pkginfo [ <str> ] ) ) error_mgr . ReportError ( <str> , pkginfo [ <str> ] , msg )   else :      error_mgr . ReportError ( <str> )   def DisabledCheckMissingSymbols ( pkgs_data , error_mgr , logger , messenger ) :    missing_symbols = [ ] all_symbols = set ( ) for pkg_data in pkgs_data :      pkgname = pkg_data [ <str> ] [ <str> ] binaries = pkg_data [ <str> ] for binary in binaries :        for ldd_elem in pkg_data [ <str> ] [ binary ] :          if ldd_elem [ <str> ] == <str> :            missing_symbols . append ( ( pkgname , binary , ldd_elem [ <str> ] ) )   for symbol in pkg_data [ <str> ] [ binary ] :          all_symbols . add ( symbol )    while missing_symbols :      ms_pkgname , ms_binary , ms_symbol = missing_symbols . pop ( ) if ms_symbol not in all_symbols :        error_mgr . ReportError ( <str> , <str> % ( ms_binary , ms_symbol ) )    def CheckBuildingUser ( pkg_data , error_mgr , logger , messenger ) :    pkgname = pkg_data [ <str> ] [ <str> ] username = checkpkg_lib . ExtractBuildUsername ( pkg_data [ <str> ] ) for entry in pkg_data [ <str> ] :      entry = representations . PkgmapEntry . _make ( entry ) if entry . owner and entry . owner == username :        error_mgr . ReportError ( <str> <str> % ( entry . path , entry . owner ) )    def CheckDisallowedPaths ( pkg_data , error_mgr , logger , messenger ) :    arch = pkg_data [ <str> ] [ <str> ] common_paths = [ ] for common_path in error_mgr . GetCommonPaths ( arch ) :      if common_path . startswith ( <str> ) :        common_path = common_path [ 1 : ]  common_paths . append ( common_path )  paths_only_allowed_in = copy . copy ( PATHS_ALLOWED_ONLY_IN ) ss = paths_only_allowed_in [ <str> ] [ <str> ] paths_only_allowed_in [ <str> ] [ <str> ] = set ( ss ) . union ( common_paths ) for pkgname in paths_only_allowed_in :      if <str> in paths_only_allowed_in [ pkgname ] :        regexes = paths_only_allowed_in [ pkgname ] [ <str> ] paths_only_allowed_in [ pkgname ] [ <str> ] = map ( re . compile , regexes )  if <str> in paths_only_allowed_in [ pkgname ] :        paths_only_allowed_in [ pkgname ] [ <str> ] = set ( paths_only_allowed_in [ pkgname ] [ <str> ] )   paths_in_pkg = set ( ) for entry in pkg_data [ <str> ] :      entry = representations . PkgmapEntry . _make ( entry ) entry_path = entry . path if not entry_path :        continue  if entry_path . startswith ( <str> ) :        entry_path = entry_path [ 1 : ]  paths_in_pkg . add ( entry_path )  for pkgname in paths_only_allowed_in :      if pkgname != pkg_data [ <str> ] [ <str> ] :        if <str> in paths_only_allowed_in [ pkgname ] :          ss = paths_only_allowed_in [ pkgname ] [ <str> ] intersection = ss . intersection ( paths_in_pkg ) for path_in_pkg in intersection :            error_mgr . ReportError ( <str> , path_in_pkg , <str> <str> % pkgname )   if <str> in paths_only_allowed_in [ pkgname ] :          rr = paths_only_allowed_in [ pkgname ] [ <str> ] for disallowed_re in rr :            badpaths = filter ( disallowed_re . match , paths_in_pkg ) for path_in_pkg in badpaths :                error_mgr . ReportError ( <str> , path_in_pkg , <str> <str> % pkgname )       def CheckLinkingAgainstSunX11 ( pkg_data , error_mgr , logger , messenger ) :    shared_libs = set ( su . GetSharedLibs ( pkg_data ) ) for binary_info in pkg_data [ <str> ] :      binary_info = representations . BinaryDumpInfo . _make ( binary_info ) for soname in binary_info . needed_sonames :        if ( binary_info . path in shared_libs and soname in common_constants . DO_NOT_LINK_AGAINST_THESE_SONAMES ) :          error_mgr . ReportError ( <str> , <str> % ( binary_info . base_name , soname ) )     def CheckDiscouragedFileNamePatterns ( pkg_data , error_mgr , logger , messenger ) :    patterns = [ ( x , re . compile ( x ) , y ) for x , y in DISCOURAGED_FILE_PATTERNS ] for entry in pkg_data [ <str> ] :      entry = representations . PkgmapEntry . _make ( entry ) if entry . path :        for pattern , pattern_re , msg in patterns :          if pattern_re . search ( entry . path ) :            error_mgr . ReportError ( <str> , entry . path ) messenger . OneTimeMessage ( <str> % pattern , msg )      def CheckBadContent ( pkg_data , error_mgr , logger , messenger ) :    for regex in pkg_data [ <str> ] :      for file_name in pkg_data [ <str> ] [ regex ] :        if <str> in file_name :          continue  messenger . Message ( <str> <str> <str> <str> % ( file_name , repr ( regex ) ) ) error_mgr . ReportError ( <str> , <str> % ( regex , file_name ) )    def CheckPkgchk ( pkg_data , error_mgr , logger , messenger ) :    if pkg_data [ <str> ] [ <str> ] != 0 :      error_mgr . ReportError ( <str> , unicode ( pkg_data [ <str> ] [ <str> ] ) ) for line in pkg_data [ <str> ] [ <str> ] :        logger . warn ( line )    def CheckRpath ( pkg_data , error_mgr , logger , messenger ) :    regex_whitelist = [ re . compile ( x ) for x in RPATH_WHITELIST ] for binary_info in pkg_data [ <str> ] :      binary_info = representations . BinaryDumpInfo . _make ( binary_info ) actual_rpaths = binary_info . runpath matching = [ ] not_matching = [ ] for rpath in actual_rpaths :        matched = False for white_re in regex_whitelist :          m = white_re . match ( rpath ) if m :            matching . append ( ( rpath , m . groupdict ( ) ) ) matched = True break   if matched :          matching . append ( rpath )  else :          not_matching . append ( rpath )   for bad in sorted ( not_matching ) :        logger . debug ( <str> , bad ) error_mgr . ReportError ( <str> , <str> % ( bad , binary_info . path ) )    def DisabledCheckForMissingSymbolsDumb ( pkg_data , error_mgr , logger , messenger ) :    pkgname = pkg_data [ <str> ] [ <str> ] if not re . match ( SYMBOLS_CHECK_ONLY_FOR , pkgname ) :      return  symbol_not_found_was_seen = False relocation_was_seen = False for binary_info in pkg_data [ <str> ] :      binary_info = representations . BinaryDumpInfo . _make ( binary_info ) for ldd_elem in pkg_data [ <str> ] [ binary_info . path ] :        if not symbol_not_found_was_seen and ldd_elem [ <str> ] == <str> :          error_mgr . ReportError ( <str> , <str> % ( binary_info . path , ldd_elem [ <str> ] ) ) symbol_not_found_was_seen = True  if ( not relocation_was_seen and ldd_elem [ <str> ] == <str> ) :          error_mgr . ReportError ( ldd_elem [ <str> ] , <str> <str> % ( ldd_elem [ <str> ] , ldd_elem [ <str> ] ) )     def SetCheckFileCollisions ( pkgs_data , error_mgr , logger , messenger ) :    pkgs_by_path = { } skip_file_types = set ( [ <str> ] ) pkgnames = set ( x [ <str> ] [ <str> ] for x in pkgs_data ) for pkg_data in pkgs_data :      pkgname = pkg_data [ <str> ] [ <str> ] for pkgmap_entry in pkg_data [ <str> ] :        pkgmap_entry = representations . PkgmapEntry . _make ( pkgmap_entry ) if pkgmap_entry . path and pkgmap_entry . type_ not in skip_file_types :          if pkgmap_entry . path not in pkgs_by_path :            pkgs_by_path [ pkgmap_entry . path ] = set ( )  pkgs_by_path [ pkgmap_entry . path ] . add ( pkgname ) pkgs_in_db = error_mgr . GetPkgByPath ( pkgmap_entry . path ) pkgs_in_db = pkgs_in_db . difference ( pkgnames ) pkgs_by_path [ pkgmap_entry . path ] . update ( pkgs_in_db )    for file_path in pkgs_by_path :      if len ( pkgs_by_path [ file_path ] ) > 1 :        pkgnames = sorted ( pkgs_by_path [ file_path ] ) for pkgname in pkgnames :          error_mgr . ReportError ( pkgname , <str> , <str> % ( file_path , <str> . join ( pkgnames ) ) )     def CheckPython2PackageName ( pkg_data , error_mgr , logger , messenger ) :    pyfile_re = re . compile ( <str> ) pkgname = pkg_data [ <str> ] [ <str> ] has_py_files = False example_py_file = <str> for pkgmap_entry in pkg_data [ <str> ] :      pkgmap_entry = representations . PkgmapEntry . _make ( pkgmap_entry ) if not pkgmap_entry . path :        continue  if pyfile_re . match ( pkgmap_entry . path ) :        has_py_files = True example_py_file = pkgmap_entry . path break   if has_py_files and not pkgname . startswith ( <str> ) :      error_mgr . ReportError ( <str> ) messenger . Message ( <str> <str> <str> % repr ( example_py_file ) )  catalogname = pkg_data [ <str> ] [ <str> ] if has_py_files and not catalogname . startswith ( <str> ) :      error_mgr . ReportError ( <str> ) messenger . Message ( <str> <str> <str> % repr ( example_py_file ) )   def CheckPackageDoesNotBreakPython26 ( pkg_data , error_mgr , logger , messenger ) :    py26_file_re = re . compile ( <str> ) pkgname = pkg_data [ <str> ] [ <str> ] has_py_prefix = pkgname . startswith ( <str> ) if not has_py_prefix :      return  spotted_a_py26_file = False for pkgmap_entry in pkg_data [ <str> ] :      pkgmap_entry = representations . PkgmapEntry . _make ( pkgmap_entry ) if not pkgmap_entry . path :        continue  if py26_file_re . match ( pkgmap_entry . path ) :        spotted_a_py26_file = True example_py_file = pkgmap_entry . path break   if not spotted_a_py26_file :      error_mgr . ReportError ( <str> ) messenger . Message ( <str> <str> )   def CheckPyPackageContainsPyFiles ( pkg_data , error_mgr , logger , messenger ) :    py_file_re = re . compile ( <str> ) pkgname = pkg_data [ <str> ] [ <str> ] has_py_prefix = pkgname . startswith ( <str> ) if not has_py_prefix :      return  spotted_a_py_file = False for pkgmap_entry in pkg_data [ <str> ] :      pkgmap_entry = representations . PkgmapEntry . _make ( pkgmap_entry ) if not pkgmap_entry . path :        continue  if py_file_re . match ( pkgmap_entry . path ) :        spotted_a_py_file = True break   if not spotted_a_py_file :      error_mgr . ReportError ( <str> ) messenger . Message ( <str> <str> )   def CheckArchitecture ( pkg_data , error_mgr , logger , messenger ) :    pkgname = pkg_data [ <str> ] [ <str> ] for metadata in pkg_data [ <str> ] :      metadata = representations . FileMetadata . _make ( metadata ) if not metadata . machine_id : continue logger . debug ( <str> , metadata ) machine_id = metadata . machine_id if machine_id not in MACHINE_ID_METADATA :        error_mgr . ReportError ( <str> , <str> % ( metadata . path , metadata . machine_id ) ) continue  machine_data = MACHINE_ID_METADATA [ machine_id ] cpu_type = machine_data [ <str> ] os_release = pkg_data [ <str> ] [ <str> ] [ <str> ] if os_release not in machine_data [ <str> ] :        raise checkpkg_lib . InternalDataError ( <str> % os_release )  allowed_paths = set ( machine_data [ <str> ] [ os_release ] ) disallowed_paths = set ( machine_data [ <str> ] ) path_parts = set ( metadata . path . split ( os . path . sep ) ) if not path_parts . intersection ( allowed_paths ) :        error_mgr . ReportError ( <str> , <str> % ( metadata . path , machine_id , cpu_type ) ) messenger . OneTimeMessage ( <str> , <str> <str> <str> <str> <str> <str> <str> <str> <str> <str> <str> )  else :        for bad_path in path_parts . intersection ( disallowed_paths ) :          error_mgr . ReportError ( <str> , <str> % ( metadata . path , machine_id , cpu_type , bad_path ) ) messenger . Message ( <str> <str> <str> <str> <str> <str> <str> )     def CheckWrongArchitecture ( pkg_data , error_mgr , logger , messenger ) :    pkgname = pkg_data [ <str> ] [ <str> ] filename_arch = pkg_data [ <str> ] [ <str> ] [ <str> ] pkginfo_arch = pkg_data [ <str> ] [ <str> ] files_metadata = pkg_data [ <str> ] for file_metadata in files_metadata :      file_metadata = representations . FileMetadata . _make ( file_metadata ) if su . IsBinary ( file_metadata . _asdict ( ) ) :        machine = MACHINE_ID_METADATA [ file_metadata . machine_id ] if machine [ <str> ] != pkginfo_arch :          error_mgr . ReportError ( <str> , <str> % ( file_metadata . path , pkginfo_arch , machine [ <str> ] ) )     def CheckSharedLibraryNamingPolicy ( pkg_data , error_mgr , logger , messenger ) :    pkgname = pkg_data [ <str> ] [ <str> ] shared_libs = set ( su . GetSharedLibs ( pkg_data ) ) linkable_shared_libs = [ ] for binary_info in pkg_data [ <str> ] :      binary_info = representations . BinaryDumpInfo . _make ( binary_info ) if binary_info . path in shared_libs :        if su . IsLibraryLinkable ( binary_info . path ) :          if binary_info . soname :            soname = binary_info . soname  else :            soname = os . path . split ( binary_info . path ) [ 1 ]  linkable_shared_libs . append ( ( soname , binary_info ) )  else :          logging . debug ( <str> , binary_info . path )    logging . debug ( <str> <str> % ( pkgname , linkable_shared_libs ) ) for soname , binary_info in linkable_shared_libs :      binary_info = representations . BinaryDumpInfo . _make ( binary_info ) path = os . path . split ( binary_info . path ) [ 0 ] tmp = su . MakePackageNameBySoname ( soname , path ) policy_pkgname_list , policy_catalogname_list = tmp if pkgname not in policy_pkgname_list :        error_mgr . ReportError ( <str> , <str> <str> <str> <str> % ( binary_info . path , soname , pkgname , <str> . join ( policy_pkgname_list ) ) ) suggested_pkgname = policy_pkgname_list [ 0 ] lib_path , lib_basename = os . path . split ( binary_info . path ) pkginfo = pkg_data [ <str> ] description = <str> . join ( pkginfo [ <str> ] . split ( <str> ) [ 2 : ] ) depchecks . SuggestLibraryPackage ( error_mgr , messenger , suggested_pkgname , policy_catalogname_list [ 0 ] , description , lib_path , lib_basename , soname , pkgname ) messenger . OneTimeMessage ( soname , <str> <str> <str> <str> <str> <str> <str> <str> <str> % ( binary_info . path , policy_pkgname_list ) )    def CheckSharedLibraryPkgDoesNotHaveTheSoFile ( pkg_data , error_mgr , logger , messenger ) :    pkgname = pkg_data [ <str> ] [ <str> ] shared_libs = set ( su . GetSharedLibs ( pkg_data ) ) shared_libs = filter ( su . IsLibraryLinkable , shared_libs ) if shared_libs :      for entry in pkg_data [ <str> ] :        entry = representations . PkgmapEntry . _make ( entry ) if entry . path :          if entry . path . endswith ( <str> ) and entry . type_ == <str> :            error_mgr . ReportError ( <str> , <str> % entry . path ) messenger . SuggestGarLine ( <str> % pkgname ) messenger . SuggestGarLine ( <str> % pkgname ) messenger . SuggestGarLine ( <str> % ( pkgname , pkg_data [ <str> ] [ <str> ] ) ) messenger . SuggestGarLine ( <str> % pkgname ) messenger . SuggestGarLine ( <str> % ( pkgname , entry . path ) ) messenger . SuggestGarLine ( <str> ) messenger . SuggestGarLine ( <str> % ( pkgname ) ) messenger . Message ( <str> <str> <str> <str> <str> <str> <str> <str> <str> % entry . path )      def CheckPackagesWithHeaderFilesMustContainTheSoFile ( pkg_data , error_mgr , logger , messenger ) :    pkgname = pkg_data [ <str> ] [ <str> ] shared_libs = set ( su . GetSharedLibs ( pkg_data ) ) shared_libs = filter ( su . IsLibraryLinkable , shared_libs ) if shared_libs :      for entry in pkg_data [ <str> ] :        entry = representations . PkgmapEntry . _make ( entry ) if entry . path :          if entry . path . endswith ( <str> ) and entry . type_ == <str> :            error_mgr . ReportError ( <str> , <str> % entry . path ) messenger . Message ( <str> <str> <str> <str> <str> <str> <str> <str> <str> % entry . path )      def CheckSharedLibraryNameMustBeAsubstringOfSoname ( pkg_data , error_mgr , logger , messenger ) :    pkgname = pkg_data [ <str> ] [ <str> ] for binary_info in pkg_data [ <str> ] :      binary_info = representations . BinaryDumpInfo . _make ( binary_info ) if not binary_info . soname : continue if binary_info . soname not in binary_info . base_name :        error_mgr . ReportError ( <str> , <str> <str> % ( binary_info . soname , binary_info . base_name ) )    def CheckLicenseFilePlacement ( pkg_data , error_mgr , logger , messenger ) :    pkgname = pkg_data [ <str> ] [ <str> ] docpath_re = re . compile ( <str> ) for pkgmap_entry in pkg_data [ <str> ] :      pkgmap_entry = representations . PkgmapEntry . _make ( pkgmap_entry ) if not pkgmap_entry . path : continue m = docpath_re . match ( pkgmap_entry . path ) if m :        if m . groupdict ( ) [ <str> ] != pkg_data [ <str> ] [ <str> ] :          msg = ( <str> <str> <str> ) messenger . Message ( msg ) error_mgr . ReportError ( <str> , <str> <str> % ( pkg_data [ <str> ] [ <str> ] , pkgmap_entry . path ) )     def CheckBaseDirs ( pkg_data , error_mgr , logger , messenger ) :    pkgname = pkg_data [ <str> ] [ <str> ] for pkgmap_entry in pkg_data [ <str> ] :      pkgmap_entry = representations . PkgmapEntry . _make ( pkgmap_entry ) if not pkgmap_entry . path : continue if pkgmap_entry . type_ == <str> or pkgmap_entry . class_ != <str> :        base_dir = os . path . dirname ( pkgmap_entry . path ) error_mgr . NeedFile ( base_dir , <str> % ( pkgname , repr ( pkgmap_entry . path ) , repr ( base_dir ) ) )    def CheckDanglingSymlinks ( pkg_data , error_mgr , logger , messenger ) :    pkgname = pkg_data [ <str> ] [ <str> ] for pkgmap_entry in pkg_data [ <str> ] :      pkgmap_entry = representations . PkgmapEntry . _make ( pkgmap_entry ) if not pkgmap_entry . path : continue if pkgmap_entry . type_ in ( <str> , <str> ) :        link_type = <str> if pkgmap_entry . type_ == <str> :          link_type = <str>  error_mgr . NeedFile ( pkgmap_entry . target , <str> % ( pkgname , link_type , pkgmap_entry . path , pkgmap_entry . target ) )    def CheckPrefixDirs ( pkg_data , error_mgr , logger , messenger ) :    pkgname = pkg_data [ <str> ] [ <str> ] paths_with_slashes = [ ( x , x + <str> ) for x in ALLOWED_STARTING_PATHS ] for pkgmap_entry in pkg_data [ <str> ] :      pkgmap_entry = representations . PkgmapEntry . _make ( pkgmap_entry ) if not pkgmap_entry . path : continue allowed_found = False for p , pslash in paths_with_slashes :        if pkgmap_entry . path == p :          allowed_found = True break  if pkgmap_entry . path . startswith ( pslash ) :          allowed_found = True break   if not allowed_found :        error_mgr . ReportError ( <str> , <str> % pkgmap_entry . path )    def CheckCatalognameMatchesPkgname ( pkg_data , error_mgr , logger , messenger ) :    pkgname = pkg_data [ <str> ] [ <str> ] catalogname = pkg_data [ <str> ] [ <str> ] std_catalogname = struct_util . MakeCatalognameByPkgname ( pkgname ) if catalogname != std_catalogname :      msg = ( <str> <str> <str> <str> ) error_mgr . ReportError ( <str> , <str> % ( pkgname , catalogname , std_catalogname ) )   def CheckSonameMustNotBeEqualToFileNameIfFilenameEndsWithSo ( pkg_data , error_mgr , logger , messenger ) :    shared_libs = set ( su . GetSharedLibs ( pkg_data ) ) for binary_info in pkg_data [ <str> ] :      binary_info = representations . BinaryDumpInfo . _make ( binary_info ) if binary_info . path not in shared_libs :        continue  if not su . IsLibraryLinkable ( binary_info . path ) :        continue  base_name = binary_info . base_name if binary_info . soname :        soname = binary_info . soname  else :        soname = base_name  if ( base_name . endswith ( <str> ) and soname == base_name ) :        msg = ( <str> <str> <str> <str> <str> <str> <str> <str> <str> % binary_info . path ) messenger . Message ( msg ) error_mgr . ReportError ( <str> , <str> % binary_info . path )    def CheckLinkableSoFileMustBeAsymlink ( pkg_data , error_mgr , logger , messenger ) :    pass  def CheckPkginfoOpencswRepository ( pkg_data , error_mgr , logger , messenger ) :    repotag = <str> pkginfo = pkg_data [ <str> ] if repotag not in pkginfo :      error_mgr . ReportError ( <str> ) return  if <str> in pkginfo [ repotag ] :      error_mgr . ReportError ( <str> )   def CheckAlternativesDependency ( pkg_data , error_mgr , logger , messenger ) :    need_alternatives = False for entry in pkg_data [ <str> ] :      entry = representations . PkgmapEntry . _make ( entry ) if not entry . path :        continue  if entry . class_ == <str> :        need_alternatives = True break   if need_alternatives :      error_mgr . NeedFile ( <str> , <str> )   def CheckSharedLibrarySoExtension ( pkg_data , error_mgr , logger , messenger ) :    shared_libs = set ( su . GetSharedLibs ( pkg_data ) ) for shared_lib in shared_libs :      if <str> not in shared_lib :        error_mgr . ReportError ( <str> , <str> % shared_lib )    def Check64bitBinariesPresence ( pkg_data , error_mgr , logger , messenger ) :    paths_64 = { common_constants . ARCH_i386 : common_constants . AMD64_PATHS , common_constants . ARCH_SPARC : common_constants . SPARCV9_PATHS , } pkginfo = pkg_data [ <str> ] arch = pkginfo [ <str> ] if arch not in paths_64 :      return  if <str> not in pkginfo :      error_mgr . ReportError ( <str> , <str> ) return  if <str> not in pkginfo [ <str> ] :      return  binaries_dump_info = [ representations . BinaryDumpInfo . _make ( x ) for x in pkg_data [ <str> ] ] if <str> in pkginfo [ <str> ] :      binaries = binaries_dump_info binaries_path = <str> . join ( common_constants . BASE_BINARY_PATHS )  else :      binaries = [ x for x in binaries_dump_info if x . soname ] binaries_path = <str>  if not binaries :      return  paths_64_str = ( <str> % ( binaries_path , <str> . join ( paths_64 [ arch ] ) ) ) paths_64_re = re . compile ( paths_64_str ) for binary_info in binaries :      if paths_64_re . search ( binary_info . path ) :        return   error_mgr . ReportError ( <str> ) messenger . Message ( <str> <str> <str> <str> % ( binaries [ 0 ] , paths_64_str ) )  def CheckShouldNotDependOnStub ( pkg_data , error_mgr , logger , messenger ) :    for dep_pkgname , _ in pkg_data [ <str> ] :      dep_data = error_mgr . GetPkgByPkgname ( dep_pkgname ) if dep_data is None :        continue  if dep_data [ <str> ] . endswith ( <str> ) :        error_mgr . ReportError ( <str> , dep_data [ <str> ] , <str> <str> <str> )     