import sys import os import cjson import datetime import json import logging import pprint import sqlobject import time import re import web from sqlobject import sqlbuilder from lib . python import checkpkg_lib from lib . python import configuration from lib . python import models from lib . python import representations from lib . web import web_lib config = configuration . GetConfig ( ) LOG_FILE_TMPL = config . get ( <str> , <str> ) urls_html = ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , ) urls_rest = ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , ) urls = urls_html + urls_rest templatedir = os . path . join ( os . path . dirname ( __file__ ) , <str> ) render = web . template . render ( templatedir ) def SanitizeDescription ( catalogname , desc ) :    prefix = <str> % catalogname if desc . startswith ( prefix ) :      return desc [ len ( prefix ) : ]  return desc  def FormatPkginstList ( lst ) :    if lst :      return <str> . join ( lst )  else :      return <str>   class index ( object ) :    def GET ( self ) :      return render . index ( )   class Favicon ( object ) :    def GET ( self ) :      return <str>   class Srv4List ( object ) :    def GET ( self ) :      pkgs = models . Srv4FileStats . select ( ) . orderBy ( <str> ) [ : 30 ] now = datetime . datetime . now ( ) def Ago ( timedelta ) :        timezone_diff = 1.0 return <str> % ( timedelta . seconds / 60.0 / 60.0 - timezone_diff )  pkgs_ago = [ ( x , Ago ( now - x . mtime ) ) for x in pkgs ] return render . Srv4List ( pkgs_ago )   class Srv4Detail ( object ) :    def GET ( self , md5_sum ) :      try :        pkg = models . Srv4FileStats . selectBy ( md5_sum = md5_sum ) . getOne ( )  except sqlobject . main . SQLObjectNotFound , e :        raise web . notfound ( )  overrides = pkg . GetOverridesResult ( ) tags_by_cat = { } tags_and_catalogs = [ ] osrels = models . OsRelease . select ( ) catrels = models . CatalogRelease . select ( ) all_tags = list ( models . CheckpkgErrorTag . selectBy ( srv4_file = pkg ) ) pkg_stats_sqo = models . Srv4FileStatsBlob . selectBy ( md5_sum = md5_sum ) . getOne ( ) pkg_stats = cjson . decode ( pkg_stats_sqo . json ) pkg_stats_raw = pprint . pformat ( pkg_stats , width = 200 ) if pkg . arch . name == <str> :        archs = models . Architecture . select ( models . Architecture . q . name != <str> )  else :        archs = [ pkg . arch ]  pkgmap = [ ] for pkgmap_entry in pkg_stats [ <str> ] :        pkgmap_entry = representations . PkgmapEntry . _make ( pkgmap_entry ) pkgmap . append ( pkgmap_entry . line )  for catrel in catrels :        for arch in archs :          for osrel in osrels :            tags = pkg . GetErrorTagsResult ( osrel , arch , catrel ) key = ( osrel , arch , catrel ) tags = list ( tags ) tags_by_cat [ key ] = tags tags_and_catalogs . append ( ( osrel , arch , catrel , tags ) )    binary_md5_sums = pkg_stats [ <str> ] return render . Srv4Detail ( pkg , overrides , tags_by_cat , all_tags , tags_and_catalogs , pkg_stats_raw , pkgmap , binary_md5_sums )   class Srv4StructDump ( object ) :    def GET ( self , md5_sum ) :      try :        blob = models . Srv4FileStatsBlob . selectBy ( md5_sum = md5_sum ) . getOne ( ) struct = cjson . decode ( blob . json ) basename = struct [ <str> ] [ <str> ] struct_dump = pprint . pformat ( struct , width = 200 ) return render . Srv4StructDump ( basename , struct_dump )  except sqlobject . main . SQLObjectNotFound :        raise web . notfound ( )    class Elfdump ( object ) :    def GET ( self , md5_sum ) :      try :        blob = models . ElfdumpInfoBlob . selectBy ( md5_sum = md5_sum ) . getOne ( ) struct = cjson . decode ( blob . json ) struct_dump = pprint . pformat ( struct , width = 200 ) return render . ElfdumpInfoBlob ( md5_sum , struct_dump )  except sqlobject . main . SQLObjectNotFound :        raise web . notfound ( )    class Catalogname ( object ) :    def GET ( self , catalogname ) :      try :        pkgs = models . Srv4FileStats . selectBy ( catalogname = catalogname , registered_level_two = True ) . orderBy ( <str> ) return render . Catalogname ( catalogname , pkgs )  except sqlobject . main . SQLObjectNotFound :        raise web . notfound ( )    class CatalognameList ( object ) :    def GET ( self ) :      try :        connection = models . Srv4FileStats . _connection rows = connection . queryAll ( connection . sqlrepr ( sqlbuilder . Select ( [ models . Srv4FileStats . q . catalogname ] , distinct = True , where = sqlobject . AND ( models . Srv4FileStats . q . use_to_generate_catalogs == True , models . Srv4FileStats . q . registered_level_two == True ) , orderBy = models . Srv4FileStats . q . catalogname ) ) ) rows_by_letter = { } for row in rows :          initial = row [ 0 ] [ 0 ] rows_by_letter . setdefault ( initial , [ ] ) rows_by_letter [ initial ] . append ( row )  return render . CatalognameList ( rows_by_letter , sorted ( rows_by_letter ) )  except sqlobject . main . SQLObjectNotFound , e :        raise web . notfound ( )    class Srv4DetailFiles ( object ) :    def GET ( self , md5_sum ) :      try :        srv4 = models . Srv4FileStats . selectBy ( md5_sum = md5_sum ) . getOne ( )  except sqlobject . main . SQLObjectNotFound as e :        raise web . notfound ( )  files = models . CswFile . selectBy ( srv4_file = srv4 ) return render . Srv4DetailFiles ( srv4 , files )   class CatalogList ( object ) :    def GET ( self ) :      archs = models . Architecture . select ( ) osrels = models . OsRelease . select ( ) catrels = models . CatalogRelease . select ( ) . orderBy ( <str> ) table = [ ] for catrel in catrels :        row = [ catrel . name ] for osrel in osrels :          cell = [ ] if osrel . full_name == <str> : continue for arch in archs :            if arch . name in ( <str> ) : continue cell . append ( { <str> : osrel , <str> : arch , <str> : catrel } )  row . append ( cell )  table . append ( row )  return render . CatalogList ( table , osrels )   class CatalogDetail ( object ) :    def GET ( self , catrel_name , arch_name , osrel_name ) :      cat_name = <str> . join ( ( catrel_name , arch_name , osrel_name ) ) try :        sqo_osrel , sqo_arch , sqo_catrel = models . GetSqoTriad ( osrel_name , arch_name , catrel_name )  except sqlobject . main . SQLObjectNotFound :        raise web . notfound ( )  t2 = time . time ( ) pkgs = list ( models . GetCatPackagesResult ( sqo_osrel , sqo_arch , sqo_catrel ) ) t3 = time . time ( ) timeinfo = <str> % ( t3 - t2 ) return render . CatalogDetail ( cat_name , pkgs , timeinfo , len ( pkgs ) )   class MaintainerList ( object ) :    def GET ( self ) :      maintainers = models . Maintainer . select ( ) . orderBy ( <str> ) names = [ ] for m in maintainers :        email = m . email . split ( <str> ) if len ( email ) >= 2 :          names . append ( ( email [ 0 ] , email [ 1 ] , m ) )  else :          names . append ( ( email [ 0 ] , <str> , m ) )   return render . MaintainerList ( names )   class MaintainerDetail ( object ) :    def GET ( self , id ) :      maintainer = models . Maintainer . selectBy ( id = id ) . getOne ( ) pkgs = models . Srv4FileStats . select ( sqlobject . AND ( models . Srv4FileStats . q . maintainer == maintainer , models . Srv4FileStats . q . registered_level_two == True , ) , ) . orderBy ( <str> ) return render . MaintainerDetail ( maintainer , pkgs )   class RestMaintainerList ( object ) :    def GET ( self ) :      maintainers = models . Maintainer . select ( ) . orderBy ( <str> ) maintainers = [ m . GetRestRepr ( ) for m in maintainers ] return cjson . encode ( maintainers )   class RestMaintainerDetail ( object ) :    def GET ( self , id ) :      try :        maintainer = models . Maintainer . selectBy ( id = id ) . getOne ( ) return cjson . encode ( maintainer . GetRestRepr ( ) )  except sqlobject . main . SQLObjectNotFound :        raise web . notfound ( )    class RestMaintainerDetailByName ( object ) :    def GET ( self ) :      user_data = web . input ( ) email = user_data . email try :        maintainer = models . Maintainer . selectBy ( email = email ) . getOne ( ) return cjson . encode ( maintainer . GetRestRepr ( ) )  except sqlobject . main . SQLObjectNotFound :        raise web . notfound ( )    class MaintainerCheckpkgReport ( object ) :    def GET ( self , id ) :      maintainer = models . Maintainer . selectBy ( id = id ) . getOne ( ) pkgs = models . Srv4FileStats . select ( sqlobject . AND ( models . Srv4FileStats . q . maintainer == maintainer , models . Srv4FileStats . q . registered_level_two == True , ) , ) . orderBy ( <str> ) tags_by_md5 = { } pkgs = list ( pkgs ) for pkg in pkgs :        tags = list ( models . CheckpkgErrorTag . selectBy ( srv4_file = pkg ) . orderBy ( ( <str> , <str> ) ) ) tags_by_cat_id = { } for tag in tags :          key = ( tag . catrel . name , tag . arch . name , tag . os_rel . short_name ) tags_by_cat_id . setdefault ( key , [ ] ) . append ( tag )  tags_by_md5 . setdefault ( pkg . md5_sum , tags_by_cat_id )  return render . MaintainerCheckpkgReport ( maintainer , pkgs , tags_by_md5 )   class ErrorTagDetail ( object ) :    def GET ( self , tag_name ) :      join = [ sqlbuilder . INNERJOINOn ( None , models . Srv4FileStats , models . CheckpkgErrorTag . q . srv4_file == models . Srv4FileStats . q . id ) , ] tags = models . CheckpkgErrorTag . select ( sqlobject . AND ( models . CheckpkgErrorTag . q . tag_name == tag_name , models . Srv4FileStats . q . registered_level_two == True , models . Srv4FileStats . q . use_to_generate_catalogs == True , ) , join = join , ) . orderBy ( ( <str> , <str> , <str> , <str> , <str> ) ) return render . ErrorTagDetail ( tag_name , tags )   class ErrorTagList ( object ) :    def GET ( self ) :      connection = models . CheckpkgErrorTag . _connection rows = connection . queryAll ( connection . sqlrepr ( sqlbuilder . Select ( [ models . CheckpkgErrorTag . q . tag_name ] , distinct = True , orderBy = models . CheckpkgErrorTag . q . tag_name ) ) ) return render . ErrorTagList ( rows )   class RestCatalogDetail ( object ) :    def GET ( self , catrel_name , arch_name , osrel_name ) :      try :        sqo_osrel , sqo_arch , sqo_catrel = models . GetSqoTriad ( osrel_name , arch_name , catrel_name )  except sqlobject . main . SQLObjectNotFound :        raise web . notfound ( )  pkgs = list ( models . GetCatPackagesResult ( sqo_osrel , sqo_arch , sqo_catrel ) ) if not len ( pkgs ) :        raise web . notfound ( )  web . header ( <str> , <str> ) pkgs_data = [ p . GetRestRepr ( quick = True ) [ 1 ] for p in pkgs ] response = cjson . encode ( pkgs_data ) web . header ( <str> , str ( len ( response ) ) ) return response   class PkgnameByFilename ( object ) :    def GET ( self , catrel , arch , osrel ) :      user_data = web . input ( ) filename = user_data . filename send_filename = ( <str> % ( catrel , arch , osrel , filename . replace ( <str> , <str> ) ) ) db_catalog = checkpkg_lib . Catalog ( ) try :        pkgs = db_catalog . GetPkgByPath ( filename , osrel , arch , catrel )  except sqlobject . main . SQLObjectNotFound :        raise web . notfound ( )  web . header ( <str> , <str> ) web . header ( <str> , <str> ) web . header ( <str> , <str> % send_filename ) return cjson . encode ( sorted ( pkgs ) )   class PkgnamesAndPathsByBasename ( object ) :    def GET ( self , catrel , arch , osrel ) :      user_data = web . input ( ) try :        basename = user_data . basename  except AttributeError , e :        raise web . badrequest ( )  send_filename = ( <str> % ( catrel , arch , osrel , basename . replace ( <str> , <str> ) ) ) db_catalog = checkpkg_lib . Catalog ( ) try :        data = db_catalog . GetPathsAndPkgnamesByBasename ( basename , osrel , arch , catrel )  except sqlobject . main . SQLObjectNotFound :        raise web . notfound ( )  web . header ( <str> , <str> ) web . header ( <str> , <str> % send_filename ) response = cjson . encode ( data ) web . header ( <str> , str ( len ( response ) ) ) return response   class PkgnamesAndPathsByBasedir ( object ) :    def GET ( self , catrel , arch , osrel ) :      user_data = web . input ( ) try :        basedir = user_data . basedir  except AttributeError :        raise web . badrequest ( )  send_filename = ( <str> % ( catrel , arch , osrel , basedir . replace ( <str> , <str> ) ) ) db_catalog = checkpkg_lib . Catalog ( ) try :        data = db_catalog . GetPathsAndPkgnamesByBasedir ( basedir , osrel , arch , catrel )  except sqlobject . main . SQLObjectNotFound :        raise web . notfound ( )  web . header ( <str> , <str> ) web . header ( <str> , <str> % send_filename ) response = cjson . encode ( data ) web . header ( <str> , str ( len ( response ) ) ) return response   class RestSrv4Detail ( object ) :    def GET ( self , md5_sum ) :      try :        pkg = models . Srv4FileStats . selectBy ( md5_sum = md5_sum ) . getOne ( )  except sqlobject . main . SQLObjectNotFound , e :        raise web . notfound ( )  mimetype , data_structure = pkg . GetRestRepr ( ) web . header ( <str> , mimetype ) web . header ( <str> , <str> ) return cjson . encode ( data_structure )   class RestSrv4DetailFiles ( object ) :    def GET ( self , md5_sum ) :      try :        pkg = models . Srv4FileStats . selectBy ( md5_sum = md5_sum ) . getOne ( )  except sqlobject . main . SQLObjectNotFound , e :        raise web . notfound ( )  files = models . CswFile . selectBy ( srv4_file = pkg ) web . header ( <str> , <str> ) web . header ( <str> , <str> ) def FileDict ( file_obj ) :        return { <str> : file_obj . basename , <str> : file_obj . path , <str> : file_obj . line , }  serializable_files = [ FileDict ( x ) for x in files ] return cjson . encode ( serializable_files )   class RestSrv4FullStats ( object ) :    def GET ( self , md5_sum ) :      try :        blob = models . Srv4FileStatsBlob . selectBy ( md5_sum = md5_sum ) . getOne ( )  except sqlobject . main . SQLObjectNotFound , e :        raise web . notfound ( )  web . header ( <str> , <str> ) return blob . json   class Srv4ByCatAndCatalogname ( object ) :    def GET ( self , catrel_name , arch_name , osrel_name , catalogname ) :      web . header ( <str> , <str> ) try :        sqo_osrel , sqo_arch , sqo_catrel = models . GetSqoTriad ( osrel_name , arch_name , catrel_name )  except sqlobject . main . SQLObjectNotFound :        raise web . notfound ( cjson . encode ( { <str> : <str> % ( osrel_name , arch_name , catrel_name ) } ) )  join = [ sqlbuilder . INNERJOINOn ( None , models . Srv4FileInCatalog , models . Srv4FileInCatalog . q . srv4file == models . Srv4FileStats . q . id ) , ] res = models . Srv4FileStats . select ( sqlobject . AND ( models . Srv4FileInCatalog . q . osrel == sqo_osrel , models . Srv4FileInCatalog . q . arch == sqo_arch , models . Srv4FileInCatalog . q . catrel == sqo_catrel , models . Srv4FileStats . q . catalogname == catalogname , models . Srv4FileStats . q . use_to_generate_catalogs == True ) , join = join , ) try :        srv4 = res . getOne ( ) mimetype , data = srv4 . GetRestRepr ( quick = True ) web . header ( <str> , mimetype ) return cjson . encode ( data )  except sqlobject . main . SQLObjectNotFound :        data = { <str> : <str> % ( catrel_name , arch_name , osrel_name , catalogname ) } raise web . notfound ( cjson . encode ( data ) )  except sqlobject . dberrors . OperationalError as exc :        raise web . internalerror ( exc )    class Srv4ByCatAndPkgname ( object ) :    def GET ( self , catrel_name , arch_name , osrel_name , pkgname ) :      try :        sqo_osrel , sqo_arch , sqo_catrel = models . GetSqoTriad ( osrel_name , arch_name , catrel_name )  except sqlobject . main . SQLObjectNotFound :        raise web . notfound ( )  join = [ sqlbuilder . INNERJOINOn ( None , models . Srv4FileInCatalog , models . Srv4FileInCatalog . q . srv4file == models . Srv4FileStats . q . id ) , sqlbuilder . INNERJOINOn ( None , models . Pkginst , models . Pkginst . q . id == models . Srv4FileStats . q . pkginst ) , ] res = models . Srv4FileStats . select ( sqlobject . AND ( models . Srv4FileInCatalog . q . osrel == sqo_osrel , models . Srv4FileInCatalog . q . arch == sqo_arch , models . Srv4FileInCatalog . q . catrel == sqo_catrel , models . Pkginst . q . pkgname == pkgname , models . Srv4FileStats . q . use_to_generate_catalogs == True ) , join = join , ) try :        srv4 = res . getOne ( ) mimetype , data = srv4 . GetRestRepr ( ) web . header ( <str> , mimetype ) web . header ( <str> , <str> ) return cjson . encode ( data )  except sqlobject . main . SQLObjectNotFound :        return cjson . encode ( None )  except sqlobject . dberrors . OperationalError , e :        raise web . internalerror ( e )    class RestSrv4List ( object ) :    def GET ( self ) :      pkgs = models . Srv4FileStats . select ( ) . orderBy ( <str> ) [ : 30 ] now = datetime . datetime . now ( ) def Ago ( timedelta ) :        timezone_diff = 1.0 return <str> % ( timedelta . seconds / 60.0 / 60.0 - timezone_diff )  pkgs_ago = [ ( x , Ago ( now - x . mtime ) ) for x in pkgs ] def PrepareForJson ( pkg_ago ) :        pkg , ago = pkg_ago _ , pkg_dict = pkg . GetRestRepr ( quick = True ) pkg_dict [ <str> ] = ago pkg_dict [ <str> ] = pkg . maintainer . GetRestRepr ( ) return pkg_dict  response = cjson . encode ( [ PrepareForJson ( x ) for x in pkgs_ago ] ) web . header ( <str> , str ( len ( response ) ) ) return response   class Redirection ( object ) :    def GET ( self ) :      user_data = web . input ( redirection_type = <str> , md5_sum = <str> ) if user_data [ <str> ] == <str> :        raise web . seeother ( <str> % user_data [ <str> ] )  raise web . badrequest ( <str> % user_data [ <str> ] )   class RestCatalogList ( object ) :    def GET ( self ) :      archs = models . Architecture . select ( ) osrels = models . OsRelease . select ( ) catrels = models . CatalogRelease . select ( ) catalogs = [ ] for catrel in catrels :        for arch in archs :          if arch . name in ( <str> ) : continue for osrel in osrels :            if osrel . full_name == <str> : continue key = [ osrel . short_name , arch . name , catrel . name ] catalogs . append ( key )    return cjson . encode ( catalogs )   class RestSvr4CatalogData ( object ) :    def GET ( self , md5_sum ) :      try :        cat_gen_data = models . CatalogGenData . selectBy ( md5_sum = md5_sum ) . getOne ( )  except sqlobject . main . SQLObjectNotFound :        raise web . notfound ( <str> % md5_sum )  simple_data = { <str> : cjson . decode ( cat_gen_data . deps ) , <str> : cjson . decode ( cat_gen_data . i_deps ) , <str> : cat_gen_data . pkginfo_name , <str> : cat_gen_data . pkgname , } response = cjson . encode ( simple_data ) web . header ( <str> , str ( len ( response ) ) ) return response   def GetCatalogEntries ( catrel_name , arch_name , osrel_name ) :    try :      sqo_osrel , sqo_arch , sqo_catrel = models . GetSqoTriad ( osrel_name , arch_name , catrel_name )  except sqlobject . main . SQLObjectNotFound :      raise web . notfound ( )  rows = list ( models . GetCatalogGenerationResult ( sqo_osrel , sqo_arch , sqo_catrel ) ) def MakeCatalogEntry ( row ) :      catalogname = row [ 0 ] desc = SanitizeDescription ( catalogname , row [ 8 ] ) i_deps = cjson . decode ( row [ 7 ] ) i_deps_str = FormatPkginstList ( i_deps ) deps_with_desc = cjson . decode ( row [ 6 ] ) deps = [ x [ 0 ] for x in deps_with_desc if x [ 0 ] . startswith ( <str> ) ] deps_str = FormatPkginstList ( deps ) entry = representations . CatalogEntry ( catalogname = row [ 0 ] , version = row [ 1 ] , pkgname = row [ 2 ] , basename = row [ 3 ] , md5_sum = row [ 4 ] , size = row [ 5 ] , deps = deps_str , category = <str> , i_deps = i_deps_str , desc = desc , ) return entry  entries_list = [ MakeCatalogEntry ( row ) for row in rows ] return entries_list  class CatalogForGenerationAsDicts ( object ) :    def GET ( self , catrel_name , arch_name , osrel_name ) :      entries_list = GetCatalogEntries ( catrel_name , arch_name , osrel_name ) response_list = [ ] for entry in entries_list :        response_list . append ( entry . _asdict ( ) )  response = cjson . encode ( response_list ) web . header ( <str> , str ( len ( response ) ) ) return response   class CatalogTiming ( object ) :    def GET ( self , catrel_name , arch_name , osrel_name ) :      try :        sqo_osrel , sqo_arch , sqo_catrel = models . GetSqoTriad ( osrel_name , arch_name , catrel_name )  except sqlobject . main . SQLObjectNotFound :        raise web . notfound ( )  rows = list ( models . GetCatalogGenerationResult ( sqo_osrel , sqo_arch , sqo_catrel ) ) def MakeCatalogTimingEntry ( row ) :        catalogname = row [ 0 ] desc = SanitizeDescription ( catalogname , row [ 8 ] ) i_deps = tuple ( cjson . decode ( row [ 7 ] ) ) deps_with_desc = cjson . decode ( row [ 6 ] ) deps = tuple ( x [ 0 ] for x in deps_with_desc if x [ 0 ] . startswith ( <str> ) ) entry = representations . CatalogTimingEntry ( catalogname = catalogname , version = row [ 1 ] , pkgname = row [ 2 ] , basename = row [ 3 ] , md5_sum = row [ 4 ] , size = row [ 5 ] , deps = deps , category = <str> , i_deps = i_deps , desc = desc , maintainer = row [ 9 ] , mtime = row [ 10 ] . isoformat ( ) , inserted_on = row [ 11 ] . isoformat ( ) , inserted_by = row [ 12 ] , bundle = row [ 13 ] , ) return entry  rows = [ MakeCatalogTimingEntry ( x ) . _asdict ( ) for x in rows ] response = cjson . encode ( rows ) web . header ( <str> , str ( len ( response ) ) ) return response   debugme = False if debugme :    web . webapi . internalerror = web . debugerror  app = web . application ( urls , globals ( ) ) applogger = logging . getLogger ( <str> ) applogger . setLevel ( logging . DEBUG ) log_handler = logging . FileHandler ( filename = LOG_FILE_TMPL ) log_handler . setLevel ( logging . DEBUG ) log_formatter = logging . Formatter ( <str> <str> ) log_handler . setFormatter ( log_formatter ) applogger . addHandler ( log_handler ) def app_wrapper ( app ) :    applogger . debug ( <str> ) web_lib . ConnectToDatabase ( ) return app  if __name__ == <str> :    if debugme :      logging . basicConfig ( level = logging . DEBUG )  app . run ( )  else :    application = app_wrapper ( app ) . wsgifunc ( )   