import base64 import datetime import hashlib import logging import os import re import sys import tempfile from contextlib import contextmanager import cjson import lockfile import sqlobject import web from lib . python import checkpkg_lib from lib . python import configuration from lib . python import common_constants from lib . python import errors from lib . python import models from lib . python import opencsw from lib . python import relational_util from lib . web import web_lib CHUNK_SIZE = 2 * ( 1024 ** 2 ) urls = ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , ) templatedir = os . path . join ( os . path . dirname ( __file__ ) , <str> ) render = web . template . render ( templatedir ) config = configuration . GetConfig ( ) ALLPKGS_DIR = os . path . join ( config . get ( <str> , <str> ) , <str> ) applogger = logging . getLogger ( <str> ) applogger . setLevel ( logging . DEBUG ) log_handler = logging . FileHandler ( filename = config . get ( <str> , <str> ) ) log_handler . setLevel ( logging . DEBUG ) log_formatter = logging . Formatter ( <str> <str> ) log_handler . setFormatter ( log_formatter ) applogger . addHandler ( log_handler ) @ contextmanager def Transaction ( cls ) :    transaction = cls . _connection . transaction ( ) try :      yield transaction transaction . commit ( )  except :      transaction . rollback ( ) raise  finally :      transaction . commit ( close = True )   class Index ( object ) :    def GET ( self ) :      return   class Favicon ( object ) :    def GET ( self ) :      return <str>   def FileMd5 ( fd ) :    file_hash = hashlib . md5 ( ) data = fd . read ( CHUNK_SIZE ) while data :      file_hash . update ( data ) data = fd . read ( CHUNK_SIZE )  return file_hash . hexdigest ( )  def CopyFile ( infd , outfd ) :    infd . seek ( 0 ) data = infd . read ( CHUNK_SIZE ) while data :      os . write ( outfd , data ) data = infd . read ( CHUNK_SIZE )   class Srv4List ( object ) :    def POST ( self ) :      messages = [ ] x = web . input ( srv4_file = { } ) for field_name in ( <str> , <str> , <str> ) :        if field_name not in x :          raise web . badrequest ( <str> )   web . header ( <str> , <str> ) data_md5_sum = FileMd5 ( x [ <str> ] . file ) declared_md5_sum = x [ <str> ] basename = x [ <str> ] save_attempt = False error = False if declared_md5_sum != data_md5_sum :        raise web . conflict ( )  try :        srv4 = models . Srv4FileStats . selectBy ( md5_sum = data_md5_sum ) . getOne ( )  except sqlobject . main . SQLObjectNotFound :        messages . append ( <str> % data_md5_sum ) raise web . preconditionfailed ( )  if not srv4 . use_to_generate_catalogs :        messages . append ( <str> <str> % basename ) raise web . preconditionfailed ( )  target_path = os . path . join ( ALLPKGS_DIR , basename ) lock_path = os . path . join ( <str> , <str> . format ( basename ) ) target_file_lock = lockfile . FileLock ( lock_path ) with target_file_lock :        on_disk_md5_sum = data_md5_sum try :          with open ( target_path , <str> ) as fd :            on_disk_md5_sum = FileMd5 ( fd )   except IOError :          pass  if data_md5_sum != on_disk_md5_sum :          messages . append ( <str> <str> <str> % ( basename , on_disk_md5_sum , data_md5_sum ) ) raise web . conflict ( )  save_attempt = True fd , tmp_filename = tempfile . mkstemp ( dir = ALLPKGS_DIR ) CopyFile ( x [ <str> ] . file , fd ) os . close ( fd ) target_path = os . path . join ( ALLPKGS_DIR , basename ) os . rename ( tmp_filename , target_path ) os . chmod ( target_path , 0 644 )  messages . append ( { <str> : data_md5_sum , <str> : declared_md5_sum , <str> : save_attempt , } ) response = cjson . encode ( messages ) web . header ( <str> , str ( len ( response ) ) ) return response   class Srv4Detail ( object ) :    def GET ( self , md5_sum ) :      srv4 = None try :        srv4 = models . Srv4FileStats . selectBy ( md5_sum = md5_sum ) . getOne ( )  except sqlobject . main . SQLObjectNotFound :        raise web . notfound ( )  basename_in_allpkgs = os . path . join ( ALLPKGS_DIR , srv4 . basename ) if not os . path . exists ( basename_in_allpkgs ) :        raise web . notfound ( )  file_hash = hashlib . md5 ( ) with open ( basename_in_allpkgs ) as fd :        file_hash . update ( fd . read ( ) )  if md5_sum != file_hash . hexdigest ( ) :        raise web . notfound ( )  web . header ( <str> , <str> ) send_filename = <str> % md5_sum web . header ( <str> , <str> % send_filename ) response_data = { <str> : srv4 . md5_sum , <str> : srv4 . catalogname , <str> : srv4 . basename , <str> : srv4 . pkginst . pkgname , <str> : unicode ( srv4 . maintainer ) , <str> : srv4 . arch . name , <str> : srv4 . os_rel . short_name , } return cjson . encode ( response_data )   class Srv4CatalogAssignment ( object ) :    def GET ( self , catrel_name , arch_name , osrel_name ) :      sqo_osrel , sqo_arch , sqo_catrel = models . GetSqoTriad ( osrel_name , arch_name , catrel_name ) try :        srv4 = models . Srv4FileStats . selectBy ( md5_sum = md5_sum ) . getOne ( )  except sqlobject . main . SQLObjectNotFound as e :        raise web . notfound ( <str> % ( md5_sum ) )  applogger . debug ( <str> , srv4 . basename ) srv4_in_c = models . Srv4FileInCatalog . selectBy ( osrel = sqo_osrel , arch = sqo_arch , catrel = sqo_catrel , srv4file = srv4 ) web . header ( <str> , <str> ) response_data = { <str> : unicode ( srv4 ) , } return cjson . encode ( response_data )  def PUT ( self , catrel_name , arch_name , osrel_name , md5_sum ) :      catspec = checkpkg_lib . CatalogSpec ( catrel_name , arch_name , osrel_name ) applogger . info ( <str> , catspec , md5_sum ) try :        if arch_name == <str> :          raise web . badrequest ( <str> )  try :          srv4 = models . Srv4FileStats . selectBy ( md5_sum = md5_sum ) . getOne ( )  except sqlobject . main . SQLObjectNotFound :          try :            srv4 , _ = relational_util . StatsStructToDatabaseLevelOne ( md5_sum )  except errors . DataError as exc :            applogger . warning ( exc ) raise web . conflict ( )   parsed_basename = opencsw . ParsePackageFileName ( srv4 . basename ) if parsed_basename [ <str> ] not in ( <str> , <str> ) :          raise web . badrequest ( <str> % parsed_basename [ <str> ] )  if not srv4 . registered_level_two :          applogger . info ( <str> , srv4 . basename ) relational_util . StatsStructToDatabaseLevelTwo ( md5_sum , True )  c = checkpkg_lib . Catalog ( ) sqo_osrel , sqo_arch , sqo_catrel = models . GetSqoTriad ( osrel_name , arch_name , catrel_name ) with Transaction ( models . Srv4FileStats ) as trans :          applogger . info ( <str> <str> , catspec , srv4 . catalogname ) res = c . GetConflictingSrv4ByCatalognameResult ( srv4 , srv4 . catalogname , sqo_osrel , sqo_arch , sqo_catrel , trans ) if res . count ( ) >= 1 :            for pkg_in_catalog in res :              srv4_to_remove = pkg_in_catalog . srv4file applogger . info ( <str> <str> , srv4_to_remove . catalogname , catspec ) c . RemoveSrv4 ( srv4_to_remove , osrel_name , arch_name , catrel_name , trans )   else :            applogger . info ( <str> , srv4 . catalogname , catspec )  res = c . GetConflictingSrv4ByPkgnameResult ( srv4 , srv4 . pkginst . pkgname , sqo_osrel , sqo_arch , sqo_catrel , trans ) if res . count ( ) >= 1 :            for pkg_in_catalog in res :              srv4_to_remove = pkg_in_catalog . srv4file applogger . info ( <str> , srv4_to_remove . basename , catspec ) c . RemoveSrv4 ( srv4_to_remove , osrel_name , arch_name , catrel_name , trans )   else :            applogger . info ( <str> , srv4 . pkginst . pkgname , catspec )  username = web . ctx . env . get ( <str> ) applogger . info ( <str> , srv4 . basename , catspec ) c . AddSrv4ToCatalog ( srv4 , osrel_name , arch_name , catrel_name , username , trans ) web . header ( <str> , <str> ) response = cjson . encode ( [ <str> % ( catrel_name , arch_name , osrel_name ) , <str> % srv4 . basename , <str> % srv4 . md5_sum , ] ) web . header ( <str> , len ( response ) ) return response   except ( checkpkg_lib . CatalogDatabaseError , sqlobject . dberrors . OperationalError ) as exc :        applogger . error ( <str> , srv4 . basename , catspec ) web . header ( <str> , <str> ) response = cjson . encode ( { <str> : unicode ( exc ) } ) web . header ( <str> , str ( len ( response ) ) ) raise web . internalerror ( response )   def DELETE ( self , catrel_name , arch_name , osrel_name , md5_sum ) :      try :        if osrel_name not in common_constants . OS_RELS :          self . ReturnError ( <str> % ( osrel_name , common_constants . OS_RELS ) )  if ( osrel_name in common_constants . OBSOLETE_OS_RELS and catrel_name == <str> ) :          self . ReturnError ( <str> <str> % osrel_name )  srv4_to_remove = models . Srv4FileStats . selectBy ( md5_sum = md5_sum ) . getOne ( ) c = checkpkg_lib . Catalog ( ) with Transaction ( models . Srv4FileStats ) as trans :          c . RemoveSrv4 ( srv4_to_remove , osrel_name , arch_name , catrel_name , trans ) msg = ( <str> % ( srv4_to_remove . basename , md5_sum ) ) response = cjson . encode ( { <str> : msg } ) web . header ( <str> , len ( response ) ) return response   except ( sqlobject . main . SQLObjectNotFound , sqlobject . dberrors . OperationalError ) as e :        self . ReturnError ( <str> % e )   def ReturnError ( self , message ) :      web . header ( <str> , <str> ) response = cjson . encode ( { <str> : unicode ( message ) , } ) web . header ( <str> , len ( response ) ) raise web . notacceptable ( data = response )   class JsonStorage ( object ) :    BLOB_CLASSES = { <str> : models . Srv4FileStatsBlob , <str> : models . ElfdumpInfoBlob , } def GetBlobClass ( self , tag ) :      if tag not in self . BLOB_CLASSES :        raise web . badrequest ( cjson . encode ( { <str> : <str> % tag } ) )  return self . BLOB_CLASSES [ tag ]  def GetObject ( self , blob_class , md5_sum ) :      try :        obj = blob_class . selectBy ( md5_sum = md5_sum ) . getOne ( )  except sqlobject . main . SQLObjectNotFound as e :        raise web . notfound ( cjson . encode ( { <str> : <str> % ( blob_class , md5_sum ) } ) )  return obj  def GET ( self , tag , md5_sum ) :      BlobClass = self . GetBlobClass ( tag ) obj = self . GetObject ( BlobClass , md5_sum ) return obj . json  def HEAD ( self , tag , md5_sum ) :      BlobClass = self . GetBlobClass ( tag ) c = BlobClass . selectBy ( md5_sum = md5_sum ) . count ( ) if c > 0 :        web . header ( <str> , <str> ) return <str>  else :        web . header ( <str> , <str> ) raise web . notfound ( )   def PUT ( self , tag , md5_sum ) :      BlobClass = self . GetBlobClass ( tag ) mime_type = <str> x = web . input ( ) if <str> not in x :        raise web . badrequest ( <str> )  if <str> not in x :        raise web . badrequest ( <str> )  if md5_sum != x [ <str> ] :        raise web . badrequest ( <str> % ( md5_sum , x [ <str> ] ) )  json_data = x [ <str> ] content_hash = hashlib . md5 ( ) content_hash . update ( json_data ) content_md5_sum = content_hash . hexdigest ( ) try :        obj = BlobClass ( md5_sum = md5_sum , json = json_data , mime_type = mime_type , content_md5_sum = content_md5_sum )  except sqlobject . dberrors . DuplicateEntryError :        try :          obj = self . GetObject ( BlobClass , md5_sum ) obj . mime_type = mime_type obj . content_md5_sum = content_md5_sum obj . json = json_data  except sqlobject . main . SQLObjectNotFound :          raise web . internalerror ( <str> )   return cjson . encode ( { <str> : <str> % md5_sum } )  def DELETE ( self , tag , md5_sum ) :      BlobClass = self . GetBlobClass ( tag ) obj = self . GetObject ( BlobClass , md5_sum ) obj . destroySelf ( ) return cjson . encode ( { <str> : <str> } )   class QueryExistingSvr4 ( object ) :    def POST ( self ) :      form_data = web . input ( query_data = { } ) md5_sum_list = cjson . decode ( form_data [ <str> ] ) existing_stats = [ ] missing_stats = [ ] for md5 in md5_sum_list :        stats_count = models . Srv4FileStatsBlob . selectBy ( md5_sum = md5 ) . count ( ) if stats_count < 1 :          missing_stats . append ( md5 )  else :          existing_stats . append ( md5 )   ret_payload = cjson . encode ( { <str> : existing_stats , <str> : missing_stats , } ) web . header ( <str> , str ( len ( ret_payload ) ) ) return ret_payload   class Srv4RelationalLevelOne ( object ) :    def HEAD ( self , md5_sum ) :      try :        srv4 = models . Srv4FileStats . selectBy ( md5_sum = md5_sum ) . getOne ( )  except sqlobject . main . SQLObjectNotFound :        raise web . notfound ( <str> )  if not srv4 . registered_level_one :        raise web . notfound ( <str> )  return <str>  def PUT ( self , md5_sum ) :      try :        relational_util . StatsStructToDatabaseLevelOne ( md5_sum ) response = cjson . encode ( { <str> : <str> } ) web . header ( <str> , str ( len ( response ) ) ) return response  except errors . DataError as exc :        raise web . notacceptable ( exc )    class Srv4RelationalLevelTwo ( object ) :    def PUT ( self , md5_sum ) :      url_data = web . input ( use_in_catalogs = <str> ) negative_values = ( 0 , <str> , <str> , <str> , <str> , <str> ) use_in_catalogs = True if url_data [ <str> ] in negative_values :        use_in_catalogs = False  try :        relational_util . StatsStructToDatabaseLevelTwo ( md5_sum , use_in_catalogs = use_in_catalogs ) response = cjson . encode ( { <str> : <str> } ) web . header ( <str> , str ( len ( response ) ) ) return response  except errors . DataError as exc :        raise web . notacceptable ( exc )   def HEAD ( self , md5_sum ) :      payload = self . GET ( md5_sum ) return <str>  def GET ( self , md5_sum ) :      try :        srv4 = models . Srv4FileStats . selectBy ( md5_sum = md5_sum ) . getOne ( )  except sqlobject . main . SQLObjectNotFound :        raise web . notfound ( <str> )  if not srv4 . registered_level_two :        raise web . notfound ( <str> )  return <str>   class CatalogRelease ( object ) :    def PUT ( self , name ) :      if not re . match ( <str> , name ) :        raise web . conflict ( )  with Transaction ( models . Srv4FileStats ) as trans :        res = models . CatalogRelease . selectBy ( name = name , connection = trans ) if res . count ( ) :          return cjson . encode ( <str> % name )  models . CatalogRelease ( name = name , connection = trans )  return cjson . encode ( <str> % name )  def DELETE ( self , name ) :      with Transaction ( models . Srv4FileStats ) as trans :        try :          o = models . CatalogRelease . selectBy ( name = name , connection = trans ) . getOne ( )  except sqlobject . main . SQLObjectNotFound :          raise web . notfound ( )  res = models . Srv4FileInCatalog . select ( models . Srv4FileInCatalog . q . catrel == o , connection = trans ) if res . count ( ) :          raise web . conflict ( )  o . destroySelf ( ) return cjson . encode ( <str> % name )   def GET ( self , name ) :      try :        o = models . CatalogRelease . selectBy ( name = name ) . getOne ( ) return cjson . encode ( { <str> : name , <str> : unicode ( o ) } )  except sqlobject . main . SQLObjectNotFound :        raise web . notfound ( )    app = web . application ( urls , globals ( ) ) def app_wrapper ( app ) :    applogger . debug ( <str> ) web_lib . ConnectToDatabase ( ) return app . wsgifunc ( )  if __name__ == <str> :    logging . basicConfig ( level = logging . INFO ) app . run ( )  else :    application = app_wrapper ( app )   