import copy import datetime import hashlib import itertools import logging import marshal import os . path import progressbar import progressbar . widgets import re import sqlobject import sys from sqlobject import sqlbuilder from lib . python import checkpkg_lib from lib . python import common_constants from lib . python import configuration from lib . python import errors from lib . python import fake_pkgstats_composer from lib . python import models as m from lib . python import mute_progressbar from lib . python import opencsw from lib . python import representations from lib . python import rest from lib . python import sharedlib_utils from lib . python import shell from lib . python import util CONTENT_PKG_RE = <str> ALPHANUMERIC_RE = <str> class ParsingError ( errors . Error ) :     class PackageError ( errors . Error ) :     class DataError ( errors . Error ) :     class OsIndexingBase ( object ) :    def _ChunkName ( self , name ) :      return <str> % ( self . _Basename ( ) , name )  def SaveChunk ( self , name , data ) :      fn = self . _ChunkName ( name ) with open ( fn , <str> ) as fd :        logging . debug ( <str> , fn ) marshal . dump ( data , fd )   def ChunkExists ( self , name ) :      fn = self . _ChunkName ( name ) if os . path . exists ( fn ) :        logging . info ( <str> , fn ) return True  else :        logging . info ( <str> , fn ) return False   def LoadChunk ( self , name ) :      fn = self . _ChunkName ( name ) with open ( fn , <str> ) as fd :        logging . debug ( <str> , fn ) data = marshal . load ( fd )  return data  def _Basename ( self ) :      return <str> % ( self . osrel , self . arch )   class Indexer ( OsIndexingBase ) :    def __init__ ( self , out_basename = None , infile_contents = None , infile_pkginfo = None , osrel = None , arch = None ) :      super ( Indexer , self ) . __init__ ( ) self . out_basename = out_basename self . infile_contents = infile_contents self . infile_pkginfo = infile_pkginfo self . osrel = osrel self . arch = arch if not self . infile_contents :        self . infile_contents = common_constants . DEFAULT_INSTALL_CONTENTS_FILE  if not self . osrel :        self . osrel = self . _GetOsrel ( )  if not self . arch :        self . arch = self . _GetArch ( )  if not self . out_basename :        self . out_basename = self . _Basename ( )  logging . debug ( <str> , repr ( self . infile_contents ) , repr ( self . out_basename ) , repr ( self . osrel ) , repr ( self . arch ) ) assert self . out_basename is not None  def _ParseSrv4PkginfoLine ( self , line ) :      fields = re . split ( configuration . WS_RE , line ) pkgname = fields [ 1 ] pkg_desc = <str> . join ( fields [ 2 : ] ) return pkgname , pkg_desc  def _ParseIpsPkgListLine ( self , line ) :      fields = re . split ( configuration . WS_RE , line ) pkgname = self . _IpsNameToSrv4Name ( fields [ 0 ] ) desc_field_start = 1 if fields [ desc_field_start ] . startswith ( <str> ) :        desc_field_start += 1  pkg_desc = <str> . join ( fields [ desc_field_start : ] ) return pkgname , pkg_desc  def _ParseIpsPkgContentsLine ( self , line ) :      type_mapping = { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } parts = re . split ( configuration . WS_RE , line . strip ( ) ) if len ( parts ) < 4 :        raise ParsingError ( <str> % repr ( parts ) )  f_path = <str> + parts [ 0 ] f_target = None try :        f_type = type_mapping [ parts [ 1 ] ]  except :        raise ParsingError ( <str> % ( repr ( parts [ 1 ] ) , repr ( line ) ) )  f_mode = None f_owner = None f_group = None f_pkgname = None pkgnames = [ self . _IpsNameToSrv4Name ( parts [ 2 ] ) ] if f_type in ( <str> , <str> ) :        f_target = parts [ 3 ]  else :        ( f_mode , f_owner , f_group ) = parts [ 3 : 6 ]  return representations . PkgmapEntry ( line = line , class_ = None , mode = f_mode , owner = f_owner , group = f_group , path = f_path , target = f_target , type_ = f_type , major = None , minor = None , size = None , cksum = None , modtime = None , pkgnames = pkgnames , )  def _ParseSrv4PkgmapLine ( self , line ) :      if line . startswith ( <str> ) :        return None  parts = re . split ( configuration . WS_RE , line . strip ( ) ) if len ( parts ) < 4 :        raise ParsingError ( <str> % repr ( parts ) )  file_type = parts [ 1 ] f_path = None f_target = None f_type = None f_class = None f_major = None f_minor = None f_mode = None f_owner = None f_group = None f_size = None f_cksum = None f_modtime = None f_pkgname = None pkgnames = [ ] if file_type == <str> :        ( f_path_rpath , f_type , f_class ) = parts [ : 3 ] pkgnames . extend ( parts [ 3 : ] ) f_path , f_target = f_path_rpath . split ( <str> )  elif file_type == <str> :        f_path , f_type , f_class , f_pkgname = parts  elif file_type in ( <str> , <str> , <str> ) :        f_path , f_type , f_class , f_mode , f_owner , f_group = parts [ : 6 ] pkgnames . extend ( parts [ 6 : ] )  elif file_type == <str> :        logging . warning ( <str> , parts [ 0 ] ) f_type = <str> f_path , unused_type , f_class = parts [ : 3 ] pkgnames . extend ( parts [ 3 : ] )  elif file_type in ( <str> , <str> ) :        ( f_path , f_type , f_class , f_major , f_minor , f_mode , f_owner , f_group , f_pkgname ) = parts  elif file_type in ( <str> , <str> , <str> ) :        ( f_path , f_type , f_class , f_mode , f_owner , f_group , f_size , f_cksum , f_modtime ) = parts [ : 9 ] pkgnames . extend ( parts [ 9 : ] )  else :        raise ParsingError ( <str> % ( repr ( file_type ) , repr ( line ) ) )  if f_pkgname :        pkgnames . append ( f_pkgname )  static_parts = parts [ : 9 ] dynamic_parts = parts [ 9 : ] return representations . PkgmapEntry ( line = line , class_ = f_class , mode = f_mode , owner = f_owner , group = f_group , path = f_path , target = f_target , type_ = f_type , major = f_major , minor = f_minor , size = f_size , cksum = f_cksum , modtime = f_modtime , pkgnames = pkgnames , )  def _ParsePkgContents ( self , stream , parser , show_progress ) :      logging . debug ( <str> ) parsed_lines = [ ] c = itertools . count ( ) for line in stream :        if show_progress :          if not c . next ( ) % 1000 :            sys . stdout . write ( <str> ) sys . stdout . flush ( )   parsed_line = parser ( line ) if parsed_line :          parsed_lines . append ( tuple ( parsed_line ) )   if show_progress :        sys . stdout . write ( <str> )  logging . debug ( <str> ) return parsed_lines  def _GetUname ( self , uname_option = None ) :      args = [ <str> ] if uname_option :        args . append ( uname_option )  ret , stdout , unused_stderr = shell . ShellCommand ( args , allow_error = False ) return stdout . strip ( )  def _GetOsrel ( self ) :      osname = self . _GetUname ( ) osnumber = self . _GetUname ( <str> ) return osname + osnumber  def _GetArch ( self ) :      return self . _GetUname ( <str> )  def IndexAndSave ( self ) :      contents = None files_metadata = None show_progress = True if not self . ChunkExists ( <str> ) :        srv4_pkginfos_stream = self . _GetSrv4PkginfosStream ( ) if self . osrel in common_constants . IPS_OS_RELS :          ips_pkginfos_stream = self . _GetIpsPkginfosStream ( )  else :          ips_pkginfos_stream = None  pkginfo = self . _ParsePkginfoOutput ( srv4_pkginfos_stream , self . _ParseSrv4PkginfoLine , show_progress ) if ips_pkginfos_stream :          pkginfo . update ( self . _ParsePkginfoOutput ( ips_pkginfos_stream , self . _ParseIpsPkgListLine , show_progress ) )  self . SaveChunk ( <str> , pkginfo )  if not self . ChunkExists ( <str> ) :        srv4_pkgcontents_stream = self . _GetSrv4PkgcontentStream ( ) if self . osrel in common_constants . IPS_OS_RELS :          ips_pkgcontents_stream = self . _GetIpsPkgcontentStream ( )  else :          ips_pkgcontents_stream = None  contents_stream = open ( self . infile_contents , <str> ) contents = self . _ParsePkgContents ( contents_stream , self . _ParseSrv4PkgmapLine , show_progress = False ) if ips_pkgcontents_stream :          contents += self . _ParsePkgContents ( ips_pkgcontents_stream , self . _ParseIpsPkgContentsLine , show_progress )  self . SaveChunk ( <str> , contents )  if not self . ChunkExists ( <str> ) :        if not contents :          contents = self . LoadChunk ( <str> )  contents_namedtuple = [ representations . PkgmapEntry . _make ( x ) for x in contents ] fetch_metadata_for = [ x for x in contents_namedtuple if not x . path . startswith ( <str> ) ] files_metadata = self . _GetFilesMetadata ( fetch_metadata_for ) self . SaveChunk ( <str> , files_metadata ) del contents  if not self . ChunkExists ( <str> ) :        if not files_metadata :          files_metadata = self . LoadChunk ( <str> )  binaries_dump_info = ( [ tuple ( x ) for x in self . _GetBinariesDumpInfo ( files_metadata ) ] ) self . SaveChunk ( <str> , binaries_dump_info )   def _GetSrv4PkgcontentStream ( self ) :      return open ( self . infile_contents , <str> )  def _GetIpsPkgcontentStream ( self ) :      args = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> ] ret , stdout , unused_stderr = shell . ShellCommand ( args ) return stdout . splitlines ( )  def _GetSrv4PkginfosStream ( self ) :      if self . infile_pkginfo :        pkginfo_stream = open ( self . infile_pkginfo , <str> )  else :        args = [ <str> ] ret , stdout , stderr = shell . ShellCommand ( args ) pkginfo_stream = stdout . splitlines ( )  return pkginfo_stream  def _GetIpsPkginfosStream ( self ) :      args = [ <str> , <str> , <str> , <str> ] ret , stdout , stderr = shell . ShellCommand ( args ) pkglist_stream = stdout . splitlines ( ) return pkglist_stream  def _ParsePkginfoOutput ( self , pkginfo_stream , parser , unused_show_progress ) :      logging . debug ( <str> ) packages_by_pkgname = { } for line in pkginfo_stream :        pkgname , pkg_desc = parser ( line ) packages_by_pkgname . setdefault ( pkgname , pkg_desc )  logging . debug ( <str> ) return packages_by_pkgname  def _IpsNameToSrv4Name ( self , ips_name ) :      return <str> + <str> . join ( re . findall ( ALPHANUMERIC_RE , ips_name ) )  def _GetFilesMetadata ( self , contents ) :      logging . debug ( <str> ) file_magic = util . FileMagic ( ) files_metadata = [ ] counter = itertools . count ( ) counter_max = len ( contents ) for d in contents :        p = d . path iteration_number = counter . next ( ) sys . stdout . write ( <str> % ( iteration_number , counter_max , p [ : 60 ] ) ) sys . stdout . flush ( ) file_info = util . GetFileMetadata ( file_magic , <str> , p ) if file_info :          files_metadata . append ( tuple ( file_info ) )   sys . stdout . write ( <str> ) sys . stdout . flush ( ) return files_metadata  def _GetBinariesDumpInfo ( self , files_metadata ) :      binaries_dump_info = [ ] for metadata_tuple in files_metadata :        file_metadata = representations . FileMetadata . _make ( metadata_tuple ) d = file_metadata . _asdict ( ) if sharedlib_utils . IsBinary ( d , allow_missing = True ) :          abs_path = d [ <str> ] sys . stdout . write ( <str> % ( abs_path [ : 78 ] ) ) sys . stdout . flush ( ) binary_path = d [ <str> ] if binary_path . startswith ( <str> ) :            binary_path = binary_path [ 1 : ]  binaries_dump_info . append ( util . GetBinaryDumpInfo ( abs_path , binary_path ) )   sys . stdout . write ( <str> ) sys . stdout . flush ( ) return binaries_dump_info   class InstallContentsImporter ( OsIndexingBase ) :    def __init__ ( self , osrel , arch , debug = False ) :      super ( InstallContentsImporter , self ) . __init__ ( ) self . osrel = osrel self . arch = arch self . pkginst_cache = { } config = configuration . GetConfig ( ) username , password = rest . GetUsernameAndPassword ( ) self . rest_client = rest . RestClient ( pkgdb_url = config . get ( <str> , <str> ) , releases_url = config . get ( <str> , <str> ) , username = username , password = password , debug = debug )  def _RemoveSystemPackagesFromCatalog ( self , data ) :      sqo_osrel , sqo_arch = self . _GetSqoOsrelAndArch ( data [ <str> ] , data [ <str> ] ) result = m . Srv4FileInCatalog . select ( sqlobject . AND ( m . Srv4FileInCatalog . q . arch == sqo_arch , m . Srv4FileInCatalog . q . osrel == sqo_osrel ) ) for catalog_assignment in result :        if not catalog_assignment . srv4file . use_to_generate_catalogs :          catalog_assignment . destroySelf ( )    def ImportData ( self , data , show_progress = False , include_prefixes = None ) :      logging . debug ( <str> ) self . _RemoveSystemPackagesFromCatalog ( data ) logging . debug ( <str> ) pkgstats_list = self . _ComposePkgstats ( data ) catalogs_to_insert_to = common_constants . DEFAULT_CATALOG_RELEASES logging . info ( <str> % <str> . join ( catalogs_to_insert_to ) ) pbar = self . _GetPbar ( show_progress ) pbar . maxval = len ( pkgstats_list ) pbar . start ( ) for i , pkgstats in enumerate ( pkgstats_list ) :        md5_sum = pkgstats [ <str> ] [ <str> ] if not self . rest_client . BlobExists ( <str> , md5_sum ) :          self . rest_client . SaveBlob ( <str> , md5_sum , pkgstats )  if not self . rest_client . IsRegisteredLevelTwo ( md5_sum ) :          self . rest_client . RegisterLevelTwo ( md5_sum , use_in_catalogs = False )  for catalog_release in catalogs_to_insert_to :          self . rest_client . AddSvr4ToCatalog ( catalog_release , data [ <str> ] , data [ <str> ] , md5_sum )  pbar . update ( i )  pbar . finish ( )  def _GetSqoOsrelAndArch ( self , osrel , arch ) :      sqo_osrel = m . OsRelease . selectBy ( short_name = osrel ) . getOne ( ) sqo_arch = m . Architecture . selectBy ( name = arch ) . getOne ( ) return sqo_osrel , sqo_arch  def _GetPbar ( self , show_progress ) :      if show_progress :        pbar = progressbar . ProgressBar ( widgets = [ progressbar . widgets . Percentage ( ) , <str> , progressbar . widgets . ETA ( ) , <str> , progressbar . widgets . Bar ( ) ] )  else :        pbar = mute_progressbar . MuteProgressBar ( )  return pbar  def SanitizeInstallContentsPkgname ( self , pkgname ) :      pkgname_orig = pkgname pkgname = pkgname . split ( <str> ) [ 0 ] for c in ( <str> , <str> , <str> ) :        pkgname = pkgname . lstrip ( c )  return pkgname  def _SkipPrefix ( self , pkgname , include_prefixes ) :      skip_pkgname = False for prefix in common_constants . OWN_PKGNAME_PREFIXES :        if pkgname . startswith ( prefix ) :          skip_pkgname = True break   if include_prefixes :        for prefix_to_include in include_prefixes :          if pkgname . startswith ( prefix_to_include ) :            skip_pkgname = False break    return skip_pkgname  def _ComposePkgstats ( self , data , include_prefixes = None , show_progress = True ) :      logging . debug ( <str> ) osrel = data [ <str> ] arch = data [ <str> ] contents = data [ <str> ] files_metadata = [ representations . FileMetadata . _make ( x ) for x in data [ <str> ] ] logging . debug ( <str> ) metadata_by_file_name = dict ( ( x . path , x ) for x in files_metadata ) catalog = checkpkg_lib . Catalog ( ) srv4_files_to_catalog = set ( ) cleaned_pkgs = set ( ) pkgs_by_pkgname = { } pbar = self . _GetPbar ( show_progress ) progressbar_divisor = int ( len ( contents ) / 1000 ) if progressbar_divisor < 1 :        progressbar_divisor = 1  update_period = 1 L pbar . maxval = len ( contents ) pbar . start ( ) count = itertools . count ( ) plc = fake_pkgstats_composer . PkgstatsListComposer ( osrel , arch ) for pkgmap_tuple in contents :        pkgmap_entry = representations . PkgmapEntry . _make ( pkgmap_tuple ) logging . debug ( <str> , pkgmap_entry ) for pkgname in pkgmap_entry . pkgnames :          pkgname = self . SanitizeInstallContentsPkgname ( pkgname ) if not self . _SkipPrefix ( pkgname , include_prefixes ) :            if pkgmap_entry . path not in metadata_by_file_name :              continue  plc . AddPkgname ( pkgname ) plc . AddFile ( pkgname , pkgmap_entry , metadata_by_file_name [ pkgmap_entry . path ] , None , None )   i = count . next ( ) if not i % update_period and ( i / progressbar_divisor ) <= pbar . maxval :          pbar . update ( i / progressbar_divisor )   pbar . finish ( ) return plc . GetPkgstats ( )  def Import ( self , show_progress ) :      pkginfo = self . LoadChunk ( <str> ) contents = self . LoadChunk ( <str> ) files_metadata = self . LoadChunk ( <str> ) binaries_dump_info = self . LoadChunk ( <str> ) self . ImportData ( { <str> : pkginfo , <str> : contents , <str> : files_metadata , <str> : binaries_dump_info , <str> : self . osrel , <str> : self . arch , } , show_progress = show_progress )    