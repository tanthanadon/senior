from Cheetah import Template import cjson import logging import optparse import rest import sys import re from lib . python import configuration from lib . python import common_constants from lib . python import catalog from lib . python import opencsw CATALOG_MOD_TMPL = class Error ( Exception ) :     class UsageError ( Error ) :     def IndexDictByField ( d , field ) :    return dict ( ( x [ field ] , x ) for x in d )  def GetCatalogs ( catrel_from , catrel_to , include_version_changes , include_downgrades , rest_client ) :    def GetCatalog ( rest_client , r_catrel , r_arch , r_osrel ) :      key = r_catrel , r_arch , r_osrel catalog = rest_client . GetCatalog ( * key ) return ( key , catalog )  catalogs_to_fetch_args = [ ] for arch in common_constants . PHYSICAL_ARCHITECTURES :      for osrel in common_constants . OS_RELS :        for catrel in ( catrel_from , catrel_to ) :          catalogs_to_fetch_args . append ( ( rest_client , catrel , arch , osrel ) )    catalogs = dict ( map ( lambda x : GetCatalog ( * x ) , catalogs_to_fetch_args ) ) return catalogs  def ComposeDiffsByCatalogname ( catalogs , catrel_from , catrel_to , include_version_changes , include_downgrades ) :    diffs_by_catalogname = { } for arch in common_constants . PHYSICAL_ARCHITECTURES :      logging . debug ( <str> , arch ) for osrel in common_constants . OS_RELS :        logging . debug ( <str> , osrel ) cat_from = catalogs [ ( catrel_from , arch , osrel ) ] cat_to = catalogs [ ( catrel_to , arch , osrel ) ] if cat_from is None :          cat_from = [ ]  if cat_to is None :          cat_to = [ ]  cat_from_by_c = IndexDictByField ( cat_from , <str> ) cat_to_by_c = IndexDictByField ( cat_to , <str> ) comparator = catalog . CatalogComparator ( ) new_pkgs , removed_pkgs , updated_pkgs = comparator . GetCatalogDiff ( cat_to_by_c , cat_from_by_c ) for pkg in new_pkgs :          catalogname_d = diffs_by_catalogname . setdefault ( ( pkg [ <str> ] ) , { } ) catalogname_d . setdefault ( <str> , [ ] ) . append ( ( arch , osrel , pkg ) )  for pkg in removed_pkgs :          catalogname_d = diffs_by_catalogname . setdefault ( ( pkg [ <str> ] ) , { } ) catalogname_d . setdefault ( <str> , [ ] ) . append ( ( arch , osrel , pkg ) )  for pkg_pair in updated_pkgs :          update_decision_by_type = { <str> : True , <str> : include_version_changes , } if ( update_decision_by_type [ pkg_pair [ <str> ] ] and ( pkg_pair [ <str> ] == <str> or include_downgrades ) ) :            pkg = pkg_pair [ <str> ] catalogname_d = diffs_by_catalogname . setdefault ( ( pkg [ <str> ] ) , { } ) catalogname_d . setdefault ( <str> , [ ] ) . append ( ( arch , osrel , pkg_pair ) )     return diffs_by_catalogname  def main ( ) :    parser = optparse . OptionParser ( ) parser . add_option ( <str> , dest = <str> , default = <str> , help = <str> ) parser . add_option ( <str> , dest = <str> , default = <str> , help = <str> ) parser . add_option ( <str> , dest = <str> , help = ( <str> <str> ) ) parser . add_option ( <str> , dest = <str> , help = <str> ) parser . add_option ( <str> , <str> , dest = <str> , help = <str> ) parser . add_option ( <str> , dest = <str> , default = True , action = <str> , help = <str> ) parser . add_option ( <str> , dest = <str> , default = True , action = <str> , help = <str> ) parser . add_option ( <str> , dest = <str> , default = False , action = <str> ) options , args = parser . parse_args ( ) logging_level = logging . INFO if options . debug :      logging_level = logging . DEBUG  fmt = <str> logging . basicConfig ( format = fmt , level = logging_level ) config = configuration . GetConfig ( ) username , password = rest . GetUsernameAndPassword ( ) rest_client = rest . RestClient ( pkgdb_url = config . get ( <str> , <str> ) , releases_url = config . get ( <str> , <str> ) , username = username , password = password ) if not options . output_file :      raise UsageError ( <str> )  catrel_from = options . catrel_from catrel_to = options . catrel_to if options . from_json :      with open ( options . from_json , <str> ) as fd :        logging . info ( <str> , options . from_json ) ( bundles_by_md5 , jsonable_catalogs , diffs_by_catalogname ) = cjson . decode ( fd . read ( ) ) catalogs = dict ( ( tuple ( cjson . decode ( x ) ) , jsonable_catalogs [ x ] ) for x in jsonable_catalogs )   else :      catalogs = GetCatalogs ( catrel_from , catrel_to , options . include_version_changes , options . include_downgrades , rest_client ) diffs_by_catalogname = ComposeDiffsByCatalogname ( catalogs , catrel_from , catrel_to , options . include_version_changes , options . include_downgrades ) bundles_by_md5 = { } bundles_missing = set ( ) cp = rest . CachedPkgstats ( <str> , rest_client ) for key in catalogs :        if catalogs [ key ] :          for pkg in catalogs [ key ] :            md5 = pkg [ <str> ] if md5 not in bundles_by_md5 and md5 not in bundles_missing :              stats = cp . GetPkgstats ( md5 ) bundle_key = <str> if stats :                if bundle_key in stats [ <str> ] :                  bundles_by_md5 [ md5 ] = stats [ <str> ] [ bundle_key ]  else :                  logging . debug ( <str> , stats [ <str> ] [ <str> ] , md5 ) bundles_missing . add ( md5 )        change_types = <str> , <str> , <str> bundles_by_catalogname = { } for catalogname in diffs_by_catalogname :      l = bundles_by_catalogname . setdefault ( catalogname , set ( ) ) for change_type in change_types :        if change_type in diffs_by_catalogname [ catalogname ] :          for change_info in diffs_by_catalogname [ catalogname ] [ change_type ] :            pkg = change_info [ 2 ] if <str> in pkg :              md5s = [ x [ <str> ] for x in ( pkg [ <str> ] , pkg [ <str> ] ) ]  else :              md5s = [ pkg [ <str> ] ]  for md5 in md5s :              if md5 in bundles_by_md5 :                l . add ( bundles_by_md5 [ md5 ] )       namespace = { <str> : bundles_by_catalogname , <str> : bundles_by_md5 , <str> : diffs_by_catalogname , <str> : catrel_to , <str> : catrel_from , <str> : sys . argv [ 0 ] , } if options . save_json :      with open ( options . save_json , <str> ) as fd :        jsonable_catalogs = dict ( ( cjson . encode ( x ) , catalogs [ x ] ) for x in catalogs ) fd . write ( cjson . encode ( ( bundles_by_md5 , jsonable_catalogs , diffs_by_catalogname ) ) )   t = Template . Template ( CATALOG_MOD_TMPL , searchList = [ namespace ] ) if options . output_file :      logging . info ( <str> , options . output_file ) with open ( options . output_file , <str> ) as fd :        fd . write ( unicode ( t ) )   else :      sys . stdout . write ( unicode ( t ) )   if __name__ == <str> :    main ( )   