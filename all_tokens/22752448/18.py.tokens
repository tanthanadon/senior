import copy import logging import os import pipes import signal import subprocess from lib . python import errors class ShellError ( errors . Error ) :     class TimeoutExpired ( errors . Error ) :     def TimeoutHandler ( signum , frame ) :    raise TimeoutExpired  def ShellCommand ( args , env = None , timeout = None , quiet = True , allow_error = False , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) :    logging . debug ( <str> , <str> . join ( pipes . quote ( x ) for x in args ) ) if not env :      env = copy . copy ( os . environ )  env [ <str> ] = <str> if timeout :      signal . signal ( signal . SIGALRM , TimeoutHandler ) signal . alarm ( timeout )  try :      proc = subprocess . Popen ( args , stdout = stdout , stderr = stderr , env = env , preexec_fn = os . setsid , close_fds = True ) stdout , stderr = proc . communicate ( ) retcode = proc . wait ( ) signal . alarm ( 0 )  except TimeoutExpired :      os . kill ( - proc . pid , signal . SIGKILL ) msg = <str> % args raise TimeoutExpired ( msg )  if retcode and not allow_error :      logging . critical ( stdout ) logging . critical ( stderr ) raise ShellError ( <str> <str> % ( args , retcode , <str> . join ( pipes . quote ( x ) for x in args ) ) )  return retcode , stdout , stderr  def MakeDirP ( self , dir_path , exc_class = None ) :    try :      os . makedirs ( dir_path )  except OSError as exc :      if exc . errno == errno . EEXIST and os . path . isdir ( dir_path ) :        pass  else :        if exc_class :          raise exc_class ( <str> % ( dir_path , exc ) )  else :          raise      