from himlarcli import tests as tests tests . is_virtual_env ( ) from himlarcli . parser import Parser from himlarcli . printer import Printer from himlarcli import utils as himutils from himlarcli . nova import Nova from himlarcli . keystone import Keystone from himlarcli . statsdclient import StatsdClient parser = Parser ( ) options = parser . parse_args ( ) printer = Printer ( options . format ) kc = Keystone ( options . config , debug = options . debug ) kc . set_domain ( options . domain ) kc . set_dry_run ( options . dry_run ) logger = kc . get_logger ( ) statsd = StatsdClient ( options . config , debug = options . debug , log = logger ) statsd . set_dry_run ( options . dry_run ) if hasattr ( options , <str> ) :      regions = kc . find_regions ( region_name = options . region )  else :      regions = kc . find_regions ( )  def action_compute ( ) :      stats = dict ( ) for region in regions :          drop_az = [ <str> , <str> % region ] metrics = [ <str> , <str> , <str> , <str> , <str> , <str> ] nc = Nova ( options . config , debug = options . debug , region = region , log = logger ) aggregates = nc . get_aggregates ( False ) for a in aggregates :              a_name = <str> % ( region , a . name ) stats [ a_name ] = dict ( ) if a . availability_zone in drop_az :                  continue  hosts = nc . get_aggregate_hosts ( a . name , True ) for host in hosts :                  for metric in metrics :                      logger . debug ( <str> , host . hypervisor_hostname , metric , getattr ( host , metric ) ) stats [ a_name ] [ metric ] = int ( getattr ( host , metric ) + stats [ a_name ] . get ( metric , 0 ) )     statsd . gauge_dict ( <str> , stats ) if not options . quiet :          for name , stat in stats . iteritems ( ) :              printer . output_dict ( { <str> : name } ) printer . output_dict ( stat )    def action_legacy ( ) :      projects_count = kc . get_project_count ( <str> ) users_count = kc . get_user_count ( <str> ) stats = dict ( ) stats [ <str> ] = { } stats [ <str> ] = { } stats [ <str> ] = { } stats [ <str> ] [ <str> ] = { <str> : 0 , <str> : 0 } for region in regions :          logger . debug ( <str> % region ) stats [ <str> ] [ region ] = { } stats [ <str> ] [ <str> ] = { } stats [ <str> ] [ region ] [ <str> ] = projects_count stats [ <str> ] [ <str> ] [ <str> ] = projects_count stats [ <str> ] [ region ] = { } stats [ <str> ] [ <str> ] = { } stats [ <str> ] [ region ] [ <str> ] = users_count stats [ <str> ] [ <str> ] [ <str> ] = users_count novaclient = Nova ( options . config , debug = options . debug , region = region , log = logger ) novastats = novaclient . get_stats ( ) stats [ <str> ] [ region ] = { } stats [ <str> ] [ region ] [ <str> ] = novastats [ <str> ] stats [ <str> ] [ region ] [ <str> ] = novastats [ <str> ] stats [ <str> ] [ <str> ] [ <str> ] += novastats [ <str> ] stats [ <str> ] [ <str> ] [ <str> ] += novastats [ <str> ]  for t , s in stats . iteritems ( ) :          for r , d in s . iteritems ( ) :              name = <str> % ( r , t ) count = d [ <str> ] if not options . quiet :                  print <str> % ( name , count )  statsd . gauge ( name , count ) if <str> in d :                  name = <str> % ( r ) if not options . quiet :                      print <str> % ( name , d [ <str> ] )  statsd . gauge ( name , d [ <str> ] )     action = locals ( ) . get ( <str> + options . action . replace ( <str> , <str> ) ) if not action :      himutils . sys_error ( <str> % options . action )  action ( )  