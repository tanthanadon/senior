from himlarcli . keystone import Keystone from himlarcli . nova import Nova from himlarcli . cinder import Cinder from himlarcli . parser import Parser from himlarcli . printer import Printer from himlarcli import utils as himutils himutils . is_virtual_env ( ) parser = Parser ( ) options = parser . parse_args ( ) printer = Printer ( options . format ) ksclient = Keystone ( options . config , debug = options . debug ) ksclient . set_dry_run ( options . dry_run ) logger = ksclient . get_logger ( ) local_aggregates = [ <str> , <str> , <str> , <str> ] if hasattr ( options , <str> ) :      regions = ksclient . find_regions ( region_name = options . region )  else :      regions = ksclient . find_regions ( )  if not regions :      himutils . sys_error ( <str> )  def action_volume ( ) :      projects = ksclient . get_all_projects ( ) for region in regions :          cc = himutils . get_client ( Cinder , options , logger , region ) nc = himutils . get_client ( Nova , options , logger , region ) vms_pool = dict ( { <str> : 0 } ) for aggregate in nc . get_aggregates ( True ) :              if aggregate in local_aggregates :                  continue  hosts = nc . get_aggregate_hosts ( aggregate , True ) for host in hosts :                  vms_pool [ <str> ] += int ( host . local_gb_used )   printer . output_dict ( { <str> : <str> % region } ) printer . output_dict ( vms_pool ) quotas = dict ( { <str> : 0 , <str> : 0 } ) for project in projects :              if not hasattr ( project , <str> ) :                logger . debug ( <str> , project . name ) continue  if not options . demo and project . type == <str> :                  continue  quota = cc . get_quota ( project_id = project . id , usage = True ) quotas [ <str> ] += quota [ <str> ] [ <str> ] quotas [ <str> ] += quota [ <str> ] [ <str> ]  volumes = cc . get_volumes ( True ) volume_usage = { <str> : 0 , <str> : 0 } for volume in volumes :              volume_usage [ <str> ] += volume . size volume_usage [ <str> ] += 1  pools = cc . get_pools ( detail = True ) tmp = pools . to_dict ( ) for pool in pools . pools :              name = pool [ <str> ] [ <str> ] out_pool = dict ( ) out_pool [ <str> ] = pool [ <str> ] [ <str> ] out_pool [ <str> ] = pool [ <str> ] [ <str> ] printer . output_dict ( { <str> : <str> % ( region , name ) } ) printer . output_dict ( out_pool )  out_pools = dict ( ) out_pools [ <str> ] = volume_usage [ <str> ] out_pools [ <str> ] = float ( quotas [ <str> ] ) out_pools [ <str> ] = volume_usage [ <str> ] out_pools [ <str> ] = float ( quotas [ <str> ] ) printer . output_dict ( { <str> : <str> % region } ) printer . output_dict ( out_pools )   def action_instance ( ) :      for region in regions :          flavors = dict ( ) cores = ram = 0 novaclient = Nova ( options . config , debug = options . debug , log = logger , region = region ) instances = novaclient . get_instances ( ) total = 0 for i in instances :              project = ksclient . get_by_id ( <str> , i . tenant_id ) if not options . demo and project and <str> in project . name :                  continue  flavor_name = i . flavor . get ( <str> , <str> ) flavors [ flavor_name ] = flavors . get ( flavor_name , 0 ) + 1 cores += i . flavor . get ( <str> , 0 ) ram += i . flavor . get ( <str> , 0 ) total += 1  printer . output_dict ( { <str> : <str> % region } ) printer . output_dict ( flavors ) printer . output_dict ( { <str> : <str> % region } ) printer . output_dict ( { <str> : cores , <str> : <str> % int ( ram ) , <str> : total } )   action = locals ( ) . get ( <str> + options . action ) if not action :      himutils . sys_error ( <str> % options . action )  action ( )  