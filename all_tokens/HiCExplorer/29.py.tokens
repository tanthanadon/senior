import warnings warnings . simplefilter ( action = <str> , category = RuntimeWarning ) warnings . simplefilter ( action = <str> , category = PendingDeprecationWarning ) import argparse import re from tempfile import NamedTemporaryFile import subprocess from Bio import SeqIO from Bio . Seq import Seq from Bio . Alphabet import generic_dna from hicexplorer . _version import __version__ import logging log = logging . getLogger ( __name__ ) def parse_arguments ( args = None ) :      parser = argparse . ArgumentParser ( description = <str> , add_help = False , usage = <str> <str> ) parserRequired = parser . add_argument_group ( <str> ) parserRequired . add_argument ( <str> , <str> , help = <str> , type = argparse . FileType ( <str> ) , required = True ) parserRequired . add_argument ( <str> , <str> , help = <str> <str> <str> <str> <str> , required = True ) parserRequired . add_argument ( <str> , <str> , help = <str> , type = argparse . FileType ( <str> ) , required = True ) parserOpt = parser . add_argument_group ( <str> ) parserOpt . add_argument ( <str> , <str> , action = <str> , help = <str> ) parserOpt . add_argument ( <str> , action = <str> , version = <str> . format ( __version__ ) ) return parser  def find_pattern ( pattern , fasta_file , out_file ) :      <str> rev_compl = str ( Seq ( pattern , generic_dna ) . reverse_complement ( ) ) temp = NamedTemporaryFile ( suffix = <str> , delete = False , mode = <str> ) for record in SeqIO . parse ( fasta_file , <str> , generic_dna ) :          for match in re . finditer ( pattern , str ( record . seq ) , re . IGNORECASE ) :              _ = temp . write ( <str> . format ( record . name , match . start ( ) , match . end ( ) ) )  if rev_compl != pattern :              for match in re . finditer ( rev_compl , str ( record . seq ) , re . IGNORECASE ) :                  _ = temp . write ( <str> . format ( record . name , match . start ( ) , match . end ( ) ) )    log . info ( <str> ) tmpfile_name = temp . name temp . close ( ) subprocess . check_output ( [ <str> , tmpfile_name ] ) cmd = <str> . format ( tmpfile_name ) proc = subprocess . Popen ( cmd . split ( <str> ) , stdout = subprocess . PIPE , env = { <str> : <str> } , universal_newlines = True ) stdout , _ = proc . communicate ( ) out_file . write ( stdout ) out_file . close ( ) temp . close ( )  def main ( ) :      args = parse_arguments ( ) . parse_args ( ) find_pattern ( args . searchPattern , args . fasta , args . outFile )   