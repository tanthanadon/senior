import warnings warnings . simplefilter ( action = <str> , category = RuntimeWarning ) warnings . simplefilter ( action = <str> , category = PendingDeprecationWarning ) import argparse from scipy . sparse import csr_matrix , lil_matrix from scipy import linalg from scipy . stats import pearsonr import numpy as np import pyBigWig from hicmatrix import HiCMatrix as hm from hicexplorer . _version import __version__ from hicexplorer . utilities import obs_exp_matrix_lieberman , obs_exp_matrix_norm from hicexplorer . utilities import convertNansToZeros , convertInfsToZeros from hicexplorer . utilities import enlarge_bins from hicexplorer . parserCommon import CustomFormatter from hicexplorer . utilities import toString from hicexplorer . utilities import opener from hicmatrix . lib import MatrixFileHandler from . readBed import ReadBed import logging log = logging . getLogger ( __name__ ) def parse_arguments ( ) :      parser = argparse . ArgumentParser ( formatter_class = CustomFormatter , add_help = False , conflict_handler = <str> , description = ) parserRequired = parser . add_argument_group ( <str> ) parserRequired . add_argument ( <str> , <str> , help = <str> , required = True ) parserRequired . add_argument ( <str> , <str> , help = <str> <str> <str> <str> , nargs = <str> , default = [ <str> , <str> ] , required = True ) parserOpt = parser . add_argument_group ( <str> ) parserOpt . add_argument ( <str> , <str> , help = <str> <str> , default = 2 , type = int , required = False ) parserOpt . add_argument ( <str> , <str> , help = <str> , choices = [ <str> , <str> ] , default = <str> , required = False ) parserOpt . add_argument ( <str> , help = <str> <str> , default = None , nargs = <str> ) parserOpt . add_argument ( <str> , help = <str> <str> , action = <str> ) parserOpt . add_argument ( <str> , help = <str> <str> <str> <str> , default = None ) parserOpt . add_argument ( <str> , help = <str> <str> <str> , default = <str> ) parserOpt . add_argument ( <str> , <str> , help = <str> <str> <str> <str> <str> ) parserOpt . add_argument ( <str> , <str> , help = <str> <str> <str> <str> <str> ) parserOpt . add_argument ( <str> , help = <str> , action = <str> ) parserOpt . add_argument ( <str> , <str> , action = <str> , help = <str> <str> ) parserOpt . add_argument ( <str> , action = <str> , version = <str> . format ( __version__ ) ) return parser  def correlateEigenvectorWithGeneTrack ( pMatrix , pEigenvector , pGeneTrack ) :      file_h = opener ( pGeneTrack ) bed = ReadBed ( file_h ) gene_occurrence = np . zeros ( len ( pMatrix . cut_intervals ) ) gene_occurrence_per_chr = { } chromosome_list = pMatrix . getChrNames ( ) for interval in bed :          chromosome_name = interval . chromosome if chromosome_name not in chromosome_list :              continue  bin_id = pMatrix . getRegionBinRange ( interval . chromosome , interval . start , interval . end ) gene_occurrence [ bin_id [ 1 ] ] += 1  for chromosome in chromosome_list :          bin_id = pMatrix . getChrBinRange ( chromosome ) gene_occurrence_per_chr [ chromosome ] = gene_occurrence [ bin_id [ 0 ] : bin_id [ 1 ] ]  pEigenvector = np . array ( pEigenvector ) . real . transpose ( ) for chromosome in chromosome_list :          bin_id = pMatrix . getChrBinRange ( chromosome ) for i , eigenvector in enumerate ( pEigenvector ) :              _correlation = pearsonr ( eigenvector [ bin_id [ 0 ] : bin_id [ 1 ] ] . real , gene_occurrence_per_chr [ chromosome ] ) if _correlation [ 0 ] < 0 :                  eigenvector [ bin_id [ 0 ] : bin_id [ 1 ] ] = np . negative ( eigenvector [ bin_id [ 0 ] : bin_id [ 1 ] ] )    return np . array ( pEigenvector ) . transpose ( )  def correlateEigenvectorWithHistonMarkTrack ( pEigenvector , bwTrack , chromosome , start , end , pHistonMarkTrack , pHistonMarkType ) :      for index , vector in enumerate ( pEigenvector ) :          pos_indices = np . where ( vector > 0 ) [ 0 ] neg_indices = np . where ( vector < 0 ) [ 0 ] pos_sum = 0 neg_sum = 0 pos_mean = 0 neg_mean = 0 if chromosome in bwTrack . chroms ( ) . keys ( ) :              for ind in pos_indices :                  if bwTrack . stats ( chromosome , start [ ind ] , end [ ind ] ) [ 0 ] :                      pos_sum += bwTrack . stats ( chromosome , start [ ind ] , end [ ind ] ) [ 0 ]   if pos_sum != 0 :                  pos_mean = pos_sum / len ( pos_indices )  for ind in neg_indices :                  if bwTrack . stats ( chromosome , start [ ind ] , end [ ind ] ) [ 0 ] :                      neg_sum += bwTrack . stats ( chromosome , start [ ind ] , end [ ind ] ) [ 0 ]   if neg_sum != 0 :                  neg_mean = neg_sum / len ( neg_indices )  if pHistonMarkType == <str> :                  if ( pos_mean < neg_mean ) and ( neg_mean != 0 ) and ( pos_mean != 0 ) :                      vector [ pos_indices ] = np . negative ( vector [ pos_indices ] ) vector [ neg_indices ] = np . negative ( vector [ neg_indices ] )   else :                  assert ( pHistonMarkType == <str> ) if ( pos_mean > neg_mean ) and ( neg_mean != 0 ) and ( pos_mean != 0 ) :                      vector [ pos_indices ] = - 1 * vector [ pos_indices ] vector [ neg_indices ] = - 1 * vector [ neg_indices ]    pEigenvector [ index ] = vector   def main ( args = None ) :      args = parse_arguments ( ) . parse_args ( args ) if int ( args . numberOfEigenvectors ) != len ( args . outputFileName ) :          log . error ( <str> <str> <str> <str> . format ( args . outputFileName , args . numberOfEigenvectors ) ) exit ( 1 )  ma = hm . hiCMatrix ( args . matrix ) ma . maskBins ( ma . nan_bins ) if args . ignoreMaskedBins :          new_intervals = enlarge_bins ( ma . cut_intervals ) ma . setCutIntervals ( new_intervals )  if args . chromosomes :          ma . keepOnlyTheseChr ( args . chromosomes )  vecs_list = [ ] chrom_list = [ ] start_list = [ ] end_list = [ ] length_chromosome = 0 chromosome_count = len ( ma . getChrNames ( ) ) if args . pearsonMatrix :          trasf_matrix_pearson = lil_matrix ( ma . matrix . shape )  if args . obsexpMatrix :          trasf_matrix_obsexp = lil_matrix ( ma . matrix . shape )  for chrname in ma . getChrNames ( ) :          chr_range = ma . getChrBinRange ( chrname ) length_chromosome += chr_range [ 1 ] - chr_range [ 0 ]  if args . extraTrack and ( args . extraTrack . endswith ( <str> ) or args . extraTrack . endswith ( <str> ) ) :          bwTrack = pyBigWig . open ( args . extraTrack , <str> )  for chrname in ma . getChrNames ( ) :          chr_range = ma . getChrBinRange ( chrname ) submatrix = ma . matrix [ chr_range [ 0 ] : chr_range [ 1 ] , chr_range [ 0 ] : chr_range [ 1 ] ] if args . norm :              obs_exp_matrix_ = obs_exp_matrix_norm ( submatrix )  else :              obs_exp_matrix_ = obs_exp_matrix_lieberman ( submatrix , length_chromosome , chromosome_count )  obs_exp_matrix_ = convertNansToZeros ( csr_matrix ( obs_exp_matrix_ ) ) . todense ( ) obs_exp_matrix_ = convertInfsToZeros ( csr_matrix ( obs_exp_matrix_ ) ) . todense ( ) if args . obsexpMatrix :              trasf_matrix_obsexp [ chr_range [ 0 ] : chr_range [ 1 ] , chr_range [ 0 ] : chr_range [ 1 ] ] = lil_matrix ( obs_exp_matrix_ )  pearson_correlation_matrix = np . corrcoef ( obs_exp_matrix_ ) pearson_correlation_matrix = convertNansToZeros ( csr_matrix ( pearson_correlation_matrix ) ) . todense ( ) pearson_correlation_matrix = convertInfsToZeros ( csr_matrix ( pearson_correlation_matrix ) ) . todense ( ) if args . pearsonMatrix :              trasf_matrix_pearson [ chr_range [ 0 ] : chr_range [ 1 ] , chr_range [ 0 ] : chr_range [ 1 ] ] = lil_matrix ( pearson_correlation_matrix )  corrmatrix = np . cov ( pearson_correlation_matrix ) corrmatrix = convertNansToZeros ( csr_matrix ( corrmatrix ) ) . todense ( ) corrmatrix = convertInfsToZeros ( csr_matrix ( corrmatrix ) ) . todense ( ) evals , eigs = linalg . eig ( corrmatrix ) k = args . numberOfEigenvectors chrom , start , end , _ = zip ( * ma . cut_intervals [ chr_range [ 0 ] : chr_range [ 1 ] ] ) chrom_list += chrom start_list += start end_list += end if args . extraTrack and ( args . extraTrack . endswith ( <str> ) or args . extraTrack . endswith ( <str> ) ) :              assert ( len ( end ) == len ( start ) ) correlateEigenvectorWithHistonMarkTrack ( eigs [ : , : k ] . transpose ( ) , bwTrack , chrname , start , end , args . extraTrack , args . histonMarkType )  vecs_list += eigs [ : , : k ] . tolist ( )  if args . pearsonMatrix :          file_type = <str> if args . pearsonMatrix . endswith ( <str> ) :              file_type = <str>  matrixFileHandlerOutput = MatrixFileHandler ( pFileType = file_type ) matrixFileHandlerOutput . set_matrix_variables ( trasf_matrix_pearson . tocsr ( ) , ma . cut_intervals , ma . nan_bins , ma . correction_factors , ma . distance_counts ) matrixFileHandlerOutput . save ( args . pearsonMatrix , pSymmetric = True , pApplyCorrection = False )  if args . obsexpMatrix :          file_type = <str> if args . obsexpMatrix . endswith ( <str> ) :              file_type = <str>  matrixFileHandlerOutput = MatrixFileHandler ( pFileType = file_type ) matrixFileHandlerOutput . set_matrix_variables ( trasf_matrix_obsexp . tocsr ( ) , ma . cut_intervals , ma . nan_bins , ma . correction_factors , ma . distance_counts ) matrixFileHandlerOutput . save ( args . obsexpMatrix , pSymmetric = True , pApplyCorrection = False )  if args . extraTrack and not args . extraTrack . endswith ( <str> ) and not args . extraTrack . endswith ( <str> ) :          vecs_list = correlateEigenvectorWithGeneTrack ( ma , vecs_list , args . extraTrack )  if args . format == <str> :          for idx , outfile in enumerate ( args . outputFileName ) :              assert ( len ( vecs_list ) == len ( chrom_list ) ) with open ( outfile , <str> ) as fh :                  for i , value in enumerate ( vecs_list ) :                      if len ( value ) == args . numberOfEigenvectors :                          if isinstance ( value [ idx ] , np . complex ) :                              value [ idx ] = value [ idx ] . real  fh . write ( <str> . format ( toString ( chrom_list [ i ] ) , start_list [ i ] , end_list [ i ] , value [ idx ] ) )      elif args . format == <str> :          if not pyBigWig . numpy == 1 :              log . error ( <str> <str> . format ( pyBigWig . __file__ ) ) exit ( 1 )  old_chrom = chrom_list [ 0 ] header = [ ] for i , _chrom in enumerate ( chrom_list ) :              if old_chrom != _chrom :                  header . append ( ( toString ( old_chrom ) , end_list [ i - 1 ] ) )  old_chrom = _chrom  header . append ( ( toString ( chrom_list [ - 1 ] ) , end_list [ - 1 ] ) ) for idx , outfile in enumerate ( args . outputFileName ) :              log . debug ( <str> . format ( len ( vecs_list ) ) ) log . debug ( <str> . format ( len ( chrom_list ) ) ) assert ( len ( vecs_list ) == len ( chrom_list ) ) _chrom_list = [ ] _start_list = [ ] _end_list = [ ] values = [ ] bw = pyBigWig . open ( outfile , <str> ) bw . addHeader ( header ) for i , value in enumerate ( vecs_list ) :                  if len ( value ) == args . numberOfEigenvectors :                      if isinstance ( value [ idx ] , np . complex ) :                          value [ idx ] = value [ idx ] . real  values . append ( value [ idx ] ) _chrom_list . append ( toString ( chrom_list [ i ] ) ) _start_list . append ( start_list [ i ] ) _end_list . append ( end_list [ i ] )   bw . addEntries ( _chrom_list , _start_list , ends = _end_list , values = values ) bw . close ( )   else :          log . error ( <str> . format ( args . format ) ) exit ( 1 )    