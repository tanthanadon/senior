import argparse import math from multiprocessing import Process , Queue import time import logging log = logging . getLogger ( __name__ ) import numpy as np import fit_nbinom from hicmatrix import HiCMatrix as hm from hicexplorer . _version import __version__ from . lib import Viewpoint def parse_arguments ( args = None ) :      parser = argparse . ArgumentParser ( formatter_class = argparse . RawDescriptionHelpFormatter , add_help = False , description = ) parserRequired = parser . add_argument_group ( <str> ) parserRequired . add_argument ( <str> , <str> , help = <str> , nargs = <str> , required = True ) parserRequired . add_argument ( <str> , <str> , help = <str> , type = str , required = True ) parserOpt = parser . add_argument_group ( <str> ) parserOpt . add_argument ( <str> , help = <str> , type = int , default = 5 ) parserOpt . add_argument ( <str> , <str> , help = <str> , default = <str> ) parserOpt . add_argument ( <str> , <str> , help = <str> , required = False , default = 4 , type = int ) parserOpt . add_argument ( <str> , <str> , help = <str> , required = False , default = 500000 , type = int ) parserOpt . add_argument ( <str> , <str> , action = <str> , help = <str> ) parserOpt . add_argument ( <str> , action = <str> , version = <str> . format ( __version__ ) ) return parser  def compute_background ( pReferencePoints , pViewpointObj , pArgs , pQueue ) :      background_model_data = { } relative_positions = set ( ) for i , referencePoint in enumerate ( pReferencePoints ) :          region_start , region_end , _ = pViewpointObj . calculateViewpointRange ( referencePoint , ( pArgs . fixateRange , pArgs . fixateRange ) ) data_list = pViewpointObj . computeViewpoint ( referencePoint , referencePoint [ 0 ] , region_start , region_end ) view_point_start , _ = pViewpointObj . getReferencePointAsMatrixIndices ( referencePoint ) view_point_range_start , view_point_range_end = pViewpointObj . getViewpointRangeAsMatrixIndices ( referencePoint [ 0 ] , region_start , region_end ) for i , data in zip ( range ( view_point_range_start , view_point_range_end , 1 ) , data_list ) :              relative_position = i - view_point_start  if pArgs . averageContactBin > 0 :              data_list = pViewpointObj . smoothInteractionValues ( data_list , pArgs . averageContactBin )  for i , data in zip ( range ( view_point_range_start , view_point_range_end , 1 ) , data_list ) :              relative_position = i - view_point_start if relative_position in background_model_data :                  background_model_data [ relative_position ] . append ( data )  else :                  background_model_data [ relative_position ] = [ data ] relative_positions . add ( relative_position )    pQueue . put ( [ background_model_data , relative_positions ] ) return  def main ( args = None ) :      args = parse_arguments ( ) . parse_args ( args ) viewpointObj = Viewpoint ( ) referencePoints , _ = viewpointObj . readReferencePointFile ( args . referencePoints ) relative_positions = set ( ) bin_size = 0 referencePointsPerThread = len ( referencePoints ) // args . threads queue = [ None ] * args . threads process = [ None ] * args . threads background_model_data = None for matrix in args . matrices :          hic_ma = hm . hiCMatrix ( matrix ) viewpointObj . hicMatrix = hic_ma bin_size = hic_ma . getBinSize ( ) all_data_collected = False thread_done = [ False ] * args . threads for i in range ( args . threads ) :              if i < args . threads - 1 :                  referencePointsThread = referencePoints [ i * referencePointsPerThread : ( i + 1 ) * referencePointsPerThread ]  else :                  referencePointsThread = referencePoints [ i * referencePointsPerThread : ]  queue [ i ] = Queue ( ) process [ i ] = Process ( target = compute_background , kwargs = dict ( pReferencePoints = referencePointsThread , pViewpointObj = viewpointObj , pArgs = args , pQueue = queue [ i ] ) ) process [ i ] . start ( )  while not all_data_collected :              for i in range ( args . threads ) :                  if queue [ i ] is not None and not queue [ i ] . empty ( ) :                      background_data_thread = queue [ i ] . get ( ) background_model_data_thread , relative_positions_thread = background_data_thread if background_model_data is None :                          background_model_data = background_model_data_thread  else :                          for relativePosition in background_model_data_thread :                              if relativePosition in background_model_data :                                  background_model_data [ relativePosition ] . extend ( background_model_data_thread [ relativePosition ] )  else :                                  background_model_data [ relativePosition ] = background_model_data_thread [ relativePosition ]    relative_positions = relative_positions . union ( relative_positions_thread ) queue [ i ] = None process [ i ] . join ( ) process [ i ] . terminate ( ) process [ i ] = None thread_done [ i ] = True   all_data_collected = True for thread in thread_done :                  if not thread :                      all_data_collected = False   time . sleep ( 1 )  del hic_ma del viewpointObj . hicMatrix  relative_positions = sorted ( relative_positions ) nbinom_parameters = { } max_value = { } mean_value = { } sum_all_values = 0 for relative_position in relative_positions :          nbinom_parameters [ relative_position ] = fit_nbinom . fit ( np . array ( background_model_data [ relative_position ] ) ) max_value [ relative_position ] = np . max ( background_model_data [ relative_position ] ) average_value = np . average ( background_model_data [ relative_position ] ) mean_value [ relative_position ] = average_value sum_all_values += average_value  for relative_position in relative_positions :          mean_value [ relative_position ] /= sum_all_values  with open ( args . outFileName , <str> ) as file :          file . write ( <str> ) for relative_position in relative_positions :              relative_position_in_genomic_scale = relative_position * bin_size file . write ( <str> . format ( relative_position_in_genomic_scale , nbinom_parameters [ relative_position ] [ <str> ] , nbinom_parameters [ relative_position ] [ <str> ] , max_value [ relative_position ] , mean_value [ relative_position ] ) )     