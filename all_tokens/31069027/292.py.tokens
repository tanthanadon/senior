from datetime import datetime , timedelta from openerp import models , fields , api , _ , exceptions class ResPartner ( models . Model ) :      _inherit = <str> @ api . one @ api . constrains ( <str> ) def _check_payment_days ( self ) :          if not self . payment_days :              return  try :              payment_days = self . env [ <str> ] . _decode_payment_days ( self . payment_days ) error = any ( day <= 0 or day > 31 for day in payment_days )  except :              error = True  if error :              raise exceptions . Warning ( _ ( <str> ) )   payment_days = fields . Char ( <str> , size = 11 , help = <str> <str> <str> <str> <str> ) pays_during_holidays = fields . Boolean ( <str> , help = <str> <str> <str> , default = True ) holiday_ids = fields . One2many ( <str> , <str> , <str> )  class ResPartnerHolidays ( models . Model ) :      _name = <str> _order = <str> partner_id = fields . Many2one ( <str> , <str> , required = True , ondelete = <str> ) start = fields . Date ( <str> , required = True ) end = fields . Date ( <str> , required = True ) @ api . multi def name_get ( self ) :          result = [ ] for record in self :              result . append ( ( record . id , <str> % ( record . start , record . end ) ) )  return result   class AccountPaymentTerm ( models . Model ) :      _inherit = <str> def _decode_payment_days ( self , days_char ) :          days_char = days_char . replace ( <str> , <str> ) . replace ( <str> , <str> ) days_char = [ x . strip ( ) for x in days_char . split ( <str> ) if x ] days = [ int ( x ) for x in days_char ] days . sort ( ) return days  def days_in_month ( self , date ) :          if date . month == 12 :              date = date . replace ( day = 31 )  else :              date = date . replace ( month = date . month + 1 , day = 1 ) - timedelta ( days = 1 )  return date . day  def next_day ( self , date , day ) :          if date . day == day :              return date  if day < 1 :              day = 1  if day > self . days_in_month ( date ) :              day = self . days_in_month ( date )  while True :              date += timedelta ( days = 1 ) if date . day == day :                  return date    def _after_holidays ( self , cr , uid , partner , date , days ) :          for holidays in partner . holiday_ids :              start = datetime . strptime ( datetime . strptime ( holidays . start , <str> ) . strftime ( date . strftime ( <str> ) + <str> ) , <str> ) end = datetime . strptime ( datetime . strptime ( holidays . end , <str> ) . strftime ( date . strftime ( <str> ) + <str> ) , <str> ) if date >= start and date <= end :                  date = end + timedelta ( days = 1 )  found = False for day in days :                  if date . day <= day :                      date = self . next_day ( date , day ) found = True break   if days and not found :                  date = self . next_day ( date , days [ 0 ] )   return date . strftime ( <str> )  def compute ( self , cr , uid , id , value , date_ref = False , context = None ) :          if context is None : context = { } result = super ( AccountPaymentTerm , self ) . compute ( cr , uid , id , value , date_ref , context ) if not context . get ( <str> ) :              return result  partner = self . pool . get ( <str> ) . browse ( cr , uid , context . get ( <str> ) , context ) if not partner . payment_days :              return result  days = self . _decode_payment_days ( partner . payment_days ) new_result = [ ] for line in result :              new_date = False date = datetime . strptime ( line [ 0 ] , <str> ) for day in days :                  if date . day <= day :                      new_date = self . next_day ( date , day ) break   if days :                  if not new_date :                      day = days [ 0 ] date = self . next_day ( date , day )  else :                      date = new_date   if not partner . pays_during_holidays :                  date = self . _after_holidays ( cr , uid , partner , date , days )  new_result . append ( ( date , line [ 1 ] ) )  return new_result    