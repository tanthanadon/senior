from openerp . osv import osv , fields import openerp . netsvc import datetime class ir_translation ( osv . osv ) :      _name = <str> _inherit = <str> def english_number ( self , val ) :          to_19 = ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) tens = ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) denom = ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) def _convert_nn ( val ) :              if val < 20 :                  return to_19 [ val ]  for ( dcap , dval ) in ( ( k , 20 + ( 10 * v ) ) for ( v , k ) in enumerate ( tens ) ) :                  if dval + 10 > val :                      if val % 10 :                          return dcap + <str> + to_19 [ val % 10 ]  return dcap    def _convert_nnn ( val ) :              word = <str> ( mod , rem ) = ( val % 100 , val // 100 ) if rem > 0 :                  word = to_19 [ rem ] + <str> if mod > 0 :                      word = word + <str>   if mod > 0 :                  word = word + _convert_nn ( mod )  return word  if val < 100 :              return _convert_nn ( val )  if val < 1000 :              return _convert_nnn ( val )  for ( didx , dval ) in ( ( v - 1 , 1000 ** v ) for v in range ( len ( denom ) ) ) :              if dval > val :                  mod = 1000 ** didx l = val // mod r = val - ( l * mod ) ret = _convert_nnn ( l ) + <str> + denom [ didx ] if r > 0 :                      ret = ret + <str> + english_number ( r )  return ret    def amount_to_text_en ( self , number , currency ) :          netsvc . Logger ( ) . notifyChannel ( <str> , netsvc . LOG_INFO , <str> % ( number , currency ) ) number = <str> % number units_name = currency list = str ( number ) . split ( <str> ) start_word = self . english_number ( int ( list [ 0 ] ) ) end_word = self . english_number ( int ( list [ 1 ] ) ) cents_number = int ( list [ 1 ] ) cents_name = ( cents_number > 1 ) and <str> or <str> final_result = start_word + <str> + units_name + <str> + end_word + <str> + cents_name return final_result  def __convertNumber ( self , n ) :          UNIDADES = ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) DECENAS = ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) CENTENAS = ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) output = <str> if ( n == <str> ) :              output = <str>  elif ( n [ 0 ] != <str> ) :              output = CENTENAS [ int ( n [ 0 ] ) - 1 ]  k = int ( n [ 1 : ] ) if ( k <= 20 ) :              output += UNIDADES [ k ]  else :              if ( ( k > 30 ) & ( n [ 2 ] != <str> ) ) :                  output += <str> % ( DECENAS [ int ( n [ 1 ] ) - 2 ] , UNIDADES [ int ( n [ 2 ] ) ] )  else :                  output += <str> % ( DECENAS [ int ( n [ 1 ] ) - 2 ] , UNIDADES [ int ( n [ 2 ] ) ] )   return output  def amount_to_text_pe ( self , number_in , currency = <str> ) :          converted = <str> if type ( number_in ) != <str> :              number = str ( round ( number_in , 2 ) )  else :              number = number_in  number_str = number try :              number_int , number_dec = number_str . split ( <str> )  except ValueError :              number_int = number_str number_dec = <str>  number_str = number_int . zfill ( 9 ) millones = number_str [ : 3 ] miles = number_str [ 3 : 6 ] cientos = number_str [ 6 : ] if ( millones ) :              if ( millones == <str> ) :                  converted += <str>  elif ( int ( millones ) > 0 ) :                  converted += <str> % self . __convertNumber ( millones )   if ( miles ) :              if ( miles == <str> ) :                  converted += <str>  elif ( int ( miles ) > 0 ) :                  converted += <str> % self . __convertNumber ( miles )   if ( cientos ) :              if ( cientos == <str> ) :                  converted += <str>  elif ( int ( cientos ) > 0 ) :                  converted += <str> % self . __convertNumber ( cientos )   if number_dec == <str> :              number_dec = <str>  if ( len ( number_dec ) < 2 ) :              number_dec += <str>  converted += <str> + number_dec + <str> + ( currency or <str> ) return converted  def amount_to_text_py ( self , number_in , currency = <str> ) :          converted = <str> if type ( number_in ) != <str> :              number = str ( round ( number_in , 2 ) )  else :              number = number_in  number_str = number try :              number_int , number_dec = number_str . split ( <str> )  except ValueError :              number_int = number_str number_dec = <str>  number_str = number_int . zfill ( 9 ) millones = number_str [ : 3 ] miles = number_str [ 3 : 6 ] cientos = number_str [ 6 : ] if ( millones ) :              if ( millones == <str> ) :                  converted += <str>  elif ( int ( millones ) > 0 ) :                  converted += <str> % self . __convertNumber ( millones )   if ( miles ) :              if ( miles == <str> ) :                  converted += <str>  elif ( int ( miles ) > 0 ) :                  converted += <str> % self . __convertNumber ( miles )   if ( cientos ) :              if ( cientos == <str> ) :                  converted += <str>  elif ( int ( cientos ) > 0 ) :                  converted += <str> % self . __convertNumber ( cientos )   if number_dec == <str> :              number_dec = <str>  if ( len ( number_dec ) < 2 ) :              number_dec += <str>  converted += <str> + number_dec + <str> + ( currency or <str> ) return converted  def amount_to_text_co ( self , number_in , currency = <str> ) :          converted = <str> if type ( number_in ) != <str> :              number = str ( round ( number_in , 0 ) )  else :              number = number_in  number_str = number try :              number_int , number_dec = number_str . split ( <str> )  except ValueError :              number_int = number_str number_dec = <str>  number_str = number_int . zfill ( 9 ) millones = number_str [ : 3 ] miles = number_str [ 3 : 6 ] cientos = number_str [ 6 : ] if ( millones ) :              if ( millones == <str> ) :                  converted += <str>  elif ( int ( millones ) > 0 ) :                  converted += <str> % self . __convertNumber ( millones )   if ( miles ) :              if ( miles == <str> ) :                  converted += <str>  elif ( int ( miles ) > 0 ) :                  converted += <str> % self . __convertNumber ( miles )   if ( cientos ) :              if ( cientos == <str> ) :                  converted += <str>  elif ( int ( cientos ) > 0 ) :                  converted += <str> % self . __convertNumber ( cientos )   if number_dec == <str> :              number_dec = <str>  if ( len ( number_dec ) < 2 ) :              number_dec += <str>  converted += <str> + currency return converted  _translate_funcs = { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , } def add_amount_to_text_function ( self , lang , func ) :          self . _translate_funcs [ lang ] = func  def amount_to_text ( self , nbr , lang = <str> , currency = <str> ) :          if not self . _translate_funcs . has_key ( lang ) :              netsvc . Logger ( ) . notifyChannel ( <str> , netsvc . LOG_INFO , <str> % ( lang , ) ) lang = <str>  exec ( <str> % ( self . _translate_funcs [ lang ] ) ) return res  def date_part ( self , date , part , format = <str> , lang = <str> ) :          if isinstance ( date , datetime . datetime ) :              date = date . strftime ( <str> )  MES = ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) res = <str> if part == <str> :              if format == <str> :                  res = date [ 8 : 10 ]  else :                  res = self . __convertNumber ( date [ 8 : 10 ] )   elif part == <str> :              if format == <str> :                  res = date [ 5 : 7 ]  else :                  res = MES [ int ( date [ 5 : 7 ] ) ]   elif part == <str> :              if format == <str> :                  res = date [ 0 : 4 ]  else :                  res = self . __convertNumber ( date [ 0 : 4 ] )   else :              res = date  return res  def date_to_text ( self , date , format = <str> , lang = <str> ) :          return self . date_part ( date , <str> , format = <str> ) + <str> + self . date_part ( date , <str> , format = <str> ) + <str> + self . date_part ( date , <str> )     