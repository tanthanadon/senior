from openerp . osv import osv , fields from openerp . tools . translate import _ try :      from cStringIO import StringIO  except ImportError :      from StringIO import StringIO  from csv import writer as csvwriter from base64 import b64encode from datetime import datetime import logging log = logging . getLogger ( <str> ) from openerp import models , fields as fields2 import openerp . addons . decimal_precision as dp def get_start_date ( * args , ** kwargs ) :      now = datetime . today ( ) try :          now = now . replace ( day = 1 , month = now . month - 1 )  except ValueError :          log . debug ( <str> , exc_info = True ) now = now . replace ( day = 1 , month = now . month + 11 , year = now . year - 1 )  return now . strftime ( <str> )  class l10n_es_intrastat ( models . Model ) :      _name = <str> _inherit = <str> _rec_name = <str> _order = <str> end_date = fields2 . Date ( compute = <str> , string = <str> , readonly = True , store = True , help = <str> <str> ) num_lines = fields2 . Integer ( compute = <str> , string = <str> , store = True , track_visibility = <str> , help = <str> ) total_amount = fields2 . Float ( compute = <str> , digits = dp . get_precision ( <str> ) , string = <str> , store = True , track_visibility = <str> , help = <str> ) def _compute_total_fiscal_amount ( self , cr , uid , ids , name , arg , context = None ) :          result = { } for intrastat in self . browse ( cr , uid , ids , context = context ) :              total_fiscal_amount = 0.0 for line in intrastat . intrastat_line_ids :                  total_fiscal_amount += line . amount_company_currency * line . intrastat_type_id . fiscal_value_multiplier  result [ intrastat . id ] = total_fiscal_amount  return result  def _compute_end_date ( self , cr , uid , ids , name , arg , context = None ) :          return obj = self . browse ( cr , uid , ids [ 0 ] , context ) return self . pool . get ( <str> ) . _compute_dates ( cr , uid , ids , obj , context = context )  def _get_intrastat_from_line ( self , cr , uid , ids , context = None ) :          return self . pool . get ( <str> ) . search ( cr , uid , [ ( <str> , <str> , ids ) ] , context = context )  def _compute_total_weight ( self , cr , uid , ids , name , arg , context = None ) :          result = { } for intrastat in self . browse ( cr , uid , ids , context = context ) :              total_weight = 0.0 for line in intrastat . intrastat_line_ids :                  total_weight += line . weight  result [ intrastat . id ] = total_weight  return result  _columns = { <str> : fields . many2one ( <str> , <str> , required = True , readonly = True , help = <str> ) , <str> : fields . related ( <str> , <str> , readonly = True , type = <str> , string = <str> ) , <str> : fields . date ( <str> , required = True , states = { <str> : [ ( <str> , True ) ] } , help = <str> ) , <str> : fields . datetime ( <str> , readonly = True , help = <str> ) , <str> : fields . selection ( [ ( <str> , <str> ) , ( <str> , <str> ) , ] , string = <str> , required = True ) , <str> : fields . selection ( [ ( <str> , <str> ) , ( <str> , <str> ) , ] , <str> , select = True , readonly = True , help = <str> ) , <str> : fields . selection ( [ ( <str> , <str> ) , ( <str> , <str> ) ] , <str> , required = True , states = { <str> : [ ( <str> , True ) ] } , help = <str> ) , <str> : fields . integer ( <str> , readonly = True , help = <str> ) , <str> : fields . one2many ( <str> , <str> , <str> , states = { <str> : [ ( <str> , True ) ] } ) , <str> : fields . function ( _compute_total_weight , method = True , digits = ( 16 , 3 ) , string = <str> , store = { <str> : ( _get_intrastat_from_line , [ <str> ] , 20 ) , } , help = <str> ) , <str> : fields . related ( <str> , <str> , readonly = True , type = <str> , relation = <str> , string = <str> ) , <str> : fields . text ( <str> , help = <str> ) , <str> : fields . boolean ( <str> , states = { <str> : [ ( <str> , True ) ] } , help = <str> ) , } _defaults = { <str> : <str> , <str> : <str> , <str> : <str> , <str> : 1 , <str> : get_start_date , <str> : lambda self , cr , uid , ct : self . pool . get ( <str> ) . _get_company ( cr , uid , ct ) , <str> : lambda * a : False , } _sql_constraints = [ ( <str> , <str> , <str> ) , ] def copy ( self , cr , uid , ids , default = None , context = None ) :          if <str> not in default :              default [ <str> ] = [ ]  if <str> not in default :              default [ <str> ] = False  if <str> not in default :              default [ <str> ] = False  return super ( l10n_es_intrastat , self ) . copy ( cr , uid , ids , default , context )  def write ( self , cr , uid , ids , vals , context = None ) :          res = super ( l10n_es_intrastat , self ) . write ( cr , uid , ids , vals , context ) if <str> not in context :              cr . execute ( <str> , [ tuple ( ids ) ] )  return res  def unlink ( self , cr , uid , ids , context = None ) :          for t in self . read ( cr , uid , ids , [ <str> ] , context = context ) :              if t [ <str> ] not in ( <str> ) :                  raise osv . except_osv ( _ ( <str> ) , _ ( <str> ) )   return super ( l10n_es_intrastat , self ) . unlink ( cr , uid , ids , context = context )  def _find_stock_links ( self , cr , uid , invoice_line , context = None ) :          sm_obj = self . pool . get ( <str> ) sale_line = self . pool . get ( <str> ) if sale_line :              cr . execute ( , ( invoice_line . invoice_id . id , ) ) stock_ids = [ x [ 0 ] for x in cr . fetchall ( ) ] log . debug ( <str> , stock_ids ) return sm_obj . browse ( cr , uid , stock_ids , context = context )  return [ ]  def _find_invoice_links ( self , cr , uid , stock_line , context = None ) :          res_invoices = [ ] res_lines = [ ] if hasattr ( stock_line , <str> ) :              if stock_line . procurement_id . sale_line_id :                  res_lines . extend ( stock_line . procurement_id . sale_line_id . invoice_lines ) res_invoices . extend ( stock_line . procurement_id . sale_line_id . order_id . invoice_ids )   if hasattr ( stock_line , <str> ) :              if stock_line . purchase_line_id :                  res_lines . extend ( stock_line . purchase_line_id . invoice_lines ) res_invoices . extend ( stock_line . purchase_line_id . order_id . invoice_ids )   res_invoices = list ( set ( res_invoices ) ) res_lines = list ( set ( res_lines ) ) return res_invoices , res_lines  def _gather_invoices ( self , cr , uid , declaration , context = None ) :          decl_lines = [ ] cur_obj = self . pool . get ( <str> ) inv_obj = self . pool . get ( <str> ) product_uom_obj = self . pool . get ( <str> ) inv_ids = inv_obj . search ( cr , uid , [ ( <str> , <str> , declaration . start_date ) , ( <str> , <str> , declaration . end_date ) , ( <str> , <str> , [ <str> , <str> ] ) , ( <str> , <str> , declaration . company_id . id ) , ] , context = context ) log . debug ( <str> , len ( inv_ids ) , inv_ids ) for invoice in inv_obj . browse ( cr , uid , inv_ids , context = context ) :              if invoice . fiscal_position and not invoice . fiscal_position . intracommunity_operations :                  log . debug ( <str> , invoice . number ) continue  if not invoice . partner_id . commercial_partner_id . country_id :                  log . debug ( <str> , invoice . number ) continue  if not invoice . partner_id . commercial_partner_id . country_id . intrastat :                  log . debug ( <str> , invoice . number ) continue  if invoice . partner_id . commercial_partner_id . country_id . id == declaration . company_id . partner_id . country_id . id :                  log . debug ( <str> , invoice . number ) continue  if declaration . ttype == <str> and invoice . type in [ <str> , <str> ] :                  continue  elif declaration . ttype == <str> and invoice . type in [ <str> , <str> ] :                  continue  for inv_line in invoice . invoice_line :                  if not inv_line . product_id :                      log . debug ( <str> ) continue  if inv_line . product_id . type not in [ <str> , <str> ] :                      log . debug ( <str> ) continue  if inv_line . product_id . exclude_from_intrastat :                      log . debug ( <str> ) continue  intrastat = inv_line . product_id . intrastat_id or inv_line . product_id . categ_id . intrastat_id if not intrastat :                      raise osv . except_osv ( _ ( <str> ) , _ ( <str> <str> ) % ( inv_line . product_id . default_code , inv_line . product_id . name ) )  intrastat_code = intrastat . intrastat_code line_value = inv_line . price_subtotal if invoice . currency_id . id != declaration . company_id . currency_id . id :                      line_value = cur_obj . compute ( cr , uid , invoice . currency_id . id , declaration . company_id . currency_id . id , line_value , context = context )  if intrastat . intrastat_uom_id :                      quantity = inv_line . quantity weight = None  else :                      quantity = None if not inv_line . product_id . weight_net :                          p_name = inv_line . product_id . name + ( inv_line . product_id . default_code and ( <str> + inv_line . product_id . default_code + <str> ) or <str> ) raise osv . except_osv ( _ ( <str> ) , _ ( <str> <str> ) % ( p_name , intrastat . intrastat_code ) )  qty_in_product_uom = product_uom_obj . _compute_qty ( cr , uid , from_uom_id = inv_line . uos_id . id , qty = inv_line . quantity , to_uom_id = inv_line . product_id . uom_id . id ) weight = inv_line . product_id . weight_net * qty_in_product_uom  incoterm_model , default_incoterm = self . pool . get ( <str> ) . get_object_reference ( cr , uid , <str> , <str> ) decl_lines . append ( ( 0 , 0 , { <str> : declaration . id , <str> : invoice . id , <str> : inv_line . id , <str> : False , <str> : False , <str> : invoice . partner_id . commercial_partner_id . country_id . id , <str> : invoice . company_id . state_id . id , <str> : invoice . sale_order_ids and invoice . sale_order_ids [ 0 ] . incoterm and invoice . sale_order_ids [ 0 ] . incoterm . id or default_incoterm , <str> : inv_line . product_id . id , <str> : intrastat . id , <str> : intrastat_code , <str> : False , <str> : 1 , <str> : weight or 0.0 , <str> : quantity or 0.0 , <str> : line_value or 0.0 , <str> : line_value or 0.0 , <str> : 11 , <str> : 3 , <str> : False , <str> : invoice . number [ - 13 : ] , } ) )  log . debug ( <str> , invoice . number , decl_lines )  return decl_lines  def _gather_stock ( self , cr , uid , declaration , context = None ) :          decl_lines = [ ] sm_obj = self . pool . get ( <str> ) product_uom_obj = self . pool . get ( <str> ) stock_ids = sm_obj . search ( cr , uid , [ ( <str> , <str> , declaration . start_date ) , ( <str> , <str> , declaration . end_date ) , ( <str> , <str> , [ <str> , <str> ] ) , ( <str> , <str> , declaration . company_id . id ) , ] , context = context ) for move in sm_obj . browse ( cr , uid , stock_ids , context = context ) :              address = ( move . partner_id and move . partner_id . commercial_partner_id ) or ( move . picking_id and move . picking_id . partner_id . commercial_partner_id ) if not address :                  log . debug ( <str> ) continue  country = address . country_id or False if not country :                  log . debug ( <str> ) continue  if country and not country . intrastat :                  log . debug ( <str> ) continue  if country and country . id == declaration . company_id . partner_id . country_id . id :                  log . debug ( <str> ) continue  if move . product_id . exclude_from_intrastat :                  log . debug ( <str> , move . product_id . id ) continue  value = move . price_unit or move . product_id . list_price ref = move . picking_id and move . picking_id . name or <str> % ( move . id , move . product_id . default_code , move . product_id . name ) intrastat = move . product_id . intrastat_id or move . product_id . categ_id . intrastat_id if not intrastat :                  raise osv . except_osv ( _ ( <str> ) , _ ( <str> <str> ) % ( move . product_id . default_code , move . product_id . name ) )  intrastat_code = intrastat . intrastat_code invoices , inv_lines = self . _find_invoice_links ( cr , uid , move , context ) if invoices and invoices [ 0 ] . fiscal_position and not invoices [ 0 ] . fiscal_position . intracommunity_operations :                  log . debug ( <str> ) continue  trans_type = False if move . location_id . usage == <str> and move . location_dest_id . usage in [ <str> , <str> ] :                  log . debug ( <str> ) if declaration . ttype == <str> :                      trans_type = 1  else :                      continue   elif move . location_dest_id . usage == <str> and move . location_id . usage in [ <str> , <str> ] :                  log . debug ( <str> ) if declaration . ttype == <str> :                      trans_type = 1  else :                      continue   else :                  log . warn ( <str> , move . id , move . location_id . name , move . location_dest_id . name ) continue  if intrastat . intrastat_uom_id :                  quantity = move . product_qty weight = None  else :                  quantity = None if not move . product_id . weight_net :                      p_name = move . product_id . name + ( move . product_id . default_code and ( <str> + move . product_id . default_code + <str> ) or <str> ) raise osv . except_osv ( _ ( <str> ) , _ ( <str> <str> ) % ( p_name , intrastat . intrastat_code ) )  qty_in_product_uom = product_uom_obj . _compute_qty ( cr , uid , from_uom_id = move . product_uom . id , qty = move . product_qty , to_uom_id = move . product_id . uom_id . id ) weight = move . product_id . weight_net * qty_in_product_uom  incoterm_model , default_incoterm = self . pool . get ( <str> ) . get_object_reference ( cr , uid , <str> , <str> ) decl_lines . append ( ( 0 , 0 , { <str> : declaration . id , <str> : invoices and invoices [ 0 ] . id , <str> : inv_lines and inv_lines [ 0 ] . id , <str> : move . picking_id and move . picking_id . id or False , <str> : move . id , <str> : country . id , <str> : move . company_id . state_id . id , <str> : move . picking_id and move . picking_id . sale_id and move . picking_id . sale_id . incoterm and move . picking_id . sale_id . incoterm . id or default_incoterm , <str> : move . product_id . id , <str> : intrastat and intrastat . id , <str> : intrastat_code , <str> : False , <str> : 1 , <str> : weight or 0.0 , <str> : quantity or 0.0 , <str> : ( value * move . product_qty ) or 0.0 , <str> : ( value * move . product_qty ) or 0.0 , <str> : 11 , <str> : 3 , <str> : False , <str> : ref [ : 13 ] , } ) )  return decl_lines  def action_gather ( self , cr , uid , ids , context = None ) :          context = context or { } log . debug ( <str> , ids ) cur_obj = self . pool . get ( <str> ) inv_obj = self . pool . get ( <str> ) sm_obj = self . pool . get ( <str> ) intr_line_obj = self . pool . get ( <str> ) for declaration in self . browse ( cr , uid , ids , context = context ) :              decl_lines = [ ] if declaration . data_source == <str> :                  decl_lines += self . _gather_stock ( cr , uid , declaration , context )  elif declaration . data_source == <str> :                  decl_lines += self . _gather_invoices ( cr , uid , declaration , context )  else :                  raise osv . except_osv ( _ ( <str> ) , _ ( <str> ) )  line_ids = ids and intr_line_obj . search ( cr , uid , [ ( <str> , <str> , declaration . id ) ] ) or False if line_ids :                  intr_line_obj . unlink ( cr , uid , line_ids )  if declaration . merge_lines :                  lines_combined = [ ] for i in range ( len ( decl_lines ) ) :                      similar = False for j in range ( len ( lines_combined ) ) :                          if decl_lines [ i ] [ 2 ] [ <str> ] == lines_combined [ j ] [ 2 ] [ <str> ] and decl_lines [ i ] [ 2 ] [ <str> ] == lines_combined [ j ] [ 2 ] [ <str> ] and decl_lines [ i ] [ 2 ] [ <str> ] == lines_combined [ j ] [ 2 ] [ <str> ] and decl_lines [ i ] [ 2 ] [ <str> ] == lines_combined [ j ] [ 2 ] [ <str> ] and decl_lines [ i ] [ 2 ] [ <str> ] == lines_combined [ j ] [ 2 ] [ <str> ] and decl_lines [ i ] [ 2 ] [ <str> ] == lines_combined [ j ] [ 2 ] [ <str> ] and decl_lines [ i ] [ 2 ] [ <str> ] == lines_combined [ j ] [ 2 ] [ <str> ] and decl_lines [ i ] [ 2 ] [ <str> ] == lines_combined [ j ] [ 2 ] [ <str> ] and decl_lines [ i ] [ 2 ] [ <str> ] == lines_combined [ j ] [ 2 ] [ <str> ] :                              similar = True lines_combined [ j ] [ 2 ] [ <str> ] = False lines_combined [ j ] [ 2 ] [ <str> ] = False lines_combined [ j ] [ 2 ] [ <str> ] = False lines_combined [ j ] [ 2 ] [ <str> ] = False lines_combined [ j ] [ 2 ] [ <str> ] = False lines_combined [ j ] [ 2 ] [ <str> ] += decl_lines [ i ] [ 2 ] [ <str> ] or 0.0 lines_combined [ j ] [ 2 ] [ <str> ] += decl_lines [ i ] [ 2 ] [ <str> ] or 0.0 lines_combined [ j ] [ 2 ] [ <str> ] += decl_lines [ i ] [ 2 ] [ <str> ] or 0.0 lines_combined [ j ] [ 2 ] [ <str> ] += decl_lines [ i ] [ 2 ] [ <str> ] or 0.0   if not similar :                          lines_combined . append ( decl_lines [ i ] )   decl_lines = lines_combined  declaration . write ( { <str> : decl_lines , } , context = context )  return True  def action_send ( self , cr , uid , ids , context = None ) :          context = context or { } itx_buffer = StringIO ( ) itx_file = csvwriter ( itx_buffer , delimiter = <str> ) today = datetime . today ( ) for declaration in self . browse ( cr , uid , ids , context = context ) :              decl_date = datetime . strptime ( declaration . start_date , <str> ) vat_no = declaration . company_id . partner_id . vat if not vat_no :                  raise osv . except_osv ( _ ( <str> ) , _ ( <str> ) )  vat_no = vat_no . replace ( <str> , <str> ) . upper ( ) vat = vat_no [ 2 : ] itx_head = [ vat_no [ 2 : ] , <str> , <str> , <str> % ( str ( declaration . id ) . zfill ( 4 ) [ - 4 : ] , str ( declaration . revision ) . zfill ( 4 ) [ - 4 : ] ) , ] lines_all = [ ] for intrastat_line in declaration . intrastat_line_ids :                  if not intrastat_line . country_code :                      raise osv . except_osv ( _ ( <str> ) , _ ( <str> ) % intrastat_line . extnr )  if not intrastat_line . state_code :                      raise osv . except_osv ( _ ( <str> ) , _ ( <str> ) % intrastat_line . extnr )  if not intrastat_line . incoterm :                      raise osv . except_osv ( _ ( <str> ) , _ ( <str> ) % intrastat_line . extnr )  if not intrastat_line . transaction :                      raise osv . except_osv ( _ ( <str> ) , _ ( <str> ) % intrastat_line . extnr )  if not intrastat_line . transport :                      raise osv . except_osv ( _ ( <str> ) , _ ( <str> ) % intrastat_line . extnr )  if not intrastat_line . intrastat_code :                      raise osv . except_osv ( _ ( <str> ) , _ ( <str> ) % intrastat_line . extnr )  if not intrastat_line . statistical_procedure :                      raise osv . except_osv ( _ ( <str> ) , _ ( <str> ) % intrastat_line . extnr )  lines_all . append ( { <str> : [ intrastat_line . country_code or <str> , intrastat_line . state_code or <str> , intrastat_line . incoterm or <str> , intrastat_line . transaction or <str> , intrastat_line . transport or <str> , intrastat_line . port_loading_unloading or <str> , intrastat_line . intrastat_code . replace ( <str> , <str> ) , intrastat_line . country_origin or <str> , intrastat_line . statistical_procedure or <str> , declaration . currency_id . name , ] , <str> : [ round ( intrastat_line . weight , 3 ) , round ( intrastat_line . supplementary_quantity , 3 ) , round ( intrastat_line . amount_company_currency , 2 ) , round ( intrastat_line . amount_statistic_company_currency , 2 ) , ] , } )  lines_combined = [ ] for i in range ( len ( lines_all ) ) :                  similar = False for j in range ( len ( lines_combined ) ) :                      if lines_all [ i ] [ <str> ] == lines_combined [ j ] [ <str> ] :                          similar = True lines_combined [ j ] = { <str> : lines_combined [ j ] [ <str> ] , <str> : map ( lambda x , y : x + y , lines_all [ i ] [ <str> ] , lines_combined [ j ] [ <str> ] ) , }   if not similar :                      lines_combined . append ( lines_all [ i ] )   itx_lines = map ( lambda x : x [ <str> ] [ : 9 ] + [ <str> . format ( x [ <str> ] [ 0 ] ) . replace ( <str> , <str> ) ] + [ <str> . format ( x [ <str> ] [ 1 ] ) . replace ( <str> , <str> ) ] + [ <str> . format ( x [ <str> ] [ 2 ] ) . replace ( <str> , <str> ) ] + [ <str> . format ( x [ <str> ] [ 3 ] ) . replace ( <str> , <str> ) ] , lines_combined ) for line in itx_lines :                  if line [ 9 ] == <str> and line [ 10 ] == <str> :                      raise osv . except_osv ( _ ( <str> ) , _ ( <str> ) % line [ 6 ] )  if line [ 11 ] == <str> or line [ 12 ] == <str> :                      raise osv . except_osv ( _ ( <str> ) , _ ( <str> ) % line [ 6 ] )  itx_line = line itx_file . writerow ( itx_line )  filename = <str> % ( declaration . ttype , decl_date . year , decl_date . month , str ( declaration . id ) . zfill ( 2 ) [ - 2 : ] , str ( declaration . revision ) . zfill ( 2 ) [ - 2 : ] , ) att_id = self . pool . get ( <str> ) . create ( cr , uid , { <str> : declaration . id , <str> : self . _name , <str> : filename , <str> : b64encode ( itx_buffer . getvalue ( ) ) , } , context = context )  context . update ( { <str> : True } ) return self . write ( cr , uid , ids , { <str> : <str> , <str> : datetime . today ( ) . strftime ( <str> ) } , context = context )  def action_reset ( self , cr , uid , ids , context = None ) :          context = context or { } context . update ( { <str> : True } ) return self . write ( cr , uid , ids , { <str> : <str> , <str> : False } , context = context )  def action_done ( self , cr , uid , ids , context = None ) :          context = context or { } context . update ( { <str> : True } ) return self . write ( cr , uid , ids , { <str> : <str> , <str> : datetime . today ( ) . strftime ( <str> ) } , context = context )   l10n_es_intrastat ( ) class l10n_es_intrastat_line ( osv . osv ) :      _name = <str> _columns = { <str> : fields . many2one ( <str> , <str> , ondelete = <str> , readonly = True ) , <str> : fields . many2one ( <str> , <str> , readonly = True ) , <str> : fields . many2one ( <str> , <str> , readonly = True ) , <str> : fields . many2one ( <str> , <str> , readonly = True ) , <str> : fields . many2one ( <str> , <str> , readonly = True ) , <str> : fields . many2one ( <str> , <str> ) , <str> : fields . many2one ( <str> , <str> , help = <str> ) , <str> : fields . many2one ( <str> , <str> ) , <str> : fields . many2one ( <str> , <str> ) , <str> : fields . many2one ( <str> , <str> ) , <str> : fields . many2one ( <str> , <str> ) , <str> : fields . related ( <str> , <str> , type = <str> , size = 2 , string = <str> , readonly = True ) , <str> : fields . related ( <str> , <str> , type = <str> , size = 2 , string = <str> , readonly = True ) , <str> : fields . related ( <str> , <str> , type = <str> , size = 3 , string = <str> , readonly = True ) , <str> : fields . selection ( [ ( 11 , <str> ) , ( 12 , <str> ) , ( 13 , <str> ) , ( 14 , <str> ) , ( 15 , <str> ) , ( 19 , <str> ) , ( 21 , <str> ) , ( 22 , <str> ) , ( 23 , <str> ) , ( 29 , <str> ) , ( 31 , <str> ) , ( 32 , <str> ) , ( 33 , <str> ) , ( 41 , <str> ) , ( 42 , <str> ) , ( 44 , <str> ) , ( 45 , <str> ) , ( 51 , <str> ) , ( 52 , <str> ) , ( 54 , <str> ) , ( 55 , <str> ) , ( 61 , <str> ) , ( 62 , <str> ) , ( 70 , <str> ) , ( 80 , <str> ) , ( 91 , <str> ) , ( 99 , <str> ) , ] , <str> ) , <str> : fields . selection ( [ ( 1 , <str> ) , ( 2 , <str> ) , ( 3 , <str> ) , ( 4 , <str> ) , ( 5 , <str> ) , ( 7 , <str> ) , ( 8 , <str> ) , ( 9 , <str> ) , ] , <str> ) , <str> : fields . integer ( <str> , size = 4 ) , <str> : fields . char ( <str> , size = 10 , required = True , readonly = True ) , <str> : fields . related ( <str> , <str> , type = <str> , size = 2 , string = <str> , help = <str> , readonly = True ) , <str> : fields . selection ( [ ( 1 , <str> ) , ( 2 , <str> ) , ( 3 , <str> ) , ( 4 , <str> ) , ( 5 , <str> ) , ] , <str> ) , <str> : fields . float ( <str> , digits = ( 12 , 3 ) , required = True ) , <str> : fields . float ( <str> , digits = ( 12 , 3 ) , help = <str> ) , <str> : fields . float ( <str> , digits = ( 13 , 2 ) , required = True ) , <str> : fields . float ( <str> , digits = ( 13 , 2 ) , required = True ) , <str> : fields . char ( <str> , size = 13 , required = False ) , } _order = <str> def onchange_country ( self , cr , uid , ids , country_id , context = None ) :          res = { <str> : { } } if country_id :              country = self . pool . get ( <str> ) . browse ( cr , uid , country_id , context = context ) res [ <str> ] . update ( { <str> : country . id , <str> : country . code , } )  return res  def onchange_state ( self , cr , uid , ids , state_id , context = None ) :          res = { <str> : { } } if state_id :              state = self . pool . get ( <str> ) . browse ( cr , uid , state_id , context = context ) res [ <str> ] . update ( { <str> : state . id , <str> : state . code , } )  return res  def onchange_product ( self , cr , uid , ids , product_id , qty , context = None ) :          res = { <str> : { } } if product_id :              product = self . pool . get ( <str> ) . browse ( cr , uid , product_id , context = context ) res [ <str> ] . update ( { <str> : product . intrastat_id . id , <str> : product . intrastat_id . intrastat_code , } ) if qty :                  res [ <str> ] . update ( { <str> : str ( int ( round ( int ( qty ) * product . weight_net ) ) ) , } )   return res  def onchange_qty ( self , cr , uid , ids , product_id , qty , context = None ) :          res = { <str> : { } } if product_id and qty :              product = self . pool . get ( <str> ) . browse ( cr , uid , product_id , context = context ) res [ <str> ] . update ( { <str> : str ( int ( round ( int ( qty ) * product . weight_net ) ) ) , } )  return res   l10n_es_intrastat_line ( )  