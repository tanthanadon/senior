from openerp . osv import osv , fields import time from openerp . tools . translate import _ class sale_order_line ( osv . osv ) :      _name = <str> _inherit = <str> def _amount_invoiced ( self , cr , uid , ids , field_name , arg , context ) :          result = { } for line in self . browse ( cr , uid , ids , context ) :              if line . invoiced :                  result [ line . id ] = line . price_subtotal + self . _tax_amount ( cr , uid , line )  else :                  result [ line . id ] = 0.0   return result  def _tax_amount ( self , cr , uid , line ) :          val = 0.0 for c in self . pool . get ( <str> ) . compute_all ( cr , uid , line . tax_id , line . price_unit * ( 1 - ( line . discount or 0.0 ) / 100.0 ) , line . product_uos_qty , line . order_id . partner_invoice_id . id , line . product_id , line . order_id . partner_id ) [ <str> ] :              val += c [ <str> ]  return val  _columns = { <str> : fields . function ( _amount_invoiced , method = True , string = <str> , type = <str> ) , }  sale_order_line ( ) class sale_order ( osv . osv ) :      _inherit = <str> def onchange_partner_id ( self , cr , uid , ids , part , context = None ) :          if context is None :              context = context  result = super ( sale_order , self ) . onchange_partner_id ( cr , uid , ids , part , context = context ) if part :              partner = self . pool . get ( <str> ) . browse ( cr , uid , part ) . commercial_partner_id if partner . credit_limit and partner . available_risk < 0.0 :                  result [ <str> ] = { <str> : _ ( <str> ) , <str> : _ ( <str> ) % { <str> : partner . credit_limit , <str> : partner . total_debt , } }   return result  def _amount_invoiced ( self , cr , uid , ids , field_name , arg , context ) :          result = { } for order in self . browse ( cr , uid , ids , context ) :              if order . invoiced :                  amount = order . amount_total  else :                  amount = 0.0 for line in order . order_line :                      amount += line . amount_invoiced   result [ order . id ] = amount  return result  _columns = { <str> : fields . function ( _amount_invoiced , method = True , string = <str> , type = <str> ) , <str> : fields . selection ( [ ( <str> , <str> ) , ( <str> , <str> ) , ( <str> , <str> ) , ( <str> , <str> ) , ( <str> , <str> ) , ( <str> , <str> ) , ( <str> , <str> ) , ( <str> , <str> ) , ( <str> , <str> ) , ( <str> , <str> ) , ] , <str> , readonly = True , help = _ ( <str> ) , select = True ) , }  sale_order ( ) class account_account ( osv . osv ) :      _inherit = <str> _columns = { <str> : fields . boolean ( <str> ) }  account_account ( ) class partner ( osv . osv ) :      _name = <str> _inherit = <str> def _unpayed_amount ( self , cr , uid , ids , name , arg , context = None ) :          res = { } today = time . strftime ( <str> ) for partner in self . browse ( cr , uid , ids , context ) :              accounts = [ ] if partner . property_account_receivable :                  accounts . append ( partner . property_account_receivable . id )  if partner . property_account_payable :                  accounts . append ( partner . property_account_payable . id )  line_ids = self . pool . get ( <str> ) . search ( cr , uid , [ ( <str> , <str> , partner . id ) , ( <str> , <str> , accounts ) , ( <str> , <str> , False ) , ( <str> , <str> , today ) , ] , context = context ) amount = 0.0 for line in self . pool . get ( <str> ) . browse ( cr , uid , line_ids , context ) :                  if line . currency_id :                      sign = line . amount_currency < 0 and - 1 or 1  else :                      sign = ( line . debit - line . credit ) < 0 and - 1 or 1  if line . reconcile_partial_id :                       amount += line . debit - line . credit  else :                      amount += sign * line . amount_residual   res [ partner . id ] = amount  return res  def _pending_amount ( self , cr , uid , ids , name , arg , context = None ) :          res = { } today = time . strftime ( <str> ) for partner in self . browse ( cr , uid , ids , context ) :              accounts = [ ] if partner . property_account_receivable :                  accounts . append ( partner . property_account_receivable . id )  if partner . property_account_payable :                  accounts . append ( partner . property_account_payable . id )  line_ids = self . pool . get ( <str> ) . search ( cr , uid , [ ( <str> , <str> , partner . id ) , ( <str> , <str> , accounts ) , ( <str> , <str> , False ) , <str> , ( <str> , <str> , today ) , ( <str> , <str> , False ) ] , context = context ) amount = 0.0 for line in self . pool . get ( <str> ) . browse ( cr , uid , line_ids , context ) :                  if line . currency_id :                      sign = line . amount_currency < 0 and - 1 or 1  else :                      sign = ( line . debit - line . credit ) < 0 and - 1 or 1  if line . reconcile_partial_id :                       amount += line . debit - line . credit  else :                      amount += sign * line . amount_residual   res [ partner . id ] = amount  return res  def _draft_invoices_amount ( self , cr , uid , ids , name , arg , context = None ) :          res = { } today = time . strftime ( <str> ) for id in ids :              invids = self . pool . get ( <str> ) . search ( cr , uid , [ ( <str> , <str> , [ id ] ) , ( <str> , <str> , <str> ) , <str> , ( <str> , <str> , today ) , ( <str> , <str> , False ) ] , context = context ) val = 0.0 for invoice in self . pool . get ( <str> ) . browse ( cr , uid , invids , context ) :                  if invoice . move_id :                      continue  if invoice . type in ( <str> , <str> ) :                      val += invoice . amount_total  else :                      val -= invoice . amount_total   res [ id ] = val  return res  def _pending_orders_amount ( self , cr , uid , ids , name , arg , context = None ) :          res = { } for id in ids :              total = 0.0 mids = self . pool . get ( <str> ) . search ( cr , uid , [ ( <str> , <str> , [ id ] ) , ( <str> , <str> , [ <str> , <str> ] ) , ( <str> , <str> , False ) , ( <str> , <str> , <str> ) ] , context = context ) for move in self . pool . get ( <str> ) . browse ( cr , uid , mids ) :                  line = move . procurement_id . sale_line_id sign = move . picking_id . picking_type_code == <str> and 1 or - 1 total += sign * ( move . product_uom_qty * ( line . price_unit * ( 1 - ( line . discount or 0.0 ) / 100.0 ) ) )  sids = self . pool . get ( <str> ) . search ( cr , uid , [ ( <str> , <str> , [ id ] ) , ( <str> , <str> , [ <str> , <str> , <str> , <str> ] ) , ( <str> , <str> , False ) , <str> , ( <str> , <str> , False ) , ( <str> , <str> , <str> ) ] , context = context ) for sline in self . pool . get ( <str> ) . browse ( cr , uid , sids ) :                  total += sline . price_subtotal  res [ id ] = total  return res  def _get_circulating_amount ( self , cr , uid , ids , name , arg , context = None ) :          res = { } for id in ids :              amount = 0.0 move_ids = self . pool . get ( <str> ) . search ( cr , uid , [ ( <str> , <str> , [ id ] ) , ( <str> , <str> , True ) , ( <str> , <str> , False ) ] ) for line in self . pool . get ( <str> ) . browse ( cr , uid , move_ids , context ) :                  if line . currency_id :                      sign = line . amount_currency < 0 and - 1 or 1  else :                      sign = ( line . debit - line . credit ) < 0 and - 1 or 1  if line . reconcile_partial_id :                       amount += line . debit - line . credit  else :                      amount += sign * line . amount_residual   res [ id ] = amount  return res  def _total_debt ( self , cr , uid , ids , name , arg , context = None ) :          res = { } for partner in self . browse ( cr , uid , ids , context ) :              pending_orders = partner . pending_orders_amount or 0.0 unpayed = partner . unpayed_amount or 0.0 pending = partner . pending_amount or 0.0 draft_invoices = partner . draft_invoices_amount or 0.0 circulating = partner . circulating_amount or 0.0 res [ partner . id ] = pending_orders + unpayed + pending + draft_invoices + circulating  return res  def _available_risk ( self , cr , uid , ids , name , arg , context = None ) :          res = { } for partner in self . browse ( cr , uid , ids , context ) :              res [ partner . id ] = partner . credit_limit - partner . total_debt  return res  def _total_risk_percent ( self , cr , uid , ids , name , arg , context = None ) :          res = { } for partner in self . browse ( cr , uid , ids , context ) :              if partner . credit_limit :                  res [ partner . id ] = 100.0 * partner . total_debt / partner . credit_limit  else :                  res [ partner . id ] = 100   return res  _columns = { <str> : fields . function ( _unpayed_amount , method = True , string = _ ( <str> ) , type = <str> ) , <str> : fields . function ( _pending_amount , method = True , string = _ ( <str> ) , type = <str> ) , <str> : fields . function ( _get_circulating_amount , method = True , string = <str> , type = <str> ) , <str> : fields . function ( _draft_invoices_amount , method = True , string = _ ( <str> ) , type = <str> ) , <str> : fields . function ( _pending_orders_amount , method = True , string = _ ( <str> ) , type = <str> ) , <str> : fields . function ( _total_debt , method = True , string = _ ( <str> ) , type = <str> ) , <str> : fields . function ( _available_risk , method = True , string = _ ( <str> ) , type = <str> ) , <str> : fields . function ( _total_risk_percent , method = True , string = _ ( <str> ) , type = <str> ) }  partner ( )  