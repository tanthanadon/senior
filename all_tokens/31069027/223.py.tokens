from openerp . osv import osv , fields import openerp . addons . decimal_precision as dp import time from openerp . tools . translate import _ def rounding ( f , r ) :      if not r :          return f  return round ( f / r ) * r  class product_product ( osv . osv ) :      _inherit = <str> _columns = { <str> : fields . property ( type = <str> , relation = <str> , string = <str> ) } def action_show_product_costs ( self , cr , uid , ids , context = None ) :          if context is None :              context = { }  prod_cost_line_obj = self . pool . get ( <str> ) value = prod_cost_line_obj . show_product_costs ( cr , uid , ids , context ) return value  def action_get_product_costs ( self , cr , uid , ids , context = None ) :          if context is None :              context = { }  prod_cost_line_obj = self . pool . get ( <str> ) value = prod_cost_line_obj . get_product_costs ( cr , uid , ids , context ) return value  def action_update_product_costs ( self , cr , uid , ids , context = None ) :          if context is None :              context = { }  prod_cost = self . pool . get ( <str> ) line = self . pool . get ( <str> ) prod = self . pool . get ( <str> ) vals = { } if context . get ( <str> , False ) :              pro = [ context [ <str> ] ]  else :              pro = prod . search ( cr , uid , [ ] )  for product in prod . browse ( cr , uid , pro ) :              if product . cost_structure_id and product . cost_structure_id . elements :                  cost_ids = prod_cost . search ( cr , uid , [ ( <str> , <str> , product . id ) ] , order = <str> ) if cost_ids :                      lines = line . search ( cr , uid , [ ( <str> , <str> , cost_ids [ 0 ] ) , ( <str> , <str> , True ) , ( <str> , <str> , True ) ] , order = <str> ) if lines :                          line_cost = line . browse ( cr , uid , lines [ 0 ] ) vals = { <str> : line_cost . theoric_cost }     return vals   class product_cost ( osv . osv ) :      _name = <str> _rec_name = <str> _columns = { <str> : fields . many2one ( <str> , <str> , required = True ) , <str> : fields . one2many ( <str> , <str> , <str> ) , <str> : fields . datetime ( <str> , required = True ) , <str> : fields . many2one ( <str> , <str> , required = True ) , } _defaults = { <str> : lambda s , cr , uid , c : s . pool . get ( <str> ) . _company_default_get ( cr , uid , <str> , context = c ) , }  class product_cost_lines ( osv . osv ) :      _name = <str> def _cost_percent ( self , cr , uid , ids , name , arg , context = None ) :          res = { } for prod_cost_line in self . browse ( cr , uid , ids , context ) :              res [ prod_cost_line . id ] = { <str> : 0.0 , } if prod_cost_line . real_cost :                  res [ prod_cost_line . id ] [ <str> ] = 100 * ( ( prod_cost_line . theoric_cost / prod_cost_line . real_cost ) - 1 )  else :                  res [ prod_cost_line . id ] [ <str> ] = 100   return res  _columns = { <str> : fields . many2one ( <str> , <str> , required = True , ondelete = <str> ) , <str> : fields . integer ( <str> , required = True ) , <str> : fields . char ( <str> , size = 255 , required = True ) , <str> : fields . float ( <str> , required = True , digits = ( 16 , 3 ) ) , <str> : fields . float ( <str> , required = True , digits = ( 16 , 3 ) ) , <str> : fields . function ( _cost_percent , method = True , string = _ ( <str> ) , type = <str> , digits = ( 4 , 2 ) , multi = <str> ) , <str> : fields . boolean ( <str> ) , <str> : fields . boolean ( <str> ) , <str> : fields . related ( <str> , <str> , type = <str> , relation = <str> , string = <str> , store = True , readonly = True ) , } _defaults = { <str> : 0.0 , <str> : 0.0 , <str> : False , <str> : False , }   