from openerp . osv import osv , fields import time import calendar import datetime from dateutil . relativedelta import relativedelta import openerp . addons . decimal_precision as dp from openerp . tools . translate import _ def rounding ( f , r ) :      if not r :          return f  return round ( f / r ) * r  class product_costs_line ( osv . osv_memory ) :      _name = <str> _description = <str> _columns = { <str> : fields . integer ( <str> , required = True ) , <str> : fields . char ( <str> , size = 255 , required = True ) , <str> : fields . float ( <str> , digits = ( 16 , 3 ) , required = True ) , <str> : fields . float ( <str> , digits = ( 16 , 3 ) , required = True ) , <str> : fields . float ( <str> , digits = ( 4 , 2 ) , readonly = <str> ) , <str> : fields . boolean ( <str> ) , <str> : fields . boolean ( <str> ) } _defaults = { <str> : 0.0 , <str> : 0.0 } def _get_costs ( self , cr , uid , ids , element_id = False , product_id = False , context = None ) :          theoric = 0.0 real = 0.0 element_facade = self . pool . get ( <str> ) product_facade = self . pool . get ( <str> ) user_facade = self . pool . get ( <str> ) loc_facade = self . pool . get ( <str> ) uom_obj = self . pool . get ( <str> ) bom_obj = self . pool . get ( <str> ) budline_facade = self . pool . get ( <str> ) buditem_facade = self . pool . get ( <str> ) sale_forecast = self . pool . get ( <str> ) sale_forecast_line = self . pool . get ( <str> ) if element_id and product_id :              element = element_facade . browse ( cr , uid , element_id ) product = product_facade . browse ( cr , uid , product_id ) time_start = False time_stop = False year = time . strftime ( <str> ) time_start = <str> + year + <str> first_day , last_day = calendar . monthrange ( int ( year ) , 12 ) time_stop = str ( last_day ) + <str> + year + <str> if element . cost_type == <str> :                  if product . bom_ids :                      bom = product . bom_ids [ 0 ] factor = uom_obj . _compute_qty ( cr , uid , bom . product_uom . id , bom . product_qty , product . uom_id . id ) res1 , res2 = bom_obj . _bom_explode ( cr , uid , bom , product . id , factor / bom . product_qty , properties = [ ] ) if res1 :                          for r in res1 :                              productb = product_facade . browse ( cr , uid , r [ <str> ] ) if productb :                                  theoric += productb . standard_price * r [ <str> ]   theoric = theoric / ( factor or 1.0 )    elif element . cost_type == <str> :                      theoric = product . standard_price or 0.0  elif element . cost_type == <str> :                  if element . distribution_mode == <str> :                      theoric = element . cost_ratio * product . standard_price  elif element . distribution_mode == <str> :                      theoric = element . cost_ratio  elif element . distribution_mode == <str> :                      theoric = element . cost_ratio * product . weight_net  elif element . distribution_mode == <str> :                      if product . bom_ids :                          bom = product . bom_ids [ 0 ] if bom . routing_id :                              hours = 0.0 for wc_use in bom . routing_id . workcenter_lines :                                  wc = wc_use . workcenter_id qty_per_cycle = uom_obj . _compute_qty ( cr , uid , wc_use . uom_id . id , wc_use . qty_per_cycle , product . uom_id . id ) hours += float ( ( wc_use . hour_nbr / qty_per_cycle ) * ( wc . time_efficiency or 1.0 ) * ( wc_use . operators_number or 1.0 ) )  theoric = element . cost_ratio * hours * 60     elif element . cost_type == <str> :                  theoric = 0.0  elif element . cost_type == <str> :                  theoric = 0.0  cost = 0.0 context . update ( { <str> : time_stop [ : 10 ] } ) obj_product = product_facade . browse ( cr , uid , product_id , context = context ) domain = [ <str> , ( <str> , <str> , <str> ) , ( <str> , <str> , <str> ) ] loc_dest_ids = loc_facade . search ( cr , uid , domain ) company = user_facade . browse ( cr , uid , uid ) . company_id query = <str> + str ( product_id ) + <str> + str ( company . id ) + <str> + str ( tuple ( loc_dest_ids ) ) + <str> + time_stop + <str> + time_start + <str> cr . execute ( query ) a = cr . fetchall ( ) if a and a [ 0 ] and a [ 0 ] [ 0 ] :                  cost += a [ 0 ] [ 0 ]  real = cost  return theoric , real  def get_product_costs ( self , cr , uid , ids , context = None ) :          if context is None :              context = { }  prod = self . pool . get ( <str> ) prod_cost = self . pool . get ( <str> ) prod_cost_line = self . pool . get ( <str> ) lines = [ ] value = { } if context . get ( <str> , False ) :              pro = [ context [ <str> ] ]  else :              pro = prod . search ( cr , uid , [ ] )  for product in prod . browse ( cr , uid , pro ) :              if product . cost_structure_id and product . cost_structure_id . elements :                  new_prod_cost_id = prod_cost . create ( cr , uid , { <str> : product . id , <str> : time . strftime ( <str> ) , <str> : product . cost_structure_id . company_id . id } ) el = product . cost_structure_id . elements sumtheo = 0.0 sumreal = 0.0 theoric = 0.0 real = 0.0 for element in el :                      if element . cost_type not in ( <str> , <str> ) :                          theoric , real = self . _get_costs ( cr , uid , ids , element . id , product . id , context ) sumtheo += theoric sumreal += real  else :                          theoric = sumtheo real = sumreal  vals = { <str> : element . sequence , <str> : element . cost_type_id . name , <str> : theoric , <str> : real , <str> : ( element . cost_type in ( <str> ) ) , <str> : ( element . cost_type in ( <str> , <str> ) ) } new_id = self . create ( cr , uid , vals ) lines . append ( new_id ) vals [ <str> ] = new_prod_cost_id prod_cost_line . create ( cr , uid , vals ) if element . cost_type in ( <str> ) :                          valor_para_la_entrada = theoric value = { <str> : theoric }     if not context . get ( <str> , False ) :              value = { <str> : str ( [ ( <str> , <str> , lines ) ] ) , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : True }  return value  def show_product_costs ( self , cr , uid , ids , context = None ) :          if context is None :              context = { }  prod_cost = self . pool . get ( <str> ) prod_cost_lines = self . pool . get ( <str> ) lines_ids = [ ] value = { } if context . get ( <str> , False ) :              cost_ids = prod_cost . search ( cr , uid , [ ( <str> , <str> , context [ <str> ] ) ] , order = <str> ) if cost_ids :                  lines = prod_cost_lines . search ( cr , uid , [ ( <str> , <str> , cost_ids [ 0 ] ) ] , order = <str> ) if lines :                      lines = prod_cost_lines . browse ( cr , uid , lines ) for l in lines :                          vals = { <str> : l . sequence , <str> : l . name , <str> : l . theoric_cost , <str> : l . real_cost , <str> : l . tc_rc_percent , <str> : l . inventory , <str> : l . total } new_id = self . create ( cr , uid , vals ) lines_ids . append ( new_id )   else :                      raise osv . except_osv ( _ ( <str> ) , _ ( <str> ) )   else :                  raise osv . except_osv ( _ ( <str> ) , _ ( <str> ) )   value = { <str> : str ( [ ( <str> , <str> , lines_ids ) ] ) , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : True } return value   class update_product_costs ( osv . osv_memory ) :      _name = <str> def action_update_product_costs_wzd ( self , cr , uid , ids , context = None ) :          if context is None : context = { } c = context . copy ( ) c [ <str> ] = True c [ <str> ] = True return self . pool . get ( <str> ) . get_product_costs ( cr , uid , ids , c )    