try :      import cStringIO as StringIO  except ImportError :      import StringIO  import base64 import csv from datetime import datetime from sys import exc_info from traceback import format_exception from openerp import models , fields , api , _ from openerp . exceptions import Warning import logging _logger = logging . getLogger ( __name__ ) class AccountMoveLineImport ( models . TransientModel ) :      _name = <str> _description = <str> aml_data = fields . Binary ( string = <str> , required = True ) aml_fname = fields . Char ( string = <str> ) lines = fields . Binary ( compute = <str> , string = <str> , required = True ) dialect = fields . Binary ( compute = <str> , string = <str> , required = True ) csv_separator = fields . Selection ( [ ( <str> , <str> ) , ( <str> , <str> ) ] , string = <str> , required = True ) decimal_separator = fields . Selection ( [ ( <str> , <str> ) , ( <str> , <str> ) ] , string = <str> , default = <str> , required = True ) codepage = fields . Char ( string = <str> , default = lambda self : self . _default_codepage ( ) , help = <str> <str> ) note = fields . Text ( <str> ) @ api . model def _default_codepage ( self ) :          return <str>  @ api . one @ api . depends ( <str> ) def _compute_lines ( self ) :          if self . aml_data :              self . lines = base64 . decodestring ( self . aml_data )   @ api . one @ api . depends ( <str> , <str> ) def _compute_dialect ( self ) :          if self . lines :              try :                  self . dialect = csv . Sniffer ( ) . sniff ( self . lines [ : 128 ] , delimiters = <str> )  except :                  self . dialect = csv . Sniffer ( ) . sniff ( <str> ) if <str> in self . lines [ 128 ] :                      self . dialect . delimiter = <str>  elif <str> in self . lines [ 128 ] :                      self . dialect . delimiter = <str>    if self . csv_separator :              self . dialect . delimiter = str ( self . csv_separator )   @ api . onchange ( <str> ) def _onchange_aml_data ( self ) :          if self . lines :              self . csv_separator = self . dialect . delimiter if self . csv_separator == <str> :                  self . decimal_separator = <str>    @ api . onchange ( <str> ) def _onchange_csv_separator ( self ) :          if self . csv_separator and self . aml_data :              self . dialect . delimiter = self . csv_separator   def _remove_leading_lines ( self , lines ) :          input = StringIO . StringIO ( lines ) header = False while not header :              ln = input . next ( ) if not ln or ln and ln [ 0 ] in [ self . csv_separator , <str> ] :                  continue  else :                  header = ln . lower ( )   if not header :              raise Warning ( _ ( <str> ) )  output = input . read ( ) return output , header  def _input_fields ( self ) :          res = { <str> : { <str> : self . _handle_account } , <str> : { <str> : True } , <str> : { <str> : self . _handle_debit , <str> : True } , <str> : { <str> : self . _handle_credit , <str> : True } , <str> : { <str> : self . _handle_partner } , <str> : { <str> : self . _handle_product } , <str> : { <str> : self . _handle_date_maturity } , <str> : { <str> : self . _handle_date_maturity } , <str> : { <str> : self . _handle_currency } , <str> : { <str> : self . _handle_tax_code } , <str> : { <str> : self . _handle_tax_code } , <str> : { <str> : self . _handle_analytic_account } , } return res  def _get_orm_fields ( self ) :          aml_mod = self . env [ <str> ] orm_fields = aml_mod . fields_get ( ) blacklist = models . MAGIC_COLUMNS + [ aml_mod . CONCURRENCY_CHECK_FIELD ] self . _orm_fields = { f : orm_fields [ f ] for f in orm_fields if f not in blacklist and not orm_fields [ f ] . get ( <str> ) }  def _process_header ( self , header_fields ) :          self . _field_methods = self . _input_fields ( ) self . _skip_fields = [ ] column_cnt = 0 for cnt in range ( len ( header_fields ) ) :              if header_fields [ cnt ] == <str> :                  column_cnt = cnt break  elif cnt == len ( header_fields ) - 1 :                  column_cnt = cnt + 1 break   header_fields = header_fields [ : column_cnt ] header_fields2 = [ ] for hf in header_fields :              if hf in header_fields2 :                  raise Warning ( _ ( <str> <str> ) % hf )  else :                  header_fields2 . append ( hf )   for i , hf in enumerate ( header_fields ) :              if hf in self . _field_methods :                  continue  if hf not in self . _orm_fields and hf not in [ self . _orm_fields [ f ] [ <str> ] . lower ( ) for f in self . _orm_fields ] :                  _logger . error ( _ ( <str> <str> ) , self . _name , hf ) self . _skip_fields . append ( hf ) continue  field_def = self . _orm_fields . get ( hf ) if not field_def :                  for f in self . _orm_fields :                      if self . _orm_fields [ f ] [ <str> ] . lower ( ) == hf :                          orm_field = f field_def = self . _orm_fields . get ( f ) break    else :                  orm_field = hf  field_type = field_def [ <str> ] if field_type in [ <str> , <str> ] :                  self . _field_methods [ hf ] = { <str> : self . _handle_orm_char , <str> : orm_field , }  elif field_type == <str> :                  self . _field_methods [ hf ] = { <str> : self . _handle_orm_integer , <str> : orm_field , }  elif field_type == <str> :                  self . _field_methods [ hf ] = { <str> : self . _handle_orm_float , <str> : orm_field , }  elif field_type == <str> :                  self . _field_methods [ hf ] = { <str> : self . _handle_orm_many2one , <str> : orm_field , }  else :                  _logger . error ( _ ( <str> <str> ) , self . _name , hf , field_type ) self . _skip_fields . append ( hf )   return header_fields  def _log_line_error ( self , line , msg ) :          data = self . csv_separator . join ( [ line [ hf ] for hf in self . _header_fields ] ) self . _err_log += _ ( <str> ) % data + <str> + msg + <str>  def _handle_orm_char ( self , field , line , move , aml_vals , orm_field = False ) :          orm_field = orm_field or field if not aml_vals . get ( orm_field ) :              aml_vals [ orm_field ] = line [ field ]   def _handle_orm_integer ( self , field , line , move , aml_vals , orm_field = False ) :          orm_field = orm_field or field if not aml_vals . get ( orm_field ) :              val = str2int ( line [ field ] , self . decimal_separator ) if val is False :                  msg = _ ( <str> <str> ) % ( line [ field ] , field ) self . _log_line_error ( line , msg )  else :                  aml_vals [ orm_field ] = val    def _handle_orm_float ( self , field , line , move , aml_vals , orm_field = False ) :          orm_field = orm_field or field if not aml_vals . get ( orm_field ) :              aml_vals [ orm_field ] = str2float ( line [ field ] , self . decimal_separator ) val = str2float ( line [ field ] , self . decimal_separator ) if val is False :                  msg = _ ( <str> <str> ) % ( line [ field ] , field ) self . _log_line_error ( line , msg )  else :                  aml_vals [ orm_field ] = val    def _handle_orm_many2one ( self , field , line , move , aml_vals , orm_field = False ) :          orm_field = orm_field or field if not aml_vals . get ( orm_field ) :              val = str2int ( line [ field ] , self . decimal_separator ) if val is False :                  msg = _ ( <str> <str> <str> <str> <str> ) % ( line [ field ] , field ) self . _log_line_error ( line , msg )  else :                  aml_vals [ orm_field ] = val    def _handle_account ( self , field , line , move , aml_vals ) :          if not aml_vals . get ( <str> ) :              code = line [ field ] if code in self . _accounts_dict :                  aml_vals [ <str> ] = self . _accounts_dict [ code ]  else :                  msg = _ ( <str> ) % code self . _log_line_error ( line , msg )    def _handle_debit ( self , field , line , move , aml_vals ) :          if <str> not in aml_vals :              debit = str2float ( line [ field ] , self . decimal_separator ) aml_vals [ <str> ] = debit self . _sum_debit += debit   def _handle_credit ( self , field , line , move , aml_vals ) :          if <str> not in aml_vals :              credit = str2float ( line [ field ] , self . decimal_separator ) aml_vals [ <str> ] = credit self . _sum_credit += credit   def _handle_partner ( self , field , line , move , aml_vals ) :          if not aml_vals . get ( <str> ) :              input = line [ field ] part_mod = self . env [ <str> ] dom = [ <str> , ( <str> , <str> , False ) , ( <str> , <str> , True ) ] dom_ref = dom + [ ( <str> , <str> , input ) ] partners = part_mod . search ( dom_ref ) if not partners :                  dom_name = dom + [ ( <str> , <str> , input ) ] partners = part_mod . search ( dom_name )  if not partners :                  msg = _ ( <str> ) % input self . _log_line_error ( line , msg ) return  elif len ( partners ) > 1 :                  msg = _ ( <str> <str> ) % input self . _log_line_error ( line , msg ) return  else :                  partner = partners [ 0 ] aml_vals [ <str> ] = partner . id    def _handle_product ( self , field , line , move , aml_vals ) :          if not aml_vals . get ( <str> ) :              input = line [ field ] prod_mod = self . env [ <str> ] products = prod_mod . search ( [ ( <str> , <str> , input ) ] ) if not products :                  products = prod_mod . search ( [ ( <str> , <str> , input ) ] )  if not products :                  msg = _ ( <str> ) % input self . _log_line_error ( line , msg ) return  elif len ( products ) > 1 :                  msg = _ ( <str> <str> ) % input self . _log_line_error ( line , msg ) return  else :                  product = products [ 0 ] aml_vals [ <str> ] = product . id    def _handle_date_maturity ( self , field , line , move , aml_vals ) :          if not aml_vals . get ( <str> ) :              due = line [ field ] try :                  datetime . strptime ( due , <str> ) aml_vals [ <str> ] = due  except :                  msg = _ ( <str> <str> <str> ) % ( field , due ) self . _log_line_error ( line , msg )    def _handle_currency ( self , field , line , move , aml_vals ) :          if not aml_vals . get ( <str> ) :              name = line [ field ] curr = self . env [ <str> ] . search ( [ ( <str> , <str> , name ) ] ) if curr :                  aml_vals [ <str> ] = curr [ 0 ] . id  else :                  msg = _ ( <str> ) % name self . _log_line_error ( line , msg )    def _handle_tax_code ( self , field , line , move , aml_vals ) :          if not aml_vals . get ( <str> ) :              input = line [ field ] tc_mod = self . env [ <str> ] codes = tc_mod . search ( [ ( <str> , <str> , input ) ] ) if not codes :                  codes = tc_mod . search ( [ ( <str> , <str> , input ) ] )  if not codes :                  msg = _ ( <str> ) % ( field , input ) self . _log_line_error ( line , msg ) return  elif len ( codes ) > 1 :                  msg = _ ( <str> <str> ) % ( field , input ) self . _log_line_error ( line , msg ) return  else :                  code = codes [ 0 ] aml_vals [ <str> ] = code . id    def _handle_analytic_account ( self , field , line , move , aml_vals ) :          if not aml_vals . get ( <str> ) :              ana_mod = self . env [ <str> ] input = line [ field ] domain = [ ( <str> , <str> , <str> ) , ( <str> , <str> , move . company_id . id ) , ( <str> , <str> , [ <str> , <str> ] ) ] analytic_accounts = ana_mod . search ( domain + [ ( <str> , <str> , input ) ] ) if len ( analytic_accounts ) == 1 :                  aml_vals [ <str> ] = analytic_accounts . id  else :                  analytic_accounts = ana_mod . search ( domain + [ ( <str> , <str> , input ) ] ) if len ( analytic_accounts ) == 1 :                      aml_vals [ <str> ] = analytic_accounts . id   if not analytic_accounts :                  msg = _ ( <str> ) % input self . _log_line_error ( line , msg )  elif len ( analytic_accounts ) > 1 :                  msg = _ ( <str> <str> ) % input self . _log_line_error ( line , msg )    def _process_line_vals ( self , line , move , aml_vals ) :          if <str> not in aml_vals :              aml_vals [ <str> ] = <str>  if <str> not in aml_vals :              aml_vals [ <str> ] = 0.0  if <str> not in aml_vals :              aml_vals [ <str> ] = 0.0  if <str> not in aml_vals :              aml_vals [ <str> ] = False  all_fields = self . _field_methods required_fields = [ x for x in all_fields if all_fields [ x ] . get ( <str> ) ] for rf in required_fields :              if rf not in aml_vals :                  msg = _ ( <str> <str> ) % rf self . _log_line_error ( line , msg )    def _process_vals ( self , move , vals ) :          dp = self . env [ <str> ] . precision_get ( <str> ) if round ( self . _sum_debit , dp ) != round ( self . _sum_credit , dp ) :              self . _err_log += <str> + _ ( <str> <str> ) % ( self . _sum_debit , self . _sum_credit ) + <str>  return vals  @ api . multi def aml_import ( self ) :          self . _err_log = <str> move = self . env [ <str> ] . browse ( self . _context [ <str> ] ) accounts = self . env [ <str> ] . search ( [ ( <str> , <str> , [ <str> , <str> , <str> ] ) , ( <str> , <str> , move . company_id . id ) ] ) self . _accounts_dict = { a . code : a . id for a in accounts } self . _sum_debit = self . _sum_credit = 0.0 self . _get_orm_fields ( ) lines , header = self . _remove_leading_lines ( self . lines ) header_fields = csv . reader ( StringIO . StringIO ( header ) , dialect = self . dialect ) . next ( ) self . _header_fields = self . _process_header ( header_fields ) reader = csv . DictReader ( StringIO . StringIO ( lines ) , fieldnames = self . _header_fields , dialect = self . dialect ) move_lines = [ ] for line in reader :              aml_vals = { } for i , hf in enumerate ( self . _header_fields ) :                  try :                      line [ hf ] = line [ hf ] . decode ( self . codepage ) . strip ( )  except :                      tb = <str> . join ( format_exception ( * exc_info ( ) ) ) raise Warning ( _ ( <str> ) , _ ( <str> ) % ( line , tb ) )   for i , hf in enumerate ( self . _header_fields ) :                  if i == 0 and line [ hf ] and line [ hf ] [ 0 ] == <str> :                      break  if hf in self . _skip_fields :                      continue  if line [ hf ] == <str> :                      continue  if self . _field_methods [ hf ] . get ( <str> ) :                      self . _field_methods [ hf ] [ <str> ] ( hf , line , move , aml_vals , orm_field = self . _field_methods [ hf ] [ <str> ] )  else :                      self . _field_methods [ hf ] [ <str> ] ( hf , line , move , aml_vals )   if aml_vals :                  self . _process_line_vals ( line , move , aml_vals ) move_lines . append ( aml_vals )   vals = [ ( 0 , 0 , l ) for l in move_lines ] vals = self . _process_vals ( move , vals ) if self . _err_log :              self . note = self . _err_log module = __name__ . split ( <str> ) [ 1 ] . split ( <str> ) [ 0 ] result_view = self . env . ref ( <str> % module ) return { <str> : _ ( <str> ) , <str> : self . id , <str> : <str> , <str> : <str> , <str> : <str> , <str> : result_view . id , <str> : <str> , <str> : <str> , }  else :              move . write ( { <str> : vals } ) return { <str> : <str> }    def str2float ( amount , decimal_separator ) :      if not amount :          return 0.0  try :          if decimal_separator == <str> :              return float ( amount . replace ( <str> , <str> ) )  else :              return float ( amount . replace ( <str> , <str> ) . replace ( <str> , <str> ) )   except :          return False   def str2int ( amount , decimal_separator ) :      if not amount :          return 0  try :          if decimal_separator == <str> :              return int ( amount . replace ( <str> , <str> ) )  else :              return int ( amount . replace ( <str> , <str> ) . replace ( <str> , <str> ) )   except :          return False    