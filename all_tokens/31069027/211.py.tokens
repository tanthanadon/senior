from openerp import models , fields , api from openerp . addons . decimal_precision import decimal_precision as dp from openerp . tools . translate import _ from openerp . exceptions import except_orm from openerp . tools . float_utils import float_is_zero import time import logging _logger = logging . getLogger ( __name__ ) class StockMove ( models . Model ) :      _inherit = <str> accepted_qty = fields . Float ( digits = dp . get_precision ( <str> ) , string = <str> , copy = False ) product_uom_acc_qty = fields . Float ( digits = dp . get_precision ( <str> ) , string = <str> , copy = False ) rejected = fields . Boolean ( <str> ) price_subtotal_accepted = fields . Float ( compute = <str> , string = <str> , digits = dp . get_precision ( <str> ) , readonly = True , store = False ) cost_subtotal_accepted = fields . Float ( compute = <str> , string = <str> , digits = dp . get_precision ( <str> ) , readonly = True , store = False ) margin_accepted = fields . Float ( compute = <str> , string = <str> , digits = dp . get_precision ( <str> ) , readonly = True , store = False ) percent_margin_accepted = fields . Float ( compute = <str> , string = <str> , digits = dp . get_precision ( <str> ) , readonly = True , store = False ) change_price = fields . Boolean ( <str> ) new_price_unit = fields . Float ( <str> ) new_discount = fields . Float ( <str> ) @ api . multi def _check_qty ( self ) :          res = True for move in self :              if move . accepted_qty > move . product_uos_qty or move . product_uom_acc_qty > move . product_uom_qty :                  return False   return res  _constraints = [ ( _check_qty , <str> , [ <str> , <str> ] ) ] @ api . onchange ( <str> ) def accepted_qty_onchange ( self ) :          product = self . product_id t_uom = self . env [ <str> ] if product :              qty = self . accepted_qty uos_id = self . product_uos . id uom_id = self . product_id . uom_id . id self . product_uom_acc_qty = t_uom . _compute_qty ( uos_id , qty , uom_id )   @ api . onchange ( <str> ) def uom_acc_qty ( self ) :          product = self . product_id t_uom = self . env [ <str> ] if product :              qty = self . product_uom_acc_qty uos_id = self . product_uos . id uom_id = self . product_id . uom_id . id self . accepted_qty = t_uom . _compute_qty ( uom_id , qty , uos_id )   @ api . multi def _get_subtotal_accepted ( self ) :          qty = 0 price = 0 for move in self :              _logger . debug ( <str> ) if move . procurement_id . sale_line_id :                  price_unit = move . procurement_id . sale_line_id . price_unit price_disc_unit = price_unit price = price_disc_unit qty = move . product_uom_acc_qty sale_line = move . procurement_id . sale_line_id taxes = sale_line . tax_id . compute_all ( price , qty , move . product_id , move . picking_id . partner_id ) cur = sale_line . order_id . pricelist_id . currency_id move . price_subtotal_accepted = cur . round ( taxes [ <str> ] )    @ api . multi def action_done ( self ) :          res = super ( StockMove , self ) . action_done ( ) for move in self :              if move . picking_id . picking_type_code == <str> :                  move . write ( { <str> : move . product_uos_qty , <str> : move . product_uom_qty } )   return res  def _get_invoice_line_vals ( self , cr , uid , move , partner , inv_type , context = None ) :          res = super ( StockMove , self ) . _get_invoice_line_vals ( cr , uid , move , partner , inv_type , context = context ) if move . picking_id . state == <str> and move . picking_id . reviewed :              if move . product_uos and move . accepted_qty :                  res [ <str> ] = move . accepted_qty  elif move . product_uom_acc_qty :                  res [ <str> ] = move . product_uom_acc_qty   return res   class StockPicking ( models . Model ) :      _inherit = <str> reviewed = fields . Boolean ( string = <str> , default = False ) payment_mode = fields . Many2one ( <str> , compute = <str> , string = <str> , store = False ) move_lines = fields . One2many ( <str> , <str> , <str> , states = { <str> : [ ( <str> , False ) ] , <str> : [ ( <str> , True ) ] } , copy = True ) amount_untaxed_acc = fields . Float ( compute = <str> , digits_compute = dp . get_precision ( <str> ) , string = <str> , readonly = True , store = False ) amount_tax_acc = fields . Float ( compute = <str> , digits_compute = dp . get_precision ( <str> ) , string = <str> , readonly = True , store = False ) amount_total_acc = fields . Float ( compute = <str> , digits_compute = dp . get_precision ( <str> ) , string = <str> , readonly = True , store = False ) amount_gross_acc = fields . Float ( compute = <str> , digits_compute = dp . get_precision ( <str> ) , string = <str> , readonly = True , store = False ) amount_discounted_acc = fields . Float ( compute = <str> , digits_compute = dp . get_precision ( <str> ) , string = <str> , readonly = True , store = False ) receipt_amount = fields . Float ( compute = <str> , digits_compute = dp . get_precision ( <str> ) , string = <str> , readonly = False , store = False ) @ api . multi def _get_payment_mode ( self ) :          sale_obj = self . env [ <str> ] for picking in self :              picking . payment_mode = False if picking . group_id :                  sale_ids = sale_obj . search ( [ ( <str> , <str> , picking . group_id . id ) ] ) if sale_ids :                      picking . payment_mode = sale_ids [ 0 ] . payment_mode_id . id     @ api . multi def _receipt_amount ( self ) :          init_t = time . time ( ) cash_type = self . env [ <str> ] . get_object_reference ( <str> , <str> ) cash_type_id = cash_type [ 1 ] for picking in self :              if not picking . sale_id :                  picking . receipt_amount = 0.0 continue  else :                  if picking . sale_id . payment_mode_id . type . id == cash_type_id :                      picking . receipt_amount = picking . amount_total_acc    _logger . debug ( <str> , time . time ( ) - init_t )  @ api . multi def fast_returns ( self ) :          move_obj = self . env [ <str> ] res = [ ] for pick in self :              invoice_st = <str> if pick . invoice_state in [ <str> ] :                  invoice_st = <str>  else :                  invoice_st = <str>  moves_to_unreserve = [ ] if pick . picking_type_id . code != <str> :                  raise except_orm ( _ ( <str> ) , _ ( <str> <str> <str> ) )  for move in pick . move_lines :                  to_check_moves = [ move . move_dest_id ] if move . move_dest_id . id else [ ] while to_check_moves :                      current_move = to_check_moves . pop ( ) if current_move . state not in ( <str> , <str> ) and current_move . reserved_quant_ids :                          moves_to_unreserve . append ( current_move . id )  split_move_ids = move_obj . search ( [ ( <str> , <str> , current_move . id ) ] ) if split_move_ids :                          to_check_moves += move_obj . browse ( split_move_ids )    if moves_to_unreserve :                  move_obj . do_unreserve ( moves_to_unreserve ) move_obj . write ( moves_to_unreserve , { <str> : False } )  pick_type_id = pick . picking_type_id . return_picking_type_id and pick . picking_type_id . return_picking_type_id . id or pick . picking_type_id . id moves = self . env [ <str> ] if pick . invoice_state in [ <str> ] :                  invoice_st = <str>  else :                  invoice_st = <str>  for move in pick . move_lines :                  new_qty = move . product_uos_qty - move . accepted_qty new_uom_qty = move . product_uom_qty - move . product_uom_acc_qty if pick . invoice_state == <str> and pick . state in [ <str> ] and float_is_zero ( move . product_uom_acc_qty , precision_digits = 0 ) :                      move . invoice_state = <str>  if new_uom_qty :                      if move . origin_returned_move_id . move_dest_id . id and move . origin_returned_move_id . move_dest_id . state != <str> :                          move_dest_id = move . origin_returned_move_id . move_dest_id . id  else :                          move_dest_id = False  if len ( move . linked_move_operation_ids ) == 1 :                          lot_id = move . linked_move_operation_ids [ 0 ] . operation_id . lot_id and move . linked_move_operation_ids [ 0 ] . operation_id . lot_id . id  else :                          lot_id = False  new_move_id = move . copy ( { <str> : move . product_id . id , <str> : new_uom_qty , <str> : new_qty , <str> : False , <str> : <str> , <str> : new_qty , <str> : new_uom_qty , <str> : move . location_dest_id . id , <str> : move . location_id . id , <str> : pick_type_id , <str> : pick . picking_type_id . warehouse_id . id , <str> : move . id , <str> : <str> , <str> : lot_id , <str> : move_dest_id , <str> : invoice_st } ) moves += new_move_id   if len ( moves ) :                  new_picking = pick . copy ( { <str> : [ ] , <str> : pick_type_id , <str> : <str> , <str> : pick . name , <str> : <str> , <str> : False , <str> : invoice_st } ) res . append ( new_picking . id ) for move in moves :                      move . picking_id = new_picking . id  new_picking . action_confirm ( ) new_picking . action_assign ( )   self . write ( { <str> : True } ) return res  @ api . multi def _amount_all_acc ( self ) :          init_t = time . time ( ) for picking in self :              val1 = 0 val = 0.0 if picking . picking_type_id . code == <str> :                  if not picking . sale_id :                      picking . amount_tax_acc = picking . amount_untaxed_acc = picking . amount_gross_acc = 0.0 continue  cur = picking . partner_id . property_product_pricelist and picking . partner_id . property_product_pricelist . currency_id or False for line in picking . move_lines :                      sale_line = line . procurement_id . sale_line_id if sale_line and line . state != <str> :                          price_unit = line . procurement_id . sale_line_id . price_unit price_disc_unit = price_unit price = price_disc_unit qty = line . product_uom_acc_qty val1 += line . price_subtotal_accepted if sale_line and line . state != <str> :                              partner_sale = sale_line . order_id . partner_id res = sale_line . tax_id . compute_all ( price , qty , line . product_id , partner_sale ) [ <str> ] for c in res :                                  val += c . get ( <str> , 0.0 )    else :                          continue   if cur :                      picking . amount_tax_acc = cur . round ( val ) picking . amount_untaxed_acc = cur . round ( val1 )  else :                      picking . amount_tax_acc = round ( val , 2 ) picking . amount_untaxed_acc = round ( val1 , 2 )  picking . amount_total_acc = picking . amount_untaxed_acc + picking . amount_tax_acc   print picking _logger . debug ( <str> , time . time ( ) - init_t )  @ api . cr_uid_ids_context def do_recompute_remaining_quantities ( self , cr , uid , picking_ids , context = None ) :          for picking in self . browse ( cr , uid , picking_ids , context = context ) :              if picking . pack_operation_ids and picking . state == <str> :                  return   return super ( StockPicking , self ) . do_recompute_remaining_quantities ( cr , uid , picking_ids , context )   class StockPackOperation ( models . Model ) :      _inherit = <str> @ api . one def unlink ( self ) :          if self . picking_id . state == <str> :              return  return super ( StockPackOperation , self ) . unlink ( )    