from openerp import api , fields , models from datetime import datetime , timedelta from openerp . osv import fields as fields2 import pytz class resource_calendar_attendance ( models . Model ) :      _inherit = <str> date_to = fields . Date ( <str> )  class resource_calendar ( models . Model ) :      _inherit = <str> @ api . multi def get_attendances_for_weekdays ( self , day_dt ) :          self . ensure_one ( ) weekday = day_dt . weekday ( ) attendances = self . env [ <str> ] for attendance in self . attendance_ids . filtered ( lambda att : int ( att . dayofweek ) == weekday and not ( att . date_from and fields . Date . from_string ( att . date_from ) > day_dt . date ( ) ) and not ( att . date_to and fields . Date . from_string ( att . date_to ) < day_dt . date ( ) ) ) :              attendances |= attendance  return attendances  def get_working_intervals_of_day ( self , cr , uid , id , start_dt = None , end_dt = None , leaves = None , compute_leaves = False , resource_id = None , default_interval = None , context = None ) :          if isinstance ( id , ( list , tuple ) ) :              id = id [ 0 ]  work_limits = [ ] if start_dt is None and end_dt is not None :              start_dt = end_dt . replace ( hour = 0 , minute = 0 , second = 0 )  elif start_dt is None :              start_dt = datetime . now ( ) . replace ( hour = 0 , minute = 0 , second = 0 )  else :              work_limits . append ( ( start_dt . replace ( hour = 0 , minute = 0 , second = 0 ) , start_dt ) )  if end_dt is None :              end_dt = start_dt . replace ( hour = 23 , minute = 59 , second = 59 )  else :              work_limits . append ( ( end_dt , end_dt . replace ( hour = 23 , minute = 59 , second = 59 ) ) )  assert start_dt . date ( ) == end_dt . date ( ) , <str> intervals = [ ] work_dt = start_dt . replace ( hour = 0 , minute = 0 , second = 0 ) if id is None :              working_interval = [ ] if default_interval :                  working_interval = ( start_dt . replace ( hour = default_interval [ 0 ] , minute = 0 , second = 0 ) , start_dt . replace ( hour = default_interval [ 1 ] , minute = 0 , second = 0 ) )  intervals = self . interval_remove_leaves ( working_interval , work_limits ) return intervals  working_intervals = [ ] tz_info = fields2 . datetime . context_timestamp ( cr , uid , work_dt , context = context ) . tzinfo for calendar_working_day in self . get_attendances_for_weekdays ( cr , uid , id , start_dt , context ) :              x = work_dt . replace ( hour = 0 , minute = 0 , second = 0 , microsecond = 0 ) + timedelta ( seconds = ( calendar_working_day . hour_from * 3600 ) ) y = work_dt . replace ( hour = 0 , minute = 0 , second = 0 , microsecond = 0 ) + timedelta ( seconds = ( calendar_working_day . hour_to * 3600 ) ) x = x . replace ( tzinfo = tz_info ) . astimezone ( pytz . UTC ) . replace ( tzinfo = None ) y = y . replace ( tzinfo = tz_info ) . astimezone ( pytz . UTC ) . replace ( tzinfo = None ) working_interval = ( x , y ) working_intervals += self . interval_remove_leaves ( working_interval , work_limits )  if leaves is None and compute_leaves :              leaves = self . get_leave_intervals ( cr , uid , id , resource_id = resource_id , context = None )  for interval in working_intervals :              work_intervals = self . interval_remove_leaves ( interval , leaves ) intervals += work_intervals  return intervals    