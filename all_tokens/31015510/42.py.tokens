from openprocurement . api . utils import ( json_view , context_unpack , get_now , raise_operation_error ) from openprocurement . tender . core . utils import ( optendersresource , apply_patch , save_tender , calculate_business_date ) from openprocurement . tender . core . validation import ( validate_tender_period_extension , validate_tender_status_update_in_terminated_status , validate_tender_status_update_not_in_pre_qualificaton ) from openprocurement . tender . belowthreshold . views . tender import TenderResource from openprocurement . tender . openeu . utils import ( check_status , all_bids_are_reviewed ) from openprocurement . tender . openua . utils import calculate_normalized_date from openprocurement . tender . openua . validation import validate_patch_tender_ua_data from openprocurement . tender . openeu . constants import ( PREQUALIFICATION_COMPLAINT_STAND_STILL as COMPLAINT_STAND_STILL ) from openprocurement . tender . core . events import TenderInitializeEvent @ optendersresource ( name = <str> , path = <str> , procurementMethodType = <str> , description = <str> ) class TenderEUResource ( TenderResource ) :      @ json_view ( content_type = <str> , validators = ( validate_patch_tender_ua_data , validate_tender_status_update_in_terminated_status , validate_tender_status_update_not_in_pre_qualificaton , ) , permission = <str> ) def patch ( self ) :          tender = self . context data = self . request . validated [ <str> ] if self . request . authenticated_role == <str> and self . request . validated [ <str> ] == <str> :              if <str> in data and <str> in data [ <str> ] :                  self . request . validated [ <str> ] . tenderPeriod . import_data ( data [ <str> ] ) validate_tender_period_extension ( self . request ) self . request . registry . notify ( TenderInitializeEvent ( self . request . validated [ <str> ] ) ) self . request . validated [ <str> ] [ <str> ] = self . request . validated [ <str> ] . enquiryPeriod . serialize ( )   apply_patch ( self . request , save = False , src = self . request . validated [ <str> ] ) if self . request . authenticated_role == <str> :              check_status ( self . request )  elif self . request . authenticated_role == <str> and tender . status == <str> :              tender . invalidate_bids_data ( )  elif self . request . authenticated_role == <str> and self . request . validated [ <str> ] == <str> and tender . status == <str> :              active_lots = [ lot . id for lot in tender . lots if lot . status == <str> ] if tender . lots else [ None ] if any ( [ i [ <str> ] in self . request . validated [ <str> ] . block_complaint_status for q in self . request . validated [ <str> ] [ <str> ] for i in q [ <str> ] if q [ <str> ] in active_lots ] ) :                  raise_operation_error ( self . request , <str> )  if all_bids_are_reviewed ( self . request ) :                  normalized_date = calculate_normalized_date ( get_now ( ) , tender , True ) tender . qualificationPeriod . endDate = calculate_business_date ( normalized_date , COMPLAINT_STAND_STILL , self . request . validated [ <str> ] ) tender . check_auction_time ( )  else :                  raise_operation_error ( self . request , <str> )   save_tender ( self . request ) self . LOGGER . info ( <str> . format ( tender . id ) , extra = context_unpack ( self . request , { <str> : <str> } ) ) return { <str> : tender . serialize ( tender . status ) }    