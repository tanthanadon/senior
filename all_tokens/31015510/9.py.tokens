from logging import getLogger from functools import partial from cornice . resource import resource from openprocurement . api . models import get_now , TZ from openprocurement . api . utils import ( error_handler , context_unpack , ) from openprocurement . tender . core . utils import ( remove_draft_bids , has_unanswered_questions , has_unanswered_complaints ) from openprocurement . tender . belowthreshold . utils import ( check_tender_status ) from openprocurement . tender . openua . utils import ( add_next_award , check_complaint_status ) from openprocurement . tender . openeu . models import Qualification from openprocurement . tender . openeu . traversal import ( qualifications_factory , bid_financial_documents_factory , bid_eligibility_documents_factory , bid_qualification_documents_factory ) LOGGER = getLogger ( __name__ ) qualifications_resource = partial ( resource , error_handler = error_handler , factory = qualifications_factory ) bid_financial_documents_resource = partial ( resource , error_handler = error_handler , factory = bid_financial_documents_factory ) bid_eligibility_documents_resource = partial ( resource , error_handler = error_handler , factory = bid_eligibility_documents_factory ) bid_qualification_documents_resource = partial ( resource , error_handler = error_handler , factory = bid_qualification_documents_factory ) def check_initial_bids_count ( request ) :      tender = request . validated [ <str> ] if tender . lots :          [ setattr ( i . auctionPeriod , <str> , None ) for i in tender . lots if i . numberOfBids < 2 and i . auctionPeriod and i . auctionPeriod . startDate ] for i in tender . lots :              if i . numberOfBids < 2 and i . status == <str> :                  setattr ( i , <str> , <str> ) for bid_index , bid in enumerate ( tender . bids ) :                      for lot_index , lot_value in enumerate ( bid . lotValues ) :                          if lot_value . relatedLot == i . id :                              setattr ( tender . bids [ bid_index ] . lotValues [ lot_index ] , <str> , <str> )      if not set ( [ i . status for i in tender . lots ] ) . difference ( set ( [ <str> , <str> ] ) ) :              LOGGER . info ( <str> . format ( tender . id , <str> ) , extra = context_unpack ( request , { <str> : <str> } ) ) tender . status = <str>   elif tender . numberOfBids < 2 :          LOGGER . info ( <str> . format ( tender . id , <str> ) , extra = context_unpack ( request , { <str> : <str> } ) ) if tender . auctionPeriod and tender . auctionPeriod . startDate :              tender . auctionPeriod . startDate = None  tender . status = <str>   def prepare_qualifications ( request , bids = [ ] , lotId = None ) :      new_qualifications = [ ] tender = request . validated [ <str> ] if not bids :          bids = tender . bids  if tender . lots :          active_lots = [ lot . id for lot in tender . lots if lot . status == <str> ] for bid in bids :              if bid . status not in [ <str> , <str> ] :                  for lotValue in bid . lotValues :                      if lotValue . status == <str> and lotValue . relatedLot in active_lots :                          if lotId :                              if lotValue . relatedLot == lotId :                                  qualification = Qualification ( { <str> : bid . id , <str> : <str> , <str> : lotId } ) qualification . date = get_now ( ) tender . qualifications . append ( qualification ) new_qualifications . append ( qualification . id )   else :                              qualification = Qualification ( { <str> : bid . id , <str> : <str> , <str> : lotValue . relatedLot } ) qualification . date = get_now ( ) tender . qualifications . append ( qualification ) new_qualifications . append ( qualification . id )       else :          for bid in bids :              if bid . status == <str> :                  qualification = Qualification ( { <str> : bid . id , <str> : <str> } ) qualification . date = get_now ( ) tender . qualifications . append ( qualification ) new_qualifications . append ( qualification . id )    return new_qualifications  def all_bids_are_reviewed ( request ) :      if request . validated [ <str> ] . lots :          active_lots = [ lot . id for lot in request . validated [ <str> ] . lots if lot . status == <str> ] return all ( [ lotValue . status != <str> for bid in request . validated [ <str> ] . bids if bid . status not in [ <str> , <str> ] for lotValue in bid . lotValues if lotValue . relatedLot in active_lots ] )  else :          return all ( [ bid . status != <str> for bid in request . validated [ <str> ] . bids ] )   def check_status ( request ) :      tender = request . validated [ <str> ] now = get_now ( ) active_lots = [ lot . id for lot in tender . lots if lot . status == <str> ] if tender . lots else [ None ] configurator = request . content_configurator for award in tender . awards :          if award . status == <str> and not any ( [ i . awardID == award . id for i in tender . contracts ] ) :              tender . contracts . append ( type ( tender ) . contracts . model_class ( { <str> : award . id , <str> : award . suppliers , <str> : award . value , <str> : now , <str> : [ i for i in tender . items if i . relatedLot == award . lotID ] , <str> : <str> . format ( tender . tenderID , request . registry . server_id , len ( tender . contracts ) + 1 ) } ) ) add_next_award ( request , reverse = configurator . reverse_awarding_criteria , awarding_criteria_key = configurator . awarding_criteria_key )   if tender . status == <str> and tender . tenderPeriod . endDate <= now and not has_unanswered_complaints ( tender ) and not has_unanswered_questions ( tender ) :          for complaint in tender . complaints :              check_complaint_status ( request , complaint )  LOGGER . info ( <str> . format ( tender [ <str> ] , <str> ) , extra = context_unpack ( request , { <str> : <str> } ) ) tender . status = <str> tender . qualificationPeriod = type ( tender ) . qualificationPeriod ( { <str> : now } ) remove_draft_bids ( request ) check_initial_bids_count ( request ) prepare_qualifications ( request ) return  elif tender . status == <str> and tender . qualificationPeriod and tender . qualificationPeriod . endDate <= now and not any ( [ i . status in tender . block_complaint_status for q in tender . qualifications for i in q . complaints if q . lotID in active_lots ] ) :          LOGGER . info ( <str> . format ( tender [ <str> ] , <str> ) , extra = context_unpack ( request , { <str> : <str> } ) ) tender . status = <str> check_initial_bids_count ( request ) return  elif not tender . lots and tender . status == <str> :          standStillEnds = [ a . complaintPeriod . endDate . astimezone ( TZ ) for a in tender . awards if a . complaintPeriod . endDate ] if not standStillEnds :              return  standStillEnd = max ( standStillEnds ) if standStillEnd <= now :              check_tender_status ( request )   elif tender . lots and tender . status in [ <str> , <str> ] :          if any ( [ i [ <str> ] in tender . block_complaint_status and i . relatedLot is None for i in tender . complaints ] ) :              return  for lot in tender . lots :              if lot [ <str> ] != <str> :                  continue  lot_awards = [ i for i in tender . awards if i . lotID == lot . id ] standStillEnds = [ a . complaintPeriod . endDate . astimezone ( TZ ) for a in lot_awards if a . complaintPeriod . endDate ] if not standStillEnds :                  continue  standStillEnd = max ( standStillEnds ) if standStillEnd <= now :                  check_tender_status ( request ) return      