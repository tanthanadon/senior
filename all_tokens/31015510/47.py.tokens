from openprocurement . api . utils import ( get_file , upload_file , update_file_content_type , json_view , context_unpack , get_now , raise_operation_error ) from openprocurement . api . validation import ( validate_file_update , validate_file_upload , validate_patch_document_data , ) from openprocurement . tender . core . validation import ( validate_bid_document_operation_period , validate_bid_document_operation_with_award , validate_bid_document_operation_in_not_allowed_status ) from openprocurement . tender . core . utils import ( save_tender , apply_patch , optendersresource ) from openprocurement . tender . openeu . utils import ( bid_financial_documents_resource , bid_eligibility_documents_resource , bid_qualification_documents_resource , ) from openprocurement . tender . openua . views . bid_document import ( TenderUaBidDocumentResource ) from openprocurement . tender . openeu . validation import ( validate_update_bid_document_confidentiality , validate_add_bid_document_not_in_allowed_status , validate_update_bid_document_not_in_allowed_status ) @ optendersresource ( name = <str> , collection_path = <str> , path = <str> , procurementMethodType = <str> , description = <str> ) class TenderEUBidDocumentResource ( TenderUaBidDocumentResource ) :      container = <str> view_forbidden_states = [ <str> ] view_forbidden_bid_states = [ <str> , <str> ] def _doc_access_restricted ( self , doc ) :          is_bid_owner = self . request . authenticated_role == <str> is_tender_owner = self . request . authenticated_role == <str> return doc . confidentiality != <str> and not ( is_bid_owner or is_tender_owner )  @ json_view ( permission = <str> ) def collection_get ( self ) :          if self . request . validated [ <str> ] in self . view_forbidden_states and self . request . authenticated_role != <str> :              raise_operation_error ( self . request , <str> . format ( self . request . validated [ <str> ] ) )  if self . context . status in self . view_forbidden_bid_states and self . request . authenticated_role != <str> :              raise_operation_error ( self . request , <str> . format ( self . context . status ) )  if self . request . params . get ( <str> , <str> ) :              collection_data = [ i . serialize ( <str> ) if self . _doc_access_restricted ( i ) else i . serialize ( <str> ) for i in getattr ( self . context , self . container ) ]  else :              collection_data = sorted ( dict ( [ ( i . id , i . serialize ( <str> ) if self . _doc_access_restricted ( i ) else i . serialize ( <str> ) ) for i in getattr ( self . context , self . container ) ] ) . values ( ) , key = lambda i : i [ <str> ] )  return { <str> : collection_data }  @ json_view ( validators = ( validate_file_upload , validate_bid_document_operation_in_not_allowed_status , validate_bid_document_operation_period , validate_bid_document_operation_with_award , validate_add_bid_document_not_in_allowed_status ) , permission = <str> ) def collection_post ( self ) :          document = upload_file ( self . request ) getattr ( self . context , self . container ) . append ( document ) if self . request . validated [ <str> ] == <str> :              self . request . validated [ <str> ] . modified = False  if save_tender ( self . request ) :              self . LOGGER . info ( <str> . format ( document . id ) , extra = context_unpack ( self . request , { <str> : <str> } , { <str> : document . id } ) ) self . request . response . status = 201 document_route = self . request . matched_route . name . replace ( <str> , <str> ) self . request . response . headers [ <str> ] = self . request . current_route_url ( _route_name = document_route , document_id = document . id , _query = { } ) return { <str> : document . serialize ( <str> ) }   @ json_view ( permission = <str> ) def get ( self ) :          is_bid_owner = self . request . authenticated_role == <str> if self . request . validated [ <str> ] in self . view_forbidden_states and not is_bid_owner :              raise_operation_error ( self . request , <str> . format ( self . request . validated [ <str> ] ) )  if self . request . validated [ <str> ] . status in self . view_forbidden_bid_states and self . request . authenticated_role != <str> :              raise_operation_error ( self . request , <str> . format ( self . request . validated [ <str> ] . status ) )  document = self . request . validated [ <str> ] if self . request . params . get ( <str> ) :              if self . _doc_access_restricted ( document ) :                  raise_operation_error ( self . request , <str> )  else :                  return get_file ( self . request )   document_data = document . serialize ( <str> if self . _doc_access_restricted ( document ) else <str> ) document_data [ <str> ] = [ i . serialize ( <str> ) if self . _doc_access_restricted ( i ) else i . serialize ( <str> ) for i in self . request . validated [ <str> ] if i . url != document . url ] return { <str> : document_data }  @ json_view ( content_type = <str> , validators = ( validate_patch_document_data , validate_bid_document_operation_in_not_allowed_status , validate_bid_document_operation_period , validate_bid_document_operation_with_award , validate_update_bid_document_confidentiality , validate_update_bid_document_not_in_allowed_status ) , permission = <str> ) def patch ( self ) :          if self . request . validated [ <str> ] == <str> :              self . request . validated [ <str> ] . modified = False  if apply_patch ( self . request , src = self . request . context . serialize ( ) ) :              update_file_content_type ( self . request ) self . LOGGER . info ( <str> . format ( self . request . context . id ) , extra = context_unpack ( self . request , { <str> : <str> } ) ) return { <str> : self . request . context . serialize ( <str> ) }   @ json_view ( validators = ( validate_file_update , validate_bid_document_operation_in_not_allowed_status , validate_bid_document_operation_period , validate_bid_document_operation_with_award , validate_update_bid_document_confidentiality , validate_update_bid_document_not_in_allowed_status ) , permission = <str> ) def put ( self ) :          document = upload_file ( self . request ) getattr ( self . request . validated [ <str> ] , self . container ) . append ( document ) if self . request . validated [ <str> ] == <str> :              self . request . validated [ <str> ] . modified = False  if save_tender ( self . request ) :              self . LOGGER . info ( <str> . format ( self . request . context . id ) , extra = context_unpack ( self . request , { <str> : <str> } ) ) return { <str> : document . serialize ( <str> ) }    @ bid_financial_documents_resource ( name = <str> , collection_path = <str> , path = <str> , procurementMethodType = <str> , description = <str> ) class TenderEUBidFinancialDocumentResource ( TenderEUBidDocumentResource ) :      container = <str> view_forbidden_states = [ <str> , <str> , <str> , <str> ] view_forbidden_bid_states = [ <str> , <str> , <str> , <str> ]  @ bid_eligibility_documents_resource ( name = <str> , collection_path = <str> , path = <str> , procurementMethodType = <str> , description = <str> ) class TenderEUBidEligibilityDocumentResource ( TenderEUBidFinancialDocumentResource ) :      container = <str> view_forbidden_states = [ <str> ] view_forbidden_bid_states = [ <str> , <str> ]  @ bid_qualification_documents_resource ( name = <str> , collection_path = <str> , path = <str> , procurementMethodType = <str> , description = <str> ) class TenderEUBidQualificationDocumentResource ( TenderEUBidFinancialDocumentResource ) :      container = <str>   