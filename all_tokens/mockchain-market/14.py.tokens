from hashlib import sha256 from os import path import time from dispersy . database import Database from market . community . encoding import encode class Backend ( object ) :      def get ( self , _type , _id ) :          raise NotImplementedError  def post ( self , _type , _id , obj ) :          raise NotImplementedError  def put ( self , _type , _id , obj ) :          raise NotImplementedError  def delete ( self , obj ) :          raise NotImplementedError  def id_available ( self , _id ) :          raise NotImplementedError  def exists ( self , _type , _id ) :          raise NotImplementedError  def clear ( self ) :          raise NotImplementedError  def get_all ( self , _type ) :          raise NotImplementedError  def get_option ( self , option_name ) :          raise NotImplementedError  def set_option ( self , option_name , value ) :          raise NotImplementedError   class BlockChain ( object ) :      def add_block ( self , block ) :          raise NotImplementedError  def update_block_with_beneficiary ( self , block ) :          raise NotImplementedError  def get_latest_hash ( self ) :          raise NotImplementedError  def get_by_hash ( self , hash ) :          raise NotImplementedError  def get_by_public_key_and_sequence_number ( self , public_key , sequence_number ) :          raise NotImplementedError  def _create_database_block ( self , db_result ) :          raise NotImplementedError  def get_latest_sequence_number ( self ) :          raise NotImplementedError  def get_next_sequence_number ( self ) :          raise NotImplementedError  def create_genesis_block ( self ) :          raise NotImplementedError  def check_add_genesis_block ( self ) :          raise NotImplementedError   class MemoryBackend ( Backend ) :      _data = { <str> : { } } _id = { } def get ( self , type_name , value_id ) :          try :              return self . _data [ type_name ] [ value_id ]  except :              raise IndexError   def post ( self , type_name , value_id , obj ) :          if type_name not in self . _data :              self . _data [ type_name ] = { }  if not self . id_available ( value_id ) :              raise IndexError ( <str> )  self . _data [ type_name ] [ value_id ] = obj self . _id [ value_id ] = True  def put ( self , type_name , value_id , obj ) :          if self . exists ( type_name , value_id ) :              self . _data [ type_name ] [ value_id ] = obj return True  return False  def delete ( self , obj ) :          if obj :              if self . exists ( obj . type , obj . id ) :                  del self . _data [ obj . type ] [ obj . id ] return True   return False  def id_available ( self , value_id ) :          return value_id not in self . _id  def exists ( self , type_name , value_id ) :          if type_name in self . _data :              return value_id in self . _data [ type_name ]  return False  def clear ( self ) :          self . _data = { <str> : { } } self . _id = { }  def get_all ( self , type_name ) :          try :              return self . _data [ type_name ] . values ( )  except :              raise KeyError   def set_option ( self , option_name , value ) :          self . _data [ <str> ] [ option_name ] = value  def get_option ( self , option_name ) :          try :              return self . _data [ <str> ] [ option_name ]  except :              raise KeyError    class PersistentBackend ( Database , Backend , BlockChain ) :      DATABASE_PATH = <str> LATEST_DB_VERSION = 1 schema = <str> + str ( LATEST_DB_VERSION ) + <str> def __init__ ( self , working_directory , database_name = DATABASE_PATH ) :          super ( PersistentBackend , self ) . __init__ ( path . join ( working_directory , database_name ) ) self . open ( )  def open ( self , initial_statements = True , prepare_visioning = True ) :          return super ( PersistentBackend , self ) . open ( initial_statements , prepare_visioning )  def close ( self , commit = True ) :          return super ( PersistentBackend , self ) . close ( commit )  def check_database ( self , database_version ) :          assert isinstance ( database_version , unicode ) assert database_version . isdigit ( ) assert int ( database_version ) >= 0 database_version = int ( database_version ) if database_version < self . LATEST_DB_VERSION :              self . executescript ( self . schema ) self . commit ( )  return self . LATEST_DB_VERSION  def get ( self , type_name , value_id ) :          db_query = <str> db_result = self . execute ( db_query , ( unicode ( type_name ) , unicode ( value_id ) ) ) . fetchall ( ) if len ( db_result ) != 1 :              raise IndexError  return db_result [ 0 ] [ 0 ]  def get_all ( self , type_name ) :          db_query = <str> db_result = self . execute ( db_query , ( unicode ( type_name ) , ) ) . fetchall ( ) return [ t [ 0 ] for t in db_result ]  def post ( self , type_name , value_id , obj ) :          if not self . id_available ( value_id ) :              raise IndexError ( <str> )  db_query = <str> self . execute ( db_query , ( unicode ( value_id ) , unicode ( type_name ) , unicode ( obj ) ) ) self . commit ( )  def put ( self , type_name , value_id , obj ) :          if self . exists ( type_name , value_id ) :              db_query = <str> self . execute ( db_query , ( unicode ( obj ) , unicode ( value_id ) , unicode ( type_name ) ) ) self . commit ( ) return True  else :              return False   def delete ( self , obj ) :          db_query = <str> cur = self . execute ( db_query , ( unicode ( obj . id ) , ) ) self . commit ( ) return cur . rowcount > 0  def id_available ( self , value_id ) :          db_query = <str> db_result = self . execute ( db_query , ( unicode ( value_id ) , ) ) . fetchall ( ) return db_result [ 0 ] [ 0 ] == 0  def exists ( self , type_name , value_id ) :          db_query = <str> db_result = self . execute ( db_query , ( unicode ( value_id ) , unicode ( type_name ) ) ) . fetchall ( ) return db_result [ 0 ] [ 0 ] == 1  def clear ( self ) :          self . execute ( <str> ) self . execute ( <str> ) self . execute ( <str> )  def set_option ( self , option_name , value ) :          db_query = <str> self . execute ( db_query , ( unicode ( option_name ) , unicode ( value ) , ) ) self . commit ( )  def get_option ( self , option_name ) :          db_query = <str> db_result = self . execute ( db_query , ( unicode ( option_name ) , ) ) . fetchall ( ) if len ( db_result ) != 1 :              raise IndexError  return db_result [ 0 ] [ 0 ]  def add_block ( self , block ) :          data = ( buffer ( block . benefactor ) , buffer ( block . beneficiary ) , buffer ( block . agreement_benefactor ) , buffer ( block . agreement_beneficiary ) , block . sequence_number_benefactor , block . sequence_number_beneficiary , buffer ( block . previous_hash_benefactor ) , buffer ( block . previous_hash_beneficiary ) , buffer ( block . signature_benefactor ) , buffer ( block . signature_beneficiary ) , block . insert_time , buffer ( block . hash_block ) , buffer ( self . get_latest_hash ( ) ) , self . get_next_sequence_number ( ) ) self . execute ( <str> <str> <str> <str> <str> , data ) self . commit ( )  def update_block_with_beneficiary ( self , block ) :          data = ( buffer ( block . beneficiary ) , buffer ( block . agreement_beneficiary ) , block . sequence_number_beneficiary , buffer ( block . previous_hash_beneficiary ) , buffer ( block . signature_benefactor ) , buffer ( block . signature_beneficiary ) , buffer ( block . hash_block ) ) where = ( block . insert_time , block . sequence_number_benefactor , buffer ( block . benefactor ) ) self . execute ( <str> <str> <str> <str> <str> , data + where ) self . commit ( )  def get_latest_hash ( self ) :          db_query = <str> db_result = self . execute ( db_query ) . fetchone ( ) return str ( db_result [ 0 ] ) if db_result else <str>  def get_by_hash ( self , hash ) :          db_query = <str> <str> <str> <str> <str> <str> db_result = self . execute ( db_query , ( buffer ( hash ) , ) ) . fetchone ( ) return self . _create_database_block ( db_result )  def get_by_public_key_and_sequence_number ( self , public_key , sequence_number ) :          db_query = <str> <str> <str> <str> <str> <str> <str> <str> <str> <str> <str> <str> <str> db_result = self . execute ( db_query , ( sequence_number , buffer ( public_key ) ) ) . fetchone ( ) return self . _create_database_block ( db_result )  def _create_database_block ( self , db_result ) :          if db_result :              return DatabaseBlock ( db_result )  else :              return None   def get_latest_sequence_number ( self ) :          db_query = <str> db_result = self . execute ( db_query ) . fetchone ( ) return db_result [ 0 ] if db_result is not None else 0  def get_next_sequence_number ( self ) :          sequence_number = self . get_latest_sequence_number ( ) if sequence_number == 0 :              return sequence_number  else :              return sequence_number + 1   def create_genesis_block ( self ) :          packet = encode ( ( str ( <str> ) , str ( <str> ) , str ( None ) , str ( None ) , 0 , 0 , str ( <str> ) , str ( <str> ) , str ( <str> ) , str ( <str> ) , 0 ) ) hash = sha256 ( packet ) . hexdigest ( ) return DatabaseBlock ( ( str ( <str> ) , str ( <str> ) , str ( None ) , str ( None ) , 0 , 0 , str ( <str> ) , str ( <str> ) , str ( <str> ) , str ( <str> ) , 0 , str ( hash ) ) )  def check_add_genesis_block ( self ) :          db_query = <str> db_result = self . execute ( db_query ) . fetchone ( ) if db_result [ 0 ] == 0 :              genesis_block = self . create_genesis_block ( ) self . add_block ( genesis_block )    class DatabaseBlock :      def __init__ ( self , data ) :          self . benefactor = str ( data [ 0 ] ) self . beneficiary = str ( data [ 1 ] ) self . agreement_benefactor = str ( data [ 2 ] ) self . agreement_beneficiary = str ( data [ 3 ] ) self . sequence_number_benefactor = data [ 4 ] self . sequence_number_beneficiary = data [ 5 ] self . previous_hash_benefactor = str ( data [ 6 ] ) self . previous_hash_beneficiary = str ( data [ 7 ] ) self . signature_benefactor = str ( data [ 8 ] ) self . signature_beneficiary = str ( data [ 9 ] ) self . insert_time = data [ 10 ] self . hash_block = sha256 ( self . hash ( ) ) . hexdigest ( ) if len ( data ) > 12 :              self . previous_hash = str ( data [ 12 ] ) self . sequence_number = data [ 13 ]   def hash ( self ) :          packet = encode ( ( self . benefactor , self . beneficiary , self . agreement_benefactor , self . agreement_beneficiary , self . sequence_number_benefactor , self . sequence_number_beneficiary , self . previous_hash_benefactor , self . previous_hash_beneficiary , self . signature_benefactor , self . signature_beneficiary , self . insert_time , ) ) return packet  @ classmethod def from_signed_confirm_message ( cls , message ) :          payload = message . payload return cls ( ( payload . benefactor , payload . beneficiary , payload . agreement_benefactor and payload . agreement_benefactor . encode ( ) or <str> , payload . agreement_beneficiary and payload . agreement_beneficiary . encode ( ) or <str> , payload . sequence_number_benefactor , payload . sequence_number_beneficiary , payload . previous_hash_benefactor , payload . previous_hash_beneficiary , payload . signature_benefactor , payload . signature_beneficiary , payload . insert_time ) )    