import time import unittest from twisted . python . threadable import registerAsIOThread from uuid import UUID from dispersy . candidate import LoopbackCandidate from dispersy . dispersy import Dispersy from dispersy . endpoint import ManualEnpoint from dispersy . member import DummyMember from market . api . api import STATUS , MarketAPI from market . community . community import MortgageMarketCommunity from market . database . backends import PersistentBackend from market . database . database import MarketDatabase from market . models import DatabaseModel from market . models . loans import Mortgage from market . database . backends import DatabaseBlock class CustomAssertions ( object ) :      def assertEqualBlocks ( self , block1 , block2 ) :          self . assertEqual ( block1 . benefactor , block2 . benefactor ) self . assertEqual ( block1 . beneficiary , block2 . beneficiary ) self . assertEqual ( block1 . agreement_benefactor , block2 . agreement_benefactor ) self . assertEqual ( block1 . agreement_beneficiary , block2 . agreement_beneficiary ) self . assertEqual ( block1 . sequence_number_benefactor , block2 . sequence_number_benefactor ) self . assertEqual ( block1 . sequence_number_beneficiary , block2 . sequence_number_beneficiary ) self . assertEqual ( block1 . previous_hash_benefactor , block2 . previous_hash_benefactor ) self . assertEqual ( block1 . previous_hash_beneficiary , block2 . previous_hash_beneficiary ) self . assertEqual ( block1 . signature_benefactor , block2 . signature_benefactor ) self . assertEqual ( block1 . signature_beneficiary , block2 . signature_beneficiary ) self . assertEqual ( block1 . insert_time , block2 . insert_time ) self . assertEqual ( block1 . hash_block , block2 . hash_block )   class BlockchainDatabaseTest ( unittest . TestCase , CustomAssertions ) :      def setUp ( self ) :          registerAsIOThread ( ) self . dispersy = Dispersy ( ManualEnpoint ( 0 ) , unicode ( <str> ) ) self . dispersy_bank = Dispersy ( ManualEnpoint ( 0 ) , unicode ( <str> ) ) self . api = MarketAPI ( MarketDatabase ( PersistentBackend ( <str> , <str> ) ) ) self . api_bank = MarketAPI ( MarketDatabase ( PersistentBackend ( <str> , <str> ) ) ) self . api . db . backend . clear ( ) self . api_bank . db . backend . clear ( ) self . user , _ , priv_user = self . api . create_user ( ) self . bank , _ , priv_bank = self . api_bank . create_user ( ) self . dispersy . _database . open ( ) self . dispersy_bank . _database . open ( ) self . master_member = DummyMember ( self . dispersy , 1 , <str> * 20 ) self . member = self . dispersy . get_member ( private_key = priv_user . decode ( <str> ) ) self . member_bank = self . dispersy_bank . get_member ( private_key = priv_bank . decode ( <str> ) ) self . community = MortgageMarketCommunity . init_community ( self . dispersy , self . master_member , self . member ) self . community_bank = MortgageMarketCommunity . init_community ( self . dispersy_bank , self . master_member , self . member_bank ) self . community . api = self . api self . community . user = self . user self . api . community = self . community self . community_bank . api = self . api_bank self . community_bank . user = self . bank self . api_bank . community = self . community_bank self . db = self . api . db . backend self . bank_db = self . api_bank . db . backend self . community . persistence = self . db self . community_bank . persistence = self . bank_db self . mortgage = Mortgage ( UUID ( <str> ) , UUID ( <str> ) , <str> , 80000 , 1 , 2.5 , 1.5 , 2.5 , 36 , <str> , [ ] , STATUS . ACCEPTED ) t = int ( time . time ( ) ) self . payload = ( self . bank . id , self . user . id , self . mortgage , self . mortgage , 2 , 1 , <str> , <str> , <str> , <str> , t , ) self . payload2 = ( self . bank . id , <str> , self . mortgage , None , 2 , 1 , <str> , <str> , <str> , <str> , t , )  def test_from_signed_confirmed ( self ) :          meta = self . community . get_meta_message ( <str> ) message = meta . impl ( authentication = ( [ self . member , self . member_bank ] , ) , distribution = ( self . community . claim_global_time ( ) , ) , payload = self . payload , destination = ( LoopbackCandidate ( ) , ) ) block = DatabaseBlock . from_signed_confirm_message ( message ) self . assertEqual ( block . benefactor , message . payload . benefactor ) self . assertEqual ( block . beneficiary , message . payload . beneficiary ) self . assertEqual ( DatabaseModel . decode ( block . agreement_benefactor ) , message . payload . agreement_benefactor ) self . assertEqual ( DatabaseModel . decode ( block . agreement_beneficiary ) , message . payload . agreement_beneficiary ) self . assertEqual ( block . sequence_number_benefactor , message . payload . sequence_number_benefactor ) self . assertEqual ( block . sequence_number_beneficiary , message . payload . sequence_number_beneficiary ) self . assertEqual ( block . previous_hash_benefactor , message . payload . previous_hash_benefactor ) self . assertEqual ( block . previous_hash_beneficiary , message . payload . previous_hash_beneficiary ) self . assertEqual ( block . insert_time , message . payload . insert_time )  def test_add_get ( self ) :          meta = self . community . get_meta_message ( <str> ) message = meta . impl ( authentication = ( [ self . member , self . member_bank ] , ) , distribution = ( self . community . claim_global_time ( ) , ) , payload = self . payload , destination = ( LoopbackCandidate ( ) , ) ) block = DatabaseBlock . from_signed_confirm_message ( message ) self . db . add_block ( block ) result = self . db . get_by_hash ( block . hash_block ) self . assertEqualBlocks ( block , result )  def test_add_multiple_blocks ( self ) :          meta = self . community . get_meta_message ( <str> ) message1 = meta . impl ( authentication = ( [ self . member , self . member_bank ] , ) , distribution = ( self . community . claim_global_time ( ) , ) , payload = self . payload , destination = ( LoopbackCandidate ( ) , ) ) message2 = meta . impl ( authentication = ( [ self . member , self . member_bank ] , ) , distribution = ( self . community . claim_global_time ( ) , ) , payload = self . payload2 , destination = ( LoopbackCandidate ( ) , ) ) block1 = DatabaseBlock . from_signed_confirm_message ( message1 ) block2 = DatabaseBlock . from_signed_confirm_message ( message2 ) self . db . add_block ( block1 ) self . bank_db . add_block ( block1 ) self . db . add_block ( block2 ) self . bank_db . add_block ( block2 ) result1 = self . db . get_by_hash ( block1 . hash_block ) result2 = self . db . get_by_hash ( block2 . hash_block ) latest_hash_benefactor = self . db . get_latest_hash ( ) latest_hash_beneficiary = self . bank_db . get_latest_hash ( ) self . assertEqualBlocks ( block1 , result1 ) self . assertEqualBlocks ( block2 , result2 ) self . assertNotEqual ( block1 . hash_block , block2 . hash_block ) self . assertEqual ( latest_hash_benefactor , latest_hash_beneficiary ) self . assertEqual ( latest_hash_benefactor , block2 . hash_block ) self . assertEqual ( latest_hash_beneficiary , block2 . hash_block ) self . assertNotEqual ( latest_hash_benefactor , block1 . hash_block ) self . assertNotEqual ( latest_hash_beneficiary , block1 . hash_block )  def test_update_block_with_beneficiary ( self ) :          meta = self . community . get_meta_message ( <str> ) message_no_ben = meta . impl ( authentication = ( [ self . member , self . member_bank ] , ) , distribution = ( self . community . claim_global_time ( ) , ) , payload = self . payload2 , destination = ( LoopbackCandidate ( ) , ) ) message_ben = meta . impl ( authentication = ( [ self . member , self . member_bank ] , ) , distribution = ( self . community . claim_global_time ( ) , ) , payload = self . payload , destination = ( LoopbackCandidate ( ) , ) ) self . community . persist_signature ( message_no_ben ) block_benefactor = DatabaseBlock . from_signed_confirm_message ( message_no_ben ) self . community . update_signature ( message_ben ) block_beneficiary = DatabaseBlock . from_signed_confirm_message ( message_ben ) result = self . db . get_by_hash ( block_beneficiary . hash_block ) self . assertEqualBlocks ( block_beneficiary , result ) result_benefactor = self . db . get_by_public_key_and_sequence_number ( message_ben . payload . benefactor , block_benefactor . sequence_number_benefactor ) result_beneficiary = self . db . get_by_public_key_and_sequence_number ( message_ben . payload . beneficiary , block_beneficiary . sequence_number_beneficiary ) self . assertEqualBlocks ( result_benefactor , result_beneficiary ) self . assertEqualBlocks ( result_benefactor , result ) self . assertEqualBlocks ( result_beneficiary , result )  def test_check_add_genesis_block ( self ) :          self . db . check_add_genesis_block ( ) genesis_block = self . db . create_genesis_block ( ) meta = self . community . get_meta_message ( <str> ) message = meta . impl ( authentication = ( [ self . member , self . member_bank ] , ) , distribution = ( self . community . claim_global_time ( ) , ) , payload = self . payload , destination = ( LoopbackCandidate ( ) , ) ) block = DatabaseBlock . from_signed_confirm_message ( message ) self . db . add_block ( block ) result = self . db . get_by_hash ( block . hash_block ) self . assertEqual ( result . previous_hash , genesis_block . hash_block )  def tearDown ( self ) :          self . dispersy . _database . close ( ) self . dispersy_bank . _database . close ( ) self . api . db . backend . clear ( ) self . api_bank . db . backend . clear ( ) self . api . db . backend . close ( ) self . api_bank . db . backend . close ( )    