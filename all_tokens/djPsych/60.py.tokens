from django . shortcuts import render , get_object_or_404 from django . contrib . auth . decorators import login_required from django . http . response import HttpResponse , Http404 , HttpResponseRedirect , JsonResponse , HttpResponseBadRequest from django . conf import settings from django . core . files . storage import default_storage from django . template import loader import glob import os . path from djexperiments . models import Experiment from django . utils . translation import ugettext as _ from djPsych . utils import get_all_js_files_in_exp from django . contrib . auth . models import Group from djexperiments . forms import SandboxForm , UploadForm from djcollect . models import Participation import os import io import zipfile from argparse import Action from django . core . files import File from django . contrib import messages from djmanager . utils import get_allowed_exp_for_user from djPsych . utils import fetch_files_of_type , get_type import json import pathlib import markdown def lobby ( request , exp_label ) :      try :          exp = Experiment . objects . prefetch_related ( <str> ) . get ( label = exp_label )  except Experiment . DoesNotExist as E :          raise Http404 ( _ ( <str> ) )  if not exp . is_researcher ( request ) :          if hasattr ( exp , <str> ) :              lobby = exp . lobby . render ( )  else :              lobby = _ ( <str> )  return render ( request , <str> , { <str> : exp , <str> : lobby } )  else :          uploadForm = UploadForm ( ) researcher_experiments = Experiment . objects . filter ( research_group__in = request . user . groups . all ( ) ) return render ( request , <str> , { <str> : exp , <str> : researcher_experiments , <str> : exp . list_static_resources ( ) , <str> : uploadForm , <str> : exp . count_dropouts ( ) } )   @ login_required def launch ( request , exp_label ) :      exp = Experiment . objects . get ( label = exp_label ) resources = exp . list_static_urls ( ) if os . path . exists ( os . path . join ( settings . BASE_DIR , <str> , <str> , <str> , <str> , exp . label , <str> ) ) :          consentfile = loader . get_template ( <str> + exp_label + <str> ) . render ( )  elif exp . consent_form :          consentfile = markdown . markdown ( exp . consent_form )  else :          consentfile = None  plugins = fetch_files_of_type ( <str> , <str> ) completion = { } if request . GET . get ( <str> , default = None ) :          request . session [ <str> ] = request . GET [ <str> ] completion = Participation . objects . get ( pk = request . session [ <str> ] ) . completion_status ( )  else :          latest = exp . get_latest_pending ( request ) if latest and exp . enforce_finish :              request . session [ <str> ] = latest . pk completion = latest . completion_status ( ) if latest . completion_status ( ) is not False else { }  else :              completion = { }   return render ( request , <str> , { <str> : resources , <str> : exp , <str> : json . dumps ( completion ) , <str> : False , <str> : consentfile , <str> : plugins , <str> : settings . STATIC_URL , <str> : <str> } )  def summary ( request , exp_label ) :      return HttpResponse ( )  @ login_required def sandbox ( request , exp_label ) :      exp = Experiment . objects . get ( label = exp_label ) if not exp . research_group in request . user . groups . all ( ) :          raise Http404 ( _ ( <str> ) )  plugins = fetch_files_of_type ( <str> , <str> ) resources = exp . list_static_urls ( ) configs = exp . get_all_configurations ( ) choices = [ ] for config in configs :          choices . append ( ( config . name , config . __str__ ( ) ) )  sandboxform = SandboxForm ( versions = choices ) latest = exp . get_latest_pending ( request ) completion = { } if latest :          request . session [ <str> ] = latest . pk completion = latest . completion_status ( )  context = { <str> : resources , <str> : exp , <str> : plugins , <str> : settings . STATIC_URL , <str> : sandboxform , <str> : True , <str> : <str> , <str> : json . dumps ( completion ) } return render ( request , <str> , context ) pass  @ login_required def debrief ( request , exp_label ) :      exp = Experiment . objects . prefetch_related ( <str> , <str> ) . get ( label = exp_label ) if exp . participation_set . filter ( subject = request . user . subject , complete = True ) . exists ( ) :          done = True  elif exp . research_group in request . user . groups . all ( ) :          done = True  else :          done = False  return render ( request , <str> , { <str> : exp . debrief . render ( ) , <str> : done , <str> : exp_label } )  @ login_required def upload_resource ( request , exp_label ) :      exp = Experiment . objects . get ( label = exp_label ) if not exp . research_group in request . user . groups . all ( ) :          raise Http404 ( _ ( <str> ) )  if <str> == request . method :          form = UploadForm ( request . POST , request . FILES ) filesList = request . FILES . getlist ( <str> ) if form . is_valid ( ) :              for currentFile in filesList :                  fileObject = File ( currentFile ) initialPath = fileObject . name fileObject . name = <str> + exp_label + <str> + fileObject . name newPath = settings . MEDIA_ROOT + fileObject . name default_storage . save ( newPath , fileObject ) messages . add_message ( request , messages . SUCCESS , _ ( <str> ) + initialPath )  return HttpResponseRedirect ( <str> + exp_label + <str> )  else :              messages . add_message ( request , messages . WARNING , _ ( <str> ) ) return HttpResponseRedirect ( <str> + exp_label + <str> )   else :          form = UploadForm ( ) return render ( request , <str> , { <str> : form } )   @ login_required def exp_filesystem ( request , exp_label ) :      try :          exp = Experiment . objects . get ( label = exp_label )  except Experiment . DoesNotExist :          return JsonResponse ( { <str> : _ ( <str> + exp_label ) } )  if not exp . is_researcher ( request ) :          return JsonResponse ( { <str> : _ ( <str> + exp_label ) } )  if request . method == <str> :          if request . POST [ <str> ] == <str> :              contents = exp . list_static_resources ( ) response = contents if request . POST [ <str> ] == <str> :                  response = [ { <str> : exp . label , <str> : <str> , <str> : <str> , <str> : settings . MEDIA_URL + exp . label , <str> : { <str> : True } } ] root_nodes = [ ] for folder , files in contents . items ( ) :                      if folder == <str> :                          target = root_nodes  else :                          folder_node = { <str> : folder , <str> : <str> , <str> : settings . MEDIA_URL + exp . label + <str> + folder , <str> : [ ] } root_nodes . append ( folder_node ) target = folder_node [ <str> ]  for file in files :                          subfolder = ( folder + <str> ) if folder != <str> else <str> file_node = { <str> : settings . MEDIA_URL + exp . label + <str> + subfolder + file , <str> : get_type ( file ) , <str> : file } target . append ( file_node )   response [ 0 ] [ <str> ] = root_nodes  return JsonResponse ( response , safe = False )  elif request . POST [ <str> ] == <str> :              to_delete = json . loads ( request . POST [ <str> ] ) for filename in to_delete :                  full_path = default_storage . path ( str ( pathlib . Path ( * pathlib . Path ( filename ) . parts [ 2 : ] ) ) ) if not os . path . exists ( full_path ) :                      return JsonResponse ( { <str> : _ ( <str> + filename + <str> ) } )  if os . path . isdir ( full_path ) :                      return JsonResponse ( { <str> : _ ( <str> ) } )   for filename in to_delete :                  default_storage . delete ( str ( pathlib . Path ( * pathlib . Path ( filename ) . parts [ 2 : ] ) ) )  return JsonResponse ( { <str> : True } )  elif request . POST [ <str> ] == <str> :              parentDir = request . POST [ <str> ] name = request . POST [ <str> ] try :                  os . mkdirs ( os . path . join ( default_storage . location , exp . label , parentDir , name ) , exist_ok = True )  except OSError as e :                  return JsonResponse ( { <str> : str ( e ) } )  return JsonResponse ( { <str> : True , <str> : [ { <str> : name , <str> : <str> } ] } )  elif request . POST [ <str> ] == <str> :              filesList = request . FILES . getlist ( <str> ) parentDir = request . POST [ <str> ] parentDir = pathlib . Path ( parentDir ) parentDir = pathlib . Path ( * parentDir . parts [ 3 : ] ) parentDir = str ( parentDir ) newNodes = [ ] for currentFile in filesList :                  fileObject = File ( currentFile ) initialPath = fileObject . name newPath = os . path . join ( default_storage . location , exp . label , parentDir , initialPath ) relative_path = os . path . join ( settings . MEDIA_URL , exp . label , parentDir , initialPath ) default_storage . save ( newPath , fileObject ) messages . add_message ( request , messages . SUCCESS , _ ( <str> ) + initialPath ) newNodes . append ( { <str> : initialPath , <str> : relative_path , <str> : get_type ( initialPath ) } )  return JsonResponse ( { <str> : True , <str> : newNodes } )  elif request . POST [ <str> ] == <str> :              return JsonResponse ( { } )  elif request . POST [ <str> ] == <str> :              to_download = json . loads ( request . POST [ <str> ] ) base = pathlib . Path ( default_storage . location ) if len ( to_download ) < 2 :                  path = pathlib . Path ( * pathlib . Path ( to_download [ 0 ] ) . parts [ 2 : ] ) if base . joinpath ( path ) . is_file ( ) :                      file = default_storage . open ( str ( path ) ) response = HttpResponse ( file ) response [ <str> ] = <str> + path . name return response  else :                      return HttpResponseBadRequest ( )   else :                  the_zip = io . BytesIO ( ) downloads = zipfile . ZipFile ( the_zip , mode = <str> , compression = zipfile . ZIP_DEFLATED ) downloads . debug = 3 for file in to_download :                      path = pathlib . Path ( * pathlib . Path ( file ) . parts [ 2 : ] ) if base . joinpath ( path ) . is_file ( ) :                          contents = default_storage . open ( str ( path ) ) downloads . writestr ( os . path . basename ( str ( path ) ) , contents . read ( ) ) contents . close ( )   downloads . close ( ) response = HttpResponse ( the_zip . getvalue ( ) , content_type = <str> ) response [ <str> ] = <str> + exp_label + <str> return response    else :          return JsonResponse ( { <str> : _ ( <str> + exp_label ) } )    