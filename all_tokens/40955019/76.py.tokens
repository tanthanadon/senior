import os import numpy as np import imp from jaratoolbox import celldatabase from jaratoolbox import ephyscore from jaratoolbox import spikesanalysis from jaratoolbox import behavioranalysis from jaratoolbox import histologyanalysis as ha from jaratoolbox import settings import database_generation_funcs as funcs import database_bandwidth_tuning_fit_funcs as fitfuncs def photoID_base_stats ( db , filename = <str> ) :      soundLoc = [ ] NaKpeakLatency = np . empty ( len ( db ) ) laserTestStatistic = np . empty ( len ( db ) ) laserPVal = np . empty ( len ( db ) ) laserTrainTestStatistic = np . empty ( len ( db ) ) laserTrainPVal = np . empty ( len ( db ) ) laserChangeFR = np . empty ( len ( db ) ) soundResponseTestStatistic = np . empty ( len ( db ) ) soundResponsePVal = np . empty ( len ( db ) ) onsetSoundResponseTestStatistic = np . empty ( len ( db ) ) onsetSoundResponsePVal = np . empty ( len ( db ) ) sustainedSoundResponseTestStatistic = np . empty ( len ( db ) ) sustainedSoundResponsePVal = np . empty ( len ( db ) ) AMRate = np . empty ( len ( db ) ) gaussFit = [ ] tuningTimeRange = [ ] Rsquared = np . empty ( len ( db ) ) prefFreq = np . empty ( len ( db ) ) octavesFromPrefFreq = np . empty ( len ( db ) ) bestBandSession = np . empty ( len ( db ) ) for indRow , ( dbIndex , dbRow ) in enumerate ( db . iterrows ( ) ) :          cellObj = ephyscore . Cell ( dbRow , useModifiedClusters = True ) print <str> , dbRow [ <str> ] , dbRow [ <str> ] , dbRow [ <str> ] , dbRow [ <str> ] , dbRow [ <str> ] soundSide = dbRow [ <str> ] [ 2 ] recordingSide = dbRow [ <str> ] if ( soundSide == <str> and recordingSide == <str> ) or ( soundSide == <str> and recordingSide == <str> ) :              soundLoc . append ( <str> )  else :              soundLoc . append ( <str> )  peakTimes = dbRow [ <str> ] latency = peakTimes [ 2 ] - peakTimes [ 1 ] NaKpeakLatency [ indRow ] = latency try :              laserEphysData , noBehav = cellObj . load ( <str> )  except IndexError :              print <str> testStatistic = np . nan pVal = np . nan changeFR = np . nan  else :              testStatistic , pVal , changeFR = funcs . laser_response ( laserEphysData )  laserTestStatistic [ indRow ] = testStatistic laserPVal [ indRow ] = pVal laserChangeFR [ indRow ] = changeFR try :              laserTrainEphysData , noBehav = cellObj . load ( <str> )  except IndexError :              print <str> testStatistic = np . nan pVal = np . nan  else :              testStatistic , pVal , changeFR = funcs . laser_response ( laserTrainEphysData )  laserTrainTestStatistic [ indRow ] = testStatistic laserTrainPVal [ indRow ] = pVal try :              bandEphysData , bandBehavData = cellObj . load ( <str> )  except IndexError :              print <str> testStatistic = np . nan pVal = np . nan onsetTestStatistic = np . nan onsetpVal = np . nan sustainedTestStatistic = np . nan sustainedpVal = np . nan AM = np . nan  else :              bandEventOnsetTimes = funcs . get_sound_onset_times ( bandEphysData , <str> ) bandSpikeTimestamps = bandEphysData [ <str> ] bandEachTrial = bandBehavData [ <str> ] secondSort = bandBehavData [ <str> ] numBands = np . unique ( bandEachTrial ) numSec = np . unique ( secondSort ) AM = np . unique ( bandBehavData [ <str> ] ) trialsEachComb = behavioranalysis . find_trials_each_combination ( bandEachTrial , numBands , secondSort , numSec ) trialsEachBaseCond = trialsEachComb [ : , : , - 1 ] testStatistic , pVal = funcs . sound_response_any_stimulus ( bandEventOnsetTimes , bandSpikeTimestamps , trialsEachBaseCond , [ 0.0 , 1.0 ] , [ - 1.2 , - 0.2 ] ) onsetTestStatistic , onsetpVal = funcs . sound_response_any_stimulus ( bandEventOnsetTimes , bandSpikeTimestamps , trialsEachBaseCond , [ 0.0 , 0.05 ] , [ - 0.25 , - 0.2 ] ) sustainedTestStatistic , sustainedpVal = funcs . sound_response_any_stimulus ( bandEventOnsetTimes , bandSpikeTimestamps , trialsEachBaseCond , [ 0.2 , 1.0 ] , [ - 1.0 , - 0.2 ] ) pVal *= len ( numSec ) onsetpVal *= len ( numSec ) sustainedpVal *= len ( numSec )  soundResponseTestStatistic [ indRow ] = testStatistic soundResponsePVal [ indRow ] = pVal onsetSoundResponseTestStatistic [ indRow ] = onsetTestStatistic onsetSoundResponsePVal [ indRow ] = onsetpVal sustainedSoundResponseTestStatistic [ indRow ] = sustainedTestStatistic sustainedSoundResponsePVal [ indRow ] = sustainedpVal AMRate [ indRow ] = AM try :              tuningEphysData , tuningBehavData = cellObj . load ( <str> )  except IndexError :              print <str> freqFit = np . full ( 4 , np . nan ) thisRsquared = np . nan bestFreq = np . nan tuningWindow = [ np . nan , np . nan ] octavesFromBest = np . nan bandIndex = np . nan  else :              tuningEventOnsetTimes = funcs . get_sound_onset_times ( tuningEphysData , <str> ) tuningSpikeTimestamps = tuningEphysData [ <str> ] freqEachTrial = tuningBehavData [ <str> ] intensityEachTrial = tuningBehavData [ <str> ] numFreqs = np . unique ( freqEachTrial ) numIntensities = np . unique ( intensityEachTrial ) timeRange = [ - 0.2 , 0.2 ] spikeTimesFromEventOnset , trialIndexForEachSpike , indexLimitsEachTrial = spikesanalysis . eventlocked_spiketimes ( tuningSpikeTimestamps , tuningEventOnsetTimes , timeRange ) trialsEachType = behavioranalysis . find_trials_each_type ( intensityEachTrial , numIntensities ) trialsHighInt = trialsEachType [ : , - 1 ] trialsEachComb = behavioranalysis . find_trials_each_combination ( freqEachTrial , numFreqs , intensityEachTrial , numIntensities ) trialsEachFreqHighInt = trialsEachComb [ : , : , - 1 ] tuningWindow = funcs . best_window_freq_tuning ( spikeTimesFromEventOnset , indexLimitsEachTrial , trialsEachFreqHighInt ) spikeCountMat = spikesanalysis . spiketimes_to_spikecounts ( spikeTimesFromEventOnset , indexLimitsEachTrial , tuningWindow ) tuningSpikeRates = ( spikeCountMat [ trialsHighInt ] . flatten ( ) ) / ( tuningWindow [ 1 ] - tuningWindow [ 0 ] ) freqsThisIntensity = freqEachTrial [ trialsHighInt ] freqFit , thisRsquared = funcs . gaussian_tuning_fit ( np . log2 ( freqsThisIntensity ) , tuningSpikeRates ) if freqFit is not None :                  bestFreq = 2 ** freqFit [ 0 ] bandIndex , octavesFromBest = funcs . best_index ( cellObj , bestFreq , <str> )  else :                  freqFit = np . full ( 4 , np . nan ) bestFreq = np . nan bandIndex = np . nan octavesFromBest = np . nan   gaussFit . append ( freqFit ) tuningTimeRange . append ( tuningWindow ) Rsquared [ indRow ] = thisRsquared prefFreq [ indRow ] = bestFreq octavesFromPrefFreq [ indRow ] = octavesFromBest bestBandSession [ indRow ] = bandIndex  db [ <str> ] = soundLoc db [ <str> ] = NaKpeakLatency db [ <str> ] = AMRate db [ <str> ] = laserPVal db [ <str> ] = laserTestStatistic db [ <str> ] = laserTrainPVal db [ <str> ] = laserTrainTestStatistic db [ <str> ] = laserChangeFR db [ <str> ] = soundResponseTestStatistic db [ <str> ] = soundResponsePVal db [ <str> ] = onsetSoundResponseTestStatistic db [ <str> ] = onsetSoundResponsePVal db [ <str> ] = sustainedSoundResponseTestStatistic db [ <str> ] = sustainedSoundResponsePVal db [ <str> ] = gaussFit db [ <str> ] = tuningTimeRange db [ <str> ] = Rsquared db [ <str> ] = prefFreq db [ <str> ] = octavesFromPrefFreq db [ <str> ] = bestBandSession if len ( filename ) != 0 :          celldatabase . save_hdf ( db , filename ) print filename + <str>  return db  def photoID_indices ( db , filename = <str> ) :      bestCells = db . query ( <str> ) bestCells = bestCells . loc [ bestCells [ <str> ] > 2 ] bestCells = bestCells . query ( <str> ) bestCells = bestCells . loc [ bestCells [ <str> ] > 0.05 ] bestCells = bestCells . loc [ bestCells [ <str> ] < 0.5 ] bandwidthSpikeArraysHighAmp = np . empty ( ( len ( db ) , 7 ) ) bandwidthSpikeArraysHighAmp [ : ] = np . nan bandwidthSpikeArraysLowAmp = np . empty ( ( len ( db ) , 7 ) ) bandwidthSpikeArraysLowAmp [ : ] = np . nan bandwidthSpikeArraysOnset = np . empty ( ( len ( db ) , 6 ) ) bandwidthSpikeArraysOnset [ : ] = np . nan for dbIndex , dbRow in bestCells . iterrows ( ) :          cell = ephyscore . Cell ( dbRow , useModifiedClusters = True ) bandEphysData , bandBehavData = cell . load_by_index ( int ( dbRow [ <str> ] ) ) bandEventOnsetTimes = funcs . get_sound_onset_times ( bandEphysData , <str> ) bandSpikeTimestamps = bandEphysData [ <str> ] bandEachTrial = bandBehavData [ <str> ] secondSort = bandBehavData [ <str> ] propOnset , propSustained = funcs . onset_sustained_spike_proportion ( bandSpikeTimestamps , bandEventOnsetTimes ) db . at [ dbIndex , <str> ] = propOnset db . at [ dbIndex , <str> ] = propSustained onsetSupInds , onsetSupIndpVals , onsetFacInds , onsetFacIndpVals , onsetPeakInds , onsetSpikeArray = funcs . bandwidth_suppression_from_peak ( bandSpikeTimestamps , bandEventOnsetTimes , bandEachTrial , secondSort , timeRange = [ 0.0 , 0.05 ] , baseRange = [ - 0.05 , 0.0 ] ) db . at [ dbIndex , <str> ] = onsetSupInds [ - 1 ] db . at [ dbIndex , <str> ] = onsetSupIndpVals [ - 1 ] db . at [ dbIndex , <str> ] = onsetFacInds [ - 1 ] db . at [ dbIndex , <str> ] = onsetFacIndpVals [ - 1 ] db . at [ dbIndex , <str> ] = bandEachTrial [ onsetPeakInds [ - 1 ] ] sustainedSupInds , sustainedSupIndpVals , sustainedFacInds , sustainedFacIndpVals , sustainedPeakInds , sustainedSpikeArray = funcs . bandwidth_suppression_from_peak ( bandSpikeTimestamps , bandEventOnsetTimes , bandEachTrial , secondSort , timeRange = [ 0.2 , 1.0 ] , baseRange = [ - 1.0 , - 0.2 ] ) db . at [ dbIndex , <str> ] = sustainedSupInds [ - 1 ] db . at [ dbIndex , <str> ] = sustainedSupIndpVals [ - 1 ] db . at [ dbIndex , <str> ] = sustainedFacInds [ - 1 ] db . at [ dbIndex , <str> ] = sustainedFacIndpVals [ - 1 ] db . at [ dbIndex , <str> ] = bandEachTrial [ sustainedPeakInds [ - 1 ] ] sustainedResponse = sustainedSpikeArray [ : , - 1 ] bandsForFit = np . unique ( bandEachTrial ) bandsForFit [ - 1 ] = 6 mFixed = 1 fitParams , R2 = fitfuncs . diff_of_gauss_fit ( bandsForFit , sustainedResponse , mFixed = mFixed ) db . at [ dbIndex , <str> ] = fitParams [ 0 ] db . at [ dbIndex , <str> ] = fitParams [ 3 ] db . at [ dbIndex , <str> ] = fitParams [ 4 ] db . at [ dbIndex , <str> ] = mFixed db . at [ dbIndex , <str> ] = fitParams [ 1 ] db . at [ dbIndex , <str> ] = fitParams [ 2 ] db . at [ dbIndex , <str> ] = R2 testBands = np . linspace ( bandsForFit [ 0 ] , bandsForFit [ - 1 ] , 500 ) allFitParams = [ mFixed ] allFitParams . extend ( fitParams ) suppInd , prefBW = fitfuncs . extract_stats_from_fit ( allFitParams , testBands ) db . at [ dbIndex , <str> ] = suppInd db . at [ dbIndex , <str> ] = prefBW toneSustainedSupInds , toneSustainedSupIndpVals , toneSustainedFacInds , toneSustainedFacIndpVals , toneSustainedPeakInds , toneSustainedSpikeArray = funcs . bandwidth_suppression_from_peak ( bandSpikeTimestamps , bandEventOnsetTimes , bandEachTrial , secondSort , timeRange = [ 0.2 , 1.0 ] , baseRange = [ - 1.0 , - 0.2 ] , zeroBWBaseline = False ) db . at [ dbIndex , <str> ] = toneSustainedSupInds [ - 1 ] db . at [ dbIndex , <str> ] = toneSustainedSupIndpVals [ - 1 ] db . at [ dbIndex , <str> ] = toneSustainedFacInds [ - 1 ] db . at [ dbIndex , <str> ] = toneSustainedFacIndpVals [ - 1 ] db . at [ dbIndex , <str> ] = bandEachTrial [ toneSustainedPeakInds [ - 1 ] ] toneSustainedResponse = toneSustainedSpikeArray [ : , - 1 ] toneFitParams , toneR2 = fitfuncs . diff_of_gauss_fit ( bandsForFit , toneSustainedResponse , mFixed = mFixed ) db . at [ dbIndex , <str> ] = toneFitParams [ 0 ] db . at [ dbIndex , <str> ] = toneFitParams [ 3 ] db . at [ dbIndex , <str> ] = toneFitParams [ 4 ] db . at [ dbIndex , <str> ] = mFixed db . at [ dbIndex , <str> ] = toneFitParams [ 1 ] db . at [ dbIndex , <str> ] = toneFitParams [ 2 ] db . at [ dbIndex , <str> ] = toneR2 allFitParamsTone = [ mFixed ] allFitParamsTone . extend ( toneFitParams ) suppIndTone , prefBWTone = fitfuncs . extract_stats_from_fit ( allFitParamsTone , testBands ) db . at [ dbIndex , <str> ] = suppIndTone db . at [ dbIndex , <str> ] = prefBWTone noZeroSustainedResponseHighAmp = sustainedSpikeArray [ 1 : , - 1 ] noZeroOnsetResponseHighAmp = onsetSpikeArray [ 1 : , - 1 ] bandsForFitNoZero = bandsForFit [ 1 : ] noZeroFitParamsHigh , noZeroR2High = fitfuncs . diff_of_gauss_fit ( bandsForFitNoZero , noZeroSustainedResponseHighAmp , mFixed = mFixed ) db . at [ dbIndex , <str> ] = noZeroFitParamsHigh [ 0 ] db . at [ dbIndex , <str> ] = noZeroFitParamsHigh [ 3 ] db . at [ dbIndex , <str> ] = noZeroFitParamsHigh [ 4 ] db . at [ dbIndex , <str> ] = mFixed db . at [ dbIndex , <str> ] = noZeroFitParamsHigh [ 1 ] db . at [ dbIndex , <str> ] = noZeroFitParamsHigh [ 2 ] db . at [ dbIndex , <str> ] = noZeroR2High allFitParamsNoZeroHigh = [ mFixed ] allFitParamsNoZeroHigh . extend ( noZeroFitParamsHigh ) testBandsNoZero = np . linspace ( bandsForFitNoZero [ 0 ] , bandsForFitNoZero [ - 1 ] , 500 ) suppIndNoZero , prefBWNoZero = fitfuncs . extract_stats_from_fit ( allFitParamsNoZeroHigh , testBandsNoZero ) db . at [ dbIndex , <str> ] = suppIndNoZero db . at [ dbIndex , <str> ] = prefBWNoZero noZeroFitParamsOnset , noZeroR2Onset = fitfuncs . diff_of_gauss_fit ( bandsForFitNoZero , noZeroOnsetResponseHighAmp , mFixed = mFixed ) db . at [ dbIndex , <str> ] = noZeroFitParamsOnset [ 0 ] db . at [ dbIndex , <str> ] = noZeroFitParamsOnset [ 3 ] db . at [ dbIndex , <str> ] = noZeroFitParamsOnset [ 4 ] db . at [ dbIndex , <str> ] = mFixed db . at [ dbIndex , <str> ] = noZeroFitParamsOnset [ 1 ] db . at [ dbIndex , <str> ] = noZeroFitParamsOnset [ 2 ] db . at [ dbIndex , <str> ] = noZeroR2Onset allFitParamsNoZeroOnset = [ mFixed ] allFitParamsNoZeroOnset . extend ( noZeroFitParamsOnset ) suppIndNoZero , prefBWNoZero = fitfuncs . extract_stats_from_fit ( allFitParamsNoZeroOnset , testBandsNoZero ) db . at [ dbIndex , <str> ] = suppIndNoZero db . at [ dbIndex , <str> ] = prefBWNoZero if sustainedSpikeArray . shape [ 1 ] > 1 :              noZeroSustainedResponseLowAmp = sustainedSpikeArray [ 1 : , 0 ] if all ( noZeroSustainedResponseLowAmp ) :                  noZeroFitParamsLow , noZeroR2Low = fitfuncs . diff_of_gauss_fit ( bandsForFitNoZero , noZeroSustainedResponseLowAmp , mFixed = mFixed ) db . at [ dbIndex , <str> ] = noZeroFitParamsLow [ 0 ] db . at [ dbIndex , <str> ] = noZeroFitParamsLow [ 3 ] db . at [ dbIndex , <str> ] = noZeroFitParamsLow [ 4 ] db . at [ dbIndex , <str> ] = mFixed db . at [ dbIndex , <str> ] = noZeroFitParamsLow [ 1 ] db . at [ dbIndex , <str> ] = noZeroFitParamsLow [ 2 ] db . at [ dbIndex , <str> ] = noZeroR2Low allFitParamsNoZeroLow = [ mFixed ] allFitParamsNoZeroLow . extend ( noZeroFitParamsLow ) suppIndNoZero , prefBWNoZero = fitfuncs . extract_stats_from_fit ( allFitParamsNoZeroLow , testBandsNoZero ) db . at [ dbIndex , <str> ] = suppIndNoZero db . at [ dbIndex , <str> ] = prefBWNoZero   bandwidthSpikeArraysHighAmp [ dbIndex , : ] = toneSustainedSpikeArray [ : , - 1 ] bandwidthSpikeArraysLowAmp [ dbIndex , : ] = toneSustainedSpikeArray [ : , 0 ] bandwidthSpikeArraysOnset [ dbIndex , : ] = noZeroOnsetResponseHighAmp db . at [ dbIndex , <str> ] = sustainedResponse [ 0 ]  db [ <str> ] = list ( bandwidthSpikeArraysOnset ) db [ <str> ] = list ( bandwidthSpikeArraysHighAmp ) db [ <str> ] = list ( bandwidthSpikeArraysLowAmp ) if len ( filename ) != 0 :          celldatabase . save_hdf ( db , filename ) print filename + <str>  return db  def photoDB_cell_locations ( db , filename = <str> ) :      import nrrd from allensdk . core . mouse_connectivity_cache import MouseConnectivityCache lapPath = <str> lapData = nrrd . read ( lapPath ) lap = lapData [ 0 ] mcc = MouseConnectivityCache ( resolution = 25 ) rsp = mcc . get_reference_space ( ) rspAnnotationVolumeRotated = np . rot90 ( rsp . annotation , 1 , axes = ( 2 , 0 ) ) tetrodetoshank = { 1 : 1 , 2 : 1 , 3 : 2 , 4 : 2 , 5 : 3 , 6 : 3 , 7 : 4 , 8 : 4 } bestCells = db [ db [ <str> ] . notnull ( ) ] db [ <str> ] = <str> for dbIndex , dbRow in bestCells . iterrows ( ) :          subject = dbRow [ <str> ] try :              fileNameInfohist = os . path . join ( settings . INFOHIST_PATH , <str> . format ( subject ) ) tracks = imp . load_source ( <str> , fileNameInfohist ) . tracks  except IOError :              print ( <str> . format ( fileNameInfohist ) )  else :              brainArea = dbRow [ <str> ] if brainArea == <str> :                  brainArea = <str>  elif brainArea == <str> :                  brainArea = <str>  tetrode = dbRow [ <str> ] shank = tetrodetoshank [ tetrode ] recordingTrack = dbRow [ <str> ] [ 0 ] track = next ( ( track for track in tracks if ( track [ <str> ] == brainArea ) and ( track [ <str> ] == shank ) and ( track [ <str> ] == recordingTrack ) ) , None ) if track is not None :                  histImage = track [ <str> ] filenameSVG = ha . get_filename_registered_svg ( subject , brainArea , histImage , recordingTrack , shank ) if tetrode % 2 == 0 :                      depth = dbRow [ <str> ]  else :                      depth = dbRow [ <str> ] - 150.0  brainSurfCoords , tipCoords , siteCoords = ha . get_coords_from_svg ( filenameSVG , [ depth ] , dbRow [ <str> ] ) siteCoords = siteCoords [ 0 ] atlasZ = track [ <str> ] cortexDepthData = np . rot90 ( lap [ : , : , atlasZ ] , - 1 ) bottomData = np . where ( cortexDepthData > 0.95 ) topData = np . where ( ( cortexDepthData < 0.02 ) & ( cortexDepthData > 0 ) ) dXTop = topData [ 1 ] - siteCoords [ 0 ] dYTop = topData [ 0 ] - siteCoords [ 1 ] distanceTop = np . sqrt ( dXTop ** 2 + dYTop ** 2 ) indMinTop = np . argmin ( distanceTop ) minDistanceTop = distanceTop . min ( ) dXBottom = bottomData [ 1 ] - siteCoords [ 0 ] dYBottom = bottomData [ 0 ] - siteCoords [ 1 ] distanceBottom = np . sqrt ( dXBottom ** 2 + dYBottom ** 2 ) minDistanceBottom = distanceBottom . min ( ) cellRatio = minDistanceTop / ( minDistanceBottom + minDistanceTop ) db . at [ dbIndex , <str> ] = cellRatio thisCoordID = rspAnnotationVolumeRotated [ int ( siteCoords [ 0 ] ) , int ( siteCoords [ 1 ] ) , atlasZ ] structDict = rsp . structure_tree . get_structures_by_id ( [ thisCoordID ] ) print <str> . format ( str ( structDict [ 0 ] [ <str> ] ) ) db . at [ dbIndex , <str> ] = structDict [ 0 ] [ <str> ]  else :                  print subject , brainArea , shank , recordingTrack    if len ( filename ) != 0 :          celldatabase . save_hdf ( db , filename ) print filename + <str>  return db   