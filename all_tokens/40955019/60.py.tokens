import os import numpy as np from matplotlib import pyplot as plt from jaratoolbox import colorpalette as cp from jaratoolbox import extraplots from jaratoolbox import settings import matplotlib . gridspec as gridspec from scipy import stats import matplotlib import figparams FIGNAME = <str> dataDir = os . path . join ( settings . FIGURES_DATA_PATH , figparams . STUDY_NAME , FIGNAME ) matplotlib . rcParams [ <str> ] = <str> matplotlib . rcParams [ <str> ] = <str> PANELS = [ 1 , 1 , 1 , 1 ] SAVE_FIGURE = 1 outputDir = <str> figFilename = <str> figFormat = <str> figSize = [ 12 , 3.5 ] fontSizeLabels = figparams . fontSizeLabels fontSizeTicks = figparams . fontSizeTicks fontSizePanel = figparams . fontSizePanel labelDis = 0.1 timeRangeSound = [ - 0.2 , 0.4 ] msRaster = 2 msMvStart = 3 smoothWinSizePsth1 = 1 smoothWinSizePsth2 = 3 lwPsth = 2 downsampleFactorPsth = 1 colormapTuning = matplotlib . cm . winter labelPosX = [ 0.015 , 0.28 , 0.52 , 0.76 ] labelPosY = [ 0.95 ] PHOTOSTIMCOLORS = { <str> : <str> , <str> : <str> , <str> : <str> } soundColor = figparams . colp [ <str> ] alphaLevel = 0.05 numFreqs = 6 bonferroniCorrectedAlphaLevel = alphaLevel / numFreqs fig = plt . gcf ( ) fig . clf ( ) fig . set_facecolor ( <str> ) summaryFilename = <str> summaryFullPath = os . path . join ( dataDir , summaryFilename ) summary = np . load ( summaryFullPath ) cellSelectorBoolArray = summary [ <str> ] bestFreqEachCell = summary [ <str> ] maxZscoreEachCell = summary [ <str> ] responseIndEachCell = summary [ <str> ] nansInData = np . isnan ( responseIndEachCell ) if np . any ( nansInData ) :      print <str> responseIndEachCell [ nansInData ] = 0  pValEachFreqEachCell = summary [ <str> ] minPValEachCell = np . amin ( pValEachFreqEachCell , axis = 1 ) sigResp = ( minPValEachCell <= bonferroniCorrectedAlphaLevel ) responseFilename = <str> responseFullPath = os . path . join ( dataDir , responseFilename ) responseEachCellEachFreq = np . load ( responseFullPath ) baselineFilename = <str> baselineFullPath = os . path . join ( dataDir , baselineFilename ) baselineEachCellEachFreq = np . load ( baselineFullPath ) numCells = sum ( cellSelectorBoolArray ) overallRespInds = np . array ( [ ] ) pVals = np . array ( [ ] ) for cellInd in range ( numCells ) :      fSound = responseEachCellEachFreq [ cellInd , : , : ] . compressed ( ) fBaseline = baselineEachCellEachFreq [ cellInd , : , : ] . compressed ( ) zScore , pVal = stats . ranksums ( fBaseline , fSound ) pVals = np . append ( pVals , pVal ) if np . mean ( fSound ) + np . mean ( fBaseline ) == 0 :          overallRespIndexThisCell = 0  else :          overallRespIndexThisCell = ( np . mean ( fSound ) - np . mean ( fBaseline ) ) / ( np . mean ( fSound ) + np . mean ( fBaseline ) )  overallRespInds = np . append ( overallRespInds , overallRespIndexThisCell )  sigRespOverall = ( pVals <= 0.05 ) nansInData = np . isnan ( overallRespInds ) if np . any ( nansInData ) :      print <str> overallRespInds [ nansInData ] = 0  numCells = sum ( cellSelectorBoolArray ) numOverallRespCells = sum ( sigRespOverall ) percentRespOverall = float ( numOverallRespCells ) / numCells * 100 print <str> . format ( numOverallRespCells , percentRespOverall ) responseFilename = <str> responseFullPath = os . path . join ( dataDir , responseFilename ) responseEachCellEachFreq = np . load ( responseFullPath ) selectivityInds = np . array ( [ ] ) pVals = np . array ( [ ] ) for cellInd in range ( numCells ) :      fLow = responseEachCellEachFreq [ cellInd , : , : 3 ] . compressed ( ) fHigh = responseEachCellEachFreq [ cellInd , : , 3 : ] . compressed ( ) zScore , pVal = stats . ranksums ( fLow , fHigh ) pVals = np . append ( pVals , pVal ) if ( np . mean ( fHigh ) + np . mean ( fLow ) ) == 0 :          selectivityIndexThisCell = 0  else :          selectivityIndexThisCell = ( np . mean ( fHigh ) - np . mean ( fLow ) ) / ( np . mean ( fHigh ) + np . mean ( fLow ) )  selectivityInds = np . append ( selectivityInds , selectivityIndexThisCell )  nansInData = np . isnan ( selectivityInds ) if np . any ( nansInData ) :      print <str> selectivityInds [ nansInData ] = 0  freqSelective = ( pVals <= 0.05 ) numFreqSelCells = sum ( freqSelective . astype ( int ) ) print 100 * float ( numFreqSelCells ) / numCells , <str> , numFreqSelCells , <str> , numCells , <str> hlFreqSelSoundResp = freqSelective & sigRespOverall hlFreqNonSelSoundResp = ~ freqSelective & sigRespOverall numHLFreqSelSoundRespCells = sum ( hlFreqSelSoundResp ) print 100 * float ( numHLFreqSelSoundRespCells ) / numOverallRespCells , <str> , numHLFreqSelSoundRespCells , <str> , numOverallRespCells , <str> ANOVAfreqSelective = summary [ <str> ] <= alphaLevel numOverallFreqSelCells = sum ( ANOVAfreqSelective ) numOverallFreqSelSoundRespCells = sum ( ANOVAfreqSelective & sigRespOverall ) print 100 * float ( numOverallFreqSelSoundRespCells ) / numOverallRespCells , <str> , numOverallFreqSelSoundRespCells , <str> , numOverallRespCells , <str> print 100 * float ( numOverallFreqSelCells ) / numCells , <str> , numOverallFreqSelCells , <str> , numCells , <str> allKruskalPVals = np . ones ( numCells ) for cellInd in range ( numCells ) :      Fstat , pVal = stats . kruskal ( * np . hsplit ( responseEachCellEachFreq [ cellInd ] , numFreqs ) ) allKruskalPVals [ cellInd ] = pVal  KruskalfreqSelective = allKruskalPVals <= alphaLevel numOverallFreqSelCellsKruskal = sum ( KruskalfreqSelective ) numOverallFreqSelSoundRespCellsKruskal = sum ( KruskalfreqSelective & sigRespOverall ) print 100 * float ( numOverallFreqSelCellsKruskal ) / numCells , <str> , numOverallFreqSelCellsKruskal , <str> , numCells , <str> print 100 * float ( numOverallFreqSelSoundRespCellsKruskal ) / numOverallRespCells , <str> , numOverallFreqSelSoundRespCellsKruskal , <str> , numOverallRespCells , <str> respEachCellEachFreqSelective = responseEachCellEachFreq [ hlFreqSelSoundResp , : , : ] respEachCellEachFreqNonSelective = responseEachCellEachFreq [ hlFreqNonSelSoundResp , : , : ] rowNum = 10 colNum = 10 numOfPlots = rowNum * colNum for cellInd in range ( respEachCellEachFreqSelective . shape [ 0 ] ) :      if ( cellInd % numOfPlots == 0 ) | ( ( cellInd % numOfPlots == 0 ) & ( cellInd >= numOfPlots ) ) :          plt . figure ( )  plt . subplot ( rowNum , colNum , cellInd % numOfPlots + 1 ) plt . bar ( range ( 6 ) , respEachCellEachFreqSelective [ cellInd ] . mean ( axis = 0 ) , width = 0.3 , yerr = ( np . zeros ( 6 ) , respEachCellEachFreqSelective [ cellInd ] . std ( axis = 0 ) ) , alpha = 0.5 , color = <str> ) plt . xticks ( range ( 6 ) , [ ] ) plt . xlim ( [ - 1 , 6 ] ) plt . yticks ( [ ] , [ ] ) plt . title ( cellInd ) plt . suptitle ( <str> ) plt . tight_layout ( )  for cellInd in range ( respEachCellEachFreqNonSelective . shape [ 0 ] ) :      if ( cellInd % numOfPlots == 0 ) | ( ( cellInd % numOfPlots == 0 ) & ( cellInd >= numOfPlots ) ) :          plt . figure ( )  plt . subplot ( rowNum , colNum , cellInd % numOfPlots + 1 ) plt . bar ( range ( 6 ) , respEachCellEachFreqNonSelective [ cellInd ] . mean ( axis = 0 ) , width = 0.3 , yerr = ( np . zeros ( 6 ) , respEachCellEachFreqNonSelective [ cellInd ] . std ( axis = 0 ) ) , alpha = 0.5 , color = <str> ) plt . xticks ( range ( 6 ) , [ ] ) plt . xlim ( [ - 1 , 6 ] ) plt . yticks ( [ ] , [ ] ) plt . title ( cellInd ) plt . suptitle ( <str> ) plt . tight_layout ( )  plt . show ( )  