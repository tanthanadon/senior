from __future__ import division import sys import numpy as np from matplotlib import pyplot as plt def gaussian ( x , mu , amp , sigma , offset ) :      return offset + amp * np . exp ( - 0.5 * ( ( x - mu ) / sigma ) ** 2 )  def findsigma ( x , y , mu , amp ) :      return ( x - mu ) / np . sqrt ( - 2 * np . log ( y / amp ) )  def gRF ( inputVec , sigma ) :      nPoints = len ( inputVec ) xVec = np . linspace ( - nPoints // 2 + 1 , nPoints // 2 , nPoints ) gaussianKernel = gaussian ( xVec , 0 , 1 , sigma , 0 ) gaussianKernel = gaussianKernel / np . sum ( gaussianKernel ) outputVec = np . convolve ( inputVec , gaussianKernel , <str> ) return outputVec , gaussianKernel  def rect ( vecsize , midpoint , bandwidth ) :      if not bandwidth % 2 :          raise ValueError ( <str> )  vec = np . zeros ( vecsize ) vec [ midpoint - bandwidth // 2 : midpoint + bandwidth // 2 + 1 ] = 1 return vec  class Network ( object ) :      def __init__ ( self , nCellsPerLayer , wParams = None , rfWidths = None ) :          self . nColumns = nCellsPerLayer self . wPV = [ ] self . wSOM = [ ] self . wThal = [ ] self . outputVec = [ ] self . activationVec = [ ] self . inputVec = [ ] if wParams is not None :              self . setThal ( wParams [ <str> ] , wParams [ <str> ] ) self . setPV ( wParams [ <str> ] , wParams [ <str> ] ) self . setSOM ( wParams [ <str> ] , wParams [ <str> ] )  if rfWidths is None :              self . rfWidthPV = None self . rfWidthSOM = None self . rfWidthThal = None self . useRFs = False  else :              self . rfWidthPV = rfWidths [ <str> ] self . rfWidthSOM = rfWidths [ <str> ] self . rfWidthThal = rfWidths [ <str> ] self . useRFs = True   def make_weights_mat ( self , stdev ) :          xVec = np . arange ( 3 * self . nColumns ) midPoint = self . nColumns + self . nColumns // 2 gaussianWeights = gaussian ( xVec , midPoint , 1 , stdev , 0 ) wMat = np . empty ( ( self . nColumns , self . nColumns ) ) for indr in range ( self . nColumns ) :              wMat [ indr , : ] = - gaussianWeights [ midPoint - indr : midPoint + self . nColumns - indr ]  return wMat  def setPV ( self , ampPV , stdPV ) :          self . wPV = - ampPV * self . make_weights_mat ( stdPV )  def setSOM ( self , ampSOM , stdSOM ) :          self . wSOM = - ampSOM * self . make_weights_mat ( stdSOM )  def setThal ( self , ampThal , stdThal ) :          self . wThal = - ampThal * self . make_weights_mat ( stdThal )  def run ( self , center , bandwidth ) :          midpoint = self . nColumns // 2 - center self . inputVec = rect ( self . nColumns , midpoint , bandwidth ) if self . useRFs :              inputThal , kThal = gRF ( self . inputVec , self . rfWidthThal ) inputPV , kPV = gRF ( self . inputVec , self . rfWidthPV ) inputSOM , kSOM = gRF ( self . inputVec , self . rfWidthSOM ) self . activationVec = np . dot ( self . wPV , inputPV ) + np . dot ( self . wSOM , inputSOM ) + np . dot ( self . wThal , inputThal )  else :              self . activationVec = np . dot ( self . wPV , self . inputVec ) + np . dot ( self . wSOM , self . inputVec ) + np . dot ( self . wThal , self . inputVec )  self . outputVec = self . activationVec * ( self . activationVec > 0 )  def run_manybw ( self , center , bandwidths ) :          midpoint = self . nColumns // 2 centerOutput = np . zeros ( len ( bandwidths ) ) for indbw , oneBW in enumerate ( bandwidths ) :              self . run ( center , oneBW ) centerOutput [ indbw ] = self . outputVec [ midpoint ]  return centerOutput  def simulate_inactivation ( self ) :          condLabels = [ <str> , <str> , <str> ] cellLabels = [ <str> , <str> ] activeCells = [ [ 1 , 1 ] , [ 0 , 1 ] , [ 1 , 0 ] ] bandwidths = np . arange ( 1 , self . nColumns , 2 ) centerCellOutput = np . empty ( ( len ( condLabels ) , len ( bandwidths ) ) ) wPVcopy = np . copy ( self . wPV ) wSOMcopy = np . copy ( self . wSOM ) for indc , cond in enumerate ( condLabels ) :              if activeCells [ indc ] [ 0 ] :                  self . wPV = wPVcopy  else :                  self . wPV = 0 * wPVcopy  if activeCells [ indc ] [ 1 ] :                  self . wSOM = wSOMcopy  else :                  self . wSOM = 0 * wSOMcopy  centerCellOutput [ indc , : ] = self . run_manybw ( 0 , bandwidths )  self . wPV = wPVcopy self . wSOM = wSOMcopy return centerCellOutput , bandwidths , condLabels  def plot_weights ( self ) :          plt . clf ( ) plt . subplot ( 1 , 3 , 1 ) plt . imshow ( self . wSOM ) plt . title ( <str> ) plt . colorbar ( ) plt . subplot ( 1 , 3 , 2 ) plt . imshow ( self . wPV ) plt . title ( <str> ) plt . colorbar ( ) plt . subplot ( 1 , 3 , 3 ) plt . imshow ( self . wThal ) plt . title ( <str> ) plt . colorbar ( )  def plot_output ( self ) :          plt . clf ( ) cellVec = np . arange ( self . nColumns ) - self . nColumns // 2 plt . subplot ( 2 , 1 , 1 ) plt . bar ( cellVec , self . inputVec , fc = <str> ) plt . ylabel ( <str> ) plt . subplot ( 2 , 1 , 2 ) plt . bar ( cellVec , self . outputVec ) plt . ylabel ( <str> )   def suppression_index ( bwtunings ) :      suppIndex = np . empty ( bwtunings . shape [ 0 ] ) for indr , bwtuning in enumerate ( bwtunings ) :          peakFiring = np . max ( bwtuning ) wnFiring = bwtuning [ - 1 ] suppIndex [ indr ] = ( peakFiring - wnFiring ) / peakFiring  return suppIndex  def change_in_response ( bwTunings ) :      peakBW = np . argmax ( bwTunings [ 0 , : ] ) changeAtPeak = np . array ( [ bwTunings [ 1 , peakBW ] - bwTunings [ 0 , peakBW ] , bwTunings [ 2 , peakBW ] - bwTunings [ 0 , peakBW ] ] ) changeAtWN = np . array ( [ bwTunings [ 1 , - 1 ] - bwTunings [ 0 , - 1 ] , bwTunings [ 2 , - 1 ] - bwTunings [ 0 , - 1 ] ] ) return changeAtPeak , changeAtWN  if __name__ == <str> :      nCells = 101 net = Network ( nCells ) plt . clf ( ) ampPV = - 20 ; stdPV = 10 ; ampSOM = - 20 ; stdSOM = 30 ; ampThal = 100 ; stdThal = 6 net . useRFs = False for CASE in [ 0 , 1 , 2 ] :          if CASE == 0 :              net . setPV ( ampPV , stdPV ) net . setSOM ( ampSOM , stdSOM ) net . setThal ( ampThal , stdThal ) plt . figure ( 1 ) net . plot_weights ( )  if CASE == 1 :              net . setPV ( 0 , stdPV ) net . setSOM ( ampSOM , stdSOM ) net . setThal ( ampThal , stdThal )  if CASE == 2 :              net . setPV ( ampPV , stdPV ) net . setSOM ( 0 , stdSOM ) net . setThal ( ampThal , stdThal )  bandwidths = np . arange ( 3 , nCells + 2 , 2 ) centerOutput = net . run_manybw ( 0 , bandwidths ) plt . figure ( 2 ) plt . plot ( bandwidths , centerOutput , <str> )  plt . legend ( [ <str> , <str> , <str> ] ) plt . show ( )   