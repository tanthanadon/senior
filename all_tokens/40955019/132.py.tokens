import os import numpy as np from collections import Counter import matplotlib . pyplot as plt import matplotlib . gridspec as gridspec from jaratoolbox import settings from jaratoolbox import extraplots from jaratoolbox import colorpalette from jaratoolbox import spikesanalysis from jaratoolbox import ephyscore from jaratoolbox import celldatabase from scipy import stats import copy import pandas as pd import figparams reload ( figparams ) STUDY_NAME = <str> SAVE = False dbPath = <str> dataframe = celldatabase . load_hdf ( dbPath ) for indIter , ( indRow , dbRow ) in enumerate ( dataframe . iterrows ( ) ) :      cell = ephyscore . Cell ( dbRow , useModifiedClusters = True ) try :          pulseData , _ = cell . load ( <str> )  except ( IndexError , ValueError ) :          print <str> try :              pulseData , _ = cell . load ( <str> )  except ( IndexError , ValueError ) :              print <str> dataframe . loc [ indRow , <str> ] = 0 continue   try :          trainData , _ = cell . load ( <str> )  except ( IndexError , ValueError ) :          print <str> dataframe . loc [ indRow , <str> ] = 0 continue  spikeTimes = pulseData [ <str> ] eventOnsetTimes = pulseData [ <str> ] [ <str> ] baseRange = [ - 0.050 , - 0.04 ] binTime = baseRange [ 1 ] - baseRange [ 0 ] responseRange = [ 0 , 0 + binTime ] alignmentRange = [ baseRange [ 0 ] , responseRange [ 1 ] ] ( spikeTimesFromEventOnset , trialIndexForEachSpike , indexLimitsEachTrial ) = spikesanalysis . eventlocked_spiketimes ( spikeTimes , eventOnsetTimes , alignmentRange ) nspkBase = spikesanalysis . spiketimes_to_spikecounts ( spikeTimesFromEventOnset , indexLimitsEachTrial , baseRange ) nspkResp = spikesanalysis . spiketimes_to_spikecounts ( spikeTimesFromEventOnset , indexLimitsEachTrial , responseRange ) try :          zStat , pVal = stats . mannwhitneyu ( nspkResp , nspkBase )  except ValueError :          zStat , pVal = [ 0 , 1 ]  if ( pVal < 0.05 ) and ( nspkResp . ravel ( ) . mean ( ) > nspkBase . ravel ( ) . mean ( ) ) :          passPulse = True  else :          passPulse = False  spikeTimes = trainData [ <str> ] trainPulseOnsetTimes = trainData [ <str> ] [ <str> ] eventOnsetTimes = spikesanalysis . minimum_event_onset_diff ( trainPulseOnsetTimes , 0.5 ) baseRange = [ - 0.050 , - 0.04 ] pulseTimes = [ 0 , 0.2 , 0.4 , 0.6 , 0.8 ] binTime = baseRange [ 1 ] - baseRange [ 0 ] alignmentRange = [ baseRange [ 0 ] , pulseTimes [ - 1 ] + binTime ] ( spikeTimesFromEventOnset , trialIndexForEachSpike , indexLimitsEachTrial ) = spikesanalysis . eventlocked_spiketimes ( spikeTimes , eventOnsetTimes , alignmentRange ) nspkBase = spikesanalysis . spiketimes_to_spikecounts ( spikeTimesFromEventOnset , indexLimitsEachTrial , baseRange ) zStats = np . empty ( len ( pulseTimes ) ) pVals = np . empty ( len ( pulseTimes ) ) respSpikeMean = np . empty ( len ( pulseTimes ) ) for indPulse , pulse in enumerate ( pulseTimes ) :          responseRange = [ pulse , pulse + binTime ] nspkResp = spikesanalysis . spiketimes_to_spikecounts ( spikeTimesFromEventOnset , indexLimitsEachTrial , responseRange ) respSpikeMean [ indPulse ] = nspkResp . ravel ( ) . mean ( ) try :              zStats [ indPulse ] , pVals [ indPulse ] = stats . mannwhitneyu ( nspkResp , nspkBase )  except ValueError :              zStats [ indPulse ] , pVals [ indPulse ] = [ 0 , 1 ]   numSignificant = sum ( pVals < 0.05 ) dataframe . loc [ indRow , <str> ] = numSignificant if ( pVals [ 0 ] < 0.05 ) and ( sum ( pVals [ 1 : ] < 0.05 ) >= 3 ) and ( all ( respSpikeMean > nspkBase . ravel ( ) . mean ( ) ) ) :          passTrain = True  else :          passTrain = False  if passPulse and passTrain :          print <str> dataframe . loc [ indRow , <str> ] = 1  else :          print <str> dataframe . loc [ indRow , <str> ] = 0   if SAVE :      dataframe . to_hdf ( dbPath , <str> ) print <str> . format ( dbPath )   