import os import numpy as np from collections import Counter import matplotlib . pyplot as plt import matplotlib . gridspec as gridspec from jaratoolbox import settings from jaratoolbox import extraplots from jaratoolbox import colorpalette from scipy import stats import copy import pandas as pd import figparams reload ( figparams ) np . random . seed ( 0 ) selectUntagged = True invertUntaggedSelection = True FIGNAME = <str> SAVE_FIGURE = 1 outputDir = figparams . FIGURE_OUTPUT_DIR figFilename = <str> figFormat = <str> figSize = [ 12 , 8 ] labelPosX = [ 0.04 , 0.48 ] labelPosY = [ 0.48 , 0.95 ] dbPath = os . path . join ( settings . FIGURES_DATA_PATH , figparams . STUDY_NAME , <str> ) dbase = pd . read_hdf ( dbPath , key = <str> ) thalColor = colorpalette . TangoPalette [ <str> ] acColor = colorpalette . TangoPalette [ <str> ] fig = plt . gcf ( ) plt . clf ( ) fig . set_facecolor ( <str> ) goodFit = dbase . query ( <str> ) goodFit [ <str> ] = np . sqrt ( goodFit [ <str> ] * goodFit [ <str> ] ) goodFitToUse = goodFit . query ( <str> ) def jitter ( arr , frac ) :      jitter = ( np . random . random ( len ( arr ) ) - 0.5 ) * 2 * frac jitteredArr = arr + jitter return jitteredArr  def medline ( yval , midline , width , color = <str> , linewidth = 3 ) :      start = midline - ( width / 2 ) end = midline + ( width / 2 ) plt . plot ( [ start , end ] , [ yval , yval ] , color = color , lw = linewidth )  def plot_hist ( ax , dataArr , color , label ) :      lowFreq = 4 highFreq = 128 nFreqs = 11 freqs = np . logspace ( np . log10 ( lowFreq ) , np . log10 ( highFreq ) , nFreqs ) freqs = np . round ( freqs , decimals = 1 ) freqs = np . r_ [ 0 , freqs ] freqLabels = [ <str> . format ( freq ) for freq in freqs [ 1 : ] ] freqLabels = [ <str> , <str> ] + freqLabels roundData = np . round ( dataArr [ pd . notnull ( dataArr ) ] , decimals = 1 ) counts = Counter ( roundData ) freqsToPlot = np . r_ [ 0 , 1 , freqs [ 1 : ] ] index = np . arange ( len ( freqsToPlot ) ) heights = [ ] for freq in freqsToPlot :          try :              heights . append ( 100 * counts [ freq ] / np . double ( len ( roundData ) ) )  except KeyError :              heights . append ( 0 )   barWidth = 0.8 rects = plt . bar ( index + 0.5 * barWidth , heights , barWidth , label = label , color = color ) plt . xticks ( index + barWidth , freqs ) ax . set_xticklabels ( freqLabels , rotation = <str> ) plt . ylabel ( <str> ) extraplots . boxoff ( ax ) height = max ( heights ) * 0.05 extraplots . breakaxis ( 1.8 , 0 , 0.3 , height , gap = 0.4 ) ax . tick_params ( axis = <str> , length = 0 ) plt . ylim ( [ 0 , max ( heights ) + 1 ] ) labelText = <str> . format ( label , len ( roundData ) ) ax . annotate ( labelText , xy = ( 0.1 , 0.9 ) , xycoords = <str> , fontsize = 9 , fontweight = <str> ) return rects  plt . clf ( ) gs = gridspec . GridSpec ( 2 , 3 ) gs . update ( left = 0.12 , right = 0.98 , top = 0.88 , bottom = 0.15 , wspace = 0.52 , hspace = 1 ) features = [ <str> , <str> , <str> ] yLabels = [ <str> , <str> , <str> ] dataframe = goodFitToUse . query ( <str> ) taggedBool = ( dataframe [ <str> ] < 0.05 ) & ( dataframe [ <str> ] > 0.8 ) taggedCells = dataframe [ taggedBool ] untaggedCells = dataframe [ ~ taggedBool ] if selectUntagged :      if len ( untaggedCells ) > 0 :          sameShankAs = { 1 : 2 , 2 : 1 , 3 : 4 , 4 : 3 , 5 : 6 , 6 : 5 , 7 : 8 , 8 : 7 } untaggedCellsSSA = copy . deepcopy ( untaggedCells ) newTetrode = [ sameShankAs [ tt ] for tt in untaggedCellsSSA [ <str> ] ] untaggedCellsSSA [ <str> ] = newTetrode for indRow , row in untaggedCells . iterrows ( ) :              idString = <str> . format ( row [ <str> ] , row [ <str> ] , row [ <str> ] , row [ <str> ] ) untaggedCells . loc [ indRow , <str> ] = idString print untaggedCells . loc [ indRow , <str> ]  for indRow , row in taggedCells . iterrows ( ) :              idString = <str> . format ( row [ <str> ] , row [ <str> ] , row [ <str> ] , row [ <str> ] ) taggedCells . loc [ indRow , <str> ] = idString  for indRow , row in untaggedCellsSSA . iterrows ( ) :              idString = <str> . format ( row [ <str> ] , row [ <str> ] , row [ <str> ] , row [ <str> ] ) untaggedCellsSSA . loc [ indRow , <str> ] = idString  untaggedBool = ( untaggedCells [ <str> ] . isin ( taggedCells [ <str> ] ) | untaggedCellsSSA [ <str> ] . isin ( taggedCells [ <str> ] ) ) if not invertUntaggedSelection :              untaggedCells = untaggedCells [ untaggedBool ]  elif invertUntaggedSelection :              untaggedCells = untaggedCells [ ~ untaggedBool ]    rowX = 0 for indFeature , feature in enumerate ( features ) :      dataTagged = taggedCells [ feature ] [ pd . notnull ( taggedCells [ feature ] ) ] dataUntagged = untaggedCells [ feature ] [ pd . notnull ( untaggedCells [ feature ] ) ] ax = plt . subplot ( gs [ rowX , indFeature ] ) posTagged = jitter ( np . ones ( len ( dataTagged ) ) * 0 , 0.20 ) posUntagged = jitter ( np . ones ( len ( dataUntagged ) ) * 1 , 0.20 ) ax . plot ( posTagged , dataTagged , <str> , mec = <str> , mfc = <str> ) medline ( np . median ( dataTagged ) , 0 , 0.5 ) ax . plot ( posUntagged , dataUntagged , <str> , mec = <str> , mfc = <str> ) medline ( np . median ( dataUntagged ) , 1 , 0.5 ) ax . set_xticks ( [ 0 , 1 ] ) ax . set_xticklabels ( [ <str> . format ( len ( dataTagged ) ) , <str> . format ( len ( dataUntagged ) ) ] ) ax . set_ylabel ( yLabels [ indFeature ] ) extraplots . boxoff ( ax ) if indFeature == 1 :          ax . set_ylim ( [ 12 , 62 ] )  elif indFeature == 2 :          ax . set_ylim ( [ 0 , 0.06 ] )  zVal , pVal = stats . mannwhitneyu ( dataTagged , dataUntagged ) plt . title ( <str> . format ( pVal ) )  dataframe = goodFitToUse . query ( <str> ) taggedBool = ( dataframe [ <str> ] < 0.05 ) & ( dataframe [ <str> ] > 0.8 ) taggedCells = dataframe [ taggedBool ] untaggedCells = dataframe [ ~ taggedBool ] if selectUntagged :      if len ( untaggedCells ) > 0 :          sameShankAs = { 1 : 2 , 2 : 1 , 3 : 4 , 4 : 3 , 5 : 6 , 6 : 5 , 7 : 8 , 8 : 7 } untaggedCellsSSA = copy . deepcopy ( untaggedCells ) newTetrode = [ sameShankAs [ tt ] for tt in untaggedCellsSSA [ <str> ] ] untaggedCellsSSA [ <str> ] = newTetrode for indRow , row in untaggedCells . iterrows ( ) :              idString = <str> . format ( row [ <str> ] , row [ <str> ] , row [ <str> ] , row [ <str> ] ) untaggedCells . loc [ indRow , <str> ] = idString  for indRow , row in taggedCells . iterrows ( ) :              idString = <str> . format ( row [ <str> ] , row [ <str> ] , row [ <str> ] , row [ <str> ] ) taggedCells . loc [ indRow , <str> ] = idString  for indRow , row in untaggedCellsSSA . iterrows ( ) :              idString = <str> . format ( row [ <str> ] , row [ <str> ] , row [ <str> ] , row [ <str> ] ) untaggedCellsSSA . loc [ indRow , <str> ] = idString  untaggedBool = ( untaggedCells [ <str> ] . isin ( taggedCells [ <str> ] ) | untaggedCellsSSA [ <str> ] . isin ( taggedCells [ <str> ] ) ) if not invertUntaggedSelection :              untaggedCells = untaggedCells [ untaggedBool ]  elif invertUntaggedSelection :              untaggedCells = untaggedCells [ ~ untaggedBool ]    rowX = 1 for indFeature , feature in enumerate ( features ) :      dataTagged = taggedCells [ feature ] [ pd . notnull ( taggedCells [ feature ] ) ] dataUntagged = untaggedCells [ feature ] [ pd . notnull ( untaggedCells [ feature ] ) ] ax = plt . subplot ( gs [ rowX , indFeature ] ) posTagged = jitter ( np . ones ( len ( dataTagged ) ) * 0 , 0.20 ) posUntagged = jitter ( np . ones ( len ( dataUntagged ) ) * 1 , 0.20 ) ax . plot ( posTagged , dataTagged , <str> , mec = <str> , mfc = <str> ) medline ( np . median ( dataTagged ) , 0 , 0.5 ) ax . plot ( posUntagged , dataUntagged , <str> , mec = <str> , mfc = <str> ) medline ( np . median ( dataUntagged ) , 1 , 0.5 ) ax . set_xticks ( [ 0 , 1 ] ) ax . set_xticklabels ( [ <str> . format ( len ( dataTagged ) ) , <str> . format ( len ( dataUntagged ) ) ] ) ax . set_ylabel ( yLabels [ indFeature ] ) extraplots . boxoff ( ax ) if indFeature == 1 :          ax . set_ylim ( [ 12 , 62 ] )  elif indFeature == 2 :          ax . set_ylim ( [ 0 , 0.06 ] )  zVal , pVal = stats . mannwhitneyu ( dataTagged , dataUntagged ) plt . title ( <str> . format ( pVal ) )  ax . annotate ( <str> , xy = ( 0.04 , 0.875 ) , xycoords = <str> , fontsize = 14 , fontweight = <str> , color = thalColor ) ax . annotate ( <str> , xy = ( 0.04 , 0.45 ) , xycoords = <str> , fontsize = 14 , fontweight = <str> , color = acColor ) labelPosX = [ 0.04 , 0.4 , 0.7 ] labelPosY = [ 0.49 , 0.92 ] fontSizePanel = figparams . fontSizePanel ax . annotate ( <str> , xy = ( labelPosX [ 0 ] , labelPosY [ 1 ] ) , xycoords = <str> , fontsize = fontSizePanel , fontweight = <str> ) ax . annotate ( <str> , xy = ( labelPosX [ 1 ] , labelPosY [ 1 ] ) , xycoords = <str> , fontsize = fontSizePanel , fontweight = <str> ) ax . annotate ( <str> , xy = ( labelPosX [ 2 ] , labelPosY [ 1 ] ) , xycoords = <str> , fontsize = fontSizePanel , fontweight = <str> ) ax . annotate ( <str> , xy = ( labelPosX [ 0 ] , labelPosY [ 0 ] ) , xycoords = <str> , fontsize = fontSizePanel , fontweight = <str> ) ax . annotate ( <str> , xy = ( labelPosX [ 1 ] , labelPosY [ 0 ] ) , xycoords = <str> , fontsize = fontSizePanel , fontweight = <str> ) ax . annotate ( <str> , xy = ( labelPosX [ 2 ] , labelPosY [ 0 ] ) , xycoords = <str> , fontsize = fontSizePanel , fontweight = <str> ) plt . show ( ) if SAVE_FIGURE :      extraplots . save_figure ( figFilename , figFormat , figSize , outputDir )   