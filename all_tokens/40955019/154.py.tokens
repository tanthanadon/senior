import sys import os import pandas as pd import numpy as np import matplotlib . pyplot as plt from jaratoolbox import celldatabase from jaratoolbox import ephyscore from jaratoolbox import spikesanalysis reload ( spikesanalysis ) from jaratoolbox import behavioranalysis from jaratoolbox import settings import figparams threshold = 0.2 dbPath = os . path . join ( settings . FIGURES_DATA_PATH , figparams . STUDY_NAME , <str> ) dbase = pd . read_hdf ( dbPath , key = <str> ) goodLaser = dbase . query ( <str> ) goodStriatum = dbase . groupby ( <str> ) . get_group ( <str> ) . query ( <str> ) goodLaserPlusStriatum = goodLaser . append ( goodStriatum , ignore_index = True ) goodFit = goodLaserPlusStriatum . query ( <str> ) goodFit [ <str> ] = np . sqrt ( goodFit [ <str> ] * goodFit [ <str> ] ) goodFitToUse = goodFit . query ( <str> ) acCells = goodFitToUse . groupby ( <str> ) . get_group ( <str> ) dataframe = acCells cellDict = { <str> : <str> , <str> : <str> , <str> : 1143 , <str> : 2 , <str> : 4 } for indRow , dbRow in dataframe . iterrows ( ) :      cell = ephyscore . Cell ( dbRow ) try :          ephysData , bdata = cell . load ( <str> )  except ( IndexError , ValueError ) :          print <str> . format ( indRow ) sys . exit ( )  eventOnsetTimes = ephysData [ <str> ] [ <str> ] eventOnsetTimes = spikesanalysis . minimum_event_onset_diff ( eventOnsetTimes , minEventOnsetDiff = 0.2 ) spikeTimes = ephysData [ <str> ] freqEachTrial = bdata [ <str> ] possibleFreq = np . unique ( freqEachTrial ) intensityEachTrial = bdata [ <str> ] possibleIntensity = np . unique ( intensityEachTrial ) if len ( eventOnsetTimes ) == len ( freqEachTrial ) + 1 :          eventOnsetTimes = eventOnsetTimes [ : - 1 ]  elif len ( eventOnsetTimes ) < len ( freqEachTrial ) :          print <str> dataframe . loc [ indRow , <str> ] = np . nan continue  trialsEachCondition = behavioranalysis . find_trials_each_combination ( intensityEachTrial , possibleIntensity , freqEachTrial , possibleFreq ) baseRange = [ - 0.1 , 0 ] responseRange = [ 0 , 0.1 ] alignmentRange = [ - 0.2 , 0.2 ] ( spikeTimesFromEventOnset , trialIndexForEachSpike , indexLimitsEachTrial ) = spikesanalysis . eventlocked_spiketimes ( spikeTimes , eventOnsetTimes , alignmentRange ) nspkBase = spikesanalysis . spiketimes_to_spikecounts ( spikeTimesFromEventOnset , indexLimitsEachTrial , baseRange ) nspkResp = spikesanalysis . spiketimes_to_spikecounts ( spikeTimesFromEventOnset , indexLimitsEachTrial , responseRange ) conditionMatShape = np . shape ( trialsEachCondition ) numRepeats = np . product ( conditionMatShape [ 1 : ] ) nSpikesMat = np . reshape ( nspkResp . squeeze ( ) . repeat ( numRepeats ) , conditionMatShape ) spikesFilteredByTrialType = nSpikesMat * trialsEachCondition avgRespArray = np . sum ( spikesFilteredByTrialType , 0 ) / np . sum ( trialsEachCondition , 0 ) . astype ( <str> ) thresholdResponse = nspkBase . mean ( ) + threshold * ( avgRespArray . max ( ) - nspkBase . mean ( ) ) if not np . any ( avgRespArray > thresholdResponse ) :          print <str> sys . exit ( )  fra = avgRespArray > thresholdResponse selectedTrials = np . any ( trialsEachCondition [ : , fra ] , axis = 1 ) indexLimitsSelectedTrials = indexLimitsEachTrial [ : , selectedTrials ] timeRangeForLatency = [ - 0.1 , 0.2 ] ( respLatency , interim ) = spikesanalysis . response_latency ( spikeTimesFromEventOnset , indexLimitsSelectedTrials , timeRangeForLatency , threshold = 0.5 ) print <str> . format ( 1e3 * respLatency ) selectedTrialsInds = np . flatnonzero ( selectedTrials ) selectedSpikesInds = np . in1d ( trialIndexForEachSpike , selectedTrialsInds ) tempTIFES = trialIndexForEachSpike [ selectedSpikesInds ] newSpikeTimes = spikeTimesFromEventOnset [ selectedSpikesInds ] newTrialInds = np . empty ( tempTIFES . shape , dtype = int ) for ind , trialInd in enumerate ( np . unique ( tempTIFES ) ) :          newTrialInds [ tempTIFES == trialInd ] = ind  plt . clf ( ) plt . title ( respLatency ) plt . subplot ( 2 , 1 , 1 ) plt . plot ( newSpikeTimes , newTrialInds , <str> ) plt . xlim ( timeRangeForLatency ) plt . hold ( 1 ) plt . title ( <str> . format ( indRow ) ) plt . axvline ( respLatency , color = <str> ) plt . subplot ( 2 , 1 , 2 ) plt . plot ( interim [ <str> ] , interim [ <str> ] , <str> ) plt . hold ( 1 ) plt . axvline ( respLatency , color = <str> ) plt . axhline ( interim [ <str> ] , ls = <str> , color = <str> ) plt . axhline ( interim [ <str> ] , ls = <str> , color = <str> ) plt . axhline ( interim [ <str> ] , ls = <str> , color = <str> ) plt . plot ( interim [ <str> ] , interim [ <str> ] , <str> , mec = <str> , lw = 3 ) plt . xlim ( timeRangeForLatency ) plt . show ( ) plt . waitforbuttonpress ( )   