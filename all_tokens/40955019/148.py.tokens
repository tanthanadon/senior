import os import numpy as np from matplotlib import pyplot as plt from matplotlib import gridspec from jaratoolbox import celldatabase from jaratoolbox import spikesanalysis from jaratoolbox import spikesorting from jaratoolbox import ephyscore from jaratoolbox import extraplots from jaratoolbox import colorpalette as cp from jaratoolbox import settings from scipy import stats STUDY_NAME = <str> SAVE = 1 inforecPath = <str> dbPath = os . path . join ( settings . FIGURES_DATA_PATH , STUDY_NAME , <str> ) dataframe = celldatabase . generate_cell_database ( inforecPath ) dataframe [ <str> ] = 0 dataframe [ <str> ] = dataframe [ <str> ] . astype ( int ) dataframe [ <str> ] = 0 dataframe [ <str> ] = 0 for indIter , ( indRow , dbRow ) in enumerate ( dataframe . iterrows ( ) ) :      cell = ephyscore . Cell ( dbRow ) try :          pulseData , _ = cell . load ( <str> )  except ( IndexError , ValueError ) :          print <str> try :              pulseData , _ = cell . load ( <str> )  except ( IndexError , ValueError ) :              print <str> dataframe . loc [ indRow , <str> ] = 0 continue   try :          trainData , _ = cell . load ( <str> )  except ( IndexError , ValueError ) :          print <str> dataframe . loc [ indRow , <str> ] = 0 continue  spikeTimes = pulseData [ <str> ] eventOnsetTimes = pulseData [ <str> ] [ <str> ] baseRange = [ - 0.050 , - 0.04 ] binTime = baseRange [ 1 ] - baseRange [ 0 ] responseRange = [ 0 , 0 + binTime ] alignmentRange = [ baseRange [ 0 ] , responseRange [ 1 ] ] ( spikeTimesFromEventOnset , trialIndexForEachSpike , indexLimitsEachTrial ) = spikesanalysis . eventlocked_spiketimes ( spikeTimes , eventOnsetTimes , alignmentRange ) nspkBase = spikesanalysis . spiketimes_to_spikecounts ( spikeTimesFromEventOnset , indexLimitsEachTrial , baseRange ) nspkResp = spikesanalysis . spiketimes_to_spikecounts ( spikeTimesFromEventOnset , indexLimitsEachTrial , responseRange ) try :          zStat , pVal = stats . mannwhitneyu ( nspkResp , nspkBase )  except ValueError :          zStat , pVal = [ 0 , 1 ]  if ( pVal < 0.05 ) and ( nspkResp . ravel ( ) . mean ( ) > nspkBase . ravel ( ) . mean ( ) ) :          passPulse = True  else :          passPulse = False  spikeTimes = trainData [ <str> ] trainPulseOnsetTimes = trainData [ <str> ] [ <str> ] eventOnsetTimes = spikesanalysis . minimum_event_onset_diff ( trainPulseOnsetTimes , 0.5 ) baseRange = [ - 0.050 , - 0.04 ] pulseTimes = [ 0 , 0.2 , 0.4 , 0.6 , 0.8 ] baseRange = [ - 0.05 , - 0.03 ] binTime = baseRange [ 1 ] - baseRange [ 0 ] alignmentRange = [ baseRange [ 0 ] , pulseTimes [ - 1 ] + binTime ] ( spikeTimesFromEventOnset , trialIndexForEachSpike , indexLimitsEachTrial ) = spikesanalysis . eventlocked_spiketimes ( spikeTimes , eventOnsetTimes , alignmentRange ) nspkBase = spikesanalysis . spiketimes_to_spikecounts ( spikeTimesFromEventOnset , indexLimitsEachTrial , baseRange ) zStats = np . empty ( len ( pulseTimes ) ) pVals = np . empty ( len ( pulseTimes ) ) respSpikeMean = np . empty ( len ( pulseTimes ) ) for indPulse , pulse in enumerate ( pulseTimes ) :          responseRange = [ pulse , pulse + binTime ] nspkResp = spikesanalysis . spiketimes_to_spikecounts ( spikeTimesFromEventOnset , indexLimitsEachTrial , responseRange ) respSpikeMean [ indPulse ] = nspkResp . ravel ( ) . mean ( ) try :              zStats [ indPulse ] , pVals [ indPulse ] = stats . mannwhitneyu ( nspkResp , nspkBase )  except ValueError :              zStats [ indPulse ] , pVals [ indPulse ] = [ 0 , 1 ]   if ( pVals [ 0 ] < 0.05 ) and ( sum ( pVals [ 1 : ] < 0.05 ) >= 3 ) and ( all ( respSpikeMean > nspkBase . ravel ( ) . mean ( ) ) ) :          passTrain = True  else :          passTrain = False  if passPulse and passTrain :          print <str> dataframe . loc [ indRow , <str> ] = 1  else :          print <str> dataframe . loc [ indRow , <str> ] = 0  try :          pulseData , _ = cell . load ( <str> )  except ( IndexError , ValueError ) :          print <str> try :              pulseData , _ = cell . load ( <str> )  except ( IndexError , ValueError ) :              print <str> continue   try :          trainData , _ = cell . load ( <str> )  except ( IndexError , ValueError ) :          print <str> continue  spikeTimes = pulseData [ <str> ] eventOnsetTimes = pulseData [ <str> ] [ <str> ] baseRange = [ - 0.050 , - 0.04 ] binTime = baseRange [ 1 ] - baseRange [ 0 ] responseRange = [ 0 , 0 + binTime ] alignmentRange = [ baseRange [ 0 ] , responseRange [ 1 ] ] ( spikeTimesFromEventOnset , trialIndexForEachSpike , indexLimitsEachTrial ) = spikesanalysis . eventlocked_spiketimes ( spikeTimes , eventOnsetTimes , alignmentRange ) nspkBase = spikesanalysis . spiketimes_to_spikecounts ( spikeTimesFromEventOnset , indexLimitsEachTrial , baseRange ) nspkResp = spikesanalysis . spiketimes_to_spikecounts ( spikeTimesFromEventOnset , indexLimitsEachTrial , responseRange ) try :          zStat , pVal = stats . mannwhitneyu ( nspkResp , nspkBase )  except ValueError :          zStat , pVal = [ 0 , 1 ]  if ( pVal < 0.05 ) and ( nspkResp . ravel ( ) . mean ( ) > nspkBase . ravel ( ) . mean ( ) ) :          passPulse = True  else :          passPulse = False  spikeTimes = trainData [ <str> ] trainPulseOnsetTimes = trainData [ <str> ] [ <str> ] eventOnsetTimes = spikesanalysis . minimum_event_onset_diff ( trainPulseOnsetTimes , 0.5 ) baseRange = [ - 0.050 , - 0.04 ] pulseTimes = [ 0 , 0.2 , 0.4 , 0.6 , 0.8 ] baseRange = [ - 0.05 , - 0.03 ] binTime = baseRange [ 1 ] - baseRange [ 0 ] alignmentRange = [ baseRange [ 0 ] , pulseTimes [ - 1 ] + binTime ] ( spikeTimesFromEventOnset , trialIndexForEachSpike , indexLimitsEachTrial ) = spikesanalysis . eventlocked_spiketimes ( spikeTimes , eventOnsetTimes , alignmentRange ) nspkBase = spikesanalysis . spiketimes_to_spikecounts ( spikeTimesFromEventOnset , indexLimitsEachTrial , baseRange ) zStats = np . empty ( len ( pulseTimes ) ) pVals = np . empty ( len ( pulseTimes ) ) respSpikeMean = np . empty ( len ( pulseTimes ) ) for indPulse , pulse in enumerate ( pulseTimes ) :          responseRange = [ pulse , pulse + binTime ] nspkResp = spikesanalysis . spiketimes_to_spikecounts ( spikeTimesFromEventOnset , indexLimitsEachTrial , responseRange ) respSpikeMean [ indPulse ] = nspkResp . ravel ( ) . mean ( ) try :              zStats [ indPulse ] , pVals [ indPulse ] = stats . mannwhitneyu ( nspkResp , nspkBase )  except ValueError :              zStats [ indPulse ] , pVals [ indPulse ] = [ 0 , 1 ]   if ( pVals [ 0 ] < 0.05 ) and ( sum ( pVals [ 1 : ] < 0.05 ) >= 3 ) and ( all ( respSpikeMean > nspkBase . ravel ( ) . mean ( ) ) ) :          passTrain = True  else :          passTrain = False  if passPulse and passTrain :          print <str> dataframe . loc [ indRow , <str> ] = 1  else :          print <str> dataframe . loc [ indRow , <str> ] = 0  try :          ephysData , _ = cell . load ( <str> )  except ( IndexError , ValueError ) :          continue  spikeTimes = ephysData [ <str> ] eventOnsetTimes = ephysData [ <str> ] [ <str> ] eventOnsetTimes = spikesanalysis . minimum_event_onset_diff ( eventOnsetTimes , 0.5 ) baseRange = [ - 0.5 , - 0.4 ] alignmentRange = [ - 0.5 , 1.0 ] responseRange = [ 0 , 0.1 ] ( spikeTimesFromEventOnset , trialIndexForEachSpike , indexLimitsEachTrial ) = spikesanalysis . eventlocked_spiketimes ( spikeTimes , eventOnsetTimes , alignmentRange ) nspkBase = spikesanalysis . spiketimes_to_spikecounts ( spikeTimesFromEventOnset , indexLimitsEachTrial , baseRange ) nspkResp = spikesanalysis . spiketimes_to_spikecounts ( spikeTimesFromEventOnset , indexLimitsEachTrial , responseRange ) try :          zStat , pVal = stats . mannwhitneyu ( nspkResp , nspkBase )  except ValueError :          zStat , pVal = [ 0 , 1 ]  if pVal < 0.05 :          dataframe . loc [ indRow , <str> ] = 1   if SAVE :      print <str> . format ( dbPath ) celldatabase . save_hdf ( dataframe , dbPath )  nbqxTagged = dataframe . query ( <str> ) nbqxUntagged = dataframe . query ( <str> ) nonNbqxTagged = dataframe . query ( <str> ) nonNbqxUntagged = dataframe . query ( <str> )  