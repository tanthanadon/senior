import numpy as np from jaratoolbox import celldatabase from jaratoolbox import ephyscore from jaratoolbox import spikesanalysis import pandas as pd import figparams import matplotlib . pyplot as plt from scipy import stats PLOT = 1 SAVE = 1 dbPath = <str> database = celldatabase . load_hdf ( dbPath ) plt . clf ( ) ax0 = plt . subplot ( 111 ) mono = [ ] maxSpikes = [ ] dbToUse = database for indIter , ( indRow , dbRow ) in enumerate ( dbToUse . iterrows ( ) ) :      print indRow failed = False cell = ephyscore . Cell ( dbRow , useModifiedClusters = True ) try :          ephysData , bdata = cell . load ( <str> )  except ( IndexError , ValueError ) :          failed = True print <str> . format ( indRow )  eventOnsetTimes = ephysData [ <str> ] [ <str> ] spikeTimes = ephysData [ <str> ] freqEachTrial = bdata [ <str> ] if len ( eventOnsetTimes ) != len ( freqEachTrial ) :          eventOnsetTimes = eventOnsetTimes [ : - 1 ] if len ( eventOnsetTimes ) != len ( freqEachTrial ) :              continue   possibleFreq = np . unique ( freqEachTrial ) intensityEachTrial = bdata [ <str> ] possibleIntensity = np . unique ( intensityEachTrial ) cfTrials = freqEachTrial == dbRow [ <str> ] eventsThisFreq = eventOnsetTimes [ cfTrials ] intenThisFreq = intensityEachTrial [ cfTrials ] baseRange = [ - 0.1 , 0 ] responseRange = [ 0 , 0.1 ] alignmentRange = [ baseRange [ 0 ] , responseRange [ 1 ] ] meanSpikesAllInten = np . empty ( len ( possibleIntensity ) ) maxSpikesAllInten = np . empty ( len ( possibleIntensity ) ) baseSpikesAllInten = np . empty ( len ( possibleIntensity ) ) for indInten , inten in enumerate ( possibleIntensity ) :          trialsThisIntensity = intenThisFreq == inten eventsThisCombo = eventsThisFreq [ trialsThisIntensity ] ( spikeTimesFromEventOnset , trialIndexForEachSpike , indexLimitsEachTrial ) = spikesanalysis . eventlocked_spiketimes ( spikeTimes , eventsThisCombo , alignmentRange ) nspkBase = spikesanalysis . spiketimes_to_spikecounts ( spikeTimesFromEventOnset , indexLimitsEachTrial , baseRange ) nspkResp = spikesanalysis . spiketimes_to_spikecounts ( spikeTimesFromEventOnset , indexLimitsEachTrial , responseRange ) spikesThisInten = nspkResp [ : , 0 ] baselineThisInten = nspkBase [ : , 0 ] try :              meanSpikesThisInten = np . mean ( spikesThisInten ) meanBaselineSpikesThisInten = np . mean ( baselineThisInten ) maxSpikesThisInten = np . max ( spikesThisInten )  except ValueError :              meanSpikesThisInten = 0 maxSpikesThisInten = 0  meanSpikesAllInten [ indInten ] = meanSpikesThisInten maxSpikesAllInten [ indInten ] = maxSpikesThisInten baseSpikesAllInten [ indInten ] = meanBaselineSpikesThisInten  baseline = np . mean ( baseSpikesAllInten ) monoIndex = ( meanSpikesAllInten [ - 1 ] - baseline ) / ( np . max ( meanSpikesAllInten ) - baseline ) dbToUse . loc [ indRow , <str> ] = monoIndex overallMaxSpikes = np . max ( maxSpikesAllInten ) maxSpikes . append ( overallMaxSpikes )  if SAVE :      celldatabase . save_hdf ( database , dbPath )  if PLOT :      def jitter ( arr , frac ) :          jitter = ( np . random . random ( len ( arr ) ) - 0.5 ) * 2 * frac jitteredArr = arr + jitter return jitteredArr  plt . clf ( ) ax = plt . subplot ( 111 ) colorATh = <str> colorAC = <str> ac = dbToUse . groupby ( <str> ) . get_group ( <str> ) thal = dbToUse . groupby ( <str> ) . get_group ( <str> ) popStatCol = <str> acPopStat = ac [ popStatCol ] [ pd . notnull ( ac [ popStatCol ] ) ] thalPopStat = thal [ popStatCol ] [ pd . notnull ( thal [ popStatCol ] ) ] pos = jitter ( np . ones ( len ( thalPopStat ) ) * 0 , 0.20 ) ax . plot ( pos , thalPopStat , <str> , mec = colorATh , mfc = <str> ) pos = jitter ( np . ones ( len ( acPopStat ) ) * 1 , 0.20 ) ax . plot ( pos , acPopStat , <str> , mec = colorAC , mfc = <str> ) ax . set_ylabel ( <str> ) ax . set_xticks ( [ 0 , 1 ] ) ax . set_xticklabels ( [ <str> , <str> ] ) zstat , pVal = stats . mannwhitneyu ( thalPopStat , acPopStat ) print pVal   