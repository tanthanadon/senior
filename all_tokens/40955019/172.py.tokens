import numpy as np from numpy import inf from jaratoolbox import celldatabase from jaratoolbox import ephyscore from jaratoolbox import spikesanalysis import pandas as pd import figparams import matplotlib . pyplot as plt from scipy import stats from scipy import optimize import ipdb dbPath = <str> database = celldatabase . load_hdf ( dbPath ) goodISI = database . query ( <str> ) goodShape = goodISI . query ( <str> ) goodLaser = goodShape . query ( <str> ) goodNSpikes = goodLaser . query ( <str> ) db = goodNSpikes mono = [ ] maxSpikes = [ ] goodFit = db . query ( <str> ) goodFit [ <str> ] = np . sqrt ( goodFit [ <str> ] * goodFit [ <str> ] ) goodFitToUse = goodFit . query ( <str> ) goodFitToUseNSpikes = goodFitToUse . query ( <str> ) def split_gaussian ( l , a , mu , sigLow , sigHigh , cLow , cHigh ) :      if l <= mu :          return a * np . exp ( - 1 * ( ( l - mu ) ** 2 / ( 2 * sigLow ** 2 ) ) ) + cLow  elif l > mu :          return a * np . exp ( - 1 * ( ( l - mu ) ** 2 / ( 2 * sigHigh ** 2 ) ) ) + cHigh   dbToUse = goodFitToUseNSpikes . iloc [ : 3 ] for indIter , ( indRow , dbRow ) in enumerate ( dbToUse . iterrows ( ) ) :      print indRow failed = False cell = ephyscore . Cell ( dbRow , useModifiedClusters = True ) try :          ephysData , bdata = cell . load ( <str> )  except ( IndexError , ValueError ) :          failed = True print <str> . format ( indRow )  eventOnsetTimes = ephysData [ <str> ] [ <str> ] spikeTimes = ephysData [ <str> ] freqEachTrial = bdata [ <str> ] if len ( eventOnsetTimes ) != len ( freqEachTrial ) :          eventOnsetTimes = eventOnsetTimes [ : - 1 ] if len ( eventOnsetTimes ) != len ( freqEachTrial ) :              raise ValueError ( <str> )   possibleFreq = np . unique ( freqEachTrial ) intensityEachTrial = bdata [ <str> ] possibleIntensity = np . unique ( intensityEachTrial ) cfTrials = freqEachTrial == dbRow [ <str> ] eventsThisFreq = eventOnsetTimes [ cfTrials ] intenThisFreq = intensityEachTrial [ cfTrials ] baseRange = [ - 0.1 , 0 ] responseRange = [ 0 , 0.1 ] alignmentRange = [ baseRange [ 0 ] , responseRange [ 1 ] ] ( spikeTimesFromEventOnset , trialIndexForEachSpike , indexLimitsEachTrial ) = spikesanalysis . eventlocked_spiketimes ( spikeTimes , eventsThisFreq , alignmentRange ) nspkBase = spikesanalysis . spiketimes_to_spikecounts ( spikeTimesFromEventOnset , indexLimitsEachTrial , baseRange ) nspkResp = spikesanalysis . spiketimes_to_spikecounts ( spikeTimesFromEventOnset , indexLimitsEachTrial , responseRange ) nspkBase = nspkBase . ravel ( ) nspkResp = nspkResp . ravel ( ) ipdb . set_trace ( ) possibleInten = np . unique ( intenThisFreq ) p0 = [ 1 , , 1 , possibleInten [ - 1 ] , 0 , 0 , 0 , 0 ] , bounds = ( [ 0 , possibleInten [ 0 ] , 0 , 0 , 0 , 0 ] , [ inf , possibleInten [ - 1 ] , inf , inf , inf , inf ] ) popt , pcov = optimize . curve_fit ( split_gaussian , intenThisFreq , nspkResp , p0 , bounds ) ipdb . set_trace ( )  plt . show ( )  