from evdev import InputDevice , ecodes , UInput , list_devices from threading import Timer class TrackedEvent ( object ) :      def __init__ ( self , dev , abilities , var_x , var_y ) :          self . dev = dev self . abilities = abilities self . vars = { <str> : var_x , <str> : var_y } self . position = { <str> : None , <str> : None } self . fingers = 0 self . total_event_fingers = 0 self . discard = 0 self . moved = 0 self . track_start = None self . click_delay = 1.5  def add_finger ( self ) :          self . fingers += 1 self . total_event_fingers = self . fingers  def remove_fingers ( self ) :          if self . fingers == 1 :              print ( <str> , self . total_event_fingers )  self . fingers -= 1 if ( self . fingers == 0 and self . total_event_fingers == 2 and self . moved == 0 ) :              self . total_event_fingers = 0 self . _initiate_right_click ( )  elif ( self . fingers == 0 and self . total_event_fingers == 1 and self . moved == 0 ) :              self . total_event_fingers = 0 try :                  self . track_start . cancel ( ) self . track_start . join ( )  except AttributeError :                  pass  try :                  self . dev . ungrab ( )  except OSError :                  pass   if self . fingers == 0 :              self . discard = 1   def position_event ( self , event_code , value ) :          if self . position [ event_code ] is None :              self . position [ event_code ] = value  else :              if abs ( self . position [ event_code ] - value ) > self . vars [ event_code ] :                  self . _moved_event ( )   if ( self . fingers == 1 and self . position [ <str> ] and self . position [ <str> ] and self . track_start is None ) :              self . _trackit ( )   def _trackit ( self ) :          self . track_start = Timer ( self . click_delay , self . _long_press ) self . track_start . start ( )  def _long_press ( self ) :          if self . fingers == 1 and self . moved == 0 :              self . _initiate_right_click ( ) self . dev . grab ( )   def _moved_event ( self ) :          self . moved = 1  def _initiate_right_click ( self ) :          with UInput ( self . abilities ) as ui :              ui . write ( ecodes . EV_ABS , ecodes . ABS_X , 0 ) ui . write ( ecodes . EV_ABS , ecodes . ABS_Y , 0 ) ui . write ( ecodes . EV_KEY , ecodes . BTN_RIGHT , 1 ) ui . write ( ecodes . EV_KEY , ecodes . BTN_RIGHT , 0 ) ui . syn ( )    def initiate_gesture_find ( ) :      for device in list_devices ( ) :          dev = InputDevice ( device ) if ( dev . name == <str> ) or ( dev . name == <str> ) :              break   Abs_events = { } abilities = { ecodes . EV_ABS : [ ecodes . ABS_X , ecodes . ABS_Y ] , ecodes . EV_KEY : ( ecodes . BTN_LEFT , ecodes . BTN_RIGHT ) } res_x = 13 res_y = 13 codes = dev . capabilities ( ) for code in codes :          if code == 3 :              for type_code in codes [ code ] :                  human_code = ecodes . ABS [ type_code [ 0 ] ] if human_code == <str> :                      vals = type_code [ 1 ] abilities [ ecodes . EV_ABS ] [ 0 ] = ( ecodes . ABS_X , vals ) res_x = vals [ - 1 ]  elif human_code == <str> :                      vals = type_code [ 1 ] abilities [ ecodes . EV_ABS ] [ 1 ] = ( ecodes . ABS_Y , vals ) res_y = vals [ - 1 ]  Abs_events [ type_code [ 0 ] ] = human_code    var_x = 1.0 * res_x var_y = 1.0 * res_y MT_event = None for event in dev . read_loop ( ) :          if event . type == ecodes . EV_ABS :              if MT_event is None :                  MT_event = TrackedEvent ( dev , abilities , var_x , var_y )  event_code = Abs_events [ event . code ] if event_code == <str> or event_code == <str> :                  MT_event . position_event ( event_code , event . value )  elif event_code == <str> :                  if event . value == - 1 :                      MT_event . remove_fingers ( ) if MT_event . discard == 1 :                          MT_event = None   else :                      MT_event . add_finger ( )      if __name__ == <str> :      initiate_gesture_find ( )   