import sys from itertools import * from xotl . tools . symbols import Unset from xotl . tools . deprecation import deprecated_alias map = deprecated_alias ( map , removed_in_version = <str> , check_version = True ) zip = deprecated_alias ( zip , removed_in_version = <str> , check_version = True ) def first_non_null ( iterable , default = None ) :      return next ( ( x for x in iter ( iterable ) if x ) , default )  def flatten ( sequence , is_scalar = None , depth = None ) :      if is_scalar is None :          def is_scalar ( maybe ) :              from collections import Iterable return isinstance ( maybe , str ) or not isinstance ( maybe , Iterable )   for item in sequence :          if is_scalar ( item ) :              yield item  elif depth == 0 :              yield item  else :              if depth is not None :                  depth = depth - 1  for subitem in flatten ( item , is_scalar , depth = depth ) :                  yield subitem     def pop_first ( source , keys , default = None ) :      return next ( ( source . pop ( key ) for key in keys if key in source ) , default )  def multi_pop ( source , * keys ) :      return ( source . pop ( key ) for key in keys if key in source )  def multi_get ( source , * keys ) :      return ( source . get ( key ) for key in keys if key in source )  def dict_update_new ( target , source , fail = False ) :      for key in source :          if key not in target :              target [ key ] = source [ key ]  elif fail :              raise TypeError ( <str> . format ( key ) )    def delete_duplicates ( seq , key = lambda x : x ) :      i , done = 0 , set ( ) while i < len ( seq ) :          k = key ( seq [ i ] ) if k not in done :              done . add ( k ) i += 1  else :              seq = seq [ : i ] + seq [ i + 1 : ]   return seq  def iter_delete_duplicates ( iter , key = lambda x : x ) :      last = object ( ) for x in iter :          k = key ( x ) if k != last :              yield x  last = k   def iter_without_duplicates ( it , key = lambda x : x ) :      done = set ( ) for what in it :          k = key ( what ) if k not in done :              yield what done . add ( k )    def slides ( iterable , width = 2 , fill = None ) :      from itertools import cycle , repeat from collections import Iterable pos = 0 res = [ ] iterator = iter ( iterable ) current = next ( iterator , Unset ) while current is not Unset :          if pos < width :              res . append ( current ) current = next ( iterator , Unset ) pos = pos + 1  else :              yield tuple ( res ) res = [ ] pos = 0   if res :          if isinstance ( fill , Iterable ) :              fill = cycle ( fill )  else :              fill = repeat ( fill )  while pos < width :              res . append ( next ( fill ) ) pos += 1  yield tuple ( res )   def continuously_slides ( iterable , width = 2 , fill = None ) :      i = iter ( iterable ) res = [ ] while len ( res ) < width :          current = next ( i , fill ) res . append ( current )  yield tuple ( res ) current = next ( i , Unset ) while current is not Unset :          res . pop ( 0 ) res . append ( current ) yield tuple ( res ) current = next ( i , Unset )   def first_n ( iterable , n = 1 , fill = Unset ) :      if fill is not Unset :          from collections import Iterable from itertools import cycle , repeat , chain if isinstance ( fill , Iterable ) :              fill = cycle ( fill )  else :              fill = repeat ( fill )  seq = chain ( iterable , fill )  else :          seq = iter ( iterable )  try :          while n > 0 :              yield next ( seq ) n -= 1   except StopIteration :          return   def ungroup ( iterator ) :      for _ , xs in iterator :          for x in xs :              yield x    if sys . version_info < ( 3 , 5 ) :      class _safeitem :          __slots__ = [ <str> , <str> ] def __init__ ( self , item , key = None ) :              self . item = item self . key = key or ( lambda x : x )  def __le__ ( self , other ) :              return self . key ( self . item ) <= self . key ( other . item )  def __lt__ ( self , other ) :              return self . key ( self . item ) < self . key ( other . item )  def __ge__ ( self , other ) :              return self . key ( self . item ) >= self . key ( other . item )  def __gt__ ( self , other ) :              return self . key ( self . item ) > self . key ( other . item )  def __eq__ ( self , other ) :              return self . key ( self . item ) == self . key ( other . item )   def merge ( * iterables , key = None ) :          from heapq import merge if key is None :              key = lambda x : x  params = ( ( _safeitem ( x , key ) for x in iter_ ) for iter_ in iterables ) for x in merge ( * params ) :              yield x . item    else :      from heapq import merge  del sys  