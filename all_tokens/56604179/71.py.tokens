<str> import functools import numbers from xotl . tools . objects import classproperty UNIT = 1 @ functools . total_ordering class Quantity ( numbers . Real ) :      __slots__ = ( <str> , <str> ) def __init__ ( self , quantity , units ) :          if not isinstance ( quantity , BareReal ) :              raise TypeError ( <str> )  self . magnitude = quantity self . signature = units  def __str__ ( self ) :          return <str> . format ( self . magnitude , self . signature )  __repr__ = __str__ def __neg__ ( self ) :          return type ( self ) ( - self . magnitude , self . signature )  def __pos__ ( self ) :          return type ( self ) ( self . magnitude , self . signature )  def __add__ ( self , other ) :          if isinstance ( other , Quantity ) and self . signature == other . signature :              return type ( self ) ( self . magnitude + other . magnitude , self . signature )  else :              raise OperandTypeError ( <str> , self , other )   __radd__ = __add__ def __sub__ ( self , other ) :          if isinstance ( other , Quantity ) and self . signature == other . signature :              return type ( self ) ( self . magnitude - other . magnitude , self . signature )  else :              raise OperandTypeError ( <str> , self , other )   def __mul__ ( self , other ) :          if isinstance ( other , BareReal ) :              other = type ( self ) ( other , Signature ( ) )  if isinstance ( other , Quantity ) :              return downgrade_to_scalar ( type ( self ) ( self . magnitude * other . magnitude , self . signature * other . signature ) )  else :              raise OperandTypeError ( <str> , self , other )   __rmul__ = __mul__ def __pow__ ( self , exp ) :          if isinstance ( exp , numbers . Integral ) and exp != 0 :              if exp < 0 :                  return 1 / ( self ** ( - exp ) )  else :                  return type ( self ) ( self . magnitude ** exp , self . signature ** exp )   else :              raise OperandTypeError ( <str> , self , exp )   def __div__ ( self , other ) :          if isinstance ( other , BareReal ) :              other = type ( self ) ( other , Signature ( ) )  if isinstance ( other , Quantity ) :              return downgrade_to_scalar ( type ( self ) ( self . magnitude / other . magnitude , self . signature / other . signature ) )  else :              raise OperandTypeError ( <str> , self , other )   __truediv__ = __div__ def __floordiv__ ( self , other ) :          if isinstance ( other , BareReal ) :              other = type ( self ) ( other , Signature ( ) )  if isinstance ( other , Quantity ) :              return downgrade_to_scalar ( type ( self ) ( self . magnitude // other . magnitude , self . signature / other . signature ) )  else :              raise OperandTypeError ( <str> , self , other )   def __rdiv__ ( self , other ) :          if isinstance ( other , BareReal ) :              other = type ( self ) ( other , Signature ( ) ) return downgrade_to_scalar ( type ( self ) ( other . magnitude / self . magnitude , other . signature / self . signature ) )  else :              raise OperandTypeError ( <str> , other , self )   __rtruediv__ = __rdiv__ def __rfloordiv__ ( self , other ) :          if isinstance ( other , BareReal ) :              other = type ( self ) ( other , Signature ( ) ) return downgrade_to_scalar ( type ( self ) ( other . magnitude // self . magnitude , other . signature / self . signature ) )  else :              raise OperandTypeError ( <str> , other , self )   def __eq__ ( self , other ) :          if isinstance ( other , BareReal ) and self . signature == SCALAR :              return self . magnitude == other  elif isinstance ( other , Quantity ) and self . signature == other . signature :              return self . magnitude == other . magnitude  else :              raise TypeError ( <str> % ( self , other ) )   def __lt__ ( self , other ) :          if isinstance ( other , Quantity ) and self . signature == other . signature :              return self . magnitude < other . magnitude  else :              raise TypeError ( <str> % ( self , other ) )   def __le__ ( self , other ) :          if isinstance ( other , Quantity ) and self . signature == other . signature :              return self . magnitude <= other . magnitude  else :              raise TypeError ( <str> % ( self , other ) )   def __float__ ( self ) :          return float ( self . magnitude )  def __trunc__ ( self ) :          return self . magnitude . __trunc__ ( )  def __abs__ ( self ) :          return abs ( self . magnitude )  def __round__ ( self ) :          return round ( self . magnitude )  def __ceil__ ( self ) :          import math return math . ceil ( self . magnitude )  def __floor__ ( self ) :          import math return math . floor ( self . magnitude )  def __mod__ ( self , other ) :          if isinstance ( other , BareReal ) :              return type ( self ) ( self . magnitude % other , self . signature )  else :              raise OperandTypeError ( <str> , self , other )   def __rmod__ ( self , other ) :          if isinstance ( other , BareReal ) :              return type ( self ) ( other % self . magnitude , 1 / self . signature )  else :              raise OperandTypeError ( <str> , self , other )   def __rpow__ ( self , other ) :          raise OperandTypeError ( <str> , other , self )   class Dimension ( type ) :      Quantity = Quantity @ classproperty def _Quantity ( self ) :          from xotl . tools . objects import import_object return import_object ( self . Quantity )  def __new__ ( cls , name , bases , attrs ) :          wrappedattrs = { } Base = next ( ( base for base in bases if isinstance ( base , cls ) ) , None ) if Base is not None :              unit = Base . _unitname_ signature = Base . _signature_  else :              unit = None signature = Signature ( )  for attr , val in attrs . items ( ) :              if isinstance ( val , BareReal ) :                  if val == UNIT and unit is not None :                      raise TypeError ( <str> )  if unit is None and val == UNIT :                      unit = attr assert not signature . top signature . top = ( <str> . format ( name , unit ) , )  wrappedattrs [ attr ] = cls . _Quantity ( val , signature )  else :                  if unit is None and isinstance ( val , Quantity ) :                      if val . magnitude == UNIT :                          unit = attr  assert not signature . top and not signature . bottom signature . top = val . signature . top signature . bottom = val . signature . bottom  wrappedattrs [ attr ] = val   if unit is None :              raise TypeError ( <str> )  self = super ( ) . __new__ ( cls , name , bases , wrappedattrs ) self . _unitname_ = unit self . _unit_ = getattr ( self , unit ) self . _signature_ = signature return self  @ classmethod def new ( cls , * source , ** kwargs ) :          from xotl . tools . objects import copy_class from xotl . tools . decorator . meta import decorator @ decorator def _new ( source , unit_alias = None , unit_aliases = None , Quantity = None ) :              if Quantity is not None :                  class meta ( cls ) :                      pass  meta . Quantity = Quantity  else :                  meta = cls  res = copy_class ( source , meta = meta ) if unit_alias :                  setattr ( res , unit_alias , res . _unit_ )  if unit_aliases :                  for alias in unit_aliases :                      setattr ( res , alias , res . _unit_ )   return res  if source and kwargs or len ( source ) > 1 :              raise TypeError ( <str> )  return _new ( * source , ** kwargs )  def __instancecheck__ ( self , instance ) :          if isinstance ( instance , Quantity ) :              return instance . signature == self . _signature_  else :              return False   def __mul__ ( self , other ) :          if isinstance ( other , Dimension ) :              name = TIMES ( self . __name__ , other . __name__ ) if self == other :                  unit = SQUARED ( self . _unitname_ ) quant = self . _Quantity ( UNIT , self . _signature_ ** 2 )  else :                  unit = TIMES ( self . _unitname_ , other . _unitname_ ) quant = self . _Quantity ( UNIT , self . _signature_ * other . _signature_ )  klass = type ( self ) return klass ( name , ( object , ) , { unit : quant } )  else :              raise OperandTypeError ( <str> , self , other )   def __pow__ ( self , exp ) :          if isinstance ( exp , numbers . Integral ) :              if exp == 0 :                  return Scalar  elif exp == 1 :                  return self  elif exp == 2 :                  return self * self  elif exp < 0 :                  return 1 / ( self ** - exp )  else :                  assert exp > 0 name = POWER ( self . __name__ , exp ) unit = POWER ( self . _unitname_ , exp ) quant = self . _Quantity ( UNIT , self . _signature_ ** exp ) klass = type ( self ) return klass ( name , ( object , ) , { unit : quant } )   else :              raise OperandTypeError ( <str> , self , exp )   def __div__ ( self , other ) :          if isinstance ( other , Dimension ) :              if self == other :                  return Scalar  else :                  name = PER ( self . __name__ , other . __name__ ) unit = PER ( self . _unitname_ , other . _unitname_ ) quant = self . _Quantity ( UNIT , self . _signature_ / other . _signature_ ) klass = type ( self ) return klass ( name , ( object , ) , { unit : quant } )   else :              raise OperandTypeError ( <str> , self , other )   __truediv__ = __floordiv__ = __div__ def __rdiv__ ( self , numerator ) :          assert not isinstance ( numerator , Dimension ) if numerator == 1 :              name = PER ( <str> , self . __name__ ) unit = PER ( <str> , self . _unitname_ ) quant = self . _Quantity ( UNIT , 1 / self . _signature_ ) klass = type ( self ) return klass ( name , ( object , ) , { unit : quant } )  else :              raise OperandTypeError ( <str> , numerator , self )   __rtruediv__ = __rfloordiv__ = __rdiv__ def __eq__ ( self , other ) :          if isinstance ( other , Dimension ) :              return self . _signature_ == other . _signature_  else :              raise TypeError ( <str> % ( type ( self ) . __name__ , type ( other ) . __name__ ) )    class Signature :      __slots__ = ( <str> , <str> ) def __init__ ( self , top = None , bottom = None ) :          self . top , self . bottom = self . simplify ( top , bottom )  def __eq__ ( self , other ) :          try :              from xotl . tools . future . collections import Counter  except ImportError :              from xotl . tools . collections import Counter  if isinstance ( other , type ( self ) ) :              return Counter ( self . top ) == Counter ( other . top ) and Counter ( self . bottom ) == Counter ( other . bottom )  else :              return False   def __ne__ ( self , other ) :          return not ( self == other )  __hash__ = None def __lt__ ( self , other ) :          raise TypeError ( <str> )  __gt__ = __ge__ = __le__ = __lt__ def __mul__ ( self , other ) :          cls = type ( self ) if other == UNIT :              return self  elif isinstance ( other , cls ) :              return cls ( self . top + other . top , self . bottom + other . bottom )  else :              raise TypeError   __rmul__ = __mul__ def __div__ ( self , other ) :          cls = type ( self ) if other == UNIT :              return self  elif isinstance ( other , cls ) :              return cls ( self . top + other . bottom , self . bottom + other . top )  else :              raise TypeError   __truediv__ = __floordiv__ = __div__ def __rdiv__ ( self , numerator ) :          if numerator == UNIT :              cls = type ( self ) return cls ( self . bottom , self . top )  else :              raise TypeError   __rtruediv__ = __rfloordiv__ = __rdiv__ def __pow__ ( self , exp ) :          if isinstance ( exp , numbers . Integral ) :              if exp == 0 :                  return Signature ( )  elif exp > 0 :                  return Signature ( self . top * exp , self . bottom * exp )  else :                  return Signature ( self . bottom * - exp , self . top * - exp )   else :              raise TypeError   @ staticmethod def simplify ( top , bottom ) :          top = [ ] if top is None else list ( top ) bottom = [ ] if bottom is None else list ( bottom ) i = 0 while i < len ( top ) :              j = 0 while j < len ( bottom ) and bottom [ j ] != top [ i ] :                  j += 1  if j < len ( bottom ) :                  assert bottom [ j ] == top [ i ] del bottom [ j ] del top [ i ]  else :                  i += 1   return tuple ( top ) , tuple ( bottom )  def __str__ ( self ) :          wrap = lambda s : <str> . format ( s ) top = wrap ( <str> . join ( str ( t ) for t in self . top ) ) bottom = wrap ( <str> . join ( str ( b ) for b in self . bottom ) ) return <str> . format ( top = top , bottom = bottom )  __repr__ = __str__  class _BareRealType ( type ) :      def __instancecheck__ ( self , i ) :          return isinstance ( i , numbers . Real ) and not isinstance ( i , Quantity )   class BareReal ( metaclass = _BareRealType ) :       SCALAR = Signature ( ) @ Dimension . new class Scalar :      unit = Quantity ( UNIT , SCALAR )  TIMES = lambda a , b : <str> . format ( a , b ) PER = lambda a , b : <str> . format ( a , b ) SQUARED = lambda a : <str> . format ( a ) def POWER ( a , e ) :      return <str> . format ( a , e )  class OperandTypeError ( TypeError ) :      def __init__ ( self , operand , val1 , val2 ) :          if isinstance ( val1 , Quantity ) :              t1 = val1 . signature  else :              t1 = type ( val1 ) . __name__  if isinstance ( val2 , Quantity ) :              t2 = val2 . signature  else :              t2 = type ( val2 ) . __name__  super ( ) . __init__ ( <str> % ( operand , t1 , t2 ) )   def downgrade_to_scalar ( quantity ) :      if quantity . signature == SCALAR :          return quantity . magnitude  else :          return quantity    