import unittest import pytest try :      import greenlet  except ImportError :      GREENLETS = False  else :      GREENLETS = True  import sys sys . modules . pop ( <str> , None ) sys . modules . pop ( <str> , None ) del sys from xoutil . context import context class TestContext ( unittest . TestCase ) :      def test_simple_contexts ( self ) :          with context ( <str> ) :              self . assertIsNot ( None , context [ <str> ] ) with context ( <str> ) :                  with context ( <str> ) :                      self . assertIsNot ( None , context [ <str> ] ) self . assertIsNot ( None , context [ <str> ] )  self . assertEquals ( False , bool ( context [ <str> ] ) )  self . assertIsNot ( None , context [ <str> ] )  self . assertEquals ( False , bool ( context [ <str> ] ) )  def test_with_objects ( self ) :          CONTEXT1 = object ( ) CONTEXT2 = object ( ) with context ( CONTEXT1 ) :              self . assertIsNot ( None , context [ CONTEXT1 ] ) with context ( CONTEXT1 ) :                  with context ( CONTEXT2 ) :                      self . assertIsNot ( None , context [ CONTEXT1 ] ) self . assertIsNot ( None , context [ CONTEXT2 ] )  self . assertEquals ( False , bool ( context [ CONTEXT2 ] ) )  self . assertIsNot ( None , context [ CONTEXT1 ] )  self . assertEquals ( False , bool ( context [ CONTEXT1 ] ) )   def test_stacking_of_data_does_not_leak ( ) :      c1 = <str> with context ( c1 , a = 1 , b = 1 ) as cc1 :          assert cc1 [ <str> ] == 1 with context ( c1 , a = 2 , z = <str> ) as cc2 :              assert cc2 is cc1 assert cc2 [ <str> ] == 2 assert cc2 [ <str> ] == 1 assert cc2 [ <str> ] == <str> cc2 [ <str> ] = <str> assert cc2 [ <str> ] == <str>  assert cc1 [ <str> ] == 1 assert cc1 [ <str> ] == 1 assert set ( cc1 ) == { <str> , <str> }  try :          assert cc1 [ <str> ] == 1 assert False  except ( IndexError , KeyError ) :          pass   def test_data_is_an_opendict ( ) :      c1 = object ( ) with context ( c1 , a = 1 , b = 1 ) as cc1 :          with context ( c1 , a = 2 ) as cc2 :              assert cc2 is cc1 assert cc2 . a == 2 assert cc2 . b == 1 cc2 . b = <str>  assert cc1 . a == 1 assert cc1 [ <str> ] == 1   def test_reusing_raises ( ) :      with context ( <str> ) as a :          try :              with a :                  pass  assert False , <str>  except RuntimeError :              pass  except :              assert False , <str>    def test_from_dicts ( ) :      with context . from_dicts ( <str> , dict ( a = 1 ) , dict ( a = 2 , b = 1 ) ) as c :          assert c [ <str> ] == 1 assert c [ <str> ] == 1 with context . from_dicts ( <str> , dict ( a = 2 ) , dict ( b = 2 ) ) as c :              assert c [ <str> ] == 1 assert c [ <str> ] == 2  assert c [ <str> ] == 1 assert c [ <str> ] == 1   def test_from_defaults ( ) :      with context . from_defaults ( <str> , a = 1 ) :          with context . from_defaults ( <str> , a = 2 , b = 1 ) as c :              assert c [ <str> ] == 1 assert c [ <str> ] == 1 with context ( <str> , a = 2 ) as c2 :                  assert c2 [ <str> ] == 2  assert c [ <str> ] == 1  assert c [ <str> ] == 1   def test_recover_from_runtime_bug_33 ( ) :      try :          with context ( <str> ) as c :              with c :                  pass    except RuntimeError :          pass  with context ( <str> ) :          pass   def test_null_context_is_mapping ( ) :      from xoutil . context import NullContext dict ( ** NullContext ( ) )  @ pytest . mark . skipif ( not GREENLETS , reason = <str> ) def test_greenlet_contexts ( ) :      import random from xoutil . symbols import Unset calls = 0 switches = 0 class GreenletProg :          def __init__ ( self , arg ) :              self . arg = arg  def __call__ ( self ) :              nonlocal calls nonlocal switches calls += 1 switches += 1 assert <str> not in context with context ( <str> ) as ctx :                  assert ctx . get ( <str> , Unset ) is Unset ctx [ <str> ] = self . arg root . switch ( ) switches += 1 assert ctx [ <str> ] == self . arg assert list ( ctx . keys ( ) ) == [ <str> ]    def loop ( n ) :          nonlocal calls nonlocal switches greenlets = [ greenlet . greenlet ( run = GreenletProg ( i ) ) for i in range ( n ) ] calls = 0 switches = 0 while greenlets :              pos = random . randrange ( 0 , len ( greenlets ) ) gl = greenlets [ pos ] gl . switch ( ) if gl . dead :                  del greenlets [ pos ]   assert calls == n , <str> assert switches == 2 * n , <str>  def loop_determ ( n ) :          nonlocal calls nonlocal switches greenlets = [ greenlet . greenlet ( run = GreenletProg ( i ) ) for i in range ( n ) ] pos = 0 calls = 0 switches = 0 while greenlets :              gl = greenlets [ pos ] gl . switch ( ) if gl . dead :                  del greenlets [ pos ]  pos = ( ( pos + 1 ) % len ( greenlets ) ) if greenlets else 0  assert calls == n , <str> assert switches == 2 * n , <str>  root = greenlet . greenlet ( run = loop ) root . switch ( 10 ) root = greenlet . greenlet ( run = loop_determ ) root . switch ( 5 )   