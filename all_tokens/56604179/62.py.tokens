from functools import * from functools import _CacheInfo def power ( * args ) :      from xotl . tools . params import check_count from xotl . tools . fp . tools import compose check_count ( args , 2 , caller = <str> ) * funcs , times = args if any ( not callable ( func ) for func in funcs ) :          raise TypeError ( <str> )  if not ( isinstance ( times , int ) and times > 0 ) :          raise TypeError ( <str> )  if len ( funcs ) > 1 :          base = ( compose ( funcs ) , )  else :          base = ( funcs [ 0 ] , )  return compose ( * ( base * times ) )  def lwraps ( * args , ** kwargs ) :      from types import FunctionType , MethodType from xotl . tools . symbols import Unset from xotl . tools . params import check_count def repeated ( name ) :          msg = <str> raise TypeError ( msg . format ( name ) )  def settle_str ( name , value ) :          if value is not Unset :              if isinstance ( value , str ) :                  if name not in source :                      source [ name ] = value  else :                      repeated ( name )   else :                  msg = <str> raise TypeError ( msg . format ( name , type ( value ) . __name__ ) )    methods = ( staticmethod , classmethod , MethodType ) decorables = methods + ( FunctionType , ) name_key = <str> doc_key = <str> mod_key = <str> safes = { name_key , mod_key } source = { } target = Unset count = len ( args ) check_count ( count , 0 , 2 , caller = <str> ) i = 0 while i < count :          arg = args [ i ] if isinstance ( arg , str ) :              settle_str ( name_key , arg )  elif isinstance ( arg , decorables ) :              if target is Unset :                  target = arg  else :                  repeated ( <str> )   else :              msg = <str> raise TypeError ( msg . format ( i ) )  i += 1  wrapped = kwargs . pop ( <str> , Unset ) settle_str ( name_key , kwargs . pop ( <str> , Unset ) ) settle_str ( name_key , kwargs . pop ( name_key , Unset ) ) settle_str ( doc_key , kwargs . pop ( <str> , Unset ) ) settle_str ( doc_key , kwargs . pop ( doc_key , Unset ) ) source . update ( kwargs ) if wrapped is not Unset :          for name in ( mod_key , name_key , doc_key ) :              if name not in source :                  source [ str ( name ) ] = getattr ( wrapped , name )   d = source . setdefault ( <str> , { } ) d . update ( wrapped . __dict__ )  def wrapper ( target ) :          if isinstance ( target , decorables ) :              res = target if isinstance ( target , methods ) :                  target = target . __func__  for name in ( mod_key , name_key , doc_key ) :                  if name in source :                      value = source . pop ( name ) if name in safes :                          value = str ( value )  setattr ( target , str ( name ) , value )  d = source . pop ( <str> , Unset ) if d :                      target . __dict__ . update ( d )   for key in source :                  setattr ( target , key , source [ key ] )  return res  else :              msg = <str> raise TypeError ( msg . format ( type ( target ) . __name__ ) )   return wrapper ( target ) if target else wrapper  def curry ( f ) :      from xotl . tools . future . inspect import getfullargspec fargs = getfullargspec ( f ) [ 0 ] def curried ( cargs = None ) :          if cargs is None :              cargs = [ ]  def inner ( * args , ** kwargs ) :              cargs_ = cargs + list ( args ) if len ( cargs_ ) < len ( fargs ) :                  return curried ( cargs_ )  else :                  return f ( * cargs_ , ** kwargs )   return inner  return curried ( )   