import re from abc import ABCMeta from xotl . tools . future . functools import lwraps from xotl . tools . symbols import boolean , Unset from xotl . tools . fp . prove import vouch from xotl . tools . deprecation import deprecate_linked deprecate_linked ( check = <str> ) del deprecate_linked _coercer_decorator = lwraps ( __coercer__ = True ) class logical ( boolean ) :      __slots__ = ( ) _valid = { <str> : False , <str> : True } def __new__ ( cls , arg ) :          from xotl . tools . symbols import boolean from xotl . tools . symbols import Invalid name = ( <str> if arg else <str> ) if isinstance ( arg , boolean ) else arg value = cls . _valid . get ( name , Invalid ) if value is not Invalid :              return super ( ) . __new__ ( cls , name , value )  else :              msg = <str> raise TypeError ( msg . format ( arg ) )   def __call__ ( self , arg ) :          if self :              return arg if arg or arg is nil else self  else :              return t if arg is self else self    nil , t = logical ( <str> ) , logical ( <str> ) class MetaCoercer ( ABCMeta ) :      <str> def __instancecheck__ ( self , instance ) :          return getattr ( instance , <str> , False ) or super ( ) . __instancecheck__ ( instance )   class coercer ( metaclass = MetaCoercer ) :      __slots__ = ( ) __coercer__ = True def __new__ ( cls , source ) :          from types import FunctionType as function from xotl . tools . symbols import boolean if source == 1 and isinstance ( source , boolean ) :              return identity_coerce  elif source is None or ( source == 0 and isinstance ( source , boolean ) ) :              return void_coerce  elif isinstance ( source , coercer ) :              return source  elif isinstance ( source , ( function , staticmethod , classmethod ) ) :              return _coercer_decorator ( source )  else :              inner = types_tuple_coerce ( source ) return istype ( inner ) if inner else nil    def coercer_name ( arg , join = None ) :      if isinstance ( arg , ( tuple , list , set ) ) :          res = type ( arg ) ( coercer_name ( c ) for c in arg ) if isinstance ( join , str ) :              join = join . join  return str ( join ( res ) ) if join else res  else :          try :              res = arg . __name__  except Exception :              res = str ( arg )  suffix = str ( <str> ) if res . endswith ( suffix ) :              res = res [ : - len ( suffix ) ]  return res   @ coercer def identity_coerce ( arg ) :      <str> return arg  @ coercer def void_coerce ( arg ) :      return nil  @ coercer def type_coerce ( arg ) :      return arg if isinstance ( arg , type ) else nil  @ coercer def types_tuple_coerce ( arg ) :      if t ( type_coerce ( arg ) ) :          return ( arg , )  elif isinstance ( arg , tuple ) and all ( t ( type_coerce ( tp ) ) for tp in arg ) :          return arg  else :          return nil   @ coercer def callable_coerce ( arg ) :      return arg if callable ( arg ) else nil  @ coercer def file_coerce ( arg ) :      from io import IOBase METHODS = ( <str> , <str> , <str> ) ok = isinstance ( arg , IOBase ) or all ( hasattr ( arg , a ) for a in METHODS ) return arg if ok else nil  @ coercer def float_coerce ( arg ) :      if isinstance ( arg , float ) :          return arg  elif isinstance ( arg , int ) :          return float ( arg )  elif isinstance ( arg , ( str , bytes ) ) :          try :              return float ( arg )  except ValueError :              return nil   elif isinstance ( arg , complex ) :          return arg . real if arg . imag == 0 else nil  else :          return nil   @ coercer def int_coerce ( arg ) :      if isinstance ( arg , int ) :          return arg  else :          arg = float_coerce ( arg ) if t ( arg ) :              res = int ( arg ) return res if arg - res == 0 else nil  else :              return nil    @ coercer def number_coerce ( arg ) :      if isinstance ( arg , int ) :          return arg  else :          f = float_coerce ( arg ) if t ( f ) :              i = int ( f ) return i if f - i == 0 else f  else :              return nil    @ coercer def positive_int_coerce ( arg ) :      res = int_coerce ( arg ) return res if res is nil or res >= 0 else nil  def create_int_range_coerce ( min , max ) :      min , max = vouch ( int_coerce , min ) , vouch ( int_coerce , max ) if min < max :          @ coercer def inner ( arg ) :              <str> arg = int_coerce ( arg ) if t ( arg ) and min <= arg <= max :                  return arg  else :                  return nil   inner . __name__ = str ( <str> . format ( min , max ) ) inner . __doc__ = inner . __doc__ . format ( min , max ) return inner  else :          msg = <str> raise ValueError ( msg . format ( min , max ) )   _IDENTIFIER_REGEX = re . compile ( <str> ) @ coercer def identifier_coerce ( arg ) :      ok = isinstance ( arg , str ) and _IDENTIFIER_REGEX . match ( arg ) return str ( arg ) if ok else nil  _FULL_IDENTIFIER_REGEX = re . compile ( <str> ) @ coercer def full_identifier_coerce ( arg ) :      ok = isinstance ( arg , str ) and _FULL_IDENTIFIER_REGEX . match ( arg ) return str ( arg ) if ok else nil  @ coercer def names_coerce ( arg ) :      arg = ( arg , ) if isinstance ( arg , str ) else tuple ( arg ) return iterable ( identifier_coerce ) ( arg )  def create_unique_member_coerce ( coerce , container ) :      coerce = vouch ( coercer , coerce ) @ coercer def inner ( arg ) :          res = coerce ( arg ) if t ( res ) and hash ( res ) != hash ( arg ) and res in container :              res = nil  return res  cname = coercer_name ( coerce ) inner . __name__ = str ( <str> . format ( cname ) ) inner . __doc__ = inner . __doc__ . format ( cname ) return inner  @ coercer def sized_coerce ( arg ) :      from collections import Iterable , Sized if isinstance ( arg , Iterable ) :          return arg if isinstance ( arg , Sized ) else list ( arg )  else :          return nil   @ coercer . register class custom :      __slots__ = ( <str> , <str> ) _str_join = <str> _repr_join = <str> def __init__ ( self , * args , ** kwargs ) :          self . scope = Unset  def __str__ ( self ) :          name = coercer_name ( self . inner , join = self . _str_join ) cls_name = type ( self ) . __name__ return str ( <str> . format ( name , cls_name ) )  def __repr__ ( self ) :          name = coercer_name ( self . inner , join = self . _repr_join ) cls_name = type ( self ) . __name__ return str ( <str> . format ( cls_name , name ) )  def __call__ ( self , arg ) :          return nil  @ classmethod def flatten ( cls , obj , avoid = Unset ) :          aux = obj . inner if isinstance ( obj , cls ) else obj if isinstance ( aux , ( tuple , list ) ) :              if not types_tuple_coerce ( aux ) :                  res = ( i for l in map ( cls . flatten , aux ) for i in l )  else :                  res = ( coercer ( aux ) , )   else :              res = ( aux , )  if avoid is not Unset :              res = ( i for i in res if i is not avoid )  return tuple ( res )   class istype ( custom ) :      __slots__ = ( ) def __new__ ( cls , types ) :          if types :              self = super ( ) . __new__ ( cls ) self . inner = vouch ( types_tuple_coerce , types ) return self  else :              return void_coerce   def __call__ ( self , arg ) :          return arg if isinstance ( arg , self . inner ) else nil   class typecast ( istype ) :      __slots__ = ( ) def __call__ ( self , arg ) :          res = super ( ) . __call__ ( arg ) i = 0 while not t ( res ) and i < len ( self . inner ) :              try :                  tp = self . inner [ i ] res = tp ( arg ) self . scope = tp  except Exception :                  i += 1   return res   class safe ( custom ) :      __slots__ = ( ) def __init__ ( self , func ) :          super ( ) . __init__ ( ) self . inner = vouch ( coercer , func )  def __call__ ( self , arg ) :          try :              from xotl . tools . symbol import boolean res = self . inner ( arg ) return logical ( res ) if isinstance ( res , boolean ) else res  except Exception as error :              self . scope = ( arg , error ) return nil    class compose ( custom ) :      __slots__ = ( ) def __new__ ( cls , * coercers , ** kwds ) :          inner = cls . flatten ( coercers , avoid = identity_coerce ) count = len ( inner ) if count > 1 :              self = super ( ) . __new__ ( cls ) self . inner = inner return self  elif count == 1 :              return inner [ 0 ]  else :              res = kwds . pop ( <str> , identity_coerce ) if not kwds :                  return res  else :                  msg = <str> raise TypeError ( msg . format ( set ( kwds ) ) )    def __call__ ( self , arg ) :          coercers = self . inner i = 0 res = arg ok = True while ok and i < len ( coercers ) :              coerce = coercers [ i ] aux = coerce ( res ) if t ( aux ) :                  i += 1  else :                  ok = False self . scope = ( res , coerce )  res = aux  return res   class some ( custom ) :      __slots__ = ( ) def __new__ ( cls , * coercers ) :          inner = cls . flatten ( coercers , avoid = void_coerce ) if len ( inner ) > 1 :              self = super ( ) . __new__ ( cls ) self . inner = inner return self  elif len ( inner ) == 1 :              return inner [ 0 ]  else :              return void_coerce   def __call__ ( self , arg ) :          coercers = self . inner i = 0 res = nil while res is nil and i < len ( coercers ) :              coercer = coercers [ i ] value = coercer ( arg ) if t ( value ) :                  res = value self . scope = coercer  else :                  i += 1   return res   class combo ( custom ) :      __slots__ = ( ) def __init__ ( self , * coercers ) :          super ( ) . __init__ ( ) coercers = pargs ( coercer ) ( coercers ) self . inner = tuple ( vouch ( coercer , c ) for c in coercers )  def __call__ ( self , arg ) :          from collections import Iterable if isinstance ( arg , Iterable ) :              coercers = self . inner items = iter ( arg ) i = 0 res = [ ] ok = True while t ( res ) and ok and i < len ( coercers ) :                  item = next ( items , Unset ) if item is not Unset :                      coerce = coercers [ i ] value = coerce ( item ) if t ( value ) :                          res . append ( value ) i += 1  else :                          res = nil self . scope = ( item , coerce )   else :                      ok = False   if t ( res ) :                  try :                      res = type ( arg ) ( res )  except Exception :                      pass    else :              res = nil  return res   class pargs ( custom ) :      <str> __slots__ = ( ) def __init__ ( self , arg_coerce ) :          super ( ) . __init__ ( ) self . inner = vouch ( coercer , arg_coerce )  def __call__ ( self , arg ) :          from collections import Iterable coerce = self . inner if isinstance ( arg , Iterable ) :              arg = tuple ( arg ) if len ( arg ) == 1 :                  item = arg [ 0 ] aux = coerce ( item ) if t ( aux ) :                      res = ( aux , )  elif isinstance ( item , Iterable ) :                      res = Unset arg = tuple ( item )  else :                      self . scope = item res = nil   else :                  res = Unset  if res is Unset :                  res = arg i = 0 while t ( res ) and i < len ( res ) :                      item = res [ i ] new = coerce ( item ) if t ( new ) :                          if new is not item :                              if isinstance ( res , tuple ) :                                  res = list ( res )  res [ i ] = new  i += 1  else :                          self . scope = item res = nil   if t ( res ) :                      res = tuple ( res )    else :              res = nil  return res   class iterable ( custom ) :      __slots__ = ( ) def __init__ ( self , member_coerce , outer_coerce = True ) :          super ( ) . __init__ ( ) member_coerce = vouch ( coercer , member_coerce ) outer_coerce = compose ( coercer ( outer_coerce ) , sized_coerce ) self . inner = ( member_coerce , outer_coerce )  def __call__ ( self , arg ) :          from collections import Set , Sequence , MutableSequence member_coerce , outer_coerce = self . inner modified = False aux = outer_coerce ( arg ) if t ( aux ) :              arg = aux if isinstance ( arg , Sequence ) :                  res = arg retyped = False mutable = isinstance ( arg , MutableSequence )  else :                  res = list ( arg ) retyped = mutable = True  i = 0 while t ( res ) and i < len ( res ) :                  item = res [ i ] new = member_coerce ( item ) if t ( new ) :                      if new is not item :                          if not mutable :                              res = list ( res ) retyped = mutable = True  res [ i ] = new modified = True  i += 1  else :                      self . scope = item res = nil   if t ( res ) :                  if isinstance ( arg , Set ) and not modified :                      res = arg  elif retyped :                      try :                          res = type ( arg ) ( res )  except Exception :                          pass     else :              self . scope = arg res = nil  return res   class mapping ( custom ) :      __slots__ = ( ) _str_join = _repr_join = <str> def __new__ ( cls , key_coercer = Unset , value_coercer = Unset ) :          from collections import Mapping if key_coercer is value_coercer is Unset :              return coercer ( Mapping )  else :              self = super ( ) . __new__ ( cls ) key_coercer = vouch ( coercer , key_coercer or True ) value_coercer = vouch ( coercer , value_coercer or True ) self . inner = ( key_coercer , value_coercer ) return self   def __call__ ( self , arg ) :          from collections import Mapping , MutableMapping if isinstance ( arg , Mapping ) :              key_coercer , value_coercer = self . inner res = arg retyped = False mutable = isinstance ( arg , MutableMapping ) keys = list ( res ) i = 0 while t ( res ) and i < len ( keys ) :                  key = keys [ i ] value = res [ key ] new_key = key_coercer ( key ) if t ( new_key ) :                      new_value = value_coercer ( value ) if t ( new_value ) :                          if new_key is not key or new_value is not value :                              if not mutable :                                  res = dict ( res ) retyped = mutable = True  if key is not new_key :                                  del res [ key ]  res [ new_key ] = new_value  i += 1  else :                          self . scope = ( { key : value } , value_coercer ) res = nil   else :                      self . scope = ( { key : value } , key_coercer ) res = nil   if t ( res ) and retyped :                  try :                      res = type ( arg ) ( res )  except Exception :                      pass    else :              self . scope = ( ) res = nil  return res   del re , ABCMeta , lwraps  