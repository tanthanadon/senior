from hypothesis import strategies as s , given , example def test_fp_compose ( ) :      from xoutil . fp . tools import ( identity , compose , pos_args , kw_args , full_args ) x , obj = 15 , object ( ) f , g , h = x . __add__ , x . __mul__ , x . __xor__ def join ( * args ) :          if args :              return <str> . join ( str ( arg ) for arg in args )   def plus2 ( value ) :          return value + 2  def plus2d ( value ) :          return { <str> : value + 2 }  def myrange ( stop ) :          return list ( range ( stop ) )  assert compose ( join , pos_args , myrange , plus2 ) ( 0 ) == <str> assert compose ( join , myrange , plus2 ) ( 0 ) == <str> assert compose ( join , myrange , kw_args , plus2d ) ( 0 ) == <str> assert compose ( join , myrange , full_args . parse , plus2d ) ( 0 ) == <str> assert compose ( ) is identity assert compose ( ) ( x ) is x assert compose ( ) ( obj ) is obj assert compose ( f ) is f assert compose ( g , f ) ( x ) == g ( f ( x ) ) assert compose ( h , g , f ) ( x ) == h ( g ( f ( x ) ) )  def test_fp_compose_wrapable ( ) :      from functools import wraps from xoutil . fp . tools import compose def wrapper ( ) :          <str> pass  res = wraps ( wrapper ) ( compose ( wrapper , lambda : None ) ) assert res . __name__ == wrapper . __name__ assert res . __doc__ == wrapper . __doc__ assert res . __module__ == wrapper . __module__  def test_fp_tools ( ) :      from xoutil . fp . tools import identity , compose x , obj = 15 , object ( ) f , g , h = x . __add__ , x . __mul__ , x . __xor__ def join ( * args ) :          if args :              return <str> . join ( str ( arg ) for arg in args )   def plus2 ( value ) :          return value + 2  def plus2d ( value ) :          return { <str> : value + 2 }  def myrange ( stop ) :          return list ( range ( stop ) )  assert compose ( join , myrange , plus2 ) ( 0 ) == <str> assert compose ( ) is identity assert compose ( ) ( x ) is x assert compose ( ) ( obj ) is obj assert compose ( f ) is f assert compose ( g , f ) ( x ) == g ( f ( x ) ) assert compose ( h , g , f ) ( x ) == h ( g ( f ( x ) ) ) c = compose ( * ( ( lambda y : lambda x : x + y ) ( i ) for i in range ( 6 ) ) ) for i in range ( 7 ) :          assert c [ : i ] ( 0 ) == sum ( range ( i ) )   @ given ( s . integers ( min_value = 0 , max_value = 20 ) ) @ example ( 4 ) def test_fp_kleisli_compose ( n ) :      from xoutil . fp . iterators import kleisli_compose def fullrange ( n ) :          <str> return range ( n + 1 )  def odds ( n ) :          return [ x for x in fullrange ( n ) if x % 2 != 0 ]  odd_seqs = kleisli_compose ( odds , fullrange ) assert list ( odd_seqs ( n ) ) == [ z for y in fullrange ( n ) for z in odds ( y ) ] id_ = lambda x : [ x ] pad = ( id_ , ) * n args = pad + ( odds , ) + pad + ( fullrange , ) + pad odd_seqs = kleisli_compose ( * args ) assert list ( odd_seqs ( n ) ) == [ z for y in fullrange ( n ) for z in odds ( y ) ] odd_seqs = kleisli_compose ( fullrange , odds ) assert list ( odd_seqs ( n ) ) == [ z for y in odds ( n ) for z in fullrange ( y ) ] args = pad + ( fullrange , ) + pad + ( odds , ) + pad odd_seqs = kleisli_compose ( * args ) assert list ( odd_seqs ( n ) ) == [ z for y in odds ( n ) for z in fullrange ( y ) ]  def test_fp_kleisli_compose4 ( ) :      from xoutil . fp . iterators import kleisli_compose def fullrange ( n ) :          <str> return range ( n + 1 )  def odds ( n ) :          return [ x for x in fullrange ( n ) if x % 2 != 0 ]  id_ = lambda x : [ x ] odd_seqs = kleisli_compose ( odds , fullrange ) assert list ( odd_seqs ( 4 ) ) == [ 1 , 1 , 1 , 3 , 1 , 3 ] odd_seqs = kleisli_compose ( id_ , odds , id_ , id_ , fullrange , id_ ) assert list ( odd_seqs ( 4 ) ) == [ 1 , 1 , 1 , 3 , 1 , 3 ] odd_seqs = kleisli_compose ( fullrange , odds ) assert list ( odd_seqs ( 4 ) ) == [ 0 , 1 , 0 , 1 , 2 , 3 ] odd_seqs = kleisli_compose ( id_ , fullrange , id_ , id_ , odds , id_ ) assert list ( odd_seqs ( 4 ) ) == [ 0 , 1 , 0 , 1 , 2 , 3 ]   