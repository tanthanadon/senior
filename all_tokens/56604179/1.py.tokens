from __future__ import print_function try :      import configparser  except ImportError :      import ConfigParser as configparser  import errno import json import os import re import subprocess import sys class VersioneerConfig :       def get_root ( ) :      root = os . path . realpath ( os . path . abspath ( os . getcwd ( ) ) ) setup_py = os . path . join ( root , <str> ) versioneer_py = os . path . join ( root , <str> ) if not ( os . path . exists ( setup_py ) or os . path . exists ( versioneer_py ) ) :          root = os . path . dirname ( os . path . realpath ( os . path . abspath ( sys . argv [ 0 ] ) ) ) setup_py = os . path . join ( root , <str> ) versioneer_py = os . path . join ( root , <str> )  if not ( os . path . exists ( setup_py ) or os . path . exists ( versioneer_py ) ) :          err = ( <str> <str> <str> <str> <str> ) raise VersioneerBadRootError ( err )  try :          me = os . path . realpath ( os . path . abspath ( __file__ ) ) me_dir = os . path . normcase ( os . path . splitext ( me ) [ 0 ] ) vsr_dir = os . path . normcase ( os . path . splitext ( versioneer_py ) [ 0 ] ) if me_dir != vsr_dir :              print ( <str> % ( os . path . dirname ( me ) , versioneer_py ) )   except NameError :          pass  return root  def get_config_from_root ( root ) :      setup_cfg = os . path . join ( root , <str> ) parser = configparser . SafeConfigParser ( ) with open ( setup_cfg , <str> ) as f :          parser . readfp ( f )  VCS = parser . get ( <str> , <str> ) def get ( parser , name ) :          if parser . has_option ( <str> , name ) :              return parser . get ( <str> , name )  return None  cfg = VersioneerConfig ( ) cfg . VCS = VCS cfg . style = get ( parser , <str> ) or <str> cfg . versionfile_source = get ( parser , <str> ) cfg . versionfile_build = get ( parser , <str> ) cfg . tag_prefix = get ( parser , <str> ) if cfg . tag_prefix in ( <str> , <str> ) :          cfg . tag_prefix = <str>  cfg . parentdir_prefix = get ( parser , <str> ) cfg . verbose = get ( parser , <str> ) return cfg  class NotThisMethod ( Exception ) :       LONG_VERSION_PY = { } HANDLERS = { } def register_vcs_handler ( vcs , method ) :      def decorate ( f ) :          if vcs not in HANDLERS :              HANDLERS [ vcs ] = { }  HANDLERS [ vcs ] [ method ] = f return f  return decorate  def run_command ( commands , args , cwd = None , verbose = False , hide_stderr = False , env = None ) :      assert isinstance ( commands , list ) p = None for c in commands :          try :              dispcmd = str ( [ c ] + args ) p = subprocess . Popen ( [ c ] + args , cwd = cwd , env = env , stdout = subprocess . PIPE , stderr = ( subprocess . PIPE if hide_stderr else None ) ) break  except EnvironmentError :              e = sys . exc_info ( ) [ 1 ] if e . errno == errno . ENOENT :                  continue  if verbose :                  print ( <str> % dispcmd ) print ( e )  return None , None   else :          if verbose :              print ( <str> % ( commands , ) )  return None , None  stdout = p . communicate ( ) [ 0 ] . strip ( ) if sys . version_info [ 0 ] >= 3 :          stdout = stdout . decode ( )  if p . returncode != 0 :          if verbose :              print ( <str> % dispcmd ) print ( <str> % stdout )  return None , p . returncode  return stdout , p . returncode  LONG_VERSION_PY [ <str> ] = @ register_vcs_handler ( <str> , <str> ) def git_get_keywords ( versionfile_abs ) :      keywords = { } try :          f = open ( versionfile_abs , <str> ) for line in f . readlines ( ) :              if line . strip ( ) . startswith ( <str> ) :                  mo = re . search ( <str> , line ) if mo :                      keywords [ <str> ] = mo . group ( 1 )   if line . strip ( ) . startswith ( <str> ) :                  mo = re . search ( <str> , line ) if mo :                      keywords [ <str> ] = mo . group ( 1 )   if line . strip ( ) . startswith ( <str> ) :                  mo = re . search ( <str> , line ) if mo :                      keywords [ <str> ] = mo . group ( 1 )    f . close ( )  except EnvironmentError :          pass  return keywords  @ register_vcs_handler ( <str> , <str> ) def git_versions_from_keywords ( keywords , tag_prefix , verbose ) :      if not keywords :          raise NotThisMethod ( <str> )  date = keywords . get ( <str> ) if date is not None :          date = date . strip ( ) . replace ( <str> , <str> , 1 ) . replace ( <str> , <str> , 1 )  refnames = keywords [ <str> ] . strip ( ) if refnames . startswith ( <str> ) :          if verbose :              print ( <str> )  raise NotThisMethod ( <str> )  refs = set ( [ r . strip ( ) for r in refnames . strip ( <str> ) . split ( <str> ) ] ) TAG = <str> tags = set ( [ r [ len ( TAG ) : ] for r in refs if r . startswith ( TAG ) ] ) if not tags :          tags = set ( [ r for r in refs if re . search ( <str> , r ) ] ) if verbose :              print ( <str> % <str> . join ( refs - tags ) )   if verbose :          print ( <str> % <str> . join ( sorted ( tags ) ) )  for ref in sorted ( tags ) :          if ref . startswith ( tag_prefix ) :              r = ref [ len ( tag_prefix ) : ] if verbose :                  print ( <str> % r )  return { <str> : r , <str> : keywords [ <str> ] . strip ( ) , <str> : False , <str> : None , <str> : date }   if verbose :          print ( <str> )  return { <str> : <str> , <str> : keywords [ <str> ] . strip ( ) , <str> : False , <str> : <str> , <str> : None }  @ register_vcs_handler ( <str> , <str> ) def git_pieces_from_vcs ( tag_prefix , root , verbose , run_command = run_command ) :      GITS = [ <str> ] if sys . platform == <str> :          GITS = [ <str> , <str> ]  out , rc = run_command ( GITS , [ <str> , <str> ] , cwd = root , hide_stderr = True ) if rc != 0 :          if verbose :              print ( <str> % root )  raise NotThisMethod ( <str> )  describe_out , rc = run_command ( GITS , [ <str> , <str> , <str> , <str> , <str> , <str> , <str> % tag_prefix ] , cwd = root ) if describe_out is None :          raise NotThisMethod ( <str> )  describe_out = describe_out . strip ( ) full_out , rc = run_command ( GITS , [ <str> , <str> ] , cwd = root ) if full_out is None :          raise NotThisMethod ( <str> )  full_out = full_out . strip ( ) pieces = { } pieces [ <str> ] = full_out pieces [ <str> ] = full_out [ : 7 ] pieces [ <str> ] = None git_describe = describe_out dirty = git_describe . endswith ( <str> ) pieces [ <str> ] = dirty if dirty :          git_describe = git_describe [ : git_describe . rindex ( <str> ) ]  if <str> in git_describe :          mo = re . search ( <str> , git_describe ) if not mo :              pieces [ <str> ] = ( <str> % describe_out ) return pieces  full_tag = mo . group ( 1 ) if not full_tag . startswith ( tag_prefix ) :              if verbose :                  fmt = <str> print ( fmt % ( full_tag , tag_prefix ) )  pieces [ <str> ] = ( <str> % ( full_tag , tag_prefix ) ) return pieces  pieces [ <str> ] = full_tag [ len ( tag_prefix ) : ] pieces [ <str> ] = int ( mo . group ( 2 ) ) pieces [ <str> ] = mo . group ( 3 )  else :          pieces [ <str> ] = None count_out , rc = run_command ( GITS , [ <str> , <str> , <str> ] , cwd = root ) pieces [ <str> ] = int ( count_out )  date = run_command ( GITS , [ <str> , <str> , <str> , <str> ] , cwd = root ) [ 0 ] . strip ( ) pieces [ <str> ] = date . strip ( ) . replace ( <str> , <str> , 1 ) . replace ( <str> , <str> , 1 ) return pieces  def do_vcs_install ( manifest_in , versionfile_source , ipy ) :      GITS = [ <str> ] if sys . platform == <str> :          GITS = [ <str> , <str> ]  files = [ manifest_in , versionfile_source ] if ipy :          files . append ( ipy )  try :          me = __file__ if me . endswith ( <str> ) or me . endswith ( <str> ) :              me = os . path . splitext ( me ) [ 0 ] + <str>  versioneer_file = os . path . relpath ( me )  except NameError :          versioneer_file = <str>  files . append ( versioneer_file ) present = False try :          f = open ( <str> , <str> ) for line in f . readlines ( ) :              if line . strip ( ) . startswith ( versionfile_source ) :                  if <str> in line . strip ( ) . split ( ) [ 1 : ] :                      present = True    f . close ( )  except EnvironmentError :          pass  if not present :          f = open ( <str> , <str> ) f . write ( <str> % versionfile_source ) f . close ( ) files . append ( <str> )  run_command ( GITS , [ <str> , <str> ] + files )  def versions_from_parentdir ( parentdir_prefix , root , verbose ) :      rootdirs = [ ] for i in range ( 3 ) :          dirname = os . path . basename ( root ) if dirname . startswith ( parentdir_prefix ) :              return { <str> : dirname [ len ( parentdir_prefix ) : ] , <str> : None , <str> : False , <str> : None , <str> : None }  else :              rootdirs . append ( root ) root = os . path . dirname ( root )   if verbose :          print ( <str> % ( str ( rootdirs ) , parentdir_prefix ) )  raise NotThisMethod ( <str> )  SHORT_VERSION_PY = def versions_from_file ( filename ) :      try :          with open ( filename ) as f :              contents = f . read ( )   except EnvironmentError :          raise NotThisMethod ( <str> )  mo = re . search ( <str> , contents , re . M | re . S ) if not mo :          mo = re . search ( <str> , contents , re . M | re . S )  if not mo :          raise NotThisMethod ( <str> )  return json . loads ( mo . group ( 1 ) )  def write_to_version_file ( filename , versions ) :      os . unlink ( filename ) contents = json . dumps ( versions , sort_keys = True , indent = 1 , separators = ( <str> , <str> ) ) with open ( filename , <str> ) as f :          f . write ( SHORT_VERSION_PY % contents )  print ( <str> % ( filename , versions [ <str> ] ) )  def plus_or_dot ( pieces ) :      if <str> in pieces . get ( <str> , <str> ) :          return <str>  return <str>  def render_pep440 ( pieces ) :      if pieces [ <str> ] :          rendered = pieces [ <str> ] if pieces [ <str> ] or pieces [ <str> ] :              rendered += plus_or_dot ( pieces ) rendered += <str> % ( pieces [ <str> ] , pieces [ <str> ] ) if pieces [ <str> ] :                  rendered += <str>    else :          rendered = <str> % ( pieces [ <str> ] , pieces [ <str> ] ) if pieces [ <str> ] :              rendered += <str>   return rendered  def render_pep440_pre ( pieces ) :      if pieces [ <str> ] :          rendered = pieces [ <str> ] if pieces [ <str> ] :              rendered += <str> % pieces [ <str> ]   else :          rendered = <str> % pieces [ <str> ]  return rendered  def render_pep440_post ( pieces ) :      if pieces [ <str> ] :          rendered = pieces [ <str> ] if pieces [ <str> ] or pieces [ <str> ] :              rendered += <str> % pieces [ <str> ] if pieces [ <str> ] :                  rendered += <str>  rendered += plus_or_dot ( pieces ) rendered += <str> % pieces [ <str> ]   else :          rendered = <str> % pieces [ <str> ] if pieces [ <str> ] :              rendered += <str>  rendered += <str> % pieces [ <str> ]  return rendered  def render_pep440_old ( pieces ) :      if pieces [ <str> ] :          rendered = pieces [ <str> ] if pieces [ <str> ] or pieces [ <str> ] :              rendered += <str> % pieces [ <str> ] if pieces [ <str> ] :                  rendered += <str>    else :          rendered = <str> % pieces [ <str> ] if pieces [ <str> ] :              rendered += <str>   return rendered  def render_git_describe ( pieces ) :      if pieces [ <str> ] :          rendered = pieces [ <str> ] if pieces [ <str> ] :              rendered += <str> % ( pieces [ <str> ] , pieces [ <str> ] )   else :          rendered = pieces [ <str> ]  if pieces [ <str> ] :          rendered += <str>  return rendered  def render_git_describe_long ( pieces ) :      if pieces [ <str> ] :          rendered = pieces [ <str> ] rendered += <str> % ( pieces [ <str> ] , pieces [ <str> ] )  else :          rendered = pieces [ <str> ]  if pieces [ <str> ] :          rendered += <str>  return rendered  def render ( pieces , style ) :      if pieces [ <str> ] :          return { <str> : <str> , <str> : pieces . get ( <str> ) , <str> : None , <str> : pieces [ <str> ] , <str> : None }  if not style or style == <str> :          style = <str>  if style == <str> :          rendered = render_pep440 ( pieces )  elif style == <str> :          rendered = render_pep440_pre ( pieces )  elif style == <str> :          rendered = render_pep440_post ( pieces )  elif style == <str> :          rendered = render_pep440_old ( pieces )  elif style == <str> :          rendered = render_git_describe ( pieces )  elif style == <str> :          rendered = render_git_describe_long ( pieces )  else :          raise ValueError ( <str> % style )  return { <str> : rendered , <str> : pieces [ <str> ] , <str> : pieces [ <str> ] , <str> : None , <str> : pieces . get ( <str> ) }  class VersioneerBadRootError ( Exception ) :       def get_versions ( verbose = False ) :      if <str> in sys . modules :          del sys . modules [ <str> ]  root = get_root ( ) cfg = get_config_from_root ( root ) assert cfg . VCS is not None , <str> handlers = HANDLERS . get ( cfg . VCS ) assert handlers , <str> % cfg . VCS verbose = verbose or cfg . verbose assert cfg . versionfile_source is not None , <str> assert cfg . tag_prefix is not None , <str> versionfile_abs = os . path . join ( root , cfg . versionfile_source ) get_keywords_f = handlers . get ( <str> ) from_keywords_f = handlers . get ( <str> ) if get_keywords_f and from_keywords_f :          try :              keywords = get_keywords_f ( versionfile_abs ) ver = from_keywords_f ( keywords , cfg . tag_prefix , verbose ) if verbose :                  print ( <str> % ver )  return ver  except NotThisMethod :              pass   try :          ver = versions_from_file ( versionfile_abs ) if verbose :              print ( <str> % ( versionfile_abs , ver ) )  return ver  except NotThisMethod :          pass  from_vcs_f = handlers . get ( <str> ) if from_vcs_f :          try :              pieces = from_vcs_f ( cfg . tag_prefix , root , verbose ) ver = render ( pieces , cfg . style ) if verbose :                  print ( <str> % ver )  return ver  except NotThisMethod :              pass   try :          if cfg . parentdir_prefix :              ver = versions_from_parentdir ( cfg . parentdir_prefix , root , verbose ) if verbose :                  print ( <str> % ver )  return ver   except NotThisMethod :          pass  if verbose :          print ( <str> )  return { <str> : <str> , <str> : None , <str> : None , <str> : <str> , <str> : None }  def get_version ( ) :      return get_versions ( ) [ <str> ]  def get_cmdclass ( ) :      if <str> in sys . modules :          del sys . modules [ <str> ]  cmds = { } from distutils . core import Command class cmd_version ( Command ) :          description = <str> user_options = [ ] boolean_options = [ ] def initialize_options ( self ) :              pass  def finalize_options ( self ) :              pass  def run ( self ) :              vers = get_versions ( verbose = True ) print ( <str> % vers [ <str> ] ) print ( <str> % vers . get ( <str> ) ) print ( <str> % vers . get ( <str> ) ) print ( <str> % vers . get ( <str> ) ) if vers [ <str> ] :                  print ( <str> % vers [ <str> ] )    cmds [ <str> ] = cmd_version if <str> in sys . modules :          from setuptools . command . build_py import build_py as _build_py  else :          from distutils . command . build_py import build_py as _build_py  class cmd_build_py ( _build_py ) :          def run ( self ) :              root = get_root ( ) cfg = get_config_from_root ( root ) versions = get_versions ( ) _build_py . run ( self ) if cfg . versionfile_build :                  target_versionfile = os . path . join ( self . build_lib , cfg . versionfile_build ) print ( <str> % target_versionfile ) write_to_version_file ( target_versionfile , versions )    cmds [ <str> ] = cmd_build_py if <str> in sys . modules :          from cx_Freeze . dist import build_exe as _build_exe class cmd_build_exe ( _build_exe ) :              def run ( self ) :                  root = get_root ( ) cfg = get_config_from_root ( root ) versions = get_versions ( ) target_versionfile = cfg . versionfile_source print ( <str> % target_versionfile ) write_to_version_file ( target_versionfile , versions ) _build_exe . run ( self ) os . unlink ( target_versionfile ) with open ( cfg . versionfile_source , <str> ) as f :                      LONG = LONG_VERSION_PY [ cfg . VCS ] f . write ( LONG % { <str> : <str> , <str> : cfg . style , <str> : cfg . tag_prefix , <str> : cfg . parentdir_prefix , <str> : cfg . versionfile_source , } )    cmds [ <str> ] = cmd_build_exe del cmds [ <str> ]  if <str> in sys . modules :          try :              from py2exe . distutils_buildexe import py2exe as _py2exe  except ImportError :              from py2exe . build_exe import py2exe as _py2exe  class cmd_py2exe ( _py2exe ) :              def run ( self ) :                  root = get_root ( ) cfg = get_config_from_root ( root ) versions = get_versions ( ) target_versionfile = cfg . versionfile_source print ( <str> % target_versionfile ) write_to_version_file ( target_versionfile , versions ) _py2exe . run ( self ) os . unlink ( target_versionfile ) with open ( cfg . versionfile_source , <str> ) as f :                      LONG = LONG_VERSION_PY [ cfg . VCS ] f . write ( LONG % { <str> : <str> , <str> : cfg . style , <str> : cfg . tag_prefix , <str> : cfg . parentdir_prefix , <str> : cfg . versionfile_source , } )    cmds [ <str> ] = cmd_py2exe  if <str> in sys . modules :          from setuptools . command . sdist import sdist as _sdist  else :          from distutils . command . sdist import sdist as _sdist  class cmd_sdist ( _sdist ) :          def run ( self ) :              versions = get_versions ( ) self . _versioneer_generated_versions = versions self . distribution . metadata . version = versions [ <str> ] return _sdist . run ( self )  def make_release_tree ( self , base_dir , files ) :              root = get_root ( ) cfg = get_config_from_root ( root ) _sdist . make_release_tree ( self , base_dir , files ) target_versionfile = os . path . join ( base_dir , cfg . versionfile_source ) print ( <str> % target_versionfile ) write_to_version_file ( target_versionfile , self . _versioneer_generated_versions )   cmds [ <str> ] = cmd_sdist return cmds  CONFIG_ERROR = SAMPLE_CONFIG = INIT_PY_SNIPPET = def do_setup ( ) :      root = get_root ( ) try :          cfg = get_config_from_root ( root )  except ( EnvironmentError , configparser . NoSectionError , configparser . NoOptionError ) as e :          if isinstance ( e , ( EnvironmentError , configparser . NoSectionError ) ) :              print ( <str> , file = sys . stderr ) with open ( os . path . join ( root , <str> ) , <str> ) as f :                  f . write ( SAMPLE_CONFIG )   print ( CONFIG_ERROR , file = sys . stderr ) return 1  print ( <str> % cfg . versionfile_source ) with open ( cfg . versionfile_source , <str> ) as f :          LONG = LONG_VERSION_PY [ cfg . VCS ] f . write ( LONG % { <str> : <str> , <str> : cfg . style , <str> : cfg . tag_prefix , <str> : cfg . parentdir_prefix , <str> : cfg . versionfile_source , } )  ipy = os . path . join ( os . path . dirname ( cfg . versionfile_source ) , <str> ) if os . path . exists ( ipy ) :          try :              with open ( ipy , <str> ) as f :                  old = f . read ( )   except EnvironmentError :              old = <str>  if INIT_PY_SNIPPET not in old :              print ( <str> % ipy ) with open ( ipy , <str> ) as f :                  f . write ( INIT_PY_SNIPPET )   else :              print ( <str> % ipy )   else :          print ( <str> % ipy ) ipy = None  manifest_in = os . path . join ( root , <str> ) simple_includes = set ( ) try :          with open ( manifest_in , <str> ) as f :              for line in f :                  if line . startswith ( <str> ) :                      for include in line . split ( ) [ 1 : ] :                          simple_includes . add ( include )      except EnvironmentError :          pass  if <str> not in simple_includes :          print ( <str> ) with open ( manifest_in , <str> ) as f :              f . write ( <str> )   else :          print ( <str> )  if cfg . versionfile_source not in simple_includes :          print ( <str> % cfg . versionfile_source ) with open ( manifest_in , <str> ) as f :              f . write ( <str> % cfg . versionfile_source )   else :          print ( <str> )  do_vcs_install ( manifest_in , cfg . versionfile_source , ipy ) return 0  def scan_setup_py ( ) :      found = set ( ) setters = False errors = 0 with open ( <str> , <str> ) as f :          for line in f . readlines ( ) :              if <str> in line :                  found . add ( <str> )  if <str> in line :                  found . add ( <str> )  if <str> in line :                  found . add ( <str> )  if <str> in line :                  setters = True  if <str> in line :                  setters = True    if len ( found ) != 3 :          print ( <str> ) print ( <str> ) print ( <str> ) print ( <str> ) print ( <str> ) print ( <str> ) print ( <str> ) print ( <str> ) print ( <str> ) errors += 1  if setters :          print ( <str> ) print ( <str> ) print ( <str> ) print ( <str> ) errors += 1  return errors  if __name__ == <str> :      cmd = sys . argv [ 1 ] if cmd == <str> :          errors = do_setup ( ) errors += scan_setup_py ( ) if errors :              sys . exit ( 1 )     