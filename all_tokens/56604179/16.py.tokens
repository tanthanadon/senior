from types import ModuleType def force_module ( ref = None ) :      from importlib import import_module if isinstance ( ref , ModuleType ) :          return ref  else :          if ref is None :              ref = 1  if isinstance ( ref , int ) :              import sys frame = sys . _getframe ( ref ) try :                  ref = frame . f_globals [ <str> ]  finally :                  del frame   if not isinstance ( ref , str ) :              if isinstance ( ref , bytes ) :                  ref = ref . decode ( )  else :                  try :                      ref = ref . encode ( )  except Exception :                      msg = <str> raise TypeError ( msg . format ( type ( ref ) . __name__ , ref ) )    return import_module ( ref )   def copy_members ( source = None , target = None ) :      target = force_module ( target or 2 ) if source is None :          source = target . __name__ . rsplit ( <str> ) [ - 1 ] if source == target . __name__ :              msg = <str> raise ValueError ( msg )   source = force_module ( source ) for attr in dir ( source ) :          if not attr . startswith ( <str> ) :              setattr ( target , attr , getattr ( source , attr ) )   return source  class _CustomModuleBase ( ModuleType ) :      pass  def customize ( module , custom_attrs = None , meta = None ) :      if not isinstance ( module , _CustomModuleBase ) :          import sys meta_base = meta if meta else type class CustomModuleType ( meta_base ) :              def __new__ ( cls , name , bases , attrs ) :                  if custom_attrs :                      attrs . update ( custom_attrs )  return super ( ) . __new__ ( cls , name , bases , attrs )   class CustomModule ( _CustomModuleBase , metaclass = CustomModuleType ) :              def __getattr__ ( self , attr ) :                  self . __dict__ [ attr ] = result = getattr ( module , attr ) return result  def __dir__ ( self ) :                  res = set ( dir ( module ) ) if custom_attrs :                      res |= set ( custom_attrs . keys ( ) )  return list ( res )   sys . modules [ module . __name__ ] = result = CustomModule ( module . __name__ ) return result , True , CustomModule  else :          return module , False , type ( module )   def modulemethod ( func ) :      import sys from functools import wraps self , _created , cls = customize ( sys . modules [ func . __module__ ] ) @ wraps ( func ) def inner ( * args , ** kwargs ) :          return func ( self , * args , ** kwargs )  setattr ( cls , func . __name__ , func ) return inner  def moduleproperty ( getter , setter = None , deleter = None , doc = None , base = property ) :      import sys module = sys . modules [ getter . __module__ ] module , _created , cls = customize ( module ) class prop ( base ) :          if getattr ( base , <str> , False ) :              def setter ( self , func , _name = None ) :                  result = super ( ) . setter ( func ) setattr ( cls , _name or func . __name__ , result ) return result   if getattr ( base , <str> , False ) :              def deleter ( self , func , _name = None ) :                  result = super ( ) . deleter ( func ) setattr ( cls , _name or func . __name__ , result ) return result    result = prop ( getter , doc = doc ) name = getter . __name__ setattr ( cls , getter . __name__ , result ) if setter :          result = result . setter ( setter , _name = name )  if deleter :          result = result . deleter ( deleter , _name = name )  return result  def get_module_path ( module ) :      from importlib import import_module from xotl . tools . fs . path import normalize_path mod = import_module ( module ) if isinstance ( module , str ) else module path = mod . __path__ [ 0 ] if hasattr ( mod , <str> ) else mod . __file__ return normalize_path ( path )   