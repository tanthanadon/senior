import sys from xotl . tools . deprecation import deprecated_alias if <str> in sys . modules :      from . _greenlet_local import local  else :      try :          from threading import local  except ImportError :          from dummy_threading import local   del sys class AutoLocal ( local ) :      def __init__ ( self , ** attrs ) :          import sys super ( ) . __init__ ( ) for attr in attrs :              setattr ( self , attr , attrs [ attr ] )  if attrs :              g = sys . _getframe ( 1 ) . f_globals tname = type ( self ) . __name__ if tname in g :                  del g [ tname ]     MIN_WAIT_INTERVAL = 20 / 1000 DEFAULT_WAIT_INTERVAL = 50 / 1000 class ConstantWait :      def __init__ ( self , wait = DEFAULT_WAIT_INTERVAL ) :          import numbers if not isinstance ( wait , numbers . Real ) :              raise TypeError ( <str> )  self . wait = max ( MIN_WAIT_INTERVAL , wait )  def __call__ ( self , prev = None ) :          return self . wait   StandardWait = deprecated_alias ( ConstantWait , msg = <str> ) class BackoffWait :      def __init__ ( self , wait = DEFAULT_WAIT_INTERVAL , backoff = 1 ) :          self . wait = max ( MIN_WAIT_INTERVAL , wait ) self . backoff = min ( max ( 0.1 , backoff ) , 1 )  def __call__ ( self , prev = None ) :          res = self . wait + ( self . backoff / 1000 ) self . backoff = self . backoff * 2 return res   def get_backoff_wait ( n , * , wait = DEFAULT_WAIT_INTERVAL , backoff = 1 ) :      res = 0 fn = BackoffWait ( wait = wait , backoff = backoff ) for _ in range ( n ) :          res = fn ( prev = res )  return res  def retry ( fn , args = None , kwargs = None , * , max_tries = None , max_time = None , wait = DEFAULT_WAIT_INTERVAL , retry_only = None ) :      if args is None :          args = ( )  if kwargs is None :          kwargs = { }  return retrier ( max_tries = max_tries , max_time = max_time , wait = wait , retry_only = retry_only ) ( fn , * args , ** kwargs )  class retrier :      def __init__ ( self , max_tries = None , max_time = None , wait = DEFAULT_WAIT_INTERVAL , retry_only = None ) :          if not max_tries and not max_time :              raise TypeError ( <str> )  self . max_tries = max_tries self . max_time = max_time if not callable ( wait ) :              self . wait = ConstantWait ( wait )  else :              self . wait = wait  if not retry_only :              self . retry_only = ( Exception , )  else :              self . retry_only = retry_only   def __call__ ( self , fn , * args , ** kwargs ) :          return self . decorate ( fn ) ( * args , ** kwargs )  def decorate ( self , fn ) :          from time import monotonic as clock , sleep from xotl . tools . future . functools import wraps max_time = self . max_time max_tries = self . max_tries @ wraps ( fn ) def inner ( * args , ** kwargs ) :              t = 0 done = False start = clock ( ) waited = None while not done :                  try :                      return fn ( * args , ** kwargs )  except self . retry_only :                      t += 1 reached_max_tries = max_tries and t >= max_tries max_time_elapsed = max_time and clock ( ) - start >= max_time retry = not reached_max_tries and not max_time_elapsed if retry :                          waited = self . wait ( waited ) sleep ( waited )  else :                          raise     return inner   del deprecated_alias  