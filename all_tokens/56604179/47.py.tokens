from datetime import * from datetime import timedelta import datetime as _stdlib from re import compile as _regex_compile from time import strftime as _time_strftime from enum import IntEnum from typing import Iterator , Tuple , Union from xotl . tools . deprecation import deprecated class WEEKDAY ( IntEnum ) :      MONDAY = 0 TUESDAY = 1 WEDNESDAY = 2 THURSDAY = 3 FRIDAY = 4 SATURDAY = 5 SUNDAY = 6  class ISOWEEKDAY ( IntEnum ) :      MONDAY = 1 TUESDAY = 2 WEDNESDAY = 3 THURSDAY = 4 FRIDAY = 5 SATURDAY = 6 SUNDAY = 7  @ deprecated ( <str> ) def assure ( obj ) :      if isinstance ( obj , ( date , datetime , _stdlib . time , timedelta ) ) :          return obj  else :          raise TypeError ( <str> % obj )   @ deprecated ( assure ) def new_date ( d ) :      return date ( d . year , d . month , d . day )  @ deprecated ( assure ) def new_datetime ( d ) :      args = [ d . year , d . month , d . day ] if isinstance ( d , datetime ) :          args . extend ( [ d . hour , d . minute , d . second , d . microsecond , d . tzinfo ] )  return datetime ( * args )  del deprecated _illegal_formatting = _regex_compile ( <str> ) def _year_find_all ( fmt , year , no_year_tuple ) :      text = _time_strftime ( fmt , ( year , ) + no_year_tuple ) regex = _regex_compile ( str ( year ) ) return { match . start ( ) for match in regex . finditer ( text ) }  _TD_LABELS = <str> def _strfnumber ( number , format_spec = <str> ) :      res = format_spec % number if <str> in res :          res = res . rstrip ( <str> ) if res . endswith ( <str> ) :              res = res [ : - 1 ]   return res  def strfdelta ( delta ) :      ss , sss = str ( <str> ) , str ( <str> ) if delta . days :          days = delta . days delta -= timedelta ( days = days ) hours = delta . total_seconds ( ) / 60 / 60 res = ss % ( days , _TD_LABELS [ 0 ] ) if hours >= 0.01 :              res += sss % ( _strfnumber ( hours ) , _TD_LABELS [ 1 ] )   else :          seconds = delta . total_seconds ( ) if seconds > 60 :              minutes = seconds / 60 if minutes > 60 :                  hours = int ( minutes / 60 ) minutes -= hours * 60 res = ss % ( hours , _TD_LABELS [ 1 ] ) if minutes >= 0.01 :                      res += sss % ( _strfnumber ( minutes ) , _TD_LABELS [ 2 ] )   else :                  minutes = int ( minutes ) seconds -= 60 * minutes res = ss % ( minutes , _TD_LABELS [ 2 ] ) if seconds >= 0.01 :                      res += sss % ( _strfnumber ( seconds ) , _TD_LABELS [ 3 ] )    else :              res = ss % ( _strfnumber ( seconds , <str> ) , _TD_LABELS [ 3 ] )   return res  def strftime ( dt , fmt ) :      if dt . year >= 1900 :          bases = type ( dt ) . mro ( ) i = 0 base = _strftime = type ( dt ) . strftime while _strftime == base :              aux = getattr ( bases [ i ] , <str> , base ) if aux != base :                  _strftime = aux  else :                  i += 1   return _strftime ( dt , fmt )  else :          illegal_formatting = _illegal_formatting . search ( fmt ) if illegal_formatting is None :              year = dt . year delta = 2000 - year year += 6 * ( delta // 100 + delta // 400 ) year += ( ( 2000 - year ) // 28 ) * 28 no_year_tuple = dt . timetuple ( ) [ 1 : ] sites = _year_find_all ( fmt , year , no_year_tuple ) sites &= _year_find_all ( fmt , year + 28 , no_year_tuple ) res = _time_strftime ( fmt , ( year , ) + no_year_tuple ) syear = <str> % dt . year for site in sites :                  res = res [ : site ] + syear + res [ site + 4 : ]  return res  else :              msg = <str> raise TypeError ( msg % illegal_formatting . group ( 0 ) )    def parse_date ( value = None ) :      if value :          y , m , d = value . split ( <str> ) return date ( int ( y ) , int ( m ) , int ( d ) )  else :          return date . today ( )   def parse_datetime ( value = None ) :      if value :          d , t = value . split ( ) y , m , d = d . split ( <str> ) if <str> in t :              moment , ms = t . split ( <str> )  else :              moment , ms = t , <str>  timing = moment . split ( <str> ) if len ( timing ) == 2 :              h , mn = timing s = 0  elif len ( timing ) == 3 :              h , mn , s = timing  else :              raise ValueError ( <str> % t )  return datetime ( int ( y ) , int ( m ) , int ( d ) , int ( h ) , int ( mn ) , int ( s ) , int ( ms ) )  else :          return datetime . now ( )   def get_month_first ( ref = None ) :      aux = ref or date . today ( ) y , m = aux . year , aux . month return date ( y , m , 1 )  def get_month_last ( ref = None ) :      aux = ref or date . today ( ) y , m = aux . year , aux . month if m == 12 :          m = 1 y += 1  else :          m += 1  return date ( y , m , 1 ) - timedelta ( 1 )  def get_next_month ( ref = None , lastday = False ) :      result = get_month_last ( ref ) + timedelta ( days = 1 ) if lastday :          return get_month_last ( result )  else :          return result   def is_full_month ( start , end ) :      sd , sm , sy = start . day , start . month , start . year em , ey = end . month , end . year return ( ( sd == 1 ) and ( sm == em ) and ( sy == ey ) and ( em != ( end + timedelta ( 1 ) ) . month ) )  class flextime ( timedelta ) :      @ classmethod def parse_simple_timeformat ( cls , which ) :          if <str> in which :              hour , rest = which . split ( <str> )  else :              hour , rest = 0 , which  return int ( hour ) , int ( rest ) , 0  def __new__ ( cls , * args , ** kwargs ) :          first = None if args :              first , rest = args [ 0 ] , args [ 1 : ]  _super = super ( ) . __new__ if first and not rest and not kwargs :              hour , minutes , seconds = cls . parse_simple_timeformat ( first ) return _super ( cls , hours = hour , minutes = minutes , seconds = seconds )  else :              return _super ( cls , * args , ** kwargs )    def daterange ( * args ) :      import operator from datetime import date , datetime if len ( args ) == 1 :          start , stop , step = None , args [ 0 ] , None  elif len ( args ) == 2 :          start , stop = args step = None  else :          start , stop , step = args  if not step and step is not None :          raise ValueError ( <str> % step )  if not start :          if not isinstance ( stop , ( date , datetime ) ) :              raise TypeError ( <str> )  else :              start = get_month_first ( stop )   else :          if stop is not None and not isinstance ( stop , ( date , datetime ) ) :              stop = start + timedelta ( days = stop )   if step is None or step > 0 :          compare = operator . lt  else :          compare = operator . gt  step = timedelta ( days = ( step if step else 1 ) ) def _generator ( ) :          current = start while stop is None or compare ( current , stop ) :              yield current current += step   return _generator ( )  class DateField :      def __init__ ( self , name , nullable = False ) :          self . name = name self . nullable = nullable  def __get__ ( self , instance , owner ) :          if instance is not None :              res = instance . __dict__ [ self . name ] return res  else :              return self   def __set__ ( self , instance , value ) :          if value in ( None , False ) :              if not self . nullable :                  raise ValueError ( <str> )  else :                  value = None   elif isinstance ( value , datetime ) :              value = value . date ( )  elif not isinstance ( value , date ) :              value = parse_date ( value )  instance . __dict__ [ self . name ] = value   class DateTimeField ( object ) :      def __init__ ( self , name , nullable = False , prefer_last_minute = False ) :          self . name = name self . nullable = nullable self . prefer_last_minute = prefer_last_minute  def __get__ ( self , instance , owner ) :          if instance is not None :              res = instance . __dict__ [ self . name ] return res  else :              return self   def __set__ ( self , instance , value ) :          if value in ( None , False ) :              if not self . nullable :                  raise ValueError ( <str> )  else :                  value = None   elif isinstance ( value , datetime ) :              pass  elif isinstance ( value , date ) :              if not self . prefer_last_minute :                  value = datetime ( value . year , value . month , value . day )  else :                  value = datetime ( value . year , value . month , value . day , 23 , 59 , 59 )   else :              try :                  value = parse_datetime ( value )  except ValueError :                  value = parse_date ( value ) self . __set__ ( instance , value ) return   instance . __dict__ [ self . name ] = value   class TimeSpan :      start_date = DateField ( <str> , nullable = True ) end_date = DateField ( <str> , nullable = True ) def __init__ ( self , start_date = None , end_date = None ) :          self . start_date = start_date self . end_date = end_date  @ classmethod def from_date ( self , date : date ) -> <str> :          return self ( start_date = date , end_date = date )  @ property def past_unbound ( self ) -> bool :          <str> return self . start_date is None  @ property def future_unbound ( self ) -> bool :          <str> return self . end_date is None  @ property def unbound ( self ) -> bool :          return self . future_unbound or self . past_unbound  @ property def bound ( self ) -> bool :          <str> return not self . unbound  @ property def valid ( self ) -> bool :          if self . bound :              return self . start_date <= self . end_date  else :              return True   def __contains__ ( self , other ) :          if isinstance ( other , date ) :              if self . start_date and self . end_date :                  return self . start_date <= other <= self . end_date  elif self . start_date :                  return self . start_date <= other  elif self . end_date :                  return other <= self . end_date  else :                  return True   else :              return False   def overlaps ( self , other ) :          return bool ( self & other )  def isdisjoint ( self , other ) :          return not self . overlaps ( other )  def __le__ ( self , other ) :          <str> return ( self & other ) == self  issubset = __le__ def __lt__ ( self , other ) :          <str> return self != other and self <= other  def __gt__ ( self , other ) :          <str> return self != other and self >= other  def __ge__ ( self , other ) :          <str> return ( self & other ) == other  issuperset = covers = __ge__ def __iter__ ( self ) :          yield self . start_date yield self . end_date  def __getitem__ ( self , index ) :          this = tuple ( self ) return this [ index ]  def __eq__ ( self , other : Union [ date , <str> ] ) -> bool :          if isinstance ( other , date ) :              other = type ( self ) . from_date ( other )  elif isinstance ( other , DateTimeSpan ) :              return other == self  if not isinstance ( other , TimeSpan ) :              return NotImplemented  return self . start_date == other . start_date and self . end_date == other . end_date  def __hash__ ( self ) :          return hash ( ( TimeSpan , self . start_date , self . end_date ) )  def __and__ ( self , other ) :          from xotl . tools . infinity import Infinity if isinstance ( other , _EmptyTimeSpan ) :              return other  elif isinstance ( other , date ) :              other = TimeSpan . from_date ( other )  elif isinstance ( other , DateTimeSpan ) :              return other & self  elif not isinstance ( other , TimeSpan ) :              raise TypeError ( <str> % type ( other ) . __name__ )  start = max ( self . start_date or - Infinity , other . start_date or - Infinity ) end = min ( self . end_date or Infinity , other . end_date or Infinity ) if start <= end :              if start is - Infinity :                  start = None  if end is Infinity :                  end = None  return type ( self ) ( start , end )  else :              return EmptyTimeSpan   __mul__ = __rmul__ = __rand__ = __and__ def __bool__ ( self ) :          return True  __nonzero__ = __bool__ def __len__ ( self ) :          if self . bound :              return ( self . end_date - self . start_date ) . days  else :              return NotImplemented   def __lshift__ ( self , delta ) :          import numbers if isinstance ( delta , numbers . Integral ) :              delta = timedelta ( days = delta )  start = self . start_date - delta if self . start_date else None end = self . end_date - delta if self . end_date else None return type ( self ) ( start , end )  def __rshift__ ( self , delta ) :          return self << - delta  def intersection ( self , * others ) :          <str> import operator from functools import reduce return reduce ( operator . mul , others , self )  def diff ( self , other ) :          if not self & other :              return self , EmptyTimeSpan  other = self & other if self == other :              return EmptyTimeSpan , EmptyTimeSpan  else :              assert self > other day = timedelta ( days = 1 ) if self . start_date == other . start_date :                  return ( EmptyTimeSpan , TimeSpan ( other . end_date + day , self . end_date ) , )  elif self . end_date == other . end_date :                  return ( TimeSpan ( self . start_date , other . start_date - day ) , EmptyTimeSpan , )  else :                  return ( TimeSpan ( self . start_date , other . start_date - day ) , TimeSpan ( other . end_date + day , self . end_date ) , )    def __repr__ ( self ) :          start , end = self return <str> % ( start . isoformat ( ) if start else None , end . isoformat ( ) if end else None , )  __str__ = __repr__  class _EmptyTimeSpan :      __slots__ = [ ] def __bool__ ( self ) :          return False  __nonzero__ = __bool__ def __contains__ ( self , which ) :          return False  def __eq__ ( self , which ) :          if isinstance ( which , ( TimeSpan , date , _EmptyTimeSpan ) ) :              return self is which  else :              return NotImplemented   def __ne__ ( self , other ) :          res = self == other if res is not NotImplemented :              return not res  else :              return res   def __le__ ( self , which ) :          if isinstance ( which , ( TimeSpan , date , _EmptyTimeSpan ) ) :              return True  else :              return NotImplemented   __ge__ = covers = __eq__ __lt__ = isdisjoint = __ne__ def __gt__ ( self , which ) :          if isinstance ( which , ( TimeSpan , date , _EmptyTimeSpan ) ) :              return True  else :              return NotImplemented   def __add__ ( self , which ) :          if isinstance ( which , ( TimeSpan , date , _EmptyTimeSpan ) ) :              return which  else :              raise TypeError   __or__ = __add__ def __mul__ ( self , other ) :          if isinstance ( other , ( TimeSpan , date , _EmptyTimeSpan ) ) :              return self  else :              raise TypeError   __and__ = __mul__ def __repr__ ( self ) :          return <str>  __str__ = __repr__ def __new__ ( cls ) :          res = getattr ( cls , <str> , None ) if res is None :              res = cls . _instance = super ( ) . __new__ ( cls )  return res  def __reduce__ ( self ) :          return type ( self ) , ( )  def __len__ ( self ) :          return 0  def __lshift__ ( self , delta ) :          return self  def __rshift__ ( self , delta ) :          return self   EmptyTimeSpan = _EmptyTimeSpan ( ) class SynchronizedField ( object ) :      def __init__ ( self , descriptor , setting_descriptor , set_throu_get = True ) :          self . descriptor = descriptor self . setting_descriptor = setting_descriptor self . set_throu_get = set_throu_get  def __get__ ( self , instance , owner ) :          return self . descriptor . __get__ ( instance , owner )  def __set__ ( self , instance , value ) :          from xotl . tools . context import context self . descriptor . __set__ ( instance , value ) if ( SynchronizedField , self . setting_descriptor ) not in context :              with context ( ( SynchronizedField , self . setting_descriptor ) ) :                  if self . set_throu_get :                      value = self . __get__ ( instance , type ( instance ) )  self . setting_descriptor . __set__ ( instance , value )     class DateTimeSpan ( TimeSpan ) :      start_datetime = SynchronizedField ( DateTimeField ( <str> , nullable = True ) , TimeSpan . start_date ) end_datetime = SynchronizedField ( DateTimeField ( <str> , nullable = True , prefer_last_minute = True ) , TimeSpan . end_date , ) start_date = SynchronizedField ( TimeSpan . start_date , start_datetime . descriptor ) end_date = SynchronizedField ( TimeSpan . end_date , end_datetime . descriptor ) def __init__ ( self , start_datetime = None , end_datetime = None ) :          self . start_datetime = start_datetime self . end_datetime = end_datetime  @ classmethod def from_datetime ( self , dt ) :          return self ( start_datetime = dt , end_datetime = dt )  @ classmethod def from_timespan ( self , ts ) :          if isinstance ( ts , DateTimeSpan ) :              return ts  else :              return self ( start_datetime = ts . start_date , end_datetime = ts . end_date )   @ property def past_unbound ( self ) :          <str> return self . start_datetime is None  @ property def future_unbound ( self ) :          <str> return self . end_datetime is None  @ property def unbound ( self ) :          return self . future_unbound or self . past_unbound  @ property def bound ( self ) :          <str> return not self . unbound  @ property def valid ( self ) :          if self . bound :              return self . start_datetime <= self . end_datetime  else :              return True   def __contains__ ( self , other ) :          if isinstance ( other , date ) :              if not isinstance ( other , datetime ) :                  other = datetime ( other . year , other . month , other . day )  if self . start_datetime and self . end_datetime :                  return self . start_datetime <= other <= self . end_datetime  elif self . start_datetime :                  return self . start_datetime <= other  elif self . end_datetime :                  return other <= self . end_datetime  else :                  return True   else :              return False   def overlaps ( self , other ) :          return bool ( self & other )  def isdisjoint ( self , other ) :          return not self . overlaps ( other )  def __le__ ( self , other ) :          <str> return ( self & other ) == self  issubset = __le__ def __lt__ ( self , other ) :          <str> return self != other and self <= other  def __gt__ ( self , other ) :          <str> return self != other and self >= other  def __ge__ ( self , other ) :          <str> return ( self & other ) == other  issuperset = covers = __ge__ def __iter__ ( self ) -> Iterator [ datetime ] :          yield self . start_datetime yield self . end_datetime  def __getitem__ ( self , index ) -> datetime :          this = tuple ( self ) return this [ index ]  def __eq__ ( self , other ) :          if isinstance ( other , date ) :              other = type ( self ) . from_datetime ( other )  elif isinstance ( other , TimeSpan ) and not isinstance ( other , DateTimeSpan ) :              other = self . from_timespan ( other )  elif not isinstance ( other , DateTimeSpan ) :              return NotImplemented  return ( self . start_datetime == other . start_datetime and self . end_datetime == other . end_datetime )  def __hash__ ( self ) :          return hash ( ( DateTimeSpan , self . start_datetime , self . end_datetime ) )  def __and__ ( self , other ) :          from xotl . tools . infinity import Infinity if isinstance ( other , _EmptyTimeSpan ) :              return other  elif isinstance ( other , date ) :              other = DateTimeSpan . from_datetime ( other )  elif isinstance ( other , TimeSpan ) :              other = DateTimeSpan . from_timespan ( other )  elif not isinstance ( other , TimeSpan ) :              raise TypeError ( <str> % type ( other ) . __name__ )  start = max ( self . start_datetime or - Infinity , other . start_datetime or - Infinity ) end = min ( self . end_datetime or Infinity , other . end_datetime or Infinity ) if start <= end :              if start is - Infinity :                  start = None  if end is Infinity :                  end = None  return type ( self ) ( start , end )  else :              return EmptyTimeSpan   __mul__ = __rmul__ = __rand__ = __and__ def __bool__ ( self ) :          return True  __nonzero__ = __bool__ def __lshift__ ( self , delta ) :          import numbers if isinstance ( delta , numbers . Integral ) :              delta = timedelta ( days = delta )  start = self . start_datetime - delta if self . start_datetime else None end = self . end_datetime - delta if self . end_datetime else None return type ( self ) ( start , end )  def __rshift__ ( self , delta ) :          return self << - delta  def intersection ( self , * others ) :          <str> import operator from functools import reduce return reduce ( operator . mul , others , self )  def diff ( self , other ) :          if not self & other :              return self , EmptyTimeSpan  other = self & other if self == other :              return EmptyTimeSpan , EmptyTimeSpan  else :              assert self > other sec = timedelta ( seconds = 1 ) if self . start_datetime == other . start_datetime :                  return ( EmptyTimeSpan , DateTimeSpan ( other . end_datetime + sec , self . end_datetime ) , )  elif self . end_datetime == other . end_datetime :                  return ( DateTimeSpan ( self . start_datetime , other . start_datetime - sec ) , EmptyTimeSpan , )  else :                  return ( DateTimeSpan ( self . start_datetime , other . start_datetime - sec ) , DateTimeSpan ( other . end_datetime + sec , self . end_datetime ) , )    def __repr__ ( self ) :          start , end = self return <str> % ( start . isoformat ( ) . replace ( <str> , <str> ) if start else None , end . isoformat ( ) . replace ( <str> , <str> ) if end else None , )  __str__ = __repr__  del IntEnum  