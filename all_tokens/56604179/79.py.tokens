import pytest from xoutil . objects import smart_copy def test_smart_copy ( ) :      class new :          def __init__ ( self , ** kw ) :              for k , v in kw . items ( ) :                  setattr ( self , k , v )    source = new ( a = 1 , b = 2 , c = 4 , _d = 5 ) target = { } smart_copy ( source , target , defaults = False ) assert target == dict ( a = 1 , b = 2 , c = 4 ) source = new ( a = 1 , b = 2 , c = 4 , _d = 5 ) target = { } smart_copy ( source , target , defaults = None ) assert target == dict ( a = 1 , b = 2 , c = 4 ) target = { } smart_copy ( source , target , defaults = True ) assert target [ <str> ] == 5  def test_smart_copy_with_defaults ( ) :      defaults = { <str> : <str> , <str> : 5432 , <str> : <str> , <str> : ( KeyError , <str> ) } kwargs = { <str> : <str> } args = smart_copy ( kwargs , { } , defaults = defaults ) assert args == dict ( host = <str> , port = 5432 , user = <str> , password = <str> ) with pytest . raises ( KeyError ) :          args = smart_copy ( { } , { } , defaults = defaults )   def test_smart_copy_signature ( ) :      with pytest . raises ( TypeError ) :          smart_copy ( { } , defaults = False )   def test_smart_copy_from_dict_to_dict ( ) :      c = dict ( c = 1 , d = 23 ) d = dict ( d = 1 ) smart_copy ( c , d ) assert d == dict ( c = 1 , d = 23 )  def test_smart_copy_with_plain_defaults ( ) :      c = dict ( a = 1 , b = 2 , c = 3 ) d = { } smart_copy ( c , d , defaults = ( <str> , <str> ) ) assert d == dict ( a = 1 , x = None )  def test_smart_copy_with_callable_default ( ) :      def default ( attr , source = None ) :          return attr in ( <str> , <str> )  c = dict ( a = 1 , b = <str> , c = <str> ) d = { } smart_copy ( c , d , defaults = default ) assert d == dict ( a = 1 , b = <str> ) class inset :          def __init__ ( self , items ) :              self . items = items  def __call__ ( self , attr , source = None ) :              return attr in self . items   c = dict ( a = 1 , b = <str> , c = <str> ) d = { } smart_copy ( c , d , defaults = inset ( <str> ) ) assert d == dict ( a = 1 , b = <str> )  def test_fulldir ( ) :      from xoutil . objects import fulldir assert { <str> , <str> , <str> , <str> } < fulldir ( { } )  def test_newstyle_metaclass ( ) :      class Field :          __slots__ = ( str ( <str> ) , str ( <str> ) ) def __init__ ( self , default ) :              self . default = default  def __get__ ( self , inst , owner ) :              if not inst :                  return self  return self . default   class ModelType ( type ) :          pass  class Base :          def __init__ ( self , ** attrs ) :              self . __dict__ . update ( attrs )   class Model ( metaclass = ModelType ) :          f1 = Field ( 1009 ) f2 = 0 def __init__ ( self , ** attrs ) :              self . __dict__ . update ( attrs )   class Model2 ( Base , metaclass = ModelType ) :          pass  class SubMeta ( ModelType ) :          pass  class Submodel ( Model , metaclass = SubMeta ) :          pass  inst = Model ( name = <str> ) assert inst . f1 == 1009 assert inst . name == <str> assert isinstance ( Model . f1 , Field ) assert type ( Model ) is ModelType assert type ( Submodel ) is SubMeta assert type ( Model2 ) is ModelType assert Model2 . __base__ is Base assert Submodel . __base__ is Model assert Model . __base__ is object  def test_new_style_metaclass_registration ( ) :      class BaseMeta ( type ) :          classes = [ ] def __new__ ( cls , name , bases , attrs ) :              res = super ( BaseMeta , cls ) . __new__ ( cls , name , bases , attrs ) cls . classes . append ( res ) return res   class Base ( metaclass = BaseMeta ) :          pass  class SubType ( BaseMeta ) :          pass  class Egg ( Base , metaclass = SubType ) :          pass  assert Egg . __base__ is Base assert len ( BaseMeta . classes ) == 2 class Spam ( Base , metaclass = SubType ) :          <str>  assert len ( BaseMeta . classes ) == 3 assert Spam . __bases__ == ( Base , )  def test_lazy ( ) :      from xoutil . objects import lazy , setdefaultattr class new :          pass  inst = new ( ) setter = lambda a : - a setdefaultattr ( inst , <str> , lazy ( setter , 10 ) ) assert inst . c == - 10 setdefaultattr ( inst , <str> , lazy ( setter , 20 ) ) assert inst . c == - 10  class new :      def __init__ ( self , ** kwargs ) :          attrs = { } children = { } for attr , value in kwargs . items ( ) :              if <str> in attr :                  name , childattr = attr . split ( <str> , 1 ) child = children . setdefault ( name , { } ) child [ childattr ] = value  else :                  attrs [ attr ] = value   self . __dict__ . update ( attrs ) assert set ( attrs . keys ( ) ) & set ( children . keys ( ) ) == set ( ) for child , vals in children . items ( ) :              setattr ( self , child , new ( ** vals ) )    def test_traversing ( ) :      from xoutil . objects import traverse , get_traverser obj = new ( ** { <str> : 1 , <str> : { <str> : 2 } , <str> : 3 } ) assert traverse ( obj , <str> ) == 1 assert traverse ( obj , <str> ) == 2 assert traverse ( obj , <str> ) == 3 with pytest . raises ( AttributeError ) :          traverse ( obj , <str> )  with pytest . raises ( AttributeError ) :          traverse ( obj , <str> )  traverser = get_traverser ( <str> , <str> , <str> ) with pytest . raises ( AttributeError ) :          traverser ( obj )  obj . b . c . d [ <str> ] = None assert traverser ( obj ) == ( 1 , 2 , None )  def test_traversing_bug_ignoring_getter ( ) :      import mock from xoutil . objects import traverse sentinel = object ( ) class Me :          def __getattr__ ( self , attr ) :              return self   return_sentinel = mock . Mock ( return_value = sentinel ) me = Me ( ) assert traverse ( me , <str> , getter = return_sentinel ) is sentinel assert return_sentinel . called  def test_dict_merge_base_cases ( ) :      from xoutil . objects import dict_merge base = { <str> : <str> , <str> : { <str> : 2 } } assert dict_merge ( ) == { } assert dict_merge ( base ) == base assert dict_merge ( ** base ) == base  def test_dict_merge_simple_cases ( ) :      from xoutil . objects import dict_merge first = { <str> : { <str> : 1 } , <str> : { <str> : 1 } , <str> : 194 , <str> : 1 } second = { <str> : { <str> : 2 } , <str> : { <str> : 2 } , <str> : 195 , <str> : 2 } expected = { <str> : { <str> : 1 , <str> : 2 } , <str> : { <str> : 1 , <str> : 2 } , <str> : 194 , <str> : 195 , <str> : 2 } assert dict_merge ( first , second ) == expected assert dict_merge ( first , ** second ) == expected assert dict_merge ( second , first ) == dict ( expected , shared = 1 ) assert dict_merge ( second , ** first ) == dict ( expected , shared = 1 )  def test_dict_merge_compatible_cases ( ) :      from xoutil . objects import dict_merge first = { 192 : [ <str> , 1 ] , 193 : { <str> , 1 } } second = { 192 : ( <str> , 2 ) , 193 : [ <str> , 2 ] } assert dict_merge ( first , second ) == { 192 : [ <str> , 1 , <str> , 2 ] , 193 : { <str> , 1 , <str> , 2 } } result = dict_merge ( second , first ) assert result [ 192 ] == ( <str> , 2 , <str> , 1 ) key_193 = result [ 193 ] assert key_193 [ : 2 ] == [ <str> , 2 ] assert key_193 . index ( <str> ) in ( 2 , 3 ) assert key_193 . index ( 1 ) in ( 2 , 3 )  def test_dict_merge_errors ( ) :      from xoutil . objects import dict_merge first = { 192 : 192 } second = { 192 : [ 192 ] } with pytest . raises ( TypeError ) :          dict_merge ( second , first )  with pytest . raises ( TypeError ) :          dict_merge ( first , second )   def test_get_first_of ( ) :      from xoutil . objects import get_first_of somedict = { <str> : <str> , <str> : <str> } assert get_first_of ( somedict , <str> , <str> , <str> ) == <str> somedict = { <str> : <str> , <str> : <str> } assert get_first_of ( somedict , <str> ) is None class Someobject :          pass  inst = Someobject ( ) inst . foo = <str> inst . eggs = <str> assert get_first_of ( inst , <str> , <str> , <str> ) == <str> assert get_first_of ( inst , <str> ) is None somedict = { <str> : <str> , <str> : <str> } class Someobject :          pass  inst = Someobject ( ) inst . foo = <str> inst . eggs = <str> assert get_first_of ( ( somedict , inst ) , <str> ) == <str> assert get_first_of ( ( somedict , inst ) , <str> ) == <str> assert get_first_of ( ( inst , somedict ) , <str> ) == <str> assert get_first_of ( ( inst , somedict ) , <str> ) is None none = object ( ) assert get_first_of ( ( inst , somedict ) , <str> , default = none ) is none _eggs = get_first_of ( somedict , <str> , <str> , pred = lambda v : len ( v ) > 3 ) assert _eggs == <str> _none = get_first_of ( somedict , <str> , <str> , pred = lambda v : len ( v ) > 4 ) assert _none is None with pytest . raises ( TypeError ) :          get_first_of ( None , anything = 1 )   def test_smart_getter ( ) :      from xoutil . objects import smart_getter class new :          pass  o = new ( ) o . attr1 = 1 o . attr2 = 1 getter = smart_getter ( o ) assert getter ( <str> ) == getter ( <str> ) == 1 assert getter ( <str> ) is None getter = smart_getter ( o , strict = True ) assert getter ( <str> ) == getter ( <str> ) == 1 with pytest . raises ( AttributeError ) :          assert getter ( <str> ) is None  d = { <str> : 1 , <str> : 1 } getter = smart_getter ( d ) assert getter ( <str> ) == getter ( <str> ) == 1 assert getter ( <str> ) is None getter = smart_getter ( d , strict = True ) assert getter ( <str> ) == getter ( <str> ) == 1 with pytest . raises ( KeyError ) :          assert getter ( <str> ) is None  assert getter ( <str> , None ) is None  def test_smart_setter ( ) :      from xoutil . objects import smart_setter class new :          pass  o = new ( ) setter = smart_setter ( o ) setter ( <str> , 1 ) setter ( <str> , 1 ) assert o . attr1 == o . attr2 == 1 d = { <str> : 1 , <str> : 1 } setter = smart_setter ( d ) setter ( <str> , 10 ) assert d [ <str> ] == 10  def test_extract_attrs ( ) :      from xoutil . objects import extract_attrs d = dict ( a = ( 1 , ) , b = 2 , c = 3 , x = 4 ) assert extract_attrs ( d , <str> ) == ( 1 , ) assert extract_attrs ( d , <str> , <str> , <str> , <str> ) == ( ( 1 , ) , 2 , 3 , 4 ) with pytest . raises ( AttributeError ) :          assert extract_attrs ( d , <str> )  assert extract_attrs ( d , <str> , default = None ) is None class new :          def __init__ ( self , ** kw ) :              self . __dict__ . update ( kw )   d = new ( a = ( 1 , ) , b = 2 , c = 3 , x = 4 ) assert extract_attrs ( d , <str> ) == ( 1 , ) assert extract_attrs ( d , <str> , <str> , <str> , <str> ) == ( ( 1 , ) , 2 , 3 , 4 ) with pytest . raises ( AttributeError ) :          assert extract_attrs ( d , <str> )  assert extract_attrs ( d , <str> , default = None ) is None  def test_copy_class ( ) :      from xoutil . symbols import Unset from xoutil . objects import copy_class u = str class MetaFoo ( type ) :          pass  class Foo ( metaclass = MetaFoo ) :          a = 1 b = 2 c = 3 d = 4  class Baz ( Foo ) :          e = 5  index = { k : getattr ( Foo , k ) for k in <str> } Bar = copy_class ( Foo ) assert Bar . a == Foo . a and Bar . b and Bar . c and Bar . d Egg = copy_class ( Foo , ignores = [ <str> , <str> ] ) assert getattr ( Egg , <str> , Unset ) is Unset Egg = copy_class ( Foo , ignores = [ lambda k : index . get ( k ) and index . get ( k ) > 2 ] ) assert Egg . a == Foo . a assert getattr ( Egg , <str> , Unset ) is Unset Named = copy_class ( Foo , new_name = <str> ) assert Named . __name__ == <str> Named = copy_class ( Foo , new_name = u ( <str> ) ) assert Named . __name__ == <str> import fnmatch pattern = lambda attr : fnmatch . fnmatch ( attr , <str> ) Egg = copy_class ( Foo , ignores = [ pattern ] ) assert getattr ( Egg , <str> , Unset ) is Unset import re _pattern = re . compile ( <str> ) pattern = lambda attr : _pattern . match ( attr ) Egg = copy_class ( Foo , ignores = [ pattern ] ) assert getattr ( Egg , <str> , Unset ) is Unset  def test_validate_attrs ( ) :      from xoutil . objects import validate_attrs class Person :          def __init__ ( self , ** kwargs ) :              for which in kwargs :                  setattr ( self , which , kwargs [ which ] )    source = Person ( name = <str> , age = 33 , sex = <str> ) target = { <str> : <str> , <str> : 4 , <str> : <str> } assert validate_attrs ( source , target , force_equals = ( <str> , ) , force_differents = ( <str> , ) ) assert not validate_attrs ( source , target , force_equals = ( <str> , ) )  @ pytest . mark . xfail ( ) def test_memoized_classproperty ( ) :      from xoutil . objects import memoized_property from xoutil . objects import classproperty current = 1 class Foobar :          @ memoized_property @ classproperty def prop ( cls ) :              return current  @ classproperty @ memoized_property def prop2 ( cls ) :              return current   assert Foobar . prop == current current += 1 assert Foobar . prop != current  def test_properties ( ) :      from xoutil . objects import xproperty , classproperty , staticproperty _x = <str> class Foobar :          _x = <str> def __init__ ( self ) :              self . _x = <str>  @ xproperty def x ( self ) :              return self . _x  @ classproperty def cprop ( cls ) :              return cls . _x  @ staticproperty def sprop ( ) :              return _x   f = Foobar ( ) assert Foobar . x == <str> assert f . x == <str> assert Foobar . cprop == <str> assert f . cprop == <str> assert Foobar . sprop == <str> assert f . sprop == <str>  def test_multi_getter_failure ( ) :      from xoutil . objects import multi_getter from xoutil . objects import traverse class new :          def __init__ ( self , ** k ) :              self . __dict__ . update ( k )   top = new ( d = dict ( a = 1 , b = 2 ) , a = 10 , b = 20 ) assert traverse ( top , <str> ) == 1 assert next ( multi_getter ( top , ( <str> , <str> ) ) ) == { <str> : 1 , <str> : 2 }  def test_save_attributes ( ) :      from xoutil . future . types import SimpleNamespace as new from xoutil . objects import save_attributes obj = new ( a = 1 , b = 2 ) with save_attributes ( obj , <str> ) :          obj . a = 2 obj . b = 3 assert obj . a == 2  assert obj . a == 1 assert obj . b == 3  def test_temp_attributes ( ) :      from xoutil . future . types import SimpleNamespace as new from xoutil . objects import temp_attributes obj = new ( a = 1 , b = 2 ) with temp_attributes ( obj , dict ( a = 2 ) ) :          assert obj . a == 2 assert obj . b == 2 obj . b = 3  assert obj . a == 1 assert obj . b == 3  def test_save_raises_errors ( ) :      from xoutil . future . types import SimpleNamespace as new from xoutil . objects import save_attributes getter = lambda o : lambda a : getattr ( o , a ) obj = new ( a = 1 , b = 2 ) with pytest . raises ( AttributeError ) :          with save_attributes ( obj , <str> , getter = getter ) :              pass   with save_attributes ( obj , <str> ) :          pass  assert obj . x is None obj = object ( ) with pytest . raises ( AttributeError ) :          with save_attributes ( obj , <str> ) :              pass    def test_import_object ( ) :      from xoutil . objects import import_object assert import_object ( <str> ) is import_object assert import_object ( <str> ) is import_object  def test_delegator ( ) :      from xoutil . objects import delegator class Bar :          x = object ( )  class Foo ( delegator ( <str> , { <str> : <str> , <str> : <str> } ) ) :          def __init__ ( self ) :              self . egg = Bar ( )   foo = Foo ( ) assert foo . x1 is foo . egg . x with pytest . raises ( AttributeError ) :          foo . x2   def test_final_subclasses ( ) :      from xoutil . objects import get_final_subclasses class Base :          pass  class Subclass ( Base ) :          pass  class Final ( Subclass ) :          pass  class SubSub ( Subclass ) :          pass  class Final2 ( SubSub ) :          pass  assert set ( get_final_subclasses ( Base ) ) == { Final , Final2 } assert set ( get_final_subclasses ( Final , include_this = False ) ) == set ( [ ] )  def test_FinalSubclassEnumeration ( ) :      from xoutil . objects import FinalSubclassEnumeration class Base :          pass  enum = FinalSubclassEnumeration ( Base ) enum2 = FinalSubclassEnumeration ( Base , dynamic = False ) assert not enum . __members__ assert not enum2 . __members__ class Subclass ( Base ) :          pass  class Final ( Subclass ) :          pass  assert enum . Final is Final assert not enum2 . __members__ enum2 . invalidate_cache ( ) assert enum2 . Final is Final   