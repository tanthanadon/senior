import types import warnings from functools import wraps DEFAULT_MSG = ( <str> <str> ) class DeprecationError ( Exception ) :      pass  class DeprecatedImportDescriptor :      <str> def __init__ ( self , replacement ) :          self . attr = replacement [ replacement . rfind ( <str> ) + 1 : ] self . replacement = replacement  def __get__ ( self , instance , owner ) :          if instance is not None :              import warnings from xotl . tools . objects import import_object result = import_object ( self . replacement ) warnings . warn ( <str> <str> . format ( name = self . attr , ns = self . replacement ) , UserWarning , ) return result  else :              return self    def _nameof ( item ) :      <str> singletons = ( None , True , False , Ellipsis , NotImplemented ) res = next ( ( str ( s ) for s in singletons if s is item ) , None ) if res is None :          res = <str> . join ( [ item . __module__ , item . __name__ ] )  return res  def deprecated ( replacement , msg = DEFAULT_MSG , deprecated_module = None , removed_in_version = None , check_version = False , new_name = None , ) :      def raise_if_deprecated ( target , target_version ) :          import pkg_resources pkg = _nameof ( target ) pkg , _obj = pkg . rsplit ( <str> , 1 ) dist = None while not dist and pkg :              try :                  dist = pkg_resources . get_distribution ( pkg )  except pkg_resources . DistributionNotFound :                  dist = None if <str> in pkg :                      pkg , _obj = pkg . rsplit ( <str> , 1 )  else :                      pkg , _obj = None , None    assert dist if isinstance ( target_version , str ) :              target_version = pkg_resources . parse_version ( target_version )  if dist . parsed_version >= target_version :              msg = ( <str> <str> <str> % ( _nameof ( target ) , str ( removed_in_version ) , str ( dist . version ) ) ) raise DeprecationError ( msg )   def decorator ( target ) :          target_name = new_name if new_name else target . __name__ if deprecated_module :              funcname = deprecated_module + <str> + target_name  else :              funcname = target_name  if isinstance ( replacement , ( type , types . FunctionType ) ) :              repl_name = replacement . __module__ + <str> + replacement . __name__  else :              repl_name = replacement  if removed_in_version :              in_version = <str> + removed_in_version  else :              in_version = <str>  if isinstance ( target , type ) :              def new ( * args , ** kwargs ) :                  if check_version and removed_in_version :                      raise_if_deprecated ( target , removed_in_version )  warnings . warn ( msg . format ( funcname = funcname , replacement = repl_name , in_version = in_version ) , stacklevel = 2 , ) try :                      return target . __new__ ( * args , ** kwargs )  except TypeError :                      return super ( result , args [ 0 ] ) . __new__ ( args [ 0 ] )   from xotl . tools . future . types import MemberDescriptorType meta = type ( target ) td = target . __dict__ iteritems = td . items attrs = { name : value for name , value in iteritems ( ) if name not in ( <str> , <str> , <str> , <str> , <str> ) if not isinstance ( value , MemberDescriptorType ) } attrs . update ( __new__ = new ) result = meta ( target_name , target . __bases__ , attrs ) return result  else :              @ wraps ( target ) def inner ( * args , ** kw ) :                  if check_version and removed_in_version :                      raise_if_deprecated ( target , removed_in_version )  warnings . warn ( msg . format ( funcname = funcname , replacement = repl_name , in_version = in_version ) , stacklevel = 2 , ) return target ( * args , ** kw )  if new_name :                  inner . __name__ = new_name  return inner   return decorator  def import_deprecated ( module , * names , ** aliases ) :      from xotl . tools . future . types import func_types from xotl . tools . modules import force_module src = force_module ( module ) dst = force_module ( 2 ) src_name = src . __name__ dst_name = dst . __name__ dst = force_module ( 2 ) if not names and not aliases :          names = getattr ( src , <str> , None ) if not names :              names = ( n for n in dir ( src ) if not n . startswith ( <str> ) )   for name in names :          if name not in aliases :              aliases [ name ] = name  else :              msg = <str> raise ValueError ( msg . format ( name ) )   unset = object ( ) test_classes = func_types + ( type , ) for alias in aliases :          name = aliases [ alias ] target = getattr ( src , name , unset ) if target is not unset :              if isinstance ( target , test_classes ) :                  replacement = src_name + <str> + name deprecator = deprecated ( replacement , DEFAULT_MSG , dst_name , new_name = alias ) target = deprecator ( target )  setattr ( dst , alias , target )  else :              msg = <str> raise ImportError ( msg . format ( name , src_name ) )    def deprecate_linked ( check = None , msg = None ) :      import inspect check = check or <str> frame = inspect . currentframe ( ) . f_back try :          name = frame . f_globals . get ( <str> )  finally :          del frame  if check not in name :          if msg is None :              msg = ( <str> <str> ) . format ( name , check )  warnings . warn ( msg , stacklevel = 2 )   def deprecate_module ( replacement , msg = None ) :      import inspect frame = inspect . currentframe ( ) . f_back try :          name = frame . f_globals . get ( <str> )  finally :          del frame  if msg is None :          msg = ( <str> <str> ) . format ( name , replacement )  if msg :          warnings . warn ( msg , stacklevel = 2 )   @ deprecated ( import_deprecated ) def inject_deprecated ( funcnames , source , target = None ) :      if not target :          import sys frame = sys . _getframe ( 1 ) try :              target_locals = frame . f_locals  finally :              del frame   else :          pass  for targetname in funcnames :          unset = object ( ) target = getattr ( source , targetname , unset ) if target is not unset :              testclasses = ( types . FunctionType , types . LambdaType , type ) if isinstance ( target , testclasses ) :                  replacement = source . __name__ + <str> + targetname module_name = target_locals . get ( <str> , None ) target_locals [ targetname ] = deprecated ( replacement , DEFAULT_MSG , module_name ) ( target )  else :                  target_locals [ targetname ] = target   else :              warnings . warn ( <str> . format ( targetname = targetname , source = source . __name__ ) , stacklevel = 2 , )    def deprecated_alias ( f , ** kwargs ) :      return deprecated ( f , ** kwargs ) ( f )   