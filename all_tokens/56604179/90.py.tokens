import sys import unittest from random import shuffle from xoutil . future . collections import defaultdict class TestCollections ( unittest . TestCase ) :      def test_defaultdict ( self ) :          d = defaultdict ( lambda key , _ : <str> ) self . assertEqual ( <str> , d [ <str> ] ) d [ <str> ] = 1 self . assertEqual ( 1 , d [ <str> ] )  def test_defaultdict_clone ( self ) :          d = defaultdict ( lambda key , d : d [ <str> ] , { <str> : <str> } ) self . assertEqual ( <str> , d [ <str> ] ) d = defaultdict ( lambda key , d : d [ key ] ) with self . assertRaises ( KeyError ) :              d [ <str> ]    def test_stacked_dict_with_newpop ( ) :      from xoutil . future . collections import StackedDict sd = StackedDict ( a = <str> , b = 1 ) assert sd . pop ( <str> ) == <str> assert sd . pop ( <str> , sd ) is sd try :          sd . pop ( <str> )  except KeyError :          pass  else :          assert False , <str>   def test_stacked_dict ( ) :      from xoutil . future . collections import StackedDict sd = StackedDict ( a = <str> ) assert sd . peek ( ) == dict ( a = <str> ) sd . push_level ( a = 1 , b = 2 , c = 10 ) assert sd . level == 1 assert sd . peek ( ) == dict ( a = 1 , b = 2 , c = 10 ) sd . push_level ( b = 4 , c = 5 ) assert sd . peek ( ) == dict ( b = 4 , c = 5 ) assert sd . level == 2 assert sd [ <str> ] == 4 assert sd [ <str> ] == 1 assert sd [ <str> ] == 5 assert len ( sd ) == 3 del sd [ <str> ] try :          del sd [ <str> ] assert False , <str>  except KeyError :          pass  except :          assert False , <str>  assert sd . pop_level ( ) == { <str> : 4 } assert sd [ <str> ] == 2 assert sd [ <str> ] == 1 assert len ( sd ) == 3 sd . pop_level ( ) assert sd [ <str> ] == <str> try :          sd . pop_level ( ) assert False , ( <str> <str> )  except TypeError :          pass  except :          assert False , ( <str> <str> )   from xoutil . future . collections import ChainMap , Counter from xoutil . future . collections import OrderedDict , RankedDict from xoutil . future . collections import Mapping , MutableMapping import copy import pickle from random import randrange def _items ( d ) :      <str> from xoutil . versions import python_version res = d . items ( ) if python_version . pypy and isinstance ( res , list ) :          res . sort ( )  return res  class TestChainMap ( unittest . TestCase ) :      def test_basics ( self ) :          c = ChainMap ( ) c [ <str> ] = 1 c [ <str> ] = 2 d = c . new_child ( ) d [ <str> ] = 20 d [ <str> ] = 30 self . assertEqual ( d . maps , [ { <str> : 20 , <str> : 30 } , { <str> : 1 , <str> : 2 } ] ) self . assertEqual ( _items ( d ) , _items ( dict ( a = 1 , b = 20 , c = 30 ) ) ) self . assertEqual ( len ( d ) , 3 ) for key in <str> :              self . assertIn ( key , d )  for k , v in dict ( a = 1 , b = 20 , c = 30 , z = 100 ) . items ( ) :              self . assertEqual ( d . get ( k , 100 ) , v )  del d [ <str> ] self . assertEqual ( d . maps , [ { <str> : 30 } , { <str> : 1 , <str> : 2 } ] ) self . assertEqual ( _items ( d ) , _items ( dict ( a = 1 , b = 2 , c = 30 ) ) ) self . assertEqual ( len ( d ) , 3 ) for key in <str> :              self . assertIn ( key , d )  for k , v in dict ( a = 1 , b = 2 , c = 30 , z = 100 ) . items ( ) :              self . assertEqual ( d . get ( k , 100 ) , v )  self . assertIn ( repr ( d ) , [ type ( d ) . __name__ + <str> , type ( d ) . __name__ + <str> , ] , ) for e in d . copy ( ) , copy . copy ( d ) :              self . assertEqual ( d , e ) self . assertEqual ( d . maps , e . maps ) self . assertIsNot ( d , e ) self . assertIsNot ( d . maps [ 0 ] , e . maps [ 0 ] ) for m1 , m2 in zip ( d . maps [ 1 : ] , e . maps [ 1 : ] ) :                  self . assertIs ( m1 , m2 )   for e in [ pickle . loads ( pickle . dumps ( d ) ) , copy . deepcopy ( d ) , eval ( repr ( d ) ) , ] :              self . assertEqual ( d , e ) self . assertEqual ( d . maps , e . maps ) self . assertIsNot ( d , e ) for m1 , m2 in zip ( d . maps , e . maps ) :                  self . assertIsNot ( m1 , m2 , e )   f = d . new_child ( ) f [ <str> ] = 5 self . assertEqual ( f . maps , [ { <str> : 5 } , { <str> : 30 } , { <str> : 1 , <str> : 2 } ] ) self . assertEqual ( f . parents . maps , [ { <str> : 30 } , { <str> : 1 , <str> : 2 } ] ) self . assertEqual ( f [ <str> ] , 5 ) self . assertEqual ( f . parents [ <str> ] , 2 )  def test_contructor ( self ) :          self . assertEqual ( ChainMap ( ) . maps , [ { } ] ) self . assertEqual ( ChainMap ( { 1 : 2 } ) . maps , [ { 1 : 2 } ] )  def test_bool ( self ) :          self . assertFalse ( ChainMap ( ) ) self . assertFalse ( ChainMap ( { } , { } ) ) self . assertTrue ( ChainMap ( { 1 : 2 } , { } ) ) self . assertTrue ( ChainMap ( { } , { 1 : 2 } ) )  def test_missing ( self ) :          class DefaultChainMap ( ChainMap ) :              def __missing__ ( self , key ) :                  return 999   d = DefaultChainMap ( dict ( a = 1 , b = 2 ) , dict ( b = 20 , c = 30 ) ) for k , v in dict ( a = 1 , b = 2 , c = 30 , d = 999 ) . items ( ) :              self . assertEqual ( d [ k ] , v )  for k , v in dict ( a = 1 , b = 2 , c = 30 , d = 77 ) . items ( ) :              self . assertEqual ( d . get ( k , 77 ) , v )  for k , v in dict ( a = True , b = True , c = True , d = False ) . items ( ) :              self . assertEqual ( k in d , v )  self . assertEqual ( d . pop ( <str> , 1001 ) , 1 , d ) self . assertEqual ( d . pop ( <str> , 1002 ) , 1002 ) self . assertEqual ( d . popitem ( ) , ( <str> , 2 ) ) with self . assertRaises ( KeyError ) :              d . popitem ( )   def test_dict_coercion ( self ) :          d = ChainMap ( dict ( a = 1 , b = 2 ) , dict ( b = 20 , c = 30 ) ) self . assertEqual ( dict ( d ) , dict ( a = 1 , b = 2 , c = 30 ) ) self . assertEqual ( dict ( d . items ( ) ) , dict ( a = 1 , b = 2 , c = 30 ) )  def test_new_child ( self ) :          <str> c = ChainMap ( ) c [ <str> ] = 1 c [ <str> ] = 2 m = { <str> : 20 , <str> : 30 } d = c . new_child ( m ) self . assertEqual ( d . maps , [ { <str> : 20 , <str> : 30 } , { <str> : 1 , <str> : 2 } ] ) self . assertIs ( m , d . maps [ 0 ] ) class lowerdict ( dict ) :              def __getitem__ ( self , key ) :                  if isinstance ( key , str ) :                      key = key . lower ( )  return dict . __getitem__ ( self , key )  def __contains__ ( self , key ) :                  if isinstance ( key , str ) :                      key = key . lower ( )  return dict . __contains__ ( self , key )   c = ChainMap ( ) c [ <str> ] = 1 c [ <str> ] = 2 m = lowerdict ( b = 20 , c = 30 ) d = c . new_child ( m ) self . assertIs ( m , d . maps [ 0 ] ) for key in <str> :              self . assertIn ( key , d )  for k , v in dict ( a = 1 , B = 20 , C = 30 , z = 100 ) . items ( ) :              self . assertEqual ( d . get ( k , 100 ) , v )    class TestCounter ( unittest . TestCase ) :      def test_basics ( self ) :          c = Counter ( <str> ) self . assertEqual ( c , Counter ( { <str> : 3 , <str> : 2 , <str> : 1 } ) ) self . assertEqual ( c , Counter ( a = 3 , b = 2 , c = 1 ) ) self . assertIsInstance ( c , dict ) self . assertIsInstance ( c , Mapping ) self . assertTrue ( issubclass ( Counter , dict ) ) self . assertTrue ( issubclass ( Counter , Mapping ) ) self . assertEqual ( len ( c ) , 3 ) self . assertEqual ( sum ( c . values ( ) ) , 6 ) self . assertEqual ( sorted ( c . values ( ) ) , [ 1 , 2 , 3 ] ) self . assertEqual ( sorted ( c . keys ( ) ) , [ <str> , <str> , <str> ] ) self . assertEqual ( sorted ( c ) , [ <str> , <str> , <str> ] ) self . assertEqual ( sorted ( c . items ( ) ) , [ ( <str> , 3 ) , ( <str> , 2 ) , ( <str> , 1 ) ] ) self . assertEqual ( c [ <str> ] , 2 ) self . assertEqual ( c [ <str> ] , 0 ) self . assertEqual ( c . __contains__ ( <str> ) , True ) self . assertEqual ( c . __contains__ ( <str> ) , False ) self . assertEqual ( c . get ( <str> , 10 ) , 2 ) self . assertEqual ( c . get ( <str> , 10 ) , 10 ) self . assertEqual ( c , dict ( a = 3 , b = 2 , c = 1 ) ) self . assertEqual ( repr ( c ) , <str> ) self . assertEqual ( c . most_common ( ) , [ ( <str> , 3 ) , ( <str> , 2 ) , ( <str> , 1 ) ] ) for i in range ( 5 ) :              self . assertEqual ( c . most_common ( i ) , [ ( <str> , 3 ) , ( <str> , 2 ) , ( <str> , 1 ) ] [ : i ] )  self . assertEqual ( <str> . join ( sorted ( c . elements ( ) ) ) , <str> ) c [ <str> ] += 1 c [ <str> ] -= 2 del c [ <str> ] del c [ <str> ] c [ <str> ] -= 2 c [ <str> ] = - 5 c [ <str> ] += 4 self . assertEqual ( c , dict ( a = 4 , b = 0 , d = - 2 , e = - 5 , f = 4 ) ) self . assertEqual ( <str> . join ( sorted ( c . elements ( ) ) ) , <str> ) self . assertEqual ( c . pop ( <str> ) , 4 ) self . assertNotIn ( <str> , c ) for i in range ( 3 ) :              elem , cnt = c . popitem ( ) self . assertNotIn ( elem , c )  c . clear ( ) self . assertEqual ( c , { } ) self . assertEqual ( repr ( c ) , <str> ) self . assertRaises ( NotImplementedError , Counter . fromkeys , <str> ) self . assertRaises ( TypeError , hash , c ) c . update ( dict ( a = 5 , b = 3 ) ) c . update ( c = 1 ) c . update ( Counter ( <str> * 50 + <str> * 30 ) ) c . update ( ) c . __init__ ( <str> * 500 + <str> * 300 ) c . __init__ ( <str> ) c . __init__ ( ) self . assertEqual ( c , dict ( a = 555 , b = 333 , c = 3 , d = 1 ) ) self . assertEqual ( c . setdefault ( <str> , 5 ) , 1 ) self . assertEqual ( c [ <str> ] , 1 ) self . assertEqual ( c . setdefault ( <str> , 5 ) , 5 ) self . assertEqual ( c [ <str> ] , 5 )  def test_copying ( self ) :          words = Counter ( <str> . split ( ) ) update_test = Counter ( ) update_test . update ( words ) for i , dup in enumerate ( [ words . copy ( ) , copy . copy ( words ) , copy . deepcopy ( words ) , pickle . loads ( pickle . dumps ( words , 0 ) ) , pickle . loads ( pickle . dumps ( words , 1 ) ) , pickle . loads ( pickle . dumps ( words , 2 ) ) , pickle . loads ( pickle . dumps ( words , - 1 ) ) , eval ( repr ( words ) ) , update_test , Counter ( words ) , ] ) :              self . assertTrue ( dup is not words ) self . assertEqual ( dup , words ) self . assertEqual ( len ( dup ) , len ( words ) ) self . assertEqual ( type ( dup ) , type ( words ) )   def test_copy_subclass ( self ) :          class MyCounter ( Counter ) :              pass  c = MyCounter ( <str> ) d = c . copy ( ) self . assertEqual ( d , c ) self . assertEqual ( len ( d ) , len ( c ) ) self . assertEqual ( type ( d ) , type ( c ) )  def test_conversions ( self ) :          s = <str> self . assertEqual ( sorted ( Counter ( s ) . elements ( ) ) , sorted ( s ) ) self . assertEqual ( sorted ( Counter ( s ) ) , sorted ( set ( s ) ) ) self . assertEqual ( dict ( Counter ( s ) ) , dict ( Counter ( s ) . items ( ) ) ) self . assertEqual ( set ( Counter ( s ) ) , set ( s ) )  def test_invariant_for_the_in_operator ( self ) :          c = Counter ( a = 10 , b = - 2 , c = 0 ) for elem in c :              self . assertTrue ( elem in c ) self . assertIn ( elem , c )   def test_multiset_operations ( self ) :          c = Counter ( a = 10 , b = - 2 , c = 0 ) + Counter ( ) self . assertEqual ( dict ( c ) , dict ( a = 10 ) ) elements = <str> for i in range ( 1000 ) :              p = Counter ( dict ( ( elem , randrange ( - 2 , 4 ) ) for elem in elements ) ) p . update ( e = 1 , f = - 1 , g = 0 ) q = Counter ( dict ( ( elem , randrange ( - 2 , 4 ) ) for elem in elements ) ) q . update ( h = 1 , i = - 1 , j = 0 ) for counterop , numberop in [ ( Counter . __add__ , lambda x , y : max ( 0 , x + y ) ) , ( Counter . __sub__ , lambda x , y : max ( 0 , x - y ) ) , ( Counter . __or__ , lambda x , y : max ( 0 , x , y ) ) , ( Counter . __and__ , lambda x , y : max ( 0 , min ( x , y ) ) ) , ] :                  result = counterop ( p , q ) for x in elements :                      self . assertEqual ( numberop ( p [ x ] , q [ x ] ) , result [ x ] , ( counterop , x , p , q ) )  self . assertTrue ( x > 0 for x in result . values ( ) )   elements = <str> for i in range ( 100 ) :              p = Counter ( dict ( ( elem , randrange ( 0 , 2 ) ) for elem in elements ) ) q = Counter ( dict ( ( elem , randrange ( 0 , 2 ) ) for elem in elements ) ) for counterop , setop in [ ( Counter . __sub__ , set . __sub__ ) , ( Counter . __or__ , set . __or__ ) , ( Counter . __and__ , set . __and__ ) , ] :                  counter_result = counterop ( p , q ) set_result = setop ( set ( p . elements ( ) ) , set ( q . elements ( ) ) ) self . assertEqual ( counter_result , dict . fromkeys ( set_result , 1 ) )    def test_inplace_operations ( self ) :          elements = <str> for i in range ( 1000 ) :              p = Counter ( dict ( ( elem , randrange ( - 2 , 4 ) ) for elem in elements ) ) p . update ( e = 1 , f = - 1 , g = 0 ) q = Counter ( dict ( ( elem , randrange ( - 2 , 4 ) ) for elem in elements ) ) q . update ( h = 1 , i = - 1 , j = 0 ) for inplace_op , regular_op in [ ( Counter . __iadd__ , Counter . __add__ ) , ( Counter . __isub__ , Counter . __sub__ ) , ( Counter . __ior__ , Counter . __or__ ) , ( Counter . __iand__ , Counter . __and__ ) , ] :                  c = p . copy ( ) c_id = id ( c ) regular_result = regular_op ( c , q ) inplace_result = inplace_op ( c , q ) self . assertEqual ( inplace_result , regular_result ) self . assertEqual ( id ( inplace_result ) , c_id )    def test_subtract ( self ) :          c = Counter ( a = - 5 , b = 0 , c = 5 , d = 10 , e = 15 , g = 40 ) c . subtract ( a = 1 , b = 2 , c = - 3 , d = 10 , e = 20 , f = 30 , h = - 50 ) self . assertEqual ( c , Counter ( a = - 6 , b = - 2 , c = 8 , d = 0 , e = - 5 , f = - 30 , g = 40 , h = 50 ) ) c = Counter ( a = - 5 , b = 0 , c = 5 , d = 10 , e = 15 , g = 40 ) c . subtract ( Counter ( a = 1 , b = 2 , c = - 3 , d = 10 , e = 20 , f = 30 , h = - 50 ) ) self . assertEqual ( c , Counter ( a = - 6 , b = - 2 , c = 8 , d = 0 , e = - 5 , f = - 30 , g = 40 , h = 50 ) ) c = Counter ( <str> ) c . subtract ( <str> ) self . assertEqual ( c , Counter ( a = - 1 , b = 0 , c = - 1 , d = 1 , e = - 1 ) )  def test_unary ( self ) :          c = Counter ( a = - 5 , b = 0 , c = 5 , d = 10 , e = 15 , g = 40 ) self . assertEqual ( dict ( + c ) , dict ( c = 5 , d = 10 , e = 15 , g = 40 ) ) self . assertEqual ( dict ( - c ) , dict ( a = 5 ) )  def test_repr_nonsortable ( self ) :          c = Counter ( a = 2 , b = None ) r = repr ( c ) self . assertIn ( <str> , r ) self . assertIn ( <str> , r )  def test_helper_function ( self ) :          from xoutil . future . collections import _count_elements elems = list ( <str> ) d = dict ( ) _count_elements ( d , elems ) self . assertEqual ( d , { <str> : 5 , <str> : 2 , <str> : 2 , <str> : 1 , <str> : 1 } ) m = OrderedDict ( ) _count_elements ( m , elems ) self . assertEqual ( m , OrderedDict ( [ ( <str> , 5 ) , ( <str> , 2 ) , ( <str> , 2 ) , ( <str> , 1 ) , ( <str> , 1 ) ] ) )   class TestOrderedDict ( unittest . TestCase ) :      def test_init ( self ) :          with self . assertRaises ( TypeError ) :              OrderedDict ( [ ( <str> , 1 ) , ( <str> , 2 ) ] , None )  pairs = [ ( <str> , 1 ) , ( <str> , 2 ) , ( <str> , 3 ) , ( <str> , 4 ) , ( <str> , 5 ) ] self . assertEqual ( sorted ( OrderedDict ( dict ( pairs ) ) . items ( ) ) , pairs ) self . assertEqual ( sorted ( OrderedDict ( ** dict ( pairs ) ) . items ( ) ) , pairs ) self . assertEqual ( list ( OrderedDict ( pairs ) . items ( ) ) , pairs ) self . assertEqual ( list ( OrderedDict ( [ ( <str> , 1 ) , ( <str> , 2 ) , ( <str> , 9 ) , ( <str> , 4 ) ] , c = 3 , e = 5 ) . items ( ) ) , pairs , ) d = OrderedDict ( [ ( <str> , 1 ) , ( <str> , 2 ) , ( <str> , 3 ) , ( <str> , 44 ) , ( <str> , 55 ) ] ) d . __init__ ( [ ( <str> , 5 ) , ( <str> , 6 ) ] , g = 7 , d = 4 ) self . assertEqual ( list ( d . items ( ) ) , [ ( <str> , 1 ) , ( <str> , 2 ) , ( <str> , 3 ) , ( <str> , 4 ) , ( <str> , 5 ) , ( <str> , 6 ) , ( <str> , 7 ) , ] , )  def test_update ( self ) :          with self . assertRaises ( TypeError ) :              OrderedDict ( ) . update ( [ ( <str> , 1 ) , ( <str> , 2 ) ] , None )  pairs = [ ( <str> , 1 ) , ( <str> , 2 ) , ( <str> , 3 ) , ( <str> , 4 ) , ( <str> , 5 ) ] od = OrderedDict ( ) od . update ( dict ( pairs ) ) self . assertEqual ( sorted ( od . items ( ) ) , pairs ) od = OrderedDict ( ) od . update ( ** dict ( pairs ) ) self . assertEqual ( sorted ( od . items ( ) ) , pairs ) od = OrderedDict ( ) od . update ( pairs ) self . assertEqual ( list ( od . items ( ) ) , pairs ) od = OrderedDict ( ) od . update ( [ ( <str> , 1 ) , ( <str> , 2 ) , ( <str> , 9 ) , ( <str> , 4 ) ] , c = 3 , e = 5 ) self . assertEqual ( list ( od . items ( ) ) , pairs ) od = OrderedDict ( ) od . update ( self = 23 ) self . assertEqual ( list ( od . items ( ) ) , [ ( <str> , 23 ) ] ) od = OrderedDict ( ) od . update ( other = { } ) self . assertEqual ( list ( od . items ( ) ) , [ ( <str> , { } ) ] ) od = OrderedDict ( ) od . update ( red = 5 , blue = 6 , other = 7 , self = 8 ) self . assertEqual ( sorted ( list ( od . items ( ) ) ) , [ ( <str> , 6 ) , ( <str> , 7 ) , ( <str> , 5 ) , ( <str> , 8 ) ] , ) d = OrderedDict ( [ ( <str> , 1 ) , ( <str> , 2 ) , ( <str> , 3 ) , ( <str> , 44 ) , ( <str> , 55 ) ] ) d . update ( [ ( <str> , 5 ) , ( <str> , 6 ) ] , g = 7 , d = 4 ) self . assertEqual ( list ( d . items ( ) ) , [ ( <str> , 1 ) , ( <str> , 2 ) , ( <str> , 3 ) , ( <str> , 4 ) , ( <str> , 5 ) , ( <str> , 6 ) , ( <str> , 7 ) , ] , )  def test_abc ( self ) :          self . assertIsInstance ( OrderedDict ( ) , MutableMapping ) self . assertTrue ( issubclass ( OrderedDict , MutableMapping ) )  def test_clear ( self ) :          pairs = [ ( <str> , 1 ) , ( <str> , 2 ) , ( <str> , 3 ) , ( <str> , 4 ) , ( <str> , 5 ) , ( <str> , 6 ) ] shuffle ( pairs ) od = OrderedDict ( pairs ) self . assertEqual ( len ( od ) , len ( pairs ) ) od . clear ( ) self . assertEqual ( len ( od ) , 0 )  def test_delitem ( self ) :          pairs = [ ( <str> , 1 ) , ( <str> , 2 ) , ( <str> , 3 ) , ( <str> , 4 ) , ( <str> , 5 ) , ( <str> , 6 ) ] od = OrderedDict ( pairs ) del od [ <str> ] self . assertNotIn ( <str> , od ) with self . assertRaises ( KeyError ) :              del od [ <str> ]  self . assertEqual ( list ( od . items ( ) ) , pairs [ : 2 ] + pairs [ 3 : ] )  def test_setitem ( self ) :          od = OrderedDict ( [ ( <str> , 1 ) , ( <str> , 2 ) , ( <str> , 3 ) , ( <str> , 4 ) , ( <str> , 5 ) ] ) od [ <str> ] = 10 od [ <str> ] = 20 self . assertEqual ( list ( od . items ( ) ) , [ ( <str> , 1 ) , ( <str> , 2 ) , ( <str> , 10 ) , ( <str> , 4 ) , ( <str> , 5 ) , ( <str> , 20 ) ] , )  def test_iterators ( self ) :          pairs = [ ( <str> , 1 ) , ( <str> , 2 ) , ( <str> , 3 ) , ( <str> , 4 ) , ( <str> , 5 ) , ( <str> , 6 ) ] shuffle ( pairs ) od = OrderedDict ( pairs ) self . assertEqual ( list ( od ) , [ t [ 0 ] for t in pairs ] ) self . assertEqual ( list ( od . keys ( ) ) , [ t [ 0 ] for t in pairs ] ) self . assertEqual ( list ( od . values ( ) ) , [ t [ 1 ] for t in pairs ] ) self . assertEqual ( list ( od . items ( ) ) , pairs ) self . assertEqual ( list ( reversed ( od ) ) , [ t [ 0 ] for t in reversed ( pairs ) ] )  def test_popitem ( self ) :          pairs = [ ( <str> , 1 ) , ( <str> , 2 ) , ( <str> , 3 ) , ( <str> , 4 ) , ( <str> , 5 ) , ( <str> , 6 ) ] shuffle ( pairs ) od = OrderedDict ( pairs ) while pairs :              self . assertEqual ( od . popitem ( ) , pairs . pop ( ) )  with self . assertRaises ( KeyError ) :              od . popitem ( )  self . assertEqual ( len ( od ) , 0 )  def test_pop ( self ) :          pairs = [ ( <str> , 1 ) , ( <str> , 2 ) , ( <str> , 3 ) , ( <str> , 4 ) , ( <str> , 5 ) , ( <str> , 6 ) ] shuffle ( pairs ) od = OrderedDict ( pairs ) shuffle ( pairs ) while pairs :              k , v = pairs . pop ( ) self . assertEqual ( od . pop ( k ) , v )  with self . assertRaises ( KeyError ) :              od . pop ( <str> )  self . assertEqual ( len ( od ) , 0 ) self . assertEqual ( od . pop ( k , 12345 ) , 12345 ) class Missing ( OrderedDict ) :              def __missing__ ( self , key ) :                  return 0   m = Missing ( a = 1 ) self . assertEqual ( m . pop ( <str> , 5 ) , 5 ) self . assertEqual ( m . pop ( <str> , 6 ) , 1 ) self . assertEqual ( m . pop ( <str> , 6 ) , 6 ) with self . assertRaises ( KeyError ) :              m . pop ( <str> )   def test_equality ( self ) :          pairs = [ ( <str> , 1 ) , ( <str> , 2 ) , ( <str> , 3 ) , ( <str> , 4 ) , ( <str> , 5 ) , ( <str> , 6 ) ] shuffle ( pairs ) od1 = OrderedDict ( pairs ) od2 = OrderedDict ( pairs ) self . assertEqual ( od1 , od2 ) pairs = pairs [ 2 : ] + pairs [ : 2 ] od2 = OrderedDict ( pairs ) self . assertNotEqual ( od1 , od2 ) self . assertEqual ( od1 , dict ( od2 ) ) self . assertEqual ( dict ( od2 ) , od1 ) self . assertNotEqual ( od1 , OrderedDict ( pairs [ : - 1 ] ) )  def test_copying ( self ) :          pairs = [ ( <str> , 1 ) , ( <str> , 2 ) , ( <str> , 3 ) , ( <str> , 4 ) , ( <str> , 5 ) , ( <str> , 6 ) ] od = OrderedDict ( pairs ) update_test = OrderedDict ( ) update_test . update ( od ) for i , dup in enumerate ( [ od . copy ( ) , copy . copy ( od ) , copy . deepcopy ( od ) , pickle . loads ( pickle . dumps ( od , 0 ) ) , pickle . loads ( pickle . dumps ( od , 1 ) ) , pickle . loads ( pickle . dumps ( od , 2 ) ) , pickle . loads ( pickle . dumps ( od , - 1 ) ) , eval ( repr ( od ) ) , update_test , OrderedDict ( od ) , ] ) :              self . assertTrue ( dup is not od ) self . assertEqual ( dup , od ) self . assertEqual ( list ( dup . items ( ) ) , list ( od . items ( ) ) ) self . assertEqual ( len ( dup ) , len ( od ) ) self . assertEqual ( type ( dup ) , type ( od ) )   def test_yaml_linkage ( self ) :          pairs = [ ( <str> , 1 ) , ( <str> , 2 ) , ( <str> , 3 ) , ( <str> , 4 ) , ( <str> , 5 ) , ( <str> , 6 ) ] od = OrderedDict ( pairs ) self . assertTrue ( all ( type ( pair ) == list for pair in od . __reduce__ ( ) [ 1 ] ) )  def test_reduce_not_too_fat ( self ) :          import sys pairs = [ ( <str> , 1 ) , ( <str> , 2 ) , ( <str> , 3 ) , ( <str> , 4 ) , ( <str> , 5 ) , ( <str> , 6 ) ] od = OrderedDict ( pairs ) self . assertIsNone ( od . __reduce__ ( ) [ 2 ] ) od . x = 10 self . assertIsNotNone ( od . __reduce__ ( ) [ 2 ] )  def test_repr ( self ) :          od = OrderedDict ( [ ( <str> , 1 ) , ( <str> , 2 ) , ( <str> , 3 ) ] ) self . assertEqual ( repr ( od ) , <str> ) self . assertEqual ( eval ( repr ( od ) ) , od ) self . assertEqual ( repr ( OrderedDict ( ) ) , <str> )  def test_repr_recursive ( self ) :          od = OrderedDict . fromkeys ( <str> ) od [ <str> ] = od self . assertEqual ( repr ( od ) , ( <str> <str> ) , )  def test_setdefault ( self ) :          pairs = [ ( <str> , 1 ) , ( <str> , 2 ) , ( <str> , 3 ) , ( <str> , 4 ) , ( <str> , 5 ) , ( <str> , 6 ) ] shuffle ( pairs ) od = OrderedDict ( pairs ) pair_order = list ( od . items ( ) ) self . assertEqual ( od . setdefault ( <str> , 10 ) , 3 ) self . assertEqual ( list ( od . items ( ) ) , pair_order ) self . assertEqual ( od . setdefault ( <str> , 10 ) , 10 ) self . assertEqual ( list ( od . items ( ) ) [ - 1 ] , ( <str> , 10 ) ) class Missing ( OrderedDict ) :              def __missing__ ( self , key ) :                  return 0   self . assertEqual ( Missing ( ) . setdefault ( 5 , 9 ) , 9 )  def test_reinsert ( self ) :          od = OrderedDict ( ) od [ <str> ] = 1 od [ <str> ] = 2 del od [ <str> ] od [ <str> ] = 1 self . assertEqual ( list ( od . items ( ) ) , [ ( <str> , 2 ) , ( <str> , 1 ) ] )  def test_move_to_end ( self ) :          od = OrderedDict . fromkeys ( <str> ) self . assertEqual ( list ( od ) , list ( <str> ) ) od . move_to_end ( <str> ) self . assertEqual ( list ( od ) , list ( <str> ) ) od . move_to_end ( <str> , 0 ) self . assertEqual ( list ( od ) , list ( <str> ) ) od . move_to_end ( <str> , 0 ) self . assertEqual ( list ( od ) , list ( <str> ) ) od . move_to_end ( <str> ) self . assertEqual ( list ( od ) , list ( <str> ) ) with self . assertRaises ( KeyError ) :              od . move_to_end ( <str> )   @ unittest . skipIf ( <str> in sys . version , <str> ) def test_sizeof ( self ) :          d = dict ( a = 1 ) od = OrderedDict ( ** d ) self . assertGreater ( sys . getsizeof ( od ) , sys . getsizeof ( d ) )  def test_override_update ( self ) :          class MyOD ( OrderedDict ) :              def update ( self , * args , ** kwds ) :                  raise Exception ( )   items = [ ( <str> , 1 ) , ( <str> , 3 ) , ( <str> , 2 ) ] self . assertEqual ( list ( MyOD ( items ) . items ( ) ) , items )   class TestRankedDict ( unittest . TestCase ) :      def test_init ( self ) :          with self . assertRaises ( TypeError ) :              RankedDict ( [ ( <str> , 1 ) , ( <str> , 2 ) ] , None )  pairs = [ ( <str> , 1 ) , ( <str> , 2 ) , ( <str> , 3 ) , ( <str> , 4 ) , ( <str> , 5 ) ] self . assertEqual ( sorted ( RankedDict ( dict ( pairs ) ) . items ( ) ) , pairs ) self . assertEqual ( sorted ( RankedDict ( ** dict ( pairs ) ) . items ( ) ) , pairs ) self . assertEqual ( list ( RankedDict ( pairs ) . items ( ) ) , pairs ) self . assertNotEqual ( list ( RankedDict ( [ ( <str> , 1 ) , ( <str> , 2 ) , ( <str> , 9 ) , ( <str> , 4 ) ] , c = 3 , e = 5 ) . items ( ) ) , pairs , ) d = RankedDict ( [ ( <str> , 1 ) , ( <str> , 2 ) , ( <str> , 3 ) , ( <str> , 44 ) , ( <str> , 55 ) ] ) d . __init__ ( [ ( <str> , 6 ) , ( <str> , 5 ) ] , d = 4 ) self . assertEqual ( list ( d . items ( ) ) , [ ( <str> , 1 ) , ( <str> , 2 ) , ( <str> , 3 ) , ( <str> , 6 ) , ( <str> , 5 ) , ( <str> , 4 ) ] , )  def test_update ( self ) :          with self . assertRaises ( TypeError ) :              RankedDict ( ) . update ( [ ( <str> , 1 ) , ( <str> , 2 ) ] , None )  pairs = [ ( <str> , 1 ) , ( <str> , 2 ) , ( <str> , 3 ) , ( <str> , 4 ) , ( <str> , 5 ) ] od = RankedDict ( ) od . update ( dict ( pairs ) ) self . assertEqual ( sorted ( od . items ( ) ) , pairs ) od = RankedDict ( ) od . update ( ** dict ( pairs ) ) self . assertEqual ( sorted ( od . items ( ) ) , pairs ) od = RankedDict ( ) od . update ( pairs ) self . assertEqual ( list ( od . items ( ) ) , pairs ) od = RankedDict ( ) od . update ( [ ( <str> , 1 ) , ( <str> , 2 ) , ( <str> , 9 ) , ( <str> , 4 ) ] , c = 3 , e = 5 ) self . assertNotEqual ( list ( od . items ( ) ) , pairs ) od = RankedDict ( ) od . update ( self = 23 ) self . assertEqual ( list ( od . items ( ) ) , [ ( <str> , 23 ) ] ) od = RankedDict ( ) od . update ( other = { } ) self . assertEqual ( list ( od . items ( ) ) , [ ( <str> , { } ) ] ) od = RankedDict ( ) od . update ( red = 5 , blue = 6 , other = 7 , self = 8 ) self . assertEqual ( sorted ( list ( od . items ( ) ) ) , [ ( <str> , 6 ) , ( <str> , 7 ) , ( <str> , 5 ) , ( <str> , 8 ) ] , )  def test_abc ( self ) :          self . assertIsInstance ( RankedDict ( ) , MutableMapping ) self . assertTrue ( issubclass ( RankedDict , MutableMapping ) )  def test_clear ( self ) :          pairs = [ ( <str> , 1 ) , ( <str> , 2 ) , ( <str> , 3 ) , ( <str> , 4 ) , ( <str> , 5 ) , ( <str> , 6 ) ] shuffle ( pairs ) od = RankedDict ( pairs ) self . assertEqual ( len ( od ) , len ( pairs ) ) od . clear ( ) self . assertEqual ( len ( od ) , 0 )  def test_delitem ( self ) :          pairs = [ ( <str> , 1 ) , ( <str> , 2 ) , ( <str> , 3 ) , ( <str> , 4 ) , ( <str> , 5 ) , ( <str> , 6 ) ] od = RankedDict ( pairs ) del od [ <str> ] self . assertNotIn ( <str> , od ) with self . assertRaises ( KeyError ) :              del od [ <str> ]  self . assertEqual ( list ( od . items ( ) ) , pairs [ : 2 ] + pairs [ 3 : ] )  def test_setitem ( self ) :          od = RankedDict ( [ ( <str> , 1 ) , ( <str> , 2 ) , ( <str> , 3 ) , ( <str> , 4 ) , ( <str> , 5 ) ] ) od [ <str> ] = 10 od [ <str> ] = 20 self . assertEqual ( list ( od . items ( ) ) , [ ( <str> , 1 ) , ( <str> , 2 ) , ( <str> , 4 ) , ( <str> , 5 ) , ( <str> , 10 ) , ( <str> , 20 ) ] , )  def test_iterators ( self ) :          pairs = [ ( <str> , 1 ) , ( <str> , 2 ) , ( <str> , 3 ) , ( <str> , 4 ) , ( <str> , 5 ) , ( <str> , 6 ) ] shuffle ( pairs ) od = RankedDict ( pairs ) self . assertEqual ( list ( od ) , [ t [ 0 ] for t in pairs ] ) self . assertEqual ( list ( od . keys ( ) ) , [ t [ 0 ] for t in pairs ] ) self . assertEqual ( list ( od . values ( ) ) , [ t [ 1 ] for t in pairs ] ) self . assertEqual ( list ( od . items ( ) ) , pairs ) self . assertEqual ( list ( reversed ( od ) ) , [ t [ 0 ] for t in reversed ( pairs ) ] )  def test_popitem ( self ) :          pairs = [ ( <str> , 1 ) , ( <str> , 2 ) , ( <str> , 3 ) , ( <str> , 4 ) , ( <str> , 5 ) , ( <str> , 6 ) ] shuffle ( pairs ) od = RankedDict ( pairs ) while pairs :              self . assertEqual ( od . popitem ( ) , pairs . pop ( ) )  with self . assertRaises ( KeyError ) :              od . popitem ( )  self . assertEqual ( len ( od ) , 0 )  def test_pop ( self ) :          pairs = [ ( <str> , 1 ) , ( <str> , 2 ) , ( <str> , 3 ) , ( <str> , 4 ) , ( <str> , 5 ) , ( <str> , 6 ) ] shuffle ( pairs ) od = RankedDict ( pairs ) shuffle ( pairs ) while pairs :              k , v = pairs . pop ( ) self . assertEqual ( od . pop ( k ) , v )  with self . assertRaises ( KeyError ) :              od . pop ( <str> )  self . assertEqual ( len ( od ) , 0 ) self . assertEqual ( od . pop ( k , 12345 ) , 12345 ) class Missing ( RankedDict ) :              def __missing__ ( self , key ) :                  return 0   m = Missing ( a = 1 ) self . assertEqual ( m . pop ( <str> , 5 ) , 5 ) self . assertEqual ( m . pop ( <str> , 6 ) , 1 ) self . assertEqual ( m . pop ( <str> , 6 ) , 6 ) with self . assertRaises ( KeyError ) :              m . pop ( <str> )   def test_equality ( self ) :          pairs = [ ( <str> , 1 ) , ( <str> , 2 ) , ( <str> , 3 ) , ( <str> , 4 ) , ( <str> , 5 ) , ( <str> , 6 ) ] shuffle ( pairs ) od1 = RankedDict ( pairs ) od2 = RankedDict ( pairs ) self . assertEqual ( od1 , od2 ) pairs = pairs [ 2 : ] + pairs [ : 2 ] od2 = RankedDict ( pairs ) self . assertNotEqual ( od1 , od2 ) self . assertEqual ( od1 , dict ( od2 ) ) self . assertEqual ( dict ( od2 ) , od1 ) self . assertNotEqual ( od1 , RankedDict ( pairs [ : - 1 ] ) )  def test_copying ( self ) :          pairs = [ ( <str> , 1 ) , ( <str> , 2 ) , ( <str> , 3 ) , ( <str> , 4 ) , ( <str> , 5 ) , ( <str> , 6 ) ] od = RankedDict ( pairs ) update_test = RankedDict ( ) update_test . update ( od ) for i , dup in enumerate ( [ od . copy ( ) , copy . copy ( od ) , copy . deepcopy ( od ) , pickle . loads ( pickle . dumps ( od , 0 ) ) , pickle . loads ( pickle . dumps ( od , 1 ) ) , pickle . loads ( pickle . dumps ( od , 2 ) ) , pickle . loads ( pickle . dumps ( od , - 1 ) ) , eval ( repr ( od ) ) , update_test , RankedDict ( od ) , ] ) :              self . assertTrue ( dup is not od ) self . assertEqual ( dup , od ) self . assertEqual ( list ( dup . items ( ) ) , list ( od . items ( ) ) ) self . assertEqual ( len ( dup ) , len ( od ) ) self . assertEqual ( type ( dup ) , type ( od ) )   def test_yaml_linkage ( self ) :          pairs = [ ( <str> , 1 ) , ( <str> , 2 ) , ( <str> , 3 ) , ( <str> , 4 ) , ( <str> , 5 ) , ( <str> , 6 ) ] od = RankedDict ( pairs ) self . assertTrue ( all ( type ( pair ) == list for pair in od . __reduce__ ( ) [ 1 ] ) )  def test_repr ( self ) :          od = RankedDict ( [ ( <str> , 1 ) , ( <str> , 2 ) , ( <str> , 3 ) ] ) self . assertEqual ( repr ( od ) , <str> ) self . assertEqual ( eval ( repr ( od ) ) , od ) self . assertEqual ( repr ( RankedDict ( ) ) , <str> )  def test_repr_recursive ( self ) :          od = RankedDict . fromkeys ( <str> ) od [ <str> ] = od self . assertEqual ( repr ( od ) , ( <str> <str> ) , )  def test_setdefault ( self ) :          pairs = [ ( <str> , 1 ) , ( <str> , 2 ) , ( <str> , 3 ) , ( <str> , 4 ) , ( <str> , 5 ) , ( <str> , 6 ) ] shuffle ( pairs ) od = RankedDict ( pairs ) pair_order = list ( od . items ( ) ) self . assertEqual ( od . setdefault ( <str> , 10 ) , 3 ) self . assertEqual ( list ( od . items ( ) ) , pair_order ) self . assertEqual ( od . setdefault ( <str> , 10 ) , 10 ) self . assertEqual ( list ( od . items ( ) ) [ - 1 ] , ( <str> , 10 ) ) class Missing ( RankedDict ) :              def __missing__ ( self , key ) :                  return 0   self . assertEqual ( Missing ( ) . setdefault ( 5 , 9 ) , 9 )  def test_reinsert ( self ) :          od = RankedDict ( ) od [ <str> ] = 1 od [ <str> ] = 2 del od [ <str> ] od [ <str> ] = 1 self . assertEqual ( list ( od . items ( ) ) , [ ( <str> , 2 ) , ( <str> , 1 ) ] )  def test_move_to_end ( self ) :          od = RankedDict . fromkeys ( <str> ) self . assertEqual ( list ( od ) , list ( <str> ) ) od . move_to_end ( <str> ) self . assertEqual ( list ( od ) , list ( <str> ) ) od . move_to_end ( <str> , 0 ) self . assertEqual ( list ( od ) , list ( <str> ) ) od . move_to_end ( <str> , 0 ) self . assertEqual ( list ( od ) , list ( <str> ) ) od . move_to_end ( <str> ) self . assertEqual ( list ( od ) , list ( <str> ) ) with self . assertRaises ( KeyError ) :              od . move_to_end ( <str> )   @ unittest . skipIf ( <str> in sys . version , <str> ) def test_sizeof ( self ) :          d = dict ( a = 1 ) od = RankedDict ( ** d ) self . assertGreater ( sys . getsizeof ( od ) , sys . getsizeof ( d ) )   class TestPascalSet ( unittest . TestCase ) :      def test_consistency ( self ) :          from random import randint from xoutil . future . collections import PascalSet count = 5 for test in range ( count ) :              size = randint ( 20 , 60 ) ranges = ( range ( i , randint ( i , i + 3 ) ) for i in range ( 1 , size ) ) s1 = PascalSet ( * ranges ) ranges = ( range ( i , randint ( i , i + 3 ) ) for i in range ( 1 , size ) ) s2 = PascalSet ( * ranges ) ss1 = set ( s1 ) ss2 = set ( s2 ) self . assertEqual ( s1 , ss1 ) self . assertEqual ( s1 - s2 , ss1 - ss2 ) self . assertEqual ( s2 - s1 , ss2 - ss1 ) self . assertEqual ( s1 & s2 , ss1 & ss2 ) self . assertEqual ( s2 & s1 , ss2 & ss1 ) self . assertEqual ( s1 | s2 , ss1 | ss2 ) self . assertEqual ( s2 | s1 , ss2 | ss1 ) self . assertEqual ( s1 ^ s2 , ss1 ^ ss2 ) self . assertEqual ( s2 ^ s1 , ss2 ^ ss1 ) self . assertLess ( s1 - s2 , s1 ) self . assertLess ( s1 - s2 , ss1 ) self . assertLessEqual ( s1 - s2 , s1 ) self . assertLessEqual ( s1 - s2 , ss1 ) self . assertGreater ( s1 , s1 - s2 ) self . assertGreater ( s1 , ss1 - ss2 ) self . assertGreaterEqual ( s1 , s1 - s2 ) self . assertGreaterEqual ( s1 , ss1 - ss2 )   def test_syntax_sugar ( self ) :          from xoutil . future . collections import PascalSet s1 = PascalSet [ 1 : 4 , 9 , 15 : 18 ] s2 = PascalSet [ 3 : 18 ] self . assertEqual ( str ( s1 ) , <str> ) self . assertEqual ( str ( s1 ^ s2 ) , <str> ) self . assertEqual ( list ( PascalSet [ 3 : 18 ] ) , list ( range ( 3 , 18 ) ) )  def test_operators ( self ) :          from xoutil . future . collections import PascalSet g = lambda s : ( i for i in s ) s1 = PascalSet [ 1 : 4 , 9 , 15 : 18 ] r1 = range ( 1 , 18 ) s2 = PascalSet ( s1 , 20 ) self . assertTrue ( s1 . issubset ( s1 ) ) self . assertTrue ( s1 . issubset ( set ( s1 ) ) ) self . assertTrue ( s1 . issubset ( list ( s1 ) ) ) self . assertTrue ( s1 . issubset ( g ( s1 ) ) ) self . assertTrue ( s1 . issubset ( r1 ) ) self . assertTrue ( s1 . issubset ( set ( r1 ) ) ) self . assertTrue ( s1 . issubset ( list ( r1 ) ) ) self . assertTrue ( s1 . issubset ( g ( r1 ) ) ) self . assertTrue ( s2 . issuperset ( s2 ) ) self . assertTrue ( s2 . issuperset ( s1 ) ) self . assertTrue ( s2 . issuperset ( set ( s1 ) ) ) self . assertTrue ( s2 . issuperset ( list ( s1 ) ) ) self . assertTrue ( s2 . issuperset ( g ( s1 ) ) ) self . assertTrue ( s1 <= set ( s1 ) ) self . assertTrue ( s1 < s2 ) self . assertTrue ( s1 <= s2 ) self . assertTrue ( s1 < set ( s2 ) ) self . assertTrue ( s1 <= set ( s2 ) ) self . assertTrue ( s1 < set ( r1 ) ) self . assertTrue ( s1 <= set ( r1 ) ) self . assertTrue ( s2 >= s2 ) self . assertTrue ( s2 >= set ( s2 ) ) self . assertTrue ( s2 > s1 ) self . assertTrue ( s2 > set ( s1 ) ) self . assertTrue ( s2 >= s1 ) self . assertTrue ( s2 >= set ( s1 ) )  def test_errors ( self ) :          from xoutil . future . collections import PascalSet s1 = PascalSet [ 1 : 4 , 9 , 15 : 18 ] s2 = PascalSet ( s1 , 20 ) self . assertLess ( s1 , s2 ) try :              if s1 < list ( s2 ) :                  state = <str>  else :                  state = <str>   except TypeError :              state = <str>  self . assertEqual ( state , <str> ) with self . assertRaises ( TypeError ) :              if s1 < set ( s2 ) :                  state = <str>  if s1 < list ( s2 ) :                  state = <str>  else :                  state = <str>   self . assertEqual ( state , <str> )   class TestBitPascalSet ( unittest . TestCase ) :      def test_consistency ( self ) :          from random import randint from xoutil . future . collections import BitPascalSet count = 5 for test in range ( count ) :              size = randint ( 20 , 60 ) ranges = ( range ( i , randint ( i , i + 3 ) ) for i in range ( 1 , size ) ) s1 = BitPascalSet ( * ranges ) ranges = ( range ( i , randint ( i , i + 3 ) ) for i in range ( 1 , size ) ) s2 = BitPascalSet ( * ranges ) ss1 = set ( s1 ) ss2 = set ( s2 ) self . assertEqual ( s1 , ss1 ) self . assertEqual ( s1 - s2 , ss1 - ss2 ) self . assertEqual ( s2 - s1 , ss2 - ss1 ) self . assertEqual ( s1 & s2 , ss1 & ss2 ) self . assertEqual ( s2 & s1 , ss2 & ss1 ) self . assertEqual ( s1 | s2 , ss1 | ss2 ) self . assertEqual ( s2 | s1 , ss2 | ss1 ) self . assertEqual ( s1 ^ s2 , ss1 ^ ss2 ) self . assertEqual ( s2 ^ s1 , ss2 ^ ss1 ) self . assertLess ( s1 - s2 , s1 ) self . assertLess ( s1 - s2 , ss1 ) self . assertLessEqual ( s1 - s2 , s1 ) self . assertLessEqual ( s1 - s2 , ss1 ) self . assertGreater ( s1 , s1 - s2 ) self . assertGreater ( s1 , ss1 - ss2 ) self . assertGreaterEqual ( s1 , s1 - s2 ) self . assertGreaterEqual ( s1 , ss1 - ss2 )   def test_syntax_sugar ( self ) :          from xoutil . future . collections import BitPascalSet s1 = BitPascalSet [ 1 : 4 , 9 , 15 : 18 ] s2 = BitPascalSet [ 3 : 18 ] self . assertEqual ( str ( s1 ) , <str> ) self . assertEqual ( str ( s1 ^ s2 ) , <str> ) self . assertEqual ( list ( BitPascalSet [ 3 : 18 ] ) , list ( range ( 3 , 18 ) ) )  def test_operators ( self ) :          from xoutil . future . collections import BitPascalSet g = lambda s : ( i for i in s ) s1 = BitPascalSet [ 1 : 4 , 9 , 15 : 18 ] r1 = range ( 1 , 18 ) s2 = BitPascalSet ( s1 , 20 ) self . assertTrue ( s1 . issubset ( s1 ) ) self . assertTrue ( s1 . issubset ( set ( s1 ) ) ) self . assertTrue ( s1 . issubset ( list ( s1 ) ) ) self . assertTrue ( s1 . issubset ( g ( s1 ) ) ) self . assertTrue ( s1 . issubset ( r1 ) ) self . assertTrue ( s1 . issubset ( set ( r1 ) ) ) self . assertTrue ( s1 . issubset ( list ( r1 ) ) ) self . assertTrue ( s1 . issubset ( g ( r1 ) ) ) self . assertTrue ( s2 . issuperset ( s2 ) ) self . assertTrue ( s2 . issuperset ( s1 ) ) self . assertTrue ( s2 . issuperset ( set ( s1 ) ) ) self . assertTrue ( s2 . issuperset ( list ( s1 ) ) ) self . assertTrue ( s2 . issuperset ( g ( s1 ) ) ) self . assertTrue ( s1 <= set ( s1 ) ) self . assertTrue ( s1 < s2 ) self . assertTrue ( s1 <= s2 ) self . assertTrue ( s1 < set ( s2 ) ) self . assertTrue ( s1 <= set ( s2 ) ) self . assertTrue ( s1 < set ( r1 ) ) self . assertTrue ( s1 <= set ( r1 ) ) self . assertTrue ( s2 >= s2 ) self . assertTrue ( s2 >= set ( s2 ) ) self . assertTrue ( s2 > s1 ) self . assertTrue ( s2 > set ( s1 ) ) self . assertTrue ( s2 >= s1 ) self . assertTrue ( s2 >= set ( s1 ) )  def test_errors ( self ) :          from xoutil . future . collections import BitPascalSet s1 = BitPascalSet [ 1 : 4 , 9 , 15 : 18 ] s2 = BitPascalSet ( s1 , 20 ) self . assertLess ( s1 , s2 ) try :              if s1 < list ( s2 ) :                  state = <str>  else :                  state = <str>   except TypeError :              state = <str>  self . assertEqual ( state , <str> ) with self . assertRaises ( TypeError ) :              if s1 < set ( s2 ) :                  state = <str>  if s1 < list ( s2 ) :                  state = <str>  else :                  state = <str>   self . assertEqual ( state , <str> )   class TestCodeDict ( unittest . TestCase ) :      def test_formatter ( self ) :          from xoutil . future . collections import codedict cd = codedict ( x = 1 , y = 2 , z = 3.0 ) self . assertEqual ( <str> . format ( _ = cd ) , <str> , ) self . assertEqual ( cd >> <str> , <str> , ) self . assertEqual ( <str> << cd , <str> , )   def test_abcs ( ) :      from xoutil . future . collections import Container from xoutil . future . collections import Iterable from xoutil . future . collections import Iterator from xoutil . future . collections import Sized from xoutil . future . collections import Callable from xoutil . future . collections import Sequence from xoutil . future . collections import MutableSequence from xoutil . future . collections import Set from xoutil . future . collections import MutableSet from xoutil . future . collections import Mapping from xoutil . future . collections import MutableMapping from xoutil . future . collections import MappingView from xoutil . future . collections import ItemsView from xoutil . future . collections import KeysView from xoutil . future . collections import ValuesView  def test_opendict ( ) :      try :          from enum import Enum  except ImportError :          from enum34 import Enum  from xoutil . future . collections import opendict class Foo :          x = 1 _y = 2  foo = opendict . from_enum ( Foo ) assert dict ( foo ) == { <str> : 1 } class Bar ( Enum ) :          spam = <str> def eat ( self ) :              return self . spam   bar = opendict . from_enum ( Bar ) assert dict ( bar ) == { <str> : Bar . spam }  if __name__ == <str> :      unittest . main ( verbosity = 2 )   