class predicate :      __slots__ = ( <str> , ) def __new__ ( cls , * args ) :          if cls is predicate :              count = len ( args ) if count == 0 :                  msg = <str> raise TypeError ( msg . format ( cls . __name__ ) )  elif count == 1 :                  arg = args [ 0 ] if isinstance ( arg , cls ) :                      return arg  elif isinstance ( arg , ( tuple , type ) ) :                      return TypeCheck ( arg )  elif isinstance ( arg , list ) :                      return CheckAndCast ( * arg )  elif callable ( arg ) :                      return LogicalCheck ( arg )  else :                      msg = <str> aname = type ( arg ) . __name__ raise TypeError ( msg . format ( cls . __name__ , aname ) )   else :                  return MultiCheck ( * args )   else :              return super ( ) . __new__ ( cls )   def __init__ ( self , * args ) :          pass  def __repr__ ( self ) :          return str ( self )   class TypeCheck ( predicate ) :      __slots__ = ( ) def __new__ ( cls , * args ) :          from xotl . tools . params import check_count check_count ( len ( args ) + 1 , 2 , caller = cls . __name__ ) if len ( args ) == 1 and isinstance ( args [ 0 ] , tuple ) :              args = args [ 0 ]  if all ( isinstance ( arg , type ) for arg in args ) :              self = super ( ) . __new__ ( cls ) self . inner = args return self  else :              wrong = ( arg for arg in args if not isinstance ( arg , type ) ) wnames = <str> . join ( type ( w ) . __name__ for w in wrong ) msg = <str> raise TypeError ( msg . format ( wnames ) )   def __call__ ( self , value ) :          from xotl . tools . fp . option import Just , Wrong ok = isinstance ( value , self . inner ) return ( value if value else Just ( value ) ) if ok else Wrong ( value )  def __str__ ( self ) :          return self . _str ( )  def __crop__ ( self , max_width = None , canonical = False ) :          from xotl . tools . symbols import Undefined from xotl . tools . clipping import ELLIPSIS , DEFAULT_MAX_WIDTH if max_width is None :              max_width = DEFAULT_MAX_WIDTH  start , end = <str> . format ( type ( self ) . __name__ ) , <str> borders_len = len ( start ) + len ( end ) sep = <str> res = <str> items = iter ( self . inner ) ok = True while ok :              item = next ( items , Undefined ) if item is not Undefined :                  if res :                      res += sep  aux = item . __name__ if len ( res ) + len ( aux ) + borders_len <= max_width :                      res += aux  else :                      res += ELLIPSIS ok = False   else :                  ok = False   return <str> . format ( start , res , end )   class NoneOrTypeCheck ( TypeCheck ) :      __slots__ = ( ) def __call__ ( self , value ) :          from xotl . tools . fp . option import Wrong if value is None :              _types = self . inner i , res = 0 , None while res is None and i < len ( _types ) :                  try :                      res = _types [ i ] ( )  except Exception :                      pass  i += 1  return res if res is not None else Wrong ( None )  else :              return super ( ) . __call__ ( value )   def __str__ ( self ) :          aux = super ( ) . __str__ ( ) return <str> . format ( aux )   class TypeCast ( TypeCheck ) :      __slots__ = ( ) def __call__ ( self , value ) :          from xotl . tools . fp . option import Just res = super ( ) . __call__ ( value ) if not res :              _types = self . inner i = 0 while not res and i < len ( _types ) :                  try :                      res = _types [ i ] ( value ) if not res :                          res = Just ( res )   except Exception :                      pass  i += 1   return res  def __str__ ( self ) :          aux = super ( NoneOrTypeCheck , self ) . __str__ ( ) return <str> . format ( aux )   class CheckAndCast ( predicate ) :      __slots__ = ( ) def __new__ ( cls , check , cast ) :          check = predicate ( check ) if callable ( cast ) :              self = super ( ) . __new__ ( cls ) self . inner = ( check , SafeCheck ( cast ) ) return self  else :              msg = <str> sname = type ( self ) . __name__ raise TypeError ( msg . format ( sname , type ( cast ) . __name__ ) )   def __call__ ( self , value ) :          from xotl . tools . fp . option import Wrong check , cast = self . inner aux = check ( value ) if aux :              res = cast ( value ) if check ( res ) :                  return res   else :              res = aux  if isinstance ( res , Wrong ) :              return res  else :              return Wrong ( value )   def __str__ ( self ) :          from xotl . tools . clipping import crop check , cast = self . inner fmt = <str> return fmt . format ( crop ( cast ) , check )   class FunctionalCheck ( predicate ) :      __slots__ = ( ) def __new__ ( cls , check ) :          if isinstance ( check , predicate ) :              return check  elif callable ( check ) :              self = super ( ) . __new__ ( cls ) self . inner = check return self  else :              msg = <str> raise TypeError ( msg . format ( type ( check ) . __name__ ) )   def __str__ ( self ) :          from xotl . tools . clipping import crop suffix = <str> kind = type ( self ) . __name__ . lower ( ) if kind . endswith ( suffix ) :              kind = kind [ : - len ( suffix ) ]  inner = crop ( self . inner ) return <str> . format ( kind , inner )   class LogicalCheck ( FunctionalCheck ) :      __slots__ = ( ) def __call__ ( self , value ) :          from xotl . tools . fp . option import Just , Wrong try :              res = self . inner ( value ) if res :                  if isinstance ( res , Just ) :                      return res  elif res is True :                      return Just ( value )  else :                      return res   elif isinstance ( res , Wrong ) :                  return res  elif res is False or res is None :                  return Wrong ( value )  else :                  return Wrong ( res )   except Exception as error :              return Wrong ( error )    class SafeCheck ( FunctionalCheck ) :      __slots__ = ( ) def __call__ ( self , value ) :          from xotl . tools . fp . option import Wrong try :              return self . inner ( value )  except Exception as error :              return Wrong ( error )    class MultiCheck ( predicate ) :      __slots__ = ( ) def __new__ ( cls , * args ) :          inner = tuple ( predicate ( arg ) for arg in args ) self = super ( ) . __new__ ( cls ) self . inner = inner return self  def __call__ ( self , value ) :          from xotl . tools . fp . option import Just , Wrong , none predicates = self . inner i , res = 0 , none while isinstance ( res , Wrong ) and i < len ( predicates ) :              res = predicates [ i ] ( value ) i += 1  return res . inner if isinstance ( res , Just ) and res . inner else res  def __str__ ( self ) :          aux = <str> . join ( str ( c ) for c in self . inner ) return <str> . format ( aux )    