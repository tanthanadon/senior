from abc import ABCMeta def identity ( arg ) :      return arg  def constant ( value ) :      <str> def result ( * args , ** kwargs ) :          return value  return result  def fst ( pair , strict = True ) :      if strict :          res , _ = pair return res  else :          return pair [ 0 ]   def snd ( pair , strict = True ) :      if strict :          _ , res = pair return res  else :          return pair [ 1 ]   class MetaCompose ( ABCMeta ) :      def __instancecheck__ ( self , instance ) :          res = super ( ) . __instancecheck__ ( instance ) if not res :              res = callable ( instance )  return res  def __subclasscheck__ ( self , subclass ) :          res = super ( ) . __subclasscheck__ ( subclass ) if not res :              from xotl . tools . future . types import FuncTypes res = subclass in FuncTypes  return res   class compose ( metaclass = MetaCompose ) :      <str> def __new__ ( cls , * functions ) :          functions = [ fn for fn in functions if fn is not identity ] count = len ( functions ) if count == 0 :              return identity  else :              if all ( callable ( f ) for f in functions ) :                  if count == 1 :                      return functions [ 0 ]  else :                      from xotl . tools . symbols import Unset self = super ( ) . __new__ ( cls ) self . inner = functions self . scope = Unset return self   else :                  raise TypeError ( <str> )    def __call__ ( self , * args , ** kwds ) :          funcs = self . inner count = len ( funcs ) if count :              i = 1 res = full_args ( ( args , kwds ) ) while i <= count :                  try :                      fn = funcs [ - i ] if isinstance ( res , pos_args ) :                          res = fn ( * res )  elif isinstance ( res , kw_args ) :                          res = fn ( ** res )  elif isinstance ( res , full_args ) :                          res = fn ( * res [ 0 ] , ** res [ 1 ] )  else :                          res = fn ( res )   except Exception :                      self . scope = ( count - i , fn ) raise  i += 1  return res  else :              return identity ( * args , ** kwds )   def __repr__ ( self ) :          from xotl . tools . tools import nameof if self . inner :              def getname ( fn ) :                  return nameof ( fn ) . replace ( ( lambda : None ) . __name__ , <str> )  return <str> . join ( getname ( fn ) for fn in self . inner )  else :              return nameof ( identity )   def __str__ ( self ) :          count = len ( self . inner ) if count == 0 :              return identity . __doc__  else :              res = self . inner [ 0 ] . __doc__ if count == 1 else None if not res :                  res = <str> . format ( self )  return res   def _get_name ( self ) :          res = self . __dict__ . get ( <str> ) if res is None :              res = repr ( self )  return res  def _set_name ( self , value ) :          self . __dict__ [ <str> ] = value  __name__ = property ( _get_name , _set_name ) def _get_doc ( self ) :          res = self . __dict__ . get ( <str> ) if res is None :              res = str ( self )  return res  def _set_doc ( self , value ) :          self . __dict__ [ <str> ] = value  __doc__ = property ( _get_doc , _set_doc ) def __eq__ ( self , other ) :          if isinstance ( type ( other ) , MetaCompose ) :              return self . inner == other . inner  elif self . inner :              return self . inner [ 0 ] == other  else :              return other is identity   def __len__ ( self ) :          return len ( self . inner )  def __iter__ ( self ) :          return iter ( self . inner )  def __contains__ ( self , item ) :          return item in self . inner  def __getitem__ ( self , index ) :          res = self . inner [ index ] return compose ( * res ) if isinstance ( res , list ) else res  def __setitem__ ( self , index , value ) :          if isinstance ( index , slice ) and isinstance ( type ( value ) , MetaCompose ) :              value = value . inner  self . inner [ index ] = value  def __delitem__ ( self , index ) :          del self . inner [ index ]   class pos_args ( tuple ) :       class kw_args ( dict ) :       class full_args ( tuple ) :      @ staticmethod def parse ( arg ) :          if isinstance ( arg , tuple ) :              def check ( pos , kw ) :                  return isinstance ( pos , tuple ) and isinstance ( kw , dict )  if len ( arg ) == 2 and check ( * arg ) :                  return full_args ( arg )  else :                  return pos_args ( arg )   elif isinstance ( arg , list ) :              return pos_args ( arg )  elif isinstance ( arg , dict ) :              return kw_args ( arg )  elif arg is None :              return pos_args ( )  else :              msg = <str> raise TypeError ( msg . format ( type ( arg ) . __name__ ) )     