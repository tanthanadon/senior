from xotl . tools . symbols import Undefined as _undef def _get_mappings ( source ) :      from collections import Mapping if isinstance ( source , Mapping ) :          return ( source , )  else :          from xotl . tools . future . inspect import get_attr_value l = get_attr_value ( source , <str> , _undef ) g = get_attr_value ( source , <str> , _undef ) if isinstance ( l , Mapping ) and isinstance ( g , Mapping ) :              return ( l , ) if l is g else ( l , g )  else :              return tuple ( source )    def _key_for_value ( source , value , strict = True ) :      source = _get_mappings ( source ) found , equal = _undef , ( None , { } ) i , mapping_count = 0 , len ( source ) while found is _undef and ( i < mapping_count ) :          mapping = source [ i ] keys = list ( mapping ) j , key_count = 0 , len ( keys ) while found is _undef and ( j < key_count ) :              key = keys [ j ] item = mapping [ key ] if item is value :                  found = key , mapping  elif value == item :                  if strict :                      equal = key , mapping  else :                      found = key , mapping   j += 1  i += 1  return found if found is not _undef else equal  def _get_value ( source , key , default = None ) :      source = _get_mappings ( source ) res = _undef i , mapping_count = 0 , len ( source ) while res is _undef and ( i < mapping_count ) :          mapping = source [ i ] res = mapping . get ( key , _undef ) i += 1  return res if res is not _undef else default  def _get_best_name ( names , safe = False , full = False ) :      from xotl . tools . validators import ( is_valid_full_identifier , is_valid_public_identifier , is_valid_identifier , is_valid_slug , ) names = list ( names ) def inner ( start = 0 ) :          ok , best_idx , best_qlty = start , - 1 , 0 i , count = start , len ( names ) assert start < count , <str> % ( start , count ) while i < count :              name = names [ i ] if <str> in name :                  next = inner ( i + 1 ) names [ i ] = name % { <str> : next } count = i + 1  else :                  if is_valid_slug ( name ) :                      qlty = 25  if is_valid_identifier ( name ) :                      qlty = 75 if is_valid_public_identifier ( name ) else 50  elif is_valid_full_identifier ( name ) :                      qlty = 100  else :                      qlty = - 25  if best_qlty <= qlty :                      best_idx = i best_qlty = qlty  ok = i i += 1   idx = best_idx if best_idx >= 0 else ok return names [ idx ]  res = inner ( ) if safe :          is_valid = is_valid_full_identifier if full else is_valid_identifier if not is_valid ( res ) :              from xotl . tools . string import slugify _mark = <str> full = full and <str> in res if full :                  res = res . replace ( <str> , _mark )  res = slugify ( res , <str> ) if full :                  res = res . replace ( _mark , <str> )  if not is_valid ( res ) :                  res = <str> + res    return str ( res )  def module_name ( item ) :      from xotl . tools . future . inspect import get_attr_value if item is None :          res = <str>  elif isinstance ( item , str ) :          res = item  else :          res = get_attr_value ( item , <str> , None ) if res is None :              res = get_attr_value ( type ( item ) , <str> , <str> )   if res . startswith ( <str> ) or res in ( <str> , <str> , <str> ) :          res = <str>  return str ( res )  def simple_name ( item , join = True ) :      from xotl . tools . future . inspect import safe_name singletons = ( None , True , False , Ellipsis , NotImplemented ) res = next ( ( str ( s ) for s in singletons if s is item ) , None ) if res is None :          res = safe_name ( item ) if res is None :              item = type ( item ) res = safe_name ( item )  if join :              if join is True :                  def join ( arg ) :                      return str ( <str> . join ( arg ) . strip ( <str> ) )   res = join ( ( module_name ( item ) , res ) )   return res  def nameof ( * args , ** kwargs ) :      from numbers import Number from xotl . tools . future . inspect import safe_name arg_count = len ( args ) names = [ [ ] for i in range ( arg_count ) ] params = kwargs idx = 0 def grant ( name = None , ** again ) :          nonlocal params nonlocal idx if name :              names [ idx ] . append ( name ) assert len ( names [ idx ] ) < 5  if again :              params = dict ( kwargs , ** again )  else :              params = kwargs idx += 1   def param ( name , default = False ) :          nonlocal params return params . get ( name , default )  while idx < arg_count :          item = args [ idx ] if param ( <str> ) and not safe_name ( item ) :              item = type ( item )  if param ( <str> ) :              res = safe_name ( item ) if res :                  if param ( <str> ) :                      head = module_name ( item ) if head :                          res = <str> . join ( ( head , res ) )   grant ( res )  elif isinstance ( item , ( str , Number ) ) :                  grant ( str ( item ) )  else :                  grant ( <str> . join ( ( <str> , hex ( id ( item ) ) ) ) , typed = True )   else :              import sys sf = sys . _getframe ( param ( <str> , 1 ) ) try :                  i , LIMIT , res = 0 , 5 , _undef _full = param ( <str> ) while not res and sf and ( i < LIMIT ) :                      key , mapping = _key_for_value ( sf , item ) if key and _full :                          head = module_name ( _get_value ( mapping , <str> ) ) if not head :                              head = module_name ( sf . f_code . co_name )  if not head :                              head = module_name ( item ) or None   else :                          head = None  if key :                          res = key  else :                          sf = sf . f_back i += 1    finally :                  sf = None  if res :                  grant ( <str> . join ( ( head , res ) ) if head else res )  else :                  res = safe_name ( item ) if res :                      grant ( res )  else :                      grant ( None , inner = True )     for i in range ( arg_count ) :          names [ i ] = _get_best_name ( names [ i ] , safe = param ( <str> ) )  if arg_count == 0 :          return None  elif arg_count == 1 :          return names [ 0 ]  else :          return names   def identifier_from ( * args ) :      if len ( args ) == 1 :          from xotl . tools . validators . identifiers import is_valid_identifier as valid from xotl . tools . future . inspect import get_attr_value res = None if isinstance ( args [ 0 ] , type ) :              aux = get_attr_value ( args [ 0 ] , <str> , None ) if valid ( aux ) :                  res = str ( <str> % aux )   if res is None :              tests = ( { <str> : True } , { } , { <str> : True } ) names = ( nameof ( args [ 0 ] , depth = 2 , ** test ) for test in tests ) res = next ( ( name for name in names if valid ( name ) ) , None )  return res  else :          msg = <str> raise TypeError ( msg % len ( args ) )   class namelist ( list ) :      def __init__ ( self , * args ) :          if len ( args ) == 1 :              from types import GeneratorType as gtype if isinstance ( args [ 0 ] , ( tuple , list , set , frozenset , gtype ) ) :                  args = args [ 0 ]   super ( ) . __init__ ( nameof ( arg , depth = 2 ) for arg in args )  def __add__ ( self , other ) :          other = [ nameof ( item , depth = 2 ) for item in other ] return super ( ) . __add__ ( other )  __iadd__ = __add__ def __contains__ ( self , item ) :          return super ( ) . __contains__ ( nameof ( item , inner = True ) )  def append ( self , value ) :          super ( ) . append ( nameof ( value , depth = 2 ) ) return value  __call__ = append def extend ( self , items ) :          items = ( nameof ( item , depth = 2 ) for item in items ) return super ( ) . extend ( items )  def index ( self , value , * args ) :          return super ( ) . index ( nameof ( value , depth = 2 ) , * args )  def insert ( self , index , value ) :          return super ( ) . insert ( index , nameof ( value , depth = 2 ) )  def remove ( self , value ) :          return list . remove ( self , nameof ( value , depth = 2 ) )   class strlist ( list ) :      def __init__ ( self , * args ) :          if len ( args ) == 1 :              from types import GeneratorType as gtype if isinstance ( args [ 0 ] , ( tuple , list , set , frozenset , gtype ) ) :                  args = args [ 0 ]   super ( ) . __init__ ( str ( arg ) for arg in args )  def __add__ ( self , other ) :          other = [ str ( item ) for item in other ] return super ( ) . __add__ ( other )  __iadd__ = __add__ def __contains__ ( self , item ) :          return super ( ) . __contains__ ( str ( item ) )  def append ( self , value ) :          super ( ) . append ( str ( value ) ) return value  __call__ = append def extend ( self , items ) :          items = ( str ( item ) for item in items ) return super ( ) . extend ( items )  def index ( self , value , * args ) :          return super ( ) . index ( str ( value ) , * args )  def insert ( self , index , value ) :          return super ( ) . insert ( index , str ( value ) )  def remove ( self , value ) :          return list . remove ( self , str ( value ) )   import unittest as _utest from xotl . tools . symbols import Unset as _Unset class TestRelativeImports ( _utest . TestCase ) :      RelativeUnset = _Unset AbsoluteUndefined = _undef def test_relative_imports ( self ) :          self . assertEquals ( nameof ( self . RelativeUnset ) , <str> ) self . assertEquals ( nameof ( self . RelativeUnset , inner = True ) , <str> ) self . assertEquals ( nameof ( self . RelativeUnset , full = True ) , <str> ) self . assertEquals ( nameof ( self . AbsoluteUndefined , full = True ) , <str> )   del _utest  