from collections import * try :      from collections . abc import * from collections . abc import ( Set , Iterable , Sized , Container , MutableSet , Mapping , MutableMapping , )  except ImportError :      from collections import ( Set , Iterable , Sized , Container , MutableSet , Mapping , MutableMapping , )  import collections as _stdlib from collections import ( _itemgetter , _heapq , _chain , _repeat , _starmap , _count_elements , ) from xotl . tools . deprecation import deprecated from xotl . tools . symbols import Unset from xotl . tools . objects import SafeDataItem as safe from xotl . tools . reprlib import recursive_repr class safe_dict_iter ( tuple ) :      def __new__ ( cls , mapping ) :          self = super ( ) . __new__ ( cls , mapping ) self . _mapping = mapping return self  def __str__ ( self ) :          cls_name = type ( self ) . __name__ res = str ( <str> ) . join ( str ( i ) for i in self ) return str ( <str> ) . format ( cls_name , res )  __repr__ = __str__ def __len__ ( self ) :          return sum ( 1 for key in self )  def __contains__ ( self , key ) :          res = super ( ) . __contains__ ( key ) return res and key in self . mapping  def __nonzero__ ( self ) :          return bool ( len ( self ) )  __bool__ = __nonzero__ def __iter__ ( self ) :          for key in super ( ) . __iter__ ( ) :              if key in self . _mapping :                  yield key    keys = __iter__ def values ( self ) :          for key in self :              if key in self . _mapping :                  yield self . _mapping [ key ]    def items ( self ) :          for key in self :              if key in self . _mapping :                  yield ( key , self . _mapping [ key ] )     class defaultdict ( _stdlib . defaultdict ) :      def __missing__ ( self , key ) :          if self . default_factory is not None :              try :                  return self . default_factory ( key , dict ( self ) )  except TypeError :                  return super ( ) . __missing__ ( key )   else :              raise KeyError ( key )    class OpenDictMixin :      __cache_name__ = str ( <str> ) def __dir__ ( self ) :          from xotl . tools . objects import fulldir return list ( set ( ~ self ) | fulldir ( self ) )  def __getattr__ ( self , name ) :          from xotl . tools . future . inspect import get_attr_value _mark = object ( ) res = get_attr_value ( self , name , _mark ) if res is not _mark :              return res  else :              key = ( ~ self ) . get ( name ) if key :                  return self [ key ]  else :                  msg = <str> raise AttributeError ( msg % ( type ( self ) . __name__ , name ) )    def __setattr__ ( self , name , value ) :          cls = type ( self ) desc = getattr ( cls , name , None ) if desc is not None :              try :                  desc . __set__ ( self , value )  except Exception :                  pass   key = ( ~ self ) . get ( name ) if key :              self [ key ] = value  else :              super ( ) . __setattr__ ( name , value )   def __delattr__ ( self , name ) :          key = ( ~ self ) . get ( name ) if key :              del self [ key ]  else :              super ( ) . __delattr__ ( name )   def __invert__ ( self ) :          KEY_LENGTH = <str> KEY_MAPPING = <str> cache = self . _cache cached_length = cache . setdefault ( KEY_LENGTH , 0 ) length = len ( self ) if cached_length != length :              cache [ KEY_LENGTH ] = length aux = ( ( self . _key2identifier ( k ) , k ) for k in self ) res = { key : attr for key , attr in aux if key } cache [ KEY_MAPPING ] = res  else :              res = cache . get ( KEY_MAPPING ) if res is None :                  assert cached_length == 0 res = { } cache [ KEY_MAPPING ] = res   return res  @ property def _cache ( self ) :          from xotl . tools . future . inspect import get_attr_value try :              return get_attr_value ( self , type ( self ) . __cache_name__ )  except AttributeError :              res = setattr ( self , type ( self ) . __cache_name__ , dict ( ) ) return res   @ staticmethod def _key2identifier ( key ) :          from xotl . tools . keywords import suffix_kwd from xotl . tools . string import slugify from xotl . tools . validators import is_valid_identifier res = key if is_valid_identifier ( key ) else slugify ( key , <str> ) return suffix_kwd ( res )   class SmartDictMixin :      def update ( * args , ** kwds ) :          from xotl . tools . params import issue_9137 self , args = issue_9137 ( args ) for key , value in smart_iter_items ( * args , ** kwds ) :              self [ key ] = value   def search ( self , pattern ) :          from re import compile regexp = compile ( pattern ) cls = type ( self ) try :              res = cls ( )  except Exception :              from xotl . tools . future . inspect import get_attr_value creator = get_attr_value ( cls , <str> , None ) res = creator ( ) if creator else { }  for key in self :              if regexp . search ( key ) :                  res [ key ] = self [ key ]   return res   class SmartDict ( SmartDictMixin , dict ) :      def __init__ ( * args , ** kwargs ) :          from xotl . tools . params import issue_9137 self , args = issue_9137 ( args ) super ( ) . __init__ ( ) self . update ( * args , ** kwargs )   class opendict ( OpenDictMixin , dict ) :      __slots__ = safe . slot ( OpenDictMixin . __cache_name__ , dict ) @ classmethod def from_enum ( cls , enumclass ) :          from xotl . tools . symbols import Unset from xotl . tools . validators . identifiers import is_valid_public_identifier members = getattr ( enumclass , <str> , Unset ) if members is Unset :              members = { k : v for k , v in enumclass . __dict__ . items ( ) if is_valid_public_identifier ( k ) }  return cls ( members )   class codedict ( OpenDictMixin , dict ) :      def __getitem__ ( self , key ) :          try :              return super ( ) . __getitem__ ( key )  except KeyError :              if isinstance ( key , str ) :                  return eval ( key , dict ( self ) )  else :                  raise    def __rshift__ ( self , arg ) :          return arg . format ( _ = self , ** self )  __rlshift__ = __rshift__  class StackedDict ( OpenDictMixin , SmartDictMixin , MutableMapping ) :      __slots__ = ( safe . slot ( <str> , ChainMap ) , safe . slot ( OpenDictMixin . __cache_name__ , dict ) , ) def __init__ ( * args , ** kwargs ) :          from xotl . tools . params import issue_9137 self , args = issue_9137 ( args ) self . update ( * args , ** kwargs )  @ property def level ( self ) :          return len ( self . inner . maps ) - 1  def push_level ( self , * args , ** kwargs ) :          self . inner = self . inner . new_child ( ) self . update ( * args , ** kwargs ) return self . level  @ deprecated ( push_level ) def push ( self , * args , ** kwargs ) :          return self . push_level ( * args , ** kwargs )  def pop ( self , * args ) :          if len ( args ) == 0 :              cls = type ( self ) if not hasattr ( cls , <str> ) :                  import warnings setattr ( cls , <str> , True ) msg = ( <str> <str> ) warnings . warn ( msg , stacklevel = 2 )  return self . pop_level ( )  else :              return super ( ) . pop ( * args )   def pop_level ( self ) :          if self . level > 0 :              stack = self . inner res = stack . maps [ 0 ] self . inner = stack . parents return res  else :              raise TypeError ( <str> )   def peek ( self ) :          return dict ( self . inner . maps [ 0 ] )  def __str__ ( self ) :          return str ( dict ( self ) )  def __repr__ ( self ) :          return <str> % ( type ( self ) . __name__ , str ( self ) )  def __len__ ( self ) :          return len ( self . inner )  def __iter__ ( self ) :          return iter ( self . inner )  def __getitem__ ( self , key ) :          return self . inner [ key ]  def __setitem__ ( self , key , value ) :          self . inner [ key ] = value  def __delitem__ ( self , key ) :          del self . inner [ key ]   class RankedDict ( SmartDictMixin , dict ) :      def __init__ ( * args , ** kwds ) :          from xotl . tools . params import issue_9137 self , args = issue_9137 ( args ) try :              self . _ranks  except AttributeError :              self . _ranks = [ ]  self . update ( * args , ** kwds )  def rank ( self , * keys ) :          if keys :              ranks = [ ] for key in keys :                  if key in self :                      ranks . append ( key )  else :                      raise KeyError ( <str> . format ( key ) )   aux = set ( keys ) for key in self :                  if key not in aux :                      ranks . append ( key )   self . _ranks = ranks   def swap_ranks ( self , * args , ** kwds ) :          from xotl . tools . params import check_count check_count ( len ( args ) + len ( kwds ) + 1 , 2 , caller = <str> ) for key1 , key2 in args :              self . _swap_ranks ( key1 , key2 )  for key1 in kwds :              key2 = kwds [ key1 ] self . _swap_ranks ( key1 , key2 )   def move_to_end ( self , key , last = True ) :          try :              ranks = self . _ranks if last :                  if key != ranks [ - 1 ] :                      ranks . remove ( key ) ranks . append ( key )   else :                  if key != ranks [ 0 ] :                      ranks . remove ( key ) ranks . insert ( 0 , key )    except ValueError :              raise KeyError ( key )   def _swap_ranks ( self , key1 , key2 ) :          if key1 in self and key2 in self :              ranks = self . _ranks idx1 , idx2 = ranks . index ( key1 ) , ranks . index ( key2 ) if idx1 != idx2 :                  aux = ranks [ idx1 ] ranks [ idx1 ] = ranks [ idx2 ] ranks [ idx2 ] = aux   else :              raise KeyError ( <str> . format ( key1 , key2 ) )   def __setitem__ ( self , key , value ) :          ranks = self . _ranks if key in self :              if ranks [ - 1 ] != key :                  ranks . remove ( key ) ranks . append ( key )   else :              ranks . append ( key )  super ( ) . __setitem__ ( key , value )  def __delitem__ ( self , key ) :          super ( ) . __delitem__ ( key ) self . _ranks . remove ( key )  def __iter__ ( self ) :          return iter ( self . _ranks )  def __reversed__ ( self ) :          return reversed ( self . _ranks )  def clear ( self ) :          super ( ) . clear ( ) self . _ranks = [ ]  def popitem ( self , index = None ) :          if self :              if index is None or index is True :                  index = - 1  key = self . _ranks . pop ( index ) return key , super ( ) . pop ( key )  else :              raise KeyError ( <str> )   def __sizeof__ ( self ) :          return super ( ) . __sizeof__ ( ) + self . _ranks . __sizeof__ ( )  def keys ( self ) :          return self . __iter__ ( )  def values ( self ) :          for key in self :              yield self [ key ]   def items ( self ) :          for key in self :              yield ( key , self [ key ] )   def __eq__ ( self , other ) :          res = super ( ) . __eq__ ( other ) if res :              if isinstance ( other , RankedDict ) :                  return self . _ranks == other . _ranks  elif isinstance ( other , OrderedDict ) :                  return self . _ranks == list ( other )  else :                  return True   else :              return False   def __ne__ ( self , other ) :          return not self . __eq__ ( other )  def pop ( self , key , * args ) :          from xotl . tools . params import check_count count = len ( args ) check_count ( count + 1 , 1 , 2 , caller = <str> ) res = super ( ) . pop ( key , Unset ) if res is Unset :              if count == 1 :                  return args [ 0 ]  else :                  raise KeyError ( key )   else :              self . _ranks . remove ( key ) return res   def setdefault ( self , key , default = None ) :          if key in self :              return self [ key ]  else :              self [ key ] = default return default   @ recursive_repr ( ) def __repr__ ( self ) :          aux = <str> . join ( <str> . format ( k , self [ k ] ) for k in self ) if aux :              aux = <str> . format ( aux )  return <str> . format ( type ( self ) . __name__ , aux )  def __reduce__ ( self ) :          cls = type ( self ) inst_dict = vars ( self ) . copy ( ) for k in vars ( cls ( ) ) :              inst_dict . pop ( k , None )  return cls , ( ) , inst_dict or None , None , iter ( self . items ( ) )  def copy ( self ) :          return type ( self ) ( self )  @ classmethod def fromkeys ( cls , iterable , value = None ) :          return cls ( ( key , value ) for key in iterable )   class OrderedSmartDict ( SmartDictMixin , OrderedDict ) :      def __init__ ( * args , ** kwds ) :          from xotl . tools . params import issue_9137 self , args = issue_9137 ( args ) super ( ) . __init__ ( ) self . update ( * args , ** kwds )   class MetaSet ( type ) :      def __getitem__ ( cls , ranges ) :          return cls ( * ranges ) if isinstance ( ranges , tuple ) else cls ( ranges )   class PascalSet ( metaclass = MetaSet ) :      __slots__ = ( <str> , ) def __init__ ( self , * others ) :          self . _items = [ ] self . update ( * others )  def __str__ ( self ) :          def aux ( s , e ) :              if s == e :                  return str ( s )  elif s + 1 == e :                  return <str> % ( s , e )  else :                  return <str> % ( s , e )   l = self . _items ranges = ( ( l [ i ] , l [ i + 1 ] ) for i in range ( 0 , len ( l ) , 2 ) ) return str ( <str> % <str> . join ( ( aux ( s , e ) for ( s , e ) in ranges ) ) )  def __repr__ ( self ) :          cls = type ( self ) cname = cls . __name__ return str ( <str> % ( cname , <str> . join ( ( str ( i ) for i in self ) ) ) )  def __iter__ ( self ) :          l = self . _items i , count = 0 , len ( l ) while i < count :              s , e = l [ i ] , l [ i + 1 ] while s <= e :                  yield s s += 1  i += 2   def __len__ ( self ) :          res = 0 l = self . _items i , count = 0 , len ( l ) while i < count :              res += l [ i + 1 ] - l [ i ] + 1 i += 2  return res  def __nonzero__ ( self ) :          return bool ( self . _items )  __bool__ = __nonzero__ def __contains__ ( self , other ) :          return isinstance ( other , int ) and self . _search ( other ) [ 0 ]  def __hash__ ( self ) :          return Set . _hash ( self )  def __eq__ ( self , other ) :          if isinstance ( other , Set ) :              ls , lo = len ( self ) , len ( other ) if ls == lo :                  if isinstance ( other , PascalSet ) :                      return self . _items == other . _items  else :                      return self . count ( other ) == ls   else :                  return False   else :              return False   def __ne__ ( self , other ) :          return not self . __eq__ ( other )  def __gt__ ( self , other ) :          if isinstance ( other , Set ) :              if other :                  return self . issuperset ( other ) and len ( self ) > len ( other )  else :                  return bool ( self . _items )   else :              return NotImplemented   def __ge__ ( self , other ) :          if isinstance ( other , Set ) :              if other :                  return self . issuperset ( other )  else :                  return bool ( self . _items )   else :              return NotImplemented   def __lt__ ( self , other ) :          if isinstance ( other , Set ) :              if other :                  return self . issubset ( other ) and len ( self ) < len ( other )  else :                  return not self . _items   else :              return NotImplemented   def __le__ ( self , other ) :          if isinstance ( other , Set ) :              if other :                  return self . issubset ( other )  else :                  return not self . _items   else :              return NotImplemented   def __sub__ ( self , other ) :          if isinstance ( other , Set ) :              return self . difference ( other )  else :              return NotImplemented   def __isub__ ( self , other ) :          if isinstance ( other , Set ) :              self . difference_update ( other ) return self  else :              return NotImplemented   def __rsub__ ( self , other ) :          if isinstance ( other , Set ) :              return other - type ( other ) ( self )  else :              return NotImplemented   def __and__ ( self , other ) :          if isinstance ( other , Set ) :              return self . intersection ( other )  else :              return NotImplemented   def __iand__ ( self , other ) :          if isinstance ( other , Set ) :              self . intersection_update ( other ) return self  else :              return NotImplemented   def __rand__ ( self , other ) :          if isinstance ( other , Set ) :              return other & type ( other ) ( self )  else :              return NotImplemented   def __or__ ( self , other ) :          if isinstance ( other , Set ) :              return self . union ( other )  else :              return NotImplemented   def __ior__ ( self , other ) :          if isinstance ( other , Set ) :              self . update ( other ) return self  else :              return NotImplemented   def __ror__ ( self , other ) :          if isinstance ( other , Set ) :              return other | type ( other ) ( self )  else :              return NotImplemented   def __xor__ ( self , other ) :          if isinstance ( other , Set ) :              return self . symmetric_difference ( other )  else :              return NotImplemented   def __ixor__ ( self , other ) :          if isinstance ( other , Set ) :              self . symmetric_difference_update ( other ) return self  else :              return NotImplemented   def __rxor__ ( self , other ) :          if isinstance ( other , Set ) :              return other ^ type ( other ) ( self )  else :              return NotImplemented   def count ( self , other ) :          if isinstance ( other , int ) :              return 1 if other in self else 0  else :              return sum ( ( i in self for i in other ) , 0 )   def add ( self , other ) :          self . _insert ( other )  def union ( self , * others ) :          res = self . copy ( ) res . update ( * others ) return res  def update ( self , * others ) :          for other in others :              if isinstance ( other , PascalSet ) :                  l = other . _items if self . _items :                      count = len ( l ) i = 0 while i < count :                          self . _insert ( l [ i ] , l [ i + 1 ] ) i += 2   else :                      self . _items = l [ : ]   elif isinstance ( other , int ) :                  self . _insert ( other )  elif isinstance ( other , Iterable ) :                  for i in other :                      self . _insert ( i )   elif isinstance ( other , slice ) :                  start , stop , step = other . start , other . stop , other . step if step is None :                      step = 1  if step in ( 1 , - 1 ) :                      stop -= step if step == - 1 :                          start , stop = stop , start  self . _insert ( start , stop )  else :                      for i in range ( start , stop , step ) :                          self . _insert ( i )    else :                  raise self . _invalid_value ( other )    def intersection ( self , * others ) :          res = self . copy ( ) res . intersection_update ( * others ) return res  def intersection_update ( self , * others ) :          l = self . _items oi , count = 0 , len ( others ) while l and oi < count :              other = others [ oi ] if not isinstance ( other , PascalSet ) :                  other = PascalSet ( i for i in other if isinstance ( i , int ) )  o = other . _items if o :                  sl , el = l [ 0 ] , l [ - 1 ] so , eo = o [ 0 ] , o [ - 1 ] if sl < so :                      self . _remove ( sl , so - 1 )  if eo < el :                      self . _remove ( eo + 1 , el )  i = 2 while l and i < len ( o ) :                      s , e = o [ i - 1 ] + 1 , o [ i ] - 1 if s <= e :                          self . _remove ( s , e )  i += 2   else :                  del l [ : ]  oi += 1   def difference ( self , * others ) :          res = self . copy ( ) res . difference_update ( * others ) return res  def difference_update ( self , * others ) :          for other in others :              if isinstance ( other , PascalSet ) :                  l = other . _items count = len ( l ) i = 0 while i < count :                      self . _remove ( l [ i ] , l [ i + 1 ] ) i += 2   else :                  for i in other :                      if isinstance ( i , int ) :                          self . _remove ( i )      def symmetric_difference ( self , other ) :          res = self . copy ( ) res . symmetric_difference_update ( other ) return res  def symmetric_difference_update ( self , other ) :          <str> if not isinstance ( other , PascalSet ) :              other = PascalSet ( other )  if self :              if other :                  aux = other - self self -= other self |= aux   else :              self . _items = other . _items [ : ]   def discard ( self , other ) :          self . _remove ( other )  def remove ( self , other ) :          if other in self :              self . _remove ( other )  else :              raise KeyError ( <str> % other )   def pop ( self ) :          l = self . _items if l :              res = l [ 0 ] if l [ 0 ] < l [ 1 ] :                  l [ 0 ] += 1  else :                  del l [ 0 : 2 ]  return res  else :              raise KeyError ( <str> )   def clear ( self ) :          self . _items = [ ]  def copy ( self ) :          return type ( self ) ( self )  def isdisjoint ( self , other ) :          if isinstance ( other , PascalSet ) :              if self and other :                  l , o = self . _items , other . _items i , lcount , ocount = 0 , len ( l ) , len ( o ) maybe = True while maybe and i < lcount :                      found , idx = other . _search ( l [ i ] ) if idx == ocount :                          i = lcount  elif found or l [ i + 1 ] >= o [ idx ] :                          maybe = False  else :                          i += 2   return maybe  else :                  return True   else :              return not any ( i in self for i in other )   def issubset ( self , other ) :          ls = len ( self ) if isinstance ( other , PascalSet ) :              if self :                  if ls > len ( other ) :                      return False  else :                      l , o = self . _items , other . _items i , lcount = 0 , len ( l ) maybe = True while maybe and i < lcount :                          found , idx = other . _search ( l [ i ] ) if found and l [ i + 1 ] <= o [ idx + 1 ] :                              i += 2  else :                              maybe = False   return maybe   else :                  return True   elif isinstance ( other , Sized ) and ls > len ( other ) :              return False  elif isinstance ( other , Container ) :              aux = next ( ( i for i in self if i not in other ) , Unset ) return aux is Unset  else :              from operator import add from functools import reduce lo = reduce ( add , ( i in self for i in other ) , 0 ) return lo == ls   def issuperset ( self , other ) :          ls = len ( self ) if isinstance ( other , PascalSet ) :              if other :                  if ls < len ( other ) :                      return False  else :                      l , o = self . _items , other . _items i , ocount = 0 , len ( o ) maybe = True while maybe and i < ocount :                          found , idx = self . _search ( o [ i ] ) if found and o [ i + 1 ] <= l [ idx + 1 ] :                              i += 2  else :                              maybe = False   return maybe   else :                  return True   elif isinstance ( other , Sized ) and ls < len ( other ) :              return False  else :              aux = next ( ( i for i in other if i not in self ) , Unset ) return aux is Unset   def _search ( self , other ) :          if isinstance ( other , int ) :              l = self . _items start , end = 0 , len ( l ) res , pivot = False , 2 * ( end // 4 ) while not res and start < end :                  s , e = l [ pivot ] , l [ pivot + 1 ] if other < s :                      end = pivot  elif other > e :                      start = pivot + 2  else :                      res = True  pivot = start + 2 * ( ( end - start ) // 4 )  return res , pivot  else :              raise self . _invalid_value ( other )   def _insert ( self , start , end = None ) :          if not end :              end = start  assert start <= end l = self . _items count = len ( l ) found , idx = self . _search ( start ) if not found :              if idx > 0 and start == l [ idx - 1 ] + 1 :                  found = True idx -= 2 l [ idx + 1 ] = start if idx < count - 2 and end == l [ idx + 2 ] - 1 :                      end = l [ idx + 3 ]   elif idx < count and end >= l [ idx ] - 1 :                  found = True l [ idx ] = start   if found :              while end > l [ idx + 1 ] :                  if idx < count - 2 and end >= l [ idx + 2 ] - 1 :                      if end <= l [ idx + 3 ] :                          l [ idx + 1 ] = l [ idx + 3 ]  del l [ idx + 2 : idx + 4 ] count -= 2  else :                      l [ idx + 1 ] = end    else :              if idx < count :                  l . insert ( idx , start ) l . insert ( idx + 1 , end )  else :                  l . extend ( ( start , end ) )  count += 2   def _remove ( self , start , end = None ) :          if not end :              end = start  assert start <= end l = self . _items sfound , sidx = self . _search ( start ) efound , eidx = self . _search ( end ) if sfound and efound and sidx == eidx :              first = l [ sidx ] < start last = l [ eidx + 1 ] > end if first and last :                  l . insert ( eidx + 1 , end + 1 ) l . insert ( sidx + 1 , start - 1 )  elif first :                  l [ sidx + 1 ] = start - 1  elif last :                  l [ eidx ] = end + 1  else :                  del l [ sidx : eidx + 2 ]   else :              if sfound and l [ sidx ] < start :                  l [ sidx + 1 ] = start - 1 sidx += 2  if efound :                  if l [ eidx + 1 ] > end :                      l [ eidx ] = end + 1  else :                      eidx += 2   if sidx < eidx :                  del l [ sidx : eidx ]    def _invalid_value ( self , value ) :          cls_name = type ( self ) . __name__ vname = type ( value ) . __name__ msg = ( <str> <str> ) return TypeError ( msg % ( value , vname , cls_name ) )  @ classmethod def _prime_numbers_until ( cls , limit ) :          res = cls [ 2 : limit ] for i in range ( 2 , limit // 2 + 1 ) :              if i in res :                  aux = i + i while aux < limit :                      if aux in res :                          res . remove ( aux )  aux += i    return res   MutableSet . register ( PascalSet ) class BitPascalSet ( metaclass = MetaSet ) :      __slots__ = ( <str> , ) _bit_length = 62 def __init__ ( self , * others ) :          self . _items = { } self . update ( * others )  def __str__ ( self ) :          if self :              return str ( PascalSet ( self ) )  else :              cname = type ( self ) . __name__ return str ( <str> ) % cname   def __repr__ ( self ) :          cname = type ( self ) . __name__ res = str ( <str> ) . join ( str ( i ) for i in self ) return str ( <str> ) % ( cname , res )  def __iter__ ( self ) :          bl = self . _bit_length sm = self . _items for k in sorted ( sm ) :              v = sm [ k ] base = k * bl i = 0 ref = 1 while i < bl :                  if ref & v :                      yield base + i  ref <<= 1 i += 1    def __len__ ( self ) :          return sum ( ( 1 for i in self ) , 0 )  def __nonzero__ ( self ) :          return bool ( self . _items )  __bool__ = __nonzero__ def __contains__ ( self , other ) :          res = self . _search ( other ) if res :              k , ref , v = res return bool ( v & ( 1 << ref ) )  else :              return False   def __hash__ ( self ) :          return Set . _hash ( self )  def __eq__ ( self , other ) :          if isinstance ( other , Set ) :              if isinstance ( other , BitPascalSet ) :                  return self . _items == other . _items  else :                  ls , lo = len ( self ) , len ( other ) return ls == lo == self . count ( other )   else :              return False   def __ne__ ( self , other ) :          return not self . __eq__ ( other )  def __gt__ ( self , other ) :          if isinstance ( other , Set ) :              if other :                  return self . issuperset ( other ) and len ( self ) > len ( other )  else :                  return bool ( self . _items )   else :              return NotImplemented   def __ge__ ( self , other ) :          if isinstance ( other , Set ) :              return self . issuperset ( other ) if other else bool ( self . _items )  else :              return NotImplemented   def __lt__ ( self , other ) :          if isinstance ( other , Set ) :              if other :                  return self . issubset ( other ) and len ( self ) < len ( other )  else :                  return not self . _items   else :              return NotImplemented   def __le__ ( self , other ) :          if isinstance ( other , Set ) :              return self . issubset ( other ) if other else not self . _items  else :              return NotImplemented   def __sub__ ( self , other ) :          if isinstance ( other , Set ) :              return self . difference ( other )  else :              return NotImplemented   def __isub__ ( self , other ) :          if isinstance ( other , Set ) :              self . difference_update ( other ) return self  else :              return NotImplemented   def __rsub__ ( self , other ) :          if isinstance ( other , Set ) :              return other - type ( other ) ( self )  else :              return NotImplemented   def __and__ ( self , other ) :          if isinstance ( other , Set ) :              return self . intersection ( other )  else :              return NotImplemented   def __iand__ ( self , other ) :          if isinstance ( other , Set ) :              self . intersection_update ( other ) return self  else :              return NotImplemented   def __rand__ ( self , other ) :          if isinstance ( other , Set ) :              return other & type ( other ) ( self )  else :              return NotImplemented   def __or__ ( self , other ) :          if isinstance ( other , Set ) :              return self . union ( other )  else :              return NotImplemented   def __ior__ ( self , other ) :          if isinstance ( other , Set ) :              self . update ( other ) return self  else :              return NotImplemented   def __ror__ ( self , other ) :          if isinstance ( other , Set ) :              return other | type ( other ) ( self )  else :              return NotImplemented   def __xor__ ( self , other ) :          if isinstance ( other , Set ) :              return self . symmetric_difference ( other )  else :              return NotImplemented   def __ixor__ ( self , other ) :          if isinstance ( other , Set ) :              self . symmetric_difference_update ( other ) return self  else :              return NotImplemented   def __rxor__ ( self , other ) :          if isinstance ( other , Set ) :              return other ^ type ( other ) ( self )  else :              return NotImplemented   def count ( self , other ) :          if isinstance ( other , int ) :              return 1 if other in self else 0  else :              return sum ( ( i in self for i in other ) , 0 )   def add ( self , other ) :          self . _insert ( other )  def union ( self , * others ) :          res = self . copy ( ) res . update ( * others ) return res  def update ( self , * others ) :          for other in others :              if isinstance ( other , BitPascalSet ) :                  sm = self . _items om = other . _items for k , v in safe_dict_iter ( om ) . items ( ) :                      if k in sm :                          sm [ k ] |= v  else :                          sm [ k ] = v    elif isinstance ( other , int ) :                  self . _insert ( other )  elif isinstance ( other , Iterable ) :                  for i in other :                      self . _insert ( i )   elif isinstance ( other , slice ) :                  start , stop , step = other . start , other . stop , other . step if step is None :                      step = 1  for i in range ( start , stop , step ) :                      self . _insert ( i )   else :                  raise self . _invalid_value ( other )    def intersection ( self , * others ) :          res = self . copy ( ) res . intersection_update ( * others ) return res  def intersection_update ( self , * others ) :          sm = self . _items oi , count = 0 , len ( others ) while sm and oi < count :              other = others [ oi ] if not isinstance ( other , BitPascalSet ) :                  other = PascalSet ( i for i in other if isinstance ( i , int ) )  om = other . _items for k , v in safe_dict_iter ( sm ) . items ( ) :                  v &= om . get ( k , 0 ) if v :                      sm [ k ] = v  else :                      del sm [ k ]   oi += 1   def difference ( self , * others ) :          res = self . copy ( ) res . difference_update ( * others ) return res  def difference_update ( self , * others ) :          for other in others :              if isinstance ( other , BitPascalSet ) :                  sm = self . _items om = other . _items for k , v in safe_dict_iter ( om ) . items ( ) :                      if k in sm :                          v = sm [ k ] & ~ v if v :                              sm [ k ] = v  else :                              del sm [ k ]     else :                  for i in other :                      if isinstance ( i , int ) :                          self . _remove ( i )      def symmetric_difference ( self , other ) :          res = self . copy ( ) res . symmetric_difference_update ( other ) return res  def symmetric_difference_update ( self , other ) :          <str> if not isinstance ( other , BitPascalSet ) :              other = BitPascalSet ( other )  if self :              if other :                  aux = other - self self -= other self |= aux   else :              self . _items = other . _items [ : ]   def discard ( self , other ) :          self . _remove ( other )  def remove ( self , other ) :          self . _remove ( other , fail = True )  def pop ( self ) :          sm = self . _items if sm :              bl = self . _bit_length k , v = next ( sm . items ( ) ) assert v base = k * bl i = 0 ref = 1 res = None while res is None :                  if ref & v :                      res = base + i  else :                      ref <<= 1 i += 1   v &= ~ ref if v :                  sm [ k ] = v  else :                  del sm [ k ]  return res  else :              raise KeyError ( <str> )   def clear ( self ) :          self . _items = { }  def copy ( self ) :          return type ( self ) ( self )  def isdisjoint ( self , other ) :          if isinstance ( other , BitPascalSet ) :              sm , om = self . _items , other . _items if sm and om :                  return all ( sm . get ( k , 0 ) & v == 0 for k , v in om . items ( ) )  else :                  return True   else :              return not any ( i in self for i in other )   def issubset ( self , other ) :          if isinstance ( other , BitPascalSet ) :              sm , om = self . _items , other . _items if sm :                  return all ( om . get ( k , 0 ) & v == v for k , v in sm . items ( ) )  else :                  return True   elif isinstance ( other , Container ) :              return not any ( i not in other for i in self )  else :              return sum ( ( i in self for i in other ) , 0 ) == len ( self )   def issuperset ( self , other ) :          if isinstance ( other , BitPascalSet ) :              sm , om = self . _items , other . _items if om :                  return all ( sm . get ( k , 0 ) & v == v for k , v in om . items ( ) )  else :                  return True   else :              return not any ( i not in self for i in other )   def _search ( self , other ) :          if isinstance ( other , int ) :              sm = self . _items bl = self . _bit_length k , ref = divmod ( other , bl ) return k , ref , sm . get ( k , 0 )  else :              return None   def _insert ( self , other ) :          aux = self . _search ( other ) if aux :              k , ref , v = aux self . _items [ k ] = v | ( 1 << ref )  else :              raise self . _invalid_value ( other )   def _remove ( self , other , fail = False ) :          aux = self . _search ( other ) ok = False if aux :              k , ref , v = aux if v :                  aux = v & ~ ( 1 << ref ) if v != aux :                      ok = True sm = self . _items if aux :                          sm [ k ] = aux  else :                          del sm [ k ]     if not ok and fail :              raise KeyError ( <str> % other )   def _invalid_value ( self , value ) :          cls_name = type ( self ) . __name__ vname = type ( value ) . __name__ msg = ( <str> <str> ) return TypeError ( msg % ( value , vname , cls_name ) )  @ classmethod def _prime_numbers_until ( cls , limit ) :          res = cls [ 2 : limit ] for i in range ( 2 , limit // 2 + 1 ) :              if i in res :                  aux = i + i while aux < limit :                      if aux in res :                          res . remove ( aux )  aux += i    return res   MutableSet . register ( BitPascalSet ) def pair ( arg ) :      return arg if isinstance ( arg , ( tuple , list ) ) and len ( arg ) == 2 else None  def smart_iter_items ( * args , ** kwds ) :      for arg in args :          if isinstance ( arg , Mapping ) :              for key in arg :                  yield key , arg [ key ]   elif hasattr ( arg , <str> ) and hasattr ( arg , <str> ) :              for key in arg . keys ( ) :                  yield key , arg [ key ]   elif pair ( arg ) and not ( pair ( arg [ 0 ] ) and pair ( arg [ 1 ] ) ) :              yield arg  else :              for item in arg :                  if pair ( item ) :                      yield item  else :                      msg = <str> raise TypeError ( msg . format ( type ( item ) . __name__ , item ) )     for key in kwds :          yield key , kwds [ key ]   del deprecated , recursive_repr  