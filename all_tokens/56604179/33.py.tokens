from abc import abstractmethod , ABCMeta , ABC from xotl . tools . objects import staticproperty from xotl . tools . cli . tools import command_name , program_name class CommandMeta ( ABCMeta ) :      def __new__ ( meta , name , bases , namespace ) :          cls = super ( CommandMeta , meta ) . __new__ ( meta , name , bases , namespace ) cls . __subcommands_registry__ = set ( ) return cls  def register ( cls , subclass ) :          cls . __subcommands_registry__ . add ( subclass ) res = super ( CommandMeta , cls ) . register ( subclass ) if res is None :              res = subclass  return res  def cli_name ( cls ) :          from xotl . tools . cli . tools import hyphen_name unset = object ( ) names = ( <str> , <str> ) i , res = 0 , unset while i < len ( names ) and res is unset :              name = names [ i ] res = getattr ( cls , names [ i ] , unset ) if res is unset :                  i += 1  elif not isinstance ( res , str ) :                  msg = <str> . format ( name ) raise TypeError ( msg )   if res is unset :              res = hyphen_name ( cls . __name__ )  return res  def get_setting ( cls , name , * default ) :          aux = len ( default ) if aux < 2 :              unset = object ( ) default = default [ 0 ] if aux == 1 else unset res = cls . __settings__ . get ( name , default ) if res is not unset :                  return res  else :                  raise KeyError ( name )   else :              msg = <str> raise TypeError ( msg . format ( aux + 2 ) )   def set_setting ( cls , name , value ) :          cls . __settings__ [ name ] = value  def set_default_command ( cls , cmd = None ) :          if cls is Command :              if cmd is not None :                  name = cmd if isinstance ( cmd , str ) else command_name ( cmd )  else :                  raise ValueError ( <str> )   else :              if cmd is None :                  name = command_name ( cls )  else :                  raise ValueError ( <str> , cls , cmd )   Command . set_setting ( <str> , name )   class Command ( ABC , metaclass = CommandMeta ) :      __settings__ = { } __registry_cache__ = { } def __str__ ( self ) :          return command_name ( type ( self ) )  def __repr__ ( self ) :          return <str> % command_name ( type ( self ) )  @ staticproperty def registry ( ) :          res = Command . __registry_cache__ if not res :              Command . _settle_cache ( Command ) assert res . pop ( command_name ( Command ) , None ) is None Command . _check_help ( )  return res  @ abstractmethod def run ( self , args = None ) :          raise NotImplementedError  @ staticmethod def _settle_cache ( source , recursed = None ) :          from xotl . tools . names import nameof if recursed is None :              recursed = set ( )  name = nameof ( source , inner = True , full = True ) if name not in recursed :              recursed . add ( name ) sub_commands = type . __subclasses__ ( source ) virtuals = getattr ( source , <str> , ( ) ) sub_commands . extend ( virtuals ) cmds = getattr ( source , <str> , None ) if cmds :                  from collections import Iterable if not isinstance ( cmds , Iterable ) :                      cmds = cmds ( )  sub_commands . extend ( cmds )  if sub_commands :                  for cmd in sub_commands :                      Command . _settle_cache ( cmd , recursed = recursed )   else :                  from types import FunctionType as ValidMethodType assert isinstance ( source . run , ValidMethodType ) , ( <str> % ( type ( source . run ) . __name__ , source ) ) Command . __registry_cache__ [ command_name ( source ) ] = source   else :              raise ValueError ( <str> % name )   @ staticmethod def _check_help ( ) :          name = HELP_NAME hlp = Command . __registry_cache__ [ name ] if hlp is not Help and not getattr ( hlp , <str> , False ) :              Command . __registry_cache__ [ name ] = Help    class Help ( Command ) :      __order__ = - 9999 @ classmethod def get_arg_parser ( cls ) :          res = getattr ( cls , <str> ) if not res :              from argparse import ArgumentParser res = ArgumentParser ( ) cls . _arg_parser = res  return res  def run ( self , args = [ ] ) :          print ( <str> % program_name ( ) ) cmds = Command . registry ordered = [ ( getattr ( cmds [ cmd ] , <str> , 0 ) , cmd ) for cmd in cmds ] ordered . sort ( ) max_len = len ( max ( ordered , key = lambda x : len ( x [ 1 ] ) ) [ 1 ] ) for _ , cmd in ordered :              cmd_class = cmds [ cmd ] doc = self . _strip_doc ( cmd_class . __doc__ ) if not doc :                  doc = self . _strip_doc ( cmd_class . run . __doc__ )  if not doc :                  import sys mod_name = cmd_class . __module__ module = sys . modules . get ( mod_name , None ) if module :                      doc = self . _strip_doc ( module . __doc__ ) doc = <str> % ( doc if doc else mod_name )  else :                      doc = <str> % mod_name   head = <str> * 3 + cmd + <str> * ( 2 + max_len - len ( cmd ) ) print ( head , doc )   @ staticmethod def _strip_doc ( doc ) :          if doc :              doc = str ( <str> % doc ) . strip ( ) return str ( doc . split ( <str> ) [ 0 ] . strip ( ) )  else :              return <str>    HELP_NAME = command_name ( Help ) del abstractmethod , ABCMeta del staticproperty  