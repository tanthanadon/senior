_DEFAULT_TABLE = <str> <str> <str> _MAX_BASE = len ( _DEFAULT_TABLE ) _DEFAULT_BASE = _MAX_BASE def _check_base ( base ) :      if isinstance ( base , int ) :          table = _DEFAULT_TABLE if not ( 1 < base <= _MAX_BASE ) :              raise ValueError ( <str> % _MAX_BASE )   elif isinstance ( base , str ) :          table = base base = len ( table )  else :          msg = ( <str> <str> ) raise TypeError ( msg % ( type ( base ) . __name__ , base ) )  return base , table  def int2str ( number , base = _DEFAULT_BASE ) :      base , table = _check_base ( base ) sign = <str> if number >= 0 else <str> number = abs ( number ) res = table [ 0 ] if number == 0 else <str> while number :          number , idx = divmod ( number , base ) res = table [ idx ] + res  return str ( sign + res )  def str2int ( src , base = _DEFAULT_BASE ) :      base , table = _check_base ( base ) if src . startswith ( <str> ) :          sign = - 1 i = 1  else :          sign = 1 i = 0  res = 0 while i < len ( src ) :          res *= base res += table . index ( src [ i ] ) i += 1  return sign * res  class BaseConvertor :      @ classmethod def inttobase ( cls , num ) :          return int2str ( num , base = cls . table )  @ classmethod def basetoint ( cls , istr ) :          table = cls . table if cls . case_insensitive :              table = table . lower ( )  return str2int ( istr , base = table )   class B32 ( BaseConvertor ) :      table = <str> case_insensitive = True  class B64 ( BaseConvertor ) :      table = <str> case_insensitive = False  class B64symbolic ( B64 ) :      table = <str> <str> case_insensitive = True   