from threading import RLock try :      from greenlet import getcurrent  except ImportError :      from threading import current_thread as getcurrent  from weakref import WeakKeyDictionary from copy import copy import sys PYPY = hasattr ( sys , <str> ) __all__ = [ <str> ] class _localbase :      __slots__ = <str> , <str> , <str> def __new__ ( cls , * args , ** kw ) :          self = object . __new__ ( cls ) object . __setattr__ ( self , <str> , ( args , kw ) ) object . __setattr__ ( self , <str> , RLock ( ) ) dicts = WeakKeyDictionary ( ) object . __setattr__ ( self , <str> , dicts ) if args or kw :              clsi , obji = cls . __init__ , object . __init__ if ( PYPY and clsi == obji ) or ( not PYPY and clsi is obji ) :                  raise TypeError ( <str> )   dict = object . __getattribute__ ( self , <str> ) dicts [ getcurrent ( ) ] = dict return self   def _init_locals ( self ) :      d = { } dicts = object . __getattribute__ ( self , <str> ) dicts [ getcurrent ( ) ] = d object . __setattr__ ( self , <str> , d ) cls = type ( self ) if cls . __init__ is not object . __init__ :          args , kw = object . __getattribute__ ( self , <str> ) cls . __init__ ( self , * args , ** kw )   class local ( _localbase ) :      def __getattribute__ ( self , name ) :          d = object . __getattribute__ ( self , <str> ) . get ( getcurrent ( ) ) if d is None :              lock = object . __getattribute__ ( self , <str> ) lock . acquire ( ) try :                  _init_locals ( self ) return object . __getattribute__ ( self , name )  finally :                  lock . release ( )   else :              object . __setattr__ ( self , <str> , d ) return object . __getattribute__ ( self , name )   def __setattr__ ( self , name , value ) :          if name == <str> :              clsname = self . __class__ . __name__ raise AttributeError ( <str> % clsname )  d = object . __getattribute__ ( self , <str> ) . get ( getcurrent ( ) ) if d is None :              lock = object . __getattribute__ ( self , <str> ) lock . acquire ( ) try :                  _init_locals ( self ) return object . __setattr__ ( self , name , value )  finally :                  lock . release ( )   else :              object . __setattr__ ( self , <str> , d ) return object . __setattr__ ( self , name , value )   def __delattr__ ( self , name ) :          if name == <str> :              clsname = self . __class__ . __name__ raise AttributeError ( <str> % clsname )  d = object . __getattribute__ ( self , <str> ) . get ( getcurrent ( ) ) if d is None :              lock = object . __getattribute__ ( self , <str> ) lock . acquire ( ) try :                  _init_locals ( self ) return object . __delattr__ ( self , name )  finally :                  lock . release ( )   else :              object . __setattr__ ( self , <str> , d ) return object . __delattr__ ( self , name )   def __copy__ ( self ) :          currentId = getcurrent ( ) d = object . __getattribute__ ( self , <str> ) . get ( currentId ) duplicate = copy ( d ) cls = type ( self ) if cls . __init__ is not object . __init__ :              args , kw = object . __getattribute__ ( self , <str> ) instance = cls ( * args , ** kw )  else :              instance = cls ( )  object . __setattr__ ( instance , <str> , { currentId : duplicate } ) return instance    