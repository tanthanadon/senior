from contextlib import contextmanager from xotl . tools . symbols import Unset __docstring_format__ = <str> _INVALID_CLASS_TYPE_MSG = <str> def _len ( x ) :      <str> return len ( x ) if x else 0  def _true ( * args , ** kwargs ) :      return True  def _false ( * args , ** kwargs ) :      return False  class SafeDataItem :      def __init__ ( self , * args , ** kwargs ) :          self . __parse_arguments ( * args , ** kwargs ) if self . do_assigning :              cls_locals = self . _get_class_context ( ) current = cls_locals . get ( self . attr_name ) if not isinstance ( current , SafeDataItem ) :                  cls_locals [ self . attr_name ] = self  else :                  msg = ( <str> <str> ) type_name = type ( self ) . __name__ raise AttributeError ( msg % ( type_name , self . attr_name ) )    @ staticmethod def slot ( slot_name , * args , ** kwargs ) :          self = SafeDataItem ( slot_name , * args , ** kwargs ) return self . inner_name  @ staticmethod def property ( * args , ** kwargs ) :          def inner ( method ) :              from types import FunctionType as function from xotl . tools . validators import check FUNC_KINDS = ( <str> , <str> , <str> ) FUNC_TYPES = ( function , staticmethod , classmethod ) IN_FUNC_TYPES = FUNC_KINDS . __contains__ KIND_NAME = <str> kind = kwargs . pop ( KIND_NAME , FUNC_KINDS [ 0 ] ) if check ( kind , IN_FUNC_TYPES ) and check ( method , FUNC_TYPES ) :                  kwargs [ <str> ] = False def init ( ) :                      from sys import _getframe obj = _getframe ( 1 ) . f_locals [ <str> ] if kind == FUNC_KINDS [ 0 ] :                          return method ( obj )  elif kind == FUNC_KINDS [ 1 ] :                          return method ( )  else :                          return method ( type ( obj ) )   init . __name__ = method . __name__ return SafeDataItem ( init , ** kwargs )   if kwargs :              return inner  elif len ( args ) == 1 :              return inner ( args [ 0 ] )  else :              msg = <str> raise TypeError ( msg % len ( args ) )   def __get__ ( self , obj , owner ) :          if obj is not None :              from xotl . tools . future . inspect import get_attr_value res = get_attr_value ( obj , self . inner_name , Unset ) if res is not Unset :                  return res  elif self . init is not Unset :                  res = self . init ( ) self . __set__ ( obj , res ) return res  elif self . default is not Unset :                  res = self . default self . __set__ ( obj , res ) return res  else :                  msg = <str> type_name = type ( obj ) . __name__ raise AttributeError ( msg . format ( type_name , self . attr_name ) )   else :              return self   def __set__ ( self , obj , value ) :          object . __setattr__ ( obj , self . inner_name , value )  def __delete__ ( self , obj ) :          object . __delattr__ ( obj , self . inner_name )  def _get_class_context ( self ) :          <str> from sys import _getframe frame = _getframe ( 1 ) i , MAX = 0 , 5 res = None while not res and ( i < MAX ) :              aux = frame . f_locals if <str> in aux :                  res = aux  else :                  frame = frame . f_back i += 1   if res :              return res  else :              msg = <str> <str> raise TypeError ( msg % self . attr_name )   def _unique_name ( self ) :          from time import time from xotl . tools . bases import int2str return <str> % int2str ( int ( 1000000 * time ( ) ) )  def __parse_arguments ( self , * args , ** kwargs ) :          from xotl . tools . validators import is_valid_identifier , predicate self . attr_name = Unset self . init = Unset self . default = Unset self . do_assigning = True self . validator = True for i , arg in enumerate ( args ) :              if self . attr_name is Unset and is_valid_identifier ( arg ) :                  self . attr_name = arg  elif self . init is Unset and callable ( arg ) :                  self . init = arg  else :                  msg = ( <str> <str> <str> ) raise ValueError ( msg % ( args [ i : ] , i ) )   bads = { } for key in kwargs :              value = kwargs [ key ] if ( self . default is Unset and self . init is Unset and key in ( <str> , <str> , <str> ) ) :                  self . default = value  elif self . validator is True and key in ( <str> , <str> , <str> ) :                  self . validator = value  elif self . do_assigning is True and key == <str> and value is False :                  self . do_assigning = False  else :                  bads [ key ] = value   self . validator = predicate ( self . validator ) if bads :              msg = ( <str> <str> ) raise ValueError ( msg % bads )  if self . attr_name is Unset :              from xotl . tools . names import nameof if self . init is not Unset :                  if isinstance ( self . init , type ) :                      self . attr_name = str ( <str> % self . init . __name__ )  else :                      self . attr_name = nameof ( self . init , safe = True )   else :                  self . attr_name = self . _unique_name ( )   self . inner_name = str ( <str> % self . attr_name . strip ( <str> ) )   def smart_getter ( obj , strict = False ) :      from xotl . tools . future . collections import Mapping if isinstance ( obj , Mapping ) :          if not strict :              return obj . get  else :              def getter ( key , default = Unset ) :                  <str> try :                      return obj [ key ]  except KeyError :                      if default is Unset :                          raise  else :                          return default    return getter   else :          if not strict :              def getter ( attr , default = None ) :                  <str> return getattr ( obj , attr , default )  return getter  else :              def getter ( attr , default = Unset ) :                  <str> try :                      return getattr ( obj , attr )  except AttributeError :                      if default is Unset :                          raise  else :                          return default    return getter    def smart_setter ( obj ) :      from xotl . tools . future . functools import partial from xotl . tools . future . collections import MutableMapping if isinstance ( obj , MutableMapping ) :          return obj . __setitem__  else :          return partial ( setattr , obj )   def smart_getter_and_deleter ( obj ) :      from collections import Mapping , MutableMapping from functools import partial if isinstance ( obj , Mapping ) and not isinstance ( obj , MutableMapping ) :          raise TypeError ( <str> )  if isinstance ( obj , MutableMapping ) :          return lambda key , default = None : obj . pop ( key , default )  else :          return partial ( popattr , obj )   def multi_getter ( source , * ids ) :      getter = smart_getter ( source ) def first ( a ) :          return next ( ( i for i in map ( getter , a ) if i is not None ) , None )  def get ( a ) :          from xotl . tools . values . simple import logic_iterable_coerce as many return first ( a ) if many ( a ) else getter ( a )  return ( get ( aux ) for aux in ids )  def mass_setattr ( obj , ** attrs ) :      for attr in attrs :          setattr ( obj , attr , attrs [ attr ] )  return obj  def is_private_name ( name ) :      prefix = <str> return name . startswith ( prefix ) and not name . endswith ( prefix )  def fix_private_name ( cls , name ) :      if is_private_name ( name ) :          return str ( <str> % ( cls . __name__ , name ) )  else :          return name   def get_method_function ( cls , method_name ) :      if not isinstance ( cls , type ) :          cls = cls . __class__  mro = cls . mro ( ) i , res = 0 , None while not res and ( i < len ( mro ) ) :          sc = mro [ i ] method = sc . __dict__ . get ( method_name ) if callable ( method ) :              res = method  else :              i += 1   return res  def build_documentation ( cls , get_doc = None , deep = 1 ) :      from xotl . tools . future . codecs import safe_decode assert isinstance ( cls , type ) , _INVALID_CLASS_TYPE_MSG if deep < 1 :          deep = 1  get_doc = get_doc or ( lambda c : c . __doc__ ) mro = cls . mro ( ) i , level , used , res = 0 , 0 , { } , <str> while ( level < deep ) and ( i < len ( mro ) ) :          sc = mro [ i ] doc = get_doc ( sc ) if doc :              doc = safe_decode ( doc ) . strip ( ) key = sc . __name__ docs = used . setdefault ( key , set ( ) ) if doc not in docs :                  docs . add ( doc ) if res :                      res += <str>  res += <str> % ( key , doc ) level += 1   i += 1  return res  def fix_class_documentation ( cls , ignore = None , min_length = 10 , deep = 1 , default = None ) :      assert isinstance ( cls , type ) , _INVALID_CLASS_TYPE_MSG if _len ( cls . __doc__ ) < min_length :          ignore = ignore or ( ) def get_doc ( c ) :              if ( c . __name__ not in ignore ) and _len ( c . __doc__ ) >= min_length :                  return c . __doc__  else :                  return None   doc = build_documentation ( cls , get_doc , deep ) if doc :              cls . __doc__ = doc  elif default :              cls . __doc__ = default ( cls ) if callable ( default ) else default    def fix_method_documentation ( cls , method_name , ignore = None , min_length = 10 , deep = 1 , default = None ) :      assert isinstance ( cls , type ) , _INVALID_CLASS_TYPE_MSG method = get_method_function ( cls , method_name ) if method and _len ( method . __doc__ ) < min_length :          ignore = ignore or ( ) def get_doc ( c ) :              if c . __name__ not in ignore :                  method = c . __dict__ . get ( method_name ) if callable ( method ) and _len ( method . __doc__ ) >= min_length :                      return method . __doc__  else :                      return None   else :                  return None   doc = build_documentation ( cls , get_doc , deep ) if doc :              method . __doc__ = doc  elif default :              method . __doc__ = default ( cls ) if callable ( default ) else default    def fulldir ( obj ) :      from xotl . tools . future . inspect import get_attr_value , _static_getmro def getdir ( o ) :          return set ( get_attr_value ( o , <str> , { } ) )  if isinstance ( obj , type ) :          res = set . union ( getdir ( cls ) for cls in _static_getmro ( obj ) )  else :          res = getdir ( obj )  return res if isinstance ( obj , type ) else res | set ( dir ( type ( obj ) ) )  def xdir ( obj , getter = None , filter = None , _depth = 0 ) :      getter = getter or getattr attrs = dir ( obj ) res = ( ( a , getter ( obj , a ) ) for a in attrs ) if filter :          res = ( ( a , v ) for a , v in res if filter ( a , v ) )  return res  def fdir ( obj , getter = None , filter = None ) :      full = xdir ( obj , getter = getter , filter = filter , _depth = 1 ) return ( attr for attr , _v in full )  def validate_attrs ( source , target , force_equals = ( ) , force_differents = ( ) ) :      from operator import eq , ne res = True tests = ( ( eq , force_equals ) , ( ne , force_differents ) ) j = 0 get_from_source = smart_getter ( source ) get_from_target = smart_getter ( target ) while res and ( j < len ( tests ) ) :          passed , attrs = tests [ j ] i = 0 while res and ( i < len ( attrs ) ) :              attr = attrs [ i ] if passed ( get_from_source ( attr ) , get_from_target ( attr ) ) :                  i += 1  else :                  res = False   j += 1  return res  validate_attrs . _positive_testing = True def iterate_over ( source , * keys ) :      from xotl . tools . values . simple import logic_collection_coerce , nil def inner ( source ) :          get = smart_getter ( source ) for key in keys :              val = get ( key , Unset ) if val is not Unset :                  yield key , val    def when_collection ( source ) :          for generator in map ( inner , source ) :              for key , val in generator :                  yield key , val    if logic_collection_coerce ( source ) is not nil :          res = when_collection ( source )  else :          res = inner ( source )  return res  def get_first_of ( source , * keys , default = None , pred = None ) :      _key , res = next ( ( ( k , val ) for k , val in iterate_over ( source , * keys ) if not pred or pred ( val ) ) , ( Unset , Unset ) , ) return res if res is not Unset else default  def pop_first_of ( source , * keys , ** kwargs ) :      from xotl . tools . values . simple import logic_collection_coerce , nil def inner ( source ) :          get = smart_getter_and_deleter ( source ) res , i = Unset , 0 while ( res is Unset ) and ( i < len ( keys ) ) :              res = get ( keys [ i ] , Unset ) i += 1  return res  if logic_collection_coerce ( source ) is not nil :          res = Unset source = iter ( source ) probe = next ( source , None ) while res is Unset and probe :              res = inner ( probe ) probe = next ( source , None )   else :          res = inner ( source )  return res if res is not Unset else kwargs . get ( <str> , None )  def popattr ( obj , name , default = None ) :      res = getattr ( obj , name , Unset ) if res is Unset :          res = default  else :          try :              delattr ( obj , name )  except AttributeError :              try :                  delattr ( obj . __class__ , name )  except AttributeError :                  pass    return res  class lazy :      def __init__ ( self , value , * args , ** kwargs ) :          self . value = value self . args = args self . kwargs = kwargs  def __call__ ( self ) :          res = self . value if callable ( res ) :              return res ( * self . args , ** self . kwargs )  else :              return res    def iter_branch_subclasses ( cls , include_this = True ) :      children = type . __subclasses__ ( cls ) if children :          for sc in children :              for item in iter_branch_subclasses ( sc ) :                  yield item    elif include_this :          yield cls   def get_branch_subclasses ( cls ) :      return list ( iter_branch_subclasses ( cls , include_this = False ) )  def iter_final_subclasses ( cls , * , include_this = True ) :      from collections import deque nodes = deque ( [ cls ] ) while nodes :          node = nodes . pop ( ) children = node . __subclasses__ ( ) if children :              nodes . extend ( children )  else :              if node is not cls or include_this :                  yield node     def get_final_subclasses ( cls , * , include_this = True ) :      return list ( iter_final_subclasses ( cls , include_this = include_this ) )  def FinalSubclassEnumeration ( superclass , * , dynamic = True ) :      class enumtype ( type ) :          @ property def __members__ ( self ) :              if self . _cached_members is None or self . _dynamic :                  result = { c . __name__ : c for c in iter_final_subclasses ( superclass , include_this = False ) } if not self . _dynamic :                      self . _cached_members = dict ( result )   else :                  result = dict ( self . _cached_members )  return result  def __getattr__ ( self , attr ) :              result = self . __members__ . get ( attr , None ) if result is None :                  raise AttributeError ( attr )  else :                  return result   def __dir__ ( self ) :              return list ( self . __members__ . keys ( ) ) + [ <str> ]  def invalidate_cache ( self ) :              self . _cached_members = None   class enumeration ( metaclass = enumtype ) :          _dynamic = dynamic _cached_members = None  return enumeration  class xproperty ( property ) :      def __init__ ( self , fget , doc = None ) :          if fget is not None :              super ( ) . __init__ ( fget , doc = doc )  else :              raise TypeError ( <str> )   def __get__ ( self , instance , owner ) :          return self . fget ( instance if instance is not None else owner )   class classproperty ( property ) :      def __get__ ( self , instance , owner ) :          obj = type ( instance ) if instance is not None else owner return super ( ) . __get__ ( obj , owner )  def __set__ ( self , instance , value ) :          obj = instance if isinstance ( instance , type ) else type ( instance ) super ( ) . __set__ ( obj , value )  def __delete__ ( self , instance ) :          obj = instance if isinstance ( instance , type ) else type ( instance ) super ( ) . __delete__ ( obj )   class staticproperty ( property ) :      def __get__ ( self , instance , owner ) :          if self . fget is not None :              return self . fget ( )  else :              raise AttributeError ( <str> )   def __set__ ( self , instance , value ) :          if self . fset is not None :              self . fset ( value )  else :              raise AttributeError ( <str> )   def __delete__ ( self , instance ) :          if self . fdel is not None :              self . fdel ( )  else :              raise AttributeError ( <str> )    class memoized_property :      def __init__ ( self , fget , doc = None ) :          self . fget = fget self . __doc__ = doc or fget . __doc__ self . __name__ = fget . __name__  def __get__ ( self , obj , cls ) :          if obj is None :              return self  obj . __dict__ [ self . __name__ ] = result = self . fget ( obj ) return result  def reset ( self , instance ) :          instance . __dict__ . pop ( self . __name__ , None )   def setdefaultattr ( obj , name , value ) :      res = getattr ( obj , name , Unset ) if res is Unset :          if isinstance ( value , lazy ) :              value = value ( )  setattr ( obj , name , value ) res = value  return res  def adapt_exception ( value , ** kwargs ) :      isi , ebc = isinstance , Exception issc = lambda maybe , cls : isi ( maybe , type ) and issubclass ( maybe , cls ) if isi ( value , ebc ) or issc ( value , ebc ) :          return value  elif isi ( value , ( tuple , list ) ) and len ( value ) > 0 and issc ( value [ 0 ] , ebc ) :          map = lambda x : x . format ( ** kwargs ) if isinstance ( x , str ) else x ecls = value [ 0 ] return ecls ( * ( map ( x ) for x in value [ 1 : ] ) )  else :          return None   def copy_class ( cls , meta = None , ignores = None , new_attrs = None , new_name = None ) :      from types import new_class from xotl . tools . future . types import MemberDescriptorType def _get_ignored ( what ) :          if callable ( what ) :              return what  else :              return lambda s : s == what   if not meta :          meta = type ( cls )  if ignores :          ignores = tuple ( _get_ignored ( i ) for i in ignores ) ignored = lambda name : any ( ignore ( name ) for ignore in ignores )  else :          ignored = None  valid_names = ( <str> , <str> , <str> , <str> , <str> ) attrs = { name : value for name , value in cls . __dict__ . items ( ) if name not in valid_names if not isinstance ( value , MemberDescriptorType ) if ignored is None or not ignored ( name ) } if new_attrs :          attrs . update ( new_attrs )  def exec_body ( ns ) :          ns . update ( attrs )  name = new_name if new_name else cls . __name__ result = new_class ( name , cls . __bases__ , { <str> : meta } , exec_body ) return result  def smart_copy ( * args , defaults = None ) :      from xotl . tools . future . collections import MutableMapping , Mapping from xotl . tools . symbols import Undefined from xotl . tools . validators . identifiers import is_valid_identifier from xotl . tools . values . simple import logic_iterable_coerce , nil * sources , target = args if not sources :          raise TypeError ( <str> )  if isinstance ( target , ( bool , type ( None ) , int , float , str ) ) :          raise TypeError ( <str> <str> . format ( type ( target ) . __name__ ) )  if isinstance ( target , MutableMapping ) :          def setter ( key , val ) :              target [ key ] = val   else :          def setter ( key , val ) :              if is_valid_identifier ( key ) :                  setattr ( target , key , val )    _mapping = isinstance ( defaults , Mapping ) if _mapping or logic_iterable_coerce ( defaults ) is not nil :          for key , val in ( ( key , get_first_of ( sources , key , default = Unset ) ) for key in defaults ) :              if val is Unset :                  if _mapping :                      val = defaults . get ( key , None )  else :                      val = None  exc = adapt_exception ( val , key = key ) if exc or val is Undefined :                      raise KeyError ( key )   setter ( key , val )   else :          keys = [ ] for source in sources :              get = smart_getter ( source ) items = source if isinstance ( source , Mapping ) else dir ( source ) for key in items :                  private = isinstance ( key , str ) and key . startswith ( <str> ) if ( defaults is False or defaults is None ) and private :                      copy = False  elif callable ( defaults ) :                      copy = defaults ( key , source = source )  else :                      copy = True  if key not in keys :                      keys . append ( key ) if copy :                          setter ( key , get ( key ) )      return target  def extract_attrs ( obj , * names , ** kwargs ) :      default = kwargs . pop ( <str> , Unset ) if kwargs :          raise TypeError ( <str> )  getter = get_traverser ( * names , default = default ) return getter ( obj )  def traverse ( obj , path , default = Unset , sep = <str> , getter = None ) :      _traverser = get_traverser ( path , default = default , sep = sep , getter = getter ) return _traverser ( obj )  def get_traverser ( * paths , ** kw ) :      from xotl . tools . params import check_count check_count ( paths , 1 , caller = <str> ) def _traverser ( path , default = Unset , sep = <str> , getter = None ) :          if not getter :              getter = lambda o , a , default = None : smart_getter ( o ) ( a , default )  def inner ( obj ) :              found = object ( ) current = obj attrs = path . split ( sep ) while current is not found and attrs :                  attr = attrs . pop ( 0 ) current = getter ( current , attr , found )  if current is found :                  if default is Unset :                      raise AttributeError ( attr )  else :                      return default   else :                  return current   return inner  if len ( paths ) == 1 :          result = _traverser ( paths [ 0 ] , ** kw )  else :          _traversers = tuple ( _traverser ( path , ** kw ) for path in paths ) def _result ( obj ) :              return tuple ( traverse ( obj ) for traverse in _traversers )  result = _result  return result  def dict_merge ( * dicts , ** others ) :      from collections import Mapping , Sequence , Set , Container if others :          dicts = dicts + ( others , )  dicts = list ( dicts ) result = { } collections = ( Set , Sequence ) while dicts :          current = dicts . pop ( 0 ) for key , val in current . items ( ) :              if isinstance ( val , Mapping ) :                  val = { key : val [ key ] for key in val }  value = result . setdefault ( key , val ) if value is not val :                  if all ( isinstance ( v , collections ) for v in ( value , val ) ) :                      join = get_first_of ( ( value , ) , <str> , <str> ) if join :                          constructor = type ( value ) value = join ( constructor ( val ) )  else :                          raise ValueError ( <str> % key )   elif all ( isinstance ( v , Mapping ) for v in ( value , val ) ) :                      value = dict_merge ( value , val )  elif all ( not isinstance ( v , Container ) for v in ( value , val ) ) :                      value = val  else :                      raise TypeError ( <str> % key )  result [ key ] = value    return result  @ contextmanager def save_attributes ( obj , * attrs , getter = smart_getter , setter = smart_setter ) :      <str> from xotl . tools . params import check_count check_count ( attrs , 1 ) get_ = getter ( obj ) set_ = setter ( obj ) props = { attr : get_ ( attr ) for attr in attrs } try :          yield obj  finally :          for attr , val in props . items ( ) :              set_ ( attr , val )    @ contextmanager def temp_attributes ( obj , attrs , getter = smart_getter , setter = smart_setter ) :      set_ = setter ( obj ) with save_attributes ( obj , * tuple ( attrs . keys ( ) ) , getter = getter , setter = setter ) :          for attr , value in attrs . items ( ) :              set_ ( attr , value )  yield   def import_object ( name , package = None , sep = <str> , default = None , ** kwargs ) :      import importlib imp = importlib . import_module if not isinstance ( name , str ) :          return name  sep = <str> if <str> in name else sep module_name , _ , cls_name = name . rpartition ( sep ) if not module_name :          cls_name , module_name = None , package if package else cls_name  try :          module = imp ( module_name , package = package , ** kwargs ) return getattr ( module , cls_name ) if cls_name else module  except ( ImportError , AttributeError ) :          if default is None :              raise   return default  def delegator ( attribute , attrs_map , metaclass = type ) :      descriptors = { key : DelegatedAttribute ( attribute , attr ) for key , attr in attrs_map . items ( ) } return metaclass ( <str> , ( object , ) , descriptors )  class DelegatedAttribute :      def __init__ ( self , target_name , delegated_attr , default = Unset ) :          self . target_name = target_name self . attr = delegated_attr self . default = default  def __get__ ( self , instance , owner ) :          if instance is not None :              target = getattr ( instance , self . target_name ) try :                  return getattr ( target , self . attr )  except AttributeError :                  if self . default is not Unset :                      return self . default  else :                      raise    else :              return self   def __repr__ ( self ) :          return <str> % ( self . target_name , self . attr )   del contextmanager  