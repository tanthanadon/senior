from functools import singledispatch from itertools import chain import numpy from gem . node import Memoizer , reuse_if_untouched from gem . gem import ( ComponentTensor , Concatenate , FlexiblyIndexed , Index , Indexed , Literal , Node , partial_indexed , reshape , view ) from gem . optimise import remove_componenttensors from gem . interpreter import evaluate __all__ = [ <str> , <str> ] def find_group ( expressions ) :      free_indices = set ( ) . union ( chain ( * [ e . free_indices for e in expressions ] ) ) index = None nodes = [ ] seen = set ( ) lifo = [ ] for root in expressions :          if root not in seen :              seen . add ( root ) lifo . append ( root )   while lifo :          node = lifo . pop ( ) if not free_indices . intersection ( node . free_indices ) :              continue  if isinstance ( node , Indexed ) :              child , = node . children if isinstance ( child , Concatenate ) :                  i , = node . multiindex assert i in free_indices if ( index or i ) == i :                      index = i nodes . append ( node ) continue    for child in reversed ( node . children ) :              if child not in seen :                  seen . add ( child ) lifo . append ( child )    return index and nodes  def split_variable ( variable_ref , index , multiindices ) :      assert isinstance ( variable_ref , FlexiblyIndexed ) other_indices = list ( variable_ref . index_ordering ( ) ) other_indices . remove ( index ) other_indices = tuple ( other_indices ) data = ComponentTensor ( variable_ref , ( index , ) + other_indices ) slices = [ slice ( None ) ] * len ( other_indices ) shapes = [ ( other_index . extent , ) for other_index in other_indices ] offset = 0 for multiindex in multiindices :          shape = tuple ( index . extent for index in multiindex ) size = numpy . prod ( shape , dtype = int ) slice_ = slice ( offset , offset + size ) offset += size sub_ref = Indexed ( reshape ( view ( data , slice_ , * slices ) , shape , * shapes ) , multiindex + other_indices ) sub_ref , = remove_componenttensors ( ( sub_ref , ) ) yield sub_ref   def _replace_node ( node , self ) :      assert isinstance ( node , Node ) if self . cut ( node ) :          return node  try :          return self . mapping [ node ]  except KeyError :          return reuse_if_untouched ( node , self )   def replace_node ( expression , mapping , cut = None ) :      mapper = Memoizer ( _replace_node ) mapper . mapping = mapping mapper . cut = cut or ( lambda node : False ) return mapper ( expression )  def _unconcatenate ( cache , pairs ) :      concat_group = find_group ( [ e for v , e in pairs ] ) if concat_group is None :          return pairs  concat_ref = next ( iter ( concat_group ) ) assert isinstance ( concat_ref , Indexed ) concat_expr , = concat_ref . children index , = concat_ref . multiindex assert isinstance ( concat_expr , Concatenate ) try :          multiindices = cache [ index ]  except KeyError :          multiindices = tuple ( tuple ( Index ( extent = d ) for d in child . shape ) for child in concat_expr . children ) cache [ index ] = multiindices  def cut ( node ) :          return index not in node . free_indices  mappings = [ { } for i in range ( len ( multiindices ) ) ] for concat_ref in concat_group :          concat_expr , = concat_ref . children for i in range ( len ( multiindices ) ) :              sub_ref = Indexed ( concat_expr . children [ i ] , multiindices [ i ] ) sub_ref , = remove_componenttensors ( ( sub_ref , ) ) mappings [ i ] [ concat_ref ] = sub_ref   split_pairs = [ ] for var , expr in pairs :          if index not in var . free_indices :              split_pairs . append ( ( var , expr ) )  else :              for v , m in zip ( split_variable ( var , index , multiindices ) , mappings ) :                  split_pairs . append ( ( v , replace_node ( expr , m , cut ) ) )    return _unconcatenate ( cache , split_pairs )  def unconcatenate ( pairs , cache = None ) :      if cache is None :          cache = { }  exprs = remove_componenttensors ( [ e for v , e in pairs ] ) pairs = [ ( v , e ) for ( v , _ ) , e in zip ( pairs , exprs ) ] return _unconcatenate ( cache , pairs )  @ singledispatch def _flatten ( node , self ) :      raise AssertionError ( <str> % type ( node ) )  _flatten . register ( Node ) ( reuse_if_untouched ) @ _flatten . register ( Concatenate ) def _flatten_concatenate ( node , self ) :      result , = evaluate ( [ node ] ) return partial_indexed ( Literal ( result . arr ) , result . fids )  def flatten ( expressions ) :      mapper = Memoizer ( _flatten ) return list ( map ( mapper , expressions ) )   