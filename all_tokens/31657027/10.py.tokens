from collections import Counter , OrderedDict , defaultdict , namedtuple from functools import singledispatch from itertools import product from sys import intern from gem . node import Memoizer , traversal from gem . gem import ( Node , Conditional , Zero , Product , Sum , Indexed , ListTensor , one ) from gem . optimise import ( remove_componenttensors , sum_factorise , traverse_product , traverse_sum , unroll_indexsum , make_rename_map , make_renamer ) ATOMIC = intern ( <str> ) COMPOUND = intern ( <str> ) OTHER = intern ( <str> ) Monomial = namedtuple ( <str> , [ <str> , <str> , <str> ] ) class MonomialSum ( object ) :      def __init__ ( self ) :          self . monomials = defaultdict ( Zero ) self . ordering = OrderedDict ( )  def __len__ ( self ) :          return len ( self . ordering )  def add ( self , sum_indices , atomics , rest ) :          sum_indices = tuple ( sum_indices ) sum_indices_set = frozenset ( sum_indices ) assert len ( sum_indices ) == len ( sum_indices_set ) atomics = tuple ( atomics ) atomics_set = frozenset ( Counter ( atomics ) . items ( ) ) assert isinstance ( rest , Node ) key = ( sum_indices_set , atomics_set ) self . monomials [ key ] = Sum ( self . monomials [ key ] , rest ) self . ordering . setdefault ( key , ( sum_indices , atomics ) )  def __iter__ ( self ) :          for key , ( sum_indices , atomics ) in self . ordering . items ( ) :              rest = self . monomials [ key ] yield Monomial ( sum_indices , atomics , rest )   @ staticmethod def sum ( * args ) :          result = MonomialSum ( ) for arg in args :              assert isinstance ( arg , MonomialSum ) for key , rest in arg . monomials . items ( ) :                  result . monomials [ key ] = Sum ( result . monomials [ key ] , rest )  for key , value in arg . ordering . items ( ) :                  result . ordering . setdefault ( key , value )   return result  @ staticmethod def product ( * args , ** kwargs ) :          rename_map = kwargs . pop ( <str> , None ) if rename_map is None :              rename_map = make_rename_map ( )  if kwargs :              raise ValueError ( <str> + kwargs . pop ( ) )  result = MonomialSum ( ) for monomials in product ( * args ) :              renamer = make_renamer ( rename_map ) sum_indices = [ ] atomics = [ ] rest = one for s , a , r in monomials :                  s_ , applier = renamer ( s ) sum_indices . extend ( s_ ) atomics . extend ( map ( applier , a ) ) rest = Product ( applier ( r ) , rest )  result . add ( sum_indices , atomics , rest )  return result   class FactorisationError ( Exception ) :      pass  @ singledispatch def _collect_monomials ( expression , self ) :      def stop_at ( expr ) :          return self . classifier ( expr ) != COMPOUND  common_indices , terms = traverse_product ( expression , stop_at = stop_at ) common_indices = tuple ( common_indices ) common_atomics = [ ] common_others = [ ] compounds = [ ] for term in terms :          label = self . classifier ( term ) if label == ATOMIC :              common_atomics . append ( term )  elif label == COMPOUND :              compounds . append ( term )  elif label == OTHER :              common_others . append ( term )  else :              raise ValueError ( <str> )   common_atomics = tuple ( common_atomics ) sums = [ ] for expr in compounds :          summands = traverse_sum ( expr , stop_at = stop_at ) if len ( summands ) <= 1 and not isinstance ( expr , Conditional ) :              raise FactorisationError ( expr )  sums . append ( MonomialSum . sum ( * map ( self , summands ) ) )  result = MonomialSum ( ) for s , a , r in MonomialSum . product ( * sums , rename_map = self . rename_map ) :          renamer = make_renamer ( self . rename_map ) renamer ( common_indices ) s_ , applier = renamer ( s ) all_indices = common_indices + s_ atomics = common_atomics + tuple ( map ( applier , a ) ) atomic_indices = set ( ) . union ( * [ atomic . free_indices for atomic in atomics ] ) sum_indices = tuple ( index for index in all_indices if index in atomic_indices ) rest_indices = tuple ( index for index in all_indices if index not in atomic_indices ) rest = sum_factorise ( rest_indices , common_others + [ applier ( r ) ] ) result . add ( sum_indices , atomics , rest )  return result  @ _collect_monomials . register ( Conditional ) def _collect_monomials_conditional ( expression , self ) :      condition , then , else_ = expression . children then_ms = self ( then ) else_ms = self ( else_ ) result = MonomialSum ( ) zero = Zero ( ) for k in then_ms . monomials . keys ( ) | else_ms . monomials . keys ( ) :          _then = then_ms . monomials . get ( k , zero ) _else = else_ms . monomials . get ( k , zero ) result . monomials [ k ] = Conditional ( condition , _then , _else )  result . ordering = then_ms . ordering . copy ( ) for k , v in else_ms . ordering . items ( ) :          result . ordering . setdefault ( k , v )  return result  def collect_monomials ( expressions , classifier ) :      expressions = remove_componenttensors ( expressions ) must_unroll = [ ] for node in traversal ( expressions ) :          if isinstance ( node , Indexed ) :              child , = node . children if isinstance ( child , ListTensor ) and classifier ( node ) == COMPOUND :                  must_unroll . extend ( node . multiindex )    if must_unroll :          must_unroll = set ( must_unroll ) expressions = unroll_indexsum ( expressions , predicate = lambda i : i in must_unroll ) expressions = remove_componenttensors ( expressions )  mapper = Memoizer ( _collect_monomials ) mapper . classifier = classifier mapper . rename_map = make_rename_map ( ) return list ( map ( mapper , expressions ) )   