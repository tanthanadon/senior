import numpy import functools from itertools import chain , product import coffee . base as coffee import gem from gem . optimise import remove_componenttensors as prune from finat import TensorFiniteElement import ufl from tsfc . kernel_interface . common import KernelBuilderBase from tsfc . finatinterface import create_element as _create_element create_element = functools . partial ( _create_element , shape_innermost = False ) class KernelBuilder ( KernelBuilderBase ) :      def __init__ ( self , integral_type , subdomain_id , domain_number , scalar_type = None , diagonal = False ) :          if diagonal :              raise NotImplementedError ( <str> )  super ( KernelBuilder , self ) . __init__ ( scalar_type , integral_type . startswith ( <str> ) ) self . integral_type = integral_type self . local_tensor = None self . coordinates_args = None self . coefficient_args = None self . coefficient_split = None if self . interior_facet :              self . _cell_orientations = ( gem . Variable ( <str> , ( ) ) , gem . Variable ( <str> , ( ) ) )  else :              self . _cell_orientations = ( gem . Variable ( <str> , ( ) ) , )  if integral_type == <str> :              self . _entity_number = { None : gem . VariableIndex ( gem . Variable ( <str> , ( ) ) ) }  elif integral_type == <str> :              self . _entity_number = { <str> : gem . VariableIndex ( gem . Variable ( <str> , ( ) ) ) , <str> : gem . VariableIndex ( gem . Variable ( <str> , ( ) ) ) }  elif integral_type == <str> :              self . _entity_number = { None : gem . VariableIndex ( gem . Variable ( <str> , ( ) ) ) }   def set_arguments ( self , arguments , multiindices ) :          self . local_tensor , prepare , expressions = prepare_arguments ( arguments , multiindices , self . scalar_type , interior_facet = self . interior_facet ) self . apply_glue ( prepare ) return expressions  def set_coordinates ( self , domain ) :          f = ufl . Coefficient ( ufl . FunctionSpace ( domain , domain . ufl_coordinate_element ( ) ) ) self . domain_coordinate [ domain ] = f self . coordinates_args , expression = prepare_coordinates ( f , <str> , self . scalar_type , interior_facet = self . interior_facet ) self . coefficient_map [ f ] = expression  def set_cell_sizes ( self , domain ) :          pass  def set_coefficients ( self , integral_data , form_data ) :          name = <str> self . coefficient_args = [ coffee . Decl ( self . scalar_type , coffee . Symbol ( name ) , pointers = [ ( <str> , ) , ( ) ] , qualifiers = [ <str> ] ) ] for n in range ( len ( integral_data . enabled_coefficients ) ) :              if not integral_data . enabled_coefficients [ n ] :                  continue  coefficient = form_data . function_replace_map [ form_data . reduced_coefficients [ n ] ] expression = prepare_coefficient ( coefficient , n , name , self . interior_facet ) self . coefficient_map [ coefficient ] = expression   def construct_kernel ( self , name , impero_c , precision , index_names , quadrature_rule = None ) :          from tsfc . coffee import generate as generate_coffee body = generate_coffee ( impero_c , index_names , precision , scalar_type = self . scalar_type ) return self . _construct_kernel_from_body ( name , body )  def _construct_kernel_from_body ( self , name , body , quadrature_rule ) :          args = [ self . local_tensor ] args . extend ( self . coefficient_args ) args . extend ( self . coordinates_args ) if self . integral_type == <str> :              args . append ( coffee . Decl ( <str> , coffee . Symbol ( <str> ) ) )  elif self . integral_type == <str> :              args . append ( coffee . Decl ( <str> , coffee . Symbol ( <str> ) ) ) args . append ( coffee . Decl ( <str> , coffee . Symbol ( <str> ) ) )  elif self . integral_type == <str> :              args . append ( coffee . Decl ( <str> , coffee . Symbol ( <str> ) ) )  if self . interior_facet :              args . append ( coffee . Decl ( <str> , coffee . Symbol ( <str> ) ) ) args . append ( coffee . Decl ( <str> , coffee . Symbol ( <str> ) ) )  else :              args . append ( coffee . Decl ( <str> , coffee . Symbol ( <str> ) ) )  return KernelBuilderBase . construct_kernel ( self , name , args , body )  def construct_empty_kernel ( self , name ) :          body = coffee . Block ( [ ] ) return self . _construct_kernel_from_body ( name , body )  def create_element ( self , element , ** kwargs ) :          return create_element ( element , ** kwargs )   def prepare_coefficient ( coefficient , num , name , interior_facet = False ) :      varexp = gem . Variable ( name , ( None , None ) ) if coefficient . ufl_element ( ) . family ( ) == <str> :          size = numpy . prod ( coefficient . ufl_shape , dtype = int ) data = gem . view ( varexp , slice ( num , num + 1 ) , slice ( size ) ) return gem . reshape ( data , ( ) , coefficient . ufl_shape )  element = create_element ( coefficient . ufl_element ( ) ) size = numpy . prod ( element . index_shape , dtype = int ) def expression ( data ) :          result , = prune ( [ gem . reshape ( gem . view ( data , slice ( size ) ) , element . index_shape ) ] ) return result  if not interior_facet :          data = gem . view ( varexp , slice ( num , num + 1 ) , slice ( size ) ) return expression ( gem . reshape ( data , ( ) , ( size , ) ) )  else :          data_p = gem . view ( varexp , slice ( num , num + 1 ) , slice ( size ) ) data_m = gem . view ( varexp , slice ( num , num + 1 ) , slice ( size , 2 * size ) ) return ( expression ( gem . reshape ( data_p , ( ) , ( size , ) ) ) , expression ( gem . reshape ( data_m , ( ) , ( size , ) ) ) )   def prepare_coordinates ( coefficient , name , scalar_type , interior_facet = False ) :      finat_element = create_element ( coefficient . ufl_element ( ) ) shape = finat_element . index_shape size = numpy . prod ( shape , dtype = int ) assert isinstance ( finat_element , TensorFiniteElement ) scalar_shape = finat_element . base_element . index_shape tensor_shape = finat_element . _shape transposed_shape = scalar_shape + tensor_shape scalar_rank = len ( scalar_shape ) def transpose ( expr ) :          indices = tuple ( gem . Index ( extent = extent ) for extent in expr . shape ) transposed_indices = indices [ scalar_rank : ] + indices [ : scalar_rank ] return gem . ComponentTensor ( gem . Indexed ( expr , indices ) , transposed_indices )  if not interior_facet :          funargs = [ coffee . Decl ( scalar_type , coffee . Symbol ( name ) , pointers = [ ( <str> , ) ] , qualifiers = [ <str> ] ) ] variable = gem . Variable ( name , ( size , ) ) expression = transpose ( gem . reshape ( variable , transposed_shape ) )  else :          funargs = [ coffee . Decl ( scalar_type , coffee . Symbol ( name + <str> ) , pointers = [ ( <str> , ) ] , qualifiers = [ <str> ] ) , coffee . Decl ( scalar_type , coffee . Symbol ( name + <str> ) , pointers = [ ( <str> , ) ] , qualifiers = [ <str> ] ) ] variable0 = gem . Variable ( name + <str> , ( size , ) ) variable1 = gem . Variable ( name + <str> , ( size , ) ) expression = ( transpose ( gem . reshape ( variable0 , transposed_shape ) ) , transpose ( gem . reshape ( variable1 , transposed_shape ) ) )  return funargs , expression  def prepare_arguments ( arguments , multiindices , scalar_type , interior_facet = False ) :      funarg = coffee . Decl ( scalar_type , coffee . Symbol ( <str> ) , pointers = [ ( ) ] ) varexp = gem . Variable ( <str> , ( None , ) ) if len ( arguments ) == 0 :          zero = coffee . FlatBlock ( <str> . format ( name = funarg . sym . gencode ( ) ) ) return funarg , [ zero ] , [ gem . reshape ( varexp , ( ) ) ]  elements = tuple ( create_element ( arg . ufl_element ( ) ) for arg in arguments ) shapes = [ element . index_shape for element in elements ] indices = tuple ( chain ( * multiindices ) ) def expression ( restricted ) :          return gem . Indexed ( gem . reshape ( restricted , * shapes ) , indices )  u_shape = numpy . array ( [ numpy . prod ( element . index_shape , dtype = int ) for element in elements ] ) if interior_facet :          c_shape = tuple ( 2 * u_shape ) slicez = [ [ slice ( r * s , ( r + 1 ) * s ) for r , s in zip ( restrictions , u_shape ) ] for restrictions in product ( ( 0 , 1 ) , repeat = len ( arguments ) ) ]  else :          c_shape = tuple ( u_shape ) slicez = [ [ slice ( s ) for s in u_shape ] ]  expressions = [ expression ( gem . view ( gem . reshape ( varexp , c_shape ) , * slices ) ) for slices in slicez ] zero = coffee . FlatBlock ( str . format ( <str> , name = funarg . sym . gencode ( ) , size = numpy . product ( c_shape , dtype = int ) ) ) return funarg , [ zero ] , prune ( expressions )   