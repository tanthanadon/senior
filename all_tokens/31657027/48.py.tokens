import collections import operator import string import time import sys from functools import reduce from itertools import chain from numpy import asarray import ufl from ufl . algorithms import extract_arguments , extract_coefficients from ufl . algorithms . analysis import has_type from ufl . classes import Form , GeometricQuantity from ufl . log import GREEN from ufl . utils . sequences import max_degree import gem import gem . impero_utils as impero_utils from FIAT . reference_element import TensorProductCell from finat . point_set import PointSet from finat . quadrature import AbstractQuadratureRule , make_quadrature from tsfc import fem , ufl_utils from tsfc . fiatinterface import as_fiat_cell from tsfc . logging import logger from tsfc . parameters import default_parameters , is_complex sys . setrecursionlimit ( 3000 ) def compile_form ( form , prefix = <str> , parameters = None , interface = None , coffee = True , diagonal = False ) :      cpu_time = time . time ( ) assert isinstance ( form , Form ) complex_mode = parameters and is_complex ( parameters . get ( <str> ) ) if complex_mode :          logger . warning ( <str> <str> ) parameters = parameters . copy ( ) parameters [ <str> ] = <str>  fd = ufl_utils . compute_form_data ( form , complex_mode = complex_mode ) logger . info ( GREEN % <str> , time . time ( ) - cpu_time ) kernels = [ ] for integral_data in fd . integral_data :          start = time . time ( ) kernel = compile_integral ( integral_data , fd , prefix , parameters , interface = interface , coffee = coffee , diagonal = diagonal ) if kernel is not None :              kernels . append ( kernel )  logger . info ( GREEN % <str> , time . time ( ) - start )  logger . info ( GREEN % <str> , time . time ( ) - cpu_time ) return kernels  def compile_integral ( integral_data , form_data , prefix , parameters , interface , coffee , * , diagonal = False ) :      if parameters is None :          parameters = default_parameters ( )  else :          _ = default_parameters ( ) _ . update ( parameters ) parameters = _  if interface is None :          if coffee :              import tsfc . kernel_interface . firedrake as firedrake_interface_coffee interface = firedrake_interface_coffee . KernelBuilder  else :              import tsfc . kernel_interface . firedrake_loopy as firedrake_interface_loopy interface = firedrake_interface_loopy . KernelBuilder   if parameters . get ( <str> ) in [ <str> , <str> , None , - 1 , <str> ] :          del parameters [ <str> ]  if parameters . get ( <str> ) in [ <str> , <str> , None ] :          del parameters [ <str> ]  integral_type = integral_data . integral_type interior_facet = integral_type . startswith ( <str> ) mesh = integral_data . domain cell = integral_data . domain . ufl_cell ( ) arguments = form_data . preprocessed_form . arguments ( ) kernel_name = <str> % ( prefix , integral_type , integral_data . subdomain_id ) kernel_name = kernel_name . replace ( <str> , <str> ) fiat_cell = as_fiat_cell ( cell ) integration_dim , entity_ids = lower_integral_type ( fiat_cell , integral_type ) quadrature_indices = [ ] domain_numbering = form_data . original_form . domain_numbering ( ) builder = interface ( integral_type , integral_data . subdomain_id , domain_numbering [ integral_data . domain ] , parameters [ <str> ] , diagonal = diagonal ) argument_multiindices = tuple ( builder . create_element ( arg . ufl_element ( ) ) . get_indices ( ) for arg in arguments ) if diagonal :          a , _ = argument_multiindices argument_multiindices = ( a , a )  return_variables = builder . set_arguments ( arguments , argument_multiindices ) builder . set_coordinates ( mesh ) builder . set_cell_sizes ( mesh ) builder . set_coefficients ( integral_data , form_data ) index_cache = { } kernel_cfg = dict ( interface = builder , ufl_cell = cell , integral_type = integral_type , precision = parameters [ <str> ] , integration_dim = integration_dim , entity_ids = entity_ids , argument_multiindices = argument_multiindices , index_cache = index_cache ) mode_irs = collections . OrderedDict ( ) for integral in integral_data . integrals :          params = parameters . copy ( ) params . update ( integral . metadata ( ) ) if params . get ( <str> ) == <str> :              del params [ <str> ]  mode = pick_mode ( params [ <str> ] ) mode_irs . setdefault ( mode , collections . OrderedDict ( ) ) integrand = ufl . replace ( integral . integrand ( ) , form_data . function_replace_map ) integrand = ufl_utils . split_coefficients ( integrand , builder . coefficient_split ) quadrature_degree = params . get ( <str> , params [ <str> ] ) try :              quadrature_degree = params [ <str> ]  except KeyError :              quadrature_degree = params [ <str> ] functions = list ( arguments ) + [ builder . coordinate ( mesh ) ] + list ( integral_data . integral_coefficients ) function_degrees = [ f . ufl_function_space ( ) . ufl_element ( ) . degree ( ) for f in functions ] if all ( ( asarray ( quadrature_degree ) > 10 * asarray ( degree ) ) . all ( ) for degree in function_degrees ) :                  logger . warning ( <str> <str> <str> , quadrature_degree , max_degree ( function_degrees ) )   try :              quad_rule = params [ <str> ]  except KeyError :              integration_cell = fiat_cell . construct_subelement ( integration_dim ) quad_rule = make_quadrature ( integration_cell , quadrature_degree )  if not isinstance ( quad_rule , AbstractQuadratureRule ) :              raise ValueError ( <str> % type ( quad_rule ) )  quadrature_multiindex = quad_rule . point_set . indices quadrature_indices . extend ( quadrature_multiindex ) config = kernel_cfg . copy ( ) config . update ( quadrature_rule = quad_rule ) expressions = fem . compile_ufl ( integrand , interior_facet = interior_facet , ** config ) reps = mode . Integrals ( expressions , quadrature_multiindex , argument_multiindices , params ) for var , rep in zip ( return_variables , reps ) :              mode_irs [ mode ] . setdefault ( var , [ ] ) . append ( rep )   assignments = [ ] for mode , var_reps in mode_irs . items ( ) :          assignments . extend ( mode . flatten ( var_reps . items ( ) , index_cache ) )  if assignments :          return_variables , expressions = zip ( * assignments )  else :          return_variables = [ ] expressions = [ ]  options = dict ( reduce ( operator . and_ , [ mode . finalise_options . items ( ) for mode in mode_irs . keys ( ) ] ) ) expressions = impero_utils . preprocess_gem ( expressions , ** options ) assignments = list ( zip ( return_variables , expressions ) ) builder . register_requirements ( expressions ) split_argument_indices = tuple ( chain ( * [ var . index_ordering ( ) for var in return_variables ] ) ) index_ordering = tuple ( quadrature_indices ) + split_argument_indices try :          impero_c = impero_utils . compile_gem ( assignments , index_ordering , remove_zeros = True )  except impero_utils . NoopError :          return builder . construct_empty_kernel ( kernel_name )  index_names = [ ] def name_index ( index , name ) :          index_names . append ( ( index , name ) ) if index in index_cache :              for multiindex , suffix in zip ( index_cache [ index ] , string . ascii_lowercase ) :                  name_multiindex ( multiindex , name + suffix )    def name_multiindex ( multiindex , name ) :          if len ( multiindex ) == 1 :              name_index ( multiindex [ 0 ] , name )  else :              for i , index in enumerate ( multiindex ) :                  name_index ( index , name + str ( i ) )    name_multiindex ( quadrature_indices , <str> ) for multiindex , name in zip ( argument_multiindices , [ <str> , <str> ] ) :          name_multiindex ( multiindex , name )  return builder . construct_kernel ( kernel_name , impero_c , parameters [ <str> ] , index_names , quad_rule )  def compile_expression_at_points ( expression , points , coordinates , interface = None , parameters = None , coffee = True ) :      import coffee . base as ast import loopy as lp if parameters is None :          parameters = default_parameters ( )  else :          _ = default_parameters ( ) _ . update ( parameters ) parameters = _  complex_mode = is_complex ( parameters [ <str> ] ) expression = ufl_utils . preprocess_expression ( expression , complex_mode = complex_mode ) if interface is None :          if coffee :              import tsfc . kernel_interface . firedrake as firedrake_interface_coffee interface = firedrake_interface_coffee . ExpressionKernelBuilder  else :              import tsfc . kernel_interface . firedrake_loopy as firedrake_interface_loopy interface = firedrake_interface_loopy . ExpressionKernelBuilder   builder = interface ( parameters [ <str> ] ) arguments = extract_arguments ( expression ) argument_multiindices = tuple ( builder . create_element ( arg . ufl_element ( ) ) . get_indices ( ) for arg in arguments ) domain = expression . ufl_domain ( ) if domain :          assert coordinates . ufl_domain ( ) == domain builder . domain_coordinate [ domain ] = coordinates builder . set_cell_sizes ( domain )  coefficients = extract_coefficients ( expression ) if has_type ( expression , GeometricQuantity ) or any ( fem . needs_coordinate_mapping ( c . ufl_element ( ) ) for c in coefficients ) :          coefficients = [ coordinates ] + coefficients  builder . set_coefficients ( coefficients ) expression = ufl_utils . split_coefficients ( expression , builder . coefficient_split ) point_set = PointSet ( points ) config = dict ( interface = builder , ufl_cell = coordinates . ufl_domain ( ) . ufl_cell ( ) , precision = parameters [ <str> ] , point_set = point_set , argument_multiindices = argument_multiindices ) ir , = fem . compile_ufl ( expression , point_sum = False , ** config ) value_shape = ir . shape tensor_indices = tuple ( gem . Index ( ) for s in value_shape ) if value_shape :          ir = gem . Indexed ( ir , tensor_indices )  return_indices = point_set . indices + tensor_indices + tuple ( chain ( * argument_multiindices ) ) return_shape = tuple ( i . extent for i in return_indices ) return_var = gem . Variable ( <str> , return_shape ) if coffee :          return_arg = ast . Decl ( parameters [ <str> ] , ast . Symbol ( <str> , rank = return_shape ) )  else :          return_arg = lp . GlobalArg ( <str> , dtype = parameters [ <str> ] , shape = return_shape )  return_expr = gem . Indexed ( return_var , return_indices ) ir , = impero_utils . preprocess_gem ( [ ir ] ) impero_c = impero_utils . compile_gem ( [ ( return_expr , ir ) ] , return_indices ) point_index , = point_set . indices builder . register_requirements ( [ ir ] ) return builder . construct_kernel ( return_arg , impero_c , parameters [ <str> ] , { point_index : <str> } )  def lower_integral_type ( fiat_cell , integral_type ) :      vert_facet_types = [ <str> , <str> ] horiz_facet_types = [ <str> , <str> , <str> ] dim = fiat_cell . get_dimension ( ) if integral_type == <str> :          integration_dim = dim  elif integral_type in [ <str> , <str> ] :          if isinstance ( fiat_cell , TensorProductCell ) :              raise ValueError ( <str> . format ( integral_type ) )  integration_dim = dim - 1  elif integral_type == <str> :          integration_dim = 0  elif integral_type in vert_facet_types + horiz_facet_types :          if not isinstance ( fiat_cell , TensorProductCell ) :              raise ValueError ( <str> . format ( integral_type ) )  basedim , extrdim = dim assert extrdim == 1 if integral_type in vert_facet_types :              integration_dim = ( basedim - 1 , 1 )  elif integral_type in horiz_facet_types :              integration_dim = ( basedim , 0 )   else :          raise NotImplementedError ( <str> % integral_type )  if integral_type == <str> :          entity_ids = [ 0 ]  elif integral_type == <str> :          entity_ids = [ 1 ]  else :          entity_ids = list ( range ( len ( fiat_cell . get_topology ( ) [ integration_dim ] ) ) )  return integration_dim , entity_ids  def pick_mode ( mode ) :      <str> try :          from firedrake_citations import Citations cites = { <str> : ( <str> , ) , <str> : ( <str> , <str> , ) , <str> : ( <str> , <str> , <str> ) , <str> : ( <str> , <str> , ) } for c in cites [ mode ] :              Citations ( ) . register ( c )   except ImportError :          pass  if mode == <str> :          import tsfc . vanilla as m  elif mode == <str> :          import tsfc . coffee_mode as m  elif mode == <str> :          import tsfc . spectral as m  elif mode == <str> :          import tsfc . tensor as m  else :          raise ValueError ( <str> . format ( mode ) )  return m   