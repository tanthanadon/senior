from collections import OrderedDict , defaultdict from functools import singledispatch , partial , reduce from itertools import combinations , permutations , zip_longest import numpy from gem . utils import groupby from gem . node import ( Memoizer , MemoizerArg , reuse_if_untouched , reuse_if_untouched_arg , traversal ) from gem . gem import ( Node , Terminal , Failure , Identity , Literal , Zero , Product , Sum , Comparison , Conditional , Division , Index , VariableIndex , Indexed , FlexiblyIndexed , IndexSum , ComponentTensor , ListTensor , Delta , partial_indexed , one ) @ singledispatch def literal_rounding ( node , self ) :      raise AssertionError ( <str> % type ( node ) )  literal_rounding . register ( Node ) ( reuse_if_untouched ) @ literal_rounding . register ( Literal ) def literal_rounding_literal ( node , self ) :      table = node . array epsilon = self . epsilon one_decimal = numpy . asarray ( numpy . round ( table , 1 ) ) one_decimal [ numpy . logical_not ( one_decimal ) ] = 0 return Literal ( numpy . where ( abs ( table - one_decimal ) < epsilon , one_decimal , table ) )  def ffc_rounding ( expression , epsilon ) :      mapper = Memoizer ( literal_rounding ) mapper . epsilon = epsilon return mapper ( expression )  @ singledispatch def _replace_division ( node , self ) :      raise AssertionError ( <str> % type ( node ) )  _replace_division . register ( Node ) ( reuse_if_untouched ) @ _replace_division . register ( Division ) def _replace_division_division ( node , self ) :      a , b = node . children return Product ( self ( a ) , Division ( one , self ( b ) ) )  def replace_division ( expressions ) :      mapper = Memoizer ( _replace_division ) return list ( map ( mapper , expressions ) )  @ singledispatch def replace_indices ( node , self , subst ) :      raise AssertionError ( <str> % type ( node ) )  replace_indices . register ( Node ) ( reuse_if_untouched_arg ) @ replace_indices . register ( Delta ) def replace_indices_delta ( node , self , subst ) :      substitute = dict ( subst ) i = substitute . get ( node . i , node . i ) j = substitute . get ( node . j , node . j ) if i == node . i and j == node . j :          return node  else :          return Delta ( i , j )   @ replace_indices . register ( Indexed ) def replace_indices_indexed ( node , self , subst ) :      child , = node . children substitute = dict ( subst ) multiindex = tuple ( substitute . get ( i , i ) for i in node . multiindex ) if isinstance ( child , ComponentTensor ) :          substitute . update ( zip ( child . multiindex , multiindex ) ) return self ( child . children [ 0 ] , tuple ( sorted ( substitute . items ( ) ) ) )  else :          new_child = self ( child , subst ) if new_child == child and multiindex == node . multiindex :              return node  else :              return Indexed ( new_child , multiindex )    @ replace_indices . register ( FlexiblyIndexed ) def replace_indices_flexiblyindexed ( node , self , subst ) :      child , = node . children assert isinstance ( child , Terminal ) assert not child . free_indices substitute = dict ( subst ) dim2idxs = tuple ( ( offset , tuple ( ( substitute . get ( i , i ) , s ) for i , s in idxs ) ) for offset , idxs in node . dim2idxs ) if dim2idxs == node . dim2idxs :          return node  else :          return FlexiblyIndexed ( child , dim2idxs )   def filtered_replace_indices ( node , self , subst ) :      filtered_subst = tuple ( ( k , v ) for k , v in subst if k in node . free_indices ) return replace_indices ( node , self , filtered_subst )  def remove_componenttensors ( expressions ) :      mapper = MemoizerArg ( filtered_replace_indices ) return [ mapper ( expression , ( ) ) for expression in expressions ]  def _select_expression ( expressions , index ) :      expr = expressions [ 0 ] if all ( e == expr for e in expressions ) :          return expr  types = set ( map ( type , expressions ) ) if types <= { Indexed , Zero } :          multiindex , = set ( e . multiindex for e in expressions if isinstance ( e , Indexed ) ) shape = tuple ( i . extent for i in multiindex if isinstance ( i , Index ) ) def child ( expression ) :              if isinstance ( expression , Indexed ) :                  return expression . children [ 0 ]  elif isinstance ( expression , Zero ) :                  return Zero ( shape )   return Indexed ( _select_expression ( list ( map ( child , expressions ) ) , index ) , multiindex )  if types <= { Literal , Zero , Failure } :          return partial_indexed ( ListTensor ( expressions ) , ( index , ) )  if types <= { ComponentTensor , Zero } :          shape , = set ( e . shape for e in expressions ) multiindex = tuple ( Index ( extent = d ) for d in shape ) children = remove_componenttensors ( [ Indexed ( e , multiindex ) for e in expressions ] ) return ComponentTensor ( _select_expression ( children , index ) , multiindex )  if len ( types ) == 1 :          cls , = types if cls . __front__ or cls . __back__ :              raise NotImplementedError ( <str> . format ( cls . __name__ ) )  assert all ( len ( e . children ) == len ( expr . children ) for e in expressions ) assert len ( expr . children ) > 0 return expr . reconstruct ( * [ _select_expression ( nth_children , index ) for nth_children in zip ( * [ e . children for e in expressions ] ) ] )  raise NotImplementedError ( <str> )  def select_expression ( expressions , index ) :      shape = expressions [ 0 ] . shape assert all ( e . shape == shape for e in expressions ) alpha = tuple ( Index ( ) for s in shape ) exprs = remove_componenttensors ( [ Indexed ( e , alpha ) for e in expressions ] ) selected = _select_expression ( exprs , index ) return ComponentTensor ( selected , alpha )  def delta_elimination ( sum_indices , factors ) :      sum_indices = list ( sum_indices ) def substitute ( expression , from_ , to_ ) :          if from_ not in expression . free_indices :              return expression  elif isinstance ( expression , Delta ) :              mapper = MemoizerArg ( filtered_replace_indices ) return mapper ( expression , ( ( from_ , to_ ) , ) )  else :              return Indexed ( ComponentTensor ( expression , ( from_ , ) ) , ( to_ , ) )   delta_queue = [ ( f , index ) for f in factors if isinstance ( f , Delta ) for index in ( f . i , f . j ) if index in sum_indices ] while delta_queue :          delta , from_ = delta_queue [ 0 ] to_ , = list ( { delta . i , delta . j } - { from_ } ) sum_indices . remove ( from_ ) factors = [ substitute ( f , from_ , to_ ) for f in factors ] delta_queue = [ ( f , index ) for f in factors if isinstance ( f , Delta ) for index in ( f . i , f . j ) if index in sum_indices ]  return sum_indices , factors  def associate ( operator , operands ) :      if len ( operands ) > 32 :          raise NotImplementedError ( <str> )  def count ( pair ) :          a , b = pair extents = [ i . extent for i in set ( ) . union ( a . free_indices , b . free_indices ) ] return numpy . prod ( extents , dtype = int )  flops = 0 while len ( operands ) > 1 :          a , b = min ( combinations ( operands , 2 ) , key = count ) flops += count ( ( a , b ) ) operands . remove ( a ) operands . remove ( b ) operands . append ( operator ( a , b ) )  result , = operands return result , flops  def sum_factorise ( sum_indices , factors ) :      if len ( factors ) == 0 and len ( sum_indices ) == 0 :          return one  if len ( sum_indices ) > 6 :          raise NotImplementedError ( <str> )  groups = groupby ( factors , key = lambda f : f . free_indices ) groups = [ reduce ( Product , terms ) for _ , terms in groups ] expression = None best_flops = numpy . inf for ordering in permutations ( sum_indices ) :          terms = groups [ : ] flops = 0 for sum_index in ordering :              contract = [ t for t in terms if sum_index in t . free_indices ] deferred = [ t for t in terms if sum_index not in t . free_indices ] product , flops_ = associate ( Product , contract ) term = IndexSum ( product , ( sum_index , ) ) flops += flops_ + numpy . prod ( [ i . extent for i in product . free_indices ] , dtype = int ) terms = deferred + [ term ]  expr , flops_ = associate ( Product , terms ) flops += flops_ if flops < best_flops :              expression = expr best_flops = flops   return expression  def make_sum ( summands ) :      groups = groupby ( summands , key = lambda f : f . free_indices ) summands = [ reduce ( Sum , terms ) for _ , terms in groups ] result , flops = associate ( Sum , summands ) return result  def make_product ( factors , sum_indices = ( ) ) :      return sum_factorise ( sum_indices , factors )  def make_rename_map ( ) :      return defaultdict ( Index )  def make_renamer ( rename_map ) :      <str> def _renamer ( rename_map , current_set , incoming ) :          renamed = [ ] renames = [ ] for i in incoming :              j = i while j in current_set :                  j = rename_map [ j ]  current_set . add ( j ) renamed . append ( j ) if i != j :                  renames . append ( ( i , j ) )   if renames :              def applier ( expr ) :                  pairs = [ ( i , j ) for i , j in renames if i in expr . free_indices ] if pairs :                      current , renamed = zip ( * pairs ) return Indexed ( ComponentTensor ( expr , current ) , renamed )  else :                      return expr    else :              applier = lambda expr : expr  return tuple ( renamed ) , applier  return partial ( _renamer , rename_map , set ( ) )  def traverse_product ( expression , stop_at = None , rename_map = None ) :      if rename_map is None :          rename_map = make_rename_map ( )  renamer = make_renamer ( rename_map ) sum_indices = [ ] terms = [ ] stack = [ expression ] while stack :          expr = stack . pop ( ) if stop_at is not None and stop_at ( expr ) :              terms . append ( expr )  elif isinstance ( expr , IndexSum ) :              indices , applier = renamer ( expr . multiindex ) sum_indices . extend ( indices ) stack . extend ( remove_componenttensors ( map ( applier , expr . children ) ) )  elif isinstance ( expr , Product ) :              stack . extend ( reversed ( expr . children ) )  elif isinstance ( expr , Division ) :              dividend , divisor = expr . children if dividend == one :                  terms . append ( expr )  else :                  stack . append ( Division ( one , divisor ) ) stack . append ( dividend )   else :              terms . append ( expr )   return sum_indices , terms  def traverse_sum ( expression , stop_at = None ) :      stack = [ expression ] result = [ ] while stack :          expr = stack . pop ( ) if stop_at is not None and stop_at ( expr ) :              result . append ( expr )  elif isinstance ( expr , Sum ) :              stack . extend ( reversed ( expr . children ) )  else :              result . append ( expr )   return result  def contraction ( expression ) :      expression , = remove_componenttensors ( [ expression ] ) def rebuild ( expression ) :          sum_indices , factors = delta_elimination ( * traverse_product ( expression ) ) factors = remove_componenttensors ( factors ) return sum_factorise ( sum_indices , factors )  lt_fis = OrderedDict ( ) for node in traversal ( ( expression , ) ) :          if isinstance ( node , Indexed ) :              child , = node . children if isinstance ( child , ListTensor ) :                  lt_fis . update ( zip_longest ( node . multiindex , ( ) ) )    lt_fis = tuple ( index for index in lt_fis if index in expression . free_indices ) if lt_fis :          tensor = ComponentTensor ( expression , lt_fis ) entries = [ Indexed ( tensor , zeta ) for zeta in numpy . ndindex ( tensor . shape ) ] entries = remove_componenttensors ( entries ) return Indexed ( ListTensor ( numpy . array ( list ( map ( rebuild , entries ) ) ) . reshape ( tensor . shape ) ) , lt_fis )  else :          return rebuild ( expression )   @ singledispatch def _replace_delta ( node , self ) :      raise AssertionError ( <str> % type ( node ) )  _replace_delta . register ( Node ) ( reuse_if_untouched ) @ _replace_delta . register ( Delta ) def _replace_delta_delta ( node , self ) :      i , j = node . i , node . j if isinstance ( i , Index ) or isinstance ( j , Index ) :          if isinstance ( i , Index ) and isinstance ( j , Index ) :              assert i . extent == j . extent  if isinstance ( i , Index ) :              assert i . extent is not None size = i . extent  if isinstance ( j , Index ) :              assert j . extent is not None size = j . extent  return Indexed ( Identity ( size ) , ( i , j ) )  else :          def expression ( index ) :              if isinstance ( index , int ) :                  return Literal ( index )  elif isinstance ( index , VariableIndex ) :                  return index . expression  else :                  raise ValueError ( <str> )   e_i = expression ( i ) e_j = expression ( j ) return Conditional ( Comparison ( <str> , e_i , e_j ) , one , Zero ( ) )   def replace_delta ( expressions ) :      mapper = Memoizer ( _replace_delta ) return list ( map ( mapper , expressions ) )  @ singledispatch def _unroll_indexsum ( node , self ) :      raise AssertionError ( <str> % type ( node ) )  _unroll_indexsum . register ( Node ) ( reuse_if_untouched ) @ _unroll_indexsum . register ( IndexSum ) def _ ( node , self ) :      unroll = tuple ( filter ( self . predicate , node . multiindex ) ) if unroll :          summand = self ( node . children [ 0 ] ) shape = tuple ( index . extent for index in unroll ) unrolled = reduce ( Sum , ( Indexed ( ComponentTensor ( summand , unroll ) , alpha ) for alpha in numpy . ndindex ( shape ) ) , Zero ( ) ) return IndexSum ( unrolled , tuple ( index for index in node . multiindex if index not in unroll ) )  else :          return reuse_if_untouched ( node , self )   def unroll_indexsum ( expressions , predicate ) :      mapper = Memoizer ( _unroll_indexsum ) mapper . predicate = predicate return list ( map ( mapper , expressions ) )  def aggressive_unroll ( expression ) :      if expression . shape :          tensor = numpy . empty ( expression . shape , dtype = object ) for alpha in numpy . ndindex ( expression . shape ) :              tensor [ alpha ] = Indexed ( expression , alpha )  expression , = remove_componenttensors ( ( ListTensor ( tensor ) , ) )  expression , = unroll_indexsum ( ( expression , ) , predicate = lambda index : True ) expression , = remove_componenttensors ( ( expression , ) ) return expression   