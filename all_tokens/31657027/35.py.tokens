from functools import singledispatch import numpy import ufl from ufl import as_tensor , indices , replace from ufl . algorithms import compute_form_data as ufl_compute_form_data from ufl . algorithms import estimate_total_polynomial_degree from ufl . algorithms . analysis import extract_arguments from ufl . algorithms . apply_function_pullbacks import apply_function_pullbacks from ufl . algorithms . apply_algebra_lowering import apply_algebra_lowering from ufl . algorithms . apply_derivatives import apply_derivatives from ufl . algorithms . apply_geometry_lowering import apply_geometry_lowering from ufl . algorithms . comparison_checker import do_comparison_check from ufl . algorithms . remove_complex_nodes import remove_complex_nodes from ufl . corealg . map_dag import map_expr_dag from ufl . corealg . multifunction import MultiFunction from ufl . geometry import QuadratureWeight from ufl . classes import ( Abs , Argument , CellOrientation , Coefficient , ComponentTensor , Expr , FloatValue , Division , MixedElement , MultiIndex , Product , ScalarValue , Sqrt , Zero , CellVolume , FacetArea ) from gem . node import MemoizerArg from tsfc . modified_terminals import ( is_modified_terminal , analyse_modified_terminal , construct_modified_terminal ) preserve_geometry_types = ( CellVolume , FacetArea ) def compute_form_data ( form , do_apply_function_pullbacks = True , do_apply_integral_scaling = True , do_apply_geometry_lowering = True , preserve_geometry_types = preserve_geometry_types , do_apply_restrictions = True , do_estimate_degrees = True , complex_mode = False ) :      fd = ufl_compute_form_data ( form , do_apply_function_pullbacks = do_apply_function_pullbacks , do_apply_integral_scaling = do_apply_integral_scaling , do_apply_geometry_lowering = do_apply_geometry_lowering , preserve_geometry_types = preserve_geometry_types , do_apply_restrictions = do_apply_restrictions , do_estimate_degrees = do_estimate_degrees , complex_mode = complex_mode ) return fd  def one_times ( measure ) :      form = 1 * measure fd = compute_form_data ( form , do_estimate_degrees = False ) itg_data , = fd . integral_data integral , = itg_data . integrals integrand = integral . integrand ( ) expression = replace ( integrand , { QuadratureWeight ( itg_data . domain ) : 1 } ) degree = estimate_total_polynomial_degree ( expression ) return integrand , degree  def entity_avg ( integrand , measure , argument_multiindices ) :      arguments = extract_arguments ( integrand ) if len ( arguments ) == 1 :          a , = arguments integrand = ufl . replace ( integrand , { a : ufl . Argument ( a . function_space ( ) , number = 0 , part = a . part ( ) ) } ) argument_multiindices = ( argument_multiindices [ a . number ( ) ] , )  degree = estimate_total_polynomial_degree ( integrand ) form = integrand * measure fd = compute_form_data ( form , do_estimate_degrees = False , do_apply_function_pullbacks = False ) itg_data , = fd . integral_data integral , = itg_data . integrals integrand = integral . integrand ( ) return integrand , degree , argument_multiindices  def preprocess_expression ( expression , complex_mode = False ) :      if complex_mode :          expression = do_comparison_check ( expression )  else :          expression = remove_complex_nodes ( expression )  expression = apply_algebra_lowering ( expression ) expression = apply_derivatives ( expression ) expression = apply_function_pullbacks ( expression ) expression = apply_geometry_lowering ( expression , preserve_geometry_types ) expression = apply_derivatives ( expression ) expression = apply_geometry_lowering ( expression , preserve_geometry_types ) expression = apply_derivatives ( expression ) if not complex_mode :          expression = remove_complex_nodes ( expression )  return expression  class ModifiedTerminalMixin ( object ) :      def unexpected ( self , o ) :          assert False , <str> % o  grad = unexpected div = unexpected curl = unexpected reference_div = unexpected reference_curl = unexpected def _modified_terminal ( self , o ) :          assert is_modified_terminal ( o ) return self . modified_terminal ( o )  positive_restricted = _modified_terminal negative_restricted = _modified_terminal reference_grad = _modified_terminal reference_value = _modified_terminal terminal = _modified_terminal  class CoefficientSplitter ( MultiFunction , ModifiedTerminalMixin ) :      def __init__ ( self , split ) :          MultiFunction . __init__ ( self ) self . _split = split  expr = MultiFunction . reuse_if_untouched def modified_terminal ( self , o ) :          mt = analyse_modified_terminal ( o ) terminal = mt . terminal if not isinstance ( terminal , Coefficient ) :              return o  if type ( terminal . ufl_element ( ) ) != MixedElement :              return o  assert mt . reference_value beta = indices ( mt . local_derivatives ) components = [ ] for subcoeff in self . _split [ terminal ] :              component = construct_modified_terminal ( mt , subcoeff ) for alpha in numpy . ndindex ( subcoeff . ufl_element ( ) . reference_value_shape ( ) ) :                  components . append ( component [ alpha + beta ] )   c , = indices ( 1 ) return ComponentTensor ( as_tensor ( components ) [ c ] , MultiIndex ( ( c , ) + beta ) )   def split_coefficients ( expression , split ) :      if split is None :          return expression  splitter = CoefficientSplitter ( split ) return map_expr_dag ( splitter , expression )  class PickRestriction ( MultiFunction , ModifiedTerminalMixin ) :      def __init__ ( self , test = None , trial = None ) :          self . restrictions = { 0 : test , 1 : trial } MultiFunction . __init__ ( self )  expr = MultiFunction . reuse_if_untouched def multi_index ( self , o ) :          return o  def modified_terminal ( self , o ) :          mt = analyse_modified_terminal ( o ) t = mt . terminal r = mt . restriction if isinstance ( t , Argument ) and r != self . restrictions [ t . number ( ) ] :              return Zero ( o . ufl_shape , o . ufl_free_indices , o . ufl_index_dimensions )  else :              return o    def ufl_reuse_if_untouched ( o , * ops ) :      if all ( a is b for a , b in zip ( o . ufl_operands , ops ) ) :          return o  else :          return o . _ufl_expr_reconstruct_ ( * ops )   @ singledispatch def _simplify_abs ( o , self , in_abs ) :      raise AssertionError ( <str> % type ( o ) )  @ _simplify_abs . register ( Expr ) def _simplify_abs_expr ( o , self , in_abs ) :      operands = [ self ( op , False ) for op in o . ufl_operands ] result = ufl_reuse_if_untouched ( o , * operands ) if in_abs :          result = Abs ( result )  return result  @ _simplify_abs . register ( Sqrt ) def _simplify_abs_sqrt ( o , self , in_abs ) :      return ufl_reuse_if_untouched ( o , self ( o . ufl_operands [ 0 ] , False ) )  @ _simplify_abs . register ( ScalarValue ) def _simplify_abs_ ( o , self , in_abs ) :      if not in_abs :          return o  return ufl . as_ufl ( abs ( o . _value ) )  @ _simplify_abs . register ( CellOrientation ) def _simplify_abs_cellorientation ( o , self , in_abs ) :      if not in_abs :          return o  return FloatValue ( 1 )  @ _simplify_abs . register ( Division ) @ _simplify_abs . register ( Product ) def _simplify_abs_product ( o , self , in_abs ) :      if not in_abs :          ops = [ self ( op , False ) for op in o . ufl_operands ] return ufl_reuse_if_untouched ( o , * ops )  ops = [ self ( op , True ) for op in o . ufl_operands ] stripped = False strip_ops = [ ] for op in ops :          if isinstance ( op , Abs ) :              stripped = True strip_ops . append ( op . ufl_operands [ 0 ] )  else :              strip_ops . append ( op )   result = ufl_reuse_if_untouched ( o , * strip_ops ) if stripped :          result = Abs ( result )  return result  @ _simplify_abs . register ( Abs ) def _simplify_abs_abs ( o , self , in_abs ) :      return self ( o . ufl_operands [ 0 ] , True )  def simplify_abs ( expression ) :      return MemoizerArg ( _simplify_abs ) ( expression , False )   