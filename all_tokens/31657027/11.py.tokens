import collections class Node ( object ) :      __slots__ = ( <str> , ) __front__ = ( ) __back__ = ( ) def _cons_args ( self , children ) :          front_args = [ getattr ( self , name ) for name in self . __front__ ] back_args = [ getattr ( self , name ) for name in self . __back__ ] return tuple ( front_args ) + tuple ( children ) + tuple ( back_args )  def __reduce__ ( self ) :          return type ( self ) , self . _cons_args ( self . children )  def reconstruct ( self , * args ) :          return type ( self ) ( * self . _cons_args ( args ) )  def __repr__ ( self ) :          cons_args = self . _cons_args ( self . children ) return <str> % ( type ( self ) . __name__ , <str> . join ( map ( repr , cons_args ) ) )  def __eq__ ( self , other ) :          if self is other :              return True  elif hash ( self ) != hash ( other ) :              return False  else :              return self . is_equal ( other )   def __ne__ ( self , other ) :          return not self . __eq__ ( other )  def __hash__ ( self ) :          try :              return self . hash_value  except AttributeError :              self . hash_value = self . get_hash ( ) return self . hash_value   def is_equal ( self , other ) :          if type ( self ) != type ( other ) :              return False  self_consargs = self . _cons_args ( self . children ) other_consargs = other . _cons_args ( other . children ) return self_consargs == other_consargs  def get_hash ( self ) :          return hash ( ( type ( self ) , ) + self . _cons_args ( self . children ) )   def pre_traversal ( expression_dags ) :      seen = set ( ) lifo = [ ] for root in expression_dags :          if root not in seen :              seen . add ( root ) lifo . append ( root )   while lifo :          node = lifo . pop ( ) yield node for child in reversed ( node . children ) :              if child not in seen :                  seen . add ( child ) lifo . append ( child )     def post_traversal ( expression_dags ) :      seen = set ( ) lifo = [ ] for root in expression_dags :          if root not in seen :              seen . add ( root ) lifo . append ( ( root , list ( root . children ) ) )   while lifo :          node , deps = lifo [ - 1 ] for i , dep in enumerate ( deps ) :              if dep is not None and dep not in seen :                  lifo . append ( ( dep , list ( dep . children ) ) ) deps [ i ] = None break   else :              yield node seen . add ( node ) lifo . pop ( )    traversal = pre_traversal def collect_refcount ( expression_dags ) :      result = collections . Counter ( expression_dags ) for node in traversal ( expression_dags ) :          result . update ( node . children )  return result  def noop_recursive ( function ) :      def recursive ( node ) :          return function ( node , recursive )  return recursive  def noop_recursive_arg ( function ) :      def recursive ( node , arg ) :          return function ( node , recursive , arg )  return recursive  class Memoizer ( object ) :      def __init__ ( self , function ) :          self . cache = { } self . function = function  def __call__ ( self , node ) :          try :              return self . cache [ node ]  except KeyError :              result = self . function ( node , self ) self . cache [ node ] = result return result    class MemoizerArg ( object ) :      def __init__ ( self , function ) :          self . cache = { } self . function = function  def __call__ ( self , node , arg ) :          cache_key = ( node , arg ) try :              return self . cache [ cache_key ]  except KeyError :              result = self . function ( node , self , arg ) self . cache [ cache_key ] = result return result    def reuse_if_untouched ( node , self ) :      new_children = list ( map ( self , node . children ) ) if all ( nc == c for nc , c in zip ( new_children , node . children ) ) :          return node  else :          return node . reconstruct ( * new_children )   def reuse_if_untouched_arg ( node , self , arg ) :      new_children = [ self ( child , arg ) for child in node . children ] if all ( nc == c for nc , c in zip ( new_children , node . children ) ) :          return node  else :          return node . reconstruct ( * new_children )    