from collections import OrderedDict import itertools import logging import numpy from gem . gem import IndexSum , one from gem . optimise import make_sum , make_product from gem . refactorise import Monomial from gem . utils import groupby __all__ = [ <str> ] def monomial_sum_to_expression ( monomial_sum ) :      indexsums = [ ] groups = groupby ( monomial_sum , key = lambda m : frozenset ( m . sum_indices ) ) for _ , monomials in groups :          sum_indices = monomials [ 0 ] . sum_indices products = [ make_product ( monomial . atomics + ( monomial . rest , ) ) for monomial in monomials ] indexsums . append ( IndexSum ( make_sum ( products ) , sum_indices ) )  return make_sum ( indexsums )  def index_extent ( factor , linear_indices ) :      return numpy . prod ( [ i . extent for i in factor . free_indices if i in linear_indices ] )  def find_optimal_atomics ( monomials , linear_indices ) :      atomics = tuple ( OrderedDict . fromkeys ( itertools . chain ( * ( monomial . atomics for monomial in monomials ) ) ) ) def cost ( solution ) :          extent = sum ( map ( lambda atomic : index_extent ( atomic , linear_indices ) , solution ) ) return ( len ( solution ) , - extent )  optimal_solution = set ( atomics ) solution = set ( ) max_it = 1 << 12 it = iter ( range ( max_it ) ) def solve ( idx ) :          while idx < len ( monomials ) and solution . intersection ( monomials [ idx ] . atomics ) :              idx += 1  if idx < len ( monomials ) :              if len ( solution ) < len ( optimal_solution ) :                  for atomic in monomials [ idx ] . atomics :                      solution . add ( atomic ) solve ( idx + 1 ) solution . remove ( atomic )    else :              if cost ( solution ) < cost ( optimal_solution ) :                  optimal_solution . clear ( ) optimal_solution . update ( solution )  next ( it )   try :          solve ( 0 )  except StopIteration :          logger = logging . getLogger ( <str> ) logger . warning ( <str> <str> , max_it )  return tuple ( atomic for atomic in atomics if atomic in optimal_solution )  def factorise_atomics ( monomials , optimal_atomics , linear_indices ) :      if not optimal_atomics or len ( monomials ) <= 1 :          return monomials  def group_key ( monomial ) :          for oa in optimal_atomics :              if oa in monomial . atomics :                  return oa   assert False , <str>  factor_group = groupby ( monomials , key = group_key ) assert sum ( len ( ms ) for _ , ms in factor_group ) == len ( monomials ) sum_indices = next ( iter ( monomials ) ) . sum_indices new_monomials = [ ] for oa , monomials in factor_group :          sub_monomials = [ ] for monomial in monomials :              atomics = list ( monomial . atomics ) atomics . remove ( oa ) sub_monomials . append ( Monomial ( ( ) , tuple ( atomics ) , monomial . rest ) )  sub_monomials = optimise_monomials ( sub_monomials , linear_indices ) if len ( sub_monomials ) == 1 :              sub_monomial , = sub_monomials new_monomials . append ( Monomial ( sum_indices , ( oa , ) + sub_monomial . atomics , sub_monomial . rest ) )  else :              node = monomial_sum_to_expression ( sub_monomials ) if set ( linear_indices ) & set ( node . free_indices ) :                  new_monomials . append ( Monomial ( sum_indices , ( oa , node ) , one ) )  else :                  new_monomials . append ( Monomial ( sum_indices , ( oa , ) , node ) )    return new_monomials  def optimise_monomial_sum ( monomial_sum , linear_indices ) :      groups = groupby ( monomial_sum , key = lambda m : frozenset ( m . sum_indices ) ) new_monomials = [ ] for _ , monomials in groups :          new_monomials . extend ( optimise_monomials ( monomials , linear_indices ) )  return monomial_sum_to_expression ( new_monomials )  def optimise_monomials ( monomials , linear_indices ) :      assert len ( set ( frozenset ( m . sum_indices ) for m in monomials ) ) <= 1 , <str> result = [ m for m in monomials if not m . atomics ] active_monomials = [ m for m in monomials if m . atomics ] optimal_atomics = find_optimal_atomics ( active_monomials , linear_indices ) result += factorise_atomics ( active_monomials , optimal_atomics , linear_indices ) return result   