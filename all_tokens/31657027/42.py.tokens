from functools import singledispatch import weakref import finat import ufl from tsfc . fiatinterface import as_fiat_cell __all__ = ( <str> , <str> , <str> ) supported_elements = { <str> : finat . BrezziDouglasMarini , <str> : finat . BrezziDouglasFortinMarini , <str> : finat . Bubble , <str> : finat . FacetBubble , <str> : finat . CrouzeixRaviart , <str> : finat . DiscontinuousLagrange , <str> : lambda c , d : finat . DiscontinuousElement ( finat . RaviartThomas ( c , d ) ) , <str> : finat . DiscontinuousTaylor , <str> : finat . GaussLegendre , <str> : finat . GaussLobattoLegendre , <str> : finat . HDivTrace , <str> : finat . HellanHerrmannJohnson , <str> : finat . Hermite , <str> : finat . Argyris , <str> : finat . Morley , <str> : finat . Bell , <str> : finat . Lagrange , <str> : finat . Nedelec , <str> : finat . NedelecSecondKind , <str> : finat . RaviartThomas , <str> : finat . Regge , <str> : None , <str> : None , <str> : None , <str> : None , <str> : None , <str> : None , <str> : finat . DiscontinuousLagrange , <str> : finat . DPC , <str> : finat . Serendipity , <str> : finat . DPC , <str> : finat . DiscontinuousLagrange , <str> : finat . GaussLegendre , <str> : None , } def fiat_compat ( element ) :      from tsfc . fiatinterface import create_element from finat . fiat_elements import FiatElement assert element . cell ( ) . is_simplex ( ) return FiatElement ( create_element ( element ) )  @ singledispatch def convert ( element , ** kwargs ) :      if element . family ( ) in supported_elements :          raise ValueError ( <str> % element )  raise ValueError ( <str> % type ( element ) )  @ convert . register ( ufl . FiniteElement ) def convert_finiteelement ( element , ** kwargs ) :      cell = as_fiat_cell ( element . cell ( ) ) if element . family ( ) == <str> :          degree = element . degree ( ) scheme = element . quadrature_scheme ( ) if degree is None or scheme is None :              raise ValueError ( <str> )  return finat . QuadratureElement ( cell , degree , scheme ) , set ( )  elif element . family ( ) == <str> :          return fiat_compat ( element ) , set ( )  lmbda = supported_elements [ element . family ( ) ] if lmbda is None :          if element . cell ( ) . cellname ( ) == <str> :              element = element . reconstruct ( cell = quadrilateral_tpc )  elif element . cell ( ) . cellname ( ) == <str> :              element = element . reconstruct ( cell = hexahedron_tpc )  else :              raise ValueError ( <str> % element . family ( ) )  finat_elem , deps = _create_element ( element , ** kwargs ) return finat . FlattenedDimensions ( finat_elem ) , deps  kind = element . variant ( ) if kind is None :          kind = <str> if element . cell ( ) . cellname ( ) == <str> else <str>  if element . family ( ) == <str> :          if kind == <str> :              lmbda = finat . Lagrange  elif kind == <str> and element . cell ( ) . cellname ( ) == <str> :              lmbda = finat . GaussLobattoLegendre  elif kind in [ <str> , <str> , <str> , <str> ] :              degree = element . degree ( ) shift_axes = kwargs [ <str> ] restriction = kwargs [ <str> ] deps = { <str> , <str> } return finat . RuntimeTabulated ( cell , degree , variant = kind , shift_axes = shift_axes , restriction = restriction ) , deps  else :              raise ValueError ( <str> % ( kind , element . cell ( ) ) )   elif element . family ( ) in [ <str> , <str> ] :          if kind == <str> :              lmbda = finat . DiscontinuousLagrange  elif kind == <str> and element . cell ( ) . cellname ( ) == <str> :              lmbda = finat . GaussLegendre  elif kind in [ <str> , <str> , <str> , <str> ] :              degree = element . degree ( ) shift_axes = kwargs [ <str> ] restriction = kwargs [ <str> ] deps = { <str> , <str> } return finat . RuntimeTabulated ( cell , degree , variant = kind , shift_axes = shift_axes , restriction = restriction , continuous = False ) , deps  else :              raise ValueError ( <str> % ( kind , element . cell ( ) ) )   elif element . family ( ) == [ <str> , <str> ] :          if element . cell ( ) . geometric_dimension ( ) == 2 :              element = element . reconstruct ( cell = ufl . cell . hypercube ( 2 ) )  elif element . cell ( ) . geometric_dimension ( ) == 3 :              element = element . reconstruct ( cell = ufl . cell . hypercube ( 3 ) )   elif element . family ( ) == <str> :          if element . cell ( ) . geometric_dimension ( ) == 2 :              element = element . reconstruct ( cell = ufl . cell . hypercube ( 2 ) )  elif element . cell ( ) . geometric_dimension ( ) == 3 :              element = element . reconstruct ( cell = ufl . cell . hypercube ( 3 ) )   return lmbda ( cell , element . degree ( ) ) , set ( )  @ convert . register ( ufl . BrokenElement ) def convert_brokenelement ( element , ** kwargs ) :      finat_elem , deps = _create_element ( element . _element , ** kwargs ) return finat . DiscontinuousElement ( finat_elem ) , deps  @ convert . register ( ufl . EnrichedElement ) def convert_enrichedelement ( element , ** kwargs ) :      elements , deps = zip ( * [ _create_element ( elem , ** kwargs ) for elem in element . _elements ] ) return finat . EnrichedElement ( elements ) , set . union ( * deps )  @ convert . register ( ufl . MixedElement ) def convert_mixedelement ( element , ** kwargs ) :      elements , deps = zip ( * [ _create_element ( elem , ** kwargs ) for elem in element . sub_elements ( ) ] ) return finat . MixedElement ( elements ) , set . union ( * deps )  @ convert . register ( ufl . VectorElement ) def convert_vectorelement ( element , ** kwargs ) :      scalar_elem , deps = _create_element ( element . sub_elements ( ) [ 0 ] , ** kwargs ) shape = ( element . num_sub_elements ( ) , ) shape_innermost = kwargs [ <str> ] return ( finat . TensorFiniteElement ( scalar_elem , shape , not shape_innermost ) , deps | { <str> } )  @ convert . register ( ufl . TensorElement ) def convert_tensorelement ( element , ** kwargs ) :      scalar_elem , deps = _create_element ( element . sub_elements ( ) [ 0 ] , ** kwargs ) shape = element . reference_value_shape ( ) shape_innermost = kwargs [ <str> ] return ( finat . TensorFiniteElement ( scalar_elem , shape , not shape_innermost ) , deps | { <str> } )  @ convert . register ( ufl . TensorProductElement ) def convert_tensorproductelement ( element , ** kwargs ) :      cell = element . cell ( ) if type ( cell ) is not ufl . TensorProductCell :          raise ValueError ( <str> )  shift_axes = kwargs [ <str> ] dim_offset = 0 elements = [ ] deps = set ( ) for elem in element . sub_elements ( ) :          kwargs [ <str> ] = shift_axes + dim_offset dim_offset += elem . cell ( ) . topological_dimension ( ) finat_elem , ds = _create_element ( elem , ** kwargs ) elements . append ( finat_elem ) deps . update ( ds )  return finat . TensorProductElement ( elements ) , deps  @ convert . register ( ufl . HDivElement ) def convert_hdivelement ( element , ** kwargs ) :      finat_elem , deps = _create_element ( element . _element , ** kwargs ) return finat . HDivElement ( finat_elem ) , deps  @ convert . register ( ufl . HCurlElement ) def convert_hcurlelement ( element , ** kwargs ) :      finat_elem , deps = _create_element ( element . _element , ** kwargs ) return finat . HCurlElement ( finat_elem ) , deps  @ convert . register ( ufl . RestrictedElement ) def convert_restrictedelement ( element , ** kwargs ) :      return fiat_compat ( element ) , set ( )  @ convert . register ( ufl . NodalEnrichedElement ) def convert_nodalenrichedelement ( element , ** kwargs ) :      return fiat_compat ( element ) , set ( )  hexahedron_tpc = ufl . TensorProductCell ( ufl . quadrilateral , ufl . interval ) quadrilateral_tpc = ufl . TensorProductCell ( ufl . interval , ufl . interval ) _cache = weakref . WeakKeyDictionary ( ) def create_element ( ufl_element , shape_innermost = True , shift_axes = 0 , restriction = None ) :      finat_element , deps = _create_element ( ufl_element , shape_innermost = shape_innermost , shift_axes = shift_axes , restriction = restriction ) return finat_element  def _create_element ( ufl_element , ** kwargs ) :      try :          cache = _cache [ ufl_element ]  except KeyError :          _cache [ ufl_element ] = { } cache = _cache [ ufl_element ]  for key , finat_element in cache . items ( ) :          if all ( kwargs [ param ] == value for param , value in key ) :              return finat_element , set ( param for param , value in key )   if ufl_element . cell ( ) is None :          raise ValueError ( <str> )  finat_element , deps = convert ( ufl_element , ** kwargs ) key = frozenset ( ( param , kwargs [ param ] ) for param in deps ) cache [ key ] = finat_element return finat_element , deps   