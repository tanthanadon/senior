import numpy from collections import namedtuple from itertools import chain , product from functools import partial from ufl import Coefficient , MixedElement as ufl_MixedElement , FunctionSpace , FiniteElement import gem from gem . optimise import remove_componenttensors as prune import loopy as lp from tsfc . finatinterface import create_element from tsfc . kernel_interface . common import KernelBuilderBase as _KernelBuilderBase from tsfc . kernel_interface . firedrake import check_requirements from tsfc . loopy import generate as generate_loopy ExpressionKernel = namedtuple ( <str> , [ <str> , <str> , <str> , <str> , <str> ] ) def make_builder ( * args , ** kwargs ) :      return partial ( KernelBuilder , * args , ** kwargs )  class Kernel ( object ) :      __slots__ = ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) def __init__ ( self , ast = None , integral_type = None , oriented = False , subdomain_id = None , domain_number = None , quadrature_rule = None , coefficient_numbers = ( ) , needs_cell_sizes = False ) :          self . ast = ast self . integral_type = integral_type self . oriented = oriented self . domain_number = domain_number self . subdomain_id = subdomain_id self . coefficient_numbers = coefficient_numbers self . needs_cell_sizes = needs_cell_sizes super ( Kernel , self ) . __init__ ( )   class KernelBuilderBase ( _KernelBuilderBase ) :      def __init__ ( self , scalar_type , interior_facet = False ) :          super ( KernelBuilderBase , self ) . __init__ ( scalar_type = scalar_type , interior_facet = interior_facet ) if self . interior_facet :              shape = ( 2 , ) cell_orientations = gem . Variable ( <str> , shape ) self . _cell_orientations = ( gem . Indexed ( cell_orientations , ( 0 , ) ) , gem . Indexed ( cell_orientations , ( 1 , ) ) )  else :              shape = ( 1 , ) cell_orientations = gem . Variable ( <str> , shape ) self . _cell_orientations = ( gem . Indexed ( cell_orientations , ( 0 , ) ) , )  self . cell_orientations_loopy_arg = lp . GlobalArg ( <str> , dtype = numpy . int32 , shape = shape )  def _coefficient ( self , coefficient , name ) :          funarg , expression = prepare_coefficient ( coefficient , name , self . scalar_type , interior_facet = self . interior_facet ) self . coefficient_map [ coefficient ] = expression return funarg  def set_cell_sizes ( self , domain ) :          f = Coefficient ( FunctionSpace ( domain , FiniteElement ( <str> , domain . ufl_cell ( ) , 1 ) ) ) funarg , expression = prepare_coefficient ( f , <str> , self . scalar_type , interior_facet = self . interior_facet ) self . cell_sizes_arg = funarg self . _cell_sizes = expression  def create_element ( self , element , ** kwargs ) :          return create_element ( element , ** kwargs )   class ExpressionKernelBuilder ( KernelBuilderBase ) :      def __init__ ( self , scalar_type ) :          super ( ExpressionKernelBuilder , self ) . __init__ ( scalar_type = scalar_type ) self . oriented = False self . cell_sizes = False  def set_coefficients ( self , coefficients ) :          self . coefficients = [ ] self . coefficient_split = { } self . kernel_args = [ ] for i , coefficient in enumerate ( coefficients ) :              if type ( coefficient . ufl_element ( ) ) == ufl_MixedElement :                  subcoeffs = coefficient . split ( ) self . coefficients . extend ( subcoeffs ) self . coefficient_split [ coefficient ] = subcoeffs self . kernel_args += [ self . _coefficient ( subcoeff , <str> % ( i , j ) ) for j , subcoeff in enumerate ( subcoeffs ) ]  else :                  self . coefficients . append ( coefficient ) self . kernel_args . append ( self . _coefficient ( coefficient , <str> % ( i , ) ) )    def register_requirements ( self , ir ) :          self . oriented , self . cell_sizes , self . tabulations = check_requirements ( ir )  def construct_kernel ( self , return_arg , impero_c , precision , index_names ) :          args = [ return_arg ] if self . oriented :              args . append ( self . cell_orientations_loopy_arg )  if self . cell_sizes :              args . append ( self . cell_sizes_arg )  args . extend ( self . kernel_args ) for name_ , shape in self . tabulations :              args . append ( lp . GlobalArg ( name_ , dtype = self . scalar_type , shape = shape ) )  loopy_kernel = generate_loopy ( impero_c , args , precision , self . scalar_type , <str> , index_names ) return ExpressionKernel ( loopy_kernel , self . oriented , self . cell_sizes , self . coefficients , self . tabulations )   class KernelBuilder ( KernelBuilderBase ) :      def __init__ ( self , integral_type , subdomain_id , domain_number , scalar_type , dont_split = ( ) , diagonal = False ) :          super ( KernelBuilder , self ) . __init__ ( scalar_type , integral_type . startswith ( <str> ) ) self . kernel = Kernel ( integral_type = integral_type , subdomain_id = subdomain_id , domain_number = domain_number ) self . diagonal = diagonal self . local_tensor = None self . coordinates_arg = None self . coefficient_args = [ ] self . coefficient_split = { } self . dont_split = frozenset ( dont_split ) if integral_type in [ <str> , <str> ] :              facet = gem . Variable ( <str> , ( 1 , ) ) self . _entity_number = { None : gem . VariableIndex ( gem . Indexed ( facet , ( 0 , ) ) ) }  elif integral_type in [ <str> , <str> ] :              facet = gem . Variable ( <str> , ( 2 , ) ) self . _entity_number = { <str> : gem . VariableIndex ( gem . Indexed ( facet , ( 0 , ) ) ) , <str> : gem . VariableIndex ( gem . Indexed ( facet , ( 1 , ) ) ) }  elif integral_type == <str> :              self . _entity_number = { <str> : 1 , <str> : 0 }   def set_arguments ( self , arguments , multiindices ) :          self . local_tensor , expressions = prepare_arguments ( arguments , multiindices , self . scalar_type , interior_facet = self . interior_facet , diagonal = self . diagonal ) return expressions  def set_coordinates ( self , domain ) :          f = Coefficient ( FunctionSpace ( domain , domain . ufl_coordinate_element ( ) ) ) self . domain_coordinate [ domain ] = f self . coordinates_arg = self . _coefficient ( f , <str> )  def set_coefficients ( self , integral_data , form_data ) :          coefficients = [ ] coefficient_numbers = [ ] for i in range ( len ( integral_data . enabled_coefficients ) ) :              if integral_data . enabled_coefficients [ i ] :                  original = form_data . reduced_coefficients [ i ] coefficient = form_data . function_replace_map [ original ] if type ( coefficient . ufl_element ( ) ) == ufl_MixedElement :                      if original in self . dont_split :                          coefficients . append ( coefficient ) self . coefficient_split [ coefficient ] = [ coefficient ]  else :                          split = [ Coefficient ( FunctionSpace ( coefficient . ufl_domain ( ) , element ) ) for element in coefficient . ufl_element ( ) . sub_elements ( ) ] coefficients . extend ( split ) self . coefficient_split [ coefficient ] = split   else :                      coefficients . append ( coefficient )  coefficient_numbers . append ( form_data . original_coefficient_positions [ i ] )   for i , coefficient in enumerate ( coefficients ) :              self . coefficient_args . append ( self . _coefficient ( coefficient , <str> % i ) )  self . kernel . coefficient_numbers = tuple ( coefficient_numbers )  def register_requirements ( self , ir ) :          knl = self . kernel knl . oriented , knl . needs_cell_sizes , knl . tabulations = check_requirements ( ir )  def construct_kernel ( self , name , impero_c , precision , index_names , quadrature_rule ) :          args = [ self . local_tensor , self . coordinates_arg ] if self . kernel . oriented :              args . append ( self . cell_orientations_loopy_arg )  if self . kernel . needs_cell_sizes :              args . append ( self . cell_sizes_arg )  args . extend ( self . coefficient_args ) if self . kernel . integral_type in [ <str> , <str> ] :              args . append ( lp . GlobalArg ( <str> , dtype = numpy . uint32 , shape = ( 1 , ) ) )  elif self . kernel . integral_type in [ <str> , <str> ] :              args . append ( lp . GlobalArg ( <str> , dtype = numpy . uint32 , shape = ( 2 , ) ) )  for name_ , shape in self . kernel . tabulations :              args . append ( lp . GlobalArg ( name_ , dtype = self . scalar_type , shape = shape ) )  self . kernel . quadrature_rule = quadrature_rule self . kernel . ast = generate_loopy ( impero_c , args , precision , self . scalar_type , name , index_names ) return self . kernel  def construct_empty_kernel ( self , name ) :          return None   def prepare_coefficient ( coefficient , name , scalar_type , interior_facet = False ) :      assert isinstance ( interior_facet , bool ) if coefficient . ufl_element ( ) . family ( ) == <str> :          funarg = lp . GlobalArg ( name , dtype = scalar_type , shape = ( coefficient . ufl_element ( ) . value_size ( ) , ) ) expression = gem . reshape ( gem . Variable ( name , ( None , ) ) , coefficient . ufl_shape ) return funarg , expression  finat_element = create_element ( coefficient . ufl_element ( ) ) shape = finat_element . index_shape size = numpy . prod ( shape , dtype = int ) if not interior_facet :          expression = gem . reshape ( gem . Variable ( name , ( size , ) ) , shape )  else :          varexp = gem . Variable ( name , ( 2 * size , ) ) plus = gem . view ( varexp , slice ( size ) ) minus = gem . view ( varexp , slice ( size , 2 * size ) ) expression = ( gem . reshape ( plus , shape ) , gem . reshape ( minus , shape ) ) size = size * 2  funarg = lp . GlobalArg ( name , dtype = scalar_type , shape = ( size , ) ) return funarg , expression  def prepare_arguments ( arguments , multiindices , scalar_type , interior_facet = False , diagonal = False ) :      assert isinstance ( interior_facet , bool ) if len ( arguments ) == 0 :          funarg = lp . GlobalArg ( <str> , dtype = scalar_type , shape = ( 1 , ) ) expression = gem . Indexed ( gem . Variable ( <str> , ( 1 , ) ) , ( 0 , ) ) return funarg , [ expression ]  elements = tuple ( create_element ( arg . ufl_element ( ) ) for arg in arguments ) shapes = tuple ( element . index_shape for element in elements ) if diagonal :          if len ( arguments ) != 2 :              raise ValueError ( <str> )  try :              element , = set ( elements )  except ValueError :              raise ValueError ( <str> )  elements = ( element , ) shapes = tuple ( element . index_shape for element in elements ) multiindices = multiindices [ : 1 ]  def expression ( restricted ) :          return gem . Indexed ( gem . reshape ( restricted , * shapes ) , tuple ( chain ( * multiindices ) ) )  u_shape = numpy . array ( [ numpy . prod ( shape , dtype = int ) for shape in shapes ] ) if interior_facet :          c_shape = tuple ( 2 * u_shape ) slicez = [ [ slice ( r * s , ( r + 1 ) * s ) for r , s in zip ( restrictions , u_shape ) ] for restrictions in product ( ( 0 , 1 ) , repeat = len ( arguments ) ) ]  else :          c_shape = tuple ( u_shape ) slicez = [ [ slice ( s ) for s in u_shape ] ]  funarg = lp . GlobalArg ( <str> , dtype = scalar_type , shape = c_shape ) varexp = gem . Variable ( <str> , c_shape ) expressions = [ expression ( gem . view ( varexp , * slices ) ) for slices in slicez ] return funarg , prune ( expressions )   