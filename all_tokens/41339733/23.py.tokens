import six import sys sys . path [ 0 : 0 ] = [ <str> ] import os import os . path import base64 import socket try :      from ssl import SSLError  except ImportError :      class SSLError ( Exception ) :          pass   if sys . version_info [ 0 ] == 2 and sys . version_info [ 1 ] < 7 :      import unittest2 as unittest  else :      import unittest  import uuid if six . PY3 :      from base64 import decodebytes as base64decode  else :      from base64 import decodestring as base64decode  import websocket as ws from websocket . _handshake import _create_sec_websocket_key from websocket . _url import parse_url , get_proxy_info from websocket . _utils import validate_utf8 from websocket . _handshake import _validate as _validate_header from websocket . _http import read_headers TEST_WITH_INTERNET = os . environ . get ( <str> , <str> ) == <str> TEST_SECURE_WS = True TRACABLE = False def create_mask_key ( n ) :      return <str>  class SockMock ( object ) :      def __init__ ( self ) :          self . data = [ ] self . sent = [ ]  def add_packet ( self , data ) :          self . data . append ( data )  def recv ( self , bufsize ) :          if self . data :              e = self . data . pop ( 0 ) if isinstance ( e , Exception ) :                  raise e  if len ( e ) > bufsize :                  self . data . insert ( 0 , e [ bufsize : ] )  return e [ : bufsize ]   def send ( self , data ) :          self . sent . append ( data ) return len ( data )  def close ( self ) :          pass   class HeaderSockMock ( SockMock ) :      def __init__ ( self , fname ) :          SockMock . __init__ ( self ) path = os . path . join ( os . path . dirname ( __file__ ) , fname ) with open ( path , <str> ) as f :              self . add_packet ( f . read ( ) )    class WebSocketTest ( unittest . TestCase ) :      def setUp ( self ) :          ws . enableTrace ( TRACABLE )  def tearDown ( self ) :          pass  def testDefaultTimeout ( self ) :          self . assertEqual ( ws . getdefaulttimeout ( ) , None ) ws . setdefaulttimeout ( 10 ) self . assertEqual ( ws . getdefaulttimeout ( ) , 10 ) ws . setdefaulttimeout ( None )  def testParseUrl ( self ) :          p = parse_url ( <str> ) self . assertEqual ( p [ 0 ] , <str> ) self . assertEqual ( p [ 1 ] , 80 ) self . assertEqual ( p [ 2 ] , <str> ) self . assertEqual ( p [ 3 ] , False ) p = parse_url ( <str> ) self . assertEqual ( p [ 0 ] , <str> ) self . assertEqual ( p [ 1 ] , 80 ) self . assertEqual ( p [ 2 ] , <str> ) self . assertEqual ( p [ 3 ] , False ) p = parse_url ( <str> ) self . assertEqual ( p [ 0 ] , <str> ) self . assertEqual ( p [ 1 ] , 80 ) self . assertEqual ( p [ 2 ] , <str> ) self . assertEqual ( p [ 3 ] , False ) p = parse_url ( <str> ) self . assertEqual ( p [ 0 ] , <str> ) self . assertEqual ( p [ 1 ] , 80 ) self . assertEqual ( p [ 2 ] , <str> ) self . assertEqual ( p [ 3 ] , False ) p = parse_url ( <str> ) self . assertEqual ( p [ 0 ] , <str> ) self . assertEqual ( p [ 1 ] , 8080 ) self . assertEqual ( p [ 2 ] , <str> ) self . assertEqual ( p [ 3 ] , False ) p = parse_url ( <str> ) self . assertEqual ( p [ 0 ] , <str> ) self . assertEqual ( p [ 1 ] , 8080 ) self . assertEqual ( p [ 2 ] , <str> ) self . assertEqual ( p [ 3 ] , False ) p = parse_url ( <str> ) self . assertEqual ( p [ 0 ] , <str> ) self . assertEqual ( p [ 1 ] , 8080 ) self . assertEqual ( p [ 2 ] , <str> ) self . assertEqual ( p [ 3 ] , False ) p = parse_url ( <str> ) self . assertEqual ( p [ 0 ] , <str> ) self . assertEqual ( p [ 1 ] , 8080 ) self . assertEqual ( p [ 2 ] , <str> ) self . assertEqual ( p [ 3 ] , True ) p = parse_url ( <str> ) self . assertEqual ( p [ 0 ] , <str> ) self . assertEqual ( p [ 1 ] , 8080 ) self . assertEqual ( p [ 2 ] , <str> ) self . assertEqual ( p [ 3 ] , True ) self . assertRaises ( ValueError , parse_url , <str> ) if sys . version_info [ 0 ] == 2 and sys . version_info [ 1 ] < 7 :              return  p = parse_url ( <str> ) self . assertEqual ( p [ 0 ] , <str> ) self . assertEqual ( p [ 1 ] , 80 ) self . assertEqual ( p [ 2 ] , <str> ) self . assertEqual ( p [ 3 ] , False ) p = parse_url ( <str> ) self . assertEqual ( p [ 0 ] , <str> ) self . assertEqual ( p [ 1 ] , 8080 ) self . assertEqual ( p [ 2 ] , <str> ) self . assertEqual ( p [ 3 ] , False ) p = parse_url ( <str> ) self . assertEqual ( p [ 0 ] , <str> ) self . assertEqual ( p [ 1 ] , 443 ) self . assertEqual ( p [ 2 ] , <str> ) self . assertEqual ( p [ 3 ] , True ) p = parse_url ( <str> ) self . assertEqual ( p [ 0 ] , <str> ) self . assertEqual ( p [ 1 ] , 8080 ) self . assertEqual ( p [ 2 ] , <str> ) self . assertEqual ( p [ 3 ] , True )  def testWSKey ( self ) :          key = _create_sec_websocket_key ( ) self . assertTrue ( key != 24 ) self . assertTrue ( six . u ( <str> ) not in key )  def testWsUtils ( self ) :          key = <str> required_header = { <str> : <str> , <str> : <str> , <str> : <str> , } self . assertEqual ( _validate_header ( required_header , key , None ) , ( True , None ) ) header = required_header . copy ( ) header [ <str> ] = <str> self . assertEqual ( _validate_header ( header , key , None ) , ( False , None ) ) del header [ <str> ] self . assertEqual ( _validate_header ( header , key , None ) , ( False , None ) ) header = required_header . copy ( ) header [ <str> ] = <str> self . assertEqual ( _validate_header ( header , key , None ) , ( False , None ) ) del header [ <str> ] self . assertEqual ( _validate_header ( header , key , None ) , ( False , None ) ) header = required_header . copy ( ) header [ <str> ] = <str> self . assertEqual ( _validate_header ( header , key , None ) , ( False , None ) ) del header [ <str> ] self . assertEqual ( _validate_header ( header , key , None ) , ( False , None ) ) header = required_header . copy ( ) header [ <str> ] = <str> self . assertEqual ( _validate_header ( header , key , [ <str> , <str> ] ) , ( True , <str> ) ) self . assertEqual ( _validate_header ( header , key , [ <str> , <str> ] ) , ( False , None ) ) header = required_header . copy ( ) header [ <str> ] = <str> self . assertEqual ( _validate_header ( header , key , [ <str> , <str> ] ) , ( True , <str> ) )  def testReadHeader ( self ) :          status , header = read_headers ( HeaderSockMock ( <str> ) ) self . assertEqual ( status , 101 ) self . assertEqual ( header [ <str> ] , <str> ) HeaderSockMock ( <str> ) self . assertRaises ( ws . WebSocketException , read_headers , HeaderSockMock ( <str> ) )  def testSend ( self ) :          sock = ws . WebSocket ( ) sock . set_mask_key ( create_mask_key ) s = sock . sock = HeaderSockMock ( <str> ) sock . send ( <str> ) self . assertEqual ( s . sent [ 0 ] , six . b ( <str> ) ) sock . send ( <str> ) self . assertEqual ( s . sent [ 1 ] , six . b ( <str> ) ) sock . send ( <str> ) self . assertEqual ( s . sent [ 1 ] , six . b ( <str> ) ) sock . send ( <str> * 127 )  def testRecv ( self ) :          sock = ws . WebSocket ( ) s = sock . sock = SockMock ( ) something = six . b ( <str> ) s . add_packet ( something ) data = sock . recv ( ) self . assertEqual ( data , <str> ) s . add_packet ( six . b ( <str> ) ) data = sock . recv ( ) self . assertEqual ( data , <str> )  @ unittest . skipUnless ( TEST_WITH_INTERNET , <str> ) def testIter ( self ) :          count = 2 for rsvp in ws . create_connection ( <str> ) :              count -= 1 if count == 0 :                  break    @ unittest . skipUnless ( TEST_WITH_INTERNET , <str> ) def testNext ( self ) :          sock = ws . create_connection ( <str> ) self . assertEqual ( str , type ( next ( sock ) ) )  def testInternalRecvStrict ( self ) :          sock = ws . WebSocket ( ) s = sock . sock = SockMock ( ) s . add_packet ( six . b ( <str> ) ) s . add_packet ( socket . timeout ( ) ) s . add_packet ( six . b ( <str> ) ) s . add_packet ( six . b ( <str> ) ) with self . assertRaises ( ws . WebSocketTimeoutException ) :              data = sock . frame_buffer . recv_strict ( 9 )  data = sock . frame_buffer . recv_strict ( 9 ) self . assertEqual ( data , six . b ( <str> ) ) with self . assertRaises ( ws . WebSocketConnectionClosedException ) :              data = sock . frame_buffer . recv_strict ( 1 )   def testRecvTimeout ( self ) :          sock = ws . WebSocket ( ) s = sock . sock = SockMock ( ) s . add_packet ( six . b ( <str> ) ) s . add_packet ( socket . timeout ( ) ) s . add_packet ( six . b ( <str> ) ) s . add_packet ( socket . timeout ( ) ) s . add_packet ( six . b ( <str> ) ) with self . assertRaises ( ws . WebSocketTimeoutException ) :              data = sock . recv ( )  with self . assertRaises ( ws . WebSocketTimeoutException ) :              data = sock . recv ( )  data = sock . recv ( ) self . assertEqual ( data , <str> ) with self . assertRaises ( ws . WebSocketConnectionClosedException ) :              data = sock . recv ( )   def testRecvWithSimpleFragmentation ( self ) :          sock = ws . WebSocket ( ) s = sock . sock = SockMock ( ) s . add_packet ( six . b ( <str> ) ) s . add_packet ( six . b ( <str> ) ) data = sock . recv ( ) self . assertEqual ( data , <str> ) with self . assertRaises ( ws . WebSocketConnectionClosedException ) :              sock . recv ( )   def testRecvWithFireEventOfFragmentation ( self ) :          sock = ws . WebSocket ( fire_cont_frame = True ) s = sock . sock = SockMock ( ) s . add_packet ( six . b ( <str> ) ) s . add_packet ( six . b ( <str> ) ) s . add_packet ( six . b ( <str> ) ) _ , data = sock . recv_data ( ) self . assertEqual ( data , six . b ( <str> ) ) _ , data = sock . recv_data ( ) self . assertEqual ( data , six . b ( <str> ) ) _ , data = sock . recv_data ( ) self . assertEqual ( data , six . b ( <str> ) ) s . add_packet ( six . b ( <str> ) ) with self . assertRaises ( ws . WebSocketException ) :              sock . recv_data ( )  with self . assertRaises ( ws . WebSocketConnectionClosedException ) :              sock . recv ( )   def testClose ( self ) :          sock = ws . WebSocket ( ) sock . sock = SockMock ( ) sock . connected = True sock . close ( ) self . assertEqual ( sock . connected , False ) sock = ws . WebSocket ( ) s = sock . sock = SockMock ( ) sock . connected = True s . add_packet ( six . b ( <str> ) ) sock . recv ( ) self . assertEqual ( sock . connected , False )  def testRecvContFragmentation ( self ) :          sock = ws . WebSocket ( ) s = sock . sock = SockMock ( ) s . add_packet ( six . b ( <str> ) ) self . assertRaises ( ws . WebSocketException , sock . recv )  def testRecvWithProlongedFragmentation ( self ) :          sock = ws . WebSocket ( ) s = sock . sock = SockMock ( ) s . add_packet ( six . b ( <str> <str> ) ) s . add_packet ( six . b ( <str> <str> ) ) s . add_packet ( six . b ( <str> ) ) data = sock . recv ( ) self . assertEqual ( data , <str> ) with self . assertRaises ( ws . WebSocketConnectionClosedException ) :              sock . recv ( )   def testRecvWithFragmentationAndControlFrame ( self ) :          sock = ws . WebSocket ( ) sock . set_mask_key ( create_mask_key ) s = sock . sock = SockMock ( ) s . add_packet ( six . b ( <str> ) ) s . add_packet ( six . b ( <str> ) ) s . add_packet ( six . b ( <str> <str> ) ) data = sock . recv ( ) self . assertEqual ( data , <str> ) with self . assertRaises ( ws . WebSocketConnectionClosedException ) :              sock . recv ( )  self . assertEqual ( s . sent [ 0 ] , six . b ( <str> ) )  @ unittest . skipUnless ( TEST_WITH_INTERNET , <str> ) def testWebSocket ( self ) :          s = ws . create_connection ( <str> ) self . assertNotEqual ( s , None ) s . send ( <str> ) result = s . recv ( ) self . assertEqual ( result , <str> ) s . send ( <str> ) result = s . recv ( ) self . assertEqual ( result , <str> ) s . close ( )  @ unittest . skipUnless ( TEST_WITH_INTERNET , <str> ) def testPingPong ( self ) :          s = ws . create_connection ( <str> ) self . assertNotEqual ( s , None ) s . ping ( <str> ) s . pong ( <str> ) s . close ( )  @ unittest . skipUnless ( TEST_WITH_INTERNET , <str> ) @ unittest . skipUnless ( TEST_SECURE_WS , <str> ) def testSecureWebSocket ( self ) :          if 1 :              import ssl s = ws . create_connection ( <str> ) self . assertNotEqual ( s , None ) self . assertTrue ( isinstance ( s . sock , ssl . SSLSocket ) ) s . send ( <str> ) result = s . recv ( ) self . assertEqual ( result , <str> ) s . send ( <str> ) result = s . recv ( ) self . assertEqual ( result , <str> ) s . close ( )   @ unittest . skipUnless ( TEST_WITH_INTERNET , <str> ) def testWebSocketWihtCustomHeader ( self ) :          s = ws . create_connection ( <str> , headers = { <str> : <str> } ) self . assertNotEqual ( s , None ) s . send ( <str> ) result = s . recv ( ) self . assertEqual ( result , <str> ) s . close ( )  @ unittest . skipUnless ( TEST_WITH_INTERNET , <str> ) def testAfterClose ( self ) :          s = ws . create_connection ( <str> ) self . assertNotEqual ( s , None ) s . close ( ) self . assertRaises ( ws . WebSocketConnectionClosedException , s . send , <str> ) self . assertRaises ( ws . WebSocketConnectionClosedException , s . recv )  def testUUID4 ( self ) :          key = _create_sec_websocket_key ( ) u = uuid . UUID ( bytes = base64decode ( key . encode ( <str> ) ) ) self . assertEqual ( 4 , u . version )   class WebSocketAppTest ( unittest . TestCase ) :      class NotSetYet ( object ) :           def setUp ( self ) :          ws . enableTrace ( TRACABLE ) WebSocketAppTest . keep_running_open = WebSocketAppTest . NotSetYet ( ) WebSocketAppTest . keep_running_close = WebSocketAppTest . NotSetYet ( ) WebSocketAppTest . get_mask_key_id = WebSocketAppTest . NotSetYet ( )  def tearDown ( self ) :          WebSocketAppTest . keep_running_open = WebSocketAppTest . NotSetYet ( ) WebSocketAppTest . keep_running_close = WebSocketAppTest . NotSetYet ( ) WebSocketAppTest . get_mask_key_id = WebSocketAppTest . NotSetYet ( )  @ unittest . skipUnless ( TEST_WITH_INTERNET , <str> ) def testKeepRunning ( self ) :          def on_open ( self , * args , ** kwargs ) :              WebSocketAppTest . keep_running_open = self . keep_running self . close ( )  def on_close ( self , * args , ** kwargs ) :              WebSocketAppTest . keep_running_close = self . keep_running  app = ws . WebSocketApp ( <str> , on_open = on_open , on_close = on_close ) app . run_forever ( ) self . assertFalse ( isinstance ( WebSocketAppTest . keep_running_open , WebSocketAppTest . NotSetYet ) ) self . assertFalse ( isinstance ( WebSocketAppTest . keep_running_close , WebSocketAppTest . NotSetYet ) ) self . assertEqual ( True , WebSocketAppTest . keep_running_open ) self . assertEqual ( False , WebSocketAppTest . keep_running_close )  @ unittest . skipUnless ( TEST_WITH_INTERNET , <str> ) def testSockMaskKey ( self ) :          def my_mask_key_func ( ) :              pass  def on_open ( self , * args , ** kwargs ) :              WebSocketAppTest . get_mask_key_id = id ( self . get_mask_key ) self . close ( )  app = ws . WebSocketApp ( <str> , on_open = on_open , get_mask_key = my_mask_key_func ) app . run_forever ( ) self . assertEqual ( WebSocketAppTest . get_mask_key_id , id ( my_mask_key_func ) )   class SockOptTest ( unittest . TestCase ) :      @ unittest . skipUnless ( TEST_WITH_INTERNET , <str> ) def testSockOpt ( self ) :          sockopt = ( ( socket . IPPROTO_TCP , socket . TCP_NODELAY , 1 ) , ) s = ws . create_connection ( <str> , sockopt = sockopt ) self . assertNotEqual ( s . sock . getsockopt ( socket . IPPROTO_TCP , socket . TCP_NODELAY ) , 0 ) s . close ( )   class UtilsTest ( unittest . TestCase ) :      def testUtf8Validator ( self ) :          state = validate_utf8 ( six . b ( <str> ) ) self . assertEqual ( state , True ) state = validate_utf8 ( six . b ( <str> ) ) self . assertEqual ( state , False ) state = validate_utf8 ( six . b ( <str> ) ) self . assertEqual ( state , True )   class ProxyInfoTest ( unittest . TestCase ) :      def setUp ( self ) :          self . http_proxy = os . environ . get ( <str> , None ) self . https_proxy = os . environ . get ( <str> , None ) if <str> in os . environ :              del os . environ [ <str> ]  if <str> in os . environ :              del os . environ [ <str> ]   def tearDown ( self ) :          if self . http_proxy :              os . environ [ <str> ] = self . http_proxy  elif <str> in os . environ :              del os . environ [ <str> ]  if self . https_proxy :              os . environ [ <str> ] = self . https_proxy  elif <str> in os . environ :              del os . environ [ <str> ]   def testProxyFromArgs ( self ) :          self . assertEqual ( get_proxy_info ( <str> , False , proxy_host = <str> ) , ( <str> , 0 , None ) ) self . assertEqual ( get_proxy_info ( <str> , False , proxy_host = <str> , proxy_port = 3128 ) , ( <str> , 3128 , None ) ) self . assertEqual ( get_proxy_info ( <str> , True , proxy_host = <str> ) , ( <str> , 0 , None ) ) self . assertEqual ( get_proxy_info ( <str> , True , proxy_host = <str> , proxy_port = 3128 ) , ( <str> , 3128 , None ) ) self . assertEqual ( get_proxy_info ( <str> , False , proxy_host = <str> , proxy_auth = ( <str> , <str> ) ) , ( <str> , 0 , ( <str> , <str> ) ) ) self . assertEqual ( get_proxy_info ( <str> , False , proxy_host = <str> , proxy_port = 3128 , proxy_auth = ( <str> , <str> ) ) , ( <str> , 3128 , ( <str> , <str> ) ) ) self . assertEqual ( get_proxy_info ( <str> , True , proxy_host = <str> , proxy_auth = ( <str> , <str> ) ) , ( <str> , 0 , ( <str> , <str> ) ) ) self . assertEqual ( get_proxy_info ( <str> , True , proxy_host = <str> , proxy_port = 3128 , proxy_auth = ( <str> , <str> ) ) , ( <str> , 3128 , ( <str> , <str> ) ) ) self . assertEqual ( get_proxy_info ( <str> , True , proxy_host = <str> , proxy_port = 3128 , no_proxy = [ <str> ] , proxy_auth = ( <str> , <str> ) ) , ( <str> , 3128 , ( <str> , <str> ) ) ) self . assertEqual ( get_proxy_info ( <str> , True , proxy_host = <str> , proxy_port = 3128 , no_proxy = [ <str> ] , proxy_auth = ( <str> , <str> ) ) , ( None , 0 , None ) )  def testProxyFromEnv ( self ) :          os . environ [ <str> ] = <str> self . assertEqual ( get_proxy_info ( <str> , False ) , ( <str> , None , None ) ) os . environ [ <str> ] = <str> self . assertEqual ( get_proxy_info ( <str> , False ) , ( <str> , 3128 , None ) ) os . environ [ <str> ] = <str> os . environ [ <str> ] = <str> self . assertEqual ( get_proxy_info ( <str> , False ) , ( <str> , None , None ) ) os . environ [ <str> ] = <str> os . environ [ <str> ] = <str> self . assertEqual ( get_proxy_info ( <str> , False ) , ( <str> , 3128 , None ) ) os . environ [ <str> ] = <str> os . environ [ <str> ] = <str> self . assertEqual ( get_proxy_info ( <str> , True ) , ( <str> , None , None ) ) os . environ [ <str> ] = <str> os . environ [ <str> ] = <str> self . assertEqual ( get_proxy_info ( <str> , True ) , ( <str> , 3128 , None ) ) os . environ [ <str> ] = <str> self . assertEqual ( get_proxy_info ( <str> , False ) , ( <str> , None , ( <str> , <str> ) ) ) os . environ [ <str> ] = <str> self . assertEqual ( get_proxy_info ( <str> , False ) , ( <str> , 3128 , ( <str> , <str> ) ) ) os . environ [ <str> ] = <str> os . environ [ <str> ] = <str> self . assertEqual ( get_proxy_info ( <str> , False ) , ( <str> , None , ( <str> , <str> ) ) ) os . environ [ <str> ] = <str> os . environ [ <str> ] = <str> self . assertEqual ( get_proxy_info ( <str> , False ) , ( <str> , 3128 , ( <str> , <str> ) ) ) os . environ [ <str> ] = <str> os . environ [ <str> ] = <str> self . assertEqual ( get_proxy_info ( <str> , True ) , ( <str> , None , ( <str> , <str> ) ) ) os . environ [ <str> ] = <str> os . environ [ <str> ] = <str> self . assertEqual ( get_proxy_info ( <str> , True ) , ( <str> , 3128 , ( <str> , <str> ) ) ) os . environ [ <str> ] = <str> os . environ [ <str> ] = <str> os . environ [ <str> ] = <str> self . assertEqual ( get_proxy_info ( <str> , True ) , ( <str> , None , ( <str> , <str> ) ) ) os . environ [ <str> ] = <str> os . environ [ <str> ] = <str> os . environ [ <str> ] = <str> self . assertEqual ( get_proxy_info ( <str> , True ) , ( None , 0 , None ) )   if __name__ == <str> :      unittest . main ( )   