from flask import request from flask import Flask from flask import render_template import sys import time , os from datetime import datetime , timedelta import okcoin_websocket from stock import stock , KLine import time from datetime import datetime import logging import json app = Flask ( __name__ ) store_dir = <str> logging . basicConfig ( level = logging . DEBUG , format = <str> , datefmt = <str> ) pricelogging = logging . getLogger ( <str> ) class RStock ( stock ) :      def __init__ ( self , symbol , stockType , maxLength ) :          super ( RStock , self ) . __init__ ( symbol , stockType , maxLength )  def fetchKLine ( self ) :          if self . lastKline ( ) == 0 or self . lastKline ( ) == None :              fstart = startime  else :              ktime = datetime . fromtimestamp ( self . lastKline ( ) . time ) fstart = ktime . strftime ( <str> )  dt = datetime . strptime ( fstart , <str> ) if self . _stockType == stock . OneMin :              diff = 1  elif self . _stockType == stock . FiveMin :              diff = 5 dt = dt - timedelta ( minutes = dt . minute % 5 )  elif self . _stockType == stock . FifteenMin :              diff = 15 dt = dt - timedelta ( minutes = dt . minute % 15 )  fstart = ( dt - timedelta ( minutes = diff * ( self . _maxLength - 1 ) ) ) . strftime ( <str> ) klines = [ ] while len ( klines ) < self . _maxLength :              xlines = self . readKLine ( fstart , self . _maxLength - len ( klines ) ) if len ( xlines ) == 0 :                  break  klines . extend ( xlines ) diff = 0 if self . _stockType == stock . OneMin :                  diff = 1  elif self . _stockType == stock . FiveMin :                  diff = 5  elif self . _stockType == stock . FifteenMin :                  diff = 15  fstart = ( datetime . fromtimestamp ( klines [ - 1 ] . time ) + timedelta ( minutes = diff ) ) . strftime ( <str> )  self . stocks = [ 0 ] * 2 * self . _maxLength self . stocks [ 0 : len ( klines ) ] = klines self . cursor = len ( klines ) - 1 self . trades = [ 0 ] * 2 * self . _maxLength self . baseTime = klines [ 0 ] . time self . macd ( len ( klines ) - 1 , len ( klines ) )  def readKlines ( self , ftime , length ) :          if self . _stockType == stock . OneMin :              diff = 1  elif self . _stockType == stock . FiveMin :              diff = 5  elif self . _stockType == stock . FifteenMin :              diff = 15  fstart = ( datetime . fromtimestamp ( ftime ) + timedelta ( minutes = diff ) ) . strftime ( <str> ) klines = [ ] while len ( klines ) < length :              xlines = self . readKLine ( fstart , length - len ( klines ) ) if len ( xlines ) == 0 :                  break  klines . extend ( xlines ) diff = 0 if self . _stockType == stock . OneMin :                  diff = 1  elif self . _stockType == stock . FiveMin :                  diff = 5  elif self . _stockType == stock . FifteenMin :                  diff = 15  fstart = ( datetime . fromtimestamp ( klines [ - 1 ] . time ) + timedelta ( minutes = diff ) ) . strftime ( <str> )  return klines  def readKLine ( self , fstart , length ) :          tday = datetime . strptime ( fstart , <str> ) tstart = time . mktime ( tday . timetuple ( ) ) fname = tday . strftime ( <str> ) tdaytime = time . mktime ( datetime . strptime ( fname , <str> ) . timetuple ( ) ) filetype = None if self . _stockType == stock . OneMin :              filetype = <str>  elif self . _stockType == stock . FiveMin :              filetype = <str>  elif self . _stockType == stock . FifteenMin :              filetype = <str>  if os . path . exists ( store_dir + <str> + fname + <str> + filetype ) == False :              return [ ]  fwriter = open ( store_dir + <str> + fname + <str> + filetype , <str> ) if filetype == <str> :              offset = ( tstart - tdaytime ) / 60  elif filetype == <str> :              offset = ( tstart - tdaytime ) / ( 60 * 5 )  elif filetype == <str> :              offset = ( tstart - tdaytime ) / ( 60 * 15 )  fwriter . seek ( offset * 48 ) klines = [ ] while len ( klines ) < length :              line = fwriter . readline ( ) if line == <str> :                  break  print line . split ( <str> ) klines . append ( KLine ( line . split ( <str> ) , <str> ) )  return klines   stock1Min = RStock ( <str> , stock . OneMin , 500 ) stock5Min = RStock ( <str> , stock . FiveMin , 500 ) stock15Min = RStock ( <str> , stock . FifteenMin , 500 ) cacheM = None @ app . route ( <str> , methods = [ <str> ] ) def kline ( ) :      global cacheM market = request . args . get ( <str> , <str> ) ty = request . args . get ( <str> , <str> ) limit = request . args . get ( <str> , <str> ) since = request . args . get ( <str> , <str> ) kx = since ty = sys . argv [ 2 ] since = sys . argv [ 1 ] if cacheM == None :          if ty == <str> :              ret = stock1Min . readKlines ( int ( since ) , int ( limit ) )  elif ty == <str> :              ret = stock5Min . readKlines ( int ( since ) , int ( limit ) )  elif ty == <str> :              ret = stock15Min . readKlines ( int ( since ) , int ( limit ) )  ret . reverse ( ) kk = [ ] tk = None for k in ret :              kk . append ( [ int ( k . time ) * 1000 , k . open , k . high , k . low , k . close , 6 ] ) tk = k  kk . reverse ( ) cacheM = kk  if kx != <str> :          return json . dumps ( [ cacheM [ - 1 ] ] )  return json . dumps ( cacheM )  @ app . route ( <str> , methods = [ <str> ] ) def index ( ) :      return render_template ( <str> )  if __name__ == <str> :      app . run ( host = <str> )   