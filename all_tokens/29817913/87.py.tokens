import logging from odoo import models , fields , api , _ from odoo . addons . connector . unit . mapper import ( mapping , only_create , ExportMapper , ) from . . unit . mapper import CarepointImportMapper from . . backend import carepoint from . . unit . import_synchronizer import CarepointImporter from . . unit . export_synchronizer import CarepointExporter from . address import CarepointAddress from . . connector import add_checkpoint _logger = logging . getLogger ( __name__ ) try :      from carepoint . models . address_mixin import EnumAddressType  except ImportError :      _logger . warning ( <str> )  class CarepointAddressAbstract ( models . AbstractModel ) :      _inherits = { <str> : <str> } _name = <str> _description = <str> address_id = fields . Many2one ( string = <str> , comodel_name = <str> , required = True , ondelete = <str> , ) partner_id = fields . Many2one ( string = <str> , comodel_name = <str> , required = True , store = True , compute = <str> , inverse = <str> , ) res_model = fields . Char ( string = <str> , default = lambda s : s . _default_res_model ( ) , ) res_id = fields . Integer ( string = <str> , compute = <str> , store = True , ) @ property @ api . multi def medical_entity_id ( self ) :          self . ensure_one ( ) return self . env [ self . res_model ] . browse ( self . res_id )  @ api . model def _default_res_model ( self ) :          raise NotImplementedError ( _ ( <str> ) )  @ api . multi def _compute_partner_id ( self ) :          for rec_id in self :              rec_id . partner_id = rec_id . address_id . partner_id . id   @ api . multi @ api . depends ( <str> , * [ <str> % a for a in CarepointAddress . PARTNER_ATTRS ] ) def _set_partner_id ( self ) :          for rec_id in self :              need_sync = True if rec_id . partner_id != rec_id . address_id . partner_id :                  rec_id . address_id . write ( { <str> : rec_id . partner_id . id } )  if not CarepointAddressAbstractImportMapper . _has_empty_address ( rec_id ) :                  vals = self . env [ <str> ] . _get_partner_sync_vals ( rec_id . partner_id , ) if any ( vals . values ( ) ) :                      need_sync = False   if need_sync :                  rec_id . address_id . _sync_partner ( )  else :                  rec_id . address_id . write ( vals )    @ api . multi @ api . depends ( <str> , <str> ) def _compute_res_id ( self ) :          for rec_id in self :              if not all ( [ rec_id . res_model , rec_id . partner_id ] ) :                  continue  medical_entity = self . env [ rec_id . res_model ] . search ( [ ( <str> , <str> , rec_id . partner_id . id ) , ] , limit = 1 , ) rec_id . res_id = medical_entity . id   @ api . model def _get_by_partner ( self , partner , edit = True , recurse = False ) :          address = self . search ( [ ( <str> , <str> , partner . id ) ] , limit = 1 ) vals = self . address_id . _get_partner_sync_vals ( partner ) _logger . debug ( <str> % ( address , partner , vals ) ) if not edit :              return address  if not address :              vals [ <str> ] = partner . id address = self . create ( vals )  else :              address . write ( vals )  if recurse :              for child in partner . child_ids :                  self . _get_by_partner ( child , edit , recurse )   return address   @ carepoint class CarepointAddressAbstractImportMapper ( CarepointImportMapper ) :      @ staticmethod def _has_empty_address ( partner ) :          return not any ( [ partner . street , partner . street2 ] )  def _get_partner_defaults ( self , record ) :          return { <str> : <str> , <str> : True , }  def partner_id ( self , record , medical_entity ) :          if CarepointAddressAbstractImportMapper . _has_empty_address ( medical_entity . commercial_partner_id ) :              _logger . info ( <str> , medical_entity . commercial_partner_id ) partner = medical_entity . commercial_partner_id  else :              _logger . info ( <str> ) vals = self . _get_partner_defaults ( record ) vals . update ( { <str> : medical_entity . commercial_partner_id . id , } ) partner = self . env [ <str> ] . create ( vals )  return { <str> : partner . id }  def res_model_and_id ( self , record , medical_entity ) :          return { <str> : medical_entity . id , <str> : medical_entity . _name , }  @ mapping @ only_create def address_id ( self , record ) :          binder = self . binder_for ( <str> ) address_id = binder . to_odoo ( record [ <str> ] ) return { <str> : address_id }   @ carepoint class CarepointAddressAbstractImporter ( CarepointImporter ) :      _model_name = <str> def _import_dependencies ( self ) :          self . _import_dependency ( self . carepoint_record [ <str> ] , <str> )  def _create ( self , data ) :          binding = super ( CarepointAddressAbstractImporter , self ) . _create ( data ) add_checkpoint ( self . session , binding . _name , binding . id , binding . backend_id . id ) return binding   @ carepoint class CarepointAddressAbstractExportMapper ( ExportMapper ) :      @ mapping def addr_id ( self , binding ) :          binder = self . binder_for ( <str> ) rec_id = binder . to_backend ( binding . address_id . id ) return { <str> : rec_id }  @ mapping def static_defaults ( self , binding , addr_type = <str> ) :          res = { <str> : 1 , <str> : 0 , } try :              res [ <str> ] = EnumAddressType [ addr_type ] . value  except KeyError :              pass  return res   @ carepoint class CarepointAddressAbstractExporter ( CarepointExporter ) :      _model_name = <str> def _export_dependencies ( self ) :          self . _export_dependency ( self . binding_record . address_id , <str> )    