import logging from contextlib import contextmanager import psycopg2 import odoo from odoo . tools . translate import _ from odoo . addons . connector . queue . job import job , related_action from odoo . addons . connector . unit . synchronizer import Exporter from odoo . addons . connector . exception import ( IDMissingInBackend , RetryableJobError , ) from . import_synchronizer import import_record from . . connector import get_environment from . . related_action import unwrap_binding _logger = logging . getLogger ( __name__ ) class CarepointBaseExporter ( Exporter ) :      def __init__ ( self , connector_env ) :          super ( CarepointBaseExporter , self ) . __init__ ( connector_env ) self . binding_id = None self . carepoint_id = None self . binding_record = None  def _delay_import ( self ) :          assert self . carepoint_id import_record . delay ( self . session , self . model . _name , self . backend_record . id , self . carepoint_id , force = True )  def _immediate_import ( self ) :          assert self . carepoint_id import_record ( self . session , self . model . _name , self . backend_record . id , self . carepoint_id , force = True )  def _should_import ( self ) :          assert self . binding_record if not self . carepoint_id :              return False  sync = self . binding_record . sync_date if not sync :              return True  record = self . backend_adapter . read ( self . carepoint_id , attributes = [ <str> ] ) if not record [ <str> ] :              return False  sync_date = odoo . fields . Datetime . from_string ( sync ) carepoint_date = record [ <str> ] return sync_date < carepoint_date  def _get_odoo_data ( self ) :          return self . model . browse ( self . binding_id )  def run ( self , binding_id , * args , ** kwargs ) :          self . binding_id = binding_id self . binding_record = self . _get_odoo_data ( ) self . carepoint_id = self . binding_record . carepoint_id try :              should_import = self . _should_import ( )  except IDMissingInBackend :              self . carepoint_id = None should_import = False  if should_import :              self . _delay_import ( )  result = self . _run ( * args , ** kwargs ) self . binder . bind ( self . carepoint_id , self . binding_id ) self . session . commit ( ) self . _after_export ( ) return result  def _run ( self ) :          raise NotImplementedError  def _after_export ( self ) :          return   class CarepointExporter ( CarepointBaseExporter ) :      def _lock ( self ) :          sql = ( <str> % self . model . _table ) try :              self . session . cr . execute ( sql , ( self . binding_id , ) , log_exceptions = False )  except psycopg2 . OperationalError :              _logger . info ( <str> <str> , self . model . _name , self . binding_id ) raise RetryableJobError ( <str> <str> % ( self . model . _name , self . binding_id ) )   def _has_to_skip ( self ) :          return False  @ contextmanager def _retry_unique_violation ( self ) :          try :              yield  except psycopg2 . IntegrityError as err :              if err . pgcode == psycopg2 . errorcodes . UNIQUE_VIOLATION :                  raise RetryableJobError ( <str> <str> <str> <str> % err )  else :                  raise    def _export_dependency ( self , relation , binding_model , exporter_class = None , binding_field = <str> , binding_extra_vals = None , force = False , ) :          if not relation :              return  if exporter_class is None :              exporter_class = CarepointExporter  rel_binder = self . binder_for ( binding_model ) wrap = relation . _name != binding_model if wrap and hasattr ( relation , binding_field ) :              domain = [ ( <str> , <str> , relation . id ) , ( <str> , <str> , self . backend_record . id ) ] binding = self . env [ binding_model ] . search ( domain ) if binding :                  assert len ( binding ) == 1 , ( <str> <str> )  else :                  bind_values = { <str> : self . backend_record . id , <str> : relation . id } if binding_extra_vals :                      bind_values . update ( binding_extra_vals )  with self . _retry_unique_violation ( ) :                      binding = ( self . env [ binding_model ] . with_context ( connector_no_export = True ) . sudo ( ) . create ( bind_values ) ) self . session . commit ( )    else :              binding = relation  if force or not rel_binder . to_backend ( binding , wrap = False ) :              exporter = self . unit_for ( exporter_class , model = binding_model ) exporter . run ( binding . id )   def _export_dependencies ( self ) :          return  def _map_data ( self ) :          return self . mapper . map_record ( self . binding_record )  def _validate_create_data ( self , data ) :          return  def _validate_update_data ( self , data ) :          return  def _create_data ( self , map_record , fields = None , ** kwargs ) :          return map_record . values ( for_create = True , fields = fields , ** kwargs )  def _create ( self , data ) :          self . _validate_create_data ( data ) return self . backend_adapter . create ( data )  def _update_data ( self , map_record , fields = None , ** kwargs ) :          return map_record . values ( fields = fields , ** kwargs )  def _update ( self , data ) :          assert self . carepoint_id self . _validate_update_data ( data ) self . backend_adapter . write ( self . carepoint_id , data )  def _run ( self , fields = None ) :          assert self . binding_id assert self . binding_record if not self . carepoint_id :              fields = None  if self . _has_to_skip ( ) :              return  self . _export_dependencies ( ) self . _lock ( ) map_record = self . _map_data ( ) if self . carepoint_id :              record = self . _update_data ( map_record , fields = fields ) if not record :                  return _ ( <str> )  self . _update ( record )  else :              record = self . _create_data ( map_record , fields = fields ) if not record :                  return _ ( <str> )  self . carepoint_id = self . _create ( record )  return _ ( <str> ) % self . carepoint_id   @ job ( default_channel = <str> ) @ related_action ( action = unwrap_binding ) def export_record ( session , model_name , binding_id , fields = None ) :      record = session . env [ model_name ] . browse ( binding_id ) env = get_environment ( session , model_name , record . backend_id . id ) exporter = env . get_connector_unit ( CarepointExporter ) return exporter . run ( binding_id , fields = fields )   