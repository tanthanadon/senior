from math import exp , log import sqlite3 from numpy import polyval from scipy . optimize import fsolve from PyQt5 . QtWidgets import QApplication from lib import unidades from lib . sql import databank_name class Reaction ( object ) :      status = 0 msg = QApplication . translate ( <str> , <str> ) error = 0 kwargs = { <str> : [ ] , <str> : [ ] , <str> : 0 , <str> : 0 , <str> : 0 , <str> : 0 , <str> : False , <str> : 0.0 , <str> : False , <str> : None , <str> : None } kwargsValue = ( <str> , ) kwargsList = ( <str> , <str> , <str> , <str> ) kwargsCheck = ( <str> , <str> ) calculateValue = ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) TEXT_TYPE = [ QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) ] TEXT_PHASE = [ QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) ] TEXT_BASE = [ QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) ] def __init__ ( self , ** kwargs ) :          self . kwargs = Reaction . kwargs . copy ( ) if kwargs :              self . __call__ ( ** kwargs )   def __call__ ( self , ** kwargs ) :          oldkwargs = self . kwargs . copy ( ) self . kwargs . update ( kwargs ) if oldkwargs != self . kwargs and self . isCalculable :              self . calculo ( )   @ property def isCalculable ( self ) :          self . msg = <str> self . status = 1 if not self . kwargs [ <str> ] :              self . msg = QApplication . translate ( <str> , <str> ) self . status = 0 return  if not self . kwargs [ <str> ] :              self . msg = QApplication . translate ( <str> , <str> ) self . status = 0 return  if self . kwargs [ <str> ] == 0 :              if self . kwargs [ <str> ] is None :                  self . msg = QApplication . translate ( <str> , <str> ) self . status = 3   elif self . kwargs [ <str> ] == 1 :              if self . kwargs [ <str> ] is None :                  self . msg = QApplication . translate ( <str> , <str> ) self . status = 3   elif self . kwargs [ <str> ] == 2 :              pass  elif self . kwargs [ <str> ] == 3 :              pass  return True  def calculo ( self ) :          self . componentes = self . kwargs [ <str> ] self . coef = self . kwargs [ <str> ] self . tipo = self . kwargs [ <str> ] self . base = self . kwargs [ <str> ] self . fase = self . kwargs [ <str> ] self . calor = self . kwargs [ <str> ] self . formulas = self . kwargs [ <str> ] self . keq = self . kwargs [ <str> ] databank = sqlite3 . connect ( databank_name ) . cursor ( ) databank . execute ( <str> % str ( tuple ( self . componentes ) ) ) nombre = [ ] peso_molecular = [ ] formula = [ ] calor_reaccion = 0 check_estequiometria = 0 for i , compuesto in enumerate ( databank ) :              nombre . append ( compuesto [ 0 ] ) peso_molecular . append ( compuesto [ 1 ] ) formula . append ( compuesto [ 2 ] ) calor_reaccion += compuesto [ 3 ] * self . coef [ i ] check_estequiometria += self . coef [ i ] * compuesto [ 1 ]  self . nombre = nombre self . peso_molecular = peso_molecular self . formula = formula if self . calor :              self . Hr = self . kwargs . get ( <str> , 0 )  else :              self . Hr = unidades . MolarEnthalpy ( calor_reaccion / abs ( self . coef [ self . base ] ) , <str> )  self . error = round ( check_estequiometria , 1 ) self . state = self . error == 0 self . text = self . _txt ( self . formulas )  def conversion ( self , corriente , T ) :          if self . tipo == 0 :              alfa = self . kwargs [ <str> ]  elif self . tipo == 1 :              if isinstance ( self . keq , list ) :                  A , B , C , D , E , F , G , H = self . keq keq = exp ( A + B / T + C * log ( T ) + D * T + E * T ** 2 + F * T ** 3 + G * T ** 4 + H * T ** 5 )  else :                  keq = self . keq  def f ( alfa ) :                  conc_out = [ ( corriente . caudalunitariomolar [ i ] + alfa * self . coef [ i ] ) / corriente . Q . m3h for i in range ( len ( self . componentes ) ) ] productorio = 1 for i in range ( len ( self . componentes ) ) :                      productorio *= conc_out [ i ] ** self . coef [ i ]  return keq - productorio  alfa = fsolve ( f , 0.5 ) print ( alfa , f ( alfa ) )  avance = alfa * self . coef [ self . base ] * corriente . caudalunitariomolar [ self . base ] Q_out = [ corriente . caudalunitariomolar [ i ] + avance * self . coef [ i ] / self . coef [ self . base ] for i in range ( len ( self . componentes ) ) ] minimo = min ( Q_out ) if minimo < 0 :              indice = Q_out . index ( minimo ) avance = self . coef [ indice ] * corriente . caudalunitariomolar [ indice ] Q_out = [ corriente . caudalunitariomolar [ i ] + avance * self . coef [ i ] / self . coef [ indice ] for i in range ( len ( self . componentes ) ) ] h = unidades . Power ( self . Hr * self . coef [ self . base ] / self . coef [ indice ] * avance , <str> )  else :              h = unidades . Power ( self . Hr * avance , <str> )  print ( alfa , avance ) caudal = sum ( Q_out ) fraccion = [ caudal_i / caudal for caudal_i in Q_out ] return fraccion , h  def _txt ( self , nombre = False ) :          if nombre :              txt = self . nombre  else :              txt = self . formula  reactivos = [ ] productos = [ ] for i in range ( len ( self . componentes ) ) :              if self . coef [ i ] == int ( self . coef [ i ] ) :                  self . coef [ i ] = int ( self . coef [ i ] )  if self . coef [ i ] < - 1 :                  reactivos . append ( str ( - self . coef [ i ] ) + txt [ i ] )  elif self . coef [ i ] == - 1 :                  reactivos . append ( txt [ i ] )  elif - 1 < self . coef [ i ] < 0 :                  reactivos . append ( str ( - self . coef [ i ] ) + txt [ i ] )  elif 0 < self . coef [ i ] < 1 :                  productos . append ( str ( self . coef [ i ] ) + txt [ i ] )  elif self . coef [ i ] == 1 :                  productos . append ( txt [ i ] )  elif self . coef [ i ] > 1 :                  productos . append ( str ( self . coef [ i ] ) + txt [ i ] )   return <str> . join ( reactivos ) + <str> + <str> . join ( productos )  def __repr__ ( self ) :          if self . status :              eq = self . _txt ( ) return eq + <str> + <str> % self . Hr  else :              return str ( self . msg )    if __name__ == <str> :      reaccion = Reaction ( comp = [ 1 , 47 , 62 ] , coef = [ - 2 , - 1 , 2 ] ) print ( reaccion )   