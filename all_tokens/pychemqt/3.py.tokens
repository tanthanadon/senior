import os import random from scipy import exp from PyQt5 . QtWidgets import QApplication def format2txt ( formato ) :      if formato [ <str> ] :          txt = <str>  else :          txt = <str>  if formato [ <str> ] == 0 :          txt += <str> . format ( ** formato )  elif formato [ <str> ] == 1 :          txt += <str> . format ( ** formato )  elif formato [ <str> ] == 2 :          txt += <str> . format ( ** formato )  if formato . get ( <str> , False ) :          txt += <str> . format ( ** formato )  return txt  def representacion ( float , format = 0 , total = 0 , decimales = 4 , exp = False , tol = 5 , signo = False , thousand = False ) :      if type ( float ) is str :          return float  if signo :          start = <str>  else :          start = <str>  if thousand :          coma = <str>  else :          coma = <str>  if exp and ( - 10 ** tol > float or ( - 10 ** - tol < float < 10 ** ( - tol + 1 ) and float != 0 ) or float > 10 ** tol ) :          format = 2  if float == 0 :          decimales = 1  if format == 1 :          string = start + <str> . format ( coma , decimales ) + <str>  elif format == 2 :          string = start + <str> . format ( total , coma , decimales ) + <str>  else :          string = start + <str> . format ( total , coma , decimales ) + <str>  return string . format ( float )  def colors ( number , mix = <str> , scale = False ) :      colors = [ ] for i in range ( number ) :          if scale :              red = 255 * ( i / number ) green = 0 blue = 255 * ( ( number - i ) / number )  else :              red = random . randint ( 0 , 255 ) green = random . randint ( 0 , 255 ) blue = random . randint ( 0 , 255 )  if mix :              red_mix = int ( mix [ 1 : 3 ] , base = 16 ) red = ( red + red_mix ) / 2 green_mix = int ( mix [ 3 : 5 ] , base = 16 ) green = ( green + green_mix ) / 2 blue_mix = int ( mix [ 5 : ] , base = 16 ) blue = ( blue + blue_mix ) / 2  colors . append ( ( <str> % ( red , green , blue ) ) )  return colors  def exportTable ( matrix , fname , ext , title = None ) :      sheetTitle = QApplication . translate ( <str> , <str> ) if fname . split ( <str> ) [ - 1 ] != ext :          fname += <str> % ext  header = [ ] if title :          for ttl in title :              line = str ( ttl ) . split ( os . linesep ) if line [ - 1 ] != <str> :                  line [ - 1 ] = <str> + line [ - 1 ] + <str>  header . append ( <str> . join ( line ) )   if ext == <str> :          import csv with open ( fname , <str> ) as csvfile :              writer = csv . DictWriter ( csvfile , fieldnames = header ) writer . writeheader ( ) for row in matrix :                  kw = { } for ttl , value in zip ( header , row ) :                      kw [ ttl ] = value  writer . writerow ( kw )    elif ext == <str> :          import ezodf spreadsheet = ezodf . newdoc ( <str> , fname ) sheets = spreadsheet . sheets sheet = ezodf . Table ( sheetTitle ) sheets += sheet sheet . reset ( size = ( len ( matrix ) + 1 , len ( matrix [ 0 ] ) ) ) if title :              for i , ttl in enumerate ( header ) :                  sheet [ <str> % ( spreadsheetColumn ( i ) , 1 ) ] . set_value ( ttl )   for j , row in enumerate ( matrix ) :              for i , data in enumerate ( row ) :                  sheet [ <str> % ( spreadsheetColumn ( i ) , j + 2 ) ] . set_value ( data )   spreadsheet . save ( )  elif ext == <str> :          import xlwt spreadsheet = xlwt . Workbook ( ) sheet = spreadsheet . add_sheet ( sheetTitle ) font = xlwt . Font ( ) font . bold = True style = xlwt . XFStyle ( ) style . font = font if title :              for i , ttl in enumerate ( header ) :                  sheet . write ( 0 , i , ttl , style )   for j , row in enumerate ( matrix ) :              for i , data in enumerate ( row ) :                  sheet . write ( j + 1 , i , data )   spreadsheet . save ( fname )  elif ext == <str> :          import openpyxl from openpyxl . styles import Font spreadsheet = openpyxl . Workbook ( ) sheet = spreadsheet . active sheet . title = sheetTitle font1 = Font ( ) font1 . size = 9 font1 . bold = True font2 = Font ( ) font2 . size = 9 if title :              for i , ttl in enumerate ( header ) :                  sheet [ <str> % ( spreadsheetColumn ( i ) , 1 ) ] = ttl sheet [ <str> % ( spreadsheetColumn ( i ) , 1 ) ] . style . font = font1   for j , row in enumerate ( matrix ) :              for i , data in enumerate ( row ) :                  sheet [ <str> % ( spreadsheetColumn ( i ) , j + 2 ) ] = data sheet [ <str> % ( spreadsheetColumn ( i ) , j + 2 ) ] . style . font = font2   spreadsheet . save ( filename = fname )  else :          raise ValueError ( QApplication . translate ( <str> , <str> ) + <str> + ext )   def spreadsheetColumn ( index ) :      index += 1 letters = <str> while index :          mod = index % 26 index = index // 26 letters += chr ( mod + 64 )  return <str> . join ( reversed ( letters ) )  def formatLine ( config , section , name ) :      format = { } format [ <str> ] = config . get ( section , name + <str> ) format [ <str> ] = config . getfloat ( section , name + <str> ) format [ <str> ] = config . get ( section , name + <str> ) format [ <str> ] = config . getfloat ( section , name + <str> ) / 255 format [ <str> ] = config . get ( section , name + <str> ) format [ <str> ] = config . getfloat ( section , name + <str> ) format [ <str> ] = config . get ( section , name + <str> ) format [ <str> ] = config . getfloat ( section , name + <str> ) format [ <str> ] = config . get ( section , name + <str> ) return format  def SimpleEq ( Tc , T , coef ) :      <str> Tita = 1 - T / Tc pr = 0 for n , t in zip ( coef [ <str> ] , coef [ <str> ] ) :          pr += n * Tita ** t  if coef [ <str> ] == 1 :          pr += 1  if coef [ <str> ] == 3 :          pr *= Tc / T  if coef [ <str> ] in [ 2 , 3 ] :          pr = exp ( pr )  return pr  def refDoc ( doi , refs , tab = 4 ) :      def decorator ( f ) :          f . __doc__ += os . linesep + os . linesep f . __doc__ += <str> * tab + <str> + os . linesep f . __doc__ += <str> * tab + <str> + os . linesep for ref in refs :              rf = doi [ ref ] f . __doc__ += <str> * tab + <str> % ( ref , rf [ <str> ] , rf [ <str> ] , rf [ <str> ] ) + os . linesep f . __doc__ += os . linesep  return f  return decorator  if __name__ == <str> :      import math print ( representacion ( math . pi * 1000 , decimales = 6 , tol = 5 ) ) print ( representacion ( 0 , decimales = 6 , tol = 1 ) )   