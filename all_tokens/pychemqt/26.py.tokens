from configparser import ConfigParser import os from PyQt5 import QtWidgets from lib . sql import databank conf_dir = os . path . expanduser ( <str> ) + os . sep + <str> + os . sep IMAGE_PATH = os . path . join ( os . environ [ <str> ] , <str> ) + os . sep Preferences = ConfigParser ( ) Preferences . read ( conf_dir + <str> ) global currentConfig currentConfig = ConfigParser ( ) currentConfig . read ( conf_dir + <str> ) def getComponents ( solidos = False , config = None , name = True ) :      if not config :          config = getMainWindowConfig ( )  if solidos :          indices = config . get ( <str> , <str> ) if not isinstance ( indices , list ) :              indices = eval ( indices )   else :          indices = config . get ( <str> , <str> ) if not isinstance ( indices , list ) :              indices = eval ( indices )   if name :          nombres = [ ] M = [ ] for id in indices :              query = <str> % str ( id ) databank . execute ( query ) texto = databank . fetchone ( ) nombres . append ( texto [ 0 ] ) M . append ( texto [ 1 ] )  return indices , nombres , M  else :          return indices   def getMainWindowConfig ( ) :      return currentConfig  def setMainWindowConfig ( config = None ) :      global currentConfig if config :          currentConfig = config return  else :          widget = QtWidgets . QApplication . activeWindow ( ) if isinstance ( widget , QtWidgets . QMainWindow ) and widget . __class__ . __name__ == <str> :              currentConfig = widget . currentConfig  else :              lista = QtWidgets . QApplication . topLevelWidgets ( ) for widget in lista :                  if isinstance ( widget , QtWidgets . QMainWindow ) and widget . __class__ . __name__ == <str> :                      currentConfig = widget . currentConfig break      class Entity ( object ) :      _bool = False kwargs_forbidden = [ <str> ] notas = <str> notasPlain = <str> _dependence = <str> def __init__ ( self , ** kwargs ) :          self . kwargs = self . __class__ . kwargs . copy ( ) self . kwargsInteger = [ ] for key , value in self . kwargs . items ( ) :              if isinstance ( value , int ) :                  self . kwargsInteger . append ( key )   if kwargs :              self . __call__ ( ** kwargs )   def __call__ ( self , ** kwargs ) :          self . _oldkwargs = self . kwargs . copy ( ) self . cleanOldValues ( ** kwargs ) self . _bool = True txt = kwargs . get ( <str> , <str> ) if txt :              self . notas = txt self . notasPlain = txt  for key in self . kwargsInteger :              if key not in self . kwargs_forbidden :                  self . kwargs [ key ] = int ( self . kwargs [ key ] )    def cleanOldValues ( self , ** kwargs ) :          self . kwargs . update ( kwargs )  def clear ( self ) :          self . kwargs = self . __class__ . kwargs self . __dict__ . clear ( ) self . _bool = False  def __bool__ ( self ) :          return self . _bool  def show ( self ) :          for key in sorted ( self . __dict__ ) :              print ( key , <str> , self . __dict__ [ key ] )   def setNotas ( self , html , txt ) :          self . notas = html self . notasPlain = txt if html :              self . _bool = True   @ property def numInputs ( self ) :          count = 0 for key , value in self . kwargs . items ( ) :              if key not in self . kwargs_forbidden and value :                  count += 1   return count  def writeToJSON ( self , data ) :          kwarg = { } for key , value in self . kwargs . items ( ) :              if key not in self . kwargs_forbidden and value :                  if isinstance ( value , list ) :                      self . writeListtoJSON ( kwarg , key , value )  else :                      kwarg [ key ] = value    data [ <str> ] = kwarg data [ <str> ] = self . status data [ <str> ] = self . msg data [ <str> ] = self . _bool data [ <str> ] = self . _dependence data [ <str> ] = self . notas data [ <str> ] = self . notasPlain if self . status :              state = { } self . writeStatetoJSON ( state ) data [ <str> ] = state  else :              data [ <str> ] = { }   def writeListtoJSON ( self , data , key , value ) :          data [ key ] = value  def readFromJSON ( self , data ) :          for key , value in data [ <str> ] . items ( ) :              if isinstance ( self . kwargs [ key ] , list ) :                  value = self . readListFromJSON ( data [ <str> ] , key )  self . kwargs [ key ] = value  self . status = data [ <str> ] self . msg = data [ <str> ] self . _bool = data [ <str> ] try :              self . _dependence = data [ <str> ]  except KeyError :              self . _dependence = <str>  self . notas = data [ <str> ] self . notasPlain = data [ <str> ] if self . status :              self . readStatefromJSON ( data [ <str> ] )   def readListFromJSON ( self , data , key ) :          return data [ key ]  def writeStatetoJSON ( self , data ) :          pass  def readStatefromJSON ( self , data ) :          pass  @ classmethod def propertiesNames ( cls ) :          return [ ]  def properties ( self ) :          lista = [ ] for name , attr , unit in self . propertiesNames ( ) :              prop = self . _prop ( attr ) if isinstance ( prop , list ) :                  if unit == str :                      lista . append ( ( prop , name ) )  elif unit is None :                      lista . append ( ( [ <str> for f in prop ] , name ) )  else :                      lista . append ( ( [ f . str for f in prop ] , name ) )   elif unit == str :                  lista . append ( ( prop , name , 0 ) )  elif unit == int or unit == float :                  lista . append ( ( str ( prop ) , name , 1 ) )  else :                  lista . append ( ( prop . str , name , 1 ) )   return lista  def _prop ( self , attr ) :          if attr == <str> :              prop = self . __class__ . __name__  elif attr == <str> :              prop = self . notasPlain  elif type ( attr ) == tuple :              prop = self . __getattribute__ ( attr [ 0 ] ) [ self . kwargs [ attr [ 1 ] ] ]  elif attr in self . __dict__ :              prop = self . __getattribute__ ( attr )  elif attr in self . kwargs :              prop = self . kwargs [ attr ]  return prop  def propertiesListTitle ( self , index ) :          pass  def propertiesTitle ( self ) :          return [ prop [ 0 ] for prop in self . propertiesNames ( ) ]  def propertiesAttribute ( self ) :          return [ prop [ 1 ] for prop in self . propertiesNames ( ) ]  def propertiesUnit ( self ) :          return [ prop [ 2 ] for prop in self . propertiesNames ( ) ]  def popup ( self , preferences , exception = [ ] ) :          txt = [ ] propiedades = self . properties ( ) for i in eval ( preferences . get ( <str> , self . __class__ . __name__ ) ) :              if isinstance ( propiedades [ i ] [ 0 ] , list ) :                  txt . append ( ( propiedades [ i ] [ 1 ] , <str> , 0 ) ) title = self . propertiesListTitle ( i ) for name , value in zip ( title , propiedades [ i ] [ 0 ] ) :                      txt . append ( ( <str> % ( name , value ) , <str> , 1 ) )   else :                  txt . append ( propiedades [ i ] )   return txt  def propertiesToText ( self , index = None , linesep = True , suffix = <str> , kwCheck = False , kwKey = <str> , kwSuffix = <str> , kwValue = <str> ) :          mask = <str> % ( <str> , self . TEXT_FORMATING_LENG , <str> ) if index is None :              index = range ( len ( self . propertiesNames ( ) ) )  if isinstance ( index , int ) :              index = [ index ]  txt = <str> for i in index :              title , prop , unit = self . propertiesNames ( ) [ i ] if not kwKey :                  kwKey = prop  value = self . _prop ( prop ) if unit != str and unit != float and unit != int :                  value = value . str  elif unit == str :                  value = <str> + value  elif unit == float or unit == int :                  value = <str> % value . __repr__ ( )  txt += mask % ( title , value ) if kwCheck :                  if self . kwargs [ kwKey ] == kwValue :                      txt += kwSuffix   if suffix :                  txt += suffix  if linesep :                  txt += os . linesep   return txt    