from django . db import models from django . utils . translation import ugettext_lazy as l_ from django . contrib . contenttypes . models import ContentType from django . contrib . contenttypes . fields import GenericForeignKey , GenericRelation from jsonfield import JSONField from . Instructions import Instruction import json from gfklookupwidget . fields import GfkLookupField from pip . cmdoptions import verbose from . BaseStimuli import BaseStimuli , Question class BaseSettingBlock ( models . Model ) :      class Meta :          abstract = True index_together = [ <str> , <str> ]  global_settings_type = models . ForeignKey ( ContentType , help_text = l_ ( <str> ) ) global_settings_id = models . PositiveIntegerField ( help_text = l_ ( <str> ) ) part_of = GenericForeignKey ( <str> , <str> ) name = models . CharField ( max_length = 24 , help_text = l_ ( <str> ) ) position_in_timeline = models . PositiveSmallIntegerField ( default = 0 , help_text = l_ ( <str> ) ) reprise = models . PositiveSmallIntegerField ( null = True , blank = True , help_text = l_ ( <str> ) ) length = models . PositiveIntegerField ( null = True , blank = True , help_text = l_ ( <str> ) ) save_with = models . ForeignKey ( ContentType , related_name = <str> , help_text = l_ ( <str> ) ) has_practice = models . BooleanField ( help_text = l_ ( <str> ) , default = False ) instructions = GenericRelation ( Instruction ) extra_params = JSONField ( null = True , blank = True ) def toDict ( self ) :          if self . reprise is not None :              return { <str> : self . reprise }  dictionary = dict ( self . __dict__ ) dictionary [ <str> ] = self . type del dictionary [ <str> ] del dictionary [ <str> ] del dictionary [ <str> ] del dictionary [ <str> ] if self . extra_params is not None :              for key , value in self . extra_params . items ( ) :                  dictionary [ key ] = value   dictionary [ <str> ] = self . sort_instructions ( ) return dictionary  def sort_instructions ( self ) :          instructions = { } instructions_before = [ ] instructions_after = [ ] for inst in self . instructions . all ( ) :              if not inst . after :                  instructions_before . append ( inst )  else :                  instructions_after . append ( inst )   instructions_before . sort ( key = lambda x : x . order ) instructions_after . sort ( key = lambda x : x . order ) if instructions_after :              instructions [ <str> ] = { <str> : <str> , <str> : [ ] } for instruction in instructions_after :                  if instruction . show_clickable_nav :                      instructions [ <str> ] [ <str> ] = True  if instruction . key_forward :                      instructions [ <str> ] [ <str> ] = instruction . key_forward  instructions [ <str> ] [ <str> ] . append ( instruction . toDict ( ) [ <str> ] )   if instructions_before :              instructions [ <str> ] = { <str> : <str> , <str> : [ ] } for instruction in instructions_before :                  if instruction . show_clickable_nav :                      instructions [ <str> ] [ <str> ] = True  if instruction . key_forward :                      instructions [ <str> ] [ <str> ] = instruction . key_forward  instructions [ <str> ] [ <str> ] . append ( instruction . toDict ( ) [ <str> ] )   return instructions  def get_parent_name ( self ) :          if self . part_of is not None and hasattr ( self . part_of , <str> ) :              return self . part_of . name  else :              return l_ ( <str> )   get_parent_name . short_description = l_ ( <str> )  class GenericSettingBlock ( BaseSettingBlock ) :      class Meta :          verbose_name = l_ ( <str> )  def __str__ ( self ) :          return l_ ( <str> ) + self . name + <str>  pass  class AnimationBlock ( BaseSettingBlock ) :      type = <str> frame_time = models . IntegerField ( default = 250 , help_text = l_ ( <str> ) ) frame_isi = models . IntegerField ( default = 0 , help_text = l_ ( <str> ) ) sequence_reps = models . IntegerField ( default = 1 , help_text = l_ ( <str> ) ) choices = models . CharField ( blank = True , max_length = 1024 , help_text = l_ ( <str> ) ) prompt = models . CharField ( max_length = 256 , blank = True , help_text = l_ ( <str> ) ) def toDict ( self ) :          initial = super ( AnimationBlock , self ) . toDict ( ) initial [ <str> ] = self . choices . split ( <str> ) initial [ <str> ] = <str> . format ( self . prompt ) return initial   class ButtonResponseBlock ( BaseSettingBlock ) :      type = <str> is_html = models . BooleanField ( default = False , help_text = l_ ( <str> ) ) choices = models . CharField ( blank = True , max_length = 1024 , help_text = l_ ( <str> ) ) prompt = models . CharField ( max_length = 256 , blank = True , help_text = l_ ( <str> ) ) timing_stim = models . IntegerField ( help_text = l_ ( <str> ) , default = - 1 ) timing_response = models . IntegerField ( help_text = l_ ( <str> ) , default = - 1 ) response_ends_trial = models . BooleanField ( help_text = l_ ( <str> ) , default = True ) def toDict ( self ) :          initial = super ( ButtonResponseBlock , self ) . toDict ( ) initial [ <str> ] = self . choices . split ( <str> ) initial [ <str> ] = <str> . format ( self . prompt ) return initial   class CategorizeAnimationBlock ( BaseSettingBlock ) :      type = <str> choices = models . CharField ( blank = True , max_length = 1024 , help_text = l_ ( <str> ) ) correct_text = models . CharField ( max_length = 64 , help_text = l_ ( <str> ) , default = <str> ) incorrect_text = models . CharField ( max_length = 64 , help_text = l_ ( <str> ) , default = <str> ) frame_time = models . IntegerField ( default = 250 , help_text = l_ ( <str> ) ) sequence_reps = models . IntegerField ( default = 1 , help_text = l_ ( <str> ) ) allow_response_before_complete = models . BooleanField ( default = False , help_text = l_ ( <str> ) ) prompt = models . CharField ( max_length = 256 , blank = True , help_text = l_ ( <str> ) ) timing_feedback_duration = models . IntegerField ( default = 2000 , help_text = l_ ( <str> ) ) def toDict ( self ) :          initial = super ( ButtonResponseBlock , self ) . toDict ( ) initial [ <str> ] = self . choices . split ( <str> ) initial [ <str> ] = <str> . format ( self . prompt ) return initial   class FreeSortBlock ( BaseSettingBlock ) :      type = <str> stim_height = models . PositiveIntegerField ( default = 100 , help_text = l_ ( <str> ) ) stim_width = models . PositiveIntegerField ( default = 100 , help_text = l_ ( <str> ) ) sort_area_height = models . PositiveIntegerField ( default = 800 , help_text = l_ ( <str> ) ) sort_area_width = models . PositiveIntegerField ( default = 800 , help_text = l_ ( <str> ) ) prompt = models . CharField ( max_length = 256 , blank = True , help_text = l_ ( <str> ) ) prompt_location = models . CharField ( default = <str> , max_length = 24 , help_text = l_ ( <str> ) ) def toDict ( self ) :          initial = super ( FreeSortBlock , self ) . toDict ( ) initial [ <str> ] = <str> . format ( self . prompt ) return initial   class MultiStimMultiResponseBlock ( BaseSettingBlock ) :      <str> is_html = models . BooleanField ( default = False , help_text = l_ ( <str> ) ) choices = models . CharField ( blank = True , max_length = 1024 , help_text = l_ ( <str> ) ) prompt = models . CharField ( max_length = 256 , blank = True , help_text = l_ ( <str> ) ) timing_stim = models . CharField ( blank = True , max_length = 1024 , help_text = l_ ( <str> ) ) timing_response = models . IntegerField ( help_text = l_ ( <str> ) , default = - 1 ) response_ends_trial = models . BooleanField ( help_text = l_ ( <str> ) , default = True ) def toDict ( self ) :          initial = super ( MultiStimMultiResponseBlock , self ) . toDict ( ) initial [ <str> ] = [ x . split ( <str> ) for x in self . choices . split ( <str> ) ] initial [ <str> ] = self . timing_stim . split ( <str> ) initial [ <str> ] = <str> . format ( self . prompt ) return initial   class ReconstructionBlock ( BaseSettingBlock ) :      type = <str> starting_value = models . FloatField ( default = 0.5 , help_text = l_ ( <str> ) ) step_size = models . FloatField ( default = 0.05 , help_text = l_ ( <str> ) ) key_increase = models . CharField ( max_length = 2 , default = <str> , help_text = l_ ( <str> ) ) key_decrease = models . CharField ( max_length = 2 , default = <str> , help_text = l_ ( <str> ) )  class SameDifferentBlock ( BaseSettingBlock ) :      type = <str> is_html = models . BooleanField ( default = False , help_text = l_ ( <str> ) ) same_key = models . CharField ( max_length = 2 , default = <str> , help_text = l_ ( <str> ) ) different_key = models . CharField ( max_length = 2 , default = <str> , help_text = l_ ( <str> ) ) timing_first_stim = models . IntegerField ( default = 1000 , help_text = l_ ( <str> ) ) timing_gap = models . IntegerField ( default = 500 , help_text = l_ ( <str> ) ) timing_second_stim = models . IntegerField ( default = 1000 , help_text = l_ ( <str> ) ) prompt = models . CharField ( max_length = 256 , blank = True , help_text = l_ ( <str> ) ) def toDict ( self ) :          initial = super ( SameDifferentBlock , self ) . toDict ( ) initial [ <str> ] = <str> . format ( self . prompt ) return initial   class SingleAudioBlock ( BaseSettingBlock ) :      type = <str> choices = models . CharField ( blank = True , max_length = 1024 , help_text = l_ ( <str> ) ) prompt = models . CharField ( max_length = 256 , blank = True , help_text = l_ ( <str> ) ) timing_response = models . IntegerField ( help_text = l_ ( <str> ) , default = - 1 ) response_ends_trial = models . BooleanField ( help_text = l_ ( <str> ) , default = True ) def toDict ( self ) :          initial = super ( SingleAudioBlock , self ) . toDict ( ) initial [ <str> ] = self . choices . split ( <str> ) initial [ <str> ] = <str> . format ( self . prompt ) return initial   class SingleStimBlock ( BaseSettingBlock ) :      type = <str> is_html = models . BooleanField ( default = False , help_text = l_ ( <str> ) ) choices = models . CharField ( blank = True , max_length = 1024 , help_text = l_ ( <str> ) ) prompt = models . CharField ( max_length = 256 , blank = True , help_text = l_ ( <str> ) ) timing_stim = models . IntegerField ( default = - 1 , help_text = l_ ( <str> ) ) timing_response = models . IntegerField ( help_text = l_ ( <str> ) , default = - 1 ) response_ends_trial = models . BooleanField ( help_text = l_ ( <str> ) , default = True ) def toDict ( self ) :          initial = super ( SingleStimBlock , self ) . toDict ( ) initial [ <str> ] = self . choices . split ( <str> ) initial [ <str> ] = <str> . format ( self . prompt ) return initial   class SurveyLikertBlock ( BaseSettingBlock ) :      type = <str> questions = GenericRelation ( Question ) preamble = models . CharField ( max_length = 256 , null = True , blank = True , help_text = l_ ( <str> ) ) def toDict ( self ) :          initial = super ( SurveyLikertBlock , self ) . toDict ( ) questions_list = [ ] option_labels_list = [ ] question_requirement_list = [ ] for question in self . questions . all ( ) :              questions_list . append ( question . question_label ) option_labels_list . append ( question . answer_options . split ( <str> ) ) question_requirement_list . append ( question . required )  initial [ <str> ] = questions_list initial [ <str> ] = option_labels_list initial [ <str> ] = question_requirement_list initial [ <str> ] = self . preamble return initial   class SurveyMultiChoiceBlock ( BaseSettingBlock ) :      type = <str> preamble = models . TextField ( help_text = l_ ( <str> ) ) horizontal = models . BooleanField ( help_text = l_ ( <str> ) , default = False ) questions = GenericRelation ( Question ) def toDict ( self ) :          initial = super ( SurveyMultiChoiceBlock , self ) . toDict ( ) questions_list = [ ] option_labels_list = [ ] question_requirement_list = [ ] for question in self . questions . all ( ) :              questions_list . append ( question . question_label ) option_labels_list . append ( question . answer_options . split ( <str> ) ) question_requirement_list . append ( question . required )  initial [ <str> ] = questions_list initial [ <str> ] = option_labels_list initial [ <str> ] = question_requirement_list initial [ <str> ] = self . preamble return initial   class SurveyTextBlock ( BaseSettingBlock ) :      type = <str> questions = GenericRelation ( Question ) preamble = models . TextField ( blank = True , null = True , help_text = l_ ( <str> ) ) def toDict ( self ) :          initial = super ( SurveyTextBlock , self ) . toDict ( ) questions_list = [ ] option_labels_list = [ ] question_requirement_list = [ ] for question in self . questions . all ( ) :              questions_list . append ( question . question_label ) if question . answer_options is not None :                  option_labels_list . append ( question . answer_options . split ( <str> ) )  question_requirement_list . append ( question . required )  initial [ <str> ] = questions_list initial [ <str> ] = option_labels_list initial [ <str> ] = question_requirement_list initial [ <str> ] = self . preamble return initial   class XABBlock ( BaseSettingBlock ) :      type = <str> is_html = models . BooleanField ( default = False , help_text = l_ ( <str> ) ) left_key = models . CharField ( max_length = 2 , default = <str> , help_text = l_ ( <str> ) ) right_key = models . CharField ( max_length = 2 , default = <str> , help_text = l_ ( <str> ) ) prompt = models . CharField ( max_length = 256 , blank = True , help_text = l_ ( <str> ) ) timing_x = models . IntegerField ( default = 1000 , help_text = l_ ( <str> ) ) timing_xab_gap = models . IntegerField ( default = 1000 , help_text = l_ ( <str> ) ) timing_ab = models . IntegerField ( default = - 1 , help_text = l_ ( <str> ) ) timing_response = models . IntegerField ( default = - 1 , help_text = l_ ( <str> ) ) def toDict ( self ) :          initial = super ( XABBlock , self ) . toDict ( ) initial [ <str> ] = <str> . format ( self . prompt ) return initial    