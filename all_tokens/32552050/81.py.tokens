import os from django . core . files . storage import default_storage from django . core . exceptions import ObjectDoesNotExist from django . db import models from django . conf import settings from django . utils . translation import ugettext_lazy as l_ from django . utils . translation import ugettext as _ from djPsych . exceptions import SettingException , ParticipationRefused from djuser . models import Subject from django . contrib . contenttypes . models import ContentType from django . contrib . auth . models import Group , Permission from django_markdown . models import MarkdownField import markdown from djPsych . utils import get_type from django . contrib . contenttypes . fields import GenericRel , GenericRelation from . utils import validate_exp_label class BaseExperiment ( models . Model ) :      class Meta :          abstract = True  label = models . CharField ( max_length = 32 , unique = True , validators = [ validate_exp_label ] ) verbose_name = models . CharField ( max_length = 128 ) description = models . TextField ( blank = True , null = True ) estimated_length = models . CharField ( max_length = 16 , blank = True , null = True ) allow_repeats = models . BooleanField ( help_text = <str> ) max_repeats = models . SmallIntegerField ( null = True , blank = True , help_text = l_ ( <str> ) ) enforce_finish = models . BooleanField ( help_text = l_ ( <str> ) ) max_pending = models . PositiveSmallIntegerField ( blank = True , null = True , help_text = l_ ( <str> ) ) compensated = models . BooleanField ( l_ ( <str> ) , help_text = <str> , default = False ) max_payouts = models . IntegerField ( help_text = <str> , blank = True , null = True ) allow_do_overs = models . BooleanField ( help_text = <str> , blank = True , default = False ) funds_remaining = models . FloatField ( blank = True , null = True , help_text = <str> ) is_active = models . BooleanField ( l_ ( <str> ) , help_text = <str> ) total_funds_added = models . FloatField ( blank = True , null = True , help_text = <str> ) settings_model = models . ForeignKey ( ContentType ) block_models = models . ManyToManyField ( ContentType , related_name = <str> ) research_group = models . OneToOneField ( Group , null = True , blank = True ) PayPal_API_Username = models . CharField ( max_length = 64 , blank = True , null = True , help_text = l_ ( <str> ) ) PayPal_API_Password = models . CharField ( max_length = 64 , blank = True , null = True , help_text = l_ ( <str> ) ) PayPal_API_Signature = models . CharField ( max_length = 128 , blank = True , null = True , help_text = l_ ( <str> ) ) PayPal_Live_ID = models . CharField ( max_length = 64 , blank = True , null = True , help_text = l_ ( <str> ) ) PayPal_sender_email = models . EmailField ( null = True , blank = True ) ParticipationRefused = ParticipationRefused consent_form = MarkdownField ( blank = True , null = True , help_text = l_ ( <str> ) ) def __str__ ( self ) :          return self . verbose_name  def augmentFunds ( self , boost ) :          if boost <= 0 :              raise SettingException ( _ ( <str> ) )  if self . funds_remaining is not None :              self . funds_remaining = self . funds_remaining + round ( boost , 2 ) self . funds_remaining = round ( self . funds_remaining , 2 ) self . total_funds_added += round ( boost , 2 ) self . total_funds_added = round ( self . total_funds_added , 2 ) self . save ( )  else :              raise SettingException ( _ ( <str> ) )   def deductFunds ( self , amount ) :          if amount <= 0 :              raise SettingException ( _ ( <str> ) )  if self . funds_remaining is not None :              self . funds_remaining = self . funds_remaining - amount if self . funds_remaining - amount > 0.0 else 0.0 self . funds_remaining = round ( self . funds_remaining , 2 ) self . save ( )  else :              raise SettingException ( _ ( <str> ) )   def get_global_settings ( self , version , waiting = None , requested = None ) :          return self . settings_model . get_object_for_this_type ( name = version , experiment = self )  def create_participation ( self , subject , started , complete = False , parameters = { } ) :          part = self . participation_model ( subject = subject , experiment = self , started = started , complete = complete , parameters = parameters ) part . save ( ) return part  def get_all_configurations ( self ) :          return self . settings_model . model_class ( ) . objects . filter ( experiment = self )  def count_finished_part ( self ) :          return self . participation_set . count ( )  count_finished_part . short_description = l_ ( <str> ) def list_static_resources ( self ) :          resource_dict = { <str> : [ ] } exp_root = os . path . join ( settings . MEDIA_ROOT , self . label ) if os . path . exists ( exp_root ) :              entries = default_storage . listdir ( exp_root ) if entries [ 1 ] :                  resource_dict [ <str> ] = entries [ 1 ]  for folder in entries [ 0 ] :                  if folder == <str> :                      folder = <str>  subfiles = default_storage . listdir ( os . path . join ( exp_root , folder ) ) resource_dict [ folder ] = subfiles [ 1 ]  return resource_dict  else :              return { }   def is_researcher ( self , request ) :          return self . research_group in request . user . groups . all ( )  def list_static_urls ( self ) :          resource_dict = self . list_static_resources ( ) url_dict = { <str> : [ ] , <str> : [ ] , <str> : [ ] , <str> : [ ] , <str> : [ ] , <str> : [ ] } for folder , filelist in resource_dict . items ( ) :              directory = folder if folder != <str> else <str> for file in filelist :                  path = os . path . join ( default_storage . base_url , self . label + <str> , directory , file ) url_dict [ get_type ( path ) ] . append ( path )   return url_dict  def get_latest_pending ( self , request ) :          if request . user . is_anonymous ( ) :              return False  try :              last = self . participation_set . filter ( subject__user = request . user , complete = False ) . latest ( field_name = <str> )  except ObjectDoesNotExist :              return False  return last  def count_dropouts ( self ) :          return self . dropout_set . count ( )   class Experiment ( BaseExperiment ) :      participations = models . ManyToManyField ( Subject , through = <str> ) def amount_spent ( self ) :          total = 0.00 for part in self . participation_set . all ( ) :              total = total + part . payment . amount  return total   class Debrief ( models . Model ) :      experiment = models . OneToOneField ( Experiment ) content = MarkdownField ( help_text = l_ ( <str> ) ) def render ( self ) :          if self . content is not None :              return markdown . markdown ( self . content )  else :              return l_ ( <str> )   def __str__ ( self ) :          return l_ ( <str> ) % self . experiment . verbose_name   class Lobby ( models . Model ) :      experiment = models . OneToOneField ( Experiment ) content = MarkdownField ( help_text = l_ ( <str> ) ) def render ( self ) :          if self . content is not None :              return markdown . markdown ( self . content )  else :              return l_ ( <str> )   def __str__ ( self ) :          return l_ ( <str> ) % self . experiment . verbose_name    