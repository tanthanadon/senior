from base64 import b64encode from collections import Callable from errno import EOPNOTSUPP , EINVAL , EAGAIN import functools from io import BytesIO import logging import os from os import SEEK_CUR import socket import struct import sys __version__ = <str> if os . name == <str> and sys . version_info < ( 3 , 0 ) :      try :          import win_inet_pton  except ImportError :          raise ImportError ( <str> )   log = logging . getLogger ( __name__ ) PROXY_TYPE_SOCKS4 = SOCKS4 = 1 PROXY_TYPE_SOCKS5 = SOCKS5 = 2 PROXY_TYPE_HTTP = HTTP = 3 PROXY_TYPES = { <str> : SOCKS4 , <str> : SOCKS5 , <str> : HTTP } PRINTABLE_PROXY_TYPES = dict ( zip ( PROXY_TYPES . values ( ) , PROXY_TYPES . keys ( ) ) ) _orgsocket = _orig_socket = socket . socket def set_self_blocking ( function ) :      @ functools . wraps ( function ) def wrapper ( * args , ** kwargs ) :          self = args [ 0 ] try :              _is_blocking = self . gettimeout ( ) if _is_blocking == 0 :                  self . setblocking ( True )  return function ( * args , ** kwargs )  except Exception as e :              raise  finally :              if _is_blocking == 0 :                  self . setblocking ( False )    return wrapper  class ProxyError ( IOError ) :      def __init__ ( self , msg , socket_err = None ) :          self . msg = msg self . socket_err = socket_err if socket_err :              self . msg += <str> . format ( socket_err )   def __str__ ( self ) :          return self . msg   class GeneralProxyError ( ProxyError ) :      pass  class ProxyConnectionError ( ProxyError ) :      pass  class SOCKS5AuthError ( ProxyError ) :      pass  class SOCKS5Error ( ProxyError ) :      pass  class SOCKS4Error ( ProxyError ) :      pass  class HTTPError ( ProxyError ) :      pass  SOCKS4_ERRORS = { 0x5B : <str> , 0x5C : ( <str> <str> ) , 0x5D : ( <str> <str> ) } SOCKS5_ERRORS = { 0x01 : <str> , 0x02 : <str> , 0x03 : <str> , 0x04 : <str> , 0x05 : <str> , 0x06 : <str> , 0x07 : <str> , 0x08 : <str> } DEFAULT_PORTS = { SOCKS4 : 1080 , SOCKS5 : 1080 , HTTP : 8080 } def set_default_proxy ( proxy_type = None , addr = None , port = None , rdns = True , username = None , password = None ) :      socksocket . default_proxy = ( proxy_type , addr , port , rdns , username . encode ( ) if username else None , password . encode ( ) if password else None )  def setdefaultproxy ( * args , ** kwargs ) :      if <str> in kwargs :          kwargs [ <str> ] = kwargs . pop ( <str> )  return set_default_proxy ( * args , ** kwargs )  def get_default_proxy ( ) :      return socksocket . default_proxy  getdefaultproxy = get_default_proxy def wrap_module ( module ) :      if socksocket . default_proxy :          module . socket . socket = socksocket  else :          raise GeneralProxyError ( <str> )   wrapmodule = wrap_module def create_connection ( dest_pair , timeout = None , source_address = None , proxy_type = None , proxy_addr = None , proxy_port = None , proxy_rdns = True , proxy_username = None , proxy_password = None , socket_options = None ) :      remote_host , remote_port = dest_pair if remote_host . startswith ( <str> ) :          remote_host = remote_host . strip ( <str> )  if proxy_addr and proxy_addr . startswith ( <str> ) :          proxy_addr = proxy_addr . strip ( <str> )  err = None for r in socket . getaddrinfo ( proxy_addr , proxy_port , 0 , socket . SOCK_STREAM ) :          family , socket_type , proto , canonname , sa = r sock = None try :              sock = socksocket ( family , socket_type , proto ) if socket_options :                  for opt in socket_options :                      sock . setsockopt ( * opt )   if isinstance ( timeout , ( int , float ) ) :                  sock . settimeout ( timeout )  if proxy_type :                  sock . set_proxy ( proxy_type , proxy_addr , proxy_port , proxy_rdns , proxy_username , proxy_password )  if source_address :                  sock . bind ( source_address )  sock . connect ( ( remote_host , remote_port ) ) return sock  except ( socket . error , ProxyConnectionError ) as e :              err = e if sock :                  sock . close ( ) sock = None    if err :          raise err  raise socket . error ( <str> )  class _BaseSocket ( socket . socket ) :      def __init__ ( self , * pos , ** kw ) :          _orig_socket . __init__ ( self , * pos , ** kw ) self . _savedmethods = dict ( ) for name in self . _savenames :              self . _savedmethods [ name ] = getattr ( self , name ) delattr ( self , name )   _savenames = list ( )  def _makemethod ( name ) :      return lambda self , * pos , ** kw : self . _savedmethods [ name ] ( * pos , ** kw )  for name in ( <str> , <str> , <str> , <str> ) :      method = getattr ( _BaseSocket , name , None ) if not isinstance ( method , Callable ) :          _BaseSocket . _savenames . append ( name ) setattr ( _BaseSocket , name , _makemethod ( name ) )   class socksocket ( _BaseSocket ) :      default_proxy = None def __init__ ( self , family = socket . AF_INET , type = socket . SOCK_STREAM , proto = 0 , * args , ** kwargs ) :          if type not in ( socket . SOCK_STREAM , socket . SOCK_DGRAM ) :              msg = <str> raise ValueError ( msg . format ( type ) )  super ( socksocket , self ) . __init__ ( family , type , proto , * args , ** kwargs ) self . _proxyconn = None if self . default_proxy :              self . proxy = self . default_proxy  else :              self . proxy = ( None , None , None , None , None , None )  self . proxy_sockname = None self . proxy_peername = None self . _timeout = None  def _readall ( self , file , count ) :          data = <str> while len ( data ) < count :              d = file . read ( count - len ( data ) ) if not d :                  raise GeneralProxyError ( <str> )  data += d  return data  def settimeout ( self , timeout ) :          self . _timeout = timeout try :              peer = self . get_proxy_peername ( ) super ( socksocket , self ) . settimeout ( self . _timeout )  except socket . error :              pass   def gettimeout ( self ) :          return self . _timeout  def setblocking ( self , v ) :          if v :              self . settimeout ( None )  else :              self . settimeout ( 0.0 )   def set_proxy ( self , proxy_type = None , addr = None , port = None , rdns = True , username = None , password = None ) :          self . proxy = ( proxy_type , addr , port , rdns , username . encode ( ) if username else None , password . encode ( ) if password else None )  def setproxy ( self , * args , ** kwargs ) :          if <str> in kwargs :              kwargs [ <str> ] = kwargs . pop ( <str> )  return self . set_proxy ( * args , ** kwargs )  def bind ( self , * pos , ** kw ) :          ( proxy_type , proxy_addr , proxy_port , rdns , username , password ) = self . proxy if not proxy_type or self . type != socket . SOCK_DGRAM :              return _orig_socket . bind ( self , * pos , ** kw )  if self . _proxyconn :              raise socket . error ( EINVAL , <str> )  if proxy_type != SOCKS5 :              msg = <str> raise socket . error ( EOPNOTSUPP , msg )  super ( socksocket , self ) . bind ( * pos , ** kw ) _ , port = self . getsockname ( ) dst = ( <str> , port ) self . _proxyconn = _orig_socket ( ) proxy = self . _proxy_addr ( ) self . _proxyconn . connect ( proxy ) UDP_ASSOCIATE = <str> _ , relay = self . _SOCKS5_request ( self . _proxyconn , UDP_ASSOCIATE , dst ) host , _ = proxy _ , port = relay super ( socksocket , self ) . connect ( ( host , port ) ) super ( socksocket , self ) . settimeout ( self . _timeout ) self . proxy_sockname = ( <str> , 0 )  def sendto ( self , bytes , * args , ** kwargs ) :          if self . type != socket . SOCK_DGRAM :              return super ( socksocket , self ) . sendto ( bytes , * args , ** kwargs )  if not self . _proxyconn :              self . bind ( ( <str> , 0 ) )  address = args [ - 1 ] flags = args [ : - 1 ] header = BytesIO ( ) RSV = <str> header . write ( RSV ) STANDALONE = <str> header . write ( STANDALONE ) self . _write_SOCKS5_address ( address , header ) sent = super ( socksocket , self ) . send ( header . getvalue ( ) + bytes , * flags , ** kwargs ) return sent - header . tell ( )  def send ( self , bytes , flags = 0 , ** kwargs ) :          if self . type == socket . SOCK_DGRAM :              return self . sendto ( bytes , flags , self . proxy_peername , ** kwargs )  else :              return super ( socksocket , self ) . send ( bytes , flags , ** kwargs )   def recvfrom ( self , bufsize , flags = 0 ) :          if self . type != socket . SOCK_DGRAM :              return super ( socksocket , self ) . recvfrom ( bufsize , flags )  if not self . _proxyconn :              self . bind ( ( <str> , 0 ) )  buf = BytesIO ( super ( socksocket , self ) . recv ( bufsize + 1024 , flags ) ) buf . seek ( 2 , SEEK_CUR ) frag = buf . read ( 1 ) if ord ( frag ) :              raise NotImplementedError ( <str> )  fromhost , fromport = self . _read_SOCKS5_address ( buf ) if self . proxy_peername :              peerhost , peerport = self . proxy_peername if fromhost != peerhost or peerport not in ( 0 , fromport ) :                  raise socket . error ( EAGAIN , <str> )   return ( buf . read ( bufsize ) , ( fromhost , fromport ) )  def recv ( self , * pos , ** kw ) :          bytes , _ = self . recvfrom ( * pos , ** kw ) return bytes  def close ( self ) :          if self . _proxyconn :              self . _proxyconn . close ( )  return super ( socksocket , self ) . close ( )  def get_proxy_sockname ( self ) :          return self . proxy_sockname  getproxysockname = get_proxy_sockname def get_proxy_peername ( self ) :          return self . getpeername ( )  getproxypeername = get_proxy_peername def get_peername ( self ) :          return self . proxy_peername  getpeername = get_peername def _negotiate_SOCKS5 ( self , * dest_addr ) :          CONNECT = <str> self . proxy_peername , self . proxy_sockname = self . _SOCKS5_request ( self , CONNECT , dest_addr )  def _SOCKS5_request ( self , conn , cmd , dst ) :          proxy_type , addr , port , rdns , username , password = self . proxy writer = conn . makefile ( <str> ) reader = conn . makefile ( <str> , 0 ) try :              if username and password :                  writer . write ( <str> )  else :                  writer . write ( <str> )  writer . flush ( ) chosen_auth = self . _readall ( reader , 2 ) if chosen_auth [ 0 : 1 ] != <str> :                  raise GeneralProxyError ( <str> )  if chosen_auth [ 1 : 2 ] == <str> :                  writer . write ( <str> + chr ( len ( username ) ) . encode ( ) + username + chr ( len ( password ) ) . encode ( ) + password ) writer . flush ( ) auth_status = self . _readall ( reader , 2 ) if auth_status [ 0 : 1 ] != <str> :                      raise GeneralProxyError ( <str> )  if auth_status [ 1 : 2 ] != <str> :                      raise SOCKS5AuthError ( <str> )   elif chosen_auth [ 1 : 2 ] != <str> :                  if chosen_auth [ 1 : 2 ] == <str> :                      raise SOCKS5AuthError ( <str> <str> )  else :                      raise GeneralProxyError ( <str> )   writer . write ( <str> + cmd + <str> ) resolved = self . _write_SOCKS5_address ( dst , writer ) writer . flush ( ) resp = self . _readall ( reader , 3 ) if resp [ 0 : 1 ] != <str> :                  raise GeneralProxyError ( <str> )  status = ord ( resp [ 1 : 2 ] ) if status != 0x00 :                  error = SOCKS5_ERRORS . get ( status , <str> ) raise SOCKS5Error ( <str> . format ( status , error ) )  bnd = self . _read_SOCKS5_address ( reader ) super ( socksocket , self ) . settimeout ( self . _timeout ) return ( resolved , bnd )  finally :              reader . close ( ) writer . close ( )   def _write_SOCKS5_address ( self , addr , file ) :          host , port = addr proxy_type , _ , _ , rdns , username , password = self . proxy family_to_byte = { socket . AF_INET : <str> , socket . AF_INET6 : <str> } for family in ( socket . AF_INET , socket . AF_INET6 ) :              try :                  addr_bytes = socket . inet_pton ( family , host ) file . write ( family_to_byte [ family ] + addr_bytes ) host = socket . inet_ntop ( family , addr_bytes ) file . write ( struct . pack ( <str> , port ) ) return host , port  except socket . error :                  continue   if rdns :              host_bytes = host . encode ( <str> ) file . write ( <str> + chr ( len ( host_bytes ) ) . encode ( ) + host_bytes )  else :              addresses = socket . getaddrinfo ( host , port , socket . AF_UNSPEC , socket . SOCK_STREAM , socket . IPPROTO_TCP , socket . AI_ADDRCONFIG ) target_addr = addresses [ 0 ] family = target_addr [ 0 ] host = target_addr [ 4 ] [ 0 ] addr_bytes = socket . inet_pton ( family , host ) file . write ( family_to_byte [ family ] + addr_bytes ) host = socket . inet_ntop ( family , addr_bytes )  file . write ( struct . pack ( <str> , port ) ) return host , port  def _read_SOCKS5_address ( self , file ) :          atyp = self . _readall ( file , 1 ) if atyp == <str> :              addr = socket . inet_ntoa ( self . _readall ( file , 4 ) )  elif atyp == <str> :              length = self . _readall ( file , 1 ) addr = self . _readall ( file , ord ( length ) )  elif atyp == <str> :              addr = socket . inet_ntop ( socket . AF_INET6 , self . _readall ( file , 16 ) )  else :              raise GeneralProxyError ( <str> )  port = struct . unpack ( <str> , self . _readall ( file , 2 ) ) [ 0 ] return addr , port  def _negotiate_SOCKS4 ( self , dest_addr , dest_port ) :          proxy_type , addr , port , rdns , username , password = self . proxy writer = self . makefile ( <str> ) reader = self . makefile ( <str> , 0 ) try :              remote_resolve = False try :                  addr_bytes = socket . inet_aton ( dest_addr )  except socket . error :                  if rdns :                      addr_bytes = <str> remote_resolve = True  else :                      addr_bytes = socket . inet_aton ( socket . gethostbyname ( dest_addr ) )   writer . write ( struct . pack ( <str> , 0x04 , 0x01 , dest_port ) ) writer . write ( addr_bytes ) if username :                  writer . write ( username )  writer . write ( <str> ) if remote_resolve :                  writer . write ( dest_addr . encode ( <str> ) + <str> )  writer . flush ( ) resp = self . _readall ( reader , 8 ) if resp [ 0 : 1 ] != <str> :                  raise GeneralProxyError ( <str> )  status = ord ( resp [ 1 : 2 ] ) if status != 0x5A :                  error = SOCKS4_ERRORS . get ( status , <str> ) raise SOCKS4Error ( <str> . format ( status , error ) )  self . proxy_sockname = ( socket . inet_ntoa ( resp [ 4 : ] ) , struct . unpack ( <str> , resp [ 2 : 4 ] ) [ 0 ] ) if remote_resolve :                  self . proxy_peername = socket . inet_ntoa ( addr_bytes ) , dest_port  else :                  self . proxy_peername = dest_addr , dest_port   finally :              reader . close ( ) writer . close ( )   def _negotiate_HTTP ( self , dest_addr , dest_port ) :          proxy_type , addr , port , rdns , username , password = self . proxy addr = dest_addr if rdns else socket . gethostbyname ( dest_addr ) http_headers = [ ( <str> + addr . encode ( <str> ) + <str> + str ( dest_port ) . encode ( ) + <str> ) , <str> + dest_addr . encode ( <str> ) ] if username and password :              http_headers . append ( <str> + b64encode ( username + <str> + password ) )  http_headers . append ( <str> ) self . sendall ( <str> . join ( http_headers ) ) fobj = self . makefile ( ) status_line = fobj . readline ( ) fobj . close ( ) if not status_line :              raise GeneralProxyError ( <str> )  try :              proto , status_code , status_msg = status_line . split ( <str> , 2 )  except ValueError :              raise GeneralProxyError ( <str> )  if not proto . startswith ( <str> ) :              raise GeneralProxyError ( <str> )  try :              status_code = int ( status_code )  except ValueError :              raise HTTPError ( <str> )  if status_code != 200 :              error = <str> . format ( status_code , status_msg ) if status_code in ( 400 , 403 , 405 ) :                  error += ( <str> <str> <str> )  raise HTTPError ( error )  self . proxy_sockname = ( <str> , 0 ) self . proxy_peername = addr , dest_port  _proxy_negotiators = { SOCKS4 : _negotiate_SOCKS4 , SOCKS5 : _negotiate_SOCKS5 , HTTP : _negotiate_HTTP } @ set_self_blocking def connect ( self , dest_pair ) :          if len ( dest_pair ) != 2 or dest_pair [ 0 ] . startswith ( <str> ) :              raise socket . error ( <str> % str ( dest_pair ) )  dest_addr , dest_port = dest_pair if self . type == socket . SOCK_DGRAM :              if not self . _proxyconn :                  self . bind ( ( <str> , 0 ) )  dest_addr = socket . gethostbyname ( dest_addr ) if dest_addr == <str> and not dest_port :                  self . proxy_peername = None  else :                  self . proxy_peername = ( dest_addr , dest_port )  return  ( proxy_type , proxy_addr , proxy_port , rdns , username , password ) = self . proxy if ( not isinstance ( dest_pair , ( list , tuple ) ) or len ( dest_pair ) != 2 or not dest_addr or not isinstance ( dest_port , int ) ) :              raise GeneralProxyError ( <str> )  super ( socksocket , self ) . settimeout ( self . _timeout ) if proxy_type is None :              self . proxy_peername = dest_pair super ( socksocket , self ) . settimeout ( self . _timeout ) super ( socksocket , self ) . connect ( ( dest_addr , dest_port ) ) return  proxy_addr = self . _proxy_addr ( ) try :              super ( socksocket , self ) . connect ( proxy_addr )  except socket . error as error :              self . close ( ) proxy_addr , proxy_port = proxy_addr proxy_server = <str> . format ( proxy_addr , proxy_port ) printable_type = PRINTABLE_PROXY_TYPES [ proxy_type ] msg = <str> . format ( printable_type , proxy_server ) log . debug ( <str> , msg , error ) raise ProxyConnectionError ( msg , error )  else :              try :                  negotiate = self . _proxy_negotiators [ proxy_type ] negotiate ( self , dest_addr , dest_port )  except socket . error as error :                  self . close ( ) raise GeneralProxyError ( <str> , error )  except ProxyError :                  self . close ( ) raise    def _proxy_addr ( self ) :          ( proxy_type , proxy_addr , proxy_port , rdns , username , password ) = self . proxy proxy_port = proxy_port or DEFAULT_PORTS . get ( proxy_type ) if not proxy_port :              raise GeneralProxyError ( <str> )  return proxy_addr , proxy_port    