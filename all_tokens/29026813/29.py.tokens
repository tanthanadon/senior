import operator import sys import xbmc import xbmcaddon import xbmcgui import xbmcplugin from log import debug , print_tb import filesystem import urllib , time _ADDON_NAME = <str> _addon = xbmcaddon . Addon ( id = _ADDON_NAME ) _addon_path = _addon . getAddonInfo ( <str> ) . decode ( <str> ) try : 	 _addondir = xbmc . translatePath ( _addon . getAddonInfo ( <str> ) ) . decode ( <str> )  except : 	 _addondir = <str>  debug ( _addondir ) from plugin import make_url def getSetting ( id , default = <str> ) : 	 result = _addon . getSetting ( id ) if result != <str> : 		 return result  else : 		 return default   def load_settings ( ) : 	 base_path = getSetting ( <str> , <str> ) . decode ( <str> ) if base_path == <str> : 		 base_path = filesystem . join ( _addondir , base_path )  movies_path = getSetting ( <str> , <str> ) . decode ( <str> ) animation_path = getSetting ( <str> , <str> ) . decode ( <str> ) documentary_path = getSetting ( <str> , <str> ) . decode ( <str> ) anime_path = getSetting ( <str> , <str> ) . decode ( <str> ) from settings import Settings settings = Settings ( base_path , movies_path = movies_path , animation_path = animation_path , documentary_path = documentary_path , anime_path = anime_path ) settings . hdclub_passkey = getSetting ( <str> ) settings . bluebird_login = getSetting ( <str> ) settings . bluebird_password = getSetting ( <str> ) settings . bluebird_nouhd = getSetting ( <str> ) settings . anidub_login = getSetting ( <str> ) settings . anidub_password = getSetting ( <str> ) settings . anidub_rss = getSetting ( <str> ) settings . anidub_favorite = getSetting ( <str> ) settings . nnmclub_pages = 3 settings . nnmclub_login = getSetting ( <str> ) settings . nnmclub_password = getSetting ( <str> ) settings . nnmclub_domain = getSetting ( <str> ) settings . nnmclub_use_ssl = getSetting ( <str> ) == <str> settings . rutor_domain = getSetting ( <str> ) settings . rutor_filter = getSetting ( <str> ) settings . soap4me_login = getSetting ( <str> ) settings . soap4me_password = getSetting ( <str> ) settings . soap4me_rss = getSetting ( <str> ) settings . preffered_bitrate = int ( getSetting ( <str> ) ) settings . preffered_type = getSetting ( <str> ) settings . preffered_codec = getSetting ( <str> ) settings . torrent_player = getSetting ( <str> ) settings . storage_path = getSetting ( <str> ) settings . movies_save = getSetting ( <str> ) == <str> settings . animation_save = getSetting ( <str> ) == <str> settings . documentary_save = getSetting ( <str> ) == <str> settings . anime_save = getSetting ( <str> ) == <str> settings . tvshows_save = getSetting ( <str> ) == <str> settings . animation_tvshows_save = getSetting ( <str> ) == <str> settings . torrent_path = getSetting ( <str> ) settings . rutor_nosd = getSetting ( <str> ) == <str> settings . addon_data_path = _addondir if getSetting ( <str> ) : 		 settings . addon_data_path = getSetting ( <str> )  settings . run_script = getSetting ( <str> ) == <str> settings . script_params = getSetting ( <str> ) . decode ( <str> ) settings . remeber_watched = getSetting ( <str> ) == <str> settings . move_video = getSetting ( <str> ) . decode ( <str> ) == <str> settings . remove_files = getSetting ( <str> ) . decode ( <str> ) == <str> settings . copy_video_path = getSetting ( <str> ) . decode ( <str> ) settings . copy_torrent = getSetting ( <str> ) == <str> settings . copy_torrent_path = getSetting ( <str> ) . decode ( <str> ) settings . use_kinopoisk = getSetting ( <str> ) == <str> settings . use_worldart = getSetting ( <str> ) == <str> settings . kp_googlecache = getSetting ( <str> ) == <str> settings . kp_usezaborona = getSetting ( <str> ) == <str> settings . show_sources = getSetting ( <str> ) == <str> settings . skip_show_sources = getSetting ( <str> ) == <str> settings . kinohd_enable = getSetting ( <str> ) == <str> settings . kinohd_4k = getSetting ( <str> ) == <str> settings . kinohd_1080p = getSetting ( <str> ) == <str> settings . kinohd_720p = getSetting ( <str> ) == <str> settings . kinohd_3d = getSetting ( <str> ) == <str> settings . kinohd_serial = getSetting ( <str> ) == <str> return settings  def play_torrent_variant ( path , info_dialog , episodeNumber , nfoReader , settings , params , downloader ) : 	 def _debug ( msg ) : 		 try : 			 if isinstance ( msg , str ) : 				 msg = msg . decode ( <str> )  debug ( <str> . format ( msg ) )  except : 			 debug ( <str> )   play_torrent_variant . resultOK = <str> play_torrent_variant . resultCancel = <str> play_torrent_variant . resultTryNext = <str> play_torrent_variant . resultTryAgain = <str> start_time = time . time ( ) start_play_max_time = int ( _addon . getSetting ( <str> ) ) search_seed_max_time = int ( _addon . getSetting ( <str> ) ) if episodeNumber != None : 		 episodeNumber = int ( episodeNumber )  if settings == None : 		 return play_torrent_variant . resultCancel  if downloader : 		 try : 			 downloader . start ( True )  except : 			 print_tb ( )   torrent_info = None torrent_path = path xbmc_player = None if <str> in path : 		 kinohd_torrent_player = getSetting ( <str> ) if kinohd_torrent_player and kinohd_torrent_player != <str> : 			 settings . torrent_player = kinohd_torrent_player   from torrent2http import Error as TPError try : 		 if settings . torrent_player == <str> : 			 from yatpplayer import YATPPlayer player = YATPPlayer ( )  elif settings . torrent_player == <str> : 			 from torrent2httpplayer import Torrent2HTTPPlayer player = Torrent2HTTPPlayer ( settings )  elif settings . torrent_player == <str> : 			 import aceplayer player = aceplayer . AcePlayer ( settings )  elif settings . torrent_player == <str> : 			 import elementumplayer player = elementumplayer . ElementumPlayer ( )  elif settings . torrent_player == <str> : 			 import torrserverplayer player = torrserverplayer . TorrServerPlayer ( settings )  _debug ( <str> + path ) player . AddTorrent ( path ) added = False for i in range ( start_play_max_time ) : 			 if player . CheckTorrentAdded ( ) : 				 added = True break  if xbmc . abortRequested : 				 return play_torrent_variant . resultCancel  info_dialog . update ( i , <str> , <str> , <str> ) if downloader and downloader . is_finished ( ) : 				 if downloader . info_hash ( ) and downloader . info_hash ( ) != player . info_hash : 					 downloader . move_file_to ( path ) _debug ( <str> ) return play_torrent_variant . resultTryAgain  else : 					 _debug ( <str> ) downloader = None   xbmc . sleep ( 1000 )  if not added : 			 _debug ( <str> ) return play_torrent_variant . resultTryNext  files = player . GetLastTorrentData ( ) [ <str> ] if <str> not in params : 			 if <str> not in params : 				 if episodeNumber is not None : 					 files . sort ( key = operator . itemgetter ( <str> ) )  else : 					 files . sort ( key = operator . itemgetter ( <str> ) , reverse = True )    try : 			 if <str> not in params : 				 if <str> not in params : 					 if episodeNumber is None : 						 index = 0 playable_item = files [ 0 ]  else : 						 playable_item = files [ episodeNumber ] index = playable_item . get ( <str> )   else : 					 index = - 1 for item in files : 						 if int ( params [ <str> ] ) == item [ <str> ] : 							 playable_item = item index = playable_item . get ( <str> )     else : 				 cutName = urllib . unquote ( params [ <str> ] ) . decode ( <str> ) . lower ( ) index = - 1 for item in files : 					 name = item [ <str> ] . lower ( ) from tvshowapi import cutStr if cutName in unicode ( cutStr ( name ) ) : 						 playable_item = item index = playable_item . get ( <str> ) break   if index == - 1 : 					 return play_torrent_variant . resultTryNext    except IndexError : 			 for i in range ( 10 ) : 				 if downloader and downloader . is_finished ( ) : 					 if downloader . info_hash ( ) and downloader . info_hash ( ) != player . info_hash : 						 downloader . move_file_to ( path ) print <str> return play_torrent_variant . resultTryAgain   xbmc . sleep ( 1000 )   _debug ( playable_item ) player . StartBufferFile ( index ) if not player . CheckTorrentAdded ( ) : 			 info_dialog . update ( 0 , <str> )  while not info_dialog . iscanceled ( ) and not player . CheckTorrentAdded ( ) : 			 xbmc . sleep ( 1000 ) start_time = time . time ( ) player . updateCheckingProgress ( info_dialog )  info_dialog . update ( 0 , <str> ) while not info_dialog . iscanceled ( ) : 			 if player . CheckBufferComplete ( ) : 				 break  percent = player . GetBufferingProgress ( ) if percent >= 0 : 				 player . updateDialogInfo ( percent , info_dialog )  if time . time ( ) > start_time + start_play_max_time : 				 return play_torrent_variant . resultTryNext  if time . time ( ) > start_time + search_seed_max_time : 				 info = player . GetTorrentInfo ( ) if <str> in info : 					 if info [ <str> ] == 0 : 						 _debug ( <str> ) return play_torrent_variant . resultTryNext    if downloader and downloader . is_finished ( ) : 				 if downloader . info_hash ( ) and downloader . info_hash ( ) != player . info_hash : 					 downloader . move_file_to ( path ) _debug ( <str> ) return play_torrent_variant . resultTryAgain  else : 					 _debug ( <str> ) downloader = None   xbmc . sleep ( 1000 )  canceled = info_dialog . iscanceled ( ) info_dialog . update ( 0 ) info_dialog . close ( ) if canceled : 			 return play_torrent_variant . resultCancel  playable_url = player . GetStreamURL ( playable_item ) _debug ( playable_url ) handle = int ( sys . argv [ 1 ] ) if nfoReader != None : 			 list_item = nfoReader . make_list_item ( playable_url )  else : 			 list_item = xbmcgui . ListItem ( path = playable_url )  _debug ( <str> ) rel_path = urllib . unquote ( params [ <str> ] ) . decode ( <str> ) filename = urllib . unquote ( params [ <str> ] ) . decode ( <str> ) from kodidb import KodiDB k_db = KodiDB ( filename . replace ( <str> , <str> ) , rel_path , sys . argv [ 0 ] + sys . argv [ 2 ] ) k_db . PlayerPreProccessing ( ) _debug ( <str> ) class OurPlayer ( xbmc . Player ) : 			 def __init__ ( self ) : 				 xbmc . Player . __init__ ( self ) self . show_overlay = False self . time_started = time . time ( ) self . download_started = None self . fs_video = xbmcgui . Window ( 12005 ) x = 20 y = int ( getSetting ( <str> , 120 ) ) w = self . fs_video . getWidth ( ) h = 130 self . info_label = xbmcgui . ControlLabel ( x , y , w , h , <str> , textColor = <str> , font = <str> ) self . info_label_bg = xbmcgui . ControlLabel ( x + 2 , y + 2 , w , h , <str> , textColor = <str> , font = <str> )  def _show_progress ( self ) : 				 if settings . torrent_player == <str> : 					 return  if settings . torrent_player == <str> : 					 return  if getSetting ( <str> , <str> ) != <str> : 					 return  if not self . show_overlay : 					 _debug ( <str> ) self . fs_video . addControls ( [ self . info_label_bg , self . info_label ] ) self . show_overlay = True   def _hide_progress ( self ) : 				 if self . show_overlay : 					 _debug ( <str> ) self . info_label . setLabel ( <str> ) self . info_label_bg . setLabel ( <str> ) self . fs_video . removeControls ( [ self . info_label_bg , self . info_label ] ) self . show_overlay = False   def UpdateProgress ( self ) : 				 if self . show_overlay : 					 info = player . GetTorrentInfo ( ) percent = float ( info [ <str> ] ) * 100 / info [ <str> ] if percent >= 0 : 						 heading = <str> . format ( info [ <str> ] , info [ <str> ] , int ( percent ) ) + <str> + <str> if percent < 100 : 							 heading += <str> . format ( info [ <str> ] ) this_time = time . time ( ) time_passed = ( this_time - self . time_started ) if time_passed > 10 : 								 if not self . download_started : 									 self . download_started = info [ <str> ]  average_speed = float ( ( info [ <str> ] - self . download_started ) / ( time_passed - 10 ) ) seconds = ( info [ <str> ] - info [ <str> ] ) / average_speed if average_speed != 0 else - 1 if seconds > 0 : 									 heading += <str> . format ( int ( seconds / 60 ) , int ( seconds % 60 ) )   heading += <str> . format ( info [ <str> ] , info [ <str> ] )  self . info_label . setLabel ( heading ) self . info_label_bg . setLabel ( heading )    def __del__ ( self ) : 				 _debug ( <str> ) self . _hide_progress ( ) del self . info_label del self . info_label_bg  def onPlayBackPaused ( self ) : 				 self . _show_progress ( ) self . is_playing = False  def onPlayBackResumed ( self ) : 				 self . _hide_progress ( ) self . is_playing = True  def onPlayBackEnded ( self ) : self . _hide_progress ( ) def onPlayBackStopped ( self ) : self . _hide_progress ( ) def onPlayBackError ( self ) : self . _hide_progress ( )  xbmc_player = OurPlayer ( ) _debug ( <str> ) xbmcplugin . setResolvedUrl ( handle , True , list_item ) _debug ( <str> ) while not xbmc_player . isPlaying ( ) : 			 xbmc . sleep ( 300 )  _debug ( <str> ) if k_db . timeOffset != 0 : 			 _debug ( <str> + str ( k_db . timeOffset ) ) xbmc . sleep ( 2000 ) xbmc_player . seekTime ( int ( k_db . timeOffset ) )  while not xbmc . abortRequested and xbmc_player . isPlaying ( ) : 			 player . loop ( ) xbmc . sleep ( 1000 ) xbmc_player . UpdateProgress ( )  _debug ( <str> ) xbmc . sleep ( 1000 ) k_db . PlayerPostProccessing ( ) torrent_info = player . GetTorrentInfo ( ) torrent_path = player . path info_hash = player . GetLastTorrentData ( ) [ <str> ] xbmc . executebuiltin ( <str> ) UpdateLibrary_path = filesystem . join ( settings . base_path ( ) , rel_path ) . encode ( <str> ) _debug ( UpdateLibrary_path ) if not xbmc . getCondVisibility ( <str> ) : 			 from plugin import UpdateVideoLibrary UpdateVideoLibrary ( UpdateLibrary_path )  if settings . run_script or settings . remove_files or settings . move_video or settings . copy_torrent or settings . remeber_watched : 			 import afteractions afteractions . Runner ( settings , params , playable_item , torrent_info , torrent_path , info_hash )   except TPError as e : 		 _debug ( e ) print_tb ( ) return play_torrent_variant . resultTryNext  except BaseException as e : 		 _debug ( e ) print_tb ( )  finally : 		 _debug ( <str> ) player . close ( ) if xbmc_player : 			 del xbmc_player   return play_torrent_variant . resultOK  def get_path_or_url_and_episode ( settings , params , torrent_source ) : 	 tempPath = xbmc . translatePath ( <str> ) . decode ( <str> ) from downloader import TorrentDownloader torr_downloader = TorrentDownloader ( urllib . unquote ( torrent_source ) , tempPath , settings ) path = filesystem . join ( settings . torrents_path ( ) , torr_downloader . get_subdir_name ( ) , torr_downloader . get_post_index ( ) + <str> ) if not filesystem . exists ( path ) : 		 if not torr_downloader . download ( ) : 			 return None  torr_downloader . move_file_to ( path ) torr_downloader = None  return { <str> : path , <str> : params . get ( <str> , None ) , <str> : torr_downloader }  def openInTorrenter ( nfoReader ) : 	 try : 		 xbmcaddon . Addon ( id = <str> )  except : 		 return  if not nfoReader is None : 		 info = nfoReader . get_info ( ) ctitle = None if <str> in info : 			 ctitle = info [ <str> ]  elif <str> in info : 			 ctitle = info [ <str> ]  if not ctitle is None : 			 uri = <str> % ( <str> , urllib . urlencode ( { <str> : <str> , <str> : ctitle . encode ( <str> ) } ) ) debug ( <str> + uri ) xbmc . executebuiltin ( <str> % uri )    def play_torrent ( settings , params ) : 	 from nforeader import NFOReader info_dialog = xbmcgui . DialogProgress ( ) info_dialog . create ( settings . addon_name ) tempPath = xbmc . translatePath ( <str> ) . decode ( <str> ) base_path = settings . base_path ( ) . encode ( <str> ) rel_path = urllib . unquote ( params . get ( <str> , <str> ) ) nfoFilename = urllib . unquote ( params . get ( <str> , <str> ) ) nfoFullPath = NFOReader . make_path ( base_path , rel_path , nfoFilename ) strmFilename = nfoFullPath . replace ( <str> , <str> ) nfoReader = NFOReader ( nfoFullPath , tempPath ) if filesystem . exists ( nfoFullPath ) else None debug ( strmFilename ) from base import STRMWriterBase links_with_ranks = STRMWriterBase . get_links_with_ranks ( strmFilename , settings , use_scrape_info = True ) anidub_enable = _addon . getSetting ( <str> ) == <str> hdclub_enable = False bluebird_enable = _addon . getSetting ( <str> ) == <str> nnmclub_enable = _addon . getSetting ( <str> ) == <str> rutor_enable = _addon . getSetting ( <str> ) == <str> soap4me_enable = _addon . getSetting ( <str> ) == <str> kinohd_enable = _addon . getSetting ( <str> ) == <str> onlythis = False if <str> in params and params [ <str> ] == <str> : 		 onlythis = True  for v in links_with_ranks [ : ] : 		 if not anidub_enable and <str> in v [ <str> ] : 			 links_with_ranks . remove ( v )  if not hdclub_enable and <str> in v [ <str> ] : 			 links_with_ranks . remove ( v )  if not bluebird_enable and <str> in v [ <str> ] : 			 links_with_ranks . remove ( v )  if not nnmclub_enable and <str> in v [ <str> ] : 			 links_with_ranks . remove ( v )  if not rutor_enable and <str> in v [ <str> ] : 			 links_with_ranks . remove ( v )  if not soap4me_enable and <str> in v [ <str> ] : 			 links_with_ranks . remove ( v )  if not kinohd_enable and <str> in v [ <str> ] : 			 links_with_ranks . remove ( v )   play_torrent_variant_result = None if len ( links_with_ranks ) == 0 or onlythis : 		 torrent_source = params [ <str> ] path_or_url_and_episode = get_path_or_url_and_episode ( settings , params , torrent_source ) if path_or_url_and_episode : 			 path = path_or_url_and_episode [ <str> ] episodeNumber = path_or_url_and_episode [ <str> ] downloader = path_or_url_and_episode [ <str> ] play_torrent_variant_result = play_torrent_variant ( path , info_dialog , episodeNumber , nfoReader , settings , params , downloader ) if play_torrent_variant_result == play_torrent_variant . resultTryAgain : 				 play_torrent_variant_result = play_torrent_variant ( path , info_dialog , episodeNumber , nfoReader , settings , params , None )    else : 		 for tryCount , variant in enumerate ( links_with_ranks , 1 ) : 			 if tryCount > 1 : 				 info_dialog . update ( 0 , settings . addon_name , <str> % tryCount )  torrent_source = variant [ <str> ] try : 				 torrent_source = torrent_source . split ( <str> ) [ 1 ] . split ( <str> ) [ 0 ]  except : 				 continue  path_or_url_and_episode = get_path_or_url_and_episode ( settings , params , torrent_source ) if path_or_url_and_episode is None : 				 continue  episodeNumber = path_or_url_and_episode [ <str> ] downloader = path_or_url_and_episode [ <str> ] torr_params = params . copy ( ) try : 				 import urlparse dct = urlparse . parse_qs ( variant [ <str> ] ) torr_params [ <str> ] = dct [ <str> ] [ 0 ] torr_params . pop ( <str> , None ) debug ( <str> )  except : 				 pass  play_torrent_variant_result = play_torrent_variant ( path_or_url_and_episode [ <str> ] , info_dialog , episodeNumber , nfoReader , settings , torr_params , downloader ) if play_torrent_variant_result == play_torrent_variant . resultTryAgain : 				 play_torrent_variant_result = play_torrent_variant ( path_or_url_and_episode [ <str> ] , info_dialog , episodeNumber , nfoReader , settings , torr_params , None )  if play_torrent_variant_result != play_torrent_variant . resultTryNext : 				 break    info_dialog . update ( 0 , <str> , <str> ) debug ( <str> ) info_dialog . close ( ) del info_dialog try : 		 if play_torrent_variant_result == play_torrent_variant . resultTryNext and not onlythis : 			 openInTorrenter ( nfoReader )   except : 		 pass   restart_msg = <str> def check_sources ( settings ) : 	 import sources if sources . need_create ( settings ) : 		 dialog = xbmcgui . Dialog ( ) if dialog . yesno ( settings . addon_name , <str> ) : 			 if sources . create ( settings ) : 				 if dialog . yesno ( settings . addon_name , restart_msg ) : 					 xbmc . executebuiltin ( <str> )   return True  else : 			 return False   return True  class dialog_action_case : 	 generate = 0 sources = 1 settings = 2 search = 3 catalog = 4 medialibrary = 5 exit = 6  def dialog_action ( action , settings , params = None ) : 	 if action == dialog_action_case . generate : 		 anidub_enable = _addon . getSetting ( <str> ) == <str> hdclub_enable = False bluebird_enable = _addon . getSetting ( <str> ) == <str> nnmclub_enable = _addon . getSetting ( <str> ) == <str> rutor_enable = _addon . getSetting ( <str> ) == <str> soap4me_enable = _addon . getSetting ( <str> ) == <str> kinohd_enable = _addon . getSetting ( <str> ) == <str> if not ( anidub_enable or hdclub_enable or bluebird_enable or nnmclub_enable or rutor_enable or soap4me_enable or kinohd_enable ) : 			 xbmcgui . Dialog ( ) . ok ( _ADDON_NAME , <str> , <str> ) action = dialog_action_case . settings  else : 			 from service import start_generate start_generate ( ) return True   if action == dialog_action_case . sources : 		 import sources dialog = xbmcgui . Dialog ( ) if sources . create ( settings ) : 			 if dialog . yesno ( settings . addon_name , restart_msg ) : 				 from service import update_library_next_start update_library_next_start ( ) xbmc . executebuiltin ( <str> )    if action == dialog_action_case . settings : 		 save_nnmclub_login = settings . nnmclub_login save_nnmclub_password = settings . nnmclub_password _addon . openSettings ( ) settings = load_settings ( )  if action == dialog_action_case . search : 		 s = None if not <str> in params : 			 dlg = xbmcgui . Dialog ( ) s = dlg . input ( <str> ) command = sys . argv [ 0 ] + sys . argv [ 2 ] + <str> + urllib . quote ( s ) debug ( <str> . format ( command ) ) xbmc . executebuiltin ( <str> . format ( command ) ) from plugin import kodi_ver if kodi_ver ( ) [ <str> ] < 18 : 				 debug ( <str> ) return False   else : 			 s = urllib . unquote ( params . get ( <str> ) )  if s : 			 from movieapi import TMDB_API debug ( <str> + s ) show_list ( TMDB_API . search ( s . decode ( <str> ) ) )   if action == dialog_action_case . catalog : 		 addon_handle = int ( sys . argv [ 1 ] ) xbmcplugin . setContent ( addon_handle , <str> ) listing = [ ( <str> , <str> ) , ( <str> , <str> ) , ( <str> , <str> ) , ( <str> , <str> ) ] if filesystem . exists ( <str> ) : 			 listing . append ( ( <str> , <str> ) , )  for l in listing : 			 li = xbmcgui . ListItem ( l [ 1 ] ) li . setProperty ( <str> , <str> ) li . setProperty ( <str> , <str> ) url = <str> + l [ 0 ] debug ( url ) xbmcplugin . addDirectoryItem ( handle = addon_handle , url = url , listitem = li , isFolder = True )  xbmcplugin . endOfDirectory ( addon_handle )  if action == dialog_action_case . medialibrary : 		 addon_handle = int ( sys . argv [ 1 ] ) xbmcplugin . setContent ( addon_handle , <str> ) listing = [ ( <str> , <str> ) , ( <str> , <str> ) , ( <str> , <str> ) , ( <str> , <str> ) , ( <str> , <str> ) , ( <str> , <str> ) , ( <str> , <str> ) , ( <str> , <str> ) , ( <str> , <str> ) , ( <str> , <str> ) , ( <str> , <str> ) , ( <str> , <str> ) , ( <str> , <str> ) , ( <str> , <str> ) , ( <str> , <str> ) , ( <str> , <str> ) , ( <str> , <str> ) , ( <str> , <str> ) , ] for l in listing : 			 li = xbmcgui . ListItem ( l [ 1 ] ) li . setProperty ( <str> , <str> ) li . setProperty ( <str> , <str> ) url = <str> + l [ 0 ] xbmcplugin . addDirectoryItem ( handle = addon_handle , url = url , listitem = li , isFolder = True )  xbmcplugin . endOfDirectory ( addon_handle )  if action > dialog_action_case . settings or action < dialog_action_case . generate : 		 return True  return False  def next_item ( total_pages ) : 	 if not total_pages : 		 return False  from plugin import get_params params = get_params ( ) if params : 		 page = int ( params . get ( <str> , 1 ) ) if page < total_pages : 			 params [ <str> ] = page + 1 url = make_url ( params ) addon_handle = int ( sys . argv [ 1 ] ) li = xbmcgui . ListItem ( <str> ) xbmcplugin . addDirectoryItem ( handle = addon_handle , url = url , listitem = li , isFolder = True )  return page > 1  else : 		 return False   def show_list ( listing ) : 	 addon_handle = int ( sys . argv [ 1 ] ) xbmcplugin . setContent ( addon_handle , <str> ) for item in listing : 		 info = item . get_info ( ) li = xbmcgui . ListItem ( info [ <str> ] ) li . setInfo ( <str> , info ) li . setArt ( item . get_art ( ) ) url_search = make_url ( { <str> : <str> , <str> : info [ <str> ] . encode ( <str> ) , <str> : item . imdb ( ) } ) url_similar = make_url ( { <str> : <str> , <str> : item . type , <str> : item . tmdb_id ( ) } ) items = [ ( <str> , <str> % url_similar ) , ( <str> , <str> % ( url_search + <str> ) ) ] li . addContextMenuItems ( items ) xbmcplugin . addDirectoryItem ( handle = addon_handle , url = url_search , listitem = li )  updateListing = next_item ( listing . total_pages ) xbmcplugin . endOfDirectory ( addon_handle , updateListing = updateListing , cacheToDisc = True )  def force_library_update ( settings , params ) : 	 from plugin import UpdateVideoLibrary UpdateVideoLibrary ( path = <str> , wait = True )  menu_items = [ <str> , <str> , <str> , <str> , <str> , <str> ] menu_actions = [ <str> , <str> , <str> , <str> , <str> , <str> ] def main_menu ( menu_actions ) : 	 indx = 0 addon_handle = int ( sys . argv [ 1 ] ) for menu in menu_items : 		 li = xbmcgui . ListItem ( menu ) url = <str> + menu_actions [ indx ] xbmcplugin . addDirectoryItem ( handle = addon_handle , url = url , listitem = li , isFolder = indx > dialog_action_case . settings ) indx += 1  xbmcplugin . endOfDirectory ( addon_handle )  def action_add_media ( params , settings ) : 	 title = urllib . unquote_plus ( params . get ( <str> ) ) . decode ( <str> ) imdb = params . get ( <str> ) force = params . get ( <str> ) == <str> if getSetting ( <str> ) . decode ( <str> ) == <str> and params . get ( <str> ) : 		 force_library_update ( settings , params )  if force : 		 from service import add_media add_media ( title , imdb , settings ) return  found = None from jsonrpc_requests import VideoLibrary if imdb . startswith ( <str> ) and title : 		 result = VideoLibrary . GetTVShows ( properties = [ <str> , <str> , <str> , <str> , <str> ] ) try : 			 for r in result [ <str> ] : 				 if r [ <str> ] == title : 					 found = <str> break    except KeyError : 			 debug ( <str> )   if not found : 		 from complex_requests import get_movies_by_imdb result = get_movies_by_imdb ( imdb ) try : 			 if result : 				 if len ( result [ <str> ] ) > 0 : 					 r = result [ <str> ] [ 0 ] found = <str>    except KeyError : 			 debug ( <str> )   if not found : 		 result = VideoLibrary . GetTVShows ( properties = [ <str> , <str> , <str> , <str> , <str> ] ) try : 			 for r in result [ <str> ] : 				 if r [ <str> ] == imdb : 					 found = <str> break    except KeyError : 			 debug ( <str> )   dialog = xbmcgui . Dialog ( ) if found == <str> : 		 if dialog . yesno ( <str> , <str> ) : 			 xbmc . executebuiltin ( <str> % r [ <str> ] . encode ( <str> ) )   elif found == <str> : 		 if dialog . yesno ( <str> , <str> ) : 			 xbmc . executebuiltin ( <str> % r [ <str> ] . encode ( <str> ) )   elif not params . get ( <str> ) : 		 if dialog . yesno ( <str> , <str> ) : 			 from service import add_media add_media ( title , imdb , settings )    def action_show_similar ( params ) : 	 from movieapi import TMDB_API page = params . get ( <str> , 1 ) listing = TMDB_API . show_similar_t ( page , params . get ( <str> ) , params . get ( <str> ) ) debug ( listing ) show_list ( listing )  def action_show_category ( params ) : 	 page = params . get ( <str> , 1 ) import vsdbg from movieapi import TMDB_API if params . get ( <str> ) == <str> : 		 show_list ( TMDB_API . popular ( page ) )  if params . get ( <str> ) == <str> : 		 show_list ( TMDB_API . top_rated ( page ) )  if params . get ( <str> ) == <str> : 		 show_list ( TMDB_API . popular_tv ( page ) )  if params . get ( <str> ) == <str> : 		 show_list ( TMDB_API . top_rated_tv ( page ) )  if params . get ( <str> ) == <str> : 		 uri = <str> xbmc . executebuiltin ( <str> % uri )   def action_show_library ( params ) : 	 addon_handle = int ( sys . argv [ 1 ] ) def _get_cast ( castData ) : 		 listCast = [ ] listCastAndRole = [ ] for castmember in castData : 			 listCast . append ( castmember [ <str> ] ) listCastAndRole . append ( ( castmember [ <str> ] , castmember [ <str> ] ) )  return [ listCast , listCastAndRole ]  def _get_first_item ( item ) : 		 if len ( item ) > 0 : 			 item = item [ 0 ]  else : 			 item = <str>  return item  def _get_joined_items ( item ) : 		 if len ( item ) > 0 : 			 item = <str> . join ( item )  else : 			 item = <str>  return item  class query : 		 fields = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , ] content = <str> def method ( self ) : 			 return <str>  def skip ( self , item , type = <str> , imdbs = [ ] ) : 			 if item [ <str> ] and item [ <str> ] in imdbs : 				 return True  if item [ <str> ] : 				 imdbs . append ( item [ <str> ] )  if type == <str> and <str> in item [ <str> ] : 				 return True  if <str> in self . category : 				 return <str> not in item [ <str> ]  if <str> in self . category : 				 return <str> not in item [ <str> ]  if <str> in self . category : 				 return <str> not in item [ <str> ]  if <str> in self . category : 				 return <str> not in item [ <str> ]  if <str> in self . category : 				 if <str> not in item [ <str> ] : 					 return <str> not in item [ <str> ]   if <str> in self . category : 				 return <str> not in item [ <str> ]  return True  def full_listing ( self ) : 			 xbmcplugin . setContent ( addon_handle , self . content ) xbmcplugin . addSortMethod ( addon_handle , xbmcplugin . SORT_METHOD_NONE , <str> ) self . listing ( ) xbmcplugin . endOfDirectory ( addon_handle )  def listing ( self ) : 			 r = self . req ( ) if <str> not in r : 				 return  result = r [ <str> ] plot_enable = True isFolder = False ll = result . get ( <str> , [ ] ) if not ll : 				 ll = result . get ( <str> , [ ] )  if not ll : 				 ll = result . get ( <str> , [ ] ) if ll : 					 isFolder = True   imdbs = [ ] for movie in ll : 				 if self . skip ( movie ) : 					 continue  if <str> in movie : 					 cast = _get_cast ( movie [ <str> ] )  else : 					 cast = [ None , None ]  full_title = <str> . format ( movie [ <str> ] , movie [ <str> ] ) if movie [ <str> ] and self . content == <str> else movie [ <str> ] li = xbmcgui . ListItem ( full_title ) url = movie [ <str> ] li . setInfo ( type = <str> , infoLabels = { <str> : full_title , <str> : movie [ <str> ] , <str> : movie [ <str> ] , <str> : _get_joined_items ( movie . get ( <str> , <str> ) ) , <str> : _get_first_item ( movie . get ( <str> , <str> ) ) , <str> : _get_first_item ( movie . get ( <str> , <str> ) ) , <str> : movie [ <str> ] , <str> : movie . get ( <str> , <str> ) , <str> : movie . get ( <str> , <str> ) , <str> : str ( float ( movie [ <str> ] ) ) , <str> : movie [ <str> ] , <str> : movie [ <str> ] , <str> : _get_joined_items ( movie . get ( <str> , <str> ) ) , <str> : _get_joined_items ( movie . get ( <str> , <str> ) ) , <str> : cast [ 0 ] , <str> : cast [ 1 ] , <str> : <str> , <str> : movie . get ( <str> , <str> ) , <str> : movie [ <str> ] } ) if <str> in movie : 					 li . setProperty ( <str> , str ( movie [ <str> ] [ <str> ] ) ) li . setProperty ( <str> , str ( movie [ <str> ] [ <str> ] ) )  if <str> in movie : 					 li . setProperty ( <str> , str ( movie [ <str> ] ) )  li . setProperty ( <str> , str ( movie [ <str> ] ) ) li . setProperty ( <str> , movie [ <str> ] . get ( <str> , <str> ) ) li . setArt ( movie [ <str> ] ) li . setThumbnailImage ( movie [ <str> ] . get ( <str> , <str> ) ) li . setIconImage ( <str> ) xbmcplugin . addDirectoryItem ( handle = addon_handle , url = url , listitem = li , isFolder = isFolder )   def req ( self , sort = None , filter = None , limits = None ) : 			 _r = { <str> : <str> , <str> : self . method ( ) , <str> : { <str> : self . fields } , <str> : <str> } if sort : 				 _r [ <str> ] [ <str> ] = sort  if filter : 				 _r [ <str> ] [ <str> ] = filter  if limits : 				 _r [ <str> ] [ <str> ] = limits  import xbmc , json jsn = json . loads ( xbmc . executeJSONRPC ( json . dumps ( _r ) ) ) return jsn  def req_ldp ( self , type ) : 			 import xbmc , json cmd = <str> + type jsn = json . loads ( xbmc . executeJSONRPC ( json . dumps ( { <str> : <str> , <str> : <str> , <str> : { <str> : self . fields , <str> : cmd , <str> : <str> } , <str> : <str> } ) ) ) return jsn   class query_tv ( query ) : 		 def __init__ ( self ) : 			 self . fields = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , ] self . content = <str>  def method ( self ) : 			 return <str>  def listing ( self ) : 			 query . listing ( self )   class query_tv_ep ( query_tv ) : 		 def __init__ ( self ) : 			 self . fields = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] self . content = <str>  def method ( self ) : 			 return <str>  def req_ldp ( self , type ) : 			 import xbmc , json cmd = <str> + type props = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] jsn = json . loads ( xbmc . executeJSONRPC ( json . dumps ( { <str> : <str> , <str> : <str> , <str> : { <str> : props , <str> : cmd , <str> : <str> } , <str> : <str> } ) ) ) return jsn  def listing ( self ) : 			 xbmcplugin . addSortMethod ( addon_handle , xbmcplugin . SORT_METHOD_NONE , <str> ) result = self . req ( ) [ <str> ] plot_enable = True ll = result . get ( <str> , [ ] ) if not ll : 				 ll = result . get ( <str> , [ ] )  for episode in ll : 				 if self . skip ( episode , type = <str> ) : 					 continue  if <str> in episode : 					 cast = _get_cast ( episode [ <str> ] )  else : 					 cast = [ None , None ]  nEpisode = <str> % float ( episode [ <str> ] ) nSeason = <str> % float ( episode [ <str> ] ) fEpisode = <str> % ( nSeason , nEpisode ) full_title = <str> . format ( episode [ <str> ] , episode [ <str> ] , episode [ <str> ] , episode [ <str> ] ) li = xbmcgui . ListItem ( full_title ) url = episode [ <str> ] li . setInfo ( type = <str> , infoLabels = { <str> : full_title , <str> : episode [ <str> ] , <str> : episode [ <str> ] , <str> : _get_first_item ( episode . get ( <str> , <str> ) ) , <str> : episode [ <str> ] , <str> : episode [ <str> ] , <str> : episode [ <str> ] , <str> : str ( float ( episode [ <str> ] ) ) , <str> : episode [ <str> ] , <str> : episode [ <str> ] , <str> : _get_joined_items ( episode . get ( <str> , <str> ) ) , <str> : _get_joined_items ( episode . get ( <str> , <str> ) ) , <str> : cast [ 0 ] , <str> : cast [ 1 ] , <str> : <str> } ) li . setProperty ( <str> , fEpisode ) li . setProperty ( <str> , str ( episode [ <str> ] [ <str> ] ) ) li . setProperty ( <str> , str ( episode [ <str> ] [ <str> ] ) ) li . setProperty ( <str> , episode [ <str> ] . get ( <str> , <str> ) ) li . setArt ( episode [ <str> ] ) li . setThumbnailImage ( episode [ <str> ] . get ( <str> , <str> ) ) li . setIconImage ( <str> ) xbmcplugin . addDirectoryItem ( handle = addon_handle , url = url , listitem = li , isFolder = False )    class recentmovies ( query ) : 		 items = [ <str> , <str> , <str> ] def req ( self ) : 			 return self . req_ldp ( <str> )   class recenttvshows ( query_tv ) : 		 items = [ <str> , <str> , <str> ] def req ( self ) : 			 return query_tv . req ( self , sort = { <str> : <str> , <str> : <str> , <str> : True } , limits = { <str> : 0 , <str> : 250 } )   class recommendedmovies ( query ) : 		 items = [ <str> , <str> , <str> ] def req ( self ) : 			 return self . req_ldp ( <str> )   class recommendedepisodes ( query_tv_ep ) : 		 items = [ <str> , <str> , <str> ] def req ( self ) : 			 return self . req_ldp ( <str> )   class topmovies ( query ) : 		 items = [ <str> , <str> , <str> ] def req ( self ) : 			 return query . req ( self , sort = { <str> : <str> , <str> : <str> , <str> : True } , limits = { <str> : 0 , <str> : 250 } )   class toptvshows ( query_tv ) : 		 items = [ <str> , <str> , <str> ] def req ( self ) : 			 return query_tv . req ( self , sort = { <str> : <str> , <str> : <str> , <str> : True } , limits = { <str> : 0 , <str> : 250 } )   ldp_query = { <str> : recentmovies ( ) , <str> : recommendedmovies ( ) , <str> : recommendedepisodes ( ) , <str> : topmovies ( ) , <str> : toptvshows ( ) , <str> : recenttvshows ( ) } import vsdbg vsdbg . _bp ( ) for q , l in ldp_query . iteritems ( ) : 		 if params . get ( <str> ) in l . items : 			 l . category = params . get ( <str> ) l . full_listing ( )    def action_search_context ( params ) : 	 from movieapi import TMDB_API s = params . get ( <str> ) show_list ( TMDB_API . search ( s . decode ( <str> ) ) )  def action_anidub_add_favorites ( settings ) : 	 debug ( <str> ) anidub_enable = _addon . getSetting ( <str> ) == <str> if anidub_enable : 		 if settings . anime_save : 			 from anidub import write_favorites debug ( <str> ) write_favorites ( settings . anime_tvshow_path ( ) , settings )    def main ( ) : 	 from service import create_mark_file create_mark_file ( ) from dispatcher import dispatch dispatch ( )  if __name__ == <str> : 	 main ( )   