import log from log import debug , print_tb import json , re , base , filesystem import urllib2 , requests from bs4 import BeautifulSoup user_agent = <str> def copy_files ( src , dst , pattern ) : 	 from backgrounds import safe_copyfile for ext in [ <str> , <str> , <str> ] : 		 src_file = filesystem . join ( src , base . make_fullpath ( pattern , ext ) ) if filesystem . exists ( src_file ) : 			 dst_file = filesystem . join ( dst , base . make_fullpath ( pattern , ext ) ) safe_copyfile ( src_file , dst_file )    def make_imdb_path ( path , imdb ) : 	 if imdb and imdb . startswith ( <str> ) : 		 return filesystem . join ( path , <str> + imdb [ 3 : 5 ] , imdb )  return path  def write_movie ( fulltitle , link , settings , parser , path , skip_nfo_exists = False , download_torrent = True ) : 	 debug ( <str> ) filename = parser . make_filename ( ) if filename : 		 debug ( <str> + fulltitle . encode ( <str> ) ) debug ( <str> + filename . encode ( <str> ) ) debug ( <str> ) imdb = parser . get_value ( <str> ) new_path = make_imdb_path ( path , imdb ) if new_path != path : 			 copy_files ( path , new_path , filename )  with filesystem . save_make_chdir_context ( new_path , <str> ) : 			 from strmwriter import STRMWriter STRMWriter ( parser . link ( ) ) . write ( filename , new_path , parser = parser , settings = settings ) from nfowriter import NFOWriter NFOWriter ( parser , movie_api = parser . movie_api ( ) ) . write_movie ( filename , new_path , skip_nfo_exists = skip_nfo_exists ) if download_torrent : 				 from downloader import TorrentDownloader TorrentDownloader ( parser . link ( ) , settings . torrents_path ( ) , settings ) . download ( )  settings . update_paths . add ( new_path ) return filesystem . relpath ( filesystem . join ( new_path , base . make_fullpath ( filename , <str> ) ) , start = settings . base_path ( ) )    def get_tmdb_api_key ( ) : 	 key = <str> host = <str> import filesystem try : 		 import xbmc home_path = xbmc . translatePath ( <str> ) . decode ( <str> ) major = xbmc . getInfoLabel ( <str> ) . split ( <str> ) [ 0 ] if int ( major ) > 17 : 			 return { <str> : host , <str> : key }   except ImportError : 		 return { <str> : host , <str> : key }  try : 		 xml_path = filesystem . join ( home_path , <str> , <str> , <str> ) with filesystem . fopen ( xml_path , <str> ) as xml : 			 content = xml . read ( ) match = re . search ( <str> , content ) if match : 				 key = match . group ( 1 ) debug ( <str> )  m = re . search ( <str> , content ) if m : 				 host = m . group ( 1 )    except BaseException as e : 		 debug ( <str> + str ( e ) )  return { <str> : host , <str> : key }  def attr_text ( s ) : 	 return s . get_text ( )  def attr_split_slash ( s ) : 	 itms = s . get_text ( ) . split ( <str> ) return [ i . strip ( ) for i in itms ]  def attr_year ( s ) : 	 import re m = re . search ( <str> , s . get_text ( ) ) if m : 		 return m . group ( 1 )   def attr_genre ( s ) : 	 return [ a . get_text ( ) for a in s . find_all ( <str> ) ]  class IDs ( object ) : 	 kp_by_imdb = { } imdb_by_kp = { } @ staticmethod def id_by_kp_url ( url ) : 		 import re m = re . search ( <str> , url ) if m : 			 return m . group ( 1 )  return None  @ staticmethod def get_by_kp ( kp_url ) : 		 return IDs . imdb_by_kp . get ( IDs . id_by_kp_url ( kp_url ) )  @ staticmethod def get_by_imdb ( imdb_id ) : 		 return IDs . kp_by_imdb . get ( imdb_id )  @ staticmethod def set ( imdb_id , kp_url ) : 		 if imdb_id and kp_url : 			 kp_id = IDs . id_by_kp_url ( kp_url ) IDs . imdb_by_kp [ kp_id ] = imdb_id IDs . kp_by_imdb [ imdb_id ] = kp_id   @ staticmethod def has_imdb ( imdb_id ) : 		 return imdb_id in IDs . kp_by_imdb  @ staticmethod def has_kp ( kp_url ) : 		 kp_id = IDs . id_by_kp_url ( kp_url ) return kp_id in IDs . imdb_by_kp   from soup_base import soup_base class world_art_soup ( soup_base ) : 	 headers = { <str> : <str> , <str> : <str> , <str> : user_agent , <str> : <str> , } def __init__ ( self , url ) : 		 soup_base . __init__ ( self , url , self . headers )   class world_art_actors ( world_art_soup ) : 	 def __init__ ( self , url ) : 		 world_art_soup . __init__ ( self , url ) self . _actors = [ ]  @ property def actors ( self ) : 		 if not self . _actors : 			 def append_actor ( tr ) : 				 tds = tr . find_all ( <str> , recursive = False ) a = tds [ 1 ] . find ( <str> ) act = { } if a : 					 id = a [ <str> ] . split ( <str> ) [ - 1 ] id = id . split ( <str> ) [ 0 ] act [ <str> ] = tds [ 1 ] . get_text ( ) act [ <str> ] = tds [ 2 ] . get_text ( ) act [ <str> ] = tds [ 3 ] . get_text ( ) res = { } for k , v in act . iteritems ( ) : 						 if v : 							 res [ k ] = v   self . _actors . append ( res )   for b in self . soup . find_all ( <str> ) : 				 if b . get_text ( ) == <str> : 					 table = b . find_parent ( <str> ) table = table . find_next_siblings ( <str> ) [ 1 ] for tr_next in table . find_all ( <str> ) : 						 append_actor ( tr_next )     return self . _actors  def __getitem__ ( self , i ) : 		 if isinstance ( i , int ) : 			 return self . actors [ i ]  elif isinstance ( i , str ) or isinstance ( i , unicode ) : 			 for act in self . actors : 				 if act [ <str> ] == i : 					 return act  if act [ <str> ] == i : 					 return act    raise KeyError   class world_art_info ( world_art_soup ) : 	 Request_URL = <str> attrs = [ ( <str> , <str> , attr_split_slash ) , ( <str> , <str> , attr_text ) , ( <str> , <str> , attr_text ) , ( <str> , <str> , attr_genre ) , ( <str> , <str> , attr_year ) , ( <str> , <str> , attr_text ) , ] def __init__ ( self , url ) : 		 world_art_soup . __init__ ( self , self . Request_URL % url ) self . _info_data = dict ( ) self . _actors = None  @ property def actors ( self ) : 		 if not self . _actors : 			 self . _actors = world_art_actors ( self . url . replace ( <str> , <str> ) )  return self . _actors . actors  @ property def data ( self ) : 		 def next_td ( td , fn ) : 			 return fn ( td . next_sibling . next_sibling )  if not self . _info_data : 			 data = { } for td in self . soup . find_all ( <str> , class_ = <str> ) : 				 td_text = td . get_text ( ) find = [ item for item in self . attrs if td_text in item ] if find : 					 item = find [ 0 ] data [ item [ 1 ] ] = next_td ( td , item [ 2 ] )   self . _info_data = data . copy ( )  return self . _info_data  def __getattr__ ( self , name ) : 		 names = [ i [ 1 ] for i in self . attrs ] if name in names : 			 return self . data [ name ]  raise AttributeError  @ property def imdb ( self ) : 		 a = self . soup . select ( <str> ) if a : 			 for part in a [ 0 ] [ <str> ] . split ( <str> ) : 				 if part . startswith ( <str> ) : 					 return part     @ property def kp_url ( self ) : 		 a = self . soup . select ( <str> ) return a [ 0 ] [ <str> ]  @ property def plot ( self ) : 		 p = self . soup . find ( <str> , attrs = { <str> : <str> , <str> : <str> } ) if p : 			 return p . get_text ( )    class world_art ( world_art_soup ) : 	 Request_URL = <str> def __init__ ( self , title , year = None , imdbid = None , kp_url = None ) : 		 import urllib url = self . Request_URL % urllib . quote_plus ( title . encode ( <str> ) ) world_art_soup . __init__ ( self , url ) self . _title = title self . _year = year self . _imdbid = imdbid self . _kp_url = kp_url self . _info = None  @ property def info ( self ) : 		 if not self . _info : 			 results = self . search_by_title ( self . _title ) if self . _year : 				 results = [ item for item in results if item . year == self . _year ]  if self . _imdbid : 				 results = [ item for item in results if item . imdb == self . _imdbid ] if results : 					 self . _info = results [ 0 ] return self . _info   if self . _kp_url : 				 results = [ item for item in results if IDs . id_by_kp_url ( item . kp_url ) == IDs . id_by_kp_url ( self . _kp_url ) ] if results : 					 self . _info = results [ 0 ] return self . _info   for item in results : 				 if self . _title in item . knowns : 					 self . _info = item return self . _info   self . _info = <str>  if self . _info == <str> : 			 raise AttributeError  return self . _info  def search_by_title ( self , title ) : 		 result = [ ] for meta in self . soup . find_all ( <str> ) : 			 if meta . get ( <str> ) == <str> and <str> in meta . get ( <str> ) : 				 url = meta . get ( <str> ) . split ( <str> ) [ - 1 ] info = world_art_info ( url ) info . year = self . _year result . append ( info )   for a in self . soup . find_all ( <str> , class_ = <str> ) : 			 info = world_art_info ( a [ <str> ] ) tr = a while tr . name != <str> : 				 tr = tr . parent  info . year = tr . find ( <str> ) . get_text ( ) td = a . parent info . knowns = [ i . get_text ( ) for i in td . find_all ( <str> ) ] result . append ( info )  return result  def plot ( self ) : 		 return self . info . plot  def director ( self ) : 		 try : 			 result = self . info . director result = result . replace ( <str> , <str> ) return [ d . strip ( ) for d in result . split ( <str> ) ]  except : 			 return [ ]   def actors ( self ) : 		 try : 			 return self . info . actors  except : 			 return [ ]    class tmdb_movie_item ( object ) : 	 def __init__ ( self , json_data , type = <str> ) : 		 self . json_data_ = json_data self . type = type  def poster ( self ) : 		 try : 			 return <str> + self . json_data_ [ <str> ]  except BaseException : 			 return <str>   def fanart ( self ) : 		 try : 			 return <str> + self . json_data_ [ <str> ]  except BaseException : 			 return <str>   def get_art ( self ) : 		 art = { } path = self . poster ( ) art [ <str> ] = path art [ <str> ] = path art [ <str> ] = path art [ <str> ] = self . fanart ( ) return art  def get_info ( self ) : 		 info = { } if <str> in self . json_data_ : 			 info [ <str> ] = <str> . join ( [ i [ <str> ] for i in self . json_data_ [ <str> ] ] )  analogy = { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , } for tag in analogy : 			 if analogy [ tag ] in self . json_data_ : 				 info [ tag ] = self . json_data_ [ analogy [ tag ] ]   if <str> in info : 			 aired = info [ <str> ] m = re . search ( <str> , aired ) if m : 				 info [ <str> ] = int ( m . group ( 1 ) )   try : 			 vid_item = self . json_data_ [ <str> ] [ <str> ] [ 0 ] if vid_item [ <str> ] == <str> : 				 info [ <str> ] = <str> + vid_item [ <str> ]   except BaseException : 			 pass  string_items = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] for item in string_items : 			 if item in self . json_data_ : 				 info [ item ] = self . json_data_ [ item ]   return info  def imdb ( self ) : 		 try : 			 if <str> in self . json_data_ : 				 return self . json_data_ [ <str> ]  elif <str> in self . json_data_ and <str> in self . json_data_ [ <str> ] : 				 return self . json_data_ [ <str> ] [ <str> ]   except BaseException : 			 return None   def tmdb_id ( self ) : 		 if <str> in self . json_data_ : 			 return self . json_data_ [ <str> ]  else : 			 return None    class Object ( object ) :      pass  class KinopoiskAPI ( object ) : 	 session = None kp_requests = [ ] @ staticmethod def make_url_by_id ( kp_id ) : 		 return <str> + str ( kp_id ) + <str>  def __init__ ( self , kinopoisk_url = None , settings = None ) : 		 from settings import Settings self . settings = settings if settings else Settings ( <str> ) self . kinopoisk_url = kinopoisk_url self . soup = None self . _actors = None  def _http_get ( self , url ) : 		 for resp in KinopoiskAPI . kp_requests : 			 if resp [ <str> ] == url : 				 return resp [ <str> ]   r = requests . Response ( ) if self . session is None : 			 self . session = requests . session ( )  try : 			 if self . settings . kp_googlecache : 				 r = self . get_google_cache ( url )  else : 				 proxy = <str> proxies = { <str> : proxy , <str> : proxy } if self . settings . kp_usezaborona else None headers = { <str> : user_agent } r = self . session . get ( url , headers = headers , proxies = proxies , timeout = 5.0 )   except requests . exceptions . ConnectionError as ce : 			 r = requests . Response ( ) r . status_code = requests . codes . service_unavailable debug ( str ( ce ) )  except requests . exceptions . Timeout as te : 			 r = requests . Response ( ) r . status_code = requests . codes . request_timeout debug ( str ( te ) )  if not self . settings . kp_googlecache : 			 if <str> in r . text : 				 r = self . get_google_cache ( url )   KinopoiskAPI . kp_requests . append ( { <str> : url , <str> : r } ) return r  def get_google_cache ( self , url ) : 		 import urllib search_url = <str> + urllib . quote_plus ( url ) headers = { <str> : user_agent } r = self . session . get ( search_url , headers = headers , timeout = 2.0 ) try : 			 soup = BeautifulSoup ( base . clean_html ( r . text ) , <str> ) a = soup . find ( <str> , class_ = <str> ) if a : 				 cache_url = a [ <str> ] import urlparse res = urlparse . urlparse ( cache_url ) res = urlparse . ParseResult ( res . scheme if res . scheme else <str> , res . netloc if res . netloc else <str> , res . path , res . params , res . query , res . fragment ) cache_url = urlparse . urlunparse ( res ) r = self . session . get ( cache_url , headers = headers , timeout = 2.0 ) indx = r . text . find ( <str> ) resp = Object ( ) resp . status_code = r . status_code resp . text = r . text [ indx : ] return resp   except BaseException as e : 			 debug ( str ( e ) )  return requests . Response ( )  def makeSoup ( self ) : 		 if self . kinopoisk_url and self . soup is None : 			 r = self . _http_get ( self . kinopoisk_url ) if r . status_code == requests . codes . ok : 				 text = base . clean_html ( r . content ) self . soup = BeautifulSoup ( text , <str> )  else : 				 pass    def title ( self ) : 		 title = None self . makeSoup ( ) if self . soup : 			 s = self . soup . find ( <str> , class_ = <str> ) if s : 				 title = s . get_text ( ) . strip ( <str> )   return title  def originaltitle ( self ) : 		 title = None self . makeSoup ( ) if self . soup : 			 span = self . soup . find ( <str> , attrs = { <str> : <str> } ) if span : 				 title = span . get_text ( ) . strip ( <str> )   return title  def year ( self ) : 		 self . makeSoup ( ) if self . soup : 			 for a in self . soup . find_all ( <str> ) : 				 if <str> in a . get ( <str> , <str> ) : 					 return a . get_text ( )    raise AttributeError  def director ( self ) : 		 self . makeSoup ( ) if self . soup : 			 td = self . soup . find ( <str> , attrs = { <str> : <str> } ) if td : 				 return [ a . get_text ( ) for a in td . find_all ( <str> ) if <str> in a [ <str> ] ]   raise AttributeError  def plot ( self ) : 		 plot = None self . makeSoup ( ) if self . soup : 			 div = self . soup . find ( <str> , attrs = { <str> : <str> } ) if div : 				 plot = div . get_text ( ) . replace ( <str> , <str> ) return plot   raise AttributeError  def base_actors_list ( self ) : 		 actors = [ ] self . makeSoup ( ) if self . soup : 			 for li in self . soup . find_all ( <str> , attrs = { <str> : <str> } ) : 				 a = li . find ( <str> ) if a : 					 actors . append ( a . get_text ( ) )    if <str> in actors : 			 actors . remove ( <str> )  if actors : 			 return <str> . join ( actors )  else : 			 return <str>   def actors ( self ) : 		 if self . _actors is not None : 			 return self . _actors  self . _actors = [ ] if self . kinopoisk_url : 			 cast_url = self . kinopoisk_url + <str> r = self . _http_get ( cast_url ) if r . status_code == requests . codes . ok : 				 text = base . clean_html ( r . text ) soup = BeautifulSoup ( text , <str> ) if not soup : 					 return [ ]  for actorInfo in soup . find_all ( <str> , class_ = <str> ) : 					 photo = actorInfo . select ( <str> ) [ 0 ] [ <str> ] photo = photo . replace ( <str> , <str> ) . replace ( <str> , <str> ) photo = <str> + photo + <str> ru_name = actorInfo . select ( <str> ) [ 0 ] . get_text ( ) en_name = actorInfo . select ( <str> ) [ 0 ] . get_text ( ) role = actorInfo . select ( <str> ) [ 0 ] . get_text ( ) . replace ( <str> , <str> ) role = role . split ( <str> ) [ 0 ] self . _actors . append ( { <str> : photo , <str> : ru_name , <str> : en_name , <str> : role } )    return self . _actors  def __trailer ( self , element ) : 		 for parent in element . parents : 			 if parent . name == <str> : 				 for tr in parent . next_siblings : 					 if not hasattr ( tr , <str> ) : 						 continue  if tr . name != <str> : 						 continue  for a_cont in tr . select ( <str> ) : 						 if <str> in a_cont . get_text ( ) : 							 trailer = a_cont [ <str> ] trailer = re . search ( <str> , trailer ) . group ( 1 ) try : 								 debug ( <str> + trailer )  except : 								 pass  return trailer      return None  def trailer ( self ) : 		 if self . kinopoisk_url : 			 trailer_page = self . kinopoisk_url + <str> r = self . _http_get ( trailer_page ) if r . status_code == requests . codes . ok : 				 text = base . clean_html ( r . text ) soup = BeautifulSoup ( text , <str> ) if not soup : 					 return None  for div in soup . select ( <str> ) : 					 trailer = self . __trailer ( div ) if trailer : 						 return trailer   for a in soup . select ( <str> ) : 					 return self . __trailer ( a )    return None  def poster ( self ) : 		 raise AttributeError   class imdb_cast ( soup_base ) : 	 def __init__ ( self , url ) : 		 soup_base ( self , url + <str> ) self . _actors = [ ]  @ property def actors ( self ) : 		 if not self . _actors : 			 tbl = self . soup . find ( <str> , class_ = <str> ) if tbl : 				 for tr in tbl . find ( <str> ) : 					 if <str> in tr : 						 act = { }       class ImdbAPI ( object ) : 	 def __init__ ( self , imdb_id ) : 		 headers = { <str> : <str> } resp = requests . get ( <str> + imdb_id + <str> , headers = headers ) if resp . status_code == requests . codes . ok : 			 text = base . clean_html ( resp . content ) self . page = BeautifulSoup ( text , <str> )   def year ( self ) : 		 a = self . page . select_one ( <str> ) if a : 			 return a . get_text ( )  else : 			 raise AttributeError   def rating ( self ) : 		 span = self . page . find ( <str> , attrs = { <str> : <str> } ) if span : 			 return span . get_text ( ) . replace ( <str> , <str> )  else : 			 raise AttributeError   def runtime ( self ) : 		 t = self . page . find ( <str> , attrs = { <str> : <str> } ) if t : 			 return t [ <str> ] . replace ( <str> , <str> ) . replace ( <str> , <str> )  else : 			 raise AttributeError   def mpaa ( self ) : 		 rt = self . page . find ( <str> , attrs = { <str> : <str> } ) if rt : 			 return <str> + rt [ <str> ]  else : 			 raise AttributeError   def title ( self ) : 		 h1 = self . page . find ( <str> , attrs = { <str> : <str> } ) if h1 : 			 return unicode ( h1 . contents [ 0 ] ) . replace ( <str> , <str> ) . strip ( )  else : 			 raise AttributeError   def originaltitle ( self ) : 		 import re meta = self . page . find ( <str> , attrs = { <str> : <str> } ) if meta : 			 otitle = meta [ <str> ] otitle = re . sub ( <str> , <str> , otitle ) otitle = otitle . split ( <str> ) [ 0 ] return otitle . strip ( )  raise AttributeError  def type ( self ) : 		 for div in self . page . find_all ( <str> , class_ = <str> ) : 			 if div . get_text ( ) == <str> : 				 return <str>   return <str>   class KinopoiskAPI2 ( KinopoiskAPI ) : 	 movie_cc = { } token = <str> def __init__ ( self , kinopoisk_url = None , settings = None ) : 		 if kinopoisk_url : 			 self . kp_id = IDs . id_by_kp_url ( kinopoisk_url ) return super ( KinopoiskAPI2 , self ) . __init__ ( kinopoisk_url , settings )  else : 			 self . kp_id = None   @ property def data_cc ( self ) : 		 if self . kp_id is None : 			 return { }  if self . kp_id in self . movie_cc : 			 return self . movie_cc [ self . kp_id ]  url = <str> % ( self . kp_id , self . token ) r = requests . get ( url ) if r . status_code == requests . codes . ok : 			 self . movie_cc [ self . kp_id ] = r . json ( ) return self . movie_cc [ self . kp_id ]  return { }  def title ( self ) : 		 return self . data_cc . get ( <str> )  def originaltitle ( self ) : 		 return self . data_cc . get ( <str> )  def year ( self ) : 		 return self . data_cc . get ( <str> )  def plot ( self ) : 		 return self . data_cc . get ( <str> )  def actors ( self ) : 		 if self . _actors is not None : 			 return self . _actors  self . _actors = [ ] creators = self . data_cc . get ( <str> ) if creators : 			 for actor in creators . get ( <str> , [ ] ) : 				 self . _actors . append ( { <str> : actor . get ( <str> ) , <str> : actor . get ( <str> ) , <str> : actor . get ( <str> ) } )   return self . _actors  def trailer ( self ) : 		 return self . data_cc . get ( <str> )  def poster ( self ) : 		 return <str> . format ( self . kp_id )   class TMDB_API ( object ) : 	 api_url = <str> tmdb_api_key = get_tmdb_api_key ( ) @ staticmethod def url_imdb_id ( idmb_id ) : 		 url = <str> % ( TMDB_API . tmdb_api_key [ <str> ] , idmb_id , TMDB_API . tmdb_api_key [ <str> ] ) tmdb_data = json . load ( urllib2 . urlopen ( url ) ) for type in [ <str> , <str> ] : 			 try : 				 id = tmdb_data [ <str> % type ] [ 0 ] [ <str> ] return <str> % TMDB_API . tmdb_api_key [ <str> ] + type + <str> + str ( id ) + <str> + TMDB_API . tmdb_api_key [ <str> ] + <str>  except : pass  return None  @ staticmethod def search ( title ) : 		 url = <str> % TMDB_API . tmdb_api_key [ <str> ] + urllib2 . quote ( title . encode ( <str> ) ) + <str> + TMDB_API . tmdb_api_key [ <str> ] + <str> movies = TMDB_API . tmdb_query ( url ) url = <str> % TMDB_API . tmdb_api_key [ <str> ] + urllib2 . quote ( title . encode ( <str> ) ) + <str> + TMDB_API . tmdb_api_key [ <str> ] + <str> tv = TMDB_API . tmdb_query ( url , <str> ) return movies + tv  @ staticmethod def tmdb_query ( url , type = <str> ) : 		 class tmdb_query_result ( object ) : 			 def __init__ ( self ) : 				 self . result = [ ] self . total_pages = None  def append ( self , item ) : 				 self . result . append ( item )  def __iter__ ( self ) : 				 for x in self . result : 					 yield x   def __add__ ( self , other ) : 				 r = tmdb_query_result ( ) r . result = self . result + other . result return r  def __len__ ( self ) : 				 return len ( self . result )  def __getitem__ ( self , index ) : 				 return self . result [ index ]   result = tmdb_query_result ( ) try : 			 debug ( <str> + url ) data = json . load ( urllib2 . urlopen ( url ) ) debug ( <str> + unicode ( data ) )  except urllib2 . HTTPError as e : 			 debug ( <str> ) debug ( e ) return tmdb_query_result ( )  if <str> in data : 			 result . total_pages = data [ <str> ]  for tag in [ <str> , <str> , <str> ] : 			 if tag in data : 				 for r in data [ tag ] : 					 if not r [ <str> ] : 						 continue  if <str> in tag : 						 type = tag . replace ( <str> , <str> )  url2 = <str> % TMDB_API . tmdb_api_key [ <str> ] + type + <str> + str ( r [ <str> ] ) + <str> + TMDB_API . tmdb_api_key [ <str> ] + <str> data2 = json . load ( urllib2 . urlopen ( url2 ) ) if <str> in data2 : 						 result . append ( tmdb_movie_item ( data2 , type ) )  elif <str> in data2 and <str> in data2 [ <str> ] : 						 result . append ( tmdb_movie_item ( data2 , type ) )     return result  @ staticmethod def tmdb_by_imdb ( imdb , type ) : 		 url = <str> % TMDB_API . tmdb_api_key [ <str> ] + imdb + <str> + TMDB_API . tmdb_api_key [ <str> ] + <str> url += <str> debug ( url ) return TMDB_API . tmdb_query ( url , type )  @ staticmethod def popular ( page = 1 ) : 		 url = <str> % TMDB_API . tmdb_api_key [ <str> ] + TMDB_API . tmdb_api_key [ <str> ] + <str> url += <str> . format ( page ) return TMDB_API . tmdb_query ( url )  @ staticmethod def popular_tv ( page = 1 ) : 		 url = <str> % TMDB_API . tmdb_api_key [ <str> ] + TMDB_API . tmdb_api_key [ <str> ] + <str> url += <str> . format ( page ) return TMDB_API . tmdb_query ( url , <str> )  @ staticmethod def top_rated ( page = 1 ) : 		 url = <str> % TMDB_API . tmdb_api_key [ <str> ] + TMDB_API . tmdb_api_key [ <str> ] + <str> url += <str> . format ( page ) return TMDB_API . tmdb_query ( url )  @ staticmethod def top_rated_tv ( page = 1 ) : 		 url = <str> % TMDB_API . tmdb_api_key [ <str> ] + TMDB_API . tmdb_api_key [ <str> ] + <str> url += <str> . format ( page ) return TMDB_API . tmdb_query ( url , <str> )  @ staticmethod def show_similar_t ( page , tmdb_id , type ) : 		 url = <str> % TMDB_API . tmdb_api_key [ <str> ] + type + <str> + str ( tmdb_id ) + <str> + TMDB_API . tmdb_api_key [ <str> ] + <str> url += <str> . format ( page ) log . debug ( url ) return TMDB_API . tmdb_query ( url , type )  @ staticmethod def show_similar ( tmdb_id ) : 		 return TMDB_API . show_similar_t ( 1 , tmdb_id , <str> ) + TMDB_API . show_similar_t ( 1 , tmdb_id , <str> )  @ staticmethod def imdb_by_tmdb_search ( orig , year ) : 		 try : 			 for res in TMDB_API . search ( orig ) : 				 r = res . json_data_ release_date = r . get ( <str> ) if year and release_date and year not in release_date : 					 continue  r_title = r . get ( <str> ) r_original_title = r . get ( <str> ) if orig and ( orig == r_title or orig == r_original_title ) : 					 return r [ <str> ]    except BaseException as e : 			 from log import print_tb print_tb ( e )  return None  def __init__ ( self , imdb_id = None ) : 		 if imdb_id : 			 url_ = TMDB_API . url_imdb_id ( imdb_id ) try : 				 if url_ : 					 self . tmdb_data = json . load ( urllib2 . urlopen ( url_ ) ) debug ( <str> + url_ + <str> )  else : 					 self . tmdb_data = None   except : 				 self . tmdb_data = None    def title ( self ) : 		 try : 			 if <str> in self . tmdb_data : 				 return self . tmdb_data [ <str> ]  if <str> in self . tmdb_data : 				 return self . tmdb_data [ <str> ]   except : 			 pass  raise AttributeError  def originaltitle ( self ) : 		 try : 			 if <str> in self . tmdb_data : 				 return self . tmdb_data [ <str> ]  if <str> in self . tmdb_data : 				 return self . tmdb_data [ <str> ]   except : 			 pass  raise AttributeError  def year ( self ) : 		 try : 			 return self . tmdb_data [ <str> ] . split ( <str> ) [ 0 ]  except : 			 raise AttributeError   def poster ( self ) : 		 return <str> + self . tmdb_data [ <str> ]  def fanart ( self ) : 		 return <str> + self . tmdb_data [ <str> ]  def set ( self ) : 		 try : 			 if <str> in self . tmdb_data : 				 belongs_to_collection = self . tmdb_data [ <str> ] if belongs_to_collection and <str> in belongs_to_collection : 					 return belongs_to_collection [ <str> ]    except : 			 pass  raise AttributeError  def runtime ( self ) : 		 return self . tmdb_data [ <str> ]  def tag ( self ) : 		 return self . tmdb_data [ <str> ]  def plot ( self ) : 		 return self . tmdb_data [ <str> ]  def actors ( self ) : 		 try : 			 cast = self . tmdb_data [ <str> ] [ <str> ]  except AttributeError : 			 return [ ]  result = [ ] for actor in cast : 			 res = { } res [ <str> ] = actor [ <str> ] if actor . get ( <str> ) : 				 res [ <str> ] = <str> + actor [ <str> ]  if actor . get ( <str> ) : 				 res [ <str> ] = actor [ <str> ]  if actor . get ( <str> ) : 				 res [ <str> ] = actor [ <str> ]  result . append ( res )  return result  def genres ( self ) : 		 ll = [ g [ <str> ] for g in self . tmdb_data [ <str> ] ] return ll  def countries ( self ) : 		 from countries import ru cc = [ c [ <str> ] for c in self . tmdb_data [ <str> ] ] return [ ru ( c ) for c in cc ]  def studios ( self ) : 		 ss = [ s [ <str> ] for s in self . tmdb_data [ <str> ] ] return ss   class MovieAPI ( object ) : 	 APIs = { } @ staticmethod def get_by ( imdb_id = None , kinopoisk_url = None , orig = None , year = None , imdbRaiting = None , settings = None ) : 		 if not imdb_id : 			 imdb_id = IDs . get_by_kp ( kinopoisk_url ) if kinopoisk_url else None  if not imdb_id : 			 try : 				 _orig = orig _year = year if kinopoisk_url : 					 kp = KinopoiskAPI ( kinopoisk_url , settings ) orig = kp . originaltitle ( ) if not orig : 						 orig = kp . title ( )  year = kp . year ( ) imdb_id = TMDB_API . imdb_by_tmdb_search ( orig if orig else _orig , year if year else _year )   except BaseException as e : 				 from log import print_tb print_tb ( e )   if imdb_id and kinopoisk_url : 			 IDs . set ( imdb_id , kinopoisk_url )  if imdb_id and imdb_id in MovieAPI . APIs : 			 return MovieAPI . APIs [ imdb_id ] , imdb_id  elif kinopoisk_url and kinopoisk_url in MovieAPI . APIs : 			 return MovieAPI . APIs [ kinopoisk_url ] , imdb_id  api = MovieAPI ( imdb_id , kinopoisk_url , settings , orig , year ) if imdb_id : 			 MovieAPI . APIs [ imdb_id ] = api  elif kinopoisk_url : 			 MovieAPI . APIs [ kinopoisk_url ] = api  return api , imdb_id  def __init__ ( self , imdb_id = None , kinopoisk = None , settings = None , orig = None , year = None ) : 		 self . providers = [ ] self . tmdbapi = None self . imdbapi = None self . kinopoiskapi = None self . worldartapi = None self . _actors = None if imdb_id : 			 self . tmdbapi = TMDB_API ( imdb_id ) self . imdbapi = ImdbAPI ( imdb_id ) self . providers = [ self . tmdbapi , self . imdbapi ] if not self . tmdbapi . tmdb_data : 				 self . providers . remove ( self . tmdbapi )   if kinopoisk : 			 if not settings or settings . use_kinopoisk : 				 self . kinopoiskapi = KinopoiskAPI ( kinopoisk , settings ) self . providers . append ( self . kinopoiskapi )   if imdb_id or kinopoisk : 			 if not settings or settings . use_worldart : 				 if not orig : 					 for api in self . providers : 						 try : 							 orig = api . originaltitle ( ) break  except : 							 pass    try : 					 self . worldartapi = world_art ( orig , imdbid = imdb_id , kp_url = kinopoisk ) self . providers . append ( self . worldartapi )  except : 					 pass     def actors ( self ) : 		 if self . _actors is not None : 			 return self . _actors  actors = [ ] for api in [ self . kinopoiskapi , self . tmdbapi , self . worldartapi ] : 			 if api : 				 a = api . actors ( ) if a : 					 actors . append ( a )    if len ( actors ) > 0 : 			 self . _actors = [ actor . copy ( ) for actor in actors [ 0 ] ]  else : 			 self . _actors = [ ]  for act in self . _actors : 			 for variant in actors [ 1 : ] : 				 for add in variant : 					 try : 						 if act [ <str> ] == add [ <str> ] : 							 act . update ( add )   except KeyError : 						 pass     return self . _actors  def __getitem__ ( self , key ) : 		 for api in self . providers : 			 try : 				 res = api . __getattribute__ ( key ) if res : 					 return res ( )   except BaseException as e : 				 continue   raise AttributeError  def get ( self , key , default = None ) : 		 try : 			 return self . __getitem__ ( key )  except AttributeError : 			 return default   def __getattr__ ( self , name ) : 		 if name . startswith ( <str> ) or name in self . __dict__ : 			 return object . __getattribute__ ( self , name )  for api in self . providers : 			 try : 				 res = api . __getattribute__ ( name ) if res : 					 return res   except AttributeError : 				 continue   raise AttributeError  def ru ( self , name ) : 		 def ru_text ( text ) : 			 if not text : 				 return False  r = 0 nr = 0 for ch in text : 				 if ch >= <str> and ch <= <str> : 					 r += 1  elif ch >= <str> and ch <= <str> : 					 r += 1  else : 					 nr += 1   return r > nr  def ru_list ( ll ) : 			 for l in ll : 				 if ru_text ( l ) : 					 return True   return False  for api in self . providers : 			 try : 				 res = api . __getattribute__ ( name ) if res and callable ( res ) : 					 value = res ( ) if isinstance ( value , list ) : 						 if ru_list ( value ) : 							 return value   else : 						 if ru_text ( value ) : 							 return value     except AttributeError : 				 continue   raise AttributeError   if __name__ == <str> : 	 from settings import Settings settings = Settings ( <str> ) settings . kp_usezaborona = True api = KinopoiskAPI ( <str> , settings ) title = api . title ( ) api = world_art ( <str> , year = <str> , kp_url = <str> ) info = api . info knowns = info . knowns plot = info . plot actors = [ act for act in info . actors ] pass   