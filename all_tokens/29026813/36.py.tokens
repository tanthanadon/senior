import log from log import debug import sys , xbmc , re , xbmcgui import pyxbmct . addonwindow as pyxbmct import filesystem from base import STRMWriterBase , seeds_peers seeds_peers_fmt = <str> def colorify ( text , sub , color ) : 	 return text . replace ( str ( sub ) , <str> . format ( color , sub ) )  def boldify ( text , sub ) : 	 return text . replace ( str ( sub ) , <str> . format ( sub ) )  class MyWindow ( pyxbmct . AddonDialogWindow ) : 	 def fill_list ( self ) : 		 for item in self . make_links ( ) : 			 s = <str> if item . get ( <str> , 1 ) >= 1 else <str> try : 				 link = item [ <str> ] s += <str> if <str> in link : 					 s += <str>  elif <str> in link : 					 s += <str>  elif <str> in link : 					 s += <str>  elif <str> in link : 					 s += <str>  elif <str> in link : 					 s += <str>  elif <str> in link : 					 s += <str>  elif <str> in link : 					 s += <str>  s += <str>  except : 				 pass  try : 				 s += item [ <str> ]  except : 				 pass  try : 				 s += <str> + <str> + item [ <str> ]  except : 				 pass  try : 				 s += <str> + <str> + item [ <str> ]  except : 				 pass  try : 				 s += <str> + seeds_peers_fmt % ( item [ <str> ] , item [ <str> ] )  except BaseException as e : 				 pass  if s != <str> : 				 for sub in [ 1920 , 1080 , 1280 , 720 , 3840 , 2160 , 540 , 480 , 360 ] : 					 s = colorify ( s , sub , <str> ) s = boldify ( s , sub )  li = xbmcgui . ListItem ( s ) li . setProperty ( <str> , link ) self . list . addItem ( li )    def __init__ ( self , title , settings , links ) : 		 super ( MyWindow , self ) . __init__ ( title ) self . setGeometry ( 1280 , 720 , 1 , 1 ) self . settings = settings self . files = None self . left_menu = None self . list = pyxbmct . List ( <str> , _itemHeight = 120 ) self . placeControl ( self . list , 0 , 0 ) self . make_links = links self . fill_list ( ) links . set_reload ( self . reload ) kodi_ver_major = int ( xbmc . getInfoLabel ( <str> ) . split ( <str> ) [ 0 ] ) if kodi_ver_major < 16 : 			 li = xbmcgui . ListItem ( <str> ) li . setProperty ( <str> , <str> ) self . list . addItem ( li ) li = xbmcgui . ListItem ( <str> ) li . setProperty ( <str> , <str> ) self . list . addItem ( li ) li = xbmcgui . ListItem ( <str> ) li . setProperty ( <str> , <str> ) self . list . addItem ( li ) pathUnited = <str> pathUnited = xbmc . translatePath ( pathUnited ) if filesystem . exists ( pathUnited . decode ( <str> ) ) : 				 li = xbmcgui . ListItem ( <str> ) li . setProperty ( <str> , <str> ) self . list . addItem ( li )   self . setFocus ( self . list ) self . connect ( self . list , self . make_choice ) self . connect ( pyxbmct . ACTION_MOVE_RIGHT , self . go_right ) self . connect ( pyxbmct . ACTION_MOVE_LEFT , self . go_left ) self . connect ( pyxbmct . ACTION_NAV_BACK , self . close ) self . has_choice = False self . has_select_file = False  def reload ( self , item ) : 		 def find_listitem ( item ) : 			 for index in xrange ( self . list . size ( ) ) : 				 li = self . list . getListItem ( index ) if li . getProperty ( <str> ) == item [ <str> ] : 					 return li   return None  if <str> in item and <str> in item : 			 li = find_listitem ( item ) if li : 				 s = li . getLabel ( ) if not isinstance ( s , unicode ) : 					 s = s . decode ( <str> )  s += <str> + seeds_peers_fmt % ( item [ <str> ] , item [ <str> ] ) li . setLabel ( s )    def go_left ( self ) : 		 if self . files : 			 self . show_list ( )  else : 			 self . show_menu ( )   def go_right ( self ) : 		 if self . left_menu : 			 self . show_list ( )  else : 			 self . show_files ( )   def show_menu ( self ) : 		 if self . left_menu : 			 return  self . left_menu = pyxbmct . List ( <str> ) self . placeControl ( self . left_menu , 0 , 0 ) link = self . cursel_link ( ) self . list . setVisible ( False ) from downloader import TorrentDownloader import urllib torr_downloader = TorrentDownloader ( urllib . unquote ( link ) , None , self . settings ) choice_path = filesystem . join ( self . settings . torrents_path ( ) , torr_downloader . get_subdir_name ( ) , torr_downloader . get_post_index ( ) + <str> ) if self . settings . copy_torrent_path : 			 li = xbmcgui . ListItem ( <str> ) li . setProperty ( <str> , link ) li . setProperty ( <str> , <str> ) self . left_menu . addItem ( li )  if filesystem . exists ( choice_path ) : 			 li = xbmcgui . ListItem ( <str> ) li . setProperty ( <str> , link ) li . setProperty ( <str> , choice_path ) li . setProperty ( <str> , <str> )  else : 			 li = xbmcgui . ListItem ( <str> ) li . setProperty ( <str> , link ) li . setProperty ( <str> , choice_path ) li . setProperty ( <str> , <str> )  self . left_menu . addItem ( li ) self . setFocus ( self . left_menu ) self . connect ( self . left_menu , self . select_menu_item )  def select_menu_item ( self ) : 		 cursel = self . left_menu . getSelectedItem ( ) action = cursel . getProperty ( <str> ) if action == <str> : 			 link = cursel . getProperty ( <str> ) def go_copy_torrent ( ) : 				 path = self . download_torrent ( link ) debug ( path ) self . copy_torrent ( path )  import threading self . thread = threading . Thread ( target = go_copy_torrent ) self . thread . start ( )  elif action == <str> : 			 self . remember_choice ( cursel . getProperty ( <str> ) )  elif action == <str> : 			 self . cancel_choice ( cursel . getProperty ( <str> ) )  self . show_list ( )  def copy_torrent ( self , torrent_path ) : 		 settings = self . settings if settings . copy_torrent_path and filesystem . exists ( settings . copy_torrent_path ) : 			 dest_path = filesystem . join ( self . settings . copy_torrent_path , filesystem . basename ( torrent_path ) ) filesystem . copyfile ( torrent_path , dest_path )   def remember_choice ( self , choice_path ) : 		 with filesystem . fopen ( choice_path , <str> ) : 			 pass  self . list . reset ( ) self . fill_list ( )  def cancel_choice ( self , choice_path ) : 		 filesystem . remove ( choice_path ) self . list . reset ( ) self . fill_list ( )  def show_list ( self ) : 		 self . list . setVisible ( True ) self . setFocus ( self . list ) if self . files : 			 self . files . setVisible ( False ) del self . files self . files = None  if self . left_menu : 			 self . left_menu . setVisible ( False ) del self . left_menu self . left_menu = None   def cursel_link ( self ) : 		 cursel = self . list . getSelectedItem ( ) debug ( cursel . getLabel ( ) ) link = cursel . getProperty ( <str> ) match = re . search ( <str> , str ( link ) ) if not match : 			 pattern2 = <str> match = re . search ( pattern2 , str ( link ) )  if match : 			 link = match . group ( 1 )  return link  def download_torrent ( self , link ) : 		 tempPath = xbmc . translatePath ( <str> ) . decode ( <str> ) from downloader import TorrentDownloader import player settings = self . settings import urllib torr_downloader = TorrentDownloader ( urllib . unquote ( link ) , tempPath , settings ) path = filesystem . join ( settings . torrents_path ( ) , torr_downloader . get_subdir_name ( ) , torr_downloader . get_post_index ( ) + <str> ) if not filesystem . exists ( path ) : 			 torr_downloader . download ( ) path = torr_downloader . get_filename ( )  debug ( path ) return path  def show_files ( self ) : 		 if self . files : 			 return  self . files = pyxbmct . List ( <str> ) self . placeControl ( self . files , 0 , 0 ) link = self . cursel_link ( ) self . list . setVisible ( False ) path = self . download_torrent ( link ) if filesystem . exists ( path ) : 			 import base player = base . TorrentPlayer ( ) player . AddTorrent ( path ) data = player . GetLastTorrentData ( ) if data : 				 for f in data [ <str> ] : 					 try : 						 li = xbmcgui . ListItem ( str ( f [ <str> ] / 1024 / 1024 ) + <str> + f [ <str> ] )  except : 						 li = xbmcgui . ListItem ( f [ <str> ] )  li . setProperty ( <str> , str ( f [ <str> ] ) ) self . files . addItem ( li )    self . setFocus ( self . files ) self . connect ( self . files , self . select_file )  def select_file ( self ) : 		 debug ( <str> ) self . has_select_file = True self . close ( )  def make_choice ( self ) : 		 debug ( <str> ) self . has_choice = True self . close ( )   def debug_info_label ( s ) : 	 debug ( <str> % s + xbmc . getInfoLabel ( s ) ) debug ( <str> % s + sys . listitem . getProperty ( s . split ( <str> ) [ - 1 ] ) )  def get_path_name ( ) : 	 path = xbmc . getInfoLabel ( <str> ) name = xbmc . getInfoLabel ( <str> ) if path and name : 		 return path , name  dbpath = sys . listitem . getfilename ( ) if not path or not name : 		 if not dbpath . startswith ( <str> ) and dbpath . endswith ( <str> ) : 			 path = dbpath   if path and not name : 		 name = path . replace ( <str> , <str> ) . split ( <str> ) [ - 1 ]  if not path or not name : 		 if dbpath . startswith ( <str> ) : 			 dbpath = dbpath . split ( <str> ) [ - 1 ] dbpath = dbpath . split ( <str> ) [ 0 ] dbpath = dbpath . rstrip ( <str> ) parts = dbpath . split ( <str> ) dbtype = parts [ 0 ] dbid = int ( parts [ - 1 ] ) import json path = None if <str> in dbtype : 				 jsno = { <str> : <str> , <str> : <str> , <str> : { <str> : [ <str> ] , <str> : dbid } , <str> : 1 } result = json . loads ( xbmc . executeJSONRPC ( json . dumps ( jsno ) ) ) path = result [ <str> ] [ <str> ] [ <str> ]  if <str> in dbtype : 				 if xbmc . getInfoLabel ( <str> ) == <str> : 					 jsno = { <str> : <str> , <str> : <str> , <str> : { <str> : [ <str> ] , <str> : dbid } , <str> : 13 } res_type = <str>  else : 					 jsno = { <str> : <str> , <str> : <str> , <str> : { <str> : [ <str> ] , <str> : dbid } , <str> : 13 } res_type = <str>  result = json . loads ( xbmc . executeJSONRPC ( json . dumps ( jsno ) ) ) path = result [ <str> ] [ res_type ] [ <str> ]  try : 				 if path : 					 path = path . encode ( <str> )   except UnicodeDecodeError : 				 pass  name = path . replace ( <str> , <str> ) . split ( <str> ) [ - 1 ]   return path , name  def main ( settings = None , path = None , name = None , run = None ) : 	 import time main . start_time = time . time ( ) def stage ( n ) : 		  stage ( 0 ) if not path or not name : 		 path , name = get_path_name ( )  stage ( 1 ) if not settings : 		 import player settings = player . load_settings ( )  stage ( 2 ) import xbmcvfs , os tempPath = xbmc . translatePath ( <str> ) if xbmcvfs . exists ( path + <str> ) : 		 debug ( <str> ) xbmcvfs . copy ( path , os . path . join ( tempPath , name ) ) xbmcvfs . copy ( path + <str> , os . path . join ( tempPath , name + <str> ) ) path = os . path . join ( tempPath , name )  else : 		 return False  class Links ( ) : 		 def __init__ ( self ) : 			 self . reload = None self . _links = result = STRMWriterBase . get_links_with_ranks ( path . decode ( <str> ) , settings , use_scrape_info = False )  def __call__ ( self ) : 			 return self . _links  def set_reload ( self , reload ) : 			 self . reload = reload import threading self . thread = threading . Thread ( target = self . do_get_seeds_peers ) self . thread . start ( )  def do_get_seeds_peers ( self ) : 			 from base import seeds_peers for item in self . _links : 				 if self . reload : 					 sp = seeds_peers ( item ) item = dict ( item , ** sp ) self . reload ( item )    def close ( self ) : 			 self . reload = None   stage ( 3 ) links = Links ( ) stage ( 4 ) window = MyWindow ( settings . addon_name , settings = settings , links = links ) stage ( 5 ) window . doModal ( ) links . close ( ) debug ( window . has_choice ) debug ( window . has_select_file ) if not window . has_choice and not window . has_select_file : 		 del window return True  cursel = window . list . getSelectedItem ( ) debug ( cursel . getLabel ( ) ) link = cursel . getProperty ( <str> ) debug ( link ) if link == <str> : 		 xbmc . executebuiltin ( <str> ) del window return True  if link == <str> : 		 from context_show_similar import show_similar if show_similar ( ) : 			 del window return True   if link == <str> : 		 from context_get_sources import get_sources get_sources ( settings ) return True  if link == <str> : 		 import context_united_search  selected_file = None if window . has_select_file : 		 selected_file = window . files . getSelectedItem ( ) . getProperty ( <str> )  del window with filesystem . fopen ( path . decode ( <str> ) , <str> ) as strm : 		 src_link = strm . read ( ) debug ( src_link ) dst_link = str ( link ) src_link_params = src_link . split ( <str> ) [ 1 ] src_link_params = src_link_params . split ( <str> ) alt_link_params = dst_link . split ( <str> ) [ 1 ] alt_link_params = alt_link_params . split ( <str> ) dst_link = dst_link . split ( <str> ) [ 0 ] + <str> dst_link_params = list ( ) for param in alt_link_params : 			 key = param . split ( <str> ) [ 0 ] if key in ( <str> , <str> , <str> , <str> ) : 				 if not selected_file : 					 dst_link_params . append ( param )   else : 				 dst_link_params . append ( param )   for param in src_link_params : 			 key = param . split ( <str> ) [ 0 ] if key in ( <str> , <str> ) : 				 dst_link_params . append ( param )   if selected_file : 			 dst_link_params . append ( <str> . format ( selected_file ) )  dst_link_params . append ( <str> ) dst_link += <str> . join ( dst_link_params ) debug ( dst_link ) if run : 			 run_params = dict ( ) for item in dst_link_params : 				 k , v = item . split ( <str> ) run_params [ k ] = v  run ( run_params )  else : 			 xbmc . executebuiltin ( <str> + dst_link + <str> )   if tempPath in path : 		 xbmcvfs . delete ( path ) xbmcvfs . delete ( path + <str> )  return True  if __name__ == <str> : 	 import vsdbg vsdbg . _bp ( ) main ( )    