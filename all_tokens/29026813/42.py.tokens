import filesystem , log from movieapi import MovieAPI def addon_data_path ( ) : 	 from player import _addon , _addondir if _addon . getSetting ( <str> ) : 		 return _addon . getSetting ( <str> )  else : 		 return _addondir   def recheck_torrent_if_need ( from_time , settings ) : 	 if settings . torrent_player != <str> : 		 return  def check_modify_time ( fn ) : 		 import time , filesystem mt = filesystem . getmtime ( fn ) if abs ( from_time - mt ) < 3600 : 			 return True  return False  def get_hashes ( fn ) : 		 with filesystem . fopen ( fn , <str> ) as hf : 			 hashes = hf . readlines ( ) return [ h . strip ( <str> ) for h in hashes ]  return [ ]  def rehash_torrent ( hashes , torrent_path ) : 		 import time try : 			 from torrent2httpplayer import Torrent2HTTPPlayer from torrent2http import State  except ImportError : 			 return  player = Torrent2HTTPPlayer ( settings ) player . AddTorrent ( torrent_path ) player . GetLastTorrentData ( ) player . _AddTorrent ( torrent_path ) player . engine . start ( ) f_status = player . engine . file_status ( 0 ) while True : 			 time . sleep ( 1.0 ) status = player . engine . status ( ) if status . state in [ State . FINISHED , State . SEEDING , State . DOWNLOADING ] : 				 break ;   player . engine . wait_on_close ( ) player . close ( )  def process_dir ( _d ) : 		 for fn in filesystem . listdir ( _d ) : 			 full_name = filesystem . join ( _d , fn ) if fn . endswith ( <str> ) and check_modify_time ( full_name ) : 				 hashes = get_hashes ( full_name ) if len ( hashes ) > 1 : 					 rehash_torrent ( hashes , full_name . replace ( <str> , <str> ) )     for d in filesystem . listdir ( settings . torrents_path ( ) ) : 		 dd = filesystem . join ( settings . torrents_path ( ) , d ) if not filesystem . isfile ( dd ) : 			 process_dir ( dd )    def update_service ( show_progress = False ) : 	 import anidub , hdclub , nnmclub , rutor , soap4me , bluebird , kinohd from player import _addon anidub_enable = _addon . getSetting ( <str> ) == <str> hdclub_enable = False bluebird_enable = _addon . getSetting ( <str> ) == <str> nnmclub_enable = _addon . getSetting ( <str> ) == <str> rutor_enable = _addon . getSetting ( <str> ) == <str> soap4me_enable = _addon . getSetting ( <str> ) == <str> kinohd_enable = _addon . getSetting ( <str> ) == <str> from player import load_settings settings = load_settings ( ) import time from_time = time . time ( ) if show_progress : 		 import xbmcgui info_dialog = xbmcgui . DialogProgressBG ( ) info_dialog . create ( settings . addon_name ) settings . progress_dialog = info_dialog  from log import dump_context if anidub_enable : 		 with dump_context ( <str> ) : 			 anidub . run ( settings )   if bluebird_enable : 		 with dump_context ( <str> ) : 			 bluebird . run ( settings )   if rutor_enable : 		 with dump_context ( <str> ) : 			 rutor . run ( settings )   if kinohd_enable : 		 with dump_context ( <str> ) : 			 kinohd . run ( settings )   if nnmclub_enable : 		 from service import Addon addon = Addon ( <str> ) try : 			 import math from time import time settings . nnmclub_hours = int ( math . ceil ( ( time ( ) - float ( addon . getSetting ( <str> ) ) ) / 3600.0 ) )  except BaseException as e : 			 settings . nnmclub_hours = 168 log . print_tb ( e )  if settings . nnmclub_hours > 168 : 			 settings . nnmclub_hours = 168  if settings . nnmclub_hours < 8 : 			 settings . nnmclub_hours = 8  log . debug ( <str> + str ( settings . nnmclub_hours ) ) addon . setSetting ( <str> , str ( time ( ) ) ) with dump_context ( <str> ) : 			 nnmclub . run ( settings )   if show_progress : 		 info_dialog . update ( 0 , <str> , <str> ) info_dialog . close ( )  if settings . update_paths : 		 from jsonrpc_requests import VideoLibrary from plugin import UpdateVideoLibrary , ScanMonitor monitor = ScanMonitor ( ) UpdateVideoLibrary ( ) while not monitor . abortRequested ( ) : 			 if monitor . waitForAbort ( 1 ) : 				 return  if monitor . do_exit : 				 clean_movies ( ) break     def chunks ( l , n ) : 	 for i in xrange ( 0 , len ( l ) , n ) : 		 yield l [ i : i + n ]   def scrape_nnm ( ) : 	 from player import load_settings settings = load_settings ( ) data_path = settings . torrents_path ( ) if not filesystem . exists ( filesystem . join ( data_path , <str> ) ) : 		 return  hashes = [ ] for torr in filesystem . listdir ( filesystem . join ( data_path , <str> ) ) : 		 if torr . endswith ( <str> ) : 			 try : 				 from base import TorrentPlayer tp = TorrentPlayer ( ) tp . AddTorrent ( filesystem . join ( data_path , <str> , torr ) ) data = tp . GetLastTorrentData ( ) if data : 					 hashes . append ( ( data [ <str> ] , data [ <str> ] , torr . replace ( <str> , <str> ) ) )   except BaseException as e : 				 log . print_tb ( e )    for chunk in chunks ( hashes , 32 ) : 		 import scraper try : 			 seeds_peers = scraper . scrape ( chunk [ 0 ] [ 0 ] , [ i [ 1 ] for i in chunk ] , 10 )  except RuntimeError as RunE : 			 if <str> in RunE . message : 				 for c in chunks ( chunk , 16 ) : 					 try : 						 seeds_peers = scraper . scrape ( c [ 0 ] [ 0 ] , [ i [ 1 ] for i in c ] , 10 ) process_chunk ( c , data_path , seeds_peers )  except BaseException as e : 						 log . print_tb ( e )    continue  except BaseException as e : 			 log . print_tb ( e ) continue  process_chunk ( chunk , data_path , seeds_peers )   def process_chunk ( chunk , data_path , seeds_peers ) : 	 import json for item in chunk : 		 filename = filesystem . join ( data_path , <str> , item [ 2 ] ) remove_file = False with filesystem . fopen ( filename , <str> ) as stat_file : 			 try : 				 json . dump ( seeds_peers [ item [ 1 ] ] , stat_file )  except KeyError : 				 remove_file = True   if remove_file : 			 filesystem . remove ( filename )    def add_media_process ( title , imdb ) : 	 count = 0 from player import getSetting , load_settings import anidub , hdclub , nnmclub , rutor , soap4me , bluebird , kinohd settings = load_settings ( ) anidub_enable = getSetting ( <str> ) == <str> hdclub_enable = False bluebird_enable = getSetting ( <str> ) == <str> nnmclub_enable = getSetting ( <str> ) == <str> rutor_enable = getSetting ( <str> ) == <str> soap4me_enable = False kinohd_enable = getSetting ( <str> ) == <str> class RemoteDialogProgress : 		 progress_file_path = filesystem . join ( addon_data_path ( ) , <str> . join ( [ imdb , <str> ] ) ) def update ( self , percent , * args , ** kwargs ) : 			 with filesystem . fopen ( self . progress_file_path , <str> ) as progress_file : 				 progress_file . write ( str ( percent ) + <str> ) progress_file . write ( <str> . join ( args ) . encode ( <str> ) )   def close ( self ) : 			 try : 				 filesystem . remove ( self . progress_file_path )  except : pass   settings . progress_dialog = RemoteDialogProgress ( ) p = [ ] from log import dump_context if True : 		 if anidub_enable and imdb . startswith ( <str> ) : 			 with dump_context ( <str> ) : 				 c = anidub . search_generate ( title , settings , p ) count += c   if imdb . startswith ( <str> ) : 			 if bluebird_enable : 				 with dump_context ( <str> ) : 					 c = bluebird . search_generate ( title , imdb , settings , p ) count += c   if rutor_enable : 				 with dump_context ( <str> ) : 					 c = rutor . search_generate ( title , imdb , settings , p ) count += c   if kinohd_enable : 				 with dump_context ( <str> ) : 					 c = kinohd . search_generate ( title , imdb , settings , p ) count += c   if nnmclub_enable : 				 with dump_context ( <str> ) : 					 c = nnmclub . search_generate ( title , imdb , settings , p ) count += c     if p : 		 path = filesystem . join ( addon_data_path ( ) , imdb + <str> ) with filesystem . fopen ( path , <str> ) as f : 			 f . write ( p [ 0 ] . encode ( <str> ) )   settings . progress_dialog . close ( ) if count : 		 import xbmc if not xbmc . getCondVisibility ( <str> ) : 			 from jsonrpc_requests import VideoLibrary from plugin import UpdateVideoLibrary if p and p [ 0 ] : 				 path = p [ 0 ] if path . endswith ( <str> ) : 					 type = <str>  else : 					 type = <str>  base_path = filesystem . dirname ( p [ 0 ] ) from sources import Sources srcs = Sources ( ) for src in srcs . get ( <str> , normalize = False ) : 					 src_path_basename = filesystem . basename ( src . path . rstrip ( <str> ) ) if base_path . startswith ( src_path_basename ) : 						 if type == <str> : 							 path_update = src . path if src . path . startswith ( <str> ) : 								 path_update = src . path path_update = path_update . strip ( <str> ) + <str> + filesystem . basename ( path )  else : 								 path_update = filesystem . join ( src . path , filesystem . basename ( path ) )   else : 							 path_update = filesystem . join ( src . path , base_path [ len ( src_path_basename ) + 1 : ] )  log . debug ( path_update ) UpdateVideoLibrary ( path = path_update )    else : 				 UpdateVideoLibrary ( )    clean_movies ( ) path = filesystem . join ( addon_data_path ( ) , imdb + <str> ) with filesystem . fopen ( path , <str> ) as f : 		 f . write ( str ( count ) )   def load_settings ( ) : 	 from player import load_settings as _load_settings return _load_settings ( )  def safe_remove ( path ) : 	 import filesystem if filesystem . exists ( path ) : 		 filesystem . remove ( path )   def safe_copyfile ( src , dst ) : 	 import filesystem dirname = filesystem . dirname ( dst ) if not filesystem . exists ( dirname ) : 		 filesystem . makedirs ( dirname )  if filesystem . exists ( src ) : 		 filesystem . copyfile ( src , dst )   def dt ( ss ) : 	 import datetime fmt = <str> try : 		 return datetime . datetime . strptime ( ss , fmt )  except : 		 return 0   def clean_movies ( ) : 	 _debug = False from plugin import wait_for_update wait_for_update ( ) log . debug ( <str> * 80 ) log . debug ( <str> ) log . debug ( <str> * 80 ) from kodidb import MoreRequests more_requests = MoreRequests ( ) movie_duplicates_list = more_requests . get_movie_duplicates ( ) settings = load_settings ( ) watched_and_progress = { } update_paths = set ( ) clean_ids = [ ] import movieapi from base import make_fullpath def get_info_and_move_files ( imdbid ) : 		 def _log ( s ) : 			 log . debug ( <str> . format ( s ) )  api = movieapi . MovieAPI . get_by ( imdb_id = imdbid ) [ 0 ] try : 			 genre = api [ <str> ] if <str> in genre : 				 base_path = settings . animation_path ( )  elif <str> in genre : 				 base_path = settings . documentary_path ( )  else : 				 base_path = settings . movies_path ( )   except : 			 base_path = settings . movies_path ( )  from movieapi import make_imdb_path base_path = make_imdb_path ( base_path , imdbid ) one_movie_duplicates = filter ( lambda x : x [ <str> ] . endswith ( <str> ) , more_requests . get_movies_by_imdb ( imdbid ) ) from base import STRMWriterBase from base import Informer try : 			 title = Informer ( ) . filename_with ( api . title ( ) , api . originaltitle ( ) , api [ <str> ] )  except AttributeError : 			 title = Informer ( ) . filename_with ( api . title ( ) , api . originaltitle ( ) , None )  strm_path = filesystem . join ( base_path , make_fullpath ( title , <str> ) ) nfo_path = filesystem . join ( base_path , make_fullpath ( title , <str> ) ) _log ( <str> + title ) _log ( <str> + strm_path ) alt_data = [ ] update_fields = { } for movie_duplicate in one_movie_duplicates : 			 links_with_ranks = STRMWriterBase . get_links_with_ranks ( movie_duplicate [ <str> ] , settings , use_scrape_info = False ) alt_data . extend ( links_with_ranks ) if movie_duplicate [ <str> ] : 				 update_fields [ <str> ] = int ( update_fields . get ( <str> , 0 ) ) + int ( movie_duplicate [ <str> ] )  if movie_duplicate [ <str> ] and movie_duplicate [ <str> ] : 				 update_fields [ <str> ] = { <str> : int ( movie_duplicate [ <str> ] ) , <str> : int ( movie_duplicate [ <str> ] ) }   with filesystem . save_make_chdir_context ( base_path , <str> ) : 			 alt_data = [ dict ( t ) for t in set ( [ tuple ( d . iteritems ( ) ) for d in alt_data ] ) ] STRMWriterBase . write_alternative ( strm_path , alt_data ) last_strm_path = movie_duplicate [ <str> ] if last_strm_path != strm_path : 				 last_nfo_path = last_strm_path . replace ( <str> , <str> ) safe_copyfile ( last_strm_path , strm_path ) safe_copyfile ( last_nfo_path , nfo_path ) update_paths . add ( filesystem . dirname ( strm_path ) )  for movie_duplicate in one_movie_duplicates : 				 cur_strm_path = movie_duplicate [ <str> ] if cur_strm_path != strm_path : 					 safe_remove ( cur_strm_path ) safe_remove ( cur_strm_path . replace ( <str> , <str> ) ) safe_remove ( cur_strm_path + <str> ) clean_ids . append ( movie_duplicate [ <str> ] )    return update_fields  log . debug ( <str> ) log . debug ( <str> ) for movie in movie_duplicates_list : 		 try : 			 imdbid = movie [ 0 ] watched_and_progress [ imdbid ] = get_info_and_move_files ( imdbid )  except BaseException as e : 			 from log import print_tb print_tb ( ) pass  if _debug : 			 break   log . debug ( <str> ) log . debug ( <str> ) from jsonrpc_requests import VideoLibrary from plugin import wait_for_update , UpdateVideoLibrary for path in update_paths : 		 log . debug ( <str> . format ( path ) ) UpdateVideoLibrary ( path = path , wait = True )  log . debug ( <str> ) log . debug ( <str> ) for imdbid , update_data in watched_and_progress . iteritems ( ) : 		 if update_data : 			 movies = more_requests . get_movies_by_imdb ( imdbid ) if movies : 				 movieid = movies [ - 1 ] [ <str> ] log . debug ( <str> . format ( movies [ - 1 ] [ <str> ] ) ) log . debug ( unicode ( update_data ) ) VideoLibrary . SetMovieDetails ( movieid = movieid , ** update_data )   pass  log . debug ( <str> ) log . debug ( <str> ) for idMovie in clean_ids : 		 log . debug ( <str> . format ( idMovie ) ) VideoLibrary . RemoveMovie ( movieid = idMovie )  log . debug ( <str> * 80 ) log . debug ( <str> ) log . debug ( <str> * 80 )   