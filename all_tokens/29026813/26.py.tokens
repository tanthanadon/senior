 from log import * import json import re import urllib2 from contextlib import closing from zipfile import ZipFile , BadZipfile , LargeZipFile import xml . etree . ElementTree as ET import io import filesystem from base import TorrentPlayer , make_fullpath def cutStr ( s ) : 	 return s . replace ( <str> , <str> ) . replace ( <str> , <str> ) . replace ( <str> , <str> ) . replace ( <str> , <str> ) . lower ( ) . strip ( )  def sweetpair ( l ) : 	 from difflib import SequenceMatcher s = SequenceMatcher ( ) ratio = [ ] for i in range ( 0 , len ( l ) ) : ratio . append ( 0 ) for i in range ( 0 , len ( l ) ) : 		 for p in range ( 0 , len ( l ) ) : 			 s . set_seqs ( l [ i ] , l [ p ] ) ratio [ i ] = ratio [ i ] + s . quick_ratio ( )   id1 , id2 = 0 , 0 for i in range ( 0 , len ( l ) ) : 		 if ratio [ id1 ] <= ratio [ i ] and i != id2 or id2 == id1 and ratio [ id1 ] == ratio [ i ] : 			 id2 = id1 id1 = i  elif ( ratio [ id2 ] <= ratio [ i ] or id1 == id2 ) and i != id1 : 			 id2 = i   debug ( <str> + l [ id1 ] + <str> + str ( ratio [ id1 ] ) ) debug ( <str> + l [ id2 ] + <str> + str ( ratio [ id2 ] ) ) return [ l [ id1 ] , l [ id2 ] ]  def sortext ( filelist ) : 	 result = { } for name in filelist : 		 ext = name . split ( <str> ) [ - 1 ] try : 			 result [ ext ] = result [ ext ] + 1  except : 			 result [ ext ] = 1   lol = result . iteritems ( ) lol = sorted ( lol , key = lambda x : x [ 1 ] ) debug ( <str> + str ( lol ) ) popext = lol [ - 1 ] [ 0 ] result , i = [ ] , 0 for name in filelist : 		 if name . split ( <str> ) [ - 1 ] == popext : 			 result . append ( name ) i = i + 1   result = sweetpair ( result ) debug ( <str> + str ( result ) ) return result  def cutFileNames ( l ) : 	 from difflib import Differ d = Differ ( ) text = sortext ( l ) indexes = [ ] for i in l : 		 indexes . append ( l [ i ] )  newl = [ ] for li in l : 		 newl . append ( cutStr ( li [ 0 : len ( li ) - 1 - len ( li . split ( <str> ) [ - 1 ] ) ] ) )  l = newl text1 = cutStr ( text [ 0 ] [ 0 : len ( text [ 0 ] ) - 1 - len ( text [ 0 ] . split ( <str> ) [ - 1 ] ) ] ) text2 = cutStr ( text [ 1 ] [ 0 : len ( text [ 1 ] ) - 1 - len ( text [ 1 ] . split ( <str> ) [ - 1 ] ) ] ) sep_file = <str> result = list ( d . compare ( text1 . split ( sep_file ) , text2 . split ( sep_file ) ) ) debug ( <str> + unicode ( result ) ) start = <str> end = <str> for res in result : 		 if str ( res ) . startswith ( <str> ) or str ( res ) . startswith ( <str> ) or str ( res ) . startswith ( <str> ) : 			 break  start = start + str ( res ) . strip ( ) + sep_file  result . reverse ( ) for res in result : 		 if str ( res ) . startswith ( <str> ) or str ( res ) . startswith ( <str> ) or str ( res ) . startswith ( <str> ) : 			 break  end = sep_file + str ( res ) . strip ( ) + end  newl = l l = { } debug ( <str> + start ) debug ( <str> + end ) for i , fl in enumerate ( newl ) : 		 if cutStr ( fl [ 0 : len ( start ) ] ) == cutStr ( start ) : fl = fl [ len ( start ) : ] if cutStr ( fl [ len ( fl ) - len ( end ) : ] ) == cutStr ( end ) : fl = fl [ 0 : len ( fl ) - len ( end ) ] try : 			 isinstance ( int ( fl . split ( sep_file ) [ 0 ] ) , int ) fl = fl . split ( sep_file ) [ 0 ]  except : 			 pass  l [ fl ] = indexes [ i ]  debug ( <str> + unicode ( sorted ( l , key = lambda x : x ) ) ) return l  def FileNamesPrepare ( filename ) : 	 my_season = None my_episode = None try : 		 if int ( filename ) : 			 my_episode = int ( filename ) debug ( <str> + str ( [ my_season , my_episode , filename ] ) ) return [ my_season , my_episode , filename ]   except : 		 pass  urls = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] for file in urls : 		 match = re . compile ( file , re . DOTALL | re . I | re . IGNORECASE ) . findall ( filename ) if match : 			 try : 				 my_episode = int ( match [ 1 ] ) my_season = int ( match [ 0 ] )  except : 				 try : 					 my_episode = int ( match [ 0 ] )  except : 					 try : 						 my_episode = int ( match [ 0 ] [ 1 ] ) my_season = int ( match [ 0 ] [ 0 ] )  except : 						 try : 							 my_episode = int ( match [ 0 ] [ 0 ] )  except : 							 break     if my_season and my_season > 100 : my_season = None if my_episode : 				 if my_episode > 1000 : 					 dm = divmod ( my_episode , 100 ) if dm [ 0 ] + 1 == dm [ 1 ] : 						 my_episode = dm [ 0 ]  else : 						 my_episode = None   elif my_episode > 365 : 					 my_episode = None   try : 				 debug ( <str> + <str> % ( my_season , my_episode , filename ) )  except TypeError : 				 debug ( <str> ) debug ( <str> + str ( [ my_season , my_episode , filename ] ) ) pass  return [ my_season , my_episode , filename ]   return None  def get_list ( dirlist ) : 	 files = [ ] if len ( dirlist ) > 1 : 		 cutlist = cutFileNames ( dirlist )  else : 		 cutlist = dirlist  for fn in cutlist : 		 x = FileNamesPrepare ( fn ) if x : 			 x . append ( cutlist [ fn ] ) files . append ( x )  else : 			 debug ( fn , lineno ( ) )   return files  def seasonfromname ( name ) : 	 match = re . compile ( <str> , re . I ) . findall ( name ) if match : 		 try : 			 num = int ( match [ 0 ] ) return num if num > 0 and num < 20 else None  except : 			 pass   return None  def parse_torrent ( data , season = None ) : 	 from bencode import BTFailure try : 		 from bencode import bdecode decoded = bdecode ( data )  except BTFailure : 		 debug ( <str> ) return [ ]  info = decoded [ <str> ] dirlists = dict ( ) if <str> in info : 		 for i , f in enumerate ( info [ <str> ] ) : 			 fname = f [ <str> ] [ - 1 ] try : 				 parent = f [ <str> ] [ - 2 ]  except : 				 parent = <str>  if parent not in dirlists : 				 dirlists [ parent ] = dict ( )  debug ( fname ) if TorrentPlayer . is_playable ( fname ) : 				 dirlists [ parent ] [ fname ] = i    files = [ ] for dirname in dirlists : 		 dirlist = dirlists [ dirname ] save_season = season for item in get_list ( dirlist ) : 			 if item is not None : 				 if season is None : 					 if item [ 0 ] is None : 						 season = seasonfromname ( info [ <str> ] ) if season is None : 							 try : 								 season = seasonfromname ( dirname )  except : 								 pass    else : 						 season = item [ 0 ]   name = item [ 2 ] index = item [ 3 ] files . append ( { <str> : name , <str> : season , <str> : item [ 1 ] , <str> : index } ) season = save_season  else : 				 continue    files . sort ( key = lambda x : ( x [ <str> ] , x [ <str> ] ) ) return files  def parse_torrent2 ( data ) : 	 try : 		 decoded = bdecode ( data )  except BTFailure : 		 debug ( <str> % link ) return  files = [ ] info = decoded [ <str> ] if <str> in info : 		 for i , f in enumerate ( info [ <str> ] ) : 			 fname = f [ <str> ] [ - 1 ] if TorrentPlayer . is_playable ( fname ) : 				 s = re . search ( <str> , fname , re . I ) if s : 					 season = int ( s . group ( 1 ) ) episode = int ( s . group ( 2 ) ) debug ( <str> % ( fname , i , season , episode ) ) files . append ( { <str> : i , <str> : fname , <str> : season , <str> : episode } )     if len ( files ) == 0 : 		 return  files . sort ( key = lambda x : ( x [ <str> ] , x [ <str> ] ) ) return files  def season_from_title ( fulltitle ) : 	 parts = re . split ( <str> , fulltitle ) for part in parts : 		 if <str> in part . lower ( ) : 			 return None  if <str> in part . lower ( ) : 			 return None  if <str> in part . lower ( ) : 			 if re . search ( <str> , part ) : 				 return None  match = re . search ( <str> , part ) if match : 				 return int ( match . group ( 1 ) )    return None  def write_tvshow ( fulltitle , link , settings , parser , path , skip_nfo_exists = False ) : 	 from nfowriter import NFOWriter from strmwriter import STRMWriter import requests from downloader import TorrentDownloader dl = TorrentDownloader ( parser . link ( ) , settings . torrents_path ( ) , settings ) if not dl . download ( ) : 		 return None  with filesystem . fopen ( dl . get_filename ( ) , <str> ) as torr : 		 content = torr . read ( ) files = parse_torrent ( content , season_from_title ( fulltitle ) ) title = parser . get_value ( <str> ) debug ( title ) originaltitle = parser . get_value ( <str> ) debug ( originaltitle ) imdb_id = parser . get ( <str> , None ) kp_id = parser . get ( <str> , None ) tvshow_api = TVShowAPI . get_by ( originaltitle , title , imdb_id , kp_id ) try : 			 api_title = parser . movie_api ( ) . imdbapi . title ( )  except AttributeError : 			 api_title = tvshow_api . Title ( )  tvshow_path = make_fullpath ( api_title if api_title is not None else title , <str> ) debug ( tvshow_path ) if tvshow_path : 			 tvshow_path = filesystem . join ( path , tvshow_path ) with filesystem . save_make_chdir_context ( tvshow_path , <str> ) : 				 NFOWriter ( parser , tvshow_api = tvshow_api , movie_api = parser . movie_api ( ) ) . write_tvshow_nfo ( tvshow_path ) for f in files : 					 s_num = f [ <str> ] if f [ <str> ] else 1 try : 						 episode = tvshow_api . Episode ( s_num , f [ <str> ] ) if not episode : 							 episode = { <str> : title , <str> : s_num , <str> : f [ <str> ] , <str> : <str> , <str> : <str> }  season_path = <str> % s_num  except BaseException as e : 						 print_tb ( e ) continue  season_path = filesystem . join ( tvshow_path , season_path ) with filesystem . save_make_chdir_context ( season_path , <str> ) : 						 results = filter ( lambda x : x [ <str> ] == s_num and x [ <str> ] == f [ <str> ] , files ) if len ( results ) > 1 : 							 filename = f [ <str> ]  else : 							 try : 								 cnt = f [ <str> ] filename = <str> % ( cnt , s_num , f [ <str> ] )  except BaseException as e : 								 print_tb ( e ) filename = f [ <str> ]   try : 							 debug ( filename ) filename = filename . decode ( <str> )  except : 							 debug ( [ filename ] )  STRMWriter ( parser . link ( ) ) . write ( filename , season_path , index = f [ <str> ] , settings = settings , parser = parser ) NFOWriter ( parser , tvshow_api = tvshow_api , movie_api = parser . movie_api ( ) ) . write_episode ( episode , filename , season_path , skip_nfo_exists = skip_nfo_exists )    settings . update_paths . add ( tvshow_path ) return tvshow_path  else : 			 return None    def test ( link ) : 	 import requests r = requests . get ( link ) if r . status_code == requests . codes . ok : 		 files = parse_torrent ( r . content )   class TheTVDBAPI ( object ) : 	 __base_url = <str> __apikey = <str> __lang = <str> dictEpisodes = { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } def __init__ ( self , imdbId ) : 		 self . tvdb_banners = None self . tvdb_ru = None if imdbId is None : 			 return  try : 			 response1 = urllib2 . urlopen ( self . __base_url + <str> % ( imdbId , self . __lang ) ) try : 				 self . thetvdbid = re . search ( <str> , response1 . read ( ) ) . group ( 1 )  except AttributeError : 				 return   except urllib2 . HTTPError as e : 			 debug ( <str> + str ( e ) ) return  url2 = self . __base_url + self . __apikey + <str> % ( self . thetvdbid , self . __lang ) debug ( url2 ) response2 = urllib2 . urlopen ( url2 ) try : 			 f = io . BytesIO ( response2 . read ( ) ) with closing ( ZipFile ( f , <str> ) ) as zf : 				 with closing ( zf . open ( <str> , <str> ) ) as banners : 					 self . tvdb_banners = ET . fromstring ( banners . read ( ) )  with closing ( zf . open ( <str> ) ) as ru : 					 self . tvdb_ru = ET . fromstring ( ru . read ( ) )    except BadZipfile as bz : 			 debug ( str ( bz ) )  except LargeZipFile as lz : 			 debug ( str ( lz ) )   def getEpisode ( self , season , episode ) : 		 res = { } if self . tvdb_ru is None : 			 return res  for ep in self . tvdb_ru : 			 if ep . tag == <str> : 				 try : 					 episode_number = int ( ep . find ( <str> ) . text ) season_number = int ( ep . find ( <str> ) . text )  except BaseException as e : 					 print_tb ( e ) continue  if int ( episode_number ) != episode or int ( season_number ) != season : 					 continue  for child in ep : 					 if child . text is not None : 						 if child . tag in self . dictEpisodes and len ( child . text ) > 0 : 							 res [ self . dictEpisodes [ child . tag ] ] = child . text  if child . tag == <str> and len ( child . text ) > 0 : 							 res [ <str> ] = <str> + child . text   else : 						 pass     return res  def getArt ( self , type ) : 		 result = [ ] if self . tvdb_banners is None : 			 return result  baseurl = <str> for banner in self . tvdb_banners : 			 BannerType = banner . find ( <str> ) if BannerType is not None : 				 if BannerType . text == type : 					 BannerPath = banner . find ( <str> ) ThumbnailPath = banner . find ( <str> ) if BannerPath is not None and ThumbnailPath is not None : 						 result . append ( { <str> : baseurl + BannerPath . text , <str> : baseurl + ThumbnailPath . text } )     return result  def Fanart ( self ) : 		 return self . getArt ( <str> )  def Poster ( self ) : 		 return self . getArt ( <str> )  def getTitle ( self ) : 		 if self . tvdb_ru is None : 			 return None  Series = self . tvdb_ru . find ( <str> ) if Series is not None : 			 SeriesName = Series . find ( <str> ) if SeriesName is not None : 				 return SeriesName . text   return None  def get_premiered ( self ) : 		 if self . tvdb_ru is None : 			 return None  Series = self . tvdb_ru . find ( <str> ) if Series is not None : 			 premiered = Series . find ( <str> ) if premiered is not None : 				 return premiered . text   return None   class MyShowsAPI ( object ) : 	 myshows = None myshows_ep = None dictMyShows = { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } def __init__ ( self , title , ruTitle , imdbId = None , kinopoiskId = None ) : 		 if imdbId : 			 try : 				 imdbId = int ( re . search ( <str> , imdbId ) . group ( 1 ) ) debug ( imdbId )  except : 				 imdbId = None   if kinopoiskId : 			 try : 				 kinopoiskId = int ( re . search ( <str> , kinopoiskId ) . group ( 1 ) )  except : 				 kinopoiskId = None   base_url = <str> url = base_url + urllib2 . quote ( title . encode ( <str> ) ) try : 			 self . myshows = json . load ( urllib2 . urlopen ( url ) )  except urllib2 . HTTPError as e : 			 debug ( <str> + str ( e ) ) return  if not self . valid ( ) : 			 url = base_url + urllib2 . quote ( ruTitle . encode ( <str> ) ) self . myshows = json . load ( urllib2 . urlopen ( url ) )  if self . valid ( ) : 			 debug ( url ) id = self . get_myshows_id ( imdbId , kinopoiskId ) debug ( id ) if id != 0 : 				 url = <str> + str ( id ) self . myshows_ep = json . load ( urllib2 . urlopen ( url ) ) if self . valid_ep ( ) : 					 debug ( url )    debug ( str ( self . valid ( ) ) ) debug ( str ( self . valid_ep ( ) ) )  def get_myshows_id ( self , imdbId , kinopoiskId ) : 		 if True : 			 if self . valid ( ) : 				 for key in self . myshows . keys ( ) : 					 debug ( key ) section = self . myshows [ str ( key ) ] if imdbId : 						 if section [ <str> ] == imdbId : 							 return section [ <str> ]   if kinopoiskId : 						 if section [ <str> ] == kinopoiskId : 							 return section [ <str> ]   if imdbId is None or kinopoiskId is None : 						 return section [ <str> ]     else : 			 pass  return 0  def valid ( self ) : 		 if self . myshows != None : 			 return len ( self . myshows ) > 0  else : 			 return False   def valid_ep ( self ) : 		 if self . myshows_ep != None : 			 return len ( self . myshows_ep ) > 0  else : 			 return False   def data ( self ) : 		 if self . valid_ep ( ) : 			 return self . myshows_ep  return None  def getEpisode ( self , season , episode ) : 		 res = { } if self . valid_ep ( ) : 			 for episode_data in self . myshows_ep [ <str> ] : 				 ep = self . myshows_ep [ <str> ] [ episode_data ] if ep [ <str> ] != season or ep [ <str> ] != episode : 					 continue  for tag in ep : 					 if tag in self . dictMyShows : 						 res [ self . dictMyShows [ tag ] ] = ep [ tag ]     return res  def getYear ( self ) : 		 if self . data ( ) : 			 return self . data ( ) . get ( <str> )  else : 			 return None   def get_premiered ( self ) : 		 if self . data ( ) : 			 s = self . data ( ) . get ( <str> ) if s : 				 import datetime , time debug ( s ) try : 					 d = datetime . datetime . strptime ( s , <str> )  except TypeError : 					 d = datetime . datetime ( * ( time . strptime ( s , <str> ) [ 0 : 6 ] ) )  except : 					 d = None  if d : 					 return d . strftime ( <str> )    return None  def episodes ( self , season ) : 		 ren_items = { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } episodes__ = [ ] if self . valid_ep ( ) : 			 for episode in self . myshows_ep [ <str> ] : 				 ep = self . myshows_ep [ <str> ] [ episode ] . copy ( ) if ep [ <str> ] == season and ep [ <str> ] != 0 : 					 for key in ren_items : 						 ep [ ren_items [ key ] ] = ep . pop ( key )  episodes__ . append ( ep )    return sorted ( episodes__ , key = lambda k : k [ <str> ] )   class TVShowAPI ( TheTVDBAPI , MyShowsAPI ) : 	 imdb_api = { } @ staticmethod def get_by ( title , ruTitle , imdbId = None , kinopoiskId = None ) : 		 if imdbId and imdbId in TVShowAPI . imdb_api : 			 return TVShowAPI . imdb_api [ imdbId ]  api = TVShowAPI ( title , ruTitle , imdbId , kinopoiskId ) if imdbId : 			 TVShowAPI . imdb_api [ imdbId ] = api  return api  def __init__ ( self , title , ruTitle , imdbId = None , kinopoiskId = None ) : 		 TheTVDBAPI . __init__ ( self , imdbId ) MyShowsAPI . __init__ ( self , title , ruTitle , imdbId , kinopoiskId )  def Title ( self ) : 		 title = TheTVDBAPI . getTitle ( self ) if title is not None : 			 return title  d = self . data ( ) if d is not None : 			 try : 				 return d . get ( <str> , None )  except AttributeError : 				 pass   return None  def Episode ( self , season , episode ) : 		 from nfowriter import NFOWriter data_ms = MyShowsAPI . getEpisode ( self , season , episode ) data_tmdb = TheTVDBAPI . getEpisode ( self , season , episode ) res = data_ms . copy ( ) res . update ( data_tmdb ) if <str> in res : 			 res [ <str> ] = NFOWriter ( None ) . stripHtml ( res [ <str> ] )  return res  def Year ( self ) : 		 res = MyShowsAPI . getYear ( self ) return res  def Premiered ( self ) : 		 res = MyShowsAPI . get_premiered ( self ) if res : 			 return res  res = TheTVDBAPI . get_premiered ( self ) return res     