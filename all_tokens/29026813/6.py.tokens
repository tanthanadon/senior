 import os , sys , log try : 	 import xbmc , xbmcvfs  except ImportError : pass __DEBUG__ = False class MakeCHDirException ( Exception ) : 	 def __init__ ( self , path ) : 		 self . path = path   def get_filesystem_encoding ( ) : 	 return sys . getfilesystemencoding ( ) if os . name == <str> else <str>  def ensure_unicode ( string , encoding = get_filesystem_encoding ( ) ) : 	 if isinstance ( string , str ) : 		 string = string . decode ( encoding )  if __DEBUG__ : 		 log . debug ( <str> % ( string . encode ( <str> ) , encoding ) )  return string  _cwd = ensure_unicode ( os . getcwd ( ) , get_filesystem_encoding ( ) ) def _is_abs_path ( path ) : 	 if path . startswith ( <str> ) : 		 return True  if <str> in path : 		 return True  if os . name == <str> : 		 import re if re . match ( <str> , path ) : 			 return True  if path . startswith ( <str> ) : 			 return True   return False  def test_path ( path ) : 	 if not _is_abs_path ( path ) : 		 pass  return path  def _get_path ( path , use_unc_path = True ) : 	 errors = <str> try : 		 import xbmcvfs  except ImportError : 		 if path . startswith ( <str> ) and os . name == <str> and use_unc_path : 			 path = path . replace ( <str> , <str> ) . replace ( <str> , <str> )   path = ensure_unicode ( path ) if os . name == <str> : 		 return path  return path . encode ( get_filesystem_encoding ( ) , errors )  def get_path ( path ) : 	 return test_path ( _get_path ( path ) )  def xbmcvfs_path ( path ) : 	 if isinstance ( path , unicode ) : 		 u8path = path . encode ( <str> )  else : 		 u8path = path  if _is_abs_path ( path ) : 		 return xbmc . translatePath ( u8path )  else : 		 return xbmc . translatePath ( os . path . join ( _cwd . encode ( <str> ) , u8path ) )   def exists ( path ) : 	 def xbmcvfs_exists ( path ) : 		 import stat if stat . S_ISDIR ( xbmcvfs . Stat ( xbmcvfs_path ( path ) ) . st_mode ( ) ) : 			 return True  return xbmcvfs . exists ( xbmcvfs_path ( path ) )  def os_path_exists ( path ) : 		 if path . startswith ( <str> ) and os . name == <str> : 			 path = path . replace ( <str> , <str> ) . replace ( <str> , <str> )  return os . path . exists ( get_path ( path ) )  try : 		 if path . startswith ( <str> ) and os . name == <str> : 			 return os_path_exists ( path )  elif <str> in path or ( not _is_abs_path ( path ) and <str> in _cwd ) : 			 return xbmcvfs_exists ( path )  else : 			 return os_path_exists ( path )   except BaseException as e : 		 return False   def getcwd ( ) : 	 if <str> in _cwd : 		 return _cwd  else : 		 try : 			 return ensure_unicode ( os . getcwd ( ) , get_filesystem_encoding ( ) )  except OSError : 			 return _cwd    def makedirs ( path ) : 	 try : 		 return xbmcvfs . mkdirs ( xbmcvfs_path ( path ) )  except ( ImportError , NameError ) : 		 os . makedirs ( get_path ( path ) )   def chdir ( path ) : 	 global _cwd if not _is_abs_path ( path ) : 		 path = join ( _cwd , path )  _cwd = path try : 		 path = xbmcvfs_path ( path ) . decode ( <str> )  except : pass try : 		 os . chdir ( get_path ( path ) )  except : pass  def save_make_chdir ( new_path ) : 	 current = getcwd ( ) try : 		 if not exists ( new_path ) : 			 makedirs ( new_path )  chdir ( new_path )  except BaseException as e : 		 log . print_tb ( e ) raise MakeCHDirException ( current )  finally : 		 return current   from log import dump_context class save_make_chdir_context ( dump_context ) : 	 def __init__ ( self , path , module = <str> , use_timestamp = True ) : 		 self . newPath = path dump_context . __init__ ( self , module , use_timestamp )  def __enter__ ( self ) : 		 if not exists ( self . newPath ) : 			 makedirs ( self . newPath )  return dump_context . __enter__ ( self )   def isfile ( path ) : 	 if not exists ( path ) : 		 return False  try : 		 import stat return stat . S_ISREG ( xbmcvfs . Stat ( xbmcvfs_path ( path ) ) . st_mode ( ) )  except ( ImportError , NameError ) : 		 return os . path . isfile ( get_path ( path ) )   def abspath ( path ) : 	 if <str> in path : 		 return path  return ensure_unicode ( os . path . abspath ( get_path ( path ) ) , get_filesystem_encoding ( ) )  def relpath ( path , start = getcwd ( ) ) : 	 return ensure_unicode ( os . path . relpath ( get_path ( path ) , get_path ( start ) ) , get_filesystem_encoding ( ) )  def normpath ( path ) : 	 return ensure_unicode ( os . path . normpath ( get_path ( path ) ) , get_filesystem_encoding ( ) )  def fopen ( path , mode ) : 	 try : 		 import xbmcvfs from StringIO import StringIO class File ( StringIO ) : 			 def __enter__ ( self ) : 				 return self  def __exit__ ( self , exc_type , exc_val , exc_tb ) : 				 self . close ( ) if exc_type : 					 import traceback traceback . print_exception ( exc_type , exc_val , exc_tb , limit = 10 , file = sys . stderr ) log . debug ( <str> + str ( exc_val ) ) return True   def __init__ ( self , filename , opt = <str> ) : 				 self . opt = opt buf = <str> self . filename = xbmcvfs_path ( filename ) if <str> in opt or <str> in opt : 					 exst = exists ( filename ) if not exst and <str> in opt : 						 from errno import ENOENT raise IOError ( ENOENT , <str> , filename )  if exst : 						 f = xbmcvfs . File ( self . filename ) buf = f . read ( ) f . close ( )   StringIO . __init__ ( self , buf ) if <str> in opt : 					 self . seek ( 0 , mode = 2 )   def write ( self , s ) : 				 if not s : return if not isinstance ( s , str ) : 					 s = str ( s )  StringIO . write ( self , s )  def close ( self ) : 				 if <str> in self . opt or <str> in self . opt or <str> in self . opt : 					 if not self . closed : 						 f = xbmcvfs . File ( self . filename , <str> ) f . write ( self . getvalue ( ) ) f . close ( )   StringIO . close ( self )  def size ( self ) : 				 return self . len   if <str> in mode : 			 return File ( path , <str> )  else : 			 return File ( path , mode )   except BaseException : 		 return open ( get_path ( path ) , mode )   def join ( path , * paths ) : 	 path = _get_path ( path , use_unc_path = False ) fpaths = [ ] for p in paths : 		 fpaths . append ( _get_path ( p ) )  res = ensure_unicode ( os . path . join ( path , * tuple ( fpaths ) ) , get_filesystem_encoding ( ) ) if <str> in res : 		 res = res . replace ( <str> , <str> )  return test_path ( res )  def listdir ( path ) : 	 ld = [ ] try : 		 dirs , files = xbmcvfs . listdir ( xbmcvfs_path ( path ) ) for d in dirs : 			 ld . append ( d . decode ( <str> ) )  for f in files : 			 ld . append ( f . decode ( <str> ) )   except : 		 path = get_path ( path ) if path . startswith ( <str> ) : 			 with save_make_chdir_context ( path , <str> ) : 				 for p in os . listdir ( <str> ) : 					 ld . append ( ensure_unicode ( p ) )    else : 			 for p in os . listdir ( path ) : 				 ld . append ( ensure_unicode ( p ) )    return ld  def remove ( path ) : 	 try : 		 xbmcvfs . delete ( xbmcvfs_path ( path ) )  except : 		 os . remove ( get_path ( path ) )   def copyfile ( src , dst ) : 	 try : 		 xbmcvfs . copy ( xbmcvfs_path ( src ) , xbmcvfs_path ( dst ) )  except : 		 import shutil shutil . copyfile ( get_path ( src ) , get_path ( dst ) )   def movefile ( src , dst ) : 	 try : 		 xbmcvfs . rename ( xbmcvfs_path ( src ) , xbmcvfs_path ( dst ) )  except : 		 import shutil shutil . move ( get_path ( src ) , get_path ( dst ) )   def getmtime ( path ) : 	 try : 		 import stat return xbmcvfs . Stat ( xbmcvfs_path ( path ) ) . st_mtime ( )  except ( ImportError , NameError ) : 		 return os . path . getmtime ( get_path ( path ) )   def getctime ( path ) : 	 try : 		 import stat return xbmcvfs . Stat ( xbmcvfs_path ( path ) ) . st_ctime ( )  except ( ImportError , NameError ) : 		 return os . path . getctime ( get_path ( path ) )   def dirname ( path ) : 	 return ensure_unicode ( os . path . dirname ( _get_path ( path , use_unc_path = False ) ) )  def basename ( path ) : 	 return ensure_unicode ( os . path . basename ( _get_path ( path , use_unc_path = False ) ) )  def touch ( path ) : 	 with fopen ( path , <str> ) : 		 pass   def normseps ( path ) : 	 import re if os . name == <str> : 		 if path . startswith ( <str> ) or re . match ( <str> , path ) : 			 return path . replace ( <str> , <str> )   if <str> in path or path . startswith ( <str> ) : 		 return path . replace ( <str> , <str> )  return path  def test ( ) : 	 tst_name = <str> tst_nam2 = <str> tst_nam3 = <str> tst_name = normseps ( tst_name ) tst_nam2 = normseps ( tst_nam2 ) tst_nam3 = normseps ( tst_nam3 ) log . debug ( <str> % get_filesystem_encoding ( ) ) log . debug ( <str> % getcwd ( ) . encode ( <str> ) ) log . debug ( <str> % relpath ( getcwd ( ) , <str> ) . encode ( <str> ) ) subpath = <str> subpath2 = <str> with save_make_chdir_context ( join ( <str> , subpath ) ) : 		 log . debug ( <str> )  fullpath = join ( getcwd ( ) , subpath , subpath2 ) log . debug ( <str> % subpath . encode ( <str> ) ) log . debug ( <str> % subpath2 . encode ( <str> ) ) log . debug ( <str> % fullpath . encode ( <str> ) ) log . debug ( <str> % ( fullpath , dirname ( fullpath ) ) ) remote_file = <str> if isfile ( remote_file ) : 		 with fopen ( remote_file , <str> ) as f : 			 log . debug ( f . read ( ) )    if __name__ == <str> : 	 __DEBUG__ = True test ( )    