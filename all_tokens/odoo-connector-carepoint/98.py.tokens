import logging import re from os import path from odoo import models , fields from odoo . addons . connector . unit . mapper import ( mapping , only_create , ) from . . unit . backend_adapter import CarepointCRUDAdapter from . . unit . mapper import ( CarepointImportMapper , trim , ) from . . backend import carepoint from . . unit . import_synchronizer import ( DelayedBatchImporter , CarepointImporter , ) try :      from pint import LazyRegistry from pint . util import infer_base_unit ureg = LazyRegistry ( ) ureg . load_definitions ( path . abspath ( path . join ( path . dirname ( __file__ ) , <str> , <str> , <str> , ) ) )  except ImportError :      ureg = None  _logger = logging . getLogger ( __name__ ) class FdbUnit ( models . Model ) :      _inherit = <str> carepoint_bind_ids = fields . One2many ( comodel_name = <str> , inverse_name = <str> , string = <str> , )  class CarepointFdbUnit ( models . Model ) :      _name = <str> _inherit = <str> _inherits = { <str> : <str> } _description = <str> _cp_lib = <str> odoo_id = fields . Many2one ( string = <str> , comodel_name = <str> , required = True , ondelete = <str> )  @ carepoint class FdbUnitAdapter ( CarepointCRUDAdapter ) :      _model_name = <str>  @ carepoint class FdbUnitBatchImporter ( DelayedBatchImporter ) :      _model_name = [ <str> ]  @ carepoint class FdbUnitImportMapper ( CarepointImportMapper ) :      _model_name = <str> direct = [ ( trim ( <str> ) , <str> ) , ( trim ( <str> ) , <str> ) , ( <str> , <str> ) , ] @ mapping def carepoint_id ( self , record ) :          return { <str> : record [ <str> ] . strip ( ) }  def _uom_category_id ( self , unit_root_str ) :          categ_obj = self . env [ <str> ] categ_id = categ_obj . search ( [ ( <str> , <str> , unit_root_str ) , ] , limit = 1 , ) if not len ( categ_id ) :              categ_id = categ_obj . create ( { <str> : unit_root_str , } )  return categ_id  @ mapping @ only_create def uom_id ( self , record ) :          str60 = self . _parse_str60 ( record [ <str> ] ) unit_base = ureg ( str60 ) unit_base_str = str ( unit_base . u ) unit_root = infer_base_unit ( unit_base ) unit_root_str = str ( unit_root ) unit_converted = unit_base . to ( unit_root ) categ_id = self . _uom_category_id ( unit_root_str ) uom_obj = self . env [ <str> ] uom_id = uom_obj . search ( [ ( <str> , <str> , unit_base_str ) , ] ) if len ( uom_id ) :              return { <str> : uom_id [ 0 ] . id }  vals = { <str> : record [ <str> ] . strip ( ) , <str> : categ_id . id , } if unit_base == unit_root :              vals [ <str> ] = <str>  elif unit_converted . m < 0 :              factor = float ( unit_base . m ) / float ( unit_converted . m ) if unit_base . m != 1 :                  factor *= unit_base . m  vals . update ( { <str> : <str> , <str> : factor , } )  else :              factor = float ( unit_converted . m ) / float ( unit_base . m ) if unit_base . m != 1 :                  factor *= unit_base . m  vals . update ( { <str> : <str> , <str> : factor , } )  return vals  def _parse_str60 ( self , str60 ) :          str60 = str60 . strip ( ) match = re . search ( <str> , str60 , re . IGNORECASE ) if match :              return <str> % match . group ( <str> )  match = re . search ( <str> , str60 , re . IGNORECASE ) if match :              return <str> % match . group ( <str> )  return str60   @ carepoint class FdbUnitImporter ( CarepointImporter ) :      _model_name = [ <str> ] _base_mapper = FdbUnitImportMapper   