from __future__ import absolute_import , print_function , unicode_literals import errno import ipaddress import sys import humanreadable as hr import logbook import msgfy import subprocrunner as spr from . __version__ import __version__ from . _argparse_wrapper import ArgparseWrapper from . _capabilities import check_execution_authority from . _common import initialize_cli , is_execute_tc_command , normalize_tc_value from . _const import IPV6_OPTION_ERROR_MSG_FORMAT , ShapingAlgorithm , Tc , TrafficDirection from . _error import ContainerNotFoundError , ModuleNotFoundError , NetworkInterfaceNotFoundError from . _importer import set_tc_from_file from . _logger import logger , set_log_level from . _main import Main from . _netem_param import ( MAX_CORRUPTION_RATE , MAX_PACKET_DUPLICATE_RATE , MAX_PACKET_LOSS_RATE , MAX_REORDERING_RATE , MIN_CORRUPTION_RATE , MIN_PACKET_DUPLICATE_RATE , MIN_PACKET_LOSS_RATE , MIN_REORDERING_RATE , NetemParameter , ) from . _shaping_rule_finder import TcShapingRuleFinder from . traffic_control import TrafficControl def _get_unit_help_msg ( ) :      return <str> . join ( [ <str> . join ( values ) for values in hr . Time . get_text_units ( ) . values ( ) ] )  def get_arg_parser ( ) :      parser = ArgparseWrapper ( __version__ ) if set ( [ <str> , <str> ] ) . intersection ( set ( sys . argv ) ) :          parser . parser . add_argument ( <str> , <str> , required = True , help = <str> )  else :          parser . parser . add_argument ( <str> , help = <str> )  parser . parser . add_argument ( <str> , action = <str> , default = False , help = <str> , ) group = parser . parser . add_mutually_exclusive_group ( ) group . add_argument ( <str> , action = <str> , default = False , help = <str> , ) group . add_argument ( <str> , dest = <str> , action = <str> , default = False , help = , ) group . add_argument ( <str> , dest = <str> , action = <str> , default = False , help = <str> , ) group = parser . parser . add_argument_group ( <str> ) group . add_argument ( <str> , <str> , dest = <str> , help = . format ( <str> . join ( [ <str> . join ( values ) for values in hr . BitPerSecond . get_text_units ( ) . values ( ) ] ) ) , ) group . add_argument ( <str> , dest = <str> , default = Tc . ValueRange . LatencyTime . MIN , help = . format ( min_value = Tc . ValueRange . LatencyTime . MIN , max_value = Tc . ValueRange . LatencyTime . MAX , unit = _get_unit_help_msg ( ) , ) , ) group . add_argument ( <str> , dest = <str> , default = Tc . ValueRange . LatencyTime . MIN , help = . format ( unit = _get_unit_help_msg ( ) ) , ) group . add_argument ( <str> , dest = <str> , default = 0 , help = . format ( MIN_PACKET_LOSS_RATE , MAX_PACKET_LOSS_RATE ) , ) group . add_argument ( <str> , dest = <str> , default = 0 , help = . format ( MIN_PACKET_DUPLICATE_RATE , MAX_PACKET_DUPLICATE_RATE ) , ) group . add_argument ( <str> , dest = <str> , default = 0 , help = . format ( MIN_CORRUPTION_RATE , MAX_CORRUPTION_RATE ) , ) group . add_argument ( <str> , dest = <str> , default = 0 , help = . format ( MIN_REORDERING_RATE , MAX_REORDERING_RATE ) , ) group . add_argument ( <str> , dest = <str> , choices = [ ShapingAlgorithm . HTB , ShapingAlgorithm . TBF ] , default = ShapingAlgorithm . HTB , help = <str> , ) group . add_argument ( <str> , dest = <str> , action = <str> , default = False , help = <str> , ) group = parser . add_routing_group ( ) group . add_argument ( <str> , help = <str> , ) group . add_argument ( <str> , help = <str> , ) group . add_argument ( <str> , help = <str> ) group . add_argument ( <str> , help = <str> ) parser . add_docker_group ( ) return parser . parser  def verify_netem_module ( ) :      import re runner = spr . SubprocessRunner ( <str> ) try :          if runner . run ( ) != 0 :              raise OSError ( runner . returncode , <str> )   except spr . CommandError as e :          logger . debug ( msgfy . to_debug_message ( e ) )  else :          if re . search ( <str> , runner . stdout ) is None :              raise ModuleNotFoundError ( <str> )    class TcSetMain ( Main ) :      def run ( self ) :          return_code_list = [ ] for device in self . _fetch_tc_targets ( ) :              tc = self . __create_tc ( device ) return_code = self . __check_tc ( tc ) if return_code != 0 :                  return_code_list . append ( return_code ) continue  normalize_tc_value ( tc ) if self . _options . overwrite :                  if self . _options . log_level == logbook . INFO :                      set_log_level ( logbook . ERROR )  try :                      tc . delete_all_tc ( )  except NetworkInterfaceNotFoundError :                      pass  set_log_level ( self . _options . log_level )  if ( self . _options . is_add_shaping_rule and TcShapingRuleFinder ( logger = logger , tc = tc ) . is_exist_rule ( ) ) :                  logger . error ( <str> . join ( [ <str> <str> , <str> <str> , <str> <str> , ] ) ) return errno . EINVAL  try :                  return_code_list . append ( tc . set_tc ( ) )  except NetworkInterfaceNotFoundError as e :                  logger . error ( e ) return errno . EINVAL  self . _dump_history ( tc , Tc . Command . TCSET )  return self . _get_return_code ( return_code_list )  def __check_tc ( self , tc ) :          try :              tc . validate ( )  except ( NetworkInterfaceNotFoundError , ContainerNotFoundError ) as e :              logger . error ( e ) return errno . EINVAL  except ipaddress . AddressValueError as e :              logger . error ( IPV6_OPTION_ERROR_MSG_FORMAT . format ( e ) ) return errno . EINVAL  except hr . ParameterError as e :              logger . error ( msgfy . to_error_message ( e ) ) return errno . EINVAL  return 0  def __create_tc ( self , device ) :          options = self . _options return TrafficControl ( device , direction = options . direction , netem_param = NetemParameter ( device = device , bandwidth_rate = options . bandwidth_rate , latency_time = options . network_latency , latency_distro_time = options . latency_distro_time , packet_loss_rate = options . packet_loss_rate , packet_duplicate_rate = options . packet_duplicate_rate , corruption_rate = options . corruption_rate , reordering_rate = options . reordering_rate , ) , dst_network = self . _extract_dst_network ( ) , exclude_dst_network = options . exclude_dst_network , src_network = self . _extract_src_network ( ) , exclude_src_network = options . exclude_src_network , src_port = options . src_port , exclude_src_port = options . exclude_src_port , dst_port = options . dst_port , exclude_dst_port = options . exclude_dst_port , is_ipv6 = options . is_ipv6 , is_change_shaping_rule = options . is_change_shaping_rule , is_add_shaping_rule = options . is_add_shaping_rule , is_enable_iptables = options . is_enable_iptables , shaping_algorithm = options . shaping_algorithm , tc_command_output = options . tc_command_output , )   def main ( ) :      options = get_arg_parser ( ) . parse_args ( ) initialize_cli ( options ) if is_execute_tc_command ( options . tc_command_output ) :          check_execution_authority ( <str> ) if options . direction == TrafficDirection . INCOMING :              check_execution_authority ( <str> )   else :          spr . SubprocessRunner . default_is_dry_run = True  try :          verify_netem_module ( )  except ModuleNotFoundError as e :          logger . debug ( e )  if options . import_setting :          return set_tc_from_file ( logger , options . device , options . overwrite )  spr . SubprocessRunner . clear_history ( ) return TcSetMain ( options ) . run ( )  if __name__ == <str> :      sys . exit ( main ( ) )   