from openerp import models , api , fields , _ from openerp . addons import decimal_precision as dp from datetime import datetime import time from . . models . expense_type import COMPUTE_TYPES class CustomerExpenseWzd ( models . TransientModel ) :      _name = <str> structure_id = fields . Many2one ( <str> , <str> , required = True ) start_date = fields . Date ( <str> , required = True ) end_date = fields . Date ( <str> , required = True ) company_id = fields . Many2one ( <str> , <str> ) use_partner_structure = fields . Boolean ( <str> , help = <str> <str> ) only_summary = fields . Boolean ( <str> , help = <str> ) summary_description = fields . Char ( <str> ) @ api . model def default_get ( self , fields ) :          res = super ( CustomerExpenseWzd , self ) . default_get ( fields ) year = str ( time . strftime ( <str> ) ) date_start = year + <str> + <str> + <str> + <str> date_end = year + <str> + <str> + <str> + <str> structure = False model = self . _context . get ( <str> ) if self . _context . get ( <str> , False ) :              structure = self . env [ model ] . browse ( self . _context [ <str> ] ) . structure_id if not self . _context . get ( <str> , False ) :                  structure = structure or self . env [ model ] . browse ( self . _context [ <str> ] ) . commercial_partner_id . structure_id   res . update ( start_date = date_start , end_date = date_end , structure_id = structure . id if structure else False , company_id = structure . company_id . id if structure else False ) return res  @ api . multi def action_show_expense ( self ) :          res = { } ctx = self . _context . copy ( ) ctx . update ( from_date = self . start_date , to_date = self . end_date ) t_expense_line = self . env [ <str> ] . with_context ( ctx ) t_partner = self . env [ <str> ] t_company = self . env [ <str> ] if not self . _context . get ( <str> , False ) :              return res  if self . _context . get ( <str> , False ) :              partner_ids = [ t_company . browse ( self . _context [ <str> ] ) . partner_id ] line_ids = t_expense_line . get_expense_lines ( self . structure_id , False )  else :              partner_ids = [ partner . commercial_partner_id for partner in t_partner . browse ( self . _context [ <str> ] ) if partner . commercial_partner_id ] partner_ids = list ( set ( partner_ids ) ) line_ids = t_expense_line . get_expense_lines ( self . structure_id , partner_ids )  date_from = datetime . strptime ( self . start_date , <str> ) . strftime ( <str> ) date_to = datetime . strptime ( self . end_date , <str> ) . strftime ( <str> ) partner_name = partner_ids [ 0 ] . name if len ( partner_ids ) == 1 else _ ( <str> ) % ( self . summary_description or <str> ) view_name = _ ( <str> ) % ( partner_name , date_from , date_to ) res = { <str> : str ( [ ( <str> , <str> , line_ids ) ] ) , <str> : view_name , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : True } return res  @ api . multi def action_print_expense ( self ) :          ctx = self . _context . copy ( ) ctx . update ( from_date = self . start_date , to_date = self . end_date ) t_expense_line = self . env [ <str> ] . with_context ( ctx ) t_partner = self . env [ <str> ] t_company = self . env [ <str> ] p_dic = { } if self . _context . get ( <str> , False ) :              partner_ids = [ t_company . browse ( self . _context [ <str> ] ) . partner_id ]  else :              partner_ids = [ partner . commercial_partner_id for partner in t_partner . browse ( self . _context [ <str> ] ) if partner . commercial_partner_id ] partner_ids = list ( set ( partner_ids ) )  use_partner_structure = self . use_partner_structure if len ( partner_ids ) > 1 else False if self . _context . get ( <str> , False ) :              structure = self . structure_id line_ids = t_expense_line . get_expense_lines ( structure , False ) p_dic [ partner_ids [ 0 ] . id ] = ( structure . name , line_ids )  else :              if not self . only_summary :                  for partner in partner_ids :                      structure = use_partner_structure and partner . structure_id or self . structure_id line_ids = t_expense_line . get_expense_lines ( structure , partner ) p_dic [ partner . id ] = ( structure . name , line_ids )   if len ( partner_ids ) > 1 :                  structure = self . structure_id line_ids = t_expense_line . get_expense_lines ( structure , partner_ids ) p_dic [ <str> ] = ( structure . name , line_ids )   custom_data = { <str> : p_dic , <str> : self . start_date , <str> : self . end_date , <str> : self . summary_description } rep_name = <str> rep_action = self . env [ <str> ] . get_action ( self , rep_name ) rep_action [ <str> ] = custom_data return rep_action   class ExpenseLine ( models . TransientModel ) :      _name = <str> name = fields . Char ( <str> ) sales = fields . Float ( <str> , digits = dp . get_precision ( <str> ) ) cost = fields . Float ( <str> , digits = dp . get_precision ( <str> ) ) margin = fields . Float ( <str> , digits = dp . get_precision ( <str> ) ) cost_per = fields . Float ( <str> , digits = ( 12 , 2 ) ) margin_per = fields . Float ( <str> , digits = ( 12 , 2 ) ) totalizator = fields . Boolean ( <str> ) compute_type = fields . Selection ( COMPUTE_TYPES , <str> , required = True , readonly = True , default = <str> ) @ api . model def get_expense_lines ( self , structure_id , partner ) :          line_ids = [ ] line_values_lst = self . _compute_line_values ( partner , structure_id ) line_ids = self . _create_expense_lines ( line_values_lst ) return line_ids  @ api . model def _compute_line_values ( self , partner , structure ) :          res = { } values = [ ] sales = 0.0 last_margin = 0.0 first = True for e in structure . element_ids :              v = { <str> : e . name , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : e . compute_type } amount = 0.0 if e . compute_type == <str> :                  amount = self . _analytic_compute_amount ( e , partner )  elif e . compute_type == <str> :                  amount = self . _invoicing_compute_amount ( e , partner )  elif e . compute_type == <str> :                  parent_id = e . parent_id . id if res . get ( parent_id , False ) :                      amount = res [ parent_id ] [ <str> ] * e . ratio if res [ parent_id ] [ <str> ] :                          amount = res [ parent_id ] [ <str> ] * e . ratio    elif e . compute_type == <str> :                  var_ratio = self . _get_var_ratio ( partner , e , e . ratio_compute_type ) ctx = { <str> : self . _context . get ( <str> , False ) , <str> : self . _context . get ( <str> , False ) } aac = e . expense_type_id . analytic_id amount = aac . with_context ( ctx ) . balance * ( - 1 ) * var_ratio  elif e . compute_type in [ <str> , <str> , <str> , <str> ] :                  if e . compute_type == <str> :                      v [ <str> ] = self . _totalizator ( values , <str> ) v [ <str> ] = ( v [ <str> ] / ( sales or 1.0 ) ) * 100  elif e . compute_type == <str> :                      v [ <str> ] = last_margin v [ <str> ] = ( v [ <str> ] / ( sales or 1.0 ) ) * 100  elif e . compute_type == <str> :                      v [ <str> ] = self . _totalizator ( values , <str> )  elif e . compute_type == <str> :                      v [ <str> ] = self . _totalizator ( values , <str> ) v [ <str> ] = ( v [ <str> ] / ( sales or 1.0 ) ) * 100 v [ <str> ] = last_margin v [ <str> ] = ( v [ <str> ] / ( sales or 1.0 ) ) * 100 v [ <str> ] = self . _totalizator ( values , <str> )  res [ e . id ] = v values . append ( v ) continue  if e . compute_type == <str> :                  col_type = <str>  elif e . compute_type == <str> :                  col_type = e . expense_type_id . col_type  else :                  col_type = <str>  if col_type == <str> :                  if first :                      first = False v [ <str> ] = last_margin = sales = amount * ( - 1 )  else :                      v [ <str> ] = amount * ( - 1 ) last_margin += v [ <str> ] sales += v [ <str> ]   else :                  v [ <str> ] = amount if amount else 0.0  v [ <str> ] = last_margin - v [ <str> ] v [ <str> ] = ( v [ <str> ] / ( sales or 1.0 ) ) * 100 v [ <str> ] = ( v [ <str> ] / ( sales or 1.0 ) ) * 100 last_margin = v [ <str> ] res [ e . id ] = v values . append ( v )  return values  def _get_var_ratio ( self , partner , e , compute_type ) :          res = 0.0 if compute_type == <str> :              res = e . var_ratio  elif compute_type == <str> :              query , params = self . _get_invoice_query ( e , False , <str> ) self . _cr . execute ( query , params ) qres = self . _cr . fetchall ( ) q1 = qres [ 0 ] [ 0 ] if qres [ 0 ] [ 0 ] is not None else 0.0 query , params = self . _get_invoice_query ( e , False , <str> ) self . _cr . execute ( query , params ) qres = self . _cr . fetchall ( ) q2 = qres [ 0 ] [ 0 ] if qres [ 0 ] [ 0 ] is not None else 0.0 t1 = q1 - q2 query , params = self . _get_invoice_query ( e , partner , <str> ) self . _cr . execute ( query , params ) qres = self . _cr . fetchall ( ) q1 = qres [ 0 ] [ 0 ] if qres [ 0 ] [ 0 ] is not None else 0.0 query , params = self . _get_invoice_query ( e , partner , <str> ) self . _cr . execute ( query , params ) qres = self . _cr . fetchall ( ) q2 = qres [ 0 ] [ 0 ] if qres [ 0 ] [ 0 ] is not None else 0.0 t2 = q1 - q2 res = t2 / t1  return res  def _analytic_compute_amount ( self , e , partner ) :          res = 0.0 query , params = self . _get_analytic_query ( e , partner ) if not query :              return res  self . _cr . execute ( query , params ) qres = self . _cr . fetchall ( ) res = qres [ 0 ] [ 0 ] * ( - 1 ) if qres [ 0 ] [ 0 ] is not None else 0.0 return res  def _invoicing_compute_amount ( self , e , partner ) :          res = 0.0 query , params = self . _get_invoice_query ( e , partner , <str> ) self . _cr . execute ( query , params ) qres = self . _cr . fetchall ( ) q1 = qres [ 0 ] [ 0 ] if qres [ 0 ] [ 0 ] is not None else 0.0 query , params = self . _get_invoice_query ( e , partner , <str> ) self . _cr . execute ( query , params ) qres = self . _cr . fetchall ( ) q2 = qres [ 0 ] [ 0 ] if qres [ 0 ] [ 0 ] is not None else 0.0 res = q1 - q2 return res * ( - 1 )  def _get_analytic_query ( self , e , partner ) :          def get_analytic_recursive ( analytic_ids ) :              res = [ ] analytic_obj = self . env [ <str> ] if not analytic_ids :                  return res  aac_ids = [ ] for analytic_id in analytic_ids :                  new_aac_ids = [ analytic_id . id ] while new_aac_ids :                      aac_ids += new_aac_ids analytic_ids_to_browse = new_aac_ids new_aac_ids = [ ] for account in analytic_obj . browse ( analytic_ids_to_browse ) :                          new_aac_ids += map ( lambda x : x . id , [ child for child in account . child_ids if child . state != <str> ] )    res = list ( set ( aac_ids ) ) return res  aac = [ ] if partner :              for partner_id in partner :                  aad = self . env [ <str> ] . search ( [ ( <str> , <str> , partner_id . id ) ] , limit = 1 ) if not aad or len ( aad ) == 0 :                      continue  aac += aad . analytic_id  aac = list ( set ( aac ) ) if not aac :                  return False   aac_ids = get_analytic_recursive ( aac ) exp_type = e . expense_type_id if partner and exp_type . restrict_partner :              query = params = ( self . _context [ <str> ] , self . _context [ <str> ] , e . structure_id . company_id . id , tuple ( x . id for x in partner ) , )  else :              query = params = ( self . _context [ <str> ] , self . _context [ <str> ] , e . structure_id . company_id . id , )  if partner :              query += params += ( tuple ( aac_ids ) , )  if exp_type . journal_ids :              query += params += ( tuple ( x . id for x in exp_type . journal_ids ) , )  if exp_type . product_ids :              product_ids = [ p . id for p in exp_type . product_ids ] query += params += ( tuple ( product_ids ) , )  elif exp_type . categ_id :              domain = [ ( <str> , <str> , exp_type . categ_id . id ) ] prod_objs = self . env [ <str> ] . search ( domain ) product_ids = [ p . id for p in prod_objs ] if product_ids :                  query += params += ( tuple ( product_ids ) , )   return query , params  def _get_invoice_query ( self , e , partner , inv_type ) :          exp_type = e . expense_type_id query = params = ( self . _context [ <str> ] , self . _context [ <str> ] , e . structure_id . company_id . id , inv_type , ) if partner :              query += params += ( tuple ( x . id for x in partner ) , )  if exp_type . product_ids :              product_ids = [ p . id for p in exp_type . product_ids ] query += params += ( tuple ( product_ids ) , )  elif exp_type . categ_id :              domain = [ ( <str> , <str> , exp_type . categ_id . id ) ] prod_objs = self . env [ <str> ] . search ( domain ) product_ids = [ p . id for p in prod_objs ] if product_ids :                  query += params += ( tuple ( product_ids ) , )   return query , params  def _totalizator ( self , values , key ) :          total = 0.0 for v in values :              if v [ <str> ] in [ <str> , <str> , <str> , <str> ] :                  continue  total += v [ key ]  return total  @ api . model def _create_expense_lines ( self , line_values ) :          res = [ ] for v in line_values :              vals = { <str> : v [ <str> ] , <str> : v [ <str> ] , <str> : v [ <str> ] , <str> : v [ <str> ] , <str> : v [ <str> ] , <str> : v [ <str> ] , <str> : v [ <str> ] , } expense_line = self . create ( vals ) res . append ( expense_line . id )  return res    