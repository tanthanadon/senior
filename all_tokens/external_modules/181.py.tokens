from openerp import models , fields , exceptions , api , _ from . format_lang_wrapper import formatLang import openerp . addons . decimal_precision as dp class PurchaseCostDistribution ( models . Model ) :      _name = <str> _description = <str> _order = <str> @ api . one @ api . depends ( <str> , <str> ) def _compute_amount_total ( self ) :          self . amount_total = self . total_purchase + self . total_expense  @ api . one @ api . depends ( <str> , <str> ) def _compute_total_purchase ( self ) :          self . total_purchase = sum ( [ x . total_amount for x in self . cost_lines ] )  @ api . one @ api . depends ( <str> , <str> ) def _compute_total_price_unit ( self ) :          self . total_price_unit = sum ( [ x . product_price_unit for x in self . cost_lines ] )  @ api . one @ api . depends ( <str> , <str> ) def _compute_total_uom_qty ( self ) :          self . total_uom_qty = sum ( [ x . product_qty for x in self . cost_lines ] )  @ api . one @ api . depends ( <str> , <str> ) def _compute_total_weight ( self ) :          self . total_weight = sum ( [ x . total_weight for x in self . cost_lines ] )  @ api . one @ api . depends ( <str> , <str> ) def _compute_total_weight_net ( self ) :          self . total_weight_net = sum ( [ x . total_weight_net for x in self . cost_lines ] )  @ api . one @ api . depends ( <str> , <str> ) def _compute_total_volume ( self ) :          self . total_volume = sum ( [ x . total_volume for x in self . cost_lines ] )  @ api . one @ api . depends ( <str> , <str> ) def _compute_total_expense ( self ) :          self . total_expense = sum ( [ x . expense_amount for x in self . expense_lines ] )  def _expense_lines_default ( self ) :          expenses = self . env [ <str> ] . search ( [ ( <str> , <str> , True ) ] ) return [ { <str> : x , <str> : x . default_amount } for x in expenses ]  name = fields . Char ( string = <str> , required = True , select = True , default = <str> ) company_id = fields . Many2one ( comodel_name = <str> , string = <str> , required = True , default = ( lambda self : self . env [ <str> ] . _company_default_get ( <str> ) ) ) currency_id = fields . Many2one ( comodel_name = <str> , string = <str> , related = <str> ) state = fields . Selection ( [ ( <str> , <str> ) , ( <str> , <str> ) , ( <str> , <str> ) , ( <str> , <str> ) , ( <str> , <str> ) ] , string = <str> , readonly = True , default = <str> ) cost_update_type = fields . Selection ( [ ( <str> , <str> ) ] , string = <str> , default = <str> , required = True ) date = fields . Date ( string = <str> , required = True , readonly = True , select = True , states = { <str> : [ ( <str> , False ) ] } , default = fields . Date . context_today ) total_uom_qty = fields . Float ( compute = _compute_total_uom_qty , readonly = True , digits_compute = dp . get_precision ( <str> ) , string = <str> ) total_weight = fields . Float ( compute = _compute_total_weight , string = <str> , readonly = True , digits_compute = dp . get_precision ( <str> ) ) total_weight_net = fields . Float ( compute = _compute_total_weight_net , digits_compute = dp . get_precision ( <str> ) , string = <str> , readonly = True ) total_volume = fields . Float ( compute = _compute_total_volume , string = <str> , readonly = True ) total_purchase = fields . Float ( compute = _compute_total_purchase , digits_compute = dp . get_precision ( <str> ) , string = <str> ) total_price_unit = fields . Float ( compute = _compute_total_price_unit , string = <str> , digits_compute = dp . get_precision ( <str> ) ) amount_total = fields . Float ( compute = _compute_amount_total , digits_compute = dp . get_precision ( <str> ) , string = <str> ) total_expense = fields . Float ( compute = _compute_total_expense , digits_compute = dp . get_precision ( <str> ) , string = <str> ) note = fields . Text ( string = <str> ) cost_lines = fields . One2many ( comodel_name = <str> , ondelete = <str> , inverse_name = <str> , string = <str> ) expense_lines = fields . One2many ( comodel_name = <str> , ondelete = <str> , inverse_name = <str> , string = <str> , default = _expense_lines_default ) @ api . multi def unlink ( self ) :          for c in self :              if c . state not in ( <str> , <str> ) :                  raise exceptions . Warning ( _ ( <str> ) )   return super ( PurchaseCostDistribution , self ) . unlink ( )  @ api . model def create ( self , vals ) :          if vals . get ( <str> , <str> ) == <str> :              vals [ <str> ] = self . env [ <str> ] . next_by_code ( <str> )  return super ( PurchaseCostDistribution , self ) . create ( vals )  @ api . model def _prepare_expense_line ( self , expense_line , cost_line ) :          distribution = cost_line . distribution if expense_line . type . calculation_method == <str> :              multiplier = cost_line . total_amount if expense_line . affected_lines :                  divisor = sum ( [ x . total_amount for x in expense_line . affected_lines ] )  else :                  divisor = distribution . total_purchase   elif expense_line . type . calculation_method == <str> :              multiplier = cost_line . product_price_unit if expense_line . affected_lines :                  divisor = sum ( [ x . product_price_unit for x in expense_line . affected_lines ] )  else :                  divisor = distribution . total_price_unit   elif expense_line . type . calculation_method == <str> :              multiplier = cost_line . product_qty if expense_line . affected_lines :                  divisor = sum ( [ x . product_qty for x in expense_line . affected_lines ] )  else :                  divisor = distribution . total_uom_qty   elif expense_line . type . calculation_method == <str> :              multiplier = cost_line . total_weight if expense_line . affected_lines :                  divisor = sum ( [ x . total_weight for x in expense_line . affected_lines ] )  else :                  divisor = distribution . total_weight   elif expense_line . type . calculation_method == <str> :              multiplier = cost_line . total_weight_net if expense_line . affected_lines :                  divisor = sum ( [ x . total_weight_net for x in expense_line . affected_lines ] )  else :                  divisor = distribution . total_weight_net   elif expense_line . type . calculation_method == <str> :              multiplier = cost_line . total_volume if expense_line . affected_lines :                  divisor = sum ( [ x . total_volume for x in expense_line . affected_lines ] )  else :                  divisor = distribution . total_volume   elif expense_line . type . calculation_method == <str> :              multiplier = 1 divisor = ( len ( expense_line . affected_lines ) or len ( distribution . cost_lines ) )  else :              raise exceptions . Warning ( _ ( <str> ) )  if divisor :              expense_amount = ( expense_line . expense_amount * multiplier / divisor )  else :              raise exceptions . Warning ( _ ( <str> <str> <str> % cost_line . type . name ) )  return { <str> : expense_line . id , <str> : expense_amount , <str> : expense_amount / cost_line . product_qty , }  @ api . multi def action_calculate ( self ) :          for distribution in self :              if any ( [ not x . expense_amount for x in distribution . expense_lines ] ) :                  raise exceptions . Warning ( _ ( <str> ) )  if not distribution . cost_lines :                  raise exceptions . Warning ( _ ( <str> ) )  for cost_line in distribution . cost_lines :                  cost_line . expense_lines . unlink ( ) expense_lines = [ ] for expense in distribution . expense_lines :                      if ( expense . affected_lines and cost_line not in expense . affected_lines ) :                          continue  expense_lines . append ( self . _prepare_expense_line ( expense , cost_line ) )  cost_line . expense_lines = [ ( 0 , 0 , x ) for x in expense_lines ]  distribution . state = <str>  return True  def _product_price_update ( self , move , new_price ) :          if ( move . location_id . usage == <str> and move . product_id . cost_method == <str> ) :              product = move . product_id domain_quant = [ ( <str> , <str> , product . product_tmpl_id . product_variant_ids . ids ) , ( <str> , <str> , move . quant_ids . ids ) , ( <str> , <str> , <str> ) ] quants = self . env [ <str> ] . search ( domain_quant ) current_valuation = sum ( [ ( q . cost * q . qty ) for q in quants ] ) total_qty = sum ( [ q . qty for q in quants ] ) + move . product_qty if total_qty <= 0 :                  new_std_price = new_price  else :                  new_std_price = ( ( current_valuation + new_price * move . product_qty ) / total_qty )  c = self . _context . copy ( ) company_id = move . company_id . id c . update ( company_id = company_id , force_company = company_id ) product . sudo ( ) . with_context ( c ) . write ( { <str> : new_std_price } )   @ api . one def action_done ( self ) :          for line in self . cost_lines :              if self . cost_update_type == <str> :                  line . move_id . quant_ids . _price_update ( line . standard_price_new ) self . _product_price_update ( line . move_id , line . standard_price_new ) line . move_id . product_price_update_after_done ( )   self . state = <str>  @ api . multi def action_draft ( self ) :          self . write ( { <str> : <str> } ) return True  @ api . one def action_cancel ( self ) :          for line in self . cost_lines :              if self . cost_update_type == <str> :                  if self . currency_id . compare_amounts ( line . move_id . quant_ids [ 0 ] . cost , line . standard_price_new ) != 0 :                      raise exceptions . Warning ( _ ( <str> <str> <str> ) )  line . move_id . quant_ids . _price_update ( line . standard_price_old ) self . _product_price_update ( line . move_id , line . standard_price_old ) line . move_id . product_price_update_after_done ( )   self . state = <str>   class PurchaseCostDistributionLine ( models . Model ) :      _name = <str> _description = <str> @ api . one @ api . depends ( <str> , <str> ) def _compute_total_amount ( self ) :          self . total_amount = self . product_price_unit * self . product_qty  @ api . one @ api . depends ( <str> , <str> ) def _compute_total_weight ( self ) :          self . total_weight = self . product_weight * self . product_qty  @ api . one @ api . depends ( <str> , <str> ) def _compute_total_weight_net ( self ) :          self . total_weight_net = self . product_weight_net * self . product_qty  @ api . one @ api . depends ( <str> , <str> ) def _compute_total_volume ( self ) :          self . total_volume = self . product_volume * self . product_qty  @ api . one @ api . depends ( <str> , <str> ) def _compute_cost_ratio ( self ) :          self . cost_ratio = sum ( [ x . cost_ratio for x in self . expense_lines ] )  @ api . one @ api . depends ( <str> , <str> ) def _compute_expense_amount ( self ) :          self . expense_amount = sum ( [ x . expense_amount for x in self . expense_lines ] )  @ api . one @ api . depends ( <str> , <str> ) def _compute_standard_price_new ( self ) :          self . standard_price_new = self . standard_price_old + self . cost_ratio  @ api . multi @ api . depends ( <str> , <str> , <str> , <str> , <str> , <str> ) def _compute_name ( self ) :          for record in self :              record . name = <str> % ( record . distribution . name , record . picking_id . name , record . product_id . display_name , )   @ api . one @ api . depends ( <str> , <str> ) def _get_product_id ( self ) :          self . product_id = self . move_id . product_id . id  @ api . one @ api . depends ( <str> , <str> ) def _get_product_qty ( self ) :          self . product_qty = self . move_id . product_qty  @ api . one @ api . depends ( <str> ) def _get_standard_price_old ( self ) :          self . standard_price_old = ( self . move_id and self . move_id . get_price_unit ( self . move_id ) or 0.0 )  name = fields . Char ( string = <str> , compute = <str> , store = True , ) distribution = fields . Many2one ( comodel_name = <str> , string = <str> , ondelete = <str> , required = True ) move_id = fields . Many2one ( comodel_name = <str> , string = <str> , ondelete = <str> , required = True ) purchase_line_id = fields . Many2one ( comodel_name = <str> , string = <str> , related = <str> ) purchase_id = fields . Many2one ( comodel_name = <str> , string = <str> , readonly = True , related = <str> , store = True ) partner = fields . Many2one ( comodel_name = <str> , string = <str> , readonly = True , related = <str> ) picking_id = fields . Many2one ( <str> , string = <str> , related = <str> , store = True ) product_id = fields . Many2one ( comodel_name = <str> , string = <str> , store = True , compute = <str> ) product_qty = fields . Float ( string = <str> , compute = <str> , store = True ) product_uom = fields . Many2one ( comodel_name = <str> , string = <str> , related = <str> ) product_uos_qty = fields . Float ( string = <str> , related = <str> ) product_uos = fields . Many2one ( comodel_name = <str> , string = <str> , related = <str> ) product_price_unit = fields . Float ( string = <str> , related = <str> ) expense_lines = fields . One2many ( comodel_name = <str> , inverse_name = <str> , string = <str> ) product_volume = fields . Float ( string = <str> , help = <str> , related = <str> ) product_weight = fields . Float ( string = <str> , related = <str> , help = <str> ) product_weight_net = fields . Float ( string = <str> , related = <str> , help = <str> ) standard_price_old = fields . Float ( string = <str> , compute = <str> , store = True , digits_compute = dp . get_precision ( <str> ) ) expense_amount = fields . Float ( string = <str> , digits_compute = dp . get_precision ( <str> ) , compute = <str> ) cost_ratio = fields . Float ( string = <str> , compute = <str> ) standard_price_new = fields . Float ( string = <str> , digits_compute = dp . get_precision ( <str> ) , compute = <str> ) total_amount = fields . Float ( compute = _compute_total_amount , string = <str> , digits_compute = dp . get_precision ( <str> ) ) total_weight = fields . Float ( compute = _compute_total_weight , string = <str> , store = True , digits_compute = dp . get_precision ( <str> ) , help = <str> ) total_weight_net = fields . Float ( compute = _compute_total_weight_net , string = <str> , digits_compute = dp . get_precision ( <str> ) , store = True , help = <str> ) total_volume = fields . Float ( compute = _compute_total_volume , string = <str> , store = True , help = <str> ) company_id = fields . Many2one ( comodel_name = <str> , related = <str> , store = True , )  class PurchaseCostDistributionLineExpense ( models . Model ) :      _name = <str> _description = <str> @ api . one @ api . depends ( <str> , <str> ) def _get_picking_id ( self ) :          self . picking_id = self . distribution_line . picking_id . id  @ api . one @ api . depends ( <str> , <str> ) def _get_distribution ( self ) :          self . distribution = self . distribution_line . distribution . id  @ api . one @ api . depends ( <str> , <str> ) def _get_product_id ( self ) :          self . product_id = self . distribution_line . product_id . id  @ api . one @ api . depends ( <str> , <str> ) def _get_company_id ( self ) :          self . company_id = self . distribution_line . company_id . id  distribution_line = fields . Many2one ( comodel_name = <str> , string = <str> , ondelete = <str> , ) picking_id = fields . Many2one ( comodel_name = <str> , string = <str> , store = True , compute = <str> ) picking_date_done = fields . Datetime ( related = <str> , store = True , readonly = True , ) distribution = fields . Many2one ( comodel_name = <str> , string = <str> , store = True , compute = <str> ) product_id = fields . Many2one ( comodel_name = <str> , string = <str> , store = True , compute = <str> ) distribution_expense = fields . Many2one ( comodel_name = <str> , string = <str> , ondelete = <str> , ) type = fields . Many2one ( <str> , string = <str> , readonly = True , related = <str> , store = True , ) expense_amount = fields . Float ( string = <str> , digits_compute = dp . get_precision ( <str> ) , ) cost_ratio = fields . Float ( <str> ) company_id = fields . Many2one ( comodel_name = <str> , string = <str> , store = True , compute = <str> ) @ api . multi def action_open_distribution ( self ) :          res = { <str> : <str> , <str> : <str> , <str> : <str> , <str> : self . distribution_expense . distribution . id , <str> : <str> , <str> : True } return res   class PurchaseCostDistributionExpense ( models . Model ) :      _name = <str> _description = <str> _rec_name = <str> @ api . one @ api . depends ( <str> , <str> ) def _get_imported_lines ( self ) :          self . imported_lines = self . env [ <str> ] self . imported_lines |= self . distribution . cost_lines  distribution = fields . Many2one ( comodel_name = <str> , string = <str> , select = True , ondelete = <str> , required = True ) ref = fields . Char ( string = <str> ) type = fields . Many2one ( comodel_name = <str> , string = <str> , select = True , ondelete = <str> ) calculation_method = fields . Selection ( string = <str> , related = <str> , readonly = True ) imported_lines = fields . Many2many ( comodel_name = <str> , string = <str> , compute = <str> ) affected_lines = fields . Many2many ( comodel_name = <str> , column1 = <str> , relation = <str> , column2 = <str> , string = <str> , help = <str> <str> , domain = <str> ) expense_amount = fields . Float ( string = <str> , digits_compute = dp . get_precision ( <str> ) , required = True ) invoice_line = fields . Many2one ( comodel_name = <str> , string = <str> , domain = <str> <str> ) invoice_id = fields . Many2one ( comodel_name = <str> , string = <str> ) display_name = fields . Char ( compute = <str> , store = True ) company_id = fields . Many2one ( comodel_name = <str> , related = <str> , store = True , ) @ api . one @ api . depends ( <str> , <str> , <str> , <str> ) def _compute_display_name ( self ) :          self . display_name = <str> % ( self . distribution . name , self . type . name , self . ref , formatLang ( self . env , self . expense_amount , currency_obj = self . distribution . currency_id ) )  @ api . onchange ( <str> ) def onchange_type ( self ) :          if self . type and self . type . default_amount :              self . expense_amount = self . type . default_amount   @ api . onchange ( <str> ) def onchange_invoice_line ( self ) :          self . invoice_id = self . invoice_line . invoice_id . id self . expense_amount = self . invoice_line . price_subtotal  @ api . multi def button_duplicate ( self ) :          for expense in self :              expense . copy ( )     