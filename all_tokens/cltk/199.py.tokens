import re from Levenshtein import distance from cltk . prosody . latin . verse import Verse from cltk . prosody . latin . metrical_validator import MetricalValidator from cltk . prosody . latin . scansion_constants import ScansionConstants from cltk . prosody . latin . scansion_formatter import ScansionFormatter from cltk . prosody . latin . syllabifier import Syllabifier import cltk . prosody . latin . string_utils as string_utils from cltk . prosody . latin . verse_scanner import VerseScanner __author__ = [ <str> ] __license__ = <str> class PentameterScanner ( VerseScanner ) :      def __init__ ( self , constants = ScansionConstants ( ) , syllabifier = Syllabifier ( ) , optional_transform : bool = False , * args , ** kwargs ) :          super ( ) . __init__ ( * args , ** kwargs ) self . constants = constants self . remove_punct_map = string_utils . remove_punctuation_dict ( ) self . punctuation_substitutions = string_utils . punctuation_for_spaces_dict ( ) self . metrical_validator = MetricalValidator ( constants ) self . formatter = ScansionFormatter ( constants ) self . syllabifier = syllabifier self . optional_transform = optional_transform self . inverted_amphibrach_re = re . compile ( <str> . format ( self . constants . STRESSED , self . constants . UNSTRESSED , self . constants . STRESSED ) ) self . syllable_matcher = re . compile ( <str> . format ( self . constants . VOWELS + self . constants . ACCENTED_VOWELS + self . constants . LIQUIDS + self . constants . MUTES ) ) self . SPONDAIC_PENTAMETER = self . constants . SPONDEE + self . constants . SPONDEE + self . constants . STRESSED + self . constants . DACTYL + self . constants . DACTYL + self . constants . OPTIONAL_ENDING self . DACTYLIC_PENTAMETER = self . constants . DACTYL + self . constants . DACTYL + self . constants . STRESSED + self . constants . DACTYL + self . constants . DACTYL + self . constants . OPTIONAL_ENDING  def scan ( self , original_line : str , optional_transform : bool = False ) -> Verse :          verse = Verse ( original_line , meter = <str> ) line = original_line . translate ( self . punctuation_substitutions ) line = self . transform_i_to_j ( line ) working_line = self . elide_all ( line ) working_line = self . accent_by_position ( working_line ) syllables = self . syllabifier . syllabify ( working_line ) if optional_transform :              working_line = self . transform_i_to_j_optional ( line ) working_line = self . elide_all ( working_line ) working_line = self . accent_by_position ( working_line ) syllables = self . syllabifier . syllabify ( working_line ) verse . scansion_notes += [ self . constants . NOTE_MAP [ <str> ] ]  verse . working_line = working_line verse . syllable_count = self . syllabifier . get_syllable_count ( syllables ) verse . syllables = syllables if verse . syllable_count < 12 :              verse . valid = False verse . scansion_notes += [ self . constants . NOTE_MAP [ <str> ] ] return verse  stresses = self . flag_dipthongs ( syllables ) syllables_wspaces = string_utils . to_syllables_with_trailing_spaces ( working_line , syllables ) offset_map = self . calc_offset ( syllables_wspaces ) for idx , syl in enumerate ( syllables ) :              for accented in self . constants . ACCENTED_VOWELS :                  if accented in syl :                      stresses . append ( idx )    stresses . append ( 0 ) stresses . append ( verse . syllable_count - 2 ) verse . scansion = self . produce_scansion ( stresses , syllables_wspaces , offset_map ) if len ( string_utils . stress_positions ( self . constants . STRESSED , verse . scansion ) ) != len ( set ( stresses ) ) :              verse . valid = False verse . scansion_notes += [ self . constants . NOTE_MAP [ <str> ] ] return verse  if self . metrical_validator . is_valid_pentameter ( verse . scansion ) :              verse . scansion_notes += [ self . constants . NOTE_MAP [ <str> ] ] return self . assign_candidate ( verse , verse . scansion )  if verse . syllable_count == 12 :              candidate = self . make_spondaic ( verse . scansion ) verse . scansion_notes += [ self . constants . NOTE_MAP [ <str> ] ] return self . assign_candidate ( verse , candidate )  if verse . syllable_count == 14 :              candidate = self . make_dactyls ( verse . scansion ) verse . scansion_notes += [ self . constants . NOTE_MAP [ <str> ] ] return self . assign_candidate ( verse , candidate )  if verse . syllable_count > 14 :              verse . valid = False verse . scansion_notes += [ self . constants . NOTE_MAP [ <str> ] ] return verse  smoothed = self . correct_first_two_dactyls ( verse . scansion ) if distance ( verse . scansion , smoothed ) > 0 :              verse . scansion_notes += [ self . constants . NOTE_MAP [ <str> ] ] verse . scansion = smoothed stresses += string_utils . differences ( verse . scansion , smoothed )  if self . metrical_validator . is_valid_pentameter ( verse . scansion ) :              return self . assign_candidate ( verse , verse . scansion )  smoothed = self . correct_penultimate_dactyl_chain ( verse . scansion ) if distance ( verse . scansion , smoothed ) > 0 :              verse . scansion_notes += [ self . constants . NOTE_MAP [ <str> ] ] verse . scansion = smoothed stresses += string_utils . differences ( verse . scansion , smoothed )  if self . metrical_validator . is_valid_pentameter ( verse . scansion ) :              return self . assign_candidate ( verse , verse . scansion )  candidates = self . metrical_validator . closest_pentameter_patterns ( verse . scansion ) if candidates is not None :              if len ( candidates ) == 1 and len ( verse . scansion . replace ( <str> , <str> ) ) == len ( candidates [ 0 ] ) and len ( string_utils . differences ( verse . scansion , candidates [ 0 ] ) ) == 1 :                  tmp_scansion = self . produce_scansion ( string_utils . differences ( verse . scansion , candidates [ 0 ] ) , syllables_wspaces , offset_map ) if self . metrical_validator . is_valid_pentameter ( tmp_scansion ) :                      verse . scansion_notes += [ self . constants . NOTE_MAP [ <str> ] ] return self . assign_candidate ( verse , tmp_scansion )    if self . optional_transform and not verse . valid :              return self . scan ( original_line , optional_transform = True )  verse . accented = self . formatter . merge_line_scansion ( verse . original , verse . scansion ) return verse  def make_spondaic ( self , scansion : str ) -> str :          mark_list = string_utils . mark_list ( scansion ) vals = list ( scansion . replace ( <str> , <str> ) ) new_vals = self . SPONDAIC_PENTAMETER [ : - 1 ] + vals [ - 1 ] corrected = <str> . join ( new_vals ) new_line = list ( <str> * len ( scansion ) ) for idx , car in enumerate ( corrected ) :              new_line [ mark_list [ idx ] ] = car  return <str> . join ( new_line )  def make_dactyls ( self , scansion : str ) -> str :          mark_list = string_utils . mark_list ( scansion ) vals = list ( scansion . replace ( <str> , <str> ) ) new_vals = self . DACTYLIC_PENTAMETER [ : - 1 ] + vals [ - 1 ] corrected = <str> . join ( new_vals ) new_line = list ( <str> * len ( scansion ) ) for idx , car in enumerate ( corrected ) :              new_line [ mark_list [ idx ] ] = car  return <str> . join ( new_line )  def correct_penultimate_dactyl_chain ( self , scansion : str ) -> str :          mark_list = string_utils . mark_list ( scansion ) vals = list ( scansion . replace ( <str> , <str> ) ) n_vals = vals [ : - 7 ] + [ self . constants . DACTYL + self . constants . DACTYL ] + [ vals [ - 1 ] ] corrected = <str> . join ( n_vals ) new_line = list ( <str> * len ( scansion ) ) for idx , car in enumerate ( corrected ) :              new_line [ mark_list [ idx ] ] = car  return <str> . join ( new_line )    