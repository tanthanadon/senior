__author__ = [ <str> , <str> ] __license__ = <str> __version__ = <str> import unicodedata import sys try :      unicode = unicode  except NameError :      str = str unicode = str bytes = bytes basestring = ( str , bytes )  else :      str = str unicode = unicode bytes = str basestring = basestring  characterBlocks = { } _names = { } UNRECOGNISED_FAIL = 0 UNRECOGNISED_ECHO = 1 UNRECOGNISED_SUBSTITUTE = 2 options = { } def resetOptions ( ) :      global options defaultOptions = { <str> : <str> , <str> : <str> , <str> : <str> , <str> : UNRECOGNISED_FAIL , <str> : False , } options = defaultOptions . copy ( )  resetOptions ( ) def _unrecognised ( achr ) :      if options [ <str> ] == UNRECOGNISED_ECHO :          return achr  elif options [ <str> ] == UNRECOGNISED_SUBSTITUTE :          return options [ <str> ]  else :          raise KeyError ( achr )   def py23char ( x ) :      return chr ( x )  class TLCharacter ( object ) :      def __init__ ( self , unicodeHexValue , block ) :          if unicodeHexValue < 0 or unicodeHexValue > 0x10FFFF :              raise ValueError ( <str> )  self . unicodeHexValue = unicodeHexValue self . unichr = py23char ( self . unicodeHexValue ) self . name = unicodedata . name ( self . unichr ) self . equivalents = { } self . _block = block  def addEquivalent ( self , equivName , equivalent ) :          self . equivalents [ equivName ] = equivalent   class CharacterBlock ( dict ) :      def __init__ ( self , name , charRange , charClass = TLCharacter ) :          charRange . sort ( ) for c in charRange :              try :                  tlchar = charClass ( c , self ) self [ tlchar . unichr ] = tlchar  except ValueError :                  pass   self . _longestEntry = 1 self . name = name self . transliterationSchemes = { } self . _register ( )  def _register ( self ) :          characterBlocks [ self . name ] = self _names [ self . name . upper ( ) ] = self  def _transliterate ( self , text , outFormat ) :          result = [ ] for c in text :              if c . isspace ( ) : result . append ( c ) try :                  result . append ( self [ c ] . equivalents [ outFormat . name ] )  except KeyError :                  result . append ( _unrecognised ( c ) )   return result  def _preprocess ( self , text ) :          return text  def _getNextChar ( self , text , startPos ) :          return text [ startPos ]   class TransliterationScheme ( dict ) :      def __init__ ( self , blockName , schemeName , data , swapTable = None ) :          self . block = characterBlocks [ blockName ] self . name = schemeName for equiv , unicodeHexValue in data . items ( ) :              self [ equiv ] = self . block [ py23char ( unicodeHexValue ) ] self [ equiv ] . addEquivalent ( self . name , equiv )  self . _longestEntry = max ( [ len ( e ) for e in list ( data . keys ( ) ) ] ) if self . _longestEntry > 1 :              self . _parseTree = { } self . _parsedata = list ( data . keys ( ) ) self . _parsedata . sort ( ) self . _setupParseTree ( 0 , len ( data ) - 1 , 0 , self . _parseTree )  if swapTable is not None :              if not isinstance ( swapTable , dict ) : raise TypeError  self . swapTable = swapTable self . _register ( )  def _register ( self ) :          self . block . transliterationSchemes [ self . name ] = self _names [ self . name . upper ( ) ] = self  def _setupParseTree ( self , rowFrom , rowTo , colIndex , tree ) :          if colIndex == self . _longestEntry :              return  prevchar = None rowIndex = rowFrom while rowIndex <= rowTo :              if colIndex < len ( self . _parsedata [ rowIndex ] ) :                  c = self . _parsedata [ rowIndex ] [ colIndex ] if c != prevchar :                      tree [ c ] = { } if prevchar is not None :                          self . _setupParseTree ( rowFrom , rowIndex - 1 , colIndex + 1 , tree [ prevchar ] )  rowFrom = rowIndex prevchar = c  if rowIndex == rowTo :                      self . _setupParseTree ( rowFrom , rowIndex , colIndex + 1 , tree [ prevchar ] )   rowIndex = rowIndex + 1   def __getNextChar ( self , text , startPos , tree ) :          i = startPos matched = text [ i ] if i < len ( text ) - 1 :              try :                  if text [ i + 1 ] in tree [ text [ i ] ] :                      matched = matched + self . __getNextChar ( text , i + 1 , tree [ text [ i ] ] )   except KeyError :                  pass   return matched  def _getNextChar ( self , text , startPos ) :          if self . _longestEntry > 1 and not text [ startPos ] . isspace ( ) :              return self . __getNextChar ( text , startPos , self . _parseTree )  else :              return text [ startPos ]   def _preprocess ( self , text ) :          if self . swapTable :              for c in self . swapTable :                  if isinstance ( text , bytes ) :                 	 text = text . decode ( )  text = text . replace ( c , self . swapTable [ c ] )   return text  def _transliterate ( self , text , outFormat ) :          result = [ ] text = self . _preprocess ( text ) i = 0 while i < len ( text ) :              if text [ i ] . isspace ( ) :                  result . append ( text [ i ] ) i = i + 1  else :                  chr = self . _getNextChar ( text , i ) try :                      result . append ( self [ chr ] . unichr )  except KeyError :                      result . append ( _unrecognised ( chr ) )  i = i + len ( chr )   return result   def transliterate ( text , inFormat , outFormat , requestOptions = { } ) :      def asciiEncode ( chr ) :          value = ord ( chr ) if value > 255 :              return <str> % ( value )  return chr  try :          options . update ( requestOptions ) if isinstance ( text , str ) :              try :                  text = text . decode ( options [ <str> ] )  except :             	 pass   def findFormat ( fmt ) :              if isinstance ( fmt , basestring ) :                  try :                      fmt = _names [ fmt . upper ( ) ]  except KeyError :                      raise ValueError ( <str> + fmt )   return fmt  inFormat = findFormat ( inFormat ) outFormat = findFormat ( outFormat ) if not isinstance ( text , basestring ) :                  raise TypeError ( <str> )  def getBlock ( format ) :              if isinstance ( format , CharacterBlock ) :                  return format  else :                  return format . block   inBlock = getBlock ( inFormat ) outBlock = getBlock ( outFormat ) if not inBlock is outBlock :              raise ValueError ( <str> )  if inFormat is outFormat :              if inFormat . _longestEntry == 1 :                  [ inFormat [ c ] for c in set ( text ) if not c . isspace ( ) ] return text   result = inFormat . _transliterate ( text , outFormat ) if options [ <str> ] :              result = [ asciiEncode ( c ) for c in result ]  return <str> . join ( result ) . encode ( options [ <str> ] )  finally :          resetOptions ( )   class DevanagariCharacter ( TLCharacter ) :      _vowelOffset = 0x93E - 0x906 _depVowelRange = list ( range ( 0x93E , 0x94D ) ) + [ 0x962 , 0x963 ] _vowelRange = list ( range ( 0x904 , 0x915 ) ) + [ 0x960 , 0x961 ] _VIRAMA = py23char ( 0x94D ) _LETTER_A = py23char ( 0x905 ) _AGRAVAHA = 0x93D _OM = 0x950 def __init__ ( self , unicodeHexValue , block ) :          TLCharacter . __init__ ( self , unicodeHexValue , block ) self . isVowel = False if unicodeHexValue in DevanagariCharacter . _vowelRange :              self . isVowel = True  self . _dependentVowel = None if unicodeHexValue == 0x960 :              self . _setDependentVowel ( 0x944 )  if unicodeHexValue in DevanagariCharacter . _depVowelRange :              vowel = None if unicodeHexValue == 0x962 :                  vowel = block [ py23char ( 0x90C ) ]  elif unicodeHexValue == 0x963 :                  vowel = block [ py23char ( 0x961 ) ]  elif unicodeHexValue == 0x944 :                  pass  else :                  vowel = block [ py23char ( unicodeHexValue - DevanagariCharacter . _vowelOffset ) ]  if vowel is not None :                  vowel . _setDependentVowel ( unicodeHexValue )  raise ValueError  self . isConsonant = False if self . isVowel == False and self . unichr . isalpha ( ) and self . unicodeHexValue not in ( DevanagariCharacter . _AGRAVAHA , DevanagariCharacter . _OM ) :              self . isConsonant = True   def _setDependentVowel ( self , unicodeHexValue ) :          if unicodeHexValue is not None :              if not self . isVowel : raise ValueError self . _dependentVowel = py23char ( unicodeHexValue ) self . _block [ py23char ( unicodeHexValue ) ] = self    class _Devanagari ( object ) :      def _transliterate ( self , text , outFormat ) :          def getResult ( ) :              if curMatch . isspace ( ) :                  result . append ( curMatch ) return  if prevMatch in self :                  prev = self [ prevMatch ]  else :                  prev = None  if nextMatch in self :                  next = self [ nextMatch ]  else :                  next = None  try :                  equiv = outFormat . _equivalent ( self [ curMatch ] , prev , next , self . _implicitA )  except KeyError :                  equiv = _unrecognised ( curMatch )  for e in equiv :                  result . append ( e )   def incr ( c ) :              if self . _longestEntry == 1 :                  return 1  return len ( c )  result = [ ] try :              text = text . decode ( )  except :         	 pass  text = self . _preprocess ( text ) i = 0 prevMatch = None nextMatch = None curMatch = self . _getNextChar ( text , i ) i = i + len ( curMatch ) while i < len ( text ) :              nextMatch = self . _getNextChar ( text , i ) getResult ( ) i = i + len ( nextMatch ) prevMatch = curMatch curMatch = nextMatch nextMatch = None  getResult ( ) return result   class DevanagariCharacterBlock ( CharacterBlock , _Devanagari ) :      def __init__ ( self , name , charRange ) :          CharacterBlock . __init__ ( self , name , charRange , DevanagariCharacter ) self . _implicitA = True  def _transliterate ( self , text , outFormat ) :          return _Devanagari . _transliterate ( self , text , outFormat )  def _equivalent ( self , char , prev , next , implicitA ) :          result = [ ] if char . isVowel == False :              result . append ( char . unichr ) if char . isConsonant and ( ( next is not None and next . isConsonant ) or next is None ) :                  result . append ( DevanagariCharacter . _VIRAMA )   else :              if prev is None or prev . isConsonant == False :                  result . append ( char . unichr )  else :                  if char . _dependentVowel is not None :                      result . append ( char . _dependentVowel )    return result   class DevanagariTransliterationScheme ( TransliterationScheme , _Devanagari ) :      def __init__ ( self , blockName , schemeName , data , swapTable = None ) :          TransliterationScheme . __init__ ( self , blockName , schemeName , data , swapTable ) self . _implicitA = False  def _transliterate ( self , text , outFormat ) :          return _Devanagari . _transliterate ( self , text , outFormat )  def _equivalent ( self , char , prev , next , implicitA ) :          result = [ ] if char . unichr != DevanagariCharacter . _VIRAMA :              result . append ( char . equivalents [ self . name ] )  if implicitA and char . isConsonant and ( ( next is not None and next . unichr != DevanagariCharacter . _VIRAMA and not next . isVowel ) or next is None ) :              result . append ( characterBlocks [ <str> ] [ DevanagariCharacter . _LETTER_A ] . equivalents [ self . name ] )  return result   DevanagariCharacterBlock ( <str> , list ( range ( 0x900 , 0x97F ) ) ) HARVARDKYOTO = { <str> : 0x902 , <str> : 0x903 , <str> : 0x905 , <str> : 0x906 , <str> : 0x907 , <str> : 0x908 , <str> : 0x909 , <str> : 0x90A , <str> : 0x90B , <str> : 0x90C , <str> : 0x90F , <str> : 0x910 , <str> : 0x913 , <str> : 0x914 , <str> : 0x915 , <str> : 0x916 , <str> : 0x917 , <str> : 0x918 , <str> : 0x919 , <str> : 0x91A , <str> : 0x91B , <str> : 0x91C , <str> : 0x91D , <str> : 0x91E , <str> : 0x91F , <str> : 0x920 , <str> : 0x921 , <str> : 0x922 , <str> : 0x923 , <str> : 0x924 , <str> : 0x925 , <str> : 0x926 , <str> : 0x927 , <str> : 0x928 , <str> : 0x92A , <str> : 0x92B , <str> : 0x92C , <str> : 0x92D , <str> : 0x92E , <str> : 0x92F , <str> : 0x930 , <str> : 0x932 , <str> : 0x935 , <str> : 0x936 , <str> : 0x937 , <str> : 0x938 , <str> : 0x939 , <str> : 0x93D , <str> : 0x950 , } DevanagariTransliterationScheme ( <str> , <str> , HARVARDKYOTO ) ITRANS = { <str> : 0x931 , <str> : 0x902 , <str> : 0x902 , <str> : 0x902 , <str> : 0x903 , <str> : 0x905 , <str> : 0x906 , <str> : 0x906 , <str> : 0x907 , <str> : 0x908 , <str> : 0x908 , <str> : 0x909 , <str> : 0x90A , <str> : 0x90A , <str> : 0x90B , <str> : 0x90B , <str> : 0x960 , <str> : 0x960 , <str> : 0x90C , <str> : 0x90C , <str> : 0x961 , <str> : 0x961 , <str> : 0x90E , <str> : 0x90F , <str> : 0x910 , <str> : 0x912 , <str> : 0x913 , <str> : 0x914 , <str> : 0x915 , <str> : 0x916 , <str> : 0x917 , <str> : 0x918 , <str> : 0x919 , <str> : 0x91A , <str> : 0x91A , <str> : 0x91B , <str> : 0x91C , <str> : 0x91D , <str> : 0x91E , <str> : 0x91F , <str> : 0x920 , <str> : 0x921 , <str> : 0x922 , <str> : 0x923 , <str> : 0x924 , <str> : 0x936 , <str> : 0x925 , <str> : 0x926 , <str> : 0x927 , <str> : 0x928 , <str> : 0x92A , <str> : 0x92B , <str> : 0x92C , <str> : 0x92D , <str> : 0x92E , <str> : 0x92F , <str> : 0x930 , <str> : 0x932 , <str> : 0x933 , <str> : 0x933 , <str> : 0x934 , <str> : 0x935 , <str> : 0x935 , <str> : 0x936 , <str> : 0x937 , <str> : 0x938 , <str> : 0x939 , <str> : 0x93D , <str> : 0x950 , <str> : 0x950 , <str> : 0x0964 , <str> : 0x0965 , <str> : 0x0966 , <str> : 0x0967 , <str> : 0x0968 , <str> : 0x0969 , <str> : 0x096A , <str> : 0x096B , <str> : 0x096C , <str> : 0x096D , <str> : 0x096E , <str> : 0x096F , <str> : 0x903 , <str> : 0x919 , <str> : 0x937 , <str> : 0x91E , } _swapTable = { <str> : <str> , <str> : <str> , <str> : <str> , } DevanagariTransliterationScheme ( <str> , <str> , ITRANS , _swapTable ) IAST = { py23char ( 0x1E43 ) : 0x902 , py23char ( 0x1E25 ) : 0x903 , <str> : 0x905 , py23char ( 0x101 ) : 0x906 , <str> : 0x907 , py23char ( 0x12B ) : 0x908 , <str> : 0x909 , py23char ( 0x16B ) : 0x90A , py23char ( 0x1E5B ) : 0x90B , py23char ( 0x1E37 ) : 0x90C , <str> : 0x90F , <str> : 0x910 , <str> : 0x913 , <str> : 0x914 , <str> : 0x915 , <str> : 0x916 , <str> : 0x917 , <str> : 0x918 , py23char ( 0x1E45 ) : 0x919 , <str> : 0x91A , <str> : 0x91B , <str> : 0x91C , <str> : 0x91D , py23char ( 0xF1 ) : 0x91E , py23char ( 0x1E6D ) : 0x91F , py23char ( 0x1E6D ) + <str> : 0x920 , py23char ( 0x1E0D ) : 0x921 , py23char ( 0x1E0D ) + <str> : 0x922 , py23char ( 0x1E47 ) : 0x923 , <str> : 0x924 , <str> : 0x925 , <str> : 0x926 , <str> : 0x927 , <str> : 0x928 , <str> : 0x92A , <str> : 0x92B , <str> : 0x92C , <str> : 0x92D , <str> : 0x92E , <str> : 0x92F , <str> : 0x930 , <str> : 0x932 , <str> : 0x935 , py23char ( 0x15B ) : 0x936 , py23char ( 0x1E63 ) : 0x937 , <str> : 0x938 , <str> : 0x939 , <str> : 0x93D , <str> + py23char ( 0x1E43 ) : 0x950 , <str> : 0x0964 , <str> : 0x0965 , <str> : 0x0966 , <str> : 0x0967 , <str> : 0x0968 , <str> : 0x0969 , <str> : 0x096A , <str> : 0x096B , <str> : 0x096C , <str> : 0x096D , <str> : 0x096E , <str> : 0x096F , } DevanagariTransliterationScheme ( <str> , <str> , IAST ) CharacterBlock ( <str> , list ( range ( 0x400 , 0x510 ) ) ) _ISO9RUS = { py23char ( 0x0CB ) : 0x401 , <str> : 0x410 , <str> : 0x411 , <str> : 0x412 , <str> : 0x413 , <str> : 0x414 , <str> : 0x415 , py23char ( 0x17D ) : 0x416 , <str> : 0x417 , <str> : 0x418 , <str> : 0x419 , <str> : 0x41a , <str> : 0x41b , <str> : 0x41c , <str> : 0x41d , <str> : 0x41e , <str> : 0x41f , <str> : 0x420 , <str> : 0x421 , <str> : 0x422 , <str> : 0x423 , <str> : 0x424 , <str> : 0x425 , <str> : 0x426 , py23char ( 0x10C ) : 0x427 , py23char ( 0x160 ) : 0x428 , py23char ( 0x15C ) : 0x429 , py23char ( 0x2BA ) : 0x42a , <str> : 0x42b , py23char ( 0x2B9 ) : 0x42c , py23char ( 0x0C8 ) : 0x42d , py23char ( 0x0DB ) : 0x42e , py23char ( 0x0C2 ) : 0x42f , <str> : 0x430 , <str> : 0x431 , <str> : 0x432 , <str> : 0x433 , <str> : 0x434 , <str> : 0x435 , py23char ( 0x17E ) : 0x436 , <str> : 0x437 , <str> : 0x438 , <str> : 0x439 , <str> : 0x43a , <str> : 0x43b , <str> : 0x43c , <str> : 0x43d , <str> : 0x43e , <str> : 0x43f , <str> : 0x440 , <str> : 0x441 , <str> : 0x442 , <str> : 0x443 , <str> : 0x444 , <str> : 0x445 , <str> : 0x446 , py23char ( 0x10D ) : 0x447 , py23char ( 0x161 ) : 0x448 , py23char ( 0x15D ) : 0x449 , <str> : 0x44b , py23char ( 0xE8 ) : 0x44d , py23char ( 0x0FB ) : 0x44e , py23char ( 0x0E2 ) : 0x44f , py23char ( 0x0EB ) : 0x451 , } TransliterationScheme ( <str> , <str> , _ISO9RUS )  