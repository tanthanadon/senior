import re __author__ = [ <str> ] __license__ = <str> class CDLICorpus ( object ) :      def __init__ ( self ) :          self . chunks = [ ] self . catalog = { }  def parse_file ( self , file_lines ) :          chunks , chunk = [ ] , [ ] if re . match ( <str> , file_lines [ 0 ] ) :              header = re . compile ( <str> )  else :              header = re . compile ( <str> )  for line in file_lines :              if header . match ( line ) :                  if len ( chunk ) > 0 :                      chunks . append ( chunk )  chunk = [ line ]  else :                  if len ( line ) > 0 :                      chunk . append ( line )    chunks . append ( chunk ) self . chunks = chunks re_translit = re . compile ( <str> ) re_normaliz = re . compile ( <str> ) re_translat = re . compile ( <str> ) for chunk in self . chunks :              text = chunk if chunk [ 0 ] . startswith ( <str> ) :                  metadata = chunk [ : 25 ] text = chunk [ 26 : ]  else :                  metadata = [ ]  pnum = <str> . join ( [ c for c in text [ 0 ] . split ( <str> ) [ 0 ] if c != <str> ] ) . rstrip ( ) edition = text [ 0 ] . split ( <str> ) [ 1 ] . lstrip ( ) text = text [ 3 : ] translit = [ ] normaliz = [ ] translat = [ ] for line in text :                  if re . match ( <str> , line ) :                      translit . append ( re_translit . match ( line ) . groups ( ) [ 1 ] )  if line . startswith ( <str> ) :                      normaliz . append ( re_normaliz . match ( line ) . groups ( ) [ 1 ] )  if line . startswith ( <str> ) :                      translat . append ( re_translat . match ( line ) . groups ( ) [ 1 ] )   self . catalog [ pnum ] = { <str> : metadata , <str> : pnum , <str> : edition , <str> : text , <str> : translit , <str> : normaliz , <str> : translat }   def toc ( self ) :          output = [ ] for key in sorted ( self . catalog . keys ( ) ) :              edition = self . catalog [ key ] [ <str> ] length = len ( self . catalog [ key ] [ <str> ] ) output . append ( <str> . format ( key = key , edition = edition , length = length ) )  return output  def list_pnums ( self ) :          return sorted ( [ key for key in self . catalog ] )  def list_editions ( self ) :          return sorted ( [ self . catalog [ key ] [ <str> ] for key in self . catalog ] )  def print_catalog ( self , catalog_filter = [ ] ) :          keys = sorted ( self . catalog . keys ( ) ) if len ( catalog_filter ) > 0 :              valid = [ ] for key in keys :                  for f in catalog_filter :                      if len ( self . catalog [ key ] [ f ] ) > 0 :                          valid . append ( key )    keys = valid  for key in keys :              print ( <str> ) print ( <str> ) print ( <str> ) print ( <str> ) print ( <str> ) print ( <str> ) print ( )     