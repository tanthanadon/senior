__author__ = [ <str> ] __license__ = <str> import logging from cltk . exceptions import InputError LOG = logging . getLogger ( __name__ ) LOG . addHandler ( logging . NullHandler ( ) ) class DeterministicFiniteAutomaton :      def __init__ ( self , Q , S , s , F , delta = False ) :          self . Q = Q self . S = S if s not in self . Q :              LOG . error ( <str> ) raise InputError ( <str> )  else :              self . s = s  if sum ( [ f not in self . Q for f in F ] ) != 0 :              LOG . error ( <str> ) raise InputError ( <str> )  else :              self . F = F  if delta :              self . transition = delta  else :              self . transition = { }   def add_final_state ( self , f ) :          if f not in self . Q :              LOG . error ( <str> ) raise InputError ( <str> )  self . F . add ( f )  def add_transition ( self , qi , u , qj ) :          if u not in self . S :              LOG . error ( <str> ) raise InputError ( <str> )  try :              self . transition [ qi ] [ u ] = qj  except KeyError :              self . transition [ qi ] = dict ( ) self . transition [ qi ] [ u ] = qj   def transition_function ( self , qi , u ) :          try :              return self . transition [ qi ] [ u ]  except KeyError :              return None   def accepted ( self , w ) :          active_state = self . s for k in w :              active_state = self . transition_function ( active_state , k ) if active_state is None :                  return False   return bool ( active_state in self . F )  def complete_automaton ( self ) :          self . term_state = object ( ) self . Q . add ( self . term_state ) for tv in self . Q :              for u in self . S :                  try :                      self . transition [ tv ] [ u ]  except :                      self . add_transition ( tv , u , self . term_state )    for u in self . S :              self . add_transition ( self . term_state , u , self . term_state )    class NondeterministicFiniteAutomaton :      def __init__ ( self , Q , S , s , F , delta = False , isEpsilon = False ) :          self . Q = Q self . S = S self . epsilon = object ( ) self . isEpsilon = isEpsilon if self . isEpsilon : self . S . add ( self . epsilon ) if s not in self . Q :              LOG . error ( <str> ) raise InputError ( <str> )  else :              self . s = s  if sum ( [ f not in self . Q for f in F ] ) != 0 :              LOG . error ( <str> ) raise InputError ( <str> )  else :              self . F = F  if delta :              self . transition = delta  else :              self . transition = { }   def add_final_state ( self , f ) :          if f not in self . Q :              LOG . error ( <str> ) raise InputError ( <str> )  self . F . add ( f )  def add_transition ( self , qi , u , qj ) :          if u not in self . S :              LOG . error ( <str> ) raise InputError ( <str> )  try :              self . transition [ qi ] [ u ] . add ( qj )  except KeyError :              try :                  self . transition [ qi ] [ u ] = { qj }  except KeyError :                  self . transition [ qi ] = dict ( ) self . transition [ qi ] [ u ] = { qj }    def transition_function ( self , qi , u ) :          try :              return self . transition [ qi ] [ u ]  except KeyError :              return None   def convert_to_deterministic ( self ) :          starting_state = tuple ( [ self . s ] ) if self . isEpsilon :              E = { } for q in self . Q :                  visited_q0 = [ q ] active_q0 = [ q ] while active_q0 :                      q1 = active_q0 . pop ( 0 ) try :                          for t in self . transition_function ( q1 , self . epsilon ) :                              if t not in visited_q0 :                                  visited_q0 . append ( t ) active_q0 . append ( t )    except :                          pass   E [ q ] = sorted ( visited_q0 )  starting_state = E [ self . s ]  transition = { } final_states = set ( ) active_states = [ starting_state ] visited_states = [ starting_state ] while active_states :              q = tuple ( active_states . pop ( 0 ) ) str_q = <str> . join ( sorted ( q ) ) if str_q not in transition :                  transition [ str_q ] = { } if self . F . intersection ( set ( q ) ) != set ( ) :                      final_states . add ( str_q )   S = set ( ) . union ( * [ set ( self . transition [ t ] . keys ( ) ) for t in q if t in self . transition ] ) S . discard ( self . epsilon ) for s in S :                  states = set ( ) . union ( * [ self . transition_function ( t , s ) for t in q if self . transition_function ( t , s ) ] ) states = sorted ( list ( set ( ) . union ( * [ E [ state ] for state in states ] ) ) ) transition [ str_q ] [ s ] = <str> . join ( states ) if states not in visited_states :                      visited_states . append ( states ) active_states . append ( states )    return DeterministicFiniteAutomaton ( transition . keys ( ) , self . S , <str> . join ( starting_state ) , final_states , delta = transition )   class LevenshteinAutomaton ( NondeterministicFiniteAutomaton ) :      def __init__ ( self , word , depth , alphabet = <str> ) :          super ( ) . __init__ ( [ <str> + str ( i * ( len ( word ) + 1 ) + j ) for i in range ( depth + 1 ) for j in range ( len ( word ) + 1 ) ] , set ( word + <str> ) , <str> , set ( [ <str> + str ( ( i + 1 ) * ( len ( word ) + 1 ) - 1 ) for i in range ( depth + 1 ) ] ) , isEpsilon = True ) self . S . add ( self . epsilon ) self . alphabet = alphabet for i in range ( depth ) :              for j in range ( len ( word ) ) :                  self . add_transition ( ( <str> + str ( ( len ( word ) + 1 ) * i + j ) ) , word [ j ] , <str> + str ( ( len ( word ) + 1 ) * i + j + 1 ) ) self . add_transition ( ( <str> + str ( ( len ( word ) + 1 ) * i + j ) ) , self . epsilon , <str> + str ( ( len ( word ) + 1 ) * ( i + 1 ) + j + 1 ) ) self . add_transition ( <str> + str ( ( len ( word ) + 1 ) * i + j ) , <str> , <str> + str ( ( len ( word ) + 1 ) * ( i + 1 ) + j + 1 ) ) self . add_transition ( <str> + str ( ( len ( word ) + 1 ) * i + j ) , <str> , <str> + str ( ( len ( word ) + 1 ) * ( i + 1 ) + j ) )   for j in range ( len ( word ) ) :              self . add_transition ( <str> + str ( ( len ( word ) + 1 ) * depth + j ) , word [ j ] , <str> + str ( ( len ( word ) + 1 ) * depth + j + 1 ) )  for j in range ( depth ) :              self . add_transition ( <str> + str ( ( len ( word ) + 1 ) * j + len ( word ) ) , <str> , <str> + str ( ( len ( word ) + 1 ) * ( j + 1 ) + len ( word ) ) )   def convert_to_deterministic ( self ) :          A = super ( LevenshteinAutomaton , self ) . convert_to_deterministic ( ) return LevenshteinDeterministic ( A . Q , A . S , A . s , A . F , A . transition , self . alphabet )   class LevenshteinDeterministic ( DeterministicFiniteAutomaton ) :      def __init__ ( self , Q , S , s , F , transition , alphabet ) :          super ( ) . __init__ ( Q , S , s , F , transition ) self . alphabet = alphabet  def transition_function ( self , qi , u ) :          try :              return self . transition [ qi ] [ u ]  except KeyError :              if u in self . alphabet :                  try :                      return self . transition [ qi ] [ <str> ]  except KeyError :                      return None   return None    def make_worlist_trie ( wordlist ) :      dicts = dict ( ) for w in wordlist :          curr = dicts for l in w :              curr = curr . setdefault ( l , { } )  curr [ <str> ] = <str>  return dicts  def walk_trie ( dicts , w , q , A ) :      if q in A . F and <str> in dicts :          yield w  for key in dicts . keys ( ) :          if key == <str> :              continue  if A . transition_function ( q , key ) is None :              return  try :              yield from walk_trie ( dicts [ key ] , w + key , A . transition_function ( q , key ) , A )  except :              return    def spellcheck ( word , wordlist , depth = 2 ) :      Aut = LevenshteinAutomaton ( word , depth = depth ) . convert_to_deterministic ( ) W = make_worlist_trie ( wordlist ) return sorted ( list ( walk_trie ( W , <str> , Aut . s , Aut ) ) )   