import re from unicodedata import normalize __author__ = [ <str> ] __license__ = <str> VOWELS = <str> TITTLES = { <str> : chr ( 0x1E63 ) , <str> : chr ( 0x0161 ) , <str> : chr ( 0x1E6D ) , <str> : chr ( 0x02BE ) , <str> : chr ( 0x1E62 ) , <str> : chr ( 0x0160 ) , <str> : chr ( 0x1E6C ) } class ATFConverter ( object ) :      def __init__ ( self , two_three = True ) :          self . tittles = TITTLES self . two_three = two_three  @ staticmethod def _convert_consonant ( sign ) :          for key in TITTLES :              sign = sign . replace ( key , TITTLES [ key ] )  return sign  @ staticmethod def _convert_number_to_subscript ( num ) :          subscript = <str> for character in str ( num ) :              subscript += chr ( 0x2080 + int ( character ) )  return subscript  @ staticmethod def _get_number_from_sign ( sign ) :          match = re . search ( <str> , sign ) if match is None :              number = 0  else :              number = match [ 0 ]  return sign , int ( number )  def _convert_num ( self , sign ) :          new_sign , num = self . _get_number_from_sign ( sign ) if num < 2 :              return new_sign . replace ( str ( num ) , self . _convert_number_to_subscript ( num ) )  if num > 3 :              return new_sign . replace ( str ( num ) , self . _convert_number_to_subscript ( num ) )  if self . two_three :              return new_sign . replace ( str ( num ) , self . _convert_number_to_subscript ( num ) )  else :              for i , character in enumerate ( new_sign ) :                  new_vowel = <str> if character in VOWELS :                      if num == 2 :                          new_vowel = character + chr ( 0x0301 )  elif num == 3 :                          new_vowel = character + chr ( 0x0300 )  break   return new_sign [ : i ] + normalize ( <str> , new_vowel ) + new_sign [ i + 1 : ] . replace ( str ( num ) , <str> )   def process ( self , text_string ) :          output = [ self . _convert_num ( self . _convert_consonant ( token ) ) for token in text_string ] return output    