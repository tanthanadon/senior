import logging from typing import List from cltk . prosody . latin . scansion_constants import ScansionConstants from Levenshtein import distance LOG = logging . getLogger ( __name__ ) LOG . addHandler ( logging . NullHandler ( ) ) __author__ = [ <str> ] __license__ = <str> class MetricalValidator :      def is_valid_hexameter ( self , scanned_line : str ) -> bool :          line = scanned_line . replace ( self . constants . FOOT_SEPARATOR , <str> ) line = line . replace ( <str> , <str> ) if len ( line ) < 12 :              return False  line = line [ : - 1 ] + self . constants . OPTIONAL_ENDING return self . VALID_HEXAMETERS . __contains__ ( line )  def is_valid_hendecasyllables ( self , scanned_line : str ) -> bool :          line = scanned_line . replace ( self . constants . FOOT_SEPARATOR , <str> ) line = line . replace ( <str> , <str> ) if len ( line ) < 11 :              return False  line = line [ : - 1 ] + self . constants . OPTIONAL_ENDING return self . VALID_HENDECASYLLABLES . __contains__ ( line )  def is_valid_pentameter ( self , scanned_line : str ) -> bool :          line = scanned_line . replace ( self . constants . FOOT_SEPARATOR , <str> ) line = line . replace ( <str> , <str> ) if len ( line ) < 10 :              return False  line = line [ : - 1 ] + self . constants . OPTIONAL_ENDING return self . VALID_PENTAMETERS . __contains__ ( line )  def __init__ ( self , constants = ScansionConstants ( ) ) :          self . constants = constants self . VALID_HEXAMETERS = [ self . _build_hexameter_template ( bin ( x ) [ 3 : ] ) for x in range ( 32 , 64 ) ] self . VALID_HENDECASYLLABLES = self . _build_hendecasyllable_templates ( ) self . VALID_PENTAMETERS = self . _build_pentameter_templates ( )  def hexameter_feet ( self , scansion : str ) -> List [ str ] :          backwards_scan = list ( scansion . rstrip ( ) ) feet = [ ] candidates = [ self . constants . STRESSED + self . constants . OPTIONAL_ENDING , self . constants . STRESSED + self . constants . STRESSED , self . constants . STRESSED + self . constants . UNSTRESSED , self . constants . UNSTRESSED + self . constants . STRESSED ] incomplete_foot = self . constants . UNSTRESSED + self . constants . UNSTRESSED try :              while len ( backwards_scan ) > 0 :                  spaces = [ ] chunk1 = backwards_scan . pop ( ) while len ( <str> . join ( chunk1 ) . replace ( <str> , <str> ) ) == 0 :                      if len ( backwards_scan ) == 0 :                          feet . append ( chunk1 ) return feet [ : : - 1 ]  chunk1 = backwards_scan . pop ( ) + <str> . join ( chunk1 )  chunk2 = backwards_scan . pop ( ) while chunk2 == <str> :                      spaces . append ( chunk2 ) if len ( backwards_scan ) == 0 :                          feet . append ( chunk2 ) return feet [ : : - 1 ]  chunk2 = backwards_scan . pop ( )  new_candidate = <str> . join ( chunk2 ) + <str> . join ( spaces ) + <str> . join ( chunk1 ) if new_candidate . replace ( <str> , <str> ) in candidates :                      feet . append ( new_candidate )  else :                      if new_candidate . replace ( <str> , <str> ) == incomplete_foot :                          spaces2 = [ ] previous_mark = backwards_scan . pop ( ) while previous_mark == <str> :                              spaces2 . append ( previous_mark ) previous_mark = backwards_scan . pop ( )  if previous_mark == self . constants . STRESSED :                              new_candidate = <str> . join ( previous_mark ) + <str> . join ( spaces2 ) + new_candidate feet . append ( new_candidate )  else :                              feet . append ( new_candidate ) spaces3 = [ ] next_mark = backwards_scan . pop ( ) while next_mark == <str> :                                  spaces3 . append ( previous_mark ) next_mark = backwards_scan . pop ( )  feet . append ( <str> . join ( next_mark ) + <str> . join ( spaces3 ) + previous_mark )      except Exception as ex :              LOG . error ( <str> . format ( scansion , ex ) ) return list ( )  return feet [ : : - 1 ]  @ staticmethod def hexameter_known_stresses ( ) -> List [ int ] :          return list ( range ( 17 ) [ : : 3 ] )  @ staticmethod def hexameter_possible_unstresses ( ) -> List [ int ] :          return list ( set ( range ( 17 ) ) - set ( range ( 17 ) [ : : 3 ] ) )  def closest_hexameter_patterns ( self , scansion : str ) -> List [ str ] :          return self . _closest_patterns ( self . VALID_HEXAMETERS , scansion )  @ staticmethod def pentameter_possible_stresses ( ) -> List [ int ] :          return list ( range ( 0 , 6 ) ) + [ 8 ]  def closest_pentameter_patterns ( self , scansion : str ) -> List [ str ] :          return self . _closest_patterns ( self . VALID_PENTAMETERS , scansion )  def closest_hendecasyllable_patterns ( self , scansion : str ) -> List [ str ] :          return self . _closest_patterns ( self . VALID_HENDECASYLLABLES , scansion )  def _closest_patterns ( self , patterns : List [ str ] , scansion : str ) -> List [ str ] :          pattern = scansion . replace ( <str> , <str> ) pattern = pattern . replace ( self . constants . FOOT_SEPARATOR , <str> ) ending = pattern [ - 1 ] candidate = pattern [ : len ( pattern ) - 1 ] + self . constants . OPTIONAL_ENDING cans = [ ( distance ( candidate , x ) , x ) for x in patterns if len ( x ) == len ( candidate ) ] if cans :              cans = sorted ( cans , key = lambda tup : tup [ 0 ] ) top = cans [ 0 ] [ 0 ] return [ can [ 1 ] [ : - 1 ] + ending for can in cans if can [ 0 ] == top ]  return [ ]  def _build_hexameter_template ( self , stress_positions : str ) -> str :          hexameter = [ ] for binary in stress_positions :              if binary == <str> :                  hexameter . append ( self . constants . SPONDEE )  if binary == <str> :                  hexameter . append ( self . constants . DACTYL )   hexameter . append ( self . constants . HEXAMETER_ENDING ) return <str> . join ( hexameter )  def _build_hendecasyllable_templates ( self ) -> List [ str ] :          return [ self . constants . TROCHEE + self . constants . TROCHEE + self . constants . IAMB + self . constants . IAMB + self . constants . IAMB + self . constants . OPTIONAL_ENDING , self . constants . SPONDEE + self . constants . TROCHEE + self . constants . IAMB + self . constants . IAMB + self . constants . IAMB + self . constants . OPTIONAL_ENDING , self . constants . IAMB + self . constants . TROCHEE + self . constants . IAMB + self . constants . IAMB + self . constants . IAMB + self . constants . OPTIONAL_ENDING ]  def _build_pentameter_templates ( self ) -> List [ str ] :          return [ self . constants . DACTYL + self . constants . DACTYL + self . constants . STRESSED + self . constants . DACTYL + self . constants . DACTYL + self . constants . OPTIONAL_ENDING , self . constants . DACTYL + self . constants . SPONDEE + self . constants . STRESSED + self . constants . DACTYL + self . constants . DACTYL + self . constants . OPTIONAL_ENDING , self . constants . SPONDEE + self . constants . DACTYL + self . constants . STRESSED + self . constants . DACTYL + self . constants . DACTYL + self . constants . OPTIONAL_ENDING , self . constants . SPONDEE + self . constants . SPONDEE + self . constants . STRESSED + self . constants . DACTYL + self . constants . DACTYL + self . constants . OPTIONAL_ENDING ]    