from uuid import uuid4 from datetime import timedelta , datetime , time from iso8601 import parse_date from pyramid . security import Allow from zope . interface import implementer from schematics . types import StringType , MD5Type , BooleanType from schematics . types . compound import ModelType from schematics . types . serializable import serializable from schematics . transforms import blacklist , whitelist , export_loop from schematics . exceptions import ValidationError from urlparse import urlparse , parse_qs from string import hexdigits from openprocurement . api . utils import get_now from openprocurement . api . constants import TZ from openprocurement . api . models import ( listing_role , Address , Period , Model , IsoDateTimeType , ListType , SifterListType , Identifier as BaseIdentifier , ContactPoint as BaseContactPoint , plain_role ) from openprocurement . api . validation import ( validate_cpv_group , validate_items_uniq ) from openprocurement . tender . core . models import ( ITender , Bid as BaseBid , Contract as BaseContract , Cancellation as BaseCancellation , Lot as BaseLot , Document as BaseDocument , LotValue as BaseLotValue , ComplaintModelType as BaseComplaintModelType , EnquiryPeriod , PeriodStartEndRequired , create_role , edit_role , view_role , auction_view_role , auction_post_role , auction_patch_role , enquiries_role , auction_role , chronograph_role , chronograph_view_role , view_bid_role , Administrator_bid_role , Administrator_role , schematics_default_role , schematics_embedded_role , embedded_lot_role , default_lot_role , get_tender , validate_lots_uniq , rounding_shouldStartAfter , validate_parameters_uniq , bids_validation_wrapper ) from openprocurement . tender . core . utils import ( calculate_business_date , calc_auction_end_time , has_unanswered_questions , has_unanswered_complaints , ) from openprocurement . tender . belowthreshold . models import ( Tender as BaseTender ) from openprocurement . tender . openua . utils import ( calculate_normalized_date ) from openprocurement . tender . openua . models import ( Complaint as BaseComplaint , Award as BaseAward , Item as BaseItem , Tender as OpenUATender , Parameter ) from openprocurement . tender . openua . constants import ( COMPLAINT_SUBMIT_TIME , ENQUIRY_STAND_STILL_TIME , AUCTION_PERIOD_TIME , ) from openprocurement . tender . openeu . constants import ( TENDERING_DURATION , QUESTIONS_STAND_STILL , TENDERING_AUCTION , BID_UNSUCCESSFUL_FROM , TENDERING_DAYS ) eu_role = blacklist ( <str> , <str> ) edit_role_eu = edit_role + eu_role create_role_eu = create_role + eu_role pre_qualifications_role = ( blacklist ( <str> , <str> , <str> ) + schematics_embedded_role ) eu_auction_role = auction_role class IAboveThresholdEUTender ( ITender ) :        class BidModelType ( ModelType ) :      def export_loop ( self , model_instance , field_converter , role = None , print_none = False ) :          if isinstance ( model_instance , self . model_class ) :              model_class = model_instance . __class__  else :              model_class = self . model_class  tender = model_instance . __parent__ if ( tender . revisions [ 0 ] . date if tender . revisions else get_now ( ) ) > BID_UNSUCCESSFUL_FROM and role not in [ None , <str> ] and getattr ( model_instance , <str> ) == <str> :              role = <str>  shaped = export_loop ( model_class , model_instance , field_converter , role = role , print_none = print_none ) if shaped and len ( shaped ) == 0 and self . allow_none ( ) :              return shaped  elif shaped :              return shaped  elif print_none :              return shaped    class ComplaintModelType ( BaseComplaintModelType ) :      view_claim_statuses = [ <str> , <str> , <str> , <str> ]  class Item ( BaseItem ) :      description_en = StringType ( required = True , min_length = 1 )  class Identifier ( BaseIdentifier ) :      legalName_en = StringType ( required = True , min_length = 1 )  class ContactPoint ( BaseContactPoint ) :      name_en = StringType ( required = True , min_length = 1 ) availableLanguage = StringType ( required = True , choices = [ <str> , <str> , <str> ] , default = <str> )  class Organization ( Model ) :      class Options :          roles = { <str> : schematics_embedded_role , <str> : schematics_default_role , }  name = StringType ( required = True ) name_en = StringType ( required = True , min_length = 1 ) name_ru = StringType ( ) identifier = ModelType ( Identifier , required = True ) additionalIdentifiers = ListType ( ModelType ( Identifier ) ) address = ModelType ( Address , required = True ) contactPoint = ModelType ( ContactPoint , required = True ) additionalContactPoints = ListType ( ModelType ( ContactPoint , required = True ) , required = False )  class ProcuringEntity ( Organization ) :      class Options :          roles = { <str> : schematics_embedded_role , <str> : schematics_default_role , <str> : schematics_default_role + blacklist ( <str> ) , }  kind = StringType ( choices = [ <str> , <str> , <str> , <str> ] )  class Document ( BaseDocument ) :      language = StringType ( required = True , choices = [ <str> , <str> , <str> ] , default = <str> )  OpenEUDocument = Document class Contract ( BaseContract ) :      documents = ListType ( ModelType ( Document ) , default = list ( ) ) items = ListType ( ModelType ( Item ) )  class Complaint ( BaseComplaint ) :      class Options :          roles = { <str> : view_bid_role , <str> : view_bid_role , }  documents = ListType ( ModelType ( Document ) , default = list ( ) ) def serialize ( self , role = None , context = None ) :          if role == <str> and self . type == <str> and get_tender ( self ) . status in [ <str> , <str> , <str> , <str> ] :              role = <str>  return super ( Complaint , self ) . serialize ( role = role , context = context )   class Cancellation ( BaseCancellation ) :      class Options :          roles = { <str> : whitelist ( <str> , <str> , <str> , <str> , <str> ) , <str> : whitelist ( <str> , <str> ) , <str> : schematics_embedded_role , <str> : schematics_default_role , }  documents = ListType ( ModelType ( Document ) , default = list ( ) ) reasonType = StringType ( choices = [ <str> , <str> ] , default = <str> )  class TenderAuctionPeriod ( Period ) :      @ serializable ( serialize_when_none = False ) def shouldStartAfter ( self ) :          if self . endDate :              return  tender = self . __parent__ if tender . lots or tender . status not in [ <str> , <str> , <str> ] :              return  start_after = None if tender . status == <str> and tender . tenderPeriod . endDate :              start_after = calculate_business_date ( tender . tenderPeriod . endDate , TENDERING_AUCTION , tender )  elif self . startDate and get_now ( ) > calc_auction_end_time ( tender . numberOfBids , self . startDate ) :              start_after = calc_auction_end_time ( tender . numberOfBids , self . startDate )  elif tender . qualificationPeriod and tender . qualificationPeriod . endDate :              decision_dates = [ datetime . combine ( complaint . dateDecision . date ( ) + timedelta ( days = 3 ) , time ( 0 , tzinfo = complaint . dateDecision . tzinfo ) ) for qualification in tender . qualifications for complaint in qualification . complaints if complaint . dateDecision ] decision_dates . append ( tender . qualificationPeriod . endDate ) start_after = max ( decision_dates )  if start_after :              return rounding_shouldStartAfter ( start_after , tender ) . isoformat ( )    class LotAuctionPeriod ( Period ) :      @ serializable ( serialize_when_none = False ) def shouldStartAfter ( self ) :          if self . endDate :              return  tender = get_tender ( self ) lot = self . __parent__ if tender . status not in [ <str> , <str> , <str> ] or lot . status != <str> :              return  start_after = None if tender . status == <str> and tender . tenderPeriod . endDate :              start_after = calculate_business_date ( tender . tenderPeriod . endDate , TENDERING_AUCTION , tender )  elif self . startDate and get_now ( ) > calc_auction_end_time ( lot . numberOfBids , self . startDate ) :              start_after = calc_auction_end_time ( lot . numberOfBids , self . startDate )  elif tender . qualificationPeriod and tender . qualificationPeriod . endDate :              decision_dates = [ datetime . combine ( complaint . dateDecision . date ( ) + timedelta ( days = 3 ) , time ( 0 , tzinfo = complaint . dateDecision . tzinfo ) ) for qualification in tender . qualifications for complaint in qualification . complaints if complaint . dateDecision ] decision_dates . append ( tender . qualificationPeriod . endDate ) start_after = max ( decision_dates )  if start_after :              return rounding_shouldStartAfter ( start_after , tender ) . isoformat ( )    class Lot ( BaseLot ) :      class Options :          roles = { <str> : whitelist ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) , <str> : whitelist ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) , <str> : embedded_lot_role , <str> : default_lot_role , <str> : default_lot_role , <str> : default_lot_role , <str> : whitelist ( <str> , <str> ) , <str> : whitelist ( <str> , <str> ) , <str> : whitelist ( <str> , <str> , <str> , <str> ) , }  auctionPeriod = ModelType ( LotAuctionPeriod , default = { } ) @ serializable def numberOfBids ( self ) :          bids = [ bid for bid in self . __parent__ . bids if self . id in [ i . relatedLot for i in bid . lotValues if i . status in [ <str> , <str> ] ] and bid . status in [ <str> , <str> ] ] return len ( bids )   class LotValue ( BaseLotValue ) :      class Options :          roles = { <str> : whitelist ( <str> , <str> , <str> ) , <str> : whitelist ( <str> , <str> , <str> ) , <str> : whitelist ( <str> , <str> , <str> , <str> , <str> , ) , }  subcontractingDetails = StringType ( ) status = StringType ( choices = [ <str> , <str> , <str> ] , default = <str> ) def validate_value ( self , data , value ) :          if value and isinstance ( data [ <str> ] , Model ) and ( data [ <str> ] . status not in ( <str> , <str> , <str> ) ) and data [ <str> ] :              lots = [ i for i in get_tender ( data [ <str> ] ) . lots if i . id == data [ <str> ] ] if not lots :                  return  lot = lots [ 0 ] if lot . value . amount < value . amount :                  raise ValidationError ( <str> )  if lot . get ( <str> ) . currency != value . currency :                  raise ValidationError ( <str> )  if lot . get ( <str> ) . valueAddedTaxIncluded != value . valueAddedTaxIncluded :                  raise ValidationError ( <str> )    def validate_relatedLot ( self , data , relatedLot ) :          if isinstance ( data [ <str> ] , Model ) and ( data [ <str> ] . status not in ( <str> , <str> , <str> ) ) and relatedLot not in [ i . id for i in get_tender ( data [ <str> ] ) . lots ] :              raise ValidationError ( <str> )    class Document ( Document ) :      class Options :          roles = { <str> : blacklist ( <str> , <str> , <str> , <str> , <str> , <str> , <str> ) , <str> : schematics_embedded_role , <str> : ( blacklist ( <str> ) + schematics_default_role ) , <str> : ( blacklist ( <str> , <str> , <str> ) + schematics_default_role ) , <str> : whitelist ( <str> , <str> ) , }  confidentiality = StringType ( choices = [ <str> , <str> ] , default = <str> ) confidentialityRationale = StringType ( ) def validate_confidentialityRationale ( self , data , val ) :          if data [ <str> ] != <str> :              if not val :                  raise ValidationError ( <str> )  elif len ( val ) < 30 :                  raise ValidationError ( <str> )    @ serializable ( serialized_name = <str> ) def download_url ( self ) :          url = self . url if self . confidentiality == <str> :              return self . url  if not url or <str> not in url :              return url  doc_id = parse_qs ( urlparse ( url ) . query ) [ <str> ] [ - 1 ] root = self . __parent__ parents = [ ] while root . __parent__ is not None :              parents [ 0 : 0 ] = [ root ] root = root . __parent__  request = root . request if not request . registry . docservice_url :              return url  if <str> in parents [ 0 ] and parents [ 0 ] . status in type ( parents [ 0 ] ) . _options . roles :              role = parents [ 0 ] . status for index , obj in enumerate ( parents ) :                  if obj . id != url . split ( <str> ) [ ( index - len ( parents ) ) * 2 - 1 ] :                      break  field = url . split ( <str> ) [ ( index - len ( parents ) ) * 2 ] if <str> in field :                      field = field [ 0 ] + field . title ( ) . replace ( <str> , <str> ) [ 1 : ]  roles = type ( obj ) . _options . roles if roles [ role if role in roles else <str> ] ( field , [ ] ) :                      return url    from openprocurement . api . utils import generate_docservice_url if not self . hash :              path = [ i for i in urlparse ( url ) . path . split ( <str> ) if len ( i ) == 32 and not set ( i ) . difference ( hexdigits ) ] return generate_docservice_url ( request , doc_id , False , <str> . format ( path [ 0 ] , path [ - 1 ] ) )  return generate_docservice_url ( request , doc_id , False )   ConfidentialDocument = Document class Bid ( BaseBid ) :      class Options :          roles = { <str> : Administrator_bid_role , <str> : view_bid_role , <str> : view_bid_role , <str> : whitelist ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) , <str> : whitelist ( <str> , <str> , <str> , <str> , <str> , <str> ) , <str> : whitelist ( <str> , <str> , <str> , <str> , <str> , <str> , <str> ) , <str> : whitelist ( <str> , <str> , <str> , <str> ) , <str> : whitelist ( <str> , <str> , <str> ) , <str> : whitelist ( ) , <str> : whitelist ( ) , <str> : whitelist ( <str> , <str> , <str> , <str> , <str> ) , <str> : whitelist ( <str> , <str> , <str> , <str> , <str> ) , <str> : whitelist ( <str> , <str> , <str> , <str> , <str> ) , <str> : view_bid_role , <str> : view_bid_role , <str> : view_bid_role , <str> : view_bid_role , <str> : whitelist ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) , <str> : view_bid_role , <str> : whitelist ( <str> , <str> ) , <str> : whitelist ( <str> , <str> , <str> , <str> , <str> ) , <str> : whitelist ( <str> , <str> ) , }  documents = ListType ( ModelType ( Document ) , default = list ( ) ) financialDocuments = ListType ( ModelType ( Document ) , default = list ( ) ) eligibilityDocuments = ListType ( ModelType ( Document ) , default = list ( ) ) qualificationDocuments = ListType ( ModelType ( Document ) , default = list ( ) ) lotValues = ListType ( ModelType ( LotValue ) , default = list ( ) ) selfQualified = BooleanType ( required = True , choices = [ True ] ) selfEligible = BooleanType ( required = True , choices = [ True ] ) subcontractingDetails = StringType ( ) parameters = ListType ( ModelType ( Parameter ) , default = list ( ) , validators = [ validate_parameters_uniq ] ) status = StringType ( choices = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> ] , default = <str> ) def serialize ( self , role = None ) :          if role and role != <str> and self . status in [ <str> , <str> , <str> ] :              role = self . status  elif role and role != <str> and self . status == <str> :              role = <str>  return super ( Bid , self ) . serialize ( role )  @ serializable ( serialized_name = <str> ) def serialize_status ( self ) :          if self . status in [ <str> , <str> , <str> , <str> , <str> ] or self . __parent__ . status in [ <str> , <str> ] :              return self . status  if self . __parent__ . lots :              active_lots = [ lot . id for lot in self . __parent__ . lots if lot . status in ( <str> , <str> , ) ] if not self . lotValues :                  return <str>  elif [ i . relatedLot for i in self . lotValues if i . status == <str> and i . relatedLot in active_lots ] :                  return <str>  elif [ i . relatedLot for i in self . lotValues if i . status == <str> and i . relatedLot in active_lots ] :                  return <str>  else :                  return <str>   return self . status  @ bids_validation_wrapper def validate_value ( self , data , value ) :          BaseBid . _validator_functions [ <str> ] ( self , data , value )  @ bids_validation_wrapper def validate_lotValues ( self , data , lotValues ) :          BaseBid . _validator_functions [ <str> ] ( self , data , lotValues )  @ bids_validation_wrapper def validate_participationUrl ( self , data , participationUrl ) :          BaseBid . _validator_functions [ <str> ] ( self , data , participationUrl )  @ bids_validation_wrapper def validate_parameters ( self , data , parameters ) :          BaseBid . _validator_functions [ <str> ] ( self , data , parameters )   Document = OpenEUDocument class Award ( BaseAward ) :      complaints = ListType ( ModelType ( Complaint ) , default = list ( ) ) items = ListType ( ModelType ( Item ) ) documents = ListType ( ModelType ( Document ) , default = list ( ) ) qualified = BooleanType ( ) eligible = BooleanType ( ) def validate_qualified ( self , data , qualified ) :          pass  def validate_eligible ( self , data , eligible ) :          pass   class Qualification ( Model ) :      class Options :          roles = { <str> : blacklist ( <str> , <str> , <str> , <str> ) , <str> : whitelist ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) , <str> : schematics_embedded_role , <str> : schematics_default_role , }  title = StringType ( ) title_en = StringType ( ) title_ru = StringType ( ) description = StringType ( ) description_en = StringType ( ) description_ru = StringType ( ) id = MD5Type ( required = True , default = lambda : uuid4 ( ) . hex ) bidID = StringType ( required = True ) lotID = MD5Type ( ) status = StringType ( choices = [ <str> , <str> , <str> , <str> ] , default = <str> ) date = IsoDateTimeType ( ) documents = ListType ( ModelType ( Document ) , default = list ( ) ) complaints = ListType ( ModelType ( Complaint ) , default = list ( ) ) qualified = BooleanType ( default = False ) eligible = BooleanType ( default = False ) def validate_qualified ( self , data , qualified ) :          if data [ <str> ] == <str> and not qualified :              raise ValidationError ( <str> )   def validate_eligible ( self , data , eligible ) :          if data [ <str> ] == <str> and not eligible :              raise ValidationError ( <str> )   def validate_lotID ( self , data , lotID ) :          if isinstance ( data [ <str> ] , Model ) :              if not lotID and data [ <str> ] . lots :                  raise ValidationError ( <str> )  if lotID and lotID not in [ i . id for i in data [ <str> ] . lots ] :                  raise ValidationError ( <str> )     @ implementer ( IAboveThresholdEUTender ) class Tender ( BaseTender ) :      class Options :          roles = { <str> : plain_role , <str> : create_role_eu , <str> : edit_role_eu , <str> : edit_role_eu , <str> : edit_role_eu , <str> : whitelist ( <str> ) , <str> : whitelist ( ) , <str> : whitelist ( ) , <str> : whitelist ( ) , <str> : whitelist ( ) , <str> : whitelist ( ) , <str> : whitelist ( ) , <str> : whitelist ( ) , <str> : view_role , <str> : listing_role , <str> : auction_view_role , <str> : auction_post_role , <str> : auction_patch_role , <str> : enquiries_role , <str> : enquiries_role , <str> : pre_qualifications_role , <str> : pre_qualifications_role , <str> : pre_qualifications_role , <str> : view_role , <str> : view_role , <str> : view_role , <str> : view_role , <str> : view_role , <str> : chronograph_role , <str> : chronograph_view_role , <str> : Administrator_role , <str> : schematics_default_role , <str> : whitelist ( <str> , <str> ) , }  procurementMethodType = StringType ( default = <str> ) title_en = StringType ( required = True , min_length = 1 ) enquiryPeriod = ModelType ( EnquiryPeriod , required = False ) tenderPeriod = ModelType ( PeriodStartEndRequired , required = True ) auctionPeriod = ModelType ( TenderAuctionPeriod , default = { } ) documents = ListType ( ModelType ( Document ) , default = list ( ) ) items = ListType ( ModelType ( Item ) , required = True , min_size = 1 , validators = [ validate_cpv_group , validate_items_uniq ] ) complaints = ListType ( ComplaintModelType ( Complaint ) , default = list ( ) ) contracts = ListType ( ModelType ( Contract ) , default = list ( ) ) cancellations = ListType ( ModelType ( Cancellation ) , default = list ( ) ) awards = ListType ( ModelType ( Award ) , default = list ( ) ) procuringEntity = ModelType ( ProcuringEntity , required = True ) bids = SifterListType ( BidModelType ( Bid ) , default = list ( ) , filter_by = <str> , filter_in_values = [ <str> , <str> , <str> ] ) qualifications = ListType ( ModelType ( Qualification ) , default = list ( ) ) qualificationPeriod = ModelType ( Period ) lots = ListType ( ModelType ( Lot ) , default = list ( ) , validators = [ validate_lots_uniq ] ) status = StringType ( choices = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] , default = <str> ) create_accreditation = 3 edit_accreditation = 4 procuring_entity_kinds = [ <str> , <str> , <str> ] block_tender_complaint_status = OpenUATender . block_tender_complaint_status block_complaint_status = OpenUATender . block_complaint_status def __acl__ ( self ) :          acl = [ ( Allow , <str> . format ( i . owner , i . owner_token ) , <str> ) for i in self . bids if i . status in [ <str> , <str> ] ] acl . extend ( [ ( Allow , <str> . format ( i . owner , i . owner_token ) , <str> ) for i in self . bids if i . status == <str> ] ) acl . extend ( [ ( Allow , <str> . format ( self . owner , self . owner_token ) , <str> ) , ( Allow , <str> . format ( self . owner , self . owner_token ) , <str> ) , ( Allow , <str> . format ( self . owner , self . owner_token ) , <str> ) , ] ) return acl  @ serializable ( serialized_name = <str> , type = ModelType ( EnquiryPeriod ) ) def tender_enquiryPeriod ( self ) :          endDate = calculate_business_date ( self . tenderPeriod . endDate , - QUESTIONS_STAND_STILL , self ) return EnquiryPeriod ( dict ( startDate = self . tenderPeriod . startDate , endDate = endDate , invalidationDate = self . enquiryPeriod and self . enquiryPeriod . invalidationDate , clarificationsUntil = calculate_business_date ( endDate , ENQUIRY_STAND_STILL_TIME , self , True ) ) )  @ serializable ( type = ModelType ( Period ) ) def complaintPeriod ( self ) :          normalized_end = calculate_normalized_date ( self . tenderPeriod . endDate , self ) return Period ( dict ( startDate = self . tenderPeriod . startDate , endDate = calculate_business_date ( normalized_end , - COMPLAINT_SUBMIT_TIME , self ) ) )  @ serializable ( serialize_when_none = False ) def next_check ( self ) :          now = get_now ( ) checks = [ ] if self . status == <str> and self . tenderPeriod . endDate and not has_unanswered_complaints ( self ) and not has_unanswered_questions ( self ) :              checks . append ( self . tenderPeriod . endDate . astimezone ( TZ ) )  elif self . status == <str> and self . qualificationPeriod and self . qualificationPeriod . endDate :              active_lots = [ lot . id for lot in self . lots if lot . status == <str> ] if self . lots else [ None ] if not any ( [ i . status in self . block_complaint_status for q in self . qualifications for i in q . complaints if q . lotID in active_lots ] ) :                  checks . append ( self . qualificationPeriod . endDate . astimezone ( TZ ) )   elif not self . lots and self . status == <str> and self . auctionPeriod and self . auctionPeriod . startDate and not self . auctionPeriod . endDate :              if now < self . auctionPeriod . startDate :                  checks . append ( self . auctionPeriod . startDate . astimezone ( TZ ) )  elif now < calc_auction_end_time ( self . numberOfBids , self . auctionPeriod . startDate ) . astimezone ( TZ ) :                  checks . append ( calc_auction_end_time ( self . numberOfBids , self . auctionPeriod . startDate ) . astimezone ( TZ ) )   elif self . lots and self . status == <str> :              for lot in self . lots :                  if lot . status != <str> or not lot . auctionPeriod or not lot . auctionPeriod . startDate or lot . auctionPeriod . endDate :                      continue  if now < lot . auctionPeriod . startDate :                      checks . append ( lot . auctionPeriod . startDate . astimezone ( TZ ) )  elif now < calc_auction_end_time ( lot . numberOfBids , lot . auctionPeriod . startDate ) . astimezone ( TZ ) :                      checks . append ( calc_auction_end_time ( lot . numberOfBids , lot . auctionPeriod . startDate ) . astimezone ( TZ ) )    elif not self . lots and self . status == <str> and not any ( [ i . status in self . block_complaint_status for i in self . complaints ] ) and not any ( [ i . status in self . block_complaint_status for a in self . awards for i in a . complaints ] ) :              standStillEnds = [ a . complaintPeriod . endDate . astimezone ( TZ ) for a in self . awards if a . complaintPeriod . endDate ] last_award_status = self . awards [ - 1 ] . status if self . awards else <str> if standStillEnds and last_award_status == <str> :                  checks . append ( max ( standStillEnds ) )   elif self . lots and self . status in [ <str> , <str> ] and not any ( [ i . status in self . block_complaint_status and i . relatedLot is None for i in self . complaints ] ) :              for lot in self . lots :                  if lot [ <str> ] != <str> :                      continue  lot_awards = [ i for i in self . awards if i . lotID == lot . id ] pending_complaints = any ( [ i [ <str> ] in self . block_complaint_status and i . relatedLot == lot . id for i in self . complaints ] ) pending_awards_complaints = any ( [ i . status in self . block_complaint_status for a in lot_awards for i in a . complaints ] ) standStillEnds = [ a . complaintPeriod . endDate . astimezone ( TZ ) for a in lot_awards if a . complaintPeriod . endDate ] last_award_status = lot_awards [ - 1 ] . status if lot_awards else <str> if not pending_complaints and not pending_awards_complaints and standStillEnds and last_award_status == <str> :                      checks . append ( max ( standStillEnds ) )    if self . status . startswith ( <str> ) :              for award in self . awards :                  if award . status == <str> and not any ( [ i . awardID == award . id for i in self . contracts ] ) :                      checks . append ( award . date )    return min ( checks ) . isoformat ( ) if checks else None  def validate_tenderPeriod ( self , data , period ) :          if not data [ <str> ] and calculate_business_date ( get_now ( ) , - timedelta ( minutes = 10 ) ) >= period . startDate :              raise ValidationError ( <str> )  if period and calculate_business_date ( period . startDate , TENDERING_DURATION , data ) > period . endDate :              raise ValidationError ( <str> . format ( TENDERING_DAYS ) )   @ serializable def numberOfBids ( self ) :          return len ( [ bid for bid in self . bids if bid . status in ( <str> , <str> , ) ] )  def check_auction_time ( self ) :          if self . auctionPeriod and self . auctionPeriod . startDate and self . auctionPeriod . shouldStartAfter and self . auctionPeriod . startDate > calculate_business_date ( parse_date ( self . auctionPeriod . shouldStartAfter ) , AUCTION_PERIOD_TIME , self , True ) :              self . auctionPeriod . startDate = None  for lot in self . lots :              if lot . auctionPeriod and lot . auctionPeriod . startDate and lot . auctionPeriod . shouldStartAfter and lot . auctionPeriod . startDate > calculate_business_date ( parse_date ( lot . auctionPeriod . shouldStartAfter ) , AUCTION_PERIOD_TIME , self , True ) :                  lot . auctionPeriod . startDate = None    def invalidate_bids_data ( self ) :          self . check_auction_time ( ) self . enquiryPeriod . invalidationDate = get_now ( ) for bid in self . bids :              if bid . status not in [ <str> , <str> ] :                  bid . status = <str>      