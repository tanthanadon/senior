from collections import namedtuple import re import struct from decimal import Decimal from hashlib import sha256 from functools import partial import electrumx . lib . util as util from electrumx . lib . hash import Base58 , hash160 , double_sha256 , hash_to_hex_str from electrumx . lib . hash import HASHX_LEN , hex_str_to_hash from electrumx . lib . script import ( _match_ops , Script , ScriptError , ScriptPubKey , OpCodes ) import electrumx . lib . tx as lib_tx import electrumx . lib . tx_dash as lib_tx_dash import electrumx . lib . tx_axe as lib_tx_axe import electrumx . server . block_processor as block_proc import electrumx . server . daemon as daemon from electrumx . server . session import ( ElectrumX , DashElectrumX , SmartCashElectrumX , AuxPoWElectrumX ) Block = namedtuple ( <str> , <str> ) class CoinError ( Exception ) :       class Coin ( object ) :      REORG_LIMIT = 200 RPC_URL_REGEX = re . compile ( <str> ) VALUE_PER_COIN = 100000000 CHUNK_SIZE = 2016 BASIC_HEADER_SIZE = 80 STATIC_BLOCK_HEADERS = True SESSIONCLS = ElectrumX DEFAULT_MAX_SEND = 1000000 DESERIALIZER = lib_tx . Deserializer DAEMON = daemon . Daemon BLOCK_PROCESSOR = block_proc . BlockProcessor HEADER_VALUES = ( <str> , <str> , <str> , <str> , <str> , <str> ) HEADER_UNPACK = struct . Struct ( <str> ) . unpack_from MEMPOOL_HISTOGRAM_REFRESH_SECS = 500 P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] XPUB_VERBYTES = bytes ( <str> , <str> ) XPRV_VERBYTES = bytes ( <str> , <str> ) WIF_BYTE = bytes . fromhex ( <str> ) ENCODE_CHECK = Base58 . encode_check DECODE_CHECK = Base58 . decode_check GENESIS_HASH = ( <str> <str> ) GENESIS_ACTIVATION = 100_000_000 PEER_DEFAULT_PORTS = { <str> : <str> , <str> : <str> } PEERS = [ ] CRASH_CLIENT_VER = None BLACKLIST_URL = None @ classmethod def lookup_coin_class ( cls , name , net ) :          req_attrs = [ <str> , <str> , <str> ] for coin in util . subclasses ( Coin ) :              if ( coin . NAME . lower ( ) == name . lower ( ) and coin . NET . lower ( ) == net . lower ( ) ) :                  coin_req_attrs = req_attrs . copy ( ) missing = [ attr for attr in coin_req_attrs if not hasattr ( coin , attr ) ] if missing :                      raise CoinError ( <str> . format ( name , missing ) )  return coin   raise CoinError ( <str> . format ( name , net ) )  @ classmethod def sanitize_url ( cls , url ) :          url = url . strip ( ) . rstrip ( <str> ) match = cls . RPC_URL_REGEX . match ( url ) if not match :              raise CoinError ( <str> . format ( url ) )  if match . groups ( ) [ 1 ] is None :              url += <str> . format ( cls . RPC_PORT )  if not url . startswith ( <str> ) and not url . startswith ( <str> ) :              url = <str> + url  return url + <str>  @ classmethod def max_fetch_blocks ( cls , height ) :          if height < 130000 :              return 1000  return 100  @ classmethod def genesis_block ( cls , block ) :          header = cls . block_header ( block , 0 ) header_hex_hash = hash_to_hex_str ( cls . header_hash ( header ) ) if header_hex_hash != cls . GENESIS_HASH :              raise CoinError ( <str> . format ( header_hex_hash , cls . GENESIS_HASH ) )  return header + bytes ( 1 )  @ classmethod def hashX_from_script ( cls , script ) :          return sha256 ( script ) . digest ( ) [ : HASHX_LEN ]  @ staticmethod def lookup_xverbytes ( verbytes ) :          for coin in util . subclasses ( Coin ) :              if verbytes == coin . XPUB_VERBYTES :                  return True , coin  if verbytes == coin . XPRV_VERBYTES :                  return False , coin   raise CoinError ( <str> )  @ classmethod def address_to_hashX ( cls , address ) :          return cls . hashX_from_script ( cls . pay_to_address_script ( address ) )  @ classmethod def P2PKH_address_from_hash160 ( cls , hash160 ) :          assert len ( hash160 ) == 20 return cls . ENCODE_CHECK ( cls . P2PKH_VERBYTE + hash160 )  @ classmethod def P2PKH_address_from_pubkey ( cls , pubkey ) :          return cls . P2PKH_address_from_hash160 ( hash160 ( pubkey ) )  @ classmethod def P2SH_address_from_hash160 ( cls , hash160 ) :          assert len ( hash160 ) == 20 return cls . ENCODE_CHECK ( cls . P2SH_VERBYTES [ 0 ] + hash160 )  @ classmethod def hash160_to_P2PKH_script ( cls , hash160 ) :          return ScriptPubKey . P2PKH_script ( hash160 )  @ classmethod def hash160_to_P2PKH_hashX ( cls , hash160 ) :          return cls . hashX_from_script ( cls . hash160_to_P2PKH_script ( hash160 ) )  @ classmethod def pay_to_address_script ( cls , address ) :          raw = cls . DECODE_CHECK ( address ) verbyte = - 1 verlen = len ( raw ) - 20 if verlen > 0 :              verbyte , hash160 = raw [ : verlen ] , raw [ verlen : ]  if verbyte == cls . P2PKH_VERBYTE :              return cls . hash160_to_P2PKH_script ( hash160 )  if verbyte in cls . P2SH_VERBYTES :              return ScriptPubKey . P2SH_script ( hash160 )  raise CoinError ( <str> . format ( address ) )  @ classmethod def privkey_WIF ( cls , privkey_bytes , compressed ) :          payload = bytearray ( cls . WIF_BYTE ) + privkey_bytes if compressed :              payload . append ( 0x01 )  return cls . ENCODE_CHECK ( payload )  @ classmethod def header_hash ( cls , header ) :          return double_sha256 ( header )  @ classmethod def header_prevhash ( cls , header ) :          return header [ 4 : 36 ]  @ classmethod def static_header_offset ( cls , height ) :          assert cls . STATIC_BLOCK_HEADERS return height * cls . BASIC_HEADER_SIZE  @ classmethod def static_header_len ( cls , height ) :          return ( cls . static_header_offset ( height + 1 ) - cls . static_header_offset ( height ) )  @ classmethod def block_header ( cls , block , height ) :          return block [ : cls . static_header_len ( height ) ]  @ classmethod def block ( cls , raw_block , height ) :          header = cls . block_header ( raw_block , height ) txs = cls . DESERIALIZER ( raw_block , start = len ( header ) ) . read_tx_block ( ) return Block ( raw_block , header , txs )  @ classmethod def decimal_value ( cls , value ) :          return Decimal ( value ) / cls . VALUE_PER_COIN  @ classmethod def warn_old_client_on_tx_broadcast ( cls , _client_ver ) :          return False   class AuxPowMixin ( object ) :      STATIC_BLOCK_HEADERS = False DESERIALIZER = lib_tx . DeserializerAuxPow SESSIONCLS = AuxPoWElectrumX TRUNCATED_HEADER_SIZE = 80 DEFAULT_MAX_SEND = 10000000 @ classmethod def header_hash ( cls , header ) :          return double_sha256 ( header [ : cls . BASIC_HEADER_SIZE ] )  @ classmethod def block_header ( cls , block , height ) :          deserializer = cls . DESERIALIZER ( block ) return deserializer . read_header ( cls . BASIC_HEADER_SIZE )   class EquihashMixin ( object ) :      STATIC_BLOCK_HEADERS = False BASIC_HEADER_SIZE = 140 DESERIALIZER = lib_tx . DeserializerEquihash HEADER_VALUES = ( <str> , <str> , <str> , <str> , <str> , <str> , <str> ) HEADER_UNPACK = struct . Struct ( <str> ) . unpack_from @ classmethod def block_header ( cls , block , height ) :          deserializer = cls . DESERIALIZER ( block ) return deserializer . read_header ( cls . BASIC_HEADER_SIZE )   class ScryptMixin ( object ) :      DESERIALIZER = lib_tx . DeserializerTxTime HEADER_HASH = None @ classmethod def header_hash ( cls , header ) :          if cls . HEADER_HASH is None :              import scrypt cls . HEADER_HASH = lambda x : scrypt . hash ( x , x , 1024 , 1 , 1 , 32 )  version , = util . unpack_le_uint32_from ( header ) if version > 6 :              return super ( ) . header_hash ( header )  else :              return cls . HEADER_HASH ( header )    class KomodoMixin ( object ) :      P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) DESERIALIZER = lib_tx . DeserializerZcash  class BitcoinMixin ( object ) :      SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) RPC_PORT = 8332  class NameMixin ( object ) :      DATA_PUSH_MULTIPLE = - 2 @ classmethod def interpret_name_prefix ( cls , script , possible_ops ) :          try :              ops = Script . get_ops ( script )  except ScriptError :              return None , script  name_op_count = None for pops in possible_ops :              template = [ ] named_index = { } n = len ( pops ) offset = 0 for i , op in enumerate ( pops ) :                  if op == cls . DATA_PUSH_MULTIPLE :                      added , template = cls . _add_data_placeholders_to_template ( ops [ i : ] , template ) offset += added - 1  elif type ( op ) == str :                      template . append ( - 1 ) named_index [ op ] = i + offset  else :                      template . append ( op )   n += offset if not _match_ops ( ops [ : n ] , template ) :                  continue  name_op_count = n named_values = { key : ops [ named_index [ key ] ] for key in named_index } break  if name_op_count is None :              return None , script  name_end_pos = cls . find_end_position_of_name ( script , name_op_count ) address_script = script [ name_end_pos : ] return named_values , address_script  @ classmethod def _add_data_placeholders_to_template ( cls , opcodes , template ) :          num_dp = cls . _read_data_placeholders_count ( opcodes ) num_2drop = num_dp // 2 num_drop = num_dp % 2 two_drops = [ OpCodes . OP_2DROP for _ in range ( num_2drop ) ] one_drops = [ OpCodes . OP_DROP for _ in range ( num_drop ) ] elements_added = num_dp + num_2drop + num_drop placeholders = [ - 1 for _ in range ( num_dp ) ] drops = two_drops + one_drops return elements_added , template + placeholders + drops  @ classmethod def _read_data_placeholders_count ( cls , opcodes ) :          data_placeholders = 0 for opcode in opcodes :              if type ( opcode ) == tuple :                  data_placeholders += 1  else :                  break   return data_placeholders  @ staticmethod def find_end_position_of_name ( script , length ) :          n = 0 for _i in range ( length ) :              op = script [ n ] n += 1 if op <= OpCodes . OP_PUSHDATA4 :                  if op < OpCodes . OP_PUSHDATA1 :                      dlen = op  elif op == OpCodes . OP_PUSHDATA1 :                      dlen = script [ n ] n += 1  elif op == OpCodes . OP_PUSHDATA2 :                      dlen , = struct . unpack ( <str> , script [ n : n + 2 ] ) n += 2  else :                      dlen , = struct . unpack ( <str> , script [ n : n + 4 ] ) n += 4  if n + dlen > len ( script ) :                      raise IndexError  n += dlen   return n   class NameIndexMixin ( NameMixin ) :      BLOCK_PROCESSOR = block_proc . NameIndexBlockProcessor @ classmethod def build_name_index_script ( cls , name ) :          from electrumx . lib . script import Script res = bytearray ( ) res . append ( cls . OP_NAME_UPDATE ) res . extend ( Script . push_data ( name ) ) res . extend ( Script . push_data ( bytes ( [ ] ) ) ) res . append ( OpCodes . OP_2DROP ) res . append ( OpCodes . OP_DROP ) res . append ( OpCodes . OP_RETURN ) return bytes ( res )  @ classmethod def split_name_script ( cls , script ) :          named_values , address_script = cls . interpret_name_prefix ( script , cls . NAME_OPERATIONS ) if named_values is None or <str> not in named_values :              return None , address_script  name_index_script = cls . build_name_index_script ( named_values [ <str> ] [ 1 ] ) return name_index_script , address_script  @ classmethod def hashX_from_script ( cls , script ) :          _ , address_script = cls . split_name_script ( script ) return super ( ) . hashX_from_script ( address_script )  @ classmethod def address_from_script ( cls , script ) :          _ , address_script = cls . split_name_script ( script ) return super ( ) . address_from_script ( address_script )  @ classmethod def name_hashX_from_script ( cls , script ) :          name_index_script , _ = cls . split_name_script ( script ) if name_index_script is None :              return None  return super ( ) . hashX_from_script ( name_index_script )   class HOdlcoin ( Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> BASIC_HEADER_SIZE = 88 P2PKH_VERBYTE = bytes . fromhex ( <str> ) WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) DESERIALIZER = lib_tx . DeserializerSegWit TX_COUNT = 258858 TX_COUNT_HEIGHT = 382138 TX_PER_BLOCK = 5  class BitcoinSV ( BitcoinMixin , Coin ) :      NAME = <str> SHORTNAME = <str> TX_COUNT = 267318795 TX_COUNT_HEIGHT = 557037 TX_PER_BLOCK = 400 PEERS = [ <str> , <str> , <str> , <str> , <str> , ] GENESIS_ACTIVATION = 620_538  class BitcoinCash ( BitcoinMixin , Coin ) :      NAME = <str> SHORTNAME = <str> TX_COUNT = 265479628 TX_COUNT_HEIGHT = 556592 TX_PER_BLOCK = 400 PEERS = [ <str> , <str> , <str> , ] BLOCK_PROCESSOR = block_proc . LTORBlockProcessor @ classmethod def warn_old_client_on_tx_broadcast ( cls , client_ver ) :          if client_ver < ( 3 , 3 , 4 ) :              return ( <str> <str> <str> <str> <str> <str> )  return False   class BitcoinSegwit ( BitcoinMixin , Coin ) :      NAME = <str> DESERIALIZER = lib_tx . DeserializerSegWit MEMPOOL_HISTOGRAM_REFRESH_SECS = 120 TX_COUNT = 318337769 TX_COUNT_HEIGHT = 524213 TX_PER_BLOCK = 1400 CRASH_CLIENT_VER = ( 3 , 2 , 3 ) BLACKLIST_URL = <str> PEERS = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , ] @ classmethod def warn_old_client_on_tx_broadcast ( cls , client_ver ) :          if client_ver < ( 3 , 3 , 3 ) :              return ( <str> <str> <str> <str> <str> <str> )  return False   class BitcoinGold ( EquihashMixin , BitcoinMixin , Coin ) :      CHUNK_SIZE = 252 NAME = <str> SHORTNAME = <str> FORK_HEIGHT = 491407 P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] DESERIALIZER = lib_tx . DeserializerEquihashSegWit TX_COUNT = 265026255 TX_COUNT_HEIGHT = 499923 TX_PER_BLOCK = 50 REORG_LIMIT = 1000 RPC_PORT = 8332 PEERS = [ <str> , <str> ] @ classmethod def header_hash ( cls , header ) :          height , = util . unpack_le_uint32_from ( header , 68 ) if height >= cls . FORK_HEIGHT :              return double_sha256 ( header )  else :              return double_sha256 ( header [ : 68 ] + header [ 100 : 112 ] )    class BitcoinGoldTestnet ( BitcoinGold ) :      FORK_HEIGHT = 1 SHORTNAME = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) TX_COUNT = 0 TX_COUNT_HEIGHT = 1 NET = <str> RPC_PORT = 18332 GENESIS_HASH = ( <str> <str> ) PEERS = [ <str> , <str> , <str> ]  class BitcoinGoldRegtest ( BitcoinGold ) :      FORK_HEIGHT = 2000 SHORTNAME = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) TX_COUNT = 0 TX_COUNT_HEIGHT = 1 NET = <str> RPC_PORT = 18444 GENESIS_HASH = ( <str> <str> ) PEERS = [ ]  class BitcoinDiamond ( BitcoinSegwit , Coin ) :      NAME = <str> SHORTNAME = <str> TX_VERSION = 12 TX_COUNT = 274277819 TX_COUNT_HEIGHT = 498678 TX_PER_BLOCK = 50 REORG_LIMIT = 1000 PEERS = [ ] VALUE_PER_COIN = 10000000 DESERIALIZER = lib_tx . DeserializerBitcoinDiamondSegWit  class Emercoin ( NameMixin , Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] GENESIS_HASH = ( <str> <str> ) TX_COUNT = 217380620 TX_COUNT_HEIGHT = 464000 TX_PER_BLOCK = 1700 VALUE_PER_COIN = 1000000 RPC_PORT = 6662 DESERIALIZER = lib_tx . DeserializerEmercoin PEERS = [ ] OP_NAME_NEW = OpCodes . OP_1 OP_NAME_UPDATE = OpCodes . OP_2 OP_NAME_DELETE = OpCodes . OP_3 NAME_NEW_OPS = [ OP_NAME_NEW , OpCodes . OP_DROP , <str> , <str> , OpCodes . OP_2DROP , NameMixin . DATA_PUSH_MULTIPLE ] NAME_UPDATE_OPS = [ OP_NAME_UPDATE , OpCodes . OP_DROP , <str> , <str> , OpCodes . OP_2DROP , NameMixin . DATA_PUSH_MULTIPLE ] NAME_DELETE_OPS = [ OP_NAME_DELETE , OpCodes . OP_DROP , <str> , OpCodes . OP_DROP ] NAME_OPERATIONS = [ NAME_NEW_OPS , NAME_UPDATE_OPS , NAME_DELETE_OPS , ] @ classmethod def block_header ( cls , block , height ) :          deserializer = cls . DESERIALIZER ( block ) if deserializer . is_merged_block ( ) :              return deserializer . read_header ( cls . BASIC_HEADER_SIZE )  return block [ : cls . static_header_len ( height ) ]  @ classmethod def header_hash ( cls , header ) :          return double_sha256 ( header [ : cls . BASIC_HEADER_SIZE ] )  @ classmethod def hashX_from_script ( cls , script ) :          _ , address_script = cls . interpret_name_prefix ( script , cls . NAME_OPERATIONS ) return super ( ) . hashX_from_script ( address_script )   class BitcoinTestnetMixin ( object ) :      SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) REORG_LIMIT = 8000 TX_COUNT = 12242438 TX_COUNT_HEIGHT = 1035428 TX_PER_BLOCK = 21 RPC_PORT = 18332 PEER_DEFAULT_PORTS = { <str> : <str> , <str> : <str> }  class BitcoinSVTestnet ( BitcoinTestnetMixin , Coin ) :      NAME = <str> PEERS = [ <str> , ] GENESIS_ACTIVATION = 1_344_302  class BitcoinSVScalingTestnet ( BitcoinSVTestnet ) :      NET = <str> PEERS = [ <str> , ] TX_COUNT = 2015 TX_COUNT_HEIGHT = 5711 TX_PER_BLOCK = 5000 GENESIS_ACTIVATION = 14_896 @ classmethod def max_fetch_blocks ( cls , height ) :          if height <= 10 :              return 100  return 3   class BitcoinCashTestnet ( BitcoinTestnetMixin , Coin ) :      NAME = <str> PEERS = [ <str> , <str> , <str> , ] BLOCK_PROCESSOR = block_proc . LTORBlockProcessor @ classmethod def warn_old_client_on_tx_broadcast ( cls , client_ver ) :          if client_ver < ( 3 , 3 , 4 ) :              return ( <str> <str> <str> <str> <str> <str> )  return False   class BitcoinSVRegtest ( BitcoinSVTestnet ) :      NET = <str> GENESIS_HASH = ( <str> <str> ) PEERS = [ ] TX_COUNT = 1 TX_COUNT_HEIGHT = 1 GENESIS_ACTIVATION = 10_000  class BitcoinSegwitTestnet ( BitcoinTestnetMixin , Coin ) :      NAME = <str> DESERIALIZER = lib_tx . DeserializerSegWit CRASH_CLIENT_VER = ( 3 , 2 , 3 ) PEERS = [ <str> , <str> , <str> , <str> , <str> , <str> , ] @ classmethod def warn_old_client_on_tx_broadcast ( cls , client_ver ) :          if client_ver < ( 3 , 3 , 3 ) :              return ( <str> <str> <str> <str> <str> <str> )  return False   class BitcoinSegwitRegtest ( BitcoinSegwitTestnet ) :      NAME = <str> NET = <str> GENESIS_HASH = ( <str> <str> ) PEERS = [ ] TX_COUNT = 1 TX_COUNT_HEIGHT = 1  class BitcoinNolnet ( BitcoinCash ) :      NET = <str> GENESIS_HASH = ( <str> <str> ) PEERS = [ ] REORG_LIMIT = 8000 TX_COUNT = 583589 TX_COUNT_HEIGHT = 8617 TX_PER_BLOCK = 50 RPC_PORT = 28332 PEER_DEFAULT_PORTS = { <str> : <str> , <str> : <str> }  class Sumcoin ( Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) , bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) DESERIALIZER = lib_tx . DeserializerSegWit TX_COUNT = 976394 TX_COUNT_HEIGHT = 659520 TX_PER_BLOCK = 2 REORG_LIMIT = 800 RPC_PORT = 3332 PEER_DEFAULT_PORTS = { <str> : <str> , <str> : <str> } PEERS = [ ]  class Litecoin ( Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) , bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) DESERIALIZER = lib_tx . DeserializerSegWit TX_COUNT = 8908766 TX_COUNT_HEIGHT = 1105256 TX_PER_BLOCK = 10 RPC_PORT = 9332 REORG_LIMIT = 800 PEERS = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , ]  class LitecoinTestnet ( Litecoin ) :      SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) , bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) TX_COUNT = 21772 TX_COUNT_HEIGHT = 20800 TX_PER_BLOCK = 2 RPC_PORT = 19332 REORG_LIMIT = 4000 PEER_DEFAULT_PORTS = { <str> : <str> , <str> : <str> } PEERS = [ <str> , <str> , ]  class LitecoinRegtest ( LitecoinTestnet ) :      NET = <str> GENESIS_HASH = ( <str> <str> ) PEERS = [ ] TX_COUNT = 1 TX_COUNT_HEIGHT = 1  class BitcoinCashRegtest ( BitcoinTestnetMixin , Coin ) :      NAME = <str> NET = <str> PEERS = [ ] GENESIS_HASH = ( <str> <str> ) TX_COUNT = 1 TX_COUNT_HEIGHT = 1 BLOCK_PROCESSOR = block_proc . LTORBlockProcessor  class Viacoin ( AuxPowMixin , Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) TX_COUNT = 113638 TX_COUNT_HEIGHT = 3473674 TX_PER_BLOCK = 30 RPC_PORT = 5222 REORG_LIMIT = 5000 DESERIALIZER = lib_tx . DeserializerAuxPowSegWit PEERS = [ <str> , <str> , <str> , <str> , ]  class ViacoinTestnet ( Viacoin ) :      SHORTNAME = <str> NET = <str> P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) RPC_PORT = 25222 REORG_LIMIT = 2500 PEER_DEFAULT_PORTS = { <str> : <str> , <str> : <str> } PEERS = [ <str> , ]  class ViacoinTestnetSegWit ( ViacoinTestnet ) :      NET = <str> DESERIALIZER = lib_tx . DeserializerSegWit  class GravityCoin ( Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> ) TX_COUNT = 446050 TX_COUNT_HEIGHT = 547346 TX_PER_BLOCK = 2 PEER_DEFAULT_PORTS = { <str> : <str> , <str> : <str> } RPC_PORT = 29200 REORG_LIMIT = 5000 PEERS = [ ]  class Bitcoinzero ( Coin ) :      NAME = <str> SHORTNAME = <str> TX_COUNT = 43798 TX_COUNT_HEIGHT = 44 TX_PER_BLOCK = 576 NET = <str> GENESIS_HASH = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) RPC_PORT = 29202 REORG_LIMIT = 5000 PEERS = [ ]  class Unitus ( Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) DESERIALIZER = lib_tx . DeserializerSegWit TX_COUNT = 3484561 TX_COUNT_HEIGHT = 1697605 TX_PER_BLOCK = 3 RPC_PORT = 50604 REORG_LIMIT = 2000 PEERS = [ <str> , ]  class Namecoin ( NameIndexMixin , AuxPowMixin , Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) DESERIALIZER = lib_tx . DeserializerAuxPowSegWit TX_COUNT = 4415768 TX_COUNT_HEIGHT = 329065 TX_PER_BLOCK = 10 RPC_PORT = 8336 PEERS = [ <str> , <str> , <str> , <str> , <str> , ] BLOCK_PROCESSOR = block_proc . NameIndexBlockProcessor OP_NAME_NEW = OpCodes . OP_1 OP_NAME_FIRSTUPDATE = OpCodes . OP_2 OP_NAME_UPDATE = OpCodes . OP_3 NAME_NEW_OPS = [ OP_NAME_NEW , - 1 , OpCodes . OP_2DROP ] NAME_FIRSTUPDATE_OPS = [ OP_NAME_FIRSTUPDATE , <str> , - 1 , - 1 , OpCodes . OP_2DROP , OpCodes . OP_2DROP ] NAME_UPDATE_OPS = [ OP_NAME_UPDATE , <str> , - 1 , OpCodes . OP_2DROP , OpCodes . OP_DROP ] NAME_OPERATIONS = [ NAME_NEW_OPS , NAME_FIRSTUPDATE_OPS , NAME_UPDATE_OPS , ]  class NamecoinTestnet ( Namecoin ) :      NAME = <str> SHORTNAME = <str> NET = <str> P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> )  class NamecoinRegtest ( NamecoinTestnet ) :      NAME = <str> NET = <str> GENESIS_HASH = ( <str> <str> ) PEERS = [ ] TX_COUNT = 1 TX_COUNT_HEIGHT = 1  class Dogecoin ( AuxPowMixin , Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) TX_COUNT = 27583427 TX_COUNT_HEIGHT = 1604979 TX_PER_BLOCK = 20 REORG_LIMIT = 2000  class DogecoinTestnet ( Dogecoin ) :      NAME = <str> SHORTNAME = <str> NET = <str> P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> )  class Motion ( Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] TX_COUNT_HEIGHT = 54353 TX_COUNT = 92701 TX_PER_BLOCK = 4 RPC_PORT = 3385 SESSIONCLS = DashElectrumX DAEMON = daemon . DashDaemon @ classmethod def header_hash ( cls , header ) :          import x16r_hash return x16r_hash . getPoWHash ( header )   class Dash ( Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) TX_COUNT_HEIGHT = 569399 TX_COUNT = 2157510 TX_PER_BLOCK = 4 RPC_PORT = 9998 PEERS = [ <str> , <str> , <str> , <str> , <str> , <str> , ] SESSIONCLS = DashElectrumX DAEMON = daemon . DashDaemon DESERIALIZER = lib_tx_dash . DeserializerDash @ classmethod def header_hash ( cls , header ) :          import x11_hash return x11_hash . getPoWHash ( header )   class DashTestnet ( Dash ) :      SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) TX_COUNT_HEIGHT = 101619 TX_COUNT = 132681 TX_PER_BLOCK = 1 RPC_PORT = 19998 PEER_DEFAULT_PORTS = { <str> : <str> , <str> : <str> } PEERS = [ <str> , <str> , ]  class Argentum ( AuxPowMixin , Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> P2PKH_VERBYTE = bytes . fromhex ( <str> ) WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) TX_COUNT = 2263089 TX_COUNT_HEIGHT = 2050260 TX_PER_BLOCK = 2000 RPC_PORT = 13581  class ArgentumTestnet ( Argentum ) :      SHORTNAME = <str> NET = <str> P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) REORG_LIMIT = 2000  class DigiByte ( Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> P2PKH_VERBYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) DESERIALIZER = lib_tx . DeserializerSegWit TX_COUNT = 1046018 TX_COUNT_HEIGHT = 1435000 TX_PER_BLOCK = 1000 RPC_PORT = 12022  class DigiByteTestnet ( DigiByte ) :      NET = <str> P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) RPC_PORT = 15022 REORG_LIMIT = 2000  class FairCoin ( Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) BASIC_HEADER_SIZE = 108 HEADER_VALUES = ( <str> , <str> , <str> , <str> , <str> , <str> ) HEADER_UNPACK = struct . Struct ( <str> ) . unpack_from TX_COUNT = 505 TX_COUNT_HEIGHT = 470 TX_PER_BLOCK = 1 RPC_PORT = 40405 PEER_DEFAULT_PORTS = { <str> : <str> , <str> : <str> } PEERS = [ <str> , <str> , ] @ classmethod def block ( cls , raw_block , height ) :          if height > 0 :              return super ( ) . block ( raw_block , height )  else :              return Block ( raw_block , cls . block_header ( raw_block , height ) , [ ] )    class Zcash ( EquihashMixin , Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] GENESIS_HASH = ( <str> <str> ) DESERIALIZER = lib_tx . DeserializerZcash TX_COUNT = 329196 TX_COUNT_HEIGHT = 68379 TX_PER_BLOCK = 5 RPC_PORT = 8232 REORG_LIMIT = 800  class ZcashTestnet ( Zcash ) :      SHORTNAME = <str> NET = <str> P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) TX_COUNT = 242312 TX_COUNT_HEIGHT = 321685 TX_PER_BLOCK = 2 RPC_PORT = 18232  class SnowGem ( EquihashMixin , Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] GENESIS_HASH = ( <str> <str> ) DESERIALIZER = lib_tx . DeserializerZcash TX_COUNT = 1680878 TX_COUNT_HEIGHT = 627250 TX_PER_BLOCK = 2 RPC_PORT = 16112 REORG_LIMIT = 800 CHUNK_SIZE = 200  class BitcoinZ ( EquihashMixin , Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] GENESIS_HASH = ( <str> <str> ) DESERIALIZER = lib_tx . DeserializerZcash TX_COUNT = 171976 TX_COUNT_HEIGHT = 81323 TX_PER_BLOCK = 3 RPC_PORT = 1979 REORG_LIMIT = 800  class Hush ( EquihashMixin , Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] GENESIS_HASH = ( <str> <str> ) DESERIALIZER = lib_tx . DeserializerZcash TX_COUNT = 329196 TX_COUNT_HEIGHT = 68379 TX_PER_BLOCK = 5 RPC_PORT = 8822 REORG_LIMIT = 800  class ZelCash ( EquihashMixin , Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] GENESIS_HASH = ( <str> <str> ) DESERIALIZER = lib_tx . DeserializerZcash TX_COUNT = 450539 TX_COUNT_HEIGHT = 167114 TX_PER_BLOCK = 3 RPC_PORT = 16124 REORG_LIMIT = 800  class Zclassic ( EquihashMixin , Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] GENESIS_HASH = ( <str> <str> ) DESERIALIZER = lib_tx . DeserializerZcash TX_COUNT = 329196 TX_COUNT_HEIGHT = 68379 TX_PER_BLOCK = 5 RPC_PORT = 8023 REORG_LIMIT = 800  class Koto ( Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] GENESIS_HASH = ( <str> <str> ) DESERIALIZER = lib_tx . DeserializerZcash TX_COUNT = 158914 TX_COUNT_HEIGHT = 67574 TX_PER_BLOCK = 3 RPC_PORT = 8432 REORG_LIMIT = 800 PEERS = [ <str> , <str> , ]  class KotoTestnet ( Koto ) :      SHORTNAME = <str> NET = <str> P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) TX_COUNT = 91144 TX_COUNT_HEIGHT = 89662 TX_PER_BLOCK = 1 RPC_PORT = 18432 PEER_DEFAULT_PORTS = { <str> : <str> , <str> : <str> } PEERS = [ <str> , ]  class Komodo ( KomodoMixin , EquihashMixin , Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> TX_COUNT = 693629 TX_COUNT_HEIGHT = 491777 TX_PER_BLOCK = 2 RPC_PORT = 7771 REORG_LIMIT = 800 PEERS = [ ]  class Monaize ( KomodoMixin , EquihashMixin , Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> TX_COUNT = 256 TX_COUNT_HEIGHT = 128 TX_PER_BLOCK = 2 RPC_PORT = 14337 REORG_LIMIT = 800 PEERS = [ ]  class Einsteinium ( Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> P2PKH_VERBYTE = bytes . fromhex ( <str> ) WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) DESERIALIZER = lib_tx . DeserializerSegWit TX_COUNT = 2087559 TX_COUNT_HEIGHT = 1358517 TX_PER_BLOCK = 2 RPC_PORT = 41879 REORG_LIMIT = 2000  class Blackcoin ( ScryptMixin , Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) DAEMON = daemon . LegacyRPCDaemon TX_COUNT = 4594999 TX_COUNT_HEIGHT = 1667070 TX_PER_BLOCK = 3 RPC_PORT = 15715 REORG_LIMIT = 5000  class Bitbay ( ScryptMixin , Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) TX_COUNT = 4594999 TX_COUNT_HEIGHT = 1667070 TX_PER_BLOCK = 3 RPC_PORT = 19914 REORG_LIMIT = 5000  class DeepOnion ( Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) DESERIALIZER = lib_tx . DeserializerTxTime DAEMON = daemon . LegacyRPCDaemon TX_COUNT = 1194707 TX_COUNT_HEIGHT = 530000 TX_PER_BLOCK = 2 RPC_PORT = 18580 REORG_LIMIT = 200 XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) PEERS = [ ] @ classmethod def header_hash ( cls , header ) :          import x13_hash return x13_hash . getPoWHash ( header )   class Peercoin ( Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) DESERIALIZER = lib_tx . DeserializerTxTimeSegWit DAEMON = daemon . FakeEstimateFeeDaemon ESTIMATE_FEE = 0.001 RELAY_FEE = 0.01 TX_COUNT = 1691771 TX_COUNT_HEIGHT = 455409 TX_PER_BLOCK = 4 RPC_PORT = 9902 REORG_LIMIT = 5000 PEERS = [ <str> ] VALUE_PER_COIN = 1000000  class PeercoinTestnet ( Peercoin ) :      NAME = <str> SHORTNAME = <str> NET = <str> P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) ESTIMATE_FEE = 0.001  class Trezarcoin ( Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> VALUE_PER_COIN = 1000000 XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) DESERIALIZER = lib_tx . DeserializerTrezarcoin HEADER_HASH = lib_tx . DeserializerTrezarcoin . blake2s HEADER_HASH_GEN = lib_tx . DeserializerTrezarcoin . blake2s_gen BASIC_HEADER_SIZE = 80 TX_COUNT = 742886 TX_COUNT_HEIGHT = 643128 TX_PER_BLOCK = 2 RPC_PORT = 17299 REORG_LIMIT = 2000 PEERS = [ <str> , ] @ classmethod def genesis_block ( cls , block ) :          header = cls . block_header ( block , 0 ) header_hex_hash = cls . HEADER_HASH_GEN ( header ) if header_hex_hash != cls . GENESIS_HASH :              raise CoinError ( <str> . format ( header_hex_hash , cls . GENESIS_HASH ) )  return header + bytes ( 1 )  @ classmethod def header_hash ( cls , header ) :          return cls . HEADER_HASH ( header )   class Reddcoin ( Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> P2PKH_VERBYTE = bytes . fromhex ( <str> ) WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) DESERIALIZER = lib_tx . DeserializerReddcoin TX_COUNT = 5413508 TX_COUNT_HEIGHT = 1717382 TX_PER_BLOCK = 3 RPC_PORT = 45443  class TokenPay ( ScryptMixin , Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) DESERIALIZER = lib_tx . DeserializerTokenPay DAEMON = daemon . LegacyRPCDaemon TX_COUNT = 147934 TX_COUNT_HEIGHT = 73967 TX_PER_BLOCK = 100 RPC_PORT = 8800 REORG_LIMIT = 500 XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) PEERS = [ <str> , <str> , ]  class Vertcoin ( Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) DESERIALIZER = lib_tx . DeserializerSegWit TX_COUNT = 2383423 TX_COUNT_HEIGHT = 759076 TX_PER_BLOCK = 3 RPC_PORT = 5888 REORG_LIMIT = 1000  class Monacoin ( Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) , bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) DESERIALIZER = lib_tx . DeserializerSegWit TX_COUNT = 2568580 TX_COUNT_HEIGHT = 1029766 TX_PER_BLOCK = 2 RPC_PORT = 9402 REORG_LIMIT = 1000 BLACKLIST_URL = <str> PEERS = [ <str> , <str> , <str> , <str> , <str> , <str> , ]  class MonacoinTestnet ( Monacoin ) :      SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) , bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) TX_COUNT = 83602 TX_COUNT_HEIGHT = 83252 TX_PER_BLOCK = 1 RPC_PORT = 19402 REORG_LIMIT = 1000 PEER_DEFAULT_PORTS = { <str> : <str> , <str> : <str> } PEERS = [ <str> , <str> , ]  class MonacoinRegtest ( MonacoinTestnet ) :      NET = <str> GENESIS_HASH = ( <str> <str> ) PEERS = [ ] TX_COUNT = 1 TX_COUNT_HEIGHT = 1  class Crown ( AuxPowMixin , Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] GENESIS_HASH = ( <str> <str> ) TX_COUNT = 13336629 TX_COUNT_HEIGHT = 1268206 TX_PER_BLOCK = 10 RPC_PORT = 9341 REORG_LIMIT = 1000 PEERS = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , ]  class Fujicoin ( Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) DESERIALIZER = lib_tx . DeserializerSegWit TX_COUNT = 170478 TX_COUNT_HEIGHT = 1521676 TX_PER_BLOCK = 1 RPC_PORT = 3776 REORG_LIMIT = 1000  class Neblio ( ScryptMixin , Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] GENESIS_HASH = ( <str> <str> ) TX_COUNT = 23675 TX_COUNT_HEIGHT = 22785 TX_PER_BLOCK = 1 RPC_PORT = 6326 REORG_LIMIT = 1000  class Bitzeny ( Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) DESERIALIZER = lib_tx . DeserializerSegWit TX_COUNT = 1408733 TX_COUNT_HEIGHT = 1015115 TX_PER_BLOCK = 1 RPC_PORT = 9252 REORG_LIMIT = 1000 @ classmethod def header_hash ( cls , header ) :          import zny_yespower_0_5 return zny_yespower_0_5 . getPoWHash ( header )   class CanadaeCoin ( AuxPowMixin , Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) ESTIMATE_FEE = 0.0001 RELAY_FEE = 0.0001 DAEMON = daemon . FakeEstimateFeeDaemon TX_COUNT = 3455905 TX_COUNT_HEIGHT = 3645419 TX_PER_BLOCK = 1 RPC_PORT = 34330 REORG_LIMIT = 1000  class Denarius ( Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) DESERIALIZER = lib_tx . DeserializerTxTime TX_COUNT = 4230 RPC_PORT = 32339 ESTIMATE_FEE = 0.00001 RELAY_FEE = 0.00001 DAEMON = daemon . FakeEstimateFeeDaemon TX_COUNT_HEIGHT = 306187 TX_PER_BLOCK = 4000 @ classmethod def header_hash ( cls , header ) :          import tribus_hash return tribus_hash . getPoWHash ( header )   class DenariusTestnet ( Denarius ) :      NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) RPC_PORT = 32338 REORG_LIMIT = 2000  class Sibcoin ( Dash ) :      NAME = <str> SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) DAEMON = daemon . DashDaemon TX_COUNT = 1000 TX_COUNT_HEIGHT = 10000 TX_PER_BLOCK = 1 RPC_PORT = 1944 REORG_LIMIT = 1000 PEERS = [ ] @ classmethod def header_hash ( cls , header ) :          import x11_gost_hash return x11_gost_hash . getPoWHash ( header )   class SibcoinTestnet ( Sibcoin ) :      SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) RPC_PORT = 11944  class Chips ( Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) DESERIALIZER = lib_tx . DeserializerSegWit TX_COUNT = 145290 TX_COUNT_HEIGHT = 318637 TX_PER_BLOCK = 2 RPC_PORT = 57776 REORG_LIMIT = 800  class Feathercoin ( Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) DESERIALIZER = lib_tx . DeserializerSegWit TX_COUNT = 3170843 TX_COUNT_HEIGHT = 1981777 TX_PER_BLOCK = 2 RPC_PORT = 9337 REORG_LIMIT = 2000 PEERS = [ <str> , <str> , <str> , ]  class UFO ( Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) DESERIALIZER = lib_tx . DeserializerSegWit TX_COUNT = 1608926 TX_COUNT_HEIGHT = 1300154 TX_PER_BLOCK = 2 RPC_PORT = 9888 REORG_LIMIT = 2000 PEERS = [ <str> , ]  class Newyorkcoin ( AuxPowMixin , Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) TX_COUNT = 5161944 TX_COUNT_HEIGHT = 3948743 TX_PER_BLOCK = 2 REORG_LIMIT = 2000  class NewyorkcoinTestnet ( Newyorkcoin ) :      SHORTNAME = <str> NET = <str> P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) TX_COUNT = 5161944 TX_COUNT_HEIGHT = 3948743 TX_PER_BLOCK = 2 REORG_LIMIT = 2000  class Bitcore ( BitcoinMixin , Coin ) :      NAME = <str> SHORTNAME = <str> P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] DESERIALIZER = lib_tx . DeserializerSegWit GENESIS_HASH = ( <str> <str> ) TX_COUNT = 126979 TX_COUNT_HEIGHT = 126946 TX_PER_BLOCK = 2 RPC_PORT = 8556 PEERS = [ <str> , <str> , <str> , <str> ]  class GameCredits ( Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> P2PKH_VERBYTE = bytes . fromhex ( <str> ) WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) DESERIALIZER = lib_tx . DeserializerSegWit TX_COUNT = 316796 TX_COUNT_HEIGHT = 2040250 TX_PER_BLOCK = 2 RPC_PORT = 40001 REORG_LIMIT = 1000  class Machinecoin ( Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) , bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) DESERIALIZER = lib_tx . DeserializerSegWit TX_COUNT = 137641 TX_COUNT_HEIGHT = 513020 TX_PER_BLOCK = 2 RPC_PORT = 40332 REORG_LIMIT = 800  class BitcoinAtom ( Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] STATIC_BLOCK_HEADERS = False DESERIALIZER = lib_tx . DeserializerBitcoinAtom HEADER_SIZE_POST_FORK = 84 BLOCK_PROOF_OF_STAKE = 0x01 BLOCK_PROOF_OF_STAKE_FLAGS = <str> TX_COUNT = 295158744 TX_COUNT_HEIGHT = 589197 TX_PER_BLOCK = 10 RPC_PORT = 9136 REORG_LIMIT = 5000 @ classmethod def header_hash ( cls , header ) :          header_to_be_hashed = header [ : cls . BASIC_HEADER_SIZE ] if len ( header ) == cls . HEADER_SIZE_POST_FORK :              flags , = util . unpack_le_uint32_from ( header , len ( header ) - 4 ) if flags & cls . BLOCK_PROOF_OF_STAKE != 0 :                  header_to_be_hashed += cls . BLOCK_PROOF_OF_STAKE_FLAGS   return double_sha256 ( header_to_be_hashed )  @ classmethod def block_header ( cls , block , height ) :          deserializer = cls . DESERIALIZER ( block ) return deserializer . read_header ( height , cls . BASIC_HEADER_SIZE )   class Decred ( Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) BASIC_HEADER_SIZE = 180 HEADER_HASH = lib_tx . DeserializerDecred . blake256 DESERIALIZER = lib_tx . DeserializerDecred DAEMON = daemon . DecredDaemon BLOCK_PROCESSOR = block_proc . DecredBlockProcessor ENCODE_CHECK = partial ( Base58 . encode_check , hash_fn = lib_tx . DeserializerDecred . blake256d ) DECODE_CHECK = partial ( Base58 . decode_check , hash_fn = lib_tx . DeserializerDecred . blake256d ) HEADER_VALUES = ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) HEADER_UNPACK = struct . Struct ( <str> ) . unpack_from TX_COUNT = 4629388 TX_COUNT_HEIGHT = 260628 TX_PER_BLOCK = 17 REORG_LIMIT = 1000 RPC_PORT = 9109 @ classmethod def header_hash ( cls , header ) :          return cls . HEADER_HASH ( header )  @ classmethod def block ( cls , raw_block , height ) :          if height > 0 :              return super ( ) . block ( raw_block , height )  else :              return Block ( raw_block , cls . block_header ( raw_block , height ) , [ ] )    class DecredTestnet ( Decred ) :      SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> ) BASIC_HEADER_SIZE = 180 ALLOW_ADVANCING_ERRORS = True TX_COUNT = 217380620 TX_COUNT_HEIGHT = 464000 TX_PER_BLOCK = 1800 REORG_LIMIT = 1000 RPC_PORT = 19109  class Axe ( Dash ) :      NAME = <str> SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) SESSIONCLS = DashElectrumX DAEMON = daemon . DashDaemon DESERIALIZER = lib_tx_axe . DeserializerAxe TX_COUNT = 18405 TX_COUNT_HEIGHT = 30237 TX_PER_BLOCK = 1 RPC_PORT = 9337 REORG_LIMIT = 1000 PEERS = [ ] @ classmethod def header_hash ( cls , header ) :          import x11_hash return x11_hash . getPoWHash ( header )   class Xuez ( Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) TX_COUNT = 30000 TX_COUNT_HEIGHT = 15000 TX_PER_BLOCK = 1 RPC_PORT = 41799 REORG_LIMIT = 1000 BASIC_HEADER_SIZE = 112 PEERS = [ ] @ classmethod def header_hash ( cls , header ) :          version , = util . unpack_le_uint32_from ( header ) import xevan_hash if version == 1 :              return xevan_hash . getPoWHash ( header [ : 80 ] )  else :              return xevan_hash . getPoWHash ( header )    class Odin ( Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) TX_COUNT = 340000 TX_COUNT_HEIGHT = 340000 TX_PER_BLOCK = 2 RPC_PORT = 22101 REORG_LIMIT = 100 BASIC_HEADER_SIZE = 80 HDR_V4_SIZE = 112 HDR_V4_HEIGHT = 143447 HDR_V4_START_OFFSET = HDR_V4_HEIGHT * BASIC_HEADER_SIZE SESSIONCLS = DashElectrumX DAEMON = daemon . DashDaemon DESERIALIZER = lib_tx . DeserializerSegWit @ classmethod def static_header_offset ( cls , height ) :          assert cls . STATIC_BLOCK_HEADERS if height >= cls . HDR_V4_HEIGHT :              relative_v4_offset = ( height - cls . HDR_V4_HEIGHT ) * cls . HDR_V4_SIZE return cls . HDR_V4_START_OFFSET + relative_v4_offset  else :              return height * cls . BASIC_HEADER_SIZE   @ classmethod def header_hash ( cls , header ) :          version , = util . unpack_le_uint32_from ( header ) if version >= 4 :              return super ( ) . header_hash ( header )  else :              import quark_hash return quark_hash . getPoWHash ( header )    class Pac ( Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) TX_COUNT_HEIGHT = 14939 TX_COUNT = 23708 TX_PER_BLOCK = 2 RPC_PORT = 7111 PEERS = [ <str> , <str> ] SESSIONCLS = DashElectrumX DAEMON = daemon . DashDaemon ESTIMATE_FEE = 0.00001 RELAY_FEE = 0.00001 @ classmethod def header_hash ( cls , header ) :          import x11_hash return x11_hash . getPoWHash ( header )   class PacTestnet ( Pac ) :      SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) TX_COUNT_HEIGHT = 16275 TX_COUNT = 16275 TX_PER_BLOCK = 1 RPC_PORT = 17111  class Zcoin ( Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) TX_COUNT = 667154 TX_COUNT_HEIGHT = 100266 TX_PER_BLOCK = 4000 IRC_PREFIX = None RPC_PORT = 8888 REORG_LIMIT = 5000 PEER_DEFAULT_PORTS = { <str> : <str> , <str> : <str> } MTP_HEADER_EXTRA_SIZE = 100 MTP_HEADER_DATA_SIZE = 198864 MTP_HEADER_DATA_START = Coin . BASIC_HEADER_SIZE + MTP_HEADER_EXTRA_SIZE MTP_HEADER_DATA_END = MTP_HEADER_DATA_START + MTP_HEADER_DATA_SIZE STATIC_BLOCK_HEADERS = False SESSIONCLS = DashElectrumX DAEMON = daemon . ZcoinMtpDaemon DESERIALIZER = lib_tx . DeserializerZcoin PEERS = [ <str> ] @ classmethod def is_mtp ( cls , header ) :          from electrumx . lib . util import unpack_le_uint32_from , hex_to_bytes if isinstance ( header , str ) :              nVersion , = unpack_le_uint32_from ( hex_to_bytes ( header [ 0 : 4 * 2 ] ) )  elif isinstance ( header , bytes ) :              nVersion , = unpack_le_uint32_from ( header [ 0 : 4 ] )  else :              raise <str>  return nVersion & 0x1000  @ classmethod def block_header ( cls , block , height ) :          sz = cls . BASIC_HEADER_SIZE if cls . is_mtp ( block ) :              sz += cls . MTP_HEADER_EXTRA_SIZE  return block [ : sz ]  @ classmethod def header_hash ( cls , header ) :          sz = cls . BASIC_HEADER_SIZE if cls . is_mtp ( header ) :              sz += cls . MTP_HEADER_EXTRA_SIZE  return double_sha256 ( header [ : sz ] )   class ZcoinTestnet ( Zcoin ) :      SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = <str> <str> REORG_LIMIT = 8000 RPC_PORT = 18888  class GINCoin ( Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) TX_COUNT_HEIGHT = 225000 TX_COUNT = 470784 TX_PER_BLOCK = 4 RPC_PORT = 10211 PEERS = [ <str> ] SESSIONCLS = DashElectrumX DAEMON = daemon . DashDaemon @ classmethod def header_hash ( cls , header ) :          timestamp = util . unpack_le_uint32_from ( header , 68 ) [ 0 ] if timestamp > 1550246400 :              import x16rt_hash return x16rt_hash . getPoWHash ( header )  elif timestamp > 1525651200 :              import lyra2z_hash return lyra2z_hash . getPoWHash ( header )  import neoscrypt return neoscrypt . getPoWHash ( header )   class Polis ( Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) TX_COUNT_HEIGHT = 280600 TX_COUNT = 635415 TX_PER_BLOCK = 4 RPC_PORT = 24127 PEERS = [ <str> ] SESSIONCLS = DashElectrumX DAEMON = daemon . DashDaemon @ classmethod def header_hash ( cls , header ) :          import x11_hash return x11_hash . getPoWHash ( header )   class MNPCoin ( Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) TX_COUNT_HEIGHT = 248000 TX_COUNT = 506447 TX_PER_BLOCK = 4 RPC_PORT = 13373 PEERS = [ <str> ] SESSIONCLS = DashElectrumX DAEMON = daemon . DashDaemon @ classmethod def header_hash ( cls , header ) :          import quark_hash return quark_hash . getPoWHash ( header )   class ColossusXT ( Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) TX_COUNT_HEIGHT = 356500 BASIC_HEADER_SIZE = 80 HDR_V5_HEIGHT = 500000 HDR_V5_SIZE = 112 HDR_V5_START_OFFSET = HDR_V5_HEIGHT * BASIC_HEADER_SIZE TX_COUNT = 761041 TX_PER_BLOCK = 4 RPC_PORT = 51473 PEERS = [ <str> ] SESSIONCLS = DashElectrumX DAEMON = daemon . DashDaemon @ classmethod def static_header_offset ( cls , height ) :          assert cls . STATIC_BLOCK_HEADERS if height >= cls . HDR_V5_HEIGHT :              relative_v4_offset = ( height - cls . HDR_V5_HEIGHT ) * cls . HDR_V5_SIZE return cls . HDR_V5_START_OFFSET + relative_v4_offset  else :              return height * cls . BASIC_HEADER_SIZE   @ classmethod def header_hash ( cls , header ) :          version , = util . unpack_le_uint32_from ( header ) if version >= 5 :              return super ( ) . header_hash ( header )  else :              import quark_hash return quark_hash . getPoWHash ( header )    class Minexcoin ( EquihashMixin , Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> P2PKH_VERBYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) STATIC_BLOCK_HEADERS = True BASIC_HEADER_SIZE = 209 HEADER_SIZE_NO_SOLUTION = 140 TX_COUNT = 327963 TX_COUNT_HEIGHT = 74495 TX_PER_BLOCK = 5 RPC_PORT = 8022 CHUNK_SIZE = 960 PEERS = [ <str> , <str> , <str> ] @ classmethod def block_header ( cls , block , height ) :          deserializer = cls . DESERIALIZER ( block ) return deserializer . read_header ( cls . HEADER_SIZE_NO_SOLUTION )   class Groestlcoin ( Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) DESERIALIZER = lib_tx . DeserializerGroestlcoin TX_COUNT = 115900 TX_COUNT_HEIGHT = 1601528 TX_PER_BLOCK = 5 RPC_PORT = 1441 BLACKLIST_URL = <str> PEERS = [ <str> , <str> , <str> , <str> , ] def grshash ( data ) :          import groestlcoin_hash return groestlcoin_hash . getHash ( data , len ( data ) )  @ classmethod def header_hash ( cls , header ) :          return cls . grshash ( header )  ENCODE_CHECK = partial ( Base58 . encode_check , hash_fn = grshash ) DECODE_CHECK = partial ( Base58 . decode_check , hash_fn = grshash )  class GroestlcoinTestnet ( Groestlcoin ) :      SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) RPC_PORT = 17766 PEERS = [ <str> , <str> , <str> , <str> , ]  class Pivx ( Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTE = bytes . fromhex ( <str> ) WIF_BYTE = bytes . fromhex ( <str> ) TX_COUNT_HEIGHT = 569399 TX_COUNT = 2157510 TX_PER_BLOCK = 1 STATIC_BLOCK_HEADERS = False RPC_PORT = 51470 ZEROCOIN_HEADER = 112 ZEROCOIN_START_HEIGHT = 863787 ZEROCOIN_BLOCK_VERSION = 4 @ classmethod def static_header_len ( cls , height ) :          if ( height >= cls . ZEROCOIN_START_HEIGHT ) :              return cls . ZEROCOIN_HEADER  else :              return cls . BASIC_HEADER_SIZE   @ classmethod def header_hash ( cls , header ) :          version , = struct . unpack ( <str> , header [ : 4 ] ) if version >= cls . ZEROCOIN_BLOCK_VERSION :              return super ( ) . header_hash ( header )  else :              import quark_hash return quark_hash . getPoWHash ( header )    class PivxTestnet ( Pivx ) :      NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTE = bytes . fromhex ( <str> ) WIF_BYTE = bytes . fromhex ( <str> ) TX_PER_BLOCK = 4 RPC_PORT = 51472 ZEROCOIN_START_HEIGHT = 201564  class Bitg ( Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> ) DAEMON = daemon . DashDaemon TX_COUNT = 1000 TX_COUNT_HEIGHT = 10000 TX_PER_BLOCK = 1 RPC_PORT = 9332 REORG_LIMIT = 1000 SESSIONCLS = DashElectrumX DAEMON = daemon . DashDaemon @ classmethod def header_hash ( cls , header ) :          import quark_hash return quark_hash . getPoWHash ( header )   class tBitg ( Bitg ) :      SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> ) RPC_PORT = 19332  class EXOS ( Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTE = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) RPC_PORT = 4561 TX_COUNT = 1000 TX_COUNT_HEIGHT = 10000 TX_PER_BLOCK = 4 DAEMON = daemon . PreLegacyRPCDaemon DESERIALIZER = lib_tx . DeserializerTxTime @ classmethod def header_hash ( cls , header ) :          version , = util . unpack_le_uint32_from ( header ) if version > 2 :              return double_sha256 ( header )  else :              return hex_str_to_hash ( EXOS . GENESIS_HASH )    class EXOSTestnet ( EXOS ) :      SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTE = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) RPC_PORT = 14561 @ classmethod def header_hash ( cls , header ) :          version , = util . unpack_le_uint32_from ( header ) if version > 2 :              return double_sha256 ( header )  else :              return hex_str_to_hash ( EXOSTestnet . GENESIS_HASH )    class SmartCash ( Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) DESERIALIZER = lib_tx . DeserializerSmartCash RPC_PORT = 9679 REORG_LIMIT = 5000 TX_COUNT = 1115016 TX_COUNT_HEIGHT = 541656 TX_PER_BLOCK = 1 ENCODE_CHECK = partial ( Base58 . encode_check , hash_fn = lib_tx . DeserializerSmartCash . keccak ) DECODE_CHECK = partial ( Base58 . decode_check , hash_fn = lib_tx . DeserializerSmartCash . keccak ) HEADER_HASH = lib_tx . DeserializerSmartCash . keccak DAEMON = daemon . SmartCashDaemon SESSIONCLS = SmartCashElectrumX @ classmethod def header_hash ( cls , header ) :          return cls . HEADER_HASH ( header )   class NIX ( Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] GENESIS_HASH = ( <str> <str> ) DESERIALIZER = lib_tx . DeserializerSegWit TX_COUNT = 114240 TX_COUNT_HEIGHT = 87846 TX_PER_BLOCK = 3 RPC_PORT = 6215 REORG_LIMIT = 1000  class NIXTestnet ( NIX ) :      SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTE = [ bytes . fromhex ( <str> ) ] RPC_PORT = 16215 DESERIALIZER = lib_tx . DeserializerSegWit  class Noir ( Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) RPC_PORT = 8825 TX_COUNT = 586369 TX_COUNT_HEIGHT = 379290 TX_PER_BLOCK = 5  class BitcoinPlus ( Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) DESERIALIZER = lib_tx . DeserializerTxTime DAEMON = daemon . LegacyRPCDaemon TX_COUNT = 1479247 TX_COUNT_HEIGHT = 749740 TX_PER_BLOCK = 2 RPC_PORT = 8885 REORG_LIMIT = 2000 @ classmethod def header_hash ( cls , header ) :          import x13_hash return x13_hash . getPoWHash ( header )   class Myriadcoin ( AuxPowMixin , Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) DESERIALIZER = lib_tx . DeserializerAuxPowSegWit TX_COUNT = 1976629 TX_COUNT_HEIGHT = 2580356 TX_PER_BLOCK = 20 REORG_LIMIT = 2000 RPC_PORT = 10889  class MyriadcoinTestnet ( Myriadcoin ) :      NAME = <str> SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> )  class Sparks ( Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) TX_COUNT_HEIGHT = 117400 TX_COUNT = 162310 TX_PER_BLOCK = 4 RPC_PORT = 8818 SESSIONCLS = DashElectrumX DAEMON = daemon . DashDaemon @ classmethod def header_hash ( cls , header ) :          import neoscrypt return neoscrypt . getPoWHash ( header )   class Bitsend ( Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) TX_COUNT = 974672 TX_COUNT_HEIGHT = 586022 TX_PER_BLOCK = 2 RPC_PORT = 8800 REORG_LIMIT = 1000 DESERIALIZER = lib_tx . DeserializerSegWit XEVAN_TIMESTAMP = 1477958400 PEERS = [ <str> , <str> ] @ classmethod def header_hash ( cls , header ) :          timestamp , = util . unpack_le_uint32_from ( header , 68 ) if timestamp > cls . XEVAN_TIMESTAMP :              import xevan_hash return xevan_hash . getPoWHash ( header )  else :              import x11_hash return x11_hash . getPoWHash ( header )   @ classmethod def genesis_block ( cls , block ) :          header = cls . block_header ( block , 0 ) header_hex_hash = hash_to_hex_str ( cls . header_hash ( header ) ) if header_hex_hash != cls . GENESIS_HASH :              raise CoinError ( <str> . format ( header_hex_hash , cls . GENESIS_HASH ) )  return header + bytes ( 1 )   class Ritocoin ( Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] GENESIS_HASH = ( <str> <str> ) DESERIALIZER = lib_tx . DeserializerSegWit TX_COUNT = 1188090 TX_COUNT_HEIGHT = 296030 TX_PER_BLOCK = 3 RPC_PORT = 8766 REORG_LIMIT = 55 PEERS = [ <str> ] @ classmethod def header_hash ( cls , header ) :          import x21s_hash return x21s_hash . getPoWHash ( header )   class Ravencoin ( Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] GENESIS_HASH = ( <str> <str> ) DESERIALIZER = lib_tx . DeserializerSegWit X16RV2_ACTIVATION_TIME = 1569945600 TX_COUNT = 5626682 TX_COUNT_HEIGHT = 887000 TX_PER_BLOCK = 6 RPC_PORT = 8766 REORG_LIMIT = 55 PEERS = [ ] @ classmethod def header_hash ( cls , header ) :          timestamp = util . unpack_le_uint32_from ( header , 68 ) [ 0 ] if timestamp >= cls . X16RV2_ACTIVATION_TIME :              import x16rv2_hash return x16rv2_hash . getPoWHash ( header )  else :              import x16r_hash return x16r_hash . getPoWHash ( header )    class RavencoinTestnet ( Ravencoin ) :      NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) X16RV2_ACTIVATION_TIME = 1567533600 TX_COUNT = 496158 TX_COUNT_HEIGHT = 420500 TX_PER_BLOCK = 1 RPC_PORT = 18766 PEER_DEFAULT_PORTS = { <str> : <str> , <str> : <str> } REORG_LIMIT = 55 PEERS = [ ]  class Bolivarcoin ( Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) TX_COUNT = 1082515 TX_COUNT_HEIGHT = 540410 TX_PER_BLOCK = 10 RPC_PORT = 3563 REORG_LIMIT = 800 PEERS = [ ] SESSIONCLS = DashElectrumX DAEMON = daemon . DashDaemon @ classmethod def header_hash ( cls , header ) :          import x11_hash return x11_hash . getPoWHash ( header )   class Onixcoin ( Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) TX_COUNT = 431808 TX_COUNT_HEIGHT = 321132 TX_PER_BLOCK = 10 RPC_PORT = 41019 REORG_LIMIT = 800 PEERS = [ ] SESSIONCLS = DashElectrumX DAEMON = daemon . DashDaemon @ classmethod def header_hash ( cls , header ) :          import x11_hash return x11_hash . getPoWHash ( header )   class Electra ( Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) RPC_PORT = 5788 TX_COUNT = 615729 TX_COUNT_HEIGHT = 205243 TX_PER_BLOCK = 3 REORG_LIMIT = 100 DESERIALIZER = lib_tx . DeserializerElectra @ classmethod def header_hash ( cls , header ) :          version , = util . unpack_le_uint32_from ( header ) import nist5_hash if version != 8 :              return nist5_hash . getPoWHash ( header )  else :              return double_sha256 ( header )    class ECCoin ( Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> DESERIALIZER = lib_tx . DeserializerECCoin XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] GENESIS_HASH = ( <str> ) TX_COUNT = 4661197 TX_COUNT_HEIGHT = 2114846 TX_PER_BLOCK = 10 VALUE_PER_COIN = 1000000 RPC_PORT = 19119 @ classmethod def header_hash ( cls , header ) :          import scrypt return scrypt . hash ( header , header , 1024 , 1 , 1 , 32 )   class Bellcoin ( Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) DESERIALIZER = lib_tx . DeserializerSegWit TX_COUNT = 264129 TX_COUNT_HEIGHT = 219574 TX_PER_BLOCK = 5 RPC_PORT = 25252 REORG_LIMIT = 1000 PEERS = [ <str> , <str> , ] @ classmethod def header_hash ( cls , header ) :          import bell_yespower return bell_yespower . getPoWHash ( header )   class CPUchain ( Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] GENESIS_HASH = ( <str> <str> ) DESERIALIZER = lib_tx . DeserializerSegWit TX_COUNT = 4471 TX_COUNT_HEIGHT = 3491 TX_PER_BLOCK = 2 RPC_PORT = 19707 REORG_LIMIT = 1000 PEERS = [ <str> , ] @ classmethod def header_hash ( cls , header ) :          import cpupower return cpupower . getPoWHash ( header )   class Xaya ( NameIndexMixin , AuxPowMixin , Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) TX_COUNT = 1147749 TX_COUNT_HEIGHT = 1030000 TX_PER_BLOCK = 2 DESERIALIZER = lib_tx . DeserializerXaya TRUNCATED_HEADER_SIZE = 80 + 5 RPC_PORT = 8396 PEERS = [ <str> , <str> , ] OP_NAME_REGISTER = OpCodes . OP_1 OP_NAME_UPDATE = OpCodes . OP_2 NAME_REGISTER_OPS = [ OP_NAME_REGISTER , <str> , - 1 , OpCodes . OP_2DROP , OpCodes . OP_DROP ] NAME_UPDATE_OPS = [ OP_NAME_UPDATE , <str> , - 1 , OpCodes . OP_2DROP , OpCodes . OP_DROP ] NAME_OPERATIONS = [ NAME_REGISTER_OPS , NAME_UPDATE_OPS , ] @ classmethod def genesis_block ( cls , block ) :          super ( ) . genesis_block ( block ) return block   class XayaTestnet ( Xaya ) :      SHORTNAME = <str> NET = <str> P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) TX_COUNT = 51557 TX_COUNT_HEIGHT = 49000 TX_PER_BLOCK = 1 RPC_PORT = 18396 PEERS = [ ]  class XayaRegtest ( XayaTestnet ) :      NET = <str> GENESIS_HASH = ( <str> <str> ) RPC_PORT = 18493  class GravityZeroCoin ( ScryptMixin , Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> P2PKH_VERBYTE = bytes . fromhex ( <str> ) WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> ) DAEMON = daemon . FakeEstimateLegacyRPCDaemon TX_COUNT = 100 TX_COUNT_HEIGHT = 747635 TX_PER_BLOCK = 2 RPC_PORT = 36442 ESTIMATE_FEE = 0.01 RELAY_FEE = 0.01  class Simplicity ( Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTE = bytes . fromhex ( <str> ) WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> ) RPC_PORT = 11958 TX_COUNT = 1726548 TX_COUNT_HEIGHT = 1040000 TX_PER_BLOCK = 5 REORG_LIMIT = 100 DESERIALIZER = lib_tx . DeserializerSimplicity @ classmethod def header_hash ( cls , header ) :          version , = util . unpack_le_uint32_from ( header ) if version < 2 :              import quark_hash return quark_hash . getPoWHash ( header )  else :              return double_sha256 ( header )    class Myce ( Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTE = bytes . fromhex ( <str> ) WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> ) RPC_PORT = 23512 TX_COUNT = 1568977 TX_COUNT_HEIGHT = 774450 TX_PER_BLOCK = 3 REORG_LIMIT = 100 DESERIALIZER = lib_tx . DeserializerSimplicity @ classmethod def header_hash ( cls , header ) :          version , = util . unpack_le_uint32_from ( header ) if version < 7 :              import scrypt return scrypt . hash ( header , header , 1024 , 1 , 1 , 32 )  else :              return double_sha256 ( header )    class Navcoin ( Coin ) :      NAME = <str> SHORTNAME = <str> NET = <str> XPUB_VERBYTES = bytes . fromhex ( <str> ) XPRV_VERBYTES = bytes . fromhex ( <str> ) P2PKH_VERBYTE = bytes . fromhex ( <str> ) P2SH_VERBYTES = [ bytes . fromhex ( <str> ) ] WIF_BYTE = bytes . fromhex ( <str> ) GENESIS_HASH = ( <str> <str> ) DESERIALIZER = lib_tx . DeserializerTxTimeSegWitNavCoin TX_COUNT = 137641 TX_COUNT_HEIGHT = 3649662 TX_PER_BLOCK = 2 RPC_PORT = 44444 REORG_LIMIT = 1000 @ classmethod def header_hash ( cls , header ) :          if int . from_bytes ( header [ : 4 ] , <str> ) > 6 :              return double_sha256 ( header )  else :              import x13_hash return x13_hash . getPoWHash ( header )     