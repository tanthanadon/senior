from collections import namedtuple from hashlib import blake2s from electrumx . lib . hash import sha256 , double_sha256 , hash_to_hex_str from electrumx . lib . script import OpCodes from electrumx . lib . util import ( unpack_le_int32_from , unpack_le_int64_from , unpack_le_uint16_from , unpack_be_uint16_from , unpack_le_uint32_from , unpack_le_uint64_from , pack_le_int32 , pack_varint , pack_le_uint32 , pack_le_int64 , pack_varbytes , ) ZERO = bytes ( 32 ) MINUS_1 = 4294967295 class Tx ( namedtuple ( <str> , <str> ) ) :      def serialize ( self ) :          return <str> . join ( ( pack_le_int32 ( self . version ) , pack_varint ( len ( self . inputs ) ) , <str> . join ( tx_in . serialize ( ) for tx_in in self . inputs ) , pack_varint ( len ( self . outputs ) ) , <str> . join ( tx_out . serialize ( ) for tx_out in self . outputs ) , pack_le_uint32 ( self . locktime ) ) )   class TxInput ( namedtuple ( <str> , <str> ) ) :      def __str__ ( self ) :          script = self . script . hex ( ) prev_hash = hash_to_hex_str ( self . prev_hash ) return ( <str> . format ( prev_hash , self . prev_idx , script , self . sequence ) )  def is_generation ( self ) :          return self . prev_idx == MINUS_1 and self . prev_hash == ZERO  def serialize ( self ) :          return <str> . join ( ( self . prev_hash , pack_le_uint32 ( self . prev_idx ) , pack_varbytes ( self . script ) , pack_le_uint32 ( self . sequence ) , ) )   class TxOutput ( namedtuple ( <str> , <str> ) ) :      def serialize ( self ) :          return <str> . join ( ( pack_le_int64 ( self . value ) , pack_varbytes ( self . pk_script ) , ) )   class Deserializer ( object ) :      TX_HASH_FN = staticmethod ( double_sha256 ) def __init__ ( self , binary , start = 0 ) :          assert isinstance ( binary , bytes ) self . binary = binary self . binary_length = len ( binary ) self . cursor = start  def read_tx ( self ) :          return Tx ( self . _read_le_int32 ( ) , self . _read_inputs ( ) , self . _read_outputs ( ) , self . _read_le_uint32 ( ) )  def read_tx_and_hash ( self ) :          start = self . cursor return self . read_tx ( ) , self . TX_HASH_FN ( self . binary [ start : self . cursor ] )  def read_tx_and_vsize ( self ) :          return self . read_tx ( ) , self . binary_length  def read_tx_block ( self ) :          read = self . read_tx_and_hash return [ read ( ) for _ in range ( self . _read_varint ( ) ) ]  def _read_inputs ( self ) :          read_input = self . _read_input return [ read_input ( ) for i in range ( self . _read_varint ( ) ) ]  def _read_input ( self ) :          return TxInput ( self . _read_nbytes ( 32 ) , self . _read_le_uint32 ( ) , self . _read_varbytes ( ) , self . _read_le_uint32 ( ) )  def _read_outputs ( self ) :          read_output = self . _read_output return [ read_output ( ) for i in range ( self . _read_varint ( ) ) ]  def _read_output ( self ) :          return TxOutput ( self . _read_le_int64 ( ) , self . _read_varbytes ( ) , )  def _read_byte ( self ) :          cursor = self . cursor self . cursor += 1 return self . binary [ cursor ]  def _read_nbytes ( self , n ) :          cursor = self . cursor self . cursor = end = cursor + n assert self . binary_length >= end return self . binary [ cursor : end ]  def _read_varbytes ( self ) :          return self . _read_nbytes ( self . _read_varint ( ) )  def _read_varint ( self ) :          n = self . binary [ self . cursor ] self . cursor += 1 if n < 253 :              return n  if n == 253 :              return self . _read_le_uint16 ( )  if n == 254 :              return self . _read_le_uint32 ( )  return self . _read_le_uint64 ( )  def _read_le_int32 ( self ) :          result , = unpack_le_int32_from ( self . binary , self . cursor ) self . cursor += 4 return result  def _read_le_int64 ( self ) :          result , = unpack_le_int64_from ( self . binary , self . cursor ) self . cursor += 8 return result  def _read_le_uint16 ( self ) :          result , = unpack_le_uint16_from ( self . binary , self . cursor ) self . cursor += 2 return result  def _read_be_uint16 ( self ) :          result , = unpack_be_uint16_from ( self . binary , self . cursor ) self . cursor += 2 return result  def _read_le_uint32 ( self ) :          result , = unpack_le_uint32_from ( self . binary , self . cursor ) self . cursor += 4 return result  def _read_le_uint64 ( self ) :          result , = unpack_le_uint64_from ( self . binary , self . cursor ) self . cursor += 8 return result   class TxSegWit ( namedtuple ( <str> , <str> <str> ) ) :       class DeserializerSegWit ( Deserializer ) :      def _read_witness ( self , fields ) :          read_witness_field = self . _read_witness_field return [ read_witness_field ( ) for i in range ( fields ) ]  def _read_witness_field ( self ) :          read_varbytes = self . _read_varbytes return [ read_varbytes ( ) for i in range ( self . _read_varint ( ) ) ]  def _read_tx_parts ( self ) :          start = self . cursor marker = self . binary [ self . cursor + 4 ] if marker :              tx = super ( ) . read_tx ( ) tx_hash = self . TX_HASH_FN ( self . binary [ start : self . cursor ] ) return tx , tx_hash , self . binary_length  version = self . _read_le_int32 ( ) orig_ser = self . binary [ start : self . cursor ] marker = self . _read_byte ( ) flag = self . _read_byte ( ) start = self . cursor inputs = self . _read_inputs ( ) outputs = self . _read_outputs ( ) orig_ser += self . binary [ start : self . cursor ] base_size = self . cursor - start witness = self . _read_witness ( len ( inputs ) ) start = self . cursor locktime = self . _read_le_uint32 ( ) orig_ser += self . binary [ start : self . cursor ] vsize = ( 3 * base_size + self . binary_length ) // 4 return TxSegWit ( version , marker , flag , inputs , outputs , witness , locktime ) , self . TX_HASH_FN ( orig_ser ) , vsize  def read_tx ( self ) :          return self . _read_tx_parts ( ) [ 0 ]  def read_tx_and_hash ( self ) :          tx , tx_hash , _vsize = self . _read_tx_parts ( ) return tx , tx_hash  def read_tx_and_vsize ( self ) :          tx , _tx_hash , vsize = self . _read_tx_parts ( ) return tx , vsize   class DeserializerAuxPow ( Deserializer ) :      VERSION_AUXPOW = ( 1 << 8 ) def read_auxpow ( self ) :          start = self . cursor self . read_tx ( ) self . cursor += 32 merkle_size = self . _read_varint ( ) self . cursor += 32 * merkle_size self . cursor += 4 merkle_size = self . _read_varint ( ) self . cursor += 32 * merkle_size self . cursor += 4 self . cursor += 80 end = self . cursor self . cursor = start return self . _read_nbytes ( end - start )  def read_header ( self , static_header_size ) :          start = self . cursor version = self . _read_le_uint32 ( ) if version & self . VERSION_AUXPOW :              self . cursor = start self . cursor += static_header_size self . read_auxpow ( ) header_end = self . cursor  else :              header_end = start + static_header_size  self . cursor = start return self . _read_nbytes ( header_end - start )   class DeserializerAuxPowSegWit ( DeserializerSegWit , DeserializerAuxPow ) :      pass  class DeserializerEquihash ( Deserializer ) :      def read_header ( self , static_header_size ) :          start = self . cursor self . cursor += static_header_size solution_size = self . _read_varint ( ) self . cursor += solution_size header_end = self . cursor self . cursor = start return self . _read_nbytes ( header_end )   class DeserializerEquihashSegWit ( DeserializerSegWit , DeserializerEquihash ) :      pass  class TxJoinSplit ( namedtuple ( <str> , <str> ) ) :       class DeserializerZcash ( DeserializerEquihash ) :      def read_tx ( self ) :          header = self . _read_le_uint32 ( ) overwintered = ( ( header >> 31 ) == 1 ) if overwintered :              version = header & 0x7fffffff self . cursor += 4  else :              version = header  is_overwinter_v3 = version == 3 is_sapling_v4 = version == 4 base_tx = TxJoinSplit ( version , self . _read_inputs ( ) , self . _read_outputs ( ) , self . _read_le_uint32 ( ) ) if is_overwinter_v3 or is_sapling_v4 :              self . cursor += 4  has_shielded = False if is_sapling_v4 :              self . cursor += 8 shielded_spend_size = self . _read_varint ( ) self . cursor += shielded_spend_size * 384 shielded_output_size = self . _read_varint ( ) self . cursor += shielded_output_size * 948 has_shielded = shielded_spend_size > 0 or shielded_output_size > 0  if base_tx . version >= 2 :              joinsplit_size = self . _read_varint ( ) if joinsplit_size > 0 :                  joinsplit_desc_len = 1506 + ( 192 if is_sapling_v4 else 296 ) self . cursor += joinsplit_size * joinsplit_desc_len self . cursor += 32 self . cursor += 64   if is_sapling_v4 and has_shielded :              self . cursor += 64  return base_tx   class TxTime ( namedtuple ( <str> , <str> ) ) :       class DeserializerTxTime ( Deserializer ) :      def read_tx ( self ) :          return TxTime ( self . _read_le_int32 ( ) , self . _read_le_uint32 ( ) , self . _read_inputs ( ) , self . _read_outputs ( ) , self . _read_le_uint32 ( ) , )   class TxTimeSegWit ( namedtuple ( <str> , <str> ) ) :       class DeserializerTxTimeSegWit ( DeserializerTxTime ) :      def _read_witness ( self , fields ) :          read_witness_field = self . _read_witness_field return [ read_witness_field ( ) for _ in range ( fields ) ]  def _read_witness_field ( self ) :          read_varbytes = self . _read_varbytes return [ read_varbytes ( ) for _ in range ( self . _read_varint ( ) ) ]  def _read_tx_parts ( self ) :          start = self . cursor marker = self . binary [ self . cursor + 8 ] if marker :              tx = super ( ) . read_tx ( ) tx_hash = self . TX_HASH_FN ( self . binary [ start : self . cursor ] ) return tx , tx_hash , self . binary_length  version = self . _read_le_int32 ( ) time = self . _read_le_uint32 ( ) orig_ser = self . binary [ start : self . cursor ] marker = self . _read_byte ( ) flag = self . _read_byte ( ) start = self . cursor inputs = self . _read_inputs ( ) outputs = self . _read_outputs ( ) orig_ser += self . binary [ start : self . cursor ] base_size = self . cursor - start witness = self . _read_witness ( len ( inputs ) ) start = self . cursor locktime = self . _read_le_uint32 ( ) orig_ser += self . binary [ start : self . cursor ] vsize = ( 3 * base_size + self . binary_length ) // 4 return TxTimeSegWit ( version , time , marker , flag , inputs , outputs , witness , locktime ) , self . TX_HASH_FN ( orig_ser ) , vsize  def read_tx ( self ) :          return self . _read_tx_parts ( ) [ 0 ]  def read_tx_and_hash ( self ) :          tx , tx_hash , vsize = self . _read_tx_parts ( ) return tx , tx_hash  def read_tx_and_vsize ( self ) :          tx , tx_hash , vsize = self . _read_tx_parts ( ) return tx , vsize   class DeserializerTxTimeSegWitNavCoin ( DeserializerTxTime ) :      def _read_witness ( self , fields ) :          read_witness_field = self . _read_witness_field return [ read_witness_field ( ) for _ in range ( fields ) ]  def _read_witness_field ( self ) :          read_varbytes = self . _read_varbytes return [ read_varbytes ( ) for _ in range ( self . _read_varint ( ) ) ]  def read_tx_no_segwit ( self ) :          version = self . _read_le_int32 ( ) time = self . _read_le_uint32 ( ) inputs = self . _read_inputs ( ) outputs = self . _read_outputs ( ) locktime = self . _read_le_uint32 ( ) strDZeel = <str> if version >= 2 :              strDZeel = self . _read_varbytes ( )  return TxTime ( version , time , inputs , outputs , locktime )  def _read_tx_parts ( self ) :          start = self . cursor marker = self . binary [ self . cursor + 8 ] if marker :              tx = self . read_tx_no_segwit ( ) tx_hash = self . TX_HASH_FN ( self . binary [ start : self . cursor ] ) return tx , tx_hash , self . binary_length  version = self . _read_le_int32 ( ) time = self . _read_le_uint32 ( ) orig_ser = self . binary [ start : self . cursor ] marker = self . _read_byte ( ) flag = self . _read_byte ( ) start = self . cursor inputs = self . _read_inputs ( ) outputs = self . _read_outputs ( ) orig_ser += self . binary [ start : self . cursor ] base_size = self . cursor - start witness = self . _read_witness ( len ( inputs ) ) start = self . cursor locktime = self . _read_le_uint32 ( ) strDZeel = <str> if version >= 2 :              strDZeel = self . _read_varbytes ( )  vsize = ( 3 * base_size + self . binary_length ) // 4 orig_ser += self . binary [ start : self . cursor ] return TxTimeSegWit ( version , time , marker , flag , inputs , outputs , witness , locktime ) , self . TX_HASH_FN ( orig_ser ) , vsize  def read_tx ( self ) :          return self . _read_tx_parts ( ) [ 0 ]  def read_tx_and_hash ( self ) :          tx , tx_hash , vsize = self . _read_tx_parts ( ) return tx , tx_hash  def read_tx_and_vsize ( self ) :          tx , tx_hash , vsize = self . _read_tx_parts ( ) return tx , vsize   class TxTrezarcoin ( namedtuple ( <str> , <str> ) ) :       class DeserializerTrezarcoin ( Deserializer ) :      def read_tx ( self ) :          version = self . _read_le_int32 ( ) time = self . _read_le_uint32 ( ) inputs = self . _read_inputs ( ) outputs = self . _read_outputs ( ) locktime = self . _read_le_uint32 ( ) if version >= 2 :              txcomment = self . _read_varbytes ( )  else :              txcomment = <str>  return TxTrezarcoin ( version , time , inputs , outputs , locktime , txcomment )  @ staticmethod def blake2s_gen ( data ) :          keyOne = data [ 36 : 46 ] keyTwo = data [ 58 : 68 ] ntime = data [ 68 : 72 ] _nBits = data [ 72 : 76 ] _nonce = data [ 76 : 80 ] _full_merkle = data [ 36 : 68 ] _input112 = data + _full_merkle _key = keyTwo + ntime + _nBits + _nonce + keyOne blake2s_hash = blake2s ( key = _key , digest_size = 32 ) blake2s_hash . update ( _input112 ) return <str> . join ( map ( str . __add__ , blake2s_hash . hexdigest ( ) [ - 2 : : - 2 ] , blake2s_hash . hexdigest ( ) [ - 1 : : - 2 ] ) )  @ staticmethod def blake2s ( data ) :          keyOne = data [ 36 : 46 ] keyTwo = data [ 58 : 68 ] ntime = data [ 68 : 72 ] _nBits = data [ 72 : 76 ] _nonce = data [ 76 : 80 ] _full_merkle = data [ 36 : 68 ] _input112 = data + _full_merkle _key = keyTwo + ntime + _nBits + _nonce + keyOne blake2s_hash = blake2s ( key = _key , digest_size = 32 ) blake2s_hash . update ( _input112 ) return blake2s_hash . digest ( )   class DeserializerReddcoin ( Deserializer ) :      def read_tx ( self ) :          version = self . _read_le_int32 ( ) inputs = self . _read_inputs ( ) outputs = self . _read_outputs ( ) locktime = self . _read_le_uint32 ( ) if version > 1 :              time = self . _read_le_uint32 ( )  else :              time = 0  return TxTime ( version , time , inputs , outputs , locktime )   class DeserializerEmercoin ( DeserializerTxTimeSegWit ) :      VERSION_AUXPOW = ( 1 << 8 ) def is_merged_block ( self ) :          start = self . cursor self . cursor = 0 version = self . _read_le_uint32 ( ) self . cursor = start if version & self . VERSION_AUXPOW :              return True  return False  def read_header ( self , static_header_size ) :          start = self . cursor version = self . _read_le_uint32 ( ) if version & self . VERSION_AUXPOW :              self . cursor = start self . cursor += static_header_size self . read_tx ( ) self . cursor += 32 merkle_size = self . _read_varint ( ) self . cursor += 32 * merkle_size self . cursor += 4 merkle_size = self . _read_varint ( ) self . cursor += 32 * merkle_size self . cursor += 4 self . cursor += 80 header_end = self . cursor  else :              header_end = static_header_size  self . cursor = start return self . _read_nbytes ( header_end )   class DeserializerBitcoinAtom ( DeserializerSegWit ) :      FORK_BLOCK_HEIGHT = 505888 def read_header ( self , height , static_header_size ) :          header_len = static_header_size if height >= self . FORK_BLOCK_HEIGHT :              header_len += 4  return self . _read_nbytes ( header_len )   class DeserializerGroestlcoin ( DeserializerSegWit ) :      TX_HASH_FN = staticmethod ( sha256 )  class TxInputTokenPay ( TxInput ) :      OP_ANON_MARKER = 0xb9 MIN_ANON_IN_SIZE = 2 + ( 33 + 32 + 32 ) def _is_anon_input ( self ) :          return ( len ( self . script ) >= self . MIN_ANON_IN_SIZE and self . script [ 0 ] == OpCodes . OP_RETURN and self . script [ 1 ] == self . OP_ANON_MARKER )  def is_generation ( self ) :          if self . _is_anon_input ( ) :              return True  return super ( TxInputTokenPay , self ) . is_generation ( )   class TxInputTokenPayStealth ( namedtuple ( <str> , <str> ) ) :      def __str__ ( self ) :          script = self . script . hex ( ) keyimage = bytes ( self . keyimage ) . hex ( ) return ( <str> . format ( keyimage , self . ringsize [ 1 ] , script , self . sequence ) )  def is_generation ( self ) :          return True  def serialize ( self ) :          return <str> . join ( ( self . keyimage , self . ringsize , pack_varbytes ( self . script ) , pack_le_uint32 ( self . sequence ) , ) )   class DeserializerTokenPay ( DeserializerTxTime ) :      def _read_input ( self ) :          txin = TxInputTokenPay ( self . _read_nbytes ( 32 ) , self . _read_le_uint32 ( ) , self . _read_varbytes ( ) , self . _read_le_uint32 ( ) , ) if txin . _is_anon_input ( ) :              raw = txin . serialize ( ) deserializer = Deserializer ( raw ) txin = TxInputTokenPayStealth ( deserializer . _read_nbytes ( 33 ) , deserializer . _read_nbytes ( 3 ) , deserializer . _read_varbytes ( ) , deserializer . _read_le_uint32 ( ) )  return txin   class TxInputDcr ( namedtuple ( <str> , <str> ) ) :      def __str__ ( self ) :          prev_hash = hash_to_hex_str ( self . prev_hash ) return ( <str> . format ( prev_hash , self . prev_idx , self . tree , self . sequence ) )  def is_generation ( self ) :          return self . prev_idx == MINUS_1 and self . prev_hash == ZERO   class TxOutputDcr ( namedtuple ( <str> , <str> ) ) :       class TxDcr ( namedtuple ( <str> , <str> <str> ) ) :       class DeserializerDecred ( Deserializer ) :      @ staticmethod def blake256 ( data ) :          from blake256 . blake256 import blake_hash return blake_hash ( data )  @ staticmethod def blake256d ( data ) :          from blake256 . blake256 import blake_hash return blake_hash ( blake_hash ( data ) )  def read_tx ( self ) :          return self . _read_tx_parts ( produce_hash = False ) [ 0 ]  def read_tx_and_hash ( self ) :          tx , tx_hash , _vsize = self . _read_tx_parts ( ) return tx , tx_hash  def read_tx_and_vsize ( self ) :          tx , _tx_hash , vsize = self . _read_tx_parts ( produce_hash = False ) return tx , vsize  def read_tx_block ( self ) :          read = self . read_tx_and_hash txs = [ read ( ) for _ in range ( self . _read_varint ( ) ) ] stxs = [ read ( ) for _ in range ( self . _read_varint ( ) ) ] return txs + stxs  def read_tx_tree ( self ) :          read_tx = self . read_tx return [ read_tx ( ) for _ in range ( self . _read_varint ( ) ) ]  def _read_input ( self ) :          return TxInputDcr ( self . _read_nbytes ( 32 ) , self . _read_le_uint32 ( ) , self . _read_byte ( ) , self . _read_le_uint32 ( ) , )  def _read_output ( self ) :          return TxOutputDcr ( self . _read_le_int64 ( ) , self . _read_le_uint16 ( ) , self . _read_varbytes ( ) , )  def _read_witness ( self , fields ) :          read_witness_field = self . _read_witness_field assert fields == self . _read_varint ( ) return [ read_witness_field ( ) for _ in range ( fields ) ]  def _read_witness_field ( self ) :          value_in = self . _read_le_int64 ( ) block_height = self . _read_le_uint32 ( ) block_index = self . _read_le_uint32 ( ) script = self . _read_varbytes ( ) return value_in , block_height , block_index , script  def _read_tx_parts ( self , produce_hash = True ) :          start = self . cursor version = self . _read_le_int32 ( ) inputs = self . _read_inputs ( ) outputs = self . _read_outputs ( ) locktime = self . _read_le_uint32 ( ) expiry = self . _read_le_uint32 ( ) end_prefix = self . cursor witness = self . _read_witness ( len ( inputs ) ) if produce_hash :              no_witness_header = pack_le_uint32 ( 0x10000 | ( version & 0xffff ) ) prefix_tx = no_witness_header + self . binary [ start + 4 : end_prefix ] tx_hash = self . blake256 ( prefix_tx )  else :              tx_hash = None  return TxDcr ( version , inputs , outputs , locktime , expiry , witness ) , tx_hash , self . cursor - start   class DeserializerSmartCash ( Deserializer ) :      @ staticmethod def keccak ( data ) :          from Cryptodome . Hash import keccak keccak_hash = keccak . new ( digest_bits = 256 ) keccak_hash . update ( data ) return keccak_hash . digest ( )  def read_tx_and_hash ( self ) :          start = self . cursor return self . read_tx ( ) , sha256 ( self . binary [ start : self . cursor ] )   class TxBitcoinDiamond ( namedtuple ( <str> , <str> <str> ) ) :       class DeserializerBitcoinDiamond ( Deserializer ) :      bitcoin_diamond_tx_version = 12 def read_tx ( self ) :          version = self . _get_version ( ) if version != self . bitcoin_diamond_tx_version :              return Tx ( self . _read_le_int32 ( ) , self . _read_inputs ( ) , self . _read_outputs ( ) , self . _read_le_uint32 ( ) )  else :              return TxBitcoinDiamond ( self . _read_le_int32 ( ) , hash_to_hex_str ( self . _read_nbytes ( 32 ) ) , self . _read_inputs ( ) , self . _read_outputs ( ) , self . _read_le_uint32 ( ) )   def _get_version ( self ) :          result , = unpack_le_int32_from ( self . binary , self . cursor ) return result   class TxBitcoinDiamondSegWit ( namedtuple ( <str> , <str> <str> ) ) :       class DeserializerBitcoinDiamondSegWit ( DeserializerBitcoinDiamond , DeserializerSegWit ) :      def _read_tx_parts ( self ) :          start = self . cursor tx_version = self . _get_version ( ) if tx_version == self . bitcoin_diamond_tx_version :              marker = self . binary [ self . cursor + 4 + 32 ]  else :              marker = self . binary [ self . cursor + 4 ]  if marker :              tx = super ( ) . read_tx ( ) tx_hash = self . TX_HASH_FN ( self . binary [ start : self . cursor ] ) return tx , tx_hash , self . binary_length  version = self . _read_le_int32 ( ) present_block_hash = None if version == self . bitcoin_diamond_tx_version :              present_block_hash = hash_to_hex_str ( self . _read_nbytes ( 32 ) )  orig_ser = self . binary [ start : self . cursor ] marker = self . _read_byte ( ) flag = self . _read_byte ( ) start = self . cursor inputs = self . _read_inputs ( ) outputs = self . _read_outputs ( ) orig_ser += self . binary [ start : self . cursor ] base_size = self . cursor - start witness = self . _read_witness ( len ( inputs ) ) start = self . cursor locktime = self . _read_le_uint32 ( ) orig_ser += self . binary [ start : self . cursor ] vsize = ( 3 * base_size + self . binary_length ) // 4 if present_block_hash is not None :              return TxBitcoinDiamondSegWit ( version , present_block_hash , marker , flag , inputs , outputs , witness , locktime ) , self . TX_HASH_FN ( orig_ser ) , vsize  else :              return TxSegWit ( version , marker , flag , inputs , outputs , witness , locktime ) , self . TX_HASH_FN ( orig_ser ) , vsize   def read_tx ( self ) :          return self . _read_tx_parts ( ) [ 0 ]   class DeserializerElectra ( Deserializer ) :      ELECTRA_TX_VERSION = 7 def _get_version ( self ) :          result , = unpack_le_int32_from ( self . binary , self . cursor ) return result  def read_tx ( self ) :          version = self . _get_version ( ) if version != self . ELECTRA_TX_VERSION :              return TxTime ( self . _read_le_int32 ( ) , self . _read_le_uint32 ( ) , self . _read_inputs ( ) , self . _read_outputs ( ) , self . _read_le_uint32 ( ) , )  else :              return Tx ( self . _read_le_int32 ( ) , self . _read_inputs ( ) , self . _read_outputs ( ) , self . _read_le_uint32 ( ) )    class DeserializerECCoin ( Deserializer ) :      def read_tx ( self ) :          tx_version = self . _read_le_int32 ( ) tx = TxTime ( tx_version , self . _read_le_uint32 ( ) , self . _read_inputs ( ) , self . _read_outputs ( ) , self . _read_le_uint32 ( ) , ) if tx_version > 1 :              self . cursor += 32  return tx   class DeserializerZcoin ( Deserializer ) :      def _read_input ( self ) :          tx_input = TxInput ( self . _read_nbytes ( 32 ) , self . _read_le_uint32 ( ) , self . _read_varbytes ( ) , self . _read_le_uint32 ( ) ) if tx_input . prev_idx == MINUS_1 and tx_input . prev_hash == ZERO :              return tx_input  if tx_input . script [ 0 ] == 0xc4 :              return TxInput ( ZERO , MINUS_1 , tx_input . script , tx_input . sequence )  return tx_input   class DeserializerXaya ( DeserializerSegWit , DeserializerAuxPow ) :      MM_FLAG = 0x80 def read_header ( self , static_header_size ) :          start = self . cursor self . cursor += static_header_size algo = self . _read_byte ( ) self . _read_le_uint32 ( ) if algo & self . MM_FLAG :              self . read_auxpow ( )  else :              self . cursor += static_header_size  end = self . cursor self . cursor = start return self . _read_nbytes ( end - start )   class DeserializerSimplicity ( Deserializer ) :      SIMPLICITY_TX_VERSION = 3 def _get_version ( self ) :          result , = unpack_le_int32_from ( self . binary , self . cursor ) return result  def read_tx ( self ) :          version = self . _get_version ( ) if version < self . SIMPLICITY_TX_VERSION :              return TxTime ( self . _read_le_int32 ( ) , self . _read_le_uint32 ( ) , self . _read_inputs ( ) , self . _read_outputs ( ) , self . _read_le_uint32 ( ) , )  else :              return Tx ( self . _read_le_int32 ( ) , self . _read_inputs ( ) , self . _read_outputs ( ) , self . _read_le_uint32 ( ) )     