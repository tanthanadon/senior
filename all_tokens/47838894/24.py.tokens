import asyncio import os import platform import re import signal import sys import time from contextlib import suppress from functools import partial from aiorpcx import spawn from electrumx . lib . util import class_logger class ServerBase :      SUPPRESS_MESSAGE_REGEX = re . compile ( <str> <str> <str> ) SUPPRESS_TASK_REGEX = re . compile ( <str> ) PYTHON_MIN_VERSION = ( 3 , 6 ) def __init__ ( self , env ) :          asyncio . set_event_loop_policy ( env . loop_policy ) self . logger = class_logger ( __name__ , self . __class__ . __name__ ) version_str = <str> . join ( sys . version . splitlines ( ) ) self . logger . info ( <str> ) self . env = env self . start_time = 0 if sys . version_info < self . PYTHON_MIN_VERSION :              mvs = <str> . join ( str ( part ) for part in self . PYTHON_MIN_VERSION ) raise RuntimeError ( <str> . format ( mvs ) )  if platform . system ( ) == <str> :              pass  elif os . geteuid ( ) == 0 and not env . allow_root :              raise RuntimeError ( <str> <str> <str> <str> <str> )   async def serve ( self , shutdown_event ) :          shutdown_event . set ( )  def on_exception ( self , loop , context ) :          message = context . get ( <str> ) if message and self . SUPPRESS_MESSAGE_REGEX . match ( message ) :              return  if self . SUPPRESS_TASK_REGEX . match ( repr ( context . get ( <str> ) ) ) :              return  loop . default_exception_handler ( context )  async def _main ( self , loop ) :          def on_signal ( signame ) :              shutdown_event . set ( ) self . logger . warning ( <str> )  self . start_time = time . time ( ) if platform . system ( ) != <str> :              for signame in ( <str> , <str> ) :                  loop . add_signal_handler ( getattr ( signal , signame ) , partial ( on_signal , signame ) )   loop . set_exception_handler ( self . on_exception ) shutdown_event = asyncio . Event ( ) server_task = await spawn ( self . serve ( shutdown_event ) ) try :              await shutdown_event . wait ( )  except KeyboardInterrupt :              self . logger . warning ( <str> )  finally :              self . logger . info ( <str> ) server_task . cancel ( ) with suppress ( Exception ) :                  await server_task  self . logger . info ( <str> )   def run ( self ) :          loop = asyncio . get_event_loop ( ) try :              loop . run_until_complete ( self . _main ( loop ) )  finally :              loop . run_until_complete ( loop . shutdown_asyncgens ( ) )     