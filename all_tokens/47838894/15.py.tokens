from collections import namedtuple from electrumx . lib . enum import Enumeration from electrumx . lib . util import unpack_le_uint16_from , unpack_le_uint32_from , pack_le_uint16 , pack_le_uint32 class ScriptError ( Exception ) :       OpCodes = Enumeration ( <str> , [ ( <str> , 0 ) , ( <str> , 76 ) , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] ) assert OpCodes . OP_DUP == 0x76 assert OpCodes . OP_HASH160 == 0xa9 assert OpCodes . OP_EQUAL == 0x87 assert OpCodes . OP_EQUALVERIFY == 0x88 assert OpCodes . OP_CHECKSIG == 0xac assert OpCodes . OP_CHECKMULTISIG == 0xae def _match_ops ( ops , pattern ) :      if len ( ops ) != len ( pattern ) :          return False  for op , pop in zip ( ops , pattern ) :          if pop != op :              if pop == - 1 and isinstance ( op , tuple ) :                  continue  return False   return True  class ScriptPubKey ( object ) :      TO_ADDRESS_OPS = [ OpCodes . OP_DUP , OpCodes . OP_HASH160 , - 1 , OpCodes . OP_EQUALVERIFY , OpCodes . OP_CHECKSIG ] TO_P2SH_OPS = [ OpCodes . OP_HASH160 , - 1 , OpCodes . OP_EQUAL ] TO_PUBKEY_OPS = [ - 1 , OpCodes . OP_CHECKSIG ] PayToHandlers = namedtuple ( <str> , <str> <str> ) @ classmethod def pay_to ( cls , handlers , script ) :          try :              ops = Script . get_ops ( script )  except ScriptError :              return handlers . unspendable ( )  match = _match_ops if match ( ops , cls . TO_ADDRESS_OPS ) :              return handlers . address ( ops [ 2 ] [ - 1 ] )  if match ( ops , cls . TO_P2SH_OPS ) :              return handlers . script_hash ( ops [ 1 ] [ - 1 ] )  if match ( ops , cls . TO_PUBKEY_OPS ) :              return handlers . pubkey ( ops [ 0 ] [ - 1 ] )  if ops and ops [ 0 ] == OpCodes . OP_RETURN :              return handlers . unspendable ( )  return handlers . strange ( script )  @ classmethod def P2SH_script ( cls , hash160 ) :          return ( bytes ( [ OpCodes . OP_HASH160 ] ) + Script . push_data ( hash160 ) + bytes ( [ OpCodes . OP_EQUAL ] ) )  @ classmethod def P2PKH_script ( cls , hash160 ) :          return ( bytes ( [ OpCodes . OP_DUP , OpCodes . OP_HASH160 ] ) + Script . push_data ( hash160 ) + bytes ( [ OpCodes . OP_EQUALVERIFY , OpCodes . OP_CHECKSIG ] ) )   class Script ( object ) :      @ classmethod def get_ops ( cls , script ) :          ops = [ ] try :              n = 0 while n < len ( script ) :                  op = script [ n ] n += 1 if op <= OpCodes . OP_PUSHDATA4 :                      if op < OpCodes . OP_PUSHDATA1 :                          dlen = op  elif op == OpCodes . OP_PUSHDATA1 :                          dlen = script [ n ] n += 1  elif op == OpCodes . OP_PUSHDATA2 :                          dlen , = unpack_le_uint16_from ( script [ n : n + 2 ] ) n += 2  else :                          dlen , = unpack_le_uint32_from ( script [ n : n + 4 ] ) n += 4  if n + dlen > len ( script ) :                          raise IndexError  op = ( op , script [ n : n + dlen ] ) n += dlen  ops . append ( op )   except Exception :              raise ScriptError ( <str> )  return ops  @ classmethod def push_data ( cls , data ) :          assert isinstance ( data , ( bytes , bytearray ) ) n = len ( data ) if n < OpCodes . OP_PUSHDATA1 :              return bytes ( [ n ] ) + data  if n < 256 :              return bytes ( [ OpCodes . OP_PUSHDATA1 , n ] ) + data  if n < 65536 :              return bytes ( [ OpCodes . OP_PUSHDATA2 ] ) + pack_le_uint16 ( n ) + data  return bytes ( [ OpCodes . OP_PUSHDATA4 ] ) + pack_le_uint32 ( n ) + data  @ classmethod def opcode_name ( cls , opcode ) :          if OpCodes . OP_0 < opcode < OpCodes . OP_PUSHDATA1 :              return <str> . format ( opcode )  try :              return OpCodes . whatis ( opcode )  except KeyError :              return <str> . format ( opcode )   @ classmethod def dump ( cls , script ) :          opcodes , datas = cls . get_ops ( script ) for opcode , data in zip ( opcodes , datas ) :              name = cls . opcode_name ( opcode ) if data is None :                  print ( name )  else :                  print ( <str> . format ( name , data . hex ( ) , len ( data ) ) )      