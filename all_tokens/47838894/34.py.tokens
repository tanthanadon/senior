import aiohttp import asyncio import json import logging import pytest from aiorpcx import ( JSONRPCv1 , JSONRPCLoose , RPCError , ignore_after , Request , Batch , ) from electrumx . lib . coins import BitcoinCash , CoinError , Bitzeny , Dash from electrumx . server . daemon import ( Daemon , FakeEstimateFeeDaemon , DaemonError ) coin = BitcoinCash urls = [ <str> , <str> ] @ pytest . fixture ( params = [ BitcoinCash , Bitzeny ] ) def daemon ( request ) :      coin = request . param return coin . DAEMON ( coin , <str> . join ( urls ) )  @ pytest . fixture ( params = [ Dash ] ) def dash_daemon ( request ) :      coin = request . param return coin . DAEMON ( coin , <str> . join ( urls ) )  class ResponseBase ( object ) :      def __init__ ( self , headers , status ) :          self . headers = headers self . status = status  async def __aenter__ ( self ) :          return self  async def __aexit__ ( self , exc_type , exc_value , traceback ) :          pass   class JSONResponse ( ResponseBase ) :      def __init__ ( self , result , msg_id , status = 200 ) :          super ( ) . __init__ ( { <str> : <str> } , status ) self . result = result self . msg_id = msg_id  async def json ( self ) :          if isinstance ( self . msg_id , int ) :              message = JSONRPCv1 . response_message ( self . result , self . msg_id )  else :              parts = [ JSONRPCv1 . response_message ( item , msg_id ) for item , msg_id in zip ( self . result , self . msg_id ) ] message = JSONRPCv1 . batch_message_from_parts ( parts )  return json . loads ( message . decode ( ) )   class HTMLResponse ( ResponseBase ) :      def __init__ ( self , text , reason , status ) :          super ( ) . __init__ ( { <str> : <str> } , status ) self . _text = text self . reason = reason  async def text ( self ) :          return self . _text   class ClientSessionGood :      def __init__ ( self , * triples ) :          self . triples = triples self . count = 0 self . expected_url = urls [ 0 ]  def post ( self , url , data = <str> ) :          assert url == self . expected_url request , request_id = JSONRPCLoose . message_to_item ( data . encode ( ) ) method , args , result = self . triples [ self . count ] self . count += 1 if isinstance ( request , Request ) :              assert request . method == method assert request . args == args return JSONResponse ( result , request_id )  else :              batch = request assert isinstance ( batch , list ) request_ids = [ ] for payload , args in zip ( batch , args ) :                  assert payload [ <str> ] == method assert payload [ <str> ] == args request_ids . append ( payload [ <str> ] )  return JSONResponse ( result , request_ids )    class ClientSessionBadAuth :      def post ( self , url , data = <str> ) :           return HTMLResponse ( <str> , <str> , 401 )   class ClientSessionWorkQueueFull ( ClientSessionGood ) :      def post ( self , url , data = <str> ) :          self . post = super ( ) . post return HTMLResponse ( <str> , <str> , 500 )   class ClientSessionPostError ( ClientSessionGood ) :      def __init__ ( self , exception , * args ) :          super ( ) . __init__ ( * args ) self . exception = exception self . n = 0  def post ( self , url , data = <str> ) :          self . n += 1 if self . n == 1 :              raise self . exception  return super ( ) . post ( url , data )   class ClientSessionFailover ( ClientSessionGood ) :      def post ( self , url , data = <str> ) :          if url == self . expected_url :              raise aiohttp . ServerDisconnectedError  else :              self . expected_url = urls [ 1 ] return super ( ) . post ( url , data )    def in_caplog ( caplog , message , count = 1 ) :      return sum ( message in record . message for record in caplog . records ) == count  @ pytest . mark . asyncio async def test_set_urls_bad ( ) :      with pytest . raises ( CoinError ) :          Daemon ( coin , <str> )  with pytest . raises ( CoinError ) :          Daemon ( coin , <str> )   @ pytest . mark . asyncio async def test_set_urls_one ( caplog ) :      with caplog . at_level ( logging . INFO ) :          daemon = Daemon ( coin , urls [ 0 ] ) assert daemon . current_url ( ) == urls [ 0 ] assert len ( daemon . urls ) == 1 logged_url = daemon . logged_url ( ) assert logged_url == <str> assert in_caplog ( caplog , <str> )   @ pytest . mark . asyncio async def test_set_urls_two ( caplog ) :      with caplog . at_level ( logging . INFO ) :          daemon = Daemon ( coin , <str> . join ( urls ) ) assert daemon . current_url ( ) == urls [ 0 ] assert len ( daemon . urls ) == 2 logged_url = daemon . logged_url ( ) assert logged_url == <str> assert in_caplog ( caplog , <str> ) assert in_caplog ( caplog , <str> )   @ pytest . mark . asyncio async def test_set_urls_short ( ) :      no_prefix_urls = [ <str> . join ( part for part in url . split ( <str> ) [ 2 : ] ) for url in urls ] daemon = Daemon ( coin , <str> . join ( no_prefix_urls ) ) assert daemon . current_url ( ) == urls [ 0 ] assert len ( daemon . urls ) == 2 no_slash_urls = [ url [ : - 1 ] for url in urls ] daemon = Daemon ( coin , <str> . join ( no_slash_urls ) ) assert daemon . current_url ( ) == urls [ 0 ] assert len ( daemon . urls ) == 2 no_port_urls = [ url [ : url . rfind ( <str> ) ] for url in urls ] daemon = Daemon ( coin , <str> . join ( no_port_urls ) ) assert daemon . current_url ( ) == urls [ 0 ] assert len ( daemon . urls ) == 2  @ pytest . mark . asyncio async def test_failover_good ( caplog ) :      daemon = Daemon ( coin , <str> . join ( urls ) ) with caplog . at_level ( logging . INFO ) :          result = daemon . failover ( )  assert result is True assert daemon . current_url ( ) == urls [ 1 ] logged_url = daemon . logged_url ( ) assert in_caplog ( caplog , <str> ) result = daemon . failover ( ) assert result is True assert daemon . current_url ( ) == urls [ 0 ]  @ pytest . mark . asyncio async def test_failover_fail ( caplog ) :      daemon = Daemon ( coin , urls [ 0 ] ) with caplog . at_level ( logging . INFO ) :          result = daemon . failover ( )  assert result is False assert daemon . current_url ( ) == urls [ 0 ] assert not in_caplog ( caplog , <str> )  @ pytest . mark . asyncio async def test_height ( daemon ) :      assert daemon . cached_height ( ) is None height = 300 daemon . session = ClientSessionGood ( ( <str> , [ ] , height ) ) assert await daemon . height ( ) == height assert daemon . cached_height ( ) == height  @ pytest . mark . asyncio async def test_broadcast_transaction ( daemon ) :      raw_tx = <str> tx_hash = <str> daemon . session = ClientSessionGood ( ( <str> , [ raw_tx ] , tx_hash ) ) assert await daemon . broadcast_transaction ( raw_tx ) == tx_hash  @ pytest . mark . asyncio async def test_relayfee ( daemon ) :      response = { <str> : sats , <str> : <str> } daemon . session = ClientSessionGood ( ( <str> , [ ] , response ) ) assert await daemon . getnetworkinfo ( ) == response  @ pytest . mark . asyncio async def test_relayfee ( daemon ) :      if isinstance ( daemon , FakeEstimateFeeDaemon ) :          sats = daemon . coin . ESTIMATE_FEE  else :          sats = 2  response = { <str> : sats , <str> : <str> } daemon . session = ClientSessionGood ( ( <str> , [ ] , response ) ) assert await daemon . relayfee ( ) == sats  @ pytest . mark . asyncio async def test_mempool_hashes ( daemon ) :      hashes = [ <str> , <str> ] daemon . session = ClientSessionGood ( ( <str> , [ ] , hashes ) ) assert await daemon . mempool_hashes ( ) == hashes  @ pytest . mark . asyncio async def test_deserialised_block ( daemon ) :      block_hash = <str> result = { <str> : <str> } daemon . session = ClientSessionGood ( ( <str> , [ block_hash , True ] , result ) ) assert await daemon . deserialised_block ( block_hash ) == result  @ pytest . mark . asyncio async def test_estimatefee ( daemon ) :      method_not_found = RPCError ( JSONRPCv1 . METHOD_NOT_FOUND , <str> ) if isinstance ( daemon , FakeEstimateFeeDaemon ) :          result = daemon . coin . ESTIMATE_FEE  else :          result = - 1  daemon . session = ClientSessionGood ( ( <str> , [ ] , method_not_found ) , ( <str> , [ 2 ] , result ) ) assert await daemon . estimatefee ( 2 ) == result  @ pytest . mark . asyncio async def test_estimatefee_smart ( daemon ) :      bad_args = RPCError ( JSONRPCv1 . INVALID_ARGS , <str> ) if isinstance ( daemon , FakeEstimateFeeDaemon ) :          return  rate = 0.0002 result = { <str> : rate } daemon . session = ClientSessionGood ( ( <str> , [ ] , bad_args ) , ( <str> , [ 2 ] , result ) ) assert await daemon . estimatefee ( 2 ) == rate daemon . session = ClientSessionGood ( ( <str> , [ 2 ] , result ) ) assert await daemon . estimatefee ( 2 ) == rate  @ pytest . mark . asyncio async def test_getrawtransaction ( daemon ) :      hex_hash = <str> simple = <str> verbose = { <str> : hex_hash , <str> : <str> } daemon . session = ClientSessionGood ( ( <str> , [ hex_hash , 0 ] , simple ) ) assert await daemon . getrawtransaction ( hex_hash ) == simple daemon . session = ClientSessionGood ( ( <str> , [ hex_hash , 1 ] , verbose ) ) assert await daemon . getrawtransaction ( hex_hash , True ) == verbose  @ pytest . mark . asyncio async def test_protx ( dash_daemon ) :      protx_hash = <str> dash_daemon . session = ClientSessionGood ( ( <str> , [ <str> , protx_hash ] , { } ) ) assert await dash_daemon . protx ( [ <str> , protx_hash ] ) == { }  @ pytest . mark . asyncio async def test_empty_send ( daemon ) :      first = 5 count = 0 daemon . session = ClientSessionGood ( ( <str> , [ ] , [ ] ) ) assert await daemon . block_hex_hashes ( first , count ) == [ ]  @ pytest . mark . asyncio async def test_block_hex_hashes ( daemon ) :      first = 5 count = 3 hashes = [ <str> for n in range ( count ) ] daemon . session = ClientSessionGood ( ( <str> , [ [ n ] for n in range ( first , first + count ) ] , hashes ) ) assert await daemon . block_hex_hashes ( first , count ) == hashes  @ pytest . mark . asyncio async def test_raw_blocks ( daemon ) :      count = 3 hex_hashes = [ <str> for n in range ( count ) ] args_list = [ [ hex_hash , False ] for hex_hash in hex_hashes ] iterable = ( hex_hash for hex_hash in hex_hashes ) blocks = [ <str> , <str> , <str> ] blocks_raw = [ bytes . fromhex ( block ) for block in blocks ] daemon . session = ClientSessionGood ( ( <str> , args_list , blocks ) ) assert await daemon . raw_blocks ( iterable ) == blocks_raw  @ pytest . mark . asyncio async def test_get_raw_transactions ( daemon ) :      hex_hashes = [ <str> , <str> ] args_list = [ [ hex_hash , 0 ] for hex_hash in hex_hashes ] raw_txs_hex = [ <str> , <str> ] raw_txs = [ bytes . fromhex ( raw_tx ) for raw_tx in raw_txs_hex ] daemon . session = ClientSessionGood ( ( <str> , args_list , raw_txs_hex ) ) assert await daemon . getrawtransactions ( hex_hashes ) == raw_txs tx_not_found = RPCError ( - 1 , <str> ) results = [ <str> , tx_not_found ] raw_txs = [ bytes . fromhex ( results [ 0 ] ) , None ] daemon . session = ClientSessionGood ( ( <str> , args_list , results ) ) assert await daemon . getrawtransactions ( hex_hashes ) == raw_txs  @ pytest . mark . asyncio async def test_bad_auth ( daemon , caplog ) :      async with ignore_after ( 0.1 ) :          daemon . session = ClientSessionBadAuth ( ) await daemon . height ( )  assert in_caplog ( caplog , <str> ) assert in_caplog ( caplog , <str> )  @ pytest . mark . asyncio async def test_workqueue_depth ( daemon , caplog ) :      daemon . init_retry = 0.01 height = 125 with caplog . at_level ( logging . INFO ) :          daemon . session = ClientSessionWorkQueueFull ( ( <str> , [ ] , height ) ) await daemon . height ( ) == height  assert in_caplog ( caplog , <str> ) assert in_caplog ( caplog , <str> )  @ pytest . mark . asyncio async def test_connection_error ( daemon , caplog ) :      height = 100 daemon . init_retry = 0.01 with caplog . at_level ( logging . INFO ) :          daemon . session = ClientSessionPostError ( aiohttp . ClientConnectionError , ( <str> , [ ] , height ) ) await daemon . height ( ) == height  assert in_caplog ( caplog , <str> ) assert in_caplog ( caplog , <str> )  @ pytest . mark . asyncio async def test_timeout_error ( daemon , caplog ) :      height = 100 daemon . init_retry = 0.01 with caplog . at_level ( logging . INFO ) :          daemon . session = ClientSessionPostError ( asyncio . TimeoutError , ( <str> , [ ] , height ) ) await daemon . height ( ) == height  assert in_caplog ( caplog , <str> )  @ pytest . mark . asyncio async def test_disconnected ( daemon , caplog ) :      height = 100 daemon . init_retry = 0.01 with caplog . at_level ( logging . INFO ) :          daemon . session = ClientSessionPostError ( aiohttp . ServerDisconnectedError , ( <str> , [ ] , height ) ) await daemon . height ( ) == height  assert in_caplog ( caplog , <str> ) assert in_caplog ( caplog , <str> )  @ pytest . mark . asyncio async def test_warming_up ( daemon , caplog ) :      warming_up = RPCError ( - 28 , <str> ) height = 100 daemon . init_retry = 0.01 with caplog . at_level ( logging . INFO ) :          daemon . session = ClientSessionGood ( ( <str> , [ ] , warming_up ) , ( <str> , [ ] , height ) ) assert await daemon . height ( ) == height  assert in_caplog ( caplog , <str> ) assert in_caplog ( caplog , <str> )  @ pytest . mark . asyncio async def test_warming_up_batch ( daemon , caplog ) :      warming_up = RPCError ( - 28 , <str> ) first = 5 count = 1 daemon . init_retry = 0.01 hashes = [ <str> ] with caplog . at_level ( logging . INFO ) :          daemon . session = ClientSessionGood ( ( <str> , [ [ first ] ] , [ warming_up ] ) , ( <str> , [ [ first ] ] , hashes ) ) assert await daemon . block_hex_hashes ( first , count ) == hashes  assert in_caplog ( caplog , <str> ) assert in_caplog ( caplog , <str> )  @ pytest . mark . asyncio async def test_failover ( daemon , caplog ) :      height = 100 daemon . init_retry = 0.01 daemon . max_retry = 0.04 with caplog . at_level ( logging . INFO ) :          daemon . session = ClientSessionFailover ( ( <str> , [ ] , height ) ) await daemon . height ( ) == height  assert in_caplog ( caplog , <str> , 1 ) assert in_caplog ( caplog , <str> ) assert in_caplog ( caplog , <str> )   