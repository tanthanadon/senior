import re from ipaddress import IPv4Address , IPv6Address from aiorpcx import Service , ServicePart from electrumx . lib . coins import Coin from electrumx . lib . env_base import EnvBase class ServiceError ( Exception ) :      pass  class Env ( EnvBase ) :      PD_OFF , PD_SELF , PD_ON = ( <str> , <str> , <str> ) SSL_PROTOCOLS = { <str> , <str> } KNOWN_PROTOCOLS = { <str> , <str> , <str> , <str> , <str> } def __init__ ( self , coin = None ) :          super ( ) . __init__ ( ) self . obsolete ( [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] ) self . db_dir = self . required ( <str> ) self . daemon_url = self . required ( <str> ) if coin is not None :              assert issubclass ( coin , Coin ) self . coin = coin  else :              coin_name = self . required ( <str> ) . strip ( ) network = self . default ( <str> , <str> ) . strip ( ) self . coin = Coin . lookup_coin_class ( coin_name , network )  self . peer_discovery = self . peer_discovery_enum ( ) self . peer_announce = self . boolean ( <str> , True ) self . force_proxy = self . boolean ( <str> , False ) self . tor_proxy_host = self . default ( <str> , <str> ) self . tor_proxy_port = self . integer ( <str> , None ) self . db_engine = self . default ( <str> , <str> ) self . banner_file = self . default ( <str> , None ) self . tor_banner_file = self . default ( <str> , self . banner_file ) self . anon_logs = self . boolean ( <str> , False ) self . log_sessions = self . integer ( <str> , 3600 ) self . log_level = self . default ( <str> , <str> ) . upper ( ) self . donation_address = self . default ( <str> , <str> ) self . drop_client = self . custom ( <str> , None , re . compile ) self . blacklist_url = self . default ( <str> , self . coin . BLACKLIST_URL ) self . cache_MB = self . integer ( <str> , 1200 ) self . reorg_limit = self . integer ( <str> , self . coin . REORG_LIMIT ) self . max_send = self . integer ( <str> , self . coin . DEFAULT_MAX_SEND ) self . max_sessions = self . sane_max_sessions ( ) self . cost_soft_limit = self . integer ( <str> , 1000 ) self . cost_hard_limit = self . integer ( <str> , 10000 ) self . bw_unit_cost = self . integer ( <str> , 5000 ) self . initial_concurrent = self . integer ( <str> , 10 ) self . request_sleep = self . integer ( <str> , 2500 ) self . request_timeout = self . integer ( <str> , 30 ) self . session_timeout = self . integer ( <str> , 600 ) self . services = self . services_to_run ( ) if { service . protocol for service in self . services } . intersection ( self . SSL_PROTOCOLS ) :              self . ssl_certfile = self . required ( <str> ) self . ssl_keyfile = self . required ( <str> )  self . report_services = self . services_to_report ( )  def sane_max_sessions ( self ) :          env_value = self . integer ( <str> , 1000 ) try :              import resource nofile_limit = resource . getrlimit ( resource . RLIMIT_NOFILE ) [ 0 ] value = max ( 0 , min ( env_value , nofile_limit - 350 ) ) if value < env_value :                  self . logger . warning ( <str> <str> . format ( env_value , value , nofile_limit ) )   except ImportError :              value = 512  return value  def _parse_services ( self , services_str , default_func ) :          result = [ ] for service_str in services_str . split ( <str> ) :              if not service_str :                  continue  try :                  service = Service . from_string ( service_str , default_func = default_func )  except Exception as e :                  raise ServiceError ( <str> ) from None  if service . protocol not in self . KNOWN_PROTOCOLS :                  raise ServiceError ( <str> )  result . append ( service )  service_map = { service . address : [ ] for service in result } for service in result :              service_map [ service . address ] . append ( service )  for address , services in service_map . items ( ) :              if len ( services ) > 1 :                  raise ServiceError ( <str> )   return result  def services_to_run ( self ) :          def default_part ( protocol , part ) :              return default_services . get ( protocol , { } ) . get ( part )  default_services = { protocol : { ServicePart . HOST : <str> } for protocol in self . KNOWN_PROTOCOLS } default_services [ <str> ] = { ServicePart . HOST : <str> , ServicePart . PORT : 8000 } services = self . _parse_services ( self . default ( <str> , <str> ) , default_part ) for service in services :              if str ( service . host ) . endswith ( <str> ) :                  raise ServiceError ( <str> )   return services  def services_to_report ( self ) :          services = self . _parse_services ( self . default ( <str> , <str> ) , None ) for service in services :              if service . protocol == <str> :                  raise ServiceError ( <str> )  if isinstance ( service . host , ( IPv4Address , IPv6Address ) ) :                  ip_addr = service . host if ( ip_addr . is_multicast or ip_addr . is_unspecified or ( ip_addr . is_private and self . peer_announce ) ) :                      raise ServiceError ( <str> )   elif service . host . lower ( ) == <str> :                  raise ServiceError ( <str> )   return services  def peer_discovery_enum ( self ) :          pd = self . default ( <str> , <str> ) . strip ( ) . lower ( ) if pd in ( <str> , <str> ) :              return self . PD_OFF  elif pd == <str> :              return self . PD_SELF  else :              return self . PD_ON     