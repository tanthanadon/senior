import array import inspect from ipaddress import ip_address import logging import re import sys from collections . abc import Container , Mapping from struct import Struct class ConnectionLogger ( logging . LoggerAdapter ) :      def process ( self , msg , kwargs ) :          conn_id = self . extra . get ( <str> , <str> ) return <str> , kwargs   class CompactFormatter ( logging . Formatter ) :      def format ( self , record ) :          record . name = record . name . rpartition ( <str> ) [ - 1 ] return super ( ) . format ( record )   def make_logger ( name , * , handler , level ) :      logger = logging . getLogger ( name ) logger . addHandler ( handler ) logger . setLevel ( level ) logger . propagate = False return logger  def class_logger ( path , classname ) :      return logging . getLogger ( path ) . getChild ( classname )  class cachedproperty ( object ) :      def __init__ ( self , f ) :          self . f = f  def __get__ ( self , obj , type ) :          obj = obj or type value = self . f ( obj ) setattr ( obj , self . f . __name__ , value ) return value   def formatted_time ( t , sep = <str> ) :      t = int ( t ) fmts = ( ( <str> , 86400 ) , ( <str> , 3600 ) , ( <str> , 60 ) ) parts = [ ] for fmt , n in fmts :          val = t // n if parts or val :              parts . append ( fmt . format ( val ) )  t %= n  if len ( parts ) < 3 :          parts . append ( <str> . format ( t ) )  return sep . join ( parts )  def deep_getsizeof ( obj ) :      ids = set ( ) def size ( o ) :          if id ( o ) in ids :              return 0  r = sys . getsizeof ( o ) ids . add ( id ( o ) ) if isinstance ( o , ( str , bytes , bytearray , array . array ) ) :              return r  if isinstance ( o , Mapping ) :              return r + sum ( size ( k ) + size ( v ) for k , v in o . items ( ) )  if isinstance ( o , Container ) :              return r + sum ( size ( x ) for x in o )  return r  return size ( obj )  def subclasses ( base_class , strict = True ) :      def select ( obj ) :          return ( inspect . isclass ( obj ) and issubclass ( obj , base_class ) and ( not strict or obj != base_class ) )  pairs = inspect . getmembers ( sys . modules [ base_class . __module__ ] , select ) return [ pair [ 1 ] for pair in pairs ]  def chunks ( items , size ) :      for i in range ( 0 , len ( items ) , size ) :          yield items [ i : i + size ]   def resolve_limit ( limit ) :      if limit is None :          return - 1  assert isinstance ( limit , int ) and limit >= 0 return limit  def bytes_to_int ( be_bytes ) :      return int . from_bytes ( be_bytes , <str> )  def int_to_bytes ( value ) :      return value . to_bytes ( ( value . bit_length ( ) + 7 ) // 8 , <str> )  def increment_byte_string ( bs ) :      for n in range ( 1 , len ( bs ) + 1 ) :          if bs [ - n ] != 0xff :              return bs [ : - n ] + bytes ( [ bs [ - n ] + 1 ] ) + bytes ( n - 1 )   return None  class LogicalFile ( object ) :      def __init__ ( self , prefix , digits , file_size ) :          digit_fmt = <str> + <str> . format ( digits ) + <str> self . filename_fmt = prefix + digit_fmt self . file_size = file_size  def read ( self , start , size = - 1 ) :          parts = [ ] while size != 0 :              try :                  with self . open_file ( start , False ) as f :                      part = f . read ( size )  if not part :                      break   except FileNotFoundError :                  break  parts . append ( part ) start += len ( part ) if size > 0 :                  size -= len ( part )   return <str> . join ( parts )  def write ( self , start , b ) :          while b :              size = min ( len ( b ) , self . file_size - ( start % self . file_size ) ) with self . open_file ( start , True ) as f :                  f . write ( b if size == len ( b ) else b [ : size ] )  b = b [ size : ] start += size   def open_file ( self , start , create ) :          file_num , offset = divmod ( start , self . file_size ) filename = self . filename_fmt . format ( file_num ) f = open_file ( filename , create ) f . seek ( offset ) return f   def open_file ( filename , create = False ) :      try :          return open ( filename , <str> )  except FileNotFoundError :          if create :              return open ( filename , <str> )  raise   def open_truncate ( filename ) :      return open ( filename , <str> )  def address_string ( address ) :      fmt = <str> host , port = address try :          host = ip_address ( host )  except ValueError :          pass  else :          if host . version == 6 :              fmt = <str>   return fmt . format ( host , port )  def protocol_tuple ( s ) :      try :          return tuple ( int ( part ) for part in s . split ( <str> ) )  except ( TypeError , ValueError , AttributeError ) :          return ( 0 , )   def version_string ( ptuple ) :      while len ( ptuple ) < 2 :          ptuple += ( 0 , )  return <str> . join ( str ( p ) for p in ptuple )  def protocol_version ( client_req , min_tuple , max_tuple ) :      if client_req is None :          client_min = client_max = min_tuple  else :          if isinstance ( client_req , list ) and len ( client_req ) == 2 :              client_min , client_max = client_req  else :              client_min = client_max = client_req  client_min = protocol_tuple ( client_min ) client_max = protocol_tuple ( client_max )  result = min ( client_max , max_tuple ) if result < max ( client_min , min_tuple ) or result == ( 0 , ) :          result = None  return result , client_min  struct_le_i = Struct ( <str> ) struct_le_q = Struct ( <str> ) struct_le_H = Struct ( <str> ) struct_le_I = Struct ( <str> ) struct_le_Q = Struct ( <str> ) struct_be_H = Struct ( <str> ) struct_be_I = Struct ( <str> ) structB = Struct ( <str> ) unpack_le_int32_from = struct_le_i . unpack_from unpack_le_int64_from = struct_le_q . unpack_from unpack_le_uint16_from = struct_le_H . unpack_from unpack_le_uint32_from = struct_le_I . unpack_from unpack_le_uint64_from = struct_le_Q . unpack_from unpack_be_uint16_from = struct_be_H . unpack_from unpack_be_uint32_from = struct_be_I . unpack_from unpack_le_uint32 = struct_le_I . unpack unpack_le_uint64 = struct_le_Q . unpack unpack_be_uint32 = struct_be_I . unpack pack_le_int32 = struct_le_i . pack pack_le_int64 = struct_le_q . pack pack_le_uint16 = struct_le_H . pack pack_le_uint32 = struct_le_I . pack pack_le_uint64 = struct_le_Q . pack pack_be_uint16 = struct_be_H . pack pack_be_uint32 = struct_be_I . pack pack_byte = structB . pack hex_to_bytes = bytes . fromhex def pack_varint ( n ) :      if n < 253 :          return pack_byte ( n )  if n < 65536 :          return pack_byte ( 253 ) + pack_le_uint16 ( n )  if n < 4294967296 :          return pack_byte ( 254 ) + pack_le_uint32 ( n )  return pack_byte ( 255 ) + pack_le_uint64 ( n )  def pack_varbytes ( data ) :      return pack_varint ( len ( data ) ) + data   