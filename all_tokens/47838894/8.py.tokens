import asyncio import itertools import json import time from calendar import timegm from struct import pack import aiohttp from aiorpcx import JSONRPC from electrumx . lib . util import hex_to_bytes , class_logger , unpack_le_uint16_from , pack_varint from electrumx . lib . hash import hex_str_to_hash , hash_to_hex_str from electrumx . lib . tx import DeserializerDecred class DaemonError ( Exception ) :       class WarmingUpError ( Exception ) :       class ServiceRefusedError ( Exception ) :       class Daemon ( object ) :      WARMING_UP = - 28 id_counter = itertools . count ( ) def __init__ ( self , coin , url , * , max_workqueue = 10 , init_retry = 0.25 , max_retry = 4.0 ) :          self . coin = coin self . logger = class_logger ( __name__ , self . __class__ . __name__ ) self . url_index = None self . urls = [ ] self . set_url ( url ) self . workqueue_semaphore = asyncio . Semaphore ( value = max_workqueue ) self . init_retry = init_retry self . max_retry = max_retry self . _height = None self . available_rpcs = { } self . session = None  async def __aenter__ ( self ) :          self . session = aiohttp . ClientSession ( connector = self . connector ( ) ) return self  async def __aexit__ ( self , exc_type , exc_value , traceback ) :          await self . session . close ( ) self . session = None  def connector ( self ) :          return None  def set_url ( self , url ) :          urls = url . split ( <str> ) urls = [ self . coin . sanitize_url ( url ) for url in urls ] for n , url in enumerate ( urls ) :              status = <str> if n else <str> logged_url = self . logged_url ( url ) self . logger . info ( <str> )  self . url_index = 0 self . urls = urls  def current_url ( self ) :          return self . urls [ self . url_index ]  def logged_url ( self , url = None ) :          url = url or self . current_url ( ) return url [ url . rindex ( <str> ) + 1 : ]  def failover ( self ) :          if len ( self . urls ) > 1 :              self . url_index = ( self . url_index + 1 ) % len ( self . urls ) self . logger . info ( <str> ) return True  return False  async def _send_data ( self , data ) :          async with self . workqueue_semaphore :              async with self . session . post ( self . current_url ( ) , data = data ) as resp :                  kind = resp . headers . get ( <str> , None ) if kind == <str> :                      return await resp . json ( )  text = await resp . text ( ) text = text . strip ( ) or resp . reason raise ServiceRefusedError ( text )    async def _send ( self , payload , processor ) :          def log_error ( error ) :              nonlocal last_error_log , retry now = time . time ( ) if now - last_error_log > 60 :                  last_error_log = now self . logger . error ( <str> )  if retry == self . max_retry and self . failover ( ) :                  retry = 0   on_good_message = None last_error_log = 0 data = json . dumps ( payload ) retry = self . init_retry while True :              try :                  result = await self . _send_data ( data ) result = processor ( result ) if on_good_message :                      self . logger . info ( on_good_message )  return result  except asyncio . TimeoutError :                  log_error ( <str> )  except aiohttp . ServerDisconnectedError :                  log_error ( <str> ) on_good_message = <str>  except ConnectionResetError :                  log_error ( <str> ) on_good_message = <str>  except aiohttp . ClientConnectionError :                  log_error ( <str> ) on_good_message = <str>  except aiohttp . ClientError as e :                  log_error ( <str> ) on_good_message = <str>  except ServiceRefusedError as e :                  log_error ( <str> ) on_good_message = <str>  except WarmingUpError :                  log_error ( <str> ) on_good_message = <str>  await asyncio . sleep ( retry ) retry = max ( min ( self . max_retry , retry * 2 ) , self . init_retry )   async def _send_single ( self , method , params = None ) :          def processor ( result ) :              err = result [ <str> ] if not err :                  return result [ <str> ]  if err . get ( <str> ) == self . WARMING_UP :                  raise WarmingUpError  raise DaemonError ( err )  payload = { <str> : method , <str> : next ( self . id_counter ) } if params :              payload [ <str> ] = params  return await self . _send ( payload , processor )  async def _send_vector ( self , method , params_iterable , replace_errs = False ) :          def processor ( result ) :              errs = [ item [ <str> ] for item in result if item [ <str> ] ] if any ( err . get ( <str> ) == self . WARMING_UP for err in errs ) :                  raise WarmingUpError  if not errs or replace_errs :                  return [ item [ <str> ] for item in result ]  raise DaemonError ( errs )  payload = [ { <str> : method , <str> : p , <str> : next ( self . id_counter ) } for p in params_iterable ] if payload :              return await self . _send ( payload , processor )  return [ ]  async def _is_rpc_available ( self , method ) :          available = self . available_rpcs . get ( method ) if available is None :              available = True try :                  await self . _send_single ( method )  except DaemonError as e :                  err = e . args [ 0 ] error_code = err . get ( <str> ) available = error_code != JSONRPC . METHOD_NOT_FOUND  self . available_rpcs [ method ] = available  return available  async def block_hex_hashes ( self , first , count ) :          params_iterable = ( ( h , ) for h in range ( first , first + count ) ) return await self . _send_vector ( <str> , params_iterable )  async def deserialised_block ( self , hex_hash ) :          return await self . _send_single ( <str> , ( hex_hash , True ) )  async def raw_blocks ( self , hex_hashes ) :          params_iterable = ( ( h , False ) for h in hex_hashes ) blocks = await self . _send_vector ( <str> , params_iterable ) return [ hex_to_bytes ( block ) for block in blocks ]  async def mempool_hashes ( self ) :          return await self . _send_single ( <str> )  async def estimatefee ( self , block_count ) :          args = ( block_count , ) if await self . _is_rpc_available ( <str> ) :              estimate = await self . _send_single ( <str> , args ) return estimate . get ( <str> , - 1 )  return await self . _send_single ( <str> , args )  async def getnetworkinfo ( self ) :          return await self . _send_single ( <str> )  async def relayfee ( self ) :          network_info = await self . getnetworkinfo ( ) return network_info [ <str> ]  async def getrawtransaction ( self , hex_hash , verbose = False ) :          return await self . _send_single ( <str> , ( hex_hash , int ( verbose ) ) )  async def getrawtransactions ( self , hex_hashes , replace_errs = True ) :          params_iterable = ( ( hex_hash , 0 ) for hex_hash in hex_hashes ) txs = await self . _send_vector ( <str> , params_iterable , replace_errs = replace_errs ) return [ hex_to_bytes ( tx ) if tx else None for tx in txs ]  async def broadcast_transaction ( self , raw_tx ) :          return await self . _send_single ( <str> , ( raw_tx , ) )  async def height ( self ) :          self . _height = await self . _send_single ( <str> ) return self . _height  def cached_height ( self ) :          return self . _height   class DashDaemon ( Daemon ) :      async def masternode_broadcast ( self , params ) :          return await self . _send_single ( <str> , params )  async def masternode_list ( self , params ) :          return await self . _send_single ( <str> , params )  async def protx ( self , params ) :          return await self . _send_single ( <str> , params )   class FakeEstimateFeeDaemon ( Daemon ) :      async def estimatefee ( self , block_count ) :          return self . coin . ESTIMATE_FEE  async def relayfee ( self ) :          return self . coin . RELAY_FEE   class LegacyRPCDaemon ( Daemon ) :      async def raw_blocks ( self , hex_hashes ) :          params_iterable = ( ( h , ) for h in hex_hashes ) block_info = await self . _send_vector ( <str> , params_iterable ) blocks = [ ] for i in block_info :              raw_block = await self . make_raw_block ( i ) blocks . append ( raw_block )  return blocks  async def make_raw_header ( self , b ) :          pbh = b . get ( <str> ) if pbh is None :              pbh = <str> * 64  return <str> . join ( [ pack ( <str> , b . get ( <str> ) ) , hex_str_to_hash ( pbh ) , hex_str_to_hash ( b . get ( <str> ) ) , pack ( <str> , self . timestamp_safe ( b [ <str> ] ) ) , pack ( <str> , int ( b . get ( <str> ) , 16 ) ) , pack ( <str> , int ( b . get ( <str> ) ) ) ] )  async def make_raw_block ( self , b ) :          header = await self . make_raw_header ( b ) transactions = [ ] if b . get ( <str> ) > 0 :              transactions = await self . getrawtransactions ( b . get ( <str> ) , False )  raw_block = header num_txs = len ( transactions ) if num_txs > 0 :              raw_block += pack_varint ( num_txs ) raw_block += <str> . join ( transactions )  else :              raw_block += <str>  return raw_block  def timestamp_safe ( self , t ) :          if isinstance ( t , int ) :              return t  return timegm ( time . strptime ( t , <str> ) )   class FakeEstimateLegacyRPCDaemon ( LegacyRPCDaemon , FakeEstimateFeeDaemon ) :      pass  class DecredDaemon ( Daemon ) :      async def raw_blocks ( self , hex_hashes ) :          params_iterable = ( ( h , False ) for h in hex_hashes ) blocks = await self . _send_vector ( <str> , params_iterable ) raw_blocks = [ ] valid_tx_tree = { } for block in blocks :              raw_block = hex_to_bytes ( block ) raw_blocks . append ( raw_block ) prev = self . prev_hex_hash ( raw_block ) votebits = unpack_le_uint16_from ( raw_block [ 100 : 102 ] ) [ 0 ] valid_tx_tree [ prev ] = self . is_valid_tx_tree ( votebits )  processed_raw_blocks = [ ] for hash , raw_block in zip ( hex_hashes , raw_blocks ) :              if hash in valid_tx_tree :                  is_valid = valid_tx_tree [ hash ]  else :                  header = await self . _send_single ( <str> , ( hash , ) ) if <str> not in header :                      raise DaemonError ( <str> )  next_hash = header [ <str> ] next_header = await self . _send_single ( <str> , ( next_hash , ) ) is_valid = self . is_valid_tx_tree ( next_header [ <str> ] )  if is_valid :                  processed_raw_blocks . append ( raw_block )  else :                  self . logger . info ( <str> ) processed_raw_blocks . append ( self . strip_tx_tree ( raw_block ) )   return processed_raw_blocks  @ staticmethod def prev_hex_hash ( raw_block ) :          return hash_to_hex_str ( raw_block [ 4 : 36 ] )  @ staticmethod def is_valid_tx_tree ( votebits ) :          return bool ( votebits & ( 1 << 0 ) != 0 )  def strip_tx_tree ( self , raw_block ) :          c = self . coin assert issubclass ( c . DESERIALIZER , DeserializerDecred ) d = c . DESERIALIZER ( raw_block , start = c . BASIC_HEADER_SIZE ) d . read_tx_tree ( ) return raw_block [ : c . BASIC_HEADER_SIZE ] + <str> + raw_block [ d . cursor : ]  async def height ( self ) :          height = await super ( ) . height ( ) if height > 0 :              height -= 1 self . _height = height  return height  async def mempool_hashes ( self ) :          mempool = await super ( ) . mempool_hashes ( ) real_height = await self . _send_single ( <str> ) tip_hash = await self . _send_single ( <str> , ( real_height , ) ) tip = await self . deserialised_block ( tip_hash ) mempool += tip [ <str> ] [ 1 : ] mempool += tip . get ( <str> , [ ] ) return mempool  def connector ( self ) :          return aiohttp . TCPConnector ( verify_ssl = False )   class PreLegacyRPCDaemon ( LegacyRPCDaemon ) :      async def deserialised_block ( self , hex_hash ) :          return await self . _send_single ( <str> , ( hex_hash , False ) )   class SmartCashDaemon ( Daemon ) :      async def masternode_broadcast ( self , params ) :          return await self . _send_single ( <str> , params )  async def masternode_list ( self , params ) :          return await self . _send_single ( <str> , params )  async def smartrewards ( self , params ) :          return await self . _send_single ( <str> , params )   class ZcoinMtpDaemon ( Daemon ) :      def strip_mtp_data ( self , raw_block ) :          if self . coin . is_mtp ( raw_block ) :              return raw_block [ : self . coin . MTP_HEADER_DATA_START * 2 ] + raw_block [ self . coin . MTP_HEADER_DATA_END * 2 : ]  return raw_block  async def raw_blocks ( self , hex_hashes ) :          params_iterable = ( ( h , False ) for h in hex_hashes ) blocks = await self . _send_vector ( <str> , params_iterable ) return [ hex_to_bytes ( self . strip_mtp_data ( block ) ) for block in blocks ]  async def masternode_broadcast ( self , params ) :          return await self . _send_single ( <str> , params )  async def masternode_list ( self , params ) :          return await self . _send_single ( <str> , params )  async def protx ( self , params ) :          return await self . _send_single ( <str> , params )    