import os import sys sys . setrecursionlimit ( 50000 ) import gzip import pickle import numpy as np from scipy . misc import imread , imresize from load import get_seperation , get_traineval_seperation , get_labels , get_features from get_intersection import get_intersection import networkx as nx import get_overlap_ratio import itertools from collections import deque from itertools import chain , islice import time import theano from theano import tensor as T from sklearn import linear_model import lasagne from lasagne . layers . dnn import Conv2DDNNLayer as ConvLayer from lasagne . layers import Pool2DLayer as PoolLayer from lasagne . layers import InputLayer , ElemwiseSumLayer , DenseLayer , batch_norm , TransposedConv2DLayer , BatchNormLayer from sklearn . preprocessing import MinMaxScaler def get_set_intersection ( set_ ) :      intersection = get_intersection ( set_ [ 0 ] , set_ [ 1 ] ) if intersection == [ ] :         return [ ]  for s in set_ [ 2 : len ( set_ ) ] :          intersection = get_intersection ( intersection , s ) if intersection == [ ] :              return [ ]   return intersection  def extract_coords ( level_numbers , boxes ) :      coords = [ ] level_boxes = [ ] for i in level_numbers :          level_boxes . append ( boxes [ i ] [ 0 ] )  combinations = list ( itertools . combinations ( level_numbers , 2 ) ) G = nx . Graph ( ) G . add_edges_from ( combinations ) for comb in combinations :          set_ = [ ] for c in comb :              set_ . append ( boxes [ c ] [ 0 ] )  I = get_set_intersection ( set_ ) if I == [ ] :              G . remove_edges_from ( [ comb ] )   real_b = [ b [ 0 ] for b in boxes ] length = 1 index = { } nbrs = { } for u in G :          index [ u ] = len ( index ) nbrs [ u ] = { v for v in G [ u ] if v not in index }  queue = deque ( ( [ u ] , sorted ( nbrs [ u ] , key = index . __getitem__ ) ) for u in G ) while queue :          base , cnbrs = map ( list , queue . popleft ( ) ) if len ( base ) > length :              length = len ( base )  I = [ 0 , 0 , 1000 , 1000 ] for c in base :              if I != [ ] :                 I = get_intersection ( boxes [ c ] [ 0 ] , I )   if I != [ ] :              coords . append ( I )  for i , u in enumerate ( cnbrs ) :              queue . append ( ( chain ( base , [ u ] ) , filter ( nbrs [ u ] . __contains__ , islice ( cnbrs , i + 1 , None ) ) ) )   return coords  def create_tree ( boxes ) :      G = nx . Graph ( ) levels = { } levels [ 0 ] = [ 0 ] G . add_node ( 0 ) if len ( boxes ) != 1 :          for box , i in zip ( boxes [ 1 : len ( boxes ) ] , range ( 1 , len ( boxes ) ) ) :              if ( box [ 0 ] [ 2 ] - box [ 0 ] [ 0 ] ) * ( box [ 0 ] [ 3 ] - box [ 0 ] [ 1 ] ) == 0 :                  print box print <str> , i continue  possible_parents = [ ] for box_ , ii in zip ( boxes , range ( len ( boxes ) ) ) :                  if get_overlap_ratio . get_overlap_ratio ( box [ 0 ] , box_ [ 0 ] ) == 1 and box != box_ :                      possible_parents . append ( ii )   I = boxes [ i ] [ 0 ] put_here = [ ] for pp in possible_parents :                  p_h = True level = nx . shortest_path_length ( G , 0 , pp ) + 1 if level in levels :                      for window in levels [ level ] :                          II = boxes [ window ] [ 0 ] if get_overlap_ratio . get_overlap_ratio ( I , II ) == 1 :                              p_h = False   if p_h == True :                          put_here . append ( pp )   else :                      put_here . append ( pp )   parent = min ( put_here ) level = nx . shortest_path_length ( G , 0 , parent ) + 1 if level in levels :                  if parent not in levels [ level ] :                      levels [ level ] . append ( i )  G . add_edge ( i , parent )  else :                  levels [ level ] = [ i ] G . add_edge ( i , parent )    return G , levels  def sort_boxes ( boxes , from_ , to ) :      sorted_boxes = [ ] decorated = [ ( ( box [ 0 ] [ 3 ] - box [ 0 ] [ 1 ] ) * ( box [ 0 ] [ 2 ] - box [ 0 ] [ 0 ] ) , i ) for i , box in enumerate ( boxes ) ] decorated . sort ( ) for box , i in reversed ( decorated ) :          sorted_boxes . append ( boxes [ i ] )  return sorted_boxes [ from_ : to ]  def surface_area ( boxes , boxes_level ) :      if len ( boxes_level ) == 1 :          I = boxes [ boxes_level [ 0 ] ] [ 0 ] return ( I [ 3 ] - I [ 1 ] ) * ( I [ 2 ] - I [ 0 ] )  surface_area = 0 level_boxes = [ ] index = { } nbrs = { } for i in boxes_level :          level_boxes . append ( boxes [ i ] [ 0 ] )  combinations = list ( itertools . combinations ( boxes_level , 2 ) ) G = nx . Graph ( ) G . add_edges_from ( combinations ) for comb in combinations :          set_ = [ ] for c in comb :              set_ . append ( boxes [ c ] [ 0 ] )  I = get_set_intersection ( set_ ) if I == [ ] :              G . remove_edges_from ( [ comb ] )   for u in G :          index [ u ] = len ( index ) nbrs [ u ] = { v for v in G [ u ] if v not in index }  queue = deque ( ( [ u ] , sorted ( nbrs [ u ] , key = index . __getitem__ ) ) for u in G ) while queue :          base , cnbrs = map ( list , queue . popleft ( ) ) I = [ 0 , 0 , 1000 , 1000 ] for c in base :              I = get_intersection ( boxes [ c ] [ 0 ] , I )  if len ( base ) % 2 == 1 :                  surface_area += ( I [ 3 ] - I [ 1 ] ) * ( I [ 2 ] - I [ 0 ] )  elif len ( base ) % 2 == 0 :              surface_area -= ( I [ 3 ] - I [ 1 ] ) * ( I [ 2 ] - I [ 0 ] )  for i , u in enumerate ( cnbrs ) :              queue . append ( ( chain ( base , [ u ] ) , filter ( nbrs [ u ] . __contains__ , islice ( cnbrs , i + 1 , None ) ) ) )   return surface_area  flips = True ignors = False normalize = True minibatch_size = 8 print <str> file = open ( <str> , <str> ) resnet = pickle . load ( file ) print <str> file = open ( <str> , <str> ) resnet32 = pickle . load ( file ) print <str> X = T . tensor4 ( <str> ) Y = T . ivector ( <str> ) data = <str> output_caffe = lasagne . layers . get_output ( resnet [ <str> ] , X , deterministic = True ) features_caffe = theano . function ( inputs = [ X ] , outputs = output_caffe ) output_caffe32 = lasagne . layers . get_output ( resnet32 [ <str> ] , X , deterministic = True ) features_caffe32 = theano . function ( inputs = [ X ] , outputs = output_caffe32 ) rrange = 600000 if data == <str> else 9963 if data == <str> :      a = 3  else :      a = 1  for a_i in range ( 1 , a + 1 ) :      start = time . time ( ) for img_nr in range ( 9787 , 9964 ) :          index_feat = 1 print img_nr coords_to_extract = [ ] batch_feature = [ ] feat_full_all = [ ] feat_last_conv_all = [ ] if data == <str> :              if os . path . isfile ( <str> + str ( a_i ) + <str> + ( format ( img_nr , <str> ) ) + <str> ) :                  img = imread ( <str> + str ( a_i ) + <str> + ( format ( img_nr , <str> ) ) + <str> )  else :                  print <str> + str ( a_i ) + <str> + ( format ( img_nr , <str> ) ) + <str> continue   elif data == <str> :              if os . path . isfile ( <str> + ( format ( img_nr , <str> ) ) + <str> ) :                  img = imread ( <str> + ( format ( img_nr , <str> ) ) + <str> )  else :                  print <str> + ( format ( img_nr , <str> ) ) + <str> continue   elif data == <str> :              if os . path . isfile ( <str> + ( format ( img_nr , <str> ) ) + <str> ) :                  img = imread ( <str> + ( format ( img_nr , <str> ) ) + <str> )  else :                  print <str> + ( format ( img_nr , <str> ) ) + <str>   if data == <str> :              if os . path . isfile ( <str> + str ( a_i ) + <str> + ( format ( img_nr , <str> ) ) + <str> ) :                      f = open ( <str> + str ( a_i ) + <str> + ( format ( img_nr , <str> ) ) + <str> , <str> )  else :                  print <str> + str ( a_i ) + <str> + ( format ( img_nr , <str> ) ) + <str>   elif data == <str> :              if os . path . isfile ( <str> + ( format ( img_nr , <str> ) ) + <str> ) :                      f = open ( <str> + ( format ( img_nr , <str> ) ) + <str> , <str> )  else :                  print <str> + ( format ( img_nr , <str> ) ) + <str>   else :              if os . path . isfile ( <str> + ( format ( img_nr , <str> ) ) + <str> ) :                      f = open ( <str> + ( format ( img_nr , <str> ) ) + <str> , <str> )  else :                  print <str> + ( format ( img_nr , <str> ) ) + <str> continue   boxes = [ ] for i_n , line in enumerate ( f ) :              tmp = line . split ( <str> ) coord = [ ] for s in tmp :                  coord . append ( float ( s ) )  boxes . append ( [ coord ] )  f . close ( ) boxes = sort_boxes ( boxes , 0 , 5000 ) G , levels = create_tree ( boxes ) nr_levels_covered = 100 total_size = surface_area ( boxes , levels [ 0 ] ) for level in levels :              sa = surface_area ( boxes , levels [ level ] ) sa_co = sa / total_size if sa_co != 1.0 :                  G . remove_nodes_from ( levels [ level ] )  else :                  nr_levels_covered = level   levels = { k : levels [ k ] for k in range ( 0 , nr_levels_covered + 1 ) } for patch in G . nodes ( ) :              coords_to_extract . extend ( boxes [ patch ] )  for level in levels :              intersection_coords = extract_coords ( levels [ level ] , boxes ) coords_to_extract . extend ( intersection_coords ) missing_coords = extract_coords ( levels [ level ] , boxes ) coords_to_extract . extend ( missing_coords )  a = np . array ( coords_to_extract ) unique_coords = np . unique ( a . view ( np . dtype ( ( np . void , a . dtype . itemsize * a . shape [ 1 ] ) ) ) ) . view ( a . dtype ) . reshape ( - 1 , a . shape [ 1 ] ) same_coords = 0 final_coords = [ ] for coord in unique_coords :              if coord [ 1 ] == coord [ 3 ] or coord [ 0 ] == coord [ 2 ] :                  same_coords += 1  else :                  final_coords . append ( coord )   for coord in final_coords :              cropped = img [ coord [ 1 ] : coord [ 3 ] , coord [ 0 ] : coord [ 2 ] ] img_2 = imresize ( cropped , ( 224 , 224 ) ) train_X1 = np . zeros ( ( 1 , 3 , 224 , 224 ) ) if type ( img_2 [ 0 ] [ 0 ] ) == np . dtype ( <str> ) :                  train_X1 [ : , 0 , : , : ] = img_2 [ : , : ] train_X1 [ : , 1 , : , : ] = img_2 [ : , : ] train_X1 [ : , 2 , : , : ] = img_2 [ : , : ]  else :                  train_X1 [ : , 0 , : , : ] = img_2 [ : , : , 0 ] train_X1 [ : , 1 , : , : ] = img_2 [ : , : , 1 ] train_X1 [ : , 2 , : , : ] = img_2 [ : , : , 2 ]  if index_feat % 32 == 0 :                  feat_full = features_caffe32 ( np . array ( batch_feature , dtype = np . float32 ) ) batch_feature = [ ] batch_feature . extend ( train_X1 ) feat_full_all . extend ( feat_full )  else :                  batch_feature . extend ( train_X1 )  index_feat += 1  if len ( batch_feature ) > 0 :              for cc in batch_feature :                  feat_full = features_caffe ( np . array ( [ cc ] , dtype = np . float32 ) ) feat_full_all . extend ( feat_full )   print len ( feat_full_all ) print same_coords print index_feat np . savetxt ( <str> % ( a_i , format ( img_nr , <str> ) ) , np . array ( feat_full_all ) , delimiter = <str> ) np . savetxt ( <str> % ( a_i , format ( img_nr , <str> ) ) , np . array ( np . array ( final_coords ) ) , delimiter = <str> )   end = time . time ( ) print end - start  