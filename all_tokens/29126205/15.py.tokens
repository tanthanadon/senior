from __future__ import division import numpy as np import matplotlib . pyplot as plt import healpy as hp import pymaster as nmt from astropy import units as u from astropy . coordinates import SkyCoord import astropy . coordinates as coord from astropy . io import fits import os import h5py def make_mask ( nside , GALFA_cut = False , b_cut = False , save_mask = False , nonabsb_cut = False , nonabsb_cut_gt = False ) :      out_fn = <str> . format ( nside , b_cut , GALFA_cut ) if os . path . isfile ( out_fn ) :          print ( <str> . format ( out_fn ) ) mask = hp . fitsfunc . read_map ( out_fn , nest = False ) return mask  npix = 12 * nside ** 2 mask = np . zeros ( npix , np . int_ ) all_l , all_b = hp . pixelfunc . pix2ang ( nside , np . arange ( npix ) , lonlat = True ) all_coords = SkyCoord ( frame = <str> , l = all_l * u . deg , b = all_b * u . deg ) all_coords_icrs = all_coords . icrs all_ra = all_coords_icrs . ra . deg all_dec = all_coords_icrs . dec . deg if GALFA_cut :          mask [ np . where ( ( all_dec < 37.0 ) & ( all_dec > 1.0 ) ) ] = 1  if b_cut :          mask [ np . where ( np . abs ( all_b ) < b_cut ) ] = 0  if nonabsb_cut and not GALFA_cut :          print ( <str> ) print ( <str> . format ( nonabsb_cut ) ) mask = np . ones ( npix , np . int_ ) mask [ np . where ( all_b < nonabsb_cut ) ] = 0  if nonabsb_cut_gt and not GALFA_cut :          print ( <str> ) print ( <str> . format ( nonabsb_cut_gt ) ) mask = np . ones ( npix , np . int_ ) mask [ np . where ( all_b > nonabsb_cut_gt ) ] = 0  if b_cut and not GALFA_cut :          print ( <str> ) mask = np . ones ( npix , np . int_ ) mask [ np . where ( np . abs ( all_b ) < b_cut ) ] = 0  if save_mask :          hp . fitsfunc . write_map ( out_fn , mask , nest = False , fits_IDL = False , coord = <str> )  return mask  def make_circular_pixel_mask ( nside = 1024 , ipix = 4000000 , raddeg = 2 ) :      mask = np . zeros ( 12 * nside ** 2 ) mask [ hp . query_disc ( nside , hp . pix2vec ( nside , ipix ) , np . radians ( raddeg ) , nest = False ) ] = 1 return mask  def load_Planck_mask ( skycoverage = 70 , nside = 2048 , local = False ) :      if local :          maskroot = <str>  else :          maskroot = <str>  maskhdu = fits . open ( maskroot + <str> ) maskstr = <str> . format ( skycoverage ) masknest = maskhdu [ 1 ] . data [ maskstr ] maskring = hp . pixelfunc . reorder ( masknest , n2r = True ) if nside != 2048 :          if nside <= 64 :              maskring_lr = hp . ud_grade ( maskring , 512 ) maskring = hp . ud_grade ( maskring_lr , nside ) print ( <str> . format ( nside ) )  else :              maskring = hp . ud_grade ( maskring , nside ) print ( <str> . format ( nside ) )   return maskring  def apodize_mask ( mask , apod_arcmin = 60 , apod_type = <str> ) :      apod_deg = apod_arcmin / 60. mask_apod = nmt . mask_apodization ( mask , apod_deg , apotype = apod_type ) return mask_apod  def get_planck_data ( nu = 353 , local = False , Ionly = False , QU = False , IQU = False , vers = <str> , HM = False ) :      if local :          planck_root = <str>  else :          planck_root = <str>  if nu == 353 :          nustr = <str>  else :          nustr = <str>  if HM is False :          if vers == <str> :              planck_fn = planck_root + <str> . format ( nu , nustr )  else :              planck_fn = planck_root + <str> . format ( nu , nustr , vers )   elif HM == <str> :          planck_fn = planck_root + <str> . format ( nu , nustr , vers )  elif HM == <str> :          planck_fn = planck_root + <str> . format ( nu , nustr , vers )  print ( <str> . format ( planck_fn ) ) if QU :          read_fields = ( 1 , 2 )  elif IQU :          read_fields = ( 0 , 1 , 2 )  else :          read_fields = ( 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 )  if Ionly :          read_fields = 0  out_data = hp . fitsfunc . read_map ( planck_fn , field = read_fields , nest = False ) if IQU :          I_data = out_data [ 0 ] Q_data = out_data [ 1 ] U_data = out_data [ 2 ] return I_data , Q_data , U_data  elif QU :          Q_data = out_data [ 0 ] U_data = out_data [ 1 ] return Q_data , U_data  elif Ionly :          return out_data  else :          print ( <str> )   def make_bins ( nside = 2048 , binwidth = 20 , ellmax = 1001 , is_Dell = False ) :      bins = nmt . NmtBin ( nside , nlb = binwidth , lmax = int ( ellmax ) , is_Dell = is_Dell ) ell_binned = bins . get_effective_ells ( ) nbins = len ( ell_binned ) return bins , ell_binned  def xcorr_TEB ( I_Afield , Q_Afield , U_Afield , I_Bfield , Q_Bfield , U_Bfield , apod_mask = None , bins = None , nside = 2048 , savedata = True , EBpure = True , dataname = [ <str> , <str> ] , savestr = <str> , verbose = 0 , data_root = <str> , ** kwargs ) :      print ( <str> ) if EBpure :          purify_e = True purify_b = True  else :          purify_e = False purify_b = False  EB_Afield = nmt . NmtField ( apod_mask , [ Q_Afield , U_Afield ] , purify_e = purify_e , purify_b = purify_b ) EB_Bfield = nmt . NmtField ( apod_mask , [ Q_Bfield , U_Bfield ] , purify_e = purify_e , purify_b = purify_b ) T_Afield = nmt . NmtField ( apod_mask , [ I_Afield ] ) T_Bfield = nmt . NmtField ( apod_mask , [ I_Bfield ] ) if verbose :          print ( <str> )  w = nmt . NmtWorkspace ( ) if verbose :          print ( <str> )  if bins == None :          bins , ell_binned = make_bins ( nside = nside , binwidth = 20 , ellmax = 1001 )  else :          ell_binned = bins . get_effective_ells ( )  ClAA_00 = nmt . compute_full_master ( T_Afield , T_Afield , bins ) ClAB_00 = nmt . compute_full_master ( T_Afield , T_Bfield , bins ) ClBB_00 = nmt . compute_full_master ( T_Bfield , T_Bfield , bins ) ClAA_02 = nmt . compute_full_master ( T_Afield , EB_Afield , bins ) ClAB_02 = nmt . compute_full_master ( T_Afield , EB_Bfield , bins ) ClBB_02 = nmt . compute_full_master ( T_Bfield , EB_Bfield , bins ) ClAA_22 = nmt . compute_full_master ( EB_Afield , EB_Afield , bins ) ClAB_22 = nmt . compute_full_master ( EB_Afield , EB_Bfield , bins ) ClBB_22 = nmt . compute_full_master ( EB_Bfield , EB_Bfield , bins ) if verbose :          print ( <str> )  if savedata :          Aname = dataname [ 0 ] Bname = dataname [ 1 ] out_fn = data_root + <str> . format ( Aname , Bname , EBpure , nside , savestr ) print ( <str> . format ( out_fn ) ) with h5py . File ( out_fn , <str> ) as f :              dset = f . create_dataset ( name = <str> , data = ClAB_00 ) dset1 = f . create_dataset ( name = <str> , data = ClAA_00 ) dset2 = f . create_dataset ( name = <str> , data = ClBB_00 ) dset3 = f . create_dataset ( name = <str> , data = ClAB_02 ) dset4 = f . create_dataset ( name = <str> , data = ClAA_02 ) dset5 = f . create_dataset ( name = <str> , data = ClBB_02 ) dset6 = f . create_dataset ( name = <str> , data = ClAB_22 ) dset7 = f . create_dataset ( name = <str> , data = ClAA_22 ) dset8 = f . create_dataset ( name = <str> , data = ClBB_22 ) dset . attrs [ <str> ] = nside dset . attrs [ <str> ] = EBpure dset . attrs [ <str> ] = ell_binned for key in kwargs . keys ( ) :                  dset . attrs [ key ] = kwargs [ key ]     def xcorr_T_EB ( I_Afield , Q_Bfield , U_Bfield , apod_mask = None , bins = None , nside = 2048 , savedata = True , EBpure = True , CFM = False , Cerrors = False , dataname = [ <str> , <str> ] , savestr = <str> , verbose = 0 , data_root = <str> , ** kwargs ) :      print ( <str> ) if EBpure :          purify_e = True purify_b = True if verbose :              print ( <str> )   else :          purify_e = False purify_b = False if verbose :              print ( <str> )   print ( <str> . format ( np . sum ( apod_mask ) / len ( apod_mask ) ) ) print ( <str> , Q_Bfield . shape , Q_Bfield . dtype ) EB_Bfield = nmt . NmtField ( apod_mask , [ Q_Bfield , U_Bfield ] , purify_e = purify_e , purify_b = purify_b ) if verbose :          print ( <str> )  T_Afield = nmt . NmtField ( apod_mask , [ I_Afield ] ) if verbose :          print ( <str> )  w = nmt . NmtWorkspace ( ) if verbose :          print ( <str> )  if bins == None :          print ( <str> ) bins , ell_binned = make_bins ( nside = nside , binwidth = 20 , ellmax = 1001 )  else :          ell_binned = bins . get_effective_ells ( )  if CFM :          if verbose :              print ( <str> )  ClAB_02 = nmt . compute_full_master ( T_Afield , EB_Bfield , bins ) if Cerrors :              ClAA_00 = nmt . compute_full_master ( T_Afield , T_Afield , bins ) ClBB_22 = nmt . compute_full_master ( EB_Bfield , EB_Bfield , bins )   else :          w . compute_coupling_matrix ( T_Afield , EB_Bfield , bins ) if verbose :              print ( <str> )  ClAB_02 = w . decouple_cell ( nmt . compute_coupled_cell ( T_Afield , EB_Bfield ) ) if Cerrors :              print ( <str> )   if Cerrors :          TT = ClAA_00 [ 0 ] EE = ClBB_22 [ 0 ] EB = ClBB_22 [ 1 ] BE = ClBB_22 [ 2 ] BB = ClBB_22 [ 3 ] fsky = np . sum ( apod_mask ) / len ( apod_mask ) print ( <str> . format ( fsky ) ) fsky2 = np . sum ( apod_mask ** 2 ) / len ( apod_mask ) fsky3 = np . sum ( apod_mask ** 3 ) / len ( apod_mask ) fsky4 = np . sum ( apod_mask ** 4 ) / len ( apod_mask ) ell_binwidth = ell_binned [ 1 ] - ell_binned [ 0 ] err_TE = ( TT * EE ) / ( fsky * ( 2 * ell_binned + 1 ) * ell_binwidth ) err_TB = ( TT * BB ) / ( fsky * ( 2 * ell_binned + 1 ) * ell_binwidth )  if verbose :          print ( <str> )  if savedata :          Aname = dataname [ 0 ] Bname = dataname [ 1 ] out_fn = data_root + <str> . format ( Aname , Bname , EBpure , nside , savestr ) print ( <str> . format ( out_fn ) ) with h5py . File ( out_fn , <str> ) as f :              dset = f . create_dataset ( name = <str> , data = ClAB_02 ) if Cerrors :                  TT = f . create_dataset ( name = <str> , data = TT ) EE = f . create_dataset ( name = <str> , data = EE ) BB = f . create_dataset ( name = <str> , data = BB ) BE = f . create_dataset ( name = <str> , data = BE ) EB = f . create_dataset ( name = <str> , data = EB ) errTE = f . create_dataset ( name = <str> , data = err_TE ) errTB = f . create_dataset ( name = <str> , data = err_TB ) dset . attrs [ <str> ] = fsky dset . attrs [ <str> ] = fsky2 dset . attrs [ <str> ] = fsky3 dset . attrs [ <str> ] = fsky4  dset . attrs [ <str> ] = nside dset . attrs [ <str> ] = EBpure dset . attrs [ <str> ] = ell_binned for key in kwargs . keys ( ) :                  dset . attrs [ key ] = kwargs [ key ]     def xcorr_E_B ( Q_Afield , U_Afield , Q_Bfield , U_Bfield , apod_mask = None , bins = None , nside = 2048 , savedata = True , EBpure = True , dataname = [ <str> , <str> ] , savestr = <str> , verbose = 0 , data_root = <str> , ** kwargs ) :      print ( <str> ) if EBpure :          purify_e = True purify_b = True  EB_Afield = nmt . NmtField ( apod_mask , [ Q_Afield , U_Afield ] , purify_e = purify_e , purify_b = purify_b ) EB_Bfield = nmt . NmtField ( apod_mask , [ Q_Bfield , U_Bfield ] , purify_e = purify_e , purify_b = purify_b ) if verbose :          print ( <str> )  w = nmt . NmtWorkspace ( ) if verbose :          print ( <str> )  if bins == None :          bins , ell_binned = make_bins ( nside = nside , binwidth = 20 , ellmax = 1001 )  else :          ell_binned = bins . get_effective_ells ( )  w . compute_coupling_matrix ( EB_Afield , EB_Bfield , bins ) if verbose :          print ( <str> )  Cl_A_B = w . decouple_cell ( nmt . compute_coupled_cell ( EB_Afield , EB_Bfield ) ) Cl_A_A = w . decouple_cell ( nmt . compute_coupled_cell ( EB_Afield , EB_Afield ) ) Cl_B_B = w . decouple_cell ( nmt . compute_coupled_cell ( EB_Bfield , EB_Bfield ) ) if verbose :          print ( <str> )  if savedata :          Aname = dataname [ 0 ] Bname = dataname [ 1 ] out_fn = data_root + <str> . format ( Aname , Bname , EBpure , nside , savestr ) print ( <str> . format ( out_fn ) ) with h5py . File ( out_fn , <str> ) as f :              dset = f . create_dataset ( name = <str> , data = Cl_A_B ) dset1 = f . create_dataset ( name = <str> , data = Cl_A_A ) dset2 = f . create_dataset ( name = <str> , data = Cl_B_B ) dset . attrs [ <str> ] = nside dset . attrs [ <str> ] = EBpure dset . attrs [ <str> ] = ell_binned for key in kwargs . keys ( ) :                  dset . attrs [ key ] = kwargs [ key ]    else :          return Cl_A_B , Cl_A_A , Cl_B_B   def example_E_B_Planck ( ) :      Q353 , U353 = get_planck_data ( nu = 353 , local = False , QU = True , IQU = False ) Q217 , U217 = get_planck_data ( nu = 217 , local = False , QU = True , IQU = False ) nside = 2048 b_cut = 30 GALFA_cut = False apod_arcmin = 60 apod_type = <str> mask_b30 = make_mask ( nside , GALFA_cut = GALFA_cut , b_cut = b_cut , save_mask = True ) mask_b30_apod = apodize_mask ( mask_b30 , apod_arcmin = apod_arcmin , apod_type = apod_type ) bins , ell_binned = make_bins ( nside = nside , binwidth = 20 , ellmax = 1001 ) dict_kwargs = { <str> : b_cut , <str> : GALFA_cut , <str> : apod_arcmin , <str> : apod_type } outstr = <str> for _key in dict_kwargs . keys ( ) :          outstr += <str> . format ( _key , dict_kwargs [ _key ] )  outstr += <str> xcorr_E_B ( Q353 , U353 , Q217 , U217 , apod_mask = mask_b30_apod , bins = bins , nside = 2048 , savedata = True , EBpure = True , dataname = [ <str> , <str> ] , savestr = outstr , ** dict_kwargs )   