from __future__ import division , print_function import numpy as np import healpy as hp from numpy . linalg import lapack_lite import time import matplotlib . pyplot as plt import matplotlib . gridspec as gridspec from astropy . io import fits import cPickle as pickle import itertools import string import sqlite3 import scipy from scipy import special , interpolate import scipy . ndimage import copy from mpl_toolkits . axes_grid1 import make_axes_locatable , axes_size from numpy . core . multiarray import digitize , bincount , interp as compiled_interp import matplotlib as mpl import matplotlib . ticker as ticker from matplotlib import rc import emcee rc ( <str> , usetex = True ) import debias import sys sys . path . insert ( 0 , <str> ) import RHT_tools sys . path . insert ( 0 , <str> ) import basic_functions as polarization_tools class BayesianComponent ( ) :      def __init__ ( self , hp_index , verbose = True ) :          self . hp_index = hp_index self . verbose = verbose  def integrate_highest_dimension ( self , field , dx = 1 ) :          axis_num = field . ndim - 1 integrated_field = np . trapz ( field , dx = dx , axis = axis_num ) return integrated_field  def get_psi0_sampling_grid ( self , hp_index , verbose = True , returnzerotheta = False ) :          wlen = 75 psi0_sample_db = sqlite3 . connect ( <str> + str ( wlen ) + <str> ) psi0_sample_cursor = psi0_sample_db . cursor ( ) zero_theta = psi0_sample_cursor . execute ( <str> , ( hp_index , ) ) . fetchone ( ) thets = RHT_tools . get_thets ( wlen , save = False , verbose = verbose ) self . sample_psi0 = np . mod ( zero_theta [ 0 ] - thets , np . pi ) if returnzerotheta :              return self . sample_psi0 , zero_theta [ 0 ]  else :              return self . sample_psi0   def roll_RHT_zero_to_pi ( self , rht_data , sample_psi ) :          psi_0_indx = np . abs ( sample_psi ) . argmin ( ) if self . verbose is True :              print ( <str> , psi_0_indx , sample_psi [ psi_0_indx ] )  rolled_sample_psi = np . roll ( sample_psi , - psi_0_indx - 1 ) rolled_rht = np . roll ( rht_data , - psi_0_indx - 1 ) return rolled_rht , rolled_sample_psi  def get_adaptive_p_grid ( self , hp_index ) :          planck_tqu_db = sqlite3 . connect ( <str> ) planck_tqu_cursor = planck_tqu_db . cursor ( ) ( self . hp_index , self . T , self . Q , self . U ) = planck_tqu_cursor . execute ( <str> , ( self . hp_index , ) ) . fetchone ( ) pmeas = np . sqrt ( self . Q ** 2 + self . U ** 2 ) / self . T planck_cov_db = sqlite3 . connect ( <str> ) planck_cov_cursor = planck_cov_db . cursor ( ) ( self . hp_index , self . TT , self . TQ , self . TU , self . TQa , self . QQ , self . QU , self . TUa , self . QUa , self . UU ) = planck_cov_cursor . execute ( <str> , ( self . hp_index , ) ) . fetchone ( ) sigpsq = ( 1 / ( pmeas ** 2 * self . T ** 4 ) ) * ( self . Q ** 2 * self . QQ + self . U ** 2 * self . UU + 2 * self . Q * self . U * self . QU ) sigmameas = np . sqrt ( sigpsq ) pgridmin = max ( 0 , pmeas - 7 * sigmameas ) pgridmax = min ( 1 , pmeas + 7 * sigmameas ) pgrid = np . linspace ( pgridmin , pgridmax , 165 ) return pgrid  def get_thetaRHT_hat ( self , sample_psi0 , rht_data ) :          QRHT = np . sum ( np . cos ( 2 * sample_psi0 ) * rht_data ) URHT = np . sum ( np . sin ( 2 * sample_psi0 ) * rht_data ) theta_rht = np . mod ( 0.5 * np . arctan2 ( URHT , QRHT ) , np . pi ) return theta_rht   class Prior ( BayesianComponent ) :      def __init__ ( self , hp_index , sample_p0 , reverse_RHT = False , verbose = False , region = <str> , rht_cursor = None , gausssmooth = False , deltafuncprior = False , baseprioramp = 1E-8 ) :          BayesianComponent . __init__ ( self , hp_index , verbose = verbose ) if region is <str> :              self . rht_data = rht_cursor . execute ( <str> , ( self . hp_index , ) ) . fetchone ( )  if region is <str> :              self . rht_data = rht_cursor . execute ( <str> , ( self . hp_index , ) ) . fetchone ( )  self . sample_p0 = sample_p0 try :              self . rht_data = self . rht_data [ 1 : ] self . maxrht = np . max ( self . rht_data ) if deltafuncprior :                  self . rht_data = np . zeros ( len ( self . rht_data ) ) self . rht_data [ 80 ] = 100.0  if gausssmooth is True :                  self . rht_data = scipy . ndimage . gaussian_filter1d ( self . rht_data , 3 , mode = <str> )  self . sample_psi0 , self . zero_theta = self . get_psi0_sampling_grid ( hp_index , verbose = verbose , returnzerotheta = True ) self . unrolled_thetaRHT = self . get_thetaRHT_hat ( self . sample_psi0 , self . rht_data ) self . unrolled_rht_data = copy . copy ( self . rht_data ) self . unrolled_sample_psi0 = copy . copy ( self . sample_psi0 ) self . rht_data , self . sample_psi0 = self . roll_RHT_zero_to_pi ( self . rht_data , self . sample_psi0 ) self . rolled_thetaRHT = self . get_thetaRHT_hat ( self . sample_psi0 , self . rht_data ) npsample = len ( self . sample_p0 ) if reverse_RHT is True :                  if verbose is True :                      print ( <str> )  self . rht_data = self . rht_data [ : : - 1 ] self . sample_psi0 = self . sample_psi0 [ : : - 1 ]  if baseprioramp is None :                  self . prior = ( np . array ( [ self . rht_data ] * npsample ) . T + 0.7 ) * 75  elif baseprioramp is <str> :                  self . prior = ( np . array ( [ self . rht_data ] * npsample ) . T + ( 1 - self . maxrht ) )  elif baseprioramp is <str> :                  self . prior = ( np . array ( [ self . rht_data ] * npsample ) . T + max ( 0.25 - self . maxrht , 0 ) ) if max ( 0.25 - self . maxrht , 0 ) < 0 :                      print ( <str> . format ( max ( 0.25 - self . maxrht , 0 ) ) )   elif baseprioramp is <str> :                   globalmaxval = 4.2041096687316895 self . prior = ( np . array ( [ self . rht_data ] * npsample ) . T + max ( globalmaxval - self . maxrht , 0 ) )  else :                  self . prior = ( np . array ( [ self . rht_data ] * npsample ) . T + baseprioramp )  self . psi_dx = self . sample_psi0 [ 1 ] - self . sample_psi0 [ 0 ] self . p_dx = self . sample_p0 [ 1 ] - self . sample_p0 [ 0 ] if self . psi_dx < 0 :                  if verbose :                      print ( <str> )  self . psi_dx *= - 1  if verbose is True :                  print ( <str> . format ( self . psi_dx , self . p_dx ) )  self . integrated_over_psi = self . integrate_highest_dimension ( self . prior , dx = self . psi_dx ) self . integrated_over_p_and_psi = self . integrate_highest_dimension ( self . integrated_over_psi , dx = self . p_dx ) self . normed_prior = self . prior / self . integrated_over_p_and_psi  except TypeError :              if self . rht_data is None :                  print ( <str> . format ( hp_index ) )  else :                  print ( <str> . format ( hp_index ) )     class PriorThetaRHT ( BayesianComponent ) :      def __init__ ( self , hp_index , sample_p0 , reverse_RHT = False , verbose = False , region = <str> , QU_QUsq_RHT_cursor = None , smoothprior = False , fixwidth = False ) :          BayesianComponent . __init__ ( self , hp_index , verbose = verbose ) try :              if smoothprior :                  ( self . hp_index , self . QRHT , self . URHT , self . QRHTsq , self . URHTsq ) = QU_QUsq_RHT_cursor . execute ( <str> , ( self . hp_index , ) ) . fetchone ( )  else :                  ( self . hp_index , self . QRHT , self . URHT , self . QRHTsq , self . URHTsq ) = QU_QUsq_RHT_cursor . execute ( <str> , ( self . hp_index , ) ) . fetchone ( )  if fixwidth is False :                  try :                      self . sig_psi , self . sig_P = polarization_tools . sigma_psi_P ( self . QRHT , self . URHT , self . QRHTsq , self . URHTsq , degrees = False )  except ZeroDivisionError :                      print ( self . QRHT , self . URHT , self . QRHTsq , self . URHTsq )   self . sample_psi0 = np . linspace ( 0 , np . pi , 165 , endpoint = False ) self . sample_p0 = sample_p0 self . psimeas = polarization_tools . polarization_angle ( self . QRHT , self . URHT , negU = False ) if fixwidth :                  kappa = 1 / 0.063165468166971897  else :                  kappa = 1 / self . sig_psi ** 2  axialvonmises = np . cosh ( kappa * np . cos ( self . sample_psi0 - self . psimeas ) ) / ( np . pi * special . iv ( 0 , kappa ) ) npsample = len ( self . sample_p0 ) self . prior = np . array ( [ axialvonmises ] * npsample ) . T self . psi_dx = polarization_tools . angle_residual ( self . sample_psi0 [ 1 ] , self . sample_psi0 [ 0 ] , degrees = False ) self . p_dx = self . sample_p0 [ 1 ] - self . sample_p0 [ 0 ] if self . psi_dx < 0 :                  print ( <str> ) self . psi_dx *= - 1  if verbose is True :                  print ( <str> . format ( self . psi_dx , self . p_dx ) )  self . integrated_over_psi = self . integrate_highest_dimension ( self . prior , dx = self . psi_dx ) self . integrated_over_p_and_psi = self . integrate_highest_dimension ( self . integrated_over_psi , dx = self . p_dx ) self . normed_prior = self . prior / self . integrated_over_p_and_psi  except TypeError :              if self . QRHT is None :                  print ( <str> . format ( hp_index ) )  else :                  print ( <str> . format ( hp_index ) )     class Likelihood ( BayesianComponent ) :      def __init__ ( self , hp_index , planck_tqu_cursor , planck_cov_cursor , p0_all , psi0_all ) :          BayesianComponent . __init__ ( self , hp_index ) ( self . hp_index , self . T , self . Q , self . U ) = planck_tqu_cursor . execute ( <str> , ( self . hp_index , ) ) . fetchone ( ) ( self . hp_index , self . TT , self . TQ , self . TU , self . TQa , self . QQ , self . QU , self . TUa , self . QUa , self . UU ) = planck_cov_cursor . execute ( <str> , ( self . hp_index , ) ) . fetchone ( ) self . naive_psi = np . mod ( 0.5 * np . arctan2 ( self . U , self . Q ) , np . pi ) self . sigma_p = np . zeros ( ( 2 , 2 ) , np . float_ ) self . sigma_p [ 0 , 0 ] = ( 1.0 / self . T ** 2 ) * self . QQ self . sigma_p [ 0 , 1 ] = ( 1.0 / self . T ** 2 ) * self . QU self . sigma_p [ 1 , 0 ] = ( 1.0 / self . T ** 2 ) * self . QU self . sigma_p [ 1 , 1 ] = ( 1.0 / self . T ** 2 ) * self . UU det_sigma_p = np . linalg . det ( self . sigma_p ) self . sigpGsq = np . sqrt ( det_sigma_p ) psimeas = np . mod ( 0.5 * np . arctan2 ( self . U , self . Q ) , np . pi ) pmeas = np . sqrt ( self . Q ** 2 + self . U ** 2 ) / self . T self . psimeas = psimeas self . pmeas = pmeas invsig = np . linalg . inv ( self . sigma_p ) nsample = len ( p0_all ) p0_psi0_grid = np . asarray ( np . meshgrid ( p0_all , psi0_all ) ) outfast = np . zeros ( nsample * nsample , np . float_ ) measpart0 = pmeas * np . cos ( 2 * psimeas ) measpart1 = pmeas * np . sin ( 2 * psimeas ) p0pairs = p0_psi0_grid [ 0 , ... ] . ravel ( ) psi0pairs = p0_psi0_grid [ 1 , ... ] . ravel ( ) truepart0 = p0pairs * np . cos ( 2 * psi0pairs ) truepart1 = p0pairs * np . sin ( 2 * psi0pairs ) rharrbig = np . zeros ( ( 2 , 1 , nsample * nsample ) , np . float_ ) lharrbig = np . zeros ( ( 1 , 2 , nsample * nsample ) , np . float_ ) rharrbig [ 0 , 0 , : ] = measpart0 - truepart0 rharrbig [ 1 , 0 , : ] = measpart1 - truepart1 lharrbig [ 0 , 0 , : ] = measpart0 - truepart0 lharrbig [ 0 , 1 , : ] = measpart1 - truepart1 self . likelihood = ( 1.0 / ( np . pi * self . sigpGsq ) ) * np . exp ( - 0.5 * np . einsum ( <str> , lharrbig , np . einsum ( <str> , invsig , rharrbig ) ) ) self . likelihood = self . likelihood . reshape ( nsample , nsample )   class Posterior ( BayesianComponent ) :      def __init__ ( self , hp_index , sample_p0 = None , adaptivep0 = False , region = <str> , useprior = <str> , rht_cursor = None , QU_QUsq_RHT_cursor = None , gausssmooth_prior = False , deltafuncprior = False , testpsiproj = False , baseprioramp = 1E-8 , smoothprior = False , fixwidth = False ) :          BayesianComponent . __init__ ( self , hp_index ) if sample_p0 is None :              if adaptivep0 is True :                  self . sample_p0 = self . get_adaptive_p_grid ( hp_index )  else :                  self . sample_p0 = np . linspace ( 0 , 1 , 165 )   else :              self . sample_p0 = sample_p0  if useprior is <str> :              prior = Prior ( hp_index , self . sample_p0 , reverse_RHT = True , region = region , rht_cursor = rht_cursor , gausssmooth = gausssmooth_prior , deltafuncprior = deltafuncprior , baseprioramp = baseprioramp )  elif useprior is <str> :              prior = PriorThetaRHT ( hp_index , self . sample_p0 , reverse_RHT = True , region = region , QU_QUsq_RHT_cursor = QU_QUsq_RHT_cursor , smoothprior = smoothprior , fixwidth = fixwidth )  self . sample_psi0 = prior . sample_psi0 planck_cov_db = sqlite3 . connect ( <str> ) planck_cov_cursor = planck_cov_db . cursor ( ) planck_tqu_db = sqlite3 . connect ( <str> ) planck_tqu_cursor = planck_tqu_db . cursor ( ) likelihood = Likelihood ( hp_index , planck_tqu_cursor , planck_cov_cursor , self . sample_p0 , self . sample_psi0 ) self . naive_psi = likelihood . naive_psi self . psimeas = likelihood . psimeas self . pmeas = likelihood . pmeas self . likelihood = likelihood self . normed_prior = prior . normed_prior self . planck_likelihood = likelihood . likelihood if testpsiproj is True :              self . normed_posterior = self . normed_prior  else :              self . posterior = self . planck_likelihood * self . normed_prior p_dx = self . sample_p0 [ 1 ] - self . sample_p0 [ 0 ] self . psi_dx = prior . psi_dx self . p_dx = p_dx self . posterior_integrated_over_psi = self . integrate_highest_dimension ( self . posterior , dx = self . psi_dx ) self . posterior_integrated_over_p_and_psi = self . integrate_highest_dimension ( self . posterior_integrated_over_psi , dx = p_dx ) self . normed_posterior = self . posterior / self . posterior_integrated_over_p_and_psi  self . prior_obj = prior   class PlanckPosterior ( BayesianComponent ) :      def __init__ ( self , hp_index , planck_tqu_cursor , planck_cov_cursor , p0_all , psi0_all , adaptivep0 = True ) :          BayesianComponent . __init__ ( self , hp_index ) if adaptivep0 is True :              self . sample_p0 = self . get_adaptive_p_grid ( hp_index )  else :              self . sample_p0 = p0_all  self . sample_psi0 = psi0_all likelihood = Likelihood ( hp_index , planck_tqu_cursor , planck_cov_cursor , self . sample_p0 , self . sample_psi0 ) self . posterior = likelihood . likelihood self . naive_psi = likelihood . naive_psi self . psimeas = likelihood . psimeas self . pmeas = likelihood . pmeas self . planck_likelihood = likelihood . likelihood self . normed_prior = np . zeros ( self . planck_likelihood . shape ) psi_dx = np . abs ( self . sample_psi0 [ 1 ] - self . sample_psi0 [ 0 ] ) p_dx = self . sample_p0 [ 1 ] - self . sample_p0 [ 0 ] self . psi_dx = psi_dx self . p_dx = p_dx self . posterior_integrated_over_psi = self . integrate_highest_dimension ( self . posterior , dx = psi_dx ) self . posterior_integrated_over_p_and_psi = self . integrate_highest_dimension ( self . posterior_integrated_over_psi , dx = p_dx ) self . normed_posterior = self . posterior / self . posterior_integrated_over_p_and_psi   class DummyPosterior ( BayesianComponent ) :        def __init__ ( self , verbose = True ) :          BayesianComponent . __init__ ( self , 0 ) self . sample_p0 = np . linspace ( 0 , 1 , 180 ) self . sample_psi0 = np . linspace ( 0 , np . pi , 165 , endpoint = False ) self . psi_dx = self . sample_psi0 [ 1 ] - self . sample_psi0 [ 0 ] self . p_dx = self . sample_p0 [ 1 ] - self . sample_p0 [ 0 ] if self . psi_dx < 0 :              print ( <str> ) self . psi_dx *= - 1  if verbose is True :              print ( <str> . format ( self . psi_dx , self . p_dx ) )  psi_y = self . sample_psi0 [ : , np . newaxis ] p_x = self . sample_p0 self . psimeas = np . pi / 2. self . pmeas = 0.2 self . fwhm = 0.3 gaussian = np . exp ( - 4 * np . log ( 2 ) * ( ( p_x - self . pmeas ) ** 2 + ( psi_y - self . psimeas ) ** 2 ) / self . fwhm ** 2 ) newpsi0 , gaussian = center_posterior_psi_given ( self . sample_psi0 , gaussian , np . pi / 3 , verbose = False ) self . planck_likelihood = gaussian self . integrated_over_psi = self . integrate_highest_dimension ( self . planck_likelihood , dx = self . psi_dx ) self . integrated_over_p_and_psi = self . integrate_highest_dimension ( self . integrated_over_psi , dx = self . p_dx ) self . normed_posterior = self . planck_likelihood / self . integrated_over_p_and_psi self . normed_prior = np . ones ( self . normed_posterior . shape , np . float_ )   def lnlikelihood ( hp_index , T , Q , U , QQ , QU , UU , p0 , psi0 ) :      sigma_p = np . zeros ( ( 2 , 2 ) , np . float_ ) sigma_p [ 0 , 0 ] = ( 1.0 / T ** 2 ) * QQ sigma_p [ 0 , 1 ] = ( 1.0 / T ** 2 ) * QU sigma_p [ 1 , 0 ] = ( 1.0 / T ** 2 ) * QU sigma_p [ 1 , 1 ] = ( 1.0 / T ** 2 ) * UU det_sigma_p = np . linalg . det ( sigma_p ) sigpGsq = np . sqrt ( det_sigma_p ) psimeas = np . mod ( 0.5 * np . arctan2 ( U , Q ) , np . pi ) pmeas = np . sqrt ( Q ** 2 + U ** 2 ) / T invsig = np . linalg . inv ( sigma_p ) measpart0 = pmeas * np . cos ( 2 * psimeas ) measpart1 = pmeas * np . sin ( 2 * psimeas ) truepart0 = p0 * np . cos ( 2 * psi0 ) truepart1 = p0 * np . sin ( 2 * psi0 ) rharr = np . zeros ( ( 2 , 1 ) , np . float_ ) lharr = np . zeros ( ( 1 , 2 ) , np . float_ ) rharr [ 0 , 0 ] = measpart0 - truepart0 rharr [ 1 , 0 ] = measpart1 - truepart1 lharr [ 0 , 0 ] = measpart0 - truepart0 lharr [ 0 , 1 ] = measpart1 - truepart1 lnlike = np . log ( 1.0 / ( np . pi * sigpGsq ) ) + - 0.5 * np . einsum ( <str> , lharr , np . einsum ( <str> , invsig , rharr ) ) return lnlike [ 0 ] [ 0 ]  def lnprior ( hp_index , psi0 , lowerp0bound , upperp0bound , rht_data , region , gausssmooth = True , verbose = False ) :      if gausssmooth is True :          rht_data = scipy . ndimage . gaussian_filter1d ( rht_data , 3 , mode = <str> )  bayesiantool = BayesianComponent ( hp_index ) sample_psi0 = bayesiantool . get_psi0_sampling_grid ( hp_index , verbose = verbose ) prior = ( np . array ( rht_data ) + 0.7 ) * 75 psi_dx = sample_psi0 [ 1 ] - sample_psi0 [ 0 ] integrated_over_psi = np . trapz ( prior , dx = - psi_dx ) normed_prior = ( prior / integrated_over_psi ) / ( upperp0bound - lowerp0bound ) return np . log ( np . interp ( psi0 , sample_psi0 , normed_prior , period = np . pi ) )  def lnposterior ( p0psi0 , hp_index , lowerp0bound , upperp0bound , region , rht_data , T , Q , U , QQ , QU , UU ) :      p0 , psi0 = p0psi0 if ( p0 > upperp0bound ) or ( p0 < lowerp0bound ) :          return - np . inf  else :          lnlikeout = lnlikelihood ( hp_index , T , Q , U , QQ , QU , UU , p0 , psi0 ) lnpriorout = lnprior ( hp_index , psi0 , lowerp0bound , upperp0bound , rht_data , region ) return lnlikeout + lnpriorout   def MCMC_posterior ( hp_index , region = <str> , rht_cursor = None , adaptivep0 = True , verbose = False , local = False , proposal_scale = 2.0 ) :      nwalkers = 250 ndim = 2 if adaptivep0 is True :          bayesiantool = BayesianComponent ( hp_index ) p0grid = bayesiantool . get_adaptive_p_grid ( hp_index ) lowerp0bound = np . nanmin ( p0grid ) upperp0bound = np . nanmax ( p0grid )  else :          lowerp0bound = 0.0 upperp0bound = 1.0  if verbose is True :          print ( <str> . format ( lowerp0bound , upperp0bound ) )  planck_cov_db = sqlite3 . connect ( <str> ) planck_cov_cursor = planck_cov_db . cursor ( ) planck_tqu_db = sqlite3 . connect ( <str> ) planck_tqu_cursor = planck_tqu_db . cursor ( ) ( hp_index , T , Q , U ) = planck_tqu_cursor . execute ( <str> , ( hp_index , ) ) . fetchone ( ) ( hp_index , TT , TQ , TU , TQa , QQ , QU , TUa , QUa , UU ) = planck_cov_cursor . execute ( <str> , ( hp_index , ) ) . fetchone ( ) if local is True :          rht_data = rht_cursor . execute ( <str> , ( hp_index , ) ) . fetchone ( )  else :          rht_data = rht_cursor . execute ( <str> , ( hp_index , ) ) . fetchone ( )  rht_data = rht_data [ 1 : ] psimeas = np . mod ( 0.5 * np . arctan2 ( U , Q ) , np . pi ) pmeas = np . sqrt ( Q ** 2 + U ** 2 ) / T if verbose is True :          print ( <str> . format ( pmeas , psimeas ) )  startpos = np . array ( [ [ pmeas , psimeas ] + 1e-2 * np . random . randn ( ndim ) for i in range ( nwalkers ) ] ) startpos [ : , 1 ] = np . mod ( startpos [ : , 1 ] , np . pi ) sampler = emcee . EnsembleSampler ( nwalkers , ndim , lnposterior , a = proposal_scale , args = [ hp_index , lowerp0bound , upperp0bound , region , rht_data , T , Q , U , QQ , QU , UU ] ) posout , probout , stateout = sampler . run_mcmc ( startpos , 50 ) sampler . reset ( ) posout [ : , 1 ] = np . mod ( posout [ : , 1 ] , np . pi ) sampler . run_mcmc ( posout , 250 ) sampler . flatchain [ : , 1 ] = np . mod ( sampler . flatchain [ : , 1 ] , np . pi ) pmed , psimed = np . percentile ( sampler . flatchain , 50 , axis = 0 ) if verbose is True :          print ( np . mean ( sampler . flatchain , axis = 0 ) ) print ( <str> . format ( np . mean ( sampler . acceptance_fraction ) ) ) print ( pmed , psimed )  return pmed , psimed , sampler , startpos , posout  def lnposterior_interpolated ( pt , bayesian_object , lowerp0bound , upperp0bound ) :      p0 , psi0 = pt if ( p0 > upperp0bound ) or ( p0 < lowerp0bound ) :          return - np . inf  else :          interpfunc = interpolate . interp1d ( bayesian_object . sample_p0 , np . log ( bayesian_object . normed_posterior ) , axis = 1 ) psiarr = interpfunc ( p0 ) return np . interp ( psi0 , bayesian_object . sample_psi0 , psiarr , period = np . pi )   def MCMC_posterior_interpolated ( bayesian_object ) :      time0 = time . time ( ) nwalkers = 250 ndim = 2 lowerp0bound = np . nanmin ( bayesian_object . sample_p0 ) upperp0bound = np . nanmax ( bayesian_object . sample_p0 ) startpos = np . array ( [ [ bayesian_object . pmeas , bayesian_object . psimeas ] + 1e-2 * np . random . randn ( ndim ) for i in range ( nwalkers ) ] ) startpos [ : , 1 ] = np . mod ( startpos [ : , 1 ] , np . pi ) sampler = emcee . EnsembleSampler ( nwalkers , ndim , lnposterior_interpolated , args = [ bayesian_object , lowerp0bound , upperp0bound ] ) posout , probout , stateout = sampler . run_mcmc ( startpos , 50 ) sampler . reset ( ) posout [ : , 1 ] = np . mod ( posout [ : , 1 ] , np . pi ) sampler . run_mcmc ( posout , 500 ) pmed , psimed = np . percentile ( sampler . flatchain , 50 , axis = 0 ) pmed16 , psimed16 = np . percentile ( sampler . flatchain , 16 , axis = 0 ) pmed84 , psimed84 = np . percentile ( sampler . flatchain , 84 , axis = 0 ) print ( np . mean ( sampler . flatchain , axis = 0 ) ) time1 = time . time ( ) print ( <str> . format ( np . mean ( sampler . acceptance_fraction ) ) ) print ( pmed , psimed ) print ( pmed16 , pmed84 , psimed16 , psimed84 ) print ( <str> , time1 - time0 )  def latex_formatter ( x , pos ) :      return <str> . format ( x )  def plot_bayesian_component_from_posterior ( posterior_obj , component = <str> , ax = None , cmap = <str> ) :      if ax is None :          fig = plt . figure ( ) ax = fig . add_subplot ( 111 )  ax . set_aspect ( <str> ) if component == <str> :          plotarr = posterior_obj . normed_posterior title = <str>  if component == <str> :          plotarr = posterior_obj . planck_likelihood title = <str>  if component == <str> :          plotarr = posterior_obj . normed_prior title = <str>  if posterior_obj . sample_psi0 [ - 1 ] == np . pi :          im = ax . pcolor ( posterior_obj . sample_p0 , posterior_obj . sample_psi0 , plotarr , cmap = cmap )  else :          im = ax . pcolor ( posterior_obj . sample_p0 , np . mod ( posterior_obj . sample_psi0 , np . pi ) , plotarr , cmap = cmap )  ax . set_title ( title , size = 15 ) div = make_axes_locatable ( ax ) cax = div . append_axes ( <str> , size = <str> , pad = 0.05 ) cbar = plt . colorbar ( im , cax = cax , format = ticker . FuncFormatter ( latex_formatter ) )  def plot_all_bayesian_components_from_posterior ( posterior_obj , cmap = <str> , returnax = False ) :      fig = plt . figure ( figsize = ( 14 , 4 ) , facecolor = <str> ) gs = gridspec . GridSpec ( 1 , 3 ) ax1 = plt . subplot ( gs [ 0 ] ) ax2 = plt . subplot ( gs [ 1 ] ) ax3 = plt . subplot ( gs [ 2 ] ) gs . update ( left = 0.05 , right = 0.95 , wspace = 0.3 , hspace = 0.3 , bottom = 0.15 ) plot_bayesian_component_from_posterior ( posterior_obj , component = <str> , ax = ax1 , cmap = cmap ) plot_bayesian_component_from_posterior ( posterior_obj , component = <str> , ax = ax2 , cmap = cmap ) plot_bayesian_component_from_posterior ( posterior_obj , component = <str> , ax = ax3 , cmap = cmap ) pMB , psiMB = mean_bayesian_posterior ( posterior_obj , center = <str> ) ax3 . plot ( pMB , np . mod ( psiMB , np . pi ) , <str> , ms = 10 , mew = 2 , color = <str> ) p_map , psi_map = maximum_a_posteriori ( posterior_obj ) ax3 . plot ( p_map , np . mod ( psi_map , np . pi ) , <str> , ms = 10 , mew = 2 , color = <str> ) pnaive = posterior_obj . pmeas psinaive = posterior_obj . psimeas ax1 . plot ( pnaive , psinaive , <str> , ms = 10 , mew = 2 , color = <str> ) axs = [ ax1 , ax2 , ax3 ] for ax in axs :          if np . mod ( posterior_obj . sample_psi0 [ - 1 ] , np . pi ) == 0 :              ax . set_ylim ( np . mod ( posterior_obj . sample_psi0 [ 0 ] , np . pi ) , np . pi )  else :              ax . set_ylim ( np . mod ( posterior_obj . sample_psi0 [ 0 ] , np . pi ) , np . mod ( posterior_obj . sample_psi0 [ - 1 ] , np . pi ) )  ax . set_ylabel ( <str> , size = 15 ) ax . set_xlabel ( <str> , size = 15 )  if returnax :          return axs   def naive_planck_measurements ( hp_index , verbose = False ) :      planck_tqu_db = sqlite3 . connect ( <str> ) planck_tqu_cursor = planck_tqu_db . cursor ( ) I0 = planck_tqu_cursor . execute ( <str> , ( hp_index , ) ) . fetchone ( ) Qmeas = planck_tqu_cursor . execute ( <str> , ( hp_index , ) ) . fetchone ( ) Umeas = planck_tqu_cursor . execute ( <str> , ( hp_index , ) ) . fetchone ( ) Pnaive = np . sqrt ( Qmeas [ 0 ] ** 2 + Umeas [ 0 ] ** 2 ) pnaive = Pnaive / I0 psinaive = np . mod ( 0.5 * np . arctan2 ( Umeas , Qmeas ) , np . pi ) if verbose is True :          print ( <str> . format ( pnaive ) ) print ( <str> . format ( psinaive ) )  return pnaive , psinaive  def center_naive_measurements ( hp_index , sample_p0 , center_on_p , sample_psi0 , center_on_psi ) :      pnaive , psinaive = naive_planck_measurements ( hp_index ) pnaive_indx = np . abs ( sample_p0 - pnaive ) . argmin ( ) psinaive_indx = np . abs ( sample_psi0 - psinaive ) . argmin ( ) rolled_sample_p0 = np . roll ( sample_p0 , - pnaive_indx ) rolled_weights_p0 = np . roll ( center_on_p , - pnaive_indx ) rolled_sample_psi0 = np . roll ( sample_psi0 , - psinaive_indx ) rolled_weights_psi0 = np . roll ( center_on_psi , - psinaive_indx ) return rolled_sample_p0 , rolled_weights_p0 , rolled_sample_psi0 , rolled_weights_psi0  def center_posterior_naive_psi ( posterior_obj , sample_psi0 , posterior , verbose = False ) :      try :          pnaive = posterior_obj . pmeas psinaive = posterior_obj . psimeas  except AttributeError :          print ( <str> ) pnaive , psinaive = naive_planck_measurements ( posterior_obj . hp_index )  psinaive_indx = np . abs ( sample_psi0 - ( psinaive - np . pi / 2 ) ) . argmin ( ) if ( psinaive - np . pi / 2 ) <= 1E-10 :          if verbose is True :              print ( <str> )   else :          if verbose is True :              print ( <str> . format ( psinaive - np . pi / 2 , sample_psi0 [ psinaive_indx ] , np . abs ( ( psinaive - np . pi / 2 ) - sample_psi0 [ psinaive_indx ] ) ) )  if np . abs ( ( psinaive - np . pi / 2 ) - sample_psi0 [ psinaive_indx ] ) > ( sample_psi0 [ 1 ] - sample_psi0 [ 0 ] ) :              if verbose is True :                  print ( <str> )  sample_psi0 -= np . pi psinaive_indx = np . abs ( sample_psi0 - ( psinaive - np . pi / 2 ) ) . argmin ( ) if verbose is True :                  print ( <str> ) print ( <str> . format ( psinaive - np . pi / 2 , sample_psi0 [ psinaive_indx ] , np . abs ( ( psinaive - np . pi / 2 ) - sample_psi0 [ psinaive_indx ] ) ) )    rolled_posterior = np . roll ( posterior , - psinaive_indx , axis = 0 ) rolled_sample_psi0 = np . roll ( sample_psi0 , - psinaive_indx ) rolled_sample_psi0 [ rolled_sample_psi0 < psinaive - np . pi / 2 ] += np . pi rolled_sample_psi0 [ rolled_sample_psi0 > psinaive + np . pi / 2 ] -= np . pi return rolled_sample_psi0 , rolled_posterior  def center_posterior_psi_MAP ( posterior_obj , sample_psi0 , posterior , verbose = False ) :      pMAP , psiMAP = maximum_a_posteriori ( posterior_obj ) psiMAP_indx = np . abs ( sample_psi0 - ( psiMAP - np . pi / 2 ) ) . argmin ( ) if verbose is True :          print ( <str> . format ( psiMAP - np . pi / 2 , sample_psi0 [ psiMAP_indx ] , np . abs ( ( psiMAP - np . pi / 2 ) - sample_psi0 [ psiMAP_indx ] ) ) )  if np . abs ( ( psiMAP - np . pi / 2 ) - sample_psi0 [ psiMAP_indx ] ) > ( sample_psi0 [ 1 ] - sample_psi0 [ 0 ] ) :          if verbose is True :              print ( <str> )  sample_psi0 -= np . pi psiMAP_indx = np . abs ( sample_psi0 - ( psiMAP - np . pi / 2 ) ) . argmin ( ) if verbose is True :              print ( <str> ) print ( <str> . format ( psiMAP - np . pi / 2 , sample_psi0 [ psiMAP_indx ] , np . abs ( ( psiMAP - np . pi / 2 ) - sample_psi0 [ psiMAP_indx ] ) ) )   rolled_posterior = np . roll ( posterior , - psiMAP_indx , axis = 0 ) rolled_sample_psi0 = np . roll ( sample_psi0 , - psiMAP_indx ) rolled_sample_psi0 [ rolled_sample_psi0 < psiMAP - np . pi / 2 ] += np . pi rolled_sample_psi0 [ rolled_sample_psi0 > psiMAP + np . pi / 2 ] -= np . pi return rolled_sample_psi0 , rolled_posterior  def center_posterior_psi_given_old ( sample_psi0 , posterior , given_psi , verbose = False ) :      given_psi_indx = np . abs ( sample_psi0 - ( given_psi - np . pi / 2 ) ) . argmin ( ) if verbose is True :          print ( <str> . format ( given_psi - np . pi / 2 , sample_psi0 [ given_psi_indx ] , np . abs ( ( given_psi - np . pi / 2 ) - sample_psi0 [ given_psi_indx ] ) ) )  if np . abs ( ( given_psi - np . pi / 2 ) - sample_psi0 [ given_psi_indx ] ) > ( sample_psi0 [ 1 ] - sample_psi0 [ 0 ] ) :          if verbose is True :              print ( <str> )  sample_psi0 -= np . pi given_psi_indx = np . abs ( sample_psi0 - ( given_psi - np . pi / 2 ) ) . argmin ( ) if verbose is True :              print ( <str> ) print ( <str> . format ( given_psi - np . pi / 2 , sample_psi0 [ given_psi_indx ] , np . abs ( ( given_psi - np . pi / 2 ) - sample_psi0 [ given_psi_indx ] ) ) )   rolled_posterior = np . roll ( posterior , - given_psi_indx , axis = 0 ) rolled_sample_psi0 = np . roll ( sample_psi0 , - given_psi_indx ) rolled_sample_psi0 [ rolled_sample_psi0 < given_psi - np . pi / 2 ] += np . pi rolled_sample_psi0 [ rolled_sample_psi0 > given_psi + np . pi / 2 ] -= np . pi return rolled_sample_psi0 , rolled_posterior  def center_posterior_psi_given ( sample_psi0 , posterior , given_psi , verbose = False ) :      psi0new = np . linspace ( given_psi - np . pi / 2 , given_psi + np . pi / 2 , len ( sample_psi0 ) , endpoint = False ) centered_posterior = np . zeros ( posterior . shape ) for i , col in enumerate ( posterior . T ) :          centered_posterior [ : , i ] = np . interp ( psi0new , sample_psi0 , col , period = np . pi )  return psi0new , centered_posterior  def periodic_interpolation_2D ( x , xp , fp , period = 0 ) :      fp = fp [ asort_xp ] xp = np . concatenate ( ( xp [ [ - 1 ] ] - period , xp , xp [ [ 0 ] ] + period ) ) fp = np . concatenate ( ( fp [ [ - 1 ] , : ] , fp , fp [ [ 0 ] , : ] ) ) if return_array :          return compiled_interp ( x , xp , fp , left , right )  else :          return compiled_interp ( x , xp , fp , left , right ) . item ( )   def circular_integration ( xpoints , ypoints , endpoint_included = False , axis = 0 ) :      if endpoint_included is False :          integrateme = np . zeros ( len ( ypoints ) + 1 ) integrateme [ : - 1 ] = ypoints integrateme [ - 1 ] = ypoints [ 0 ] integratex = np . zeros ( len ( xpoints ) + 1 ) integratex [ : - 1 ] = xpoints integratex [ - 1 ] = xpoints [ - 1 ] + ( xpoints [ 1 ] - xpoints [ 0 ] )  elif endpoint_included is True :          integrateme = ypoints integratex = xpoints  intdata = np . trapz ( integrateme , integratex , axis = axis ) return intdata  def maximum_a_posteriori ( posterior_obj , verbose = False ) :      psi_map_indx , p_map_indx = np . where ( posterior_obj . normed_posterior == np . nanmax ( posterior_obj . normed_posterior ) ) psi_map_indx = psi_map_indx [ 0 ] p_map_indx = p_map_indx [ 0 ] psi_map = posterior_obj . sample_psi0 [ psi_map_indx ] p_map = posterior_obj . sample_p0 [ p_map_indx ] if verbose is True :          print ( <str> . format ( p_map ) ) print ( <str> . format ( psi_map ) )  return p_map , psi_map  def mean_bayesian_posterior_testQU ( posterior_obj , center = <str> , verbose = False , tol = 1E-5 ) :      posterior = copy . copy ( posterior_obj . normed_posterior ) sample_p0 = posterior_obj . sample_p0 sample_psi0 = posterior_obj . sample_psi0 pdx = sample_p0 [ 1 ] - sample_p0 [ 0 ] psidx = sample_psi0 [ 1 ] - sample_psi0 [ 0 ] pMB_integrand = posterior * sample_p0 pMB_integrated_over_psi0 = posterior_obj . integrate_highest_dimension ( pMB_integrand , dx = psidx ) pMB = posterior_obj . integrate_highest_dimension ( pMB_integrated_over_psi0 , dx = pdx ) UMB_integrand = posterior * np . sin ( 2 * sample_psi0 [ : , np . newaxis ] ) QMB_integrand = posterior * np . cos ( 2 * sample_psi0 [ : , np . newaxis ] ) psiMB_integrand = np . mod ( 0.5 * np . arctan2 ( UMB_integrand , QMB_integrand ) , np . pi ) psiMB_integrated_over_psi0 = posterior_obj . integrate_highest_dimension ( psiMB_integrand , dx = psidx ) psiMB = posterior_obj . integrate_highest_dimension ( psiMB_integrated_over_psi0 , dx = pdx ) print ( <str> . format ( pMB ) ) print ( <str> . format ( psiMB ) ) return pMB , psiMB  def compute_pMB ( posterior_obj ) :      posterior = copy . copy ( posterior_obj . normed_posterior ) sample_p0 = posterior_obj . sample_p0 sample_psi0 = posterior_obj . sample_psi0 pdx = sample_p0 [ 1 ] - sample_p0 [ 0 ] psidx = sample_psi0 [ 1 ] - sample_psi0 [ 0 ] pMB_integrand = posterior * sample_p0 pMB_integrated_over_psi0 = posterior_obj . integrate_highest_dimension ( pMB_integrand , dx = psidx ) pMB = posterior_obj . integrate_highest_dimension ( pMB_integrated_over_psi0 , dx = pdx ) print ( pMB ) return pMB_integrand , pMB_integrated_over_psi0  def compare_ludo ( save = False ) :      rht_cursor , tablename = get_rht_cursor ( local = True ) pp793551 = Posterior ( 793551 , rht_cursor = rht_cursor , adaptivep0 = True , gausssmooth_prior = True ) pp2447655 = Posterior ( 2447655 , rht_cursor = rht_cursor , adaptivep0 = True , gausssmooth_prior = True ) pp3400757 = Posterior ( 3400757 , rht_cursor = rht_cursor , adaptivep0 = True , gausssmooth_prior = True ) if save is True :          for id , posterior_obj in zip ( [ 793551 , 2447655 , 3400757 ] , [ pp793551 , pp2447655 , pp3400757 ] ) :              fits . writeto ( <str> . format ( id ) , posterior_obj . normed_posterior ) fits . writeto ( <str> . format ( id ) , posterior_obj . planck_likelihood ) fits . writeto ( <str> . format ( id ) , posterior_obj . normed_prior ) p0psi0 = np . zeros ( ( 2 , len ( posterior_obj . sample_p0 ) ) , np . float_ ) p0psi0 [ 0 , : ] = posterior_obj . sample_p0 p0psi0 [ 1 , : ] = posterior_obj . sample_psi0 fits . writeto ( <str> . format ( id ) , p0psi0 )   pMB793551 , psiMB793551 = mean_bayesian_posterior ( pp793551 , tol = pp793551 . sample_psi0 [ 1 ] - pp793551 . sample_psi0 [ 0 ] ) pMB2447655 , psiMB2447655 = mean_bayesian_posterior ( pp2447655 , tol = pp2447655 . sample_psi0 [ 1 ] - pp2447655 . sample_psi0 [ 0 ] ) pMB3400757 , psiMB3400757 = mean_bayesian_posterior ( pp3400757 , tol = pp3400757 . sample_psi0 [ 1 ] - pp3400757 . sample_psi0 [ 0 ] ) psiMB793551 = polarization_tools . mod_halfpolar_center_0 ( psiMB793551 ) psiMB2447655 = polarization_tools . mod_halfpolar_center_0 ( psiMB2447655 ) psiMB3400757 = polarization_tools . mod_halfpolar_center_0 ( psiMB3400757 ) print ( 793551 , pMB793551 , psiMB793551 ) print ( 2447655 , pMB2447655 , psiMB2447655 ) print ( 3400757 , pMB3400757 , psiMB3400757 ) pmed , psimed , sampler , startpos , posout = MCMC_posterior ( 793551 , rht_cursor = rht_cursor , local = True ) print ( <str> , pmed , psimed ) pmed , psimed , sampler , startpos , posout = MCMC_posterior ( 2447655 , rht_cursor = rht_cursor , local = True ) print ( <str> , pmed , psimed ) pmed , psimed , sampler , startpos , posout = MCMC_posterior ( 3400757 , rht_cursor = rht_cursor , local = True ) print ( <str> , pmed , psimed ) mean_bayesian_posterior_testQU ( pp793551 ) mean_bayesian_posterior_testQU ( pp2447655 ) mean_bayesian_posterior_testQU ( pp3400757 ) planck_tqu_db = sqlite3 . connect ( <str> ) planck_cov_db = sqlite3 . connect ( <str> ) planck_tqu_cursor = planck_tqu_db . cursor ( ) planck_cov_cursor = planck_cov_db . cursor ( ) planck793551 = PlanckPosterior ( 793551 , planck_tqu_cursor , planck_cov_cursor , pp793551 . sample_p0 , pp793551 . sample_psi0 , adaptivep0 = True ) planck2447655 = PlanckPosterior ( 2447655 , planck_tqu_cursor , planck_cov_cursor , pp2447655 . sample_p0 , pp2447655 . sample_psi0 , adaptivep0 = True ) planck3400757 = PlanckPosterior ( 3400757 , planck_tqu_cursor , planck_cov_cursor , pp3400757 . sample_p0 , pp3400757 . sample_psi0 , adaptivep0 = True ) pplanckMB793551 , psiplanckMB793551 = mean_bayesian_posterior ( planck793551 , tol = planck793551 . sample_psi0 [ 1 ] - planck793551 . sample_psi0 [ 0 ] ) pplanckMB2447655 , psiplanckMB2447655 = mean_bayesian_posterior ( planck2447655 , tol = planck2447655 . sample_psi0 [ 1 ] - planck2447655 . sample_psi0 [ 0 ] ) pplanckMB3400757 , psiplanckMB3400757 = mean_bayesian_posterior ( planck3400757 , tol = planck3400757 . sample_psi0 [ 1 ] - planck3400757 . sample_psi0 [ 0 ] ) psiplanckMB793551 = polarization_tools . mod_halfpolar_center_0 ( psiplanckMB793551 ) psiplanckMB2447655 = polarization_tools . mod_halfpolar_center_0 ( psiplanckMB2447655 ) psiplanckMB3400757 = polarization_tools . mod_halfpolar_center_0 ( psiplanckMB3400757 ) print ( 793551 , pplanckMB793551 , psiplanckMB793551 ) print ( 2447655 , pplanckMB2447655 , psiplanckMB2447655 ) print ( 3400757 , pplanckMB3400757 , psiplanckMB3400757 )  def mean_bayesian_posterior ( posterior_obj , center = <str> , verbose = True , tol = 0.1 ) :      posterior = copy . copy ( posterior_obj . normed_posterior ) sample_p0 = posterior_obj . sample_p0 sample_psi0 = posterior_obj . sample_psi0 pdx = sample_p0 [ 1 ] - sample_p0 [ 0 ] psidx = sample_psi0 [ 1 ] - sample_psi0 [ 0 ] pMB_integrand = posterior * sample_p0 pMB_integrated_over_psi0 = posterior_obj . integrate_highest_dimension ( pMB_integrand , dx = psidx ) pMB = posterior_obj . integrate_highest_dimension ( pMB_integrated_over_psi0 , dx = pdx ) psiMB_integrand = posterior_obj . normed_posterior * sample_psi0 [ : , np . newaxis ] pdf = np . trapz ( psiMB_integrand , dx = pdx , axis = 0 ) sin_nocenter_psiMB_integrand = posterior_obj . normed_posterior * np . sin ( 2 * sample_psi0 [ : , np . newaxis ] ) cos_nocenter_psiMB_integrand = posterior_obj . normed_posterior * np . cos ( 2 * sample_psi0 [ : , np . newaxis ] ) sin_nocenter_pdf = np . trapz ( sin_nocenter_psiMB_integrand , dx = pdx , axis = 0 ) cos_nocenter_pdf = np . trapz ( cos_nocenter_psiMB_integrand , dx = pdx , axis = 0 ) psiMB = 0.5 * np . arctan2 ( np . sum ( sin_nocenter_pdf ) , np . sum ( cos_nocenter_pdf ) ) psiMB = np . mod ( psiMB , np . pi ) return pMB , psiMB  def mean_bayesian_posterior_old ( posterior_obj , center = <str> , verbose = True , tol = 0.1 ) :      posterior = copy . copy ( posterior_obj . normed_posterior ) sample_p0 = posterior_obj . sample_p0 sample_psi0 = posterior_obj . sample_psi0 pdx = sample_p0 [ 1 ] - sample_p0 [ 0 ] psidx = sample_psi0 [ 1 ] - sample_psi0 [ 0 ] pMB_integrand = posterior * sample_p0 pMB_integrated_over_psi0 = posterior_obj . integrate_highest_dimension ( pMB_integrand , dx = psidx ) pMB = posterior_obj . integrate_highest_dimension ( pMB_integrated_over_psi0 , dx = pdx ) if verbose is True :          print ( <str> . format ( pdx , psidx ) )  if verbose is True :          norm_posterior_test = test_normalization ( posterior_obj , pdx , psidx )  nocenter_psiMB_integrand = posterior_obj . normed_posterior * sample_psi0 [ : , np . newaxis ] nocenter_pdf = np . trapz ( nocenter_psiMB_integrand , dx = pdx , axis = 0 ) nocenter_psi0_ludo_new = 0.5 * np . arctan2 ( np . sum ( np . sin ( 2 * sample_psi0 ) * nocenter_pdf ) , np . sum ( np . cos ( 2 * sample_psi0 ) * nocenter_pdf ) ) sin_nocenter_psiMB_integrand = posterior_obj . normed_posterior * np . sin ( 2 * sample_psi0 [ : , np . newaxis ] ) cos_nocenter_psiMB_integrand = posterior_obj . normed_posterior * np . cos ( 2 * sample_psi0 [ : , np . newaxis ] ) sin_nocenter_pdf = np . trapz ( sin_nocenter_psiMB_integrand , dx = pdx , axis = 0 ) cos_nocenter_pdf = np . trapz ( cos_nocenter_psiMB_integrand , dx = pdx , axis = 0 ) my_new_psi0 = 0.5 * np . arctan2 ( np . sum ( sin_nocenter_pdf ) , np . sum ( cos_nocenter_pdf ) ) print ( <str> , np . mod ( nocenter_psi0_ludo_new , np . pi ) ) print ( <str> , np . mod ( my_new_psi0 , np . pi ) ) if center == <str> :          if verbose is True :              print ( <str> )  psinaive = posterior_obj . psimeas pnaive = posterior_obj . pmeas psi0new , centered_posterior = center_posterior_psi_given ( sample_psi0 , posterior , psinaive , verbose = verbose ) psidx = psi0new [ 1 ] - psi0new [ 0 ] if verbose is True :              print ( <str> . format ( psinaive , pnaive ) )   elif center == <str> :          print ( <str> ) if verbose is True :              print ( <str> )  rolled_sample_psi0 , rolled_posterior = center_posterior_psi_MAP ( posterior_obj , sample_psi0 , posterior , verbose = verbose )  v0 = posterior_obj . psimeas v0 = polarization_tools . mod_halfpolar_center_0 ( v0 ) print ( v0 ) psiMB_integrand = posterior_obj . normed_posterior * sample_psi0 [ : , np . newaxis ] pdf = np . trapz ( psiMB_integrand , dx = pdx , axis = 0 ) v0_new = np . sum ( angle_residual ( sample_psi0 , v0 , degrees = False ) * pdf ) * psidx print ( v0_new ) v0 = v0_new + v0 print ( v0 ) ok = 0 i = 0 while ok is 0 :          v0_new = np . sum ( angle_residual ( sample_psi0 , v0 , degrees = False ) * pdf ) * psidx if v0_new <= psidx :              ok = 1  v0 = v0_new + v0 print ( v0 ) i = i + 1  print ( i ) print ( <str> . format ( v0 ) ) psi0_ludo_new = 0.5 * np . arctan2 ( np . sum ( np . sin ( 2 * sample_psi0 ) * pdf ) , np . sum ( np . cos ( 2 * sample_psi0 ) * pdf ) ) print ( <str> . format ( psi0_ludo_new ) ) if psidx != psi0new [ 1 ] - psi0new [ 0 ] :          print ( <str> . format ( psidx , psi0new [ 1 ] - psi0new [ 0 ] ) )  psi0new = polarization_tools . mod_halfpolar_center_0 ( psi0new ) psiMB_integrand = centered_posterior * psi0new [ : , np . newaxis ] psiMB_integrated_over_psi0 = posterior_obj . integrate_highest_dimension ( psiMB_integrand , dx = psidx ) psiMB = posterior_obj . integrate_highest_dimension ( psiMB_integrated_over_psi0 , dx = pdx ) if verbose is True :          print ( <str> . format ( pMB ) ) print ( <str> . format ( psiMB ) )  psi_last = copy . copy ( psinaive ) i = 0 itertol = 3000 if verbose is True :          print ( <str> . format ( tol ) )  while ( np . abs ( angle_residual ( psi_last , psiMB , degrees = False ) ) > tol ) and ( i < itertol ) :          if verbose is True :              print ( <str> . format ( psi_last , psiMB , np . abs ( angle_residual ( psi_last , psiMB , degrees = False ) ) ) ) print ( <str> . format ( i ) ) print ( <str> . format ( psiMB ) )  psi_last = copy . copy ( psiMB ) psi0new , centered_posterior = center_posterior_psi_given ( psi0new , centered_posterior , psiMB , verbose = verbose ) psi0new = polarization_tools . mod_halfpolar_center_0 ( psi0new ) psiMB_integrand = centered_posterior * psi0new [ : , np . newaxis ] psiMB_integrated_over_psi0 = posterior_obj . integrate_highest_dimension ( psiMB_integrand , dx = psidx ) psiMB = posterior_obj . integrate_highest_dimension ( psiMB_integrated_over_psi0 , dx = pdx ) if verbose is True :              print ( <str> . format ( psiMB ) )  i += 1  print ( i ) return pMB , psiMB , my_new_psi0  def test_normalization ( posterior_obj , pdx , psidx ) :      norm_posterior_test = posterior_obj . integrate_highest_dimension ( posterior_obj . normed_posterior , dx = psidx ) norm_posterior_test = posterior_obj . integrate_highest_dimension ( norm_posterior_test , dx = pdx ) print ( <str> . format ( norm_posterior_test ) ) return norm_posterior_test  def get_all_rht_ids ( rht_cursor , tablename ) :      all_ids = rht_cursor . execute ( <str> + tablename ) . fetchall ( ) return all_ids  def get_rht_cursor ( region = <str> , velrangestring = <str> , local = False ) :      if region is <str> :          rht_db = sqlite3 . connect ( <str> ) tablename = <str>  elif region is <str> :          if local is True :              root = <str>  else :              root = <str>  tablename = <str> if velrangestring == <str> :              rht_db = sqlite3 . connect ( root + <str> )  elif velrangestring == <str> :              print ( <str> ) rht_db = sqlite3 . connect ( root + <str> )  elif velrangestring == <str> :              print ( <str> ) rht_db = sqlite3 . connect ( root + <str> )   rht_cursor = rht_db . cursor ( ) return rht_cursor , tablename  def get_rht_QU_cursors ( local = False , smoothprior = False , sig = 30 ) :      if local is True :          root = <str> print ( root )  else :          root = <str>  if smoothprior :          db_fn = root + <str> + str ( sig ) + <str>  else :          db_fn = root + <str>  print ( <str> , db_fn ) QU_QUsq_RHT_db = sqlite3 . connect ( db_fn ) QU_QUsq_RHT_cursor = QU_QUsq_RHT_db . cursor ( ) return QU_QUsq_RHT_cursor  def sample_all_rht_points ( all_ids , adaptivep0 = True , rht_cursor = None , region = <str> , useprior = <str> , gausssmooth_prior = False , tol = 1E-5 , sampletype = <str> , verbose = False , mcmc = False , deltafuncprior = False , testpsiproj = False , testthetas = False , baseprioramp = 1E-8 ) :      all_pMB = np . zeros ( len ( all_ids ) ) all_psiMB = np . zeros ( len ( all_ids ) ) if testthetas is True :          all_preroll_thetaRHTs = np . zeros ( len ( all_ids ) ) all_postroll_thetaRHTs = np . zeros ( len ( all_ids ) ) all_psi0s = np . zeros ( len ( all_ids ) ) all_zero_thetas = np . zeros ( len ( all_ids ) )  if rht_cursor is None :          print ( <str> ) rht_cursor , tablename = get_rht_cursor ( region = region )  update_progress ( 0.0 ) for i , _id in enumerate ( all_ids ) :          if mcmc is False :              posterior_obj = Posterior ( _id [ 0 ] , adaptivep0 = adaptivep0 , region = region , useprior = useprior , rht_cursor = rht_cursor , gausssmooth_prior = gausssmooth_prior , deltafuncprior = deltafuncprior , testpsiproj = testpsiproj , baseprioramp = baseprioramp ) if testthetas is True :                  all_preroll_thetaRHTs [ i ] = posterior_obj . prior_obj . maxrht  else :                  if sampletype is <str> :                      all_pMB [ i ] , all_psiMB [ i ] = mean_bayesian_posterior ( posterior_obj , center = <str> , verbose = True , tol = tol )  elif sampletype is <str> :                      all_pMB [ i ] , all_psiMB [ i ] = maximum_a_posteriori ( posterior_obj , verbose = verbose )    else :              MCMC_posterior ( _id [ 0 ] , rht_cursor = rht_cursor )  update_progress ( ( i + 1.0 ) / len ( all_ids ) , message = <str> , final_message = <str> )  if testthetas is True :          return all_preroll_thetaRHTs , all_postroll_thetaRHTs  else :          return all_pMB , all_psiMB   def sample_all_planck_points ( all_ids , adaptivep0 = True , planck_tqu_cursor = None , planck_cov_cursor = None , region = <str> , verbose = False , tol = 1E-5 , sampletype = <str> , testproj = False ) :      if testproj :          all_naive_p = np . zeros ( len ( all_ids ) ) all_naive_psi = np . zeros ( len ( all_ids ) )  else :          all_pMB = np . zeros ( len ( all_ids ) ) all_psiMB = np . zeros ( len ( all_ids ) )  if planck_tqu_cursor is None :          print ( <str> ) planck_tqu_db = sqlite3 . connect ( <str> ) planck_tqu_cursor = planck_tqu_db . cursor ( )  if planck_cov_cursor is None :          print ( <str> ) planck_cov_db = sqlite3 . connect ( <str> ) planck_cov_cursor = planck_cov_db . cursor ( )  p0_all = np . linspace ( 0 , 1 , 165 ) psi0_all = np . linspace ( 0 , np . pi , 165 , endpoint = False ) update_progress ( 0.0 ) for i , _id in enumerate ( all_ids ) :          posterior_obj = PlanckPosterior ( _id [ 0 ] , planck_tqu_cursor , planck_cov_cursor , p0_all , psi0_all , adaptivep0 = adaptivep0 ) if testproj :              all_naive_p [ i ] = posterior_obj . pmeas all_naive_psi [ i ] = posterior_obj . psimeas  else :              if sampletype is <str> :                  all_pMB [ i ] , all_psiMB [ i ] = mean_bayesian_posterior ( posterior_obj , center = <str> , verbose = verbose , tol = tol )  elif sampletype is <str> :                  all_pMB [ i ] , all_psiMB [ i ] = maximum_a_posteriori ( posterior_obj , verbose = verbose )  if verbose is True :                  print ( <str> . format ( _id , i , all_pMB [ i ] , all_psiMB [ i ] ) )   update_progress ( ( i + 1.0 ) / len ( all_ids ) , message = <str> , final_message = <str> )  if testproj :          return all_naive_p , all_naive_psi  else :          return all_pMB , all_psiMB   def sample_all_rht_points_ThetaRHTPrior ( all_ids , adaptivep0 = True , region = <str> , useprior = <str> , local = False , tol = 1E-5 , smoothprior = False , sig = 30 , fixwidth = False ) :      all_pMB = np . zeros ( len ( all_ids ) ) all_psiMB = np . zeros ( len ( all_ids ) ) QU_QUsq_RHT_cursor = get_rht_QU_cursors ( local = local , smoothprior = smoothprior , sig = sig ) update_progress ( 0.0 ) for i , _id in enumerate ( all_ids ) :          posterior_obj = Posterior ( _id [ 0 ] , adaptivep0 = adaptivep0 , region = region , useprior = useprior , QU_QUsq_RHT_cursor = QU_QUsq_RHT_cursor , smoothprior = smoothprior , fixwidth = fixwidth ) all_pMB [ i ] , all_psiMB [ i ] = mean_bayesian_posterior ( posterior_obj , center = <str> , verbose = False , tol = tol ) update_progress ( ( i + 1.0 ) / len ( all_ids ) , message = <str> , final_message = <str> )  return all_pMB , all_psiMB  def fully_sample_sky ( region = <str> , limitregion = False , adaptivep0 = True , useprior = <str> , velrangestring = <str> , gausssmooth_prior = False , tol = 1E-5 , sampletype = <str> , mcmc = False , deltafuncprior = False , testpsiproj = False , testthetas = False , save = True , baseprioramp = 1E-8 , smoothprior = False , sig = 30 , fixwidth = False ) :      print ( <str> . format ( region , limitregion , useprior , velrangestring , gausssmooth_prior , deltafuncprior , testpsiproj , testthetas ) ) out_root = <str> rht_cursor , tablename = get_rht_cursor ( region = region , velrangestring = velrangestring ) print ( <str> , tablename ) all_ids = get_all_rht_ids ( rht_cursor , tablename ) if limitregion is True :          print ( <str> ) all_ids_SC = pickle . load ( open ( <str> , <str> ) ) all_ids = list ( set ( all_ids ) . intersection ( all_ids_SC ) )  print ( <str> ) if testthetas is False :          if useprior is <str> :              all_pMB , all_psiMB = sample_all_rht_points ( all_ids , adaptivep0 = adaptivep0 , rht_cursor = rht_cursor , region = region , useprior = useprior , gausssmooth_prior = gausssmooth_prior , tol = tol , sampletype = sampletype , mcmc = mcmc , deltafuncprior = deltafuncprior , testpsiproj = testpsiproj , baseprioramp = baseprioramp )  elif useprior is <str> :              all_pMB , all_psiMB = sample_all_rht_points_ThetaRHTPrior ( all_ids , adaptivep0 = adaptivep0 , region = region , useprior = useprior , local = False , tol = tol , smoothprior = smoothprior , sig = sig , fixwidth = fixwidth )  hp_psiMB = make_hp_map ( all_psiMB , all_ids , Nside = 2048 , nest = True ) hp_pMB = make_hp_map ( all_pMB , all_ids , Nside = 2048 , nest = True ) if limitregion is False :              psiMB_out_fn = <str> + velrangestring + <str> + str ( gausssmooth_prior ) + <str> + str ( adaptivep0 ) + <str> pMB_out_fn = <str> + velrangestring + <str> + str ( gausssmooth_prior ) + <str> + str ( adaptivep0 ) + <str>  elif limitregion is True :              if mcmc is True :                  psiMB_out_fn = <str> + velrangestring + <str> + str ( gausssmooth_prior ) + <str> + str ( adaptivep0 ) + <str> . format ( tol ) pMB_out_fn = <str> + velrangestring + <str> + str ( gausssmooth_prior ) + <str> + str ( adaptivep0 ) + <str> . format ( tol )  else :                  if sampletype is <str> :                      print ( <str> ) if useprior is <str> :                          psiMB_out_fn = <str> + useprior + <str> + velrangestring + <str> + str ( gausssmooth_prior ) + <str> + str ( adaptivep0 ) + <str> + str ( deltafuncprior ) + <str> + str ( baseprioramp ) + <str> pMB_out_fn = <str> + useprior + <str> + velrangestring + <str> + str ( gausssmooth_prior ) + <str> + str ( adaptivep0 ) + <str> + str ( deltafuncprior ) + <str> + str ( baseprioramp ) + <str>  elif useprior is <str> :                          psiMB_out_fn = <str> + useprior + <str> + velrangestring + <str> + str ( smoothprior ) + <str> + str ( sig ) + <str> + str ( adaptivep0 ) + <str> + str ( fixwidth ) + <str> pMB_out_fn = <str> + useprior + <str> + velrangestring + <str> + str ( smoothprior ) + <str> + str ( sig ) + <str> + str ( adaptivep0 ) + <str> + str ( fixwidth ) + <str>   elif sampletype is <str> :                      psiMB_out_fn = <str> + velrangestring + <str> + str ( gausssmooth_prior ) + <str> + str ( adaptivep0 ) + <str> + str ( baseprioramp ) + <str> pMB_out_fn = <str> + velrangestring + <str> + str ( gausssmooth_prior ) + <str> + str ( adaptivep0 ) + <str> + str ( baseprioramp ) + <str>   if testpsiproj is True :                  psiMB_out_fn = <str> + velrangestring + <str> + str ( gausssmooth_prior ) + <str> + str ( adaptivep0 ) + <str> + str ( deltafuncprior ) + <str> + str ( testpsiproj ) + <str> pMB_out_fn = <str> + velrangestring + <str> + str ( gausssmooth_prior ) + <str> + str ( adaptivep0 ) + <str> + str ( deltafuncprior ) + <str> + str ( testpsiproj ) + <str>   if save :              hp . fitsfunc . write_map ( out_root + psiMB_out_fn , hp_psiMB , coord = <str> , nest = True ) hp . fitsfunc . write_map ( out_root + pMB_out_fn , hp_pMB , coord = <str> , nest = True )   else :          all_maxrhts , zzz = sample_all_rht_points ( all_ids , adaptivep0 = adaptivep0 , rht_cursor = rht_cursor , region = region , useprior = useprior , gausssmooth_prior = gausssmooth_prior , tol = tol , sampletype = sampletype , mcmc = mcmc , deltafuncprior = deltafuncprior , testpsiproj = testpsiproj , testthetas = testthetas ) maxrhts = make_hp_map ( all_maxrhts , all_ids , Nside = 2048 , nest = True ) hp . fitsfunc . write_map ( out_root + <str> + velrangestring + <str> , maxrhts , coord = <str> , nest = True )   def fully_sample_planck_sky ( region = <str> , adaptivep0 = True , limitregion = False , local = False , verbose = False , tol = 1E-5 , sampletype = <str> , testproj = False ) :      if region == <str> :          Npix = hp . pixelfunc . nside2npix ( 2048 ) all_ids = [ ( i_ , ) for i_ in xrange ( Npix ) ] print ( <str> . format ( Npix ) )  else :          rht_cursor , tablename = get_rht_cursor ( region = region ) all_ids = get_all_rht_ids ( rht_cursor , tablename )  planck_tqu_db = sqlite3 . connect ( <str> ) planck_tqu_cursor = planck_tqu_db . cursor ( ) planck_cov_db = sqlite3 . connect ( <str> ) planck_cov_cursor = planck_cov_db . cursor ( ) if limitregion is True :          print ( <str> ) all_ids_SC = pickle . load ( open ( <str> , <str> ) ) all_ids = list ( set ( all_ids ) . intersection ( all_ids_SC ) )  print ( <str> ) all_pMB , all_psiMB = sample_all_planck_points ( all_ids , adaptivep0 = adaptivep0 , planck_tqu_cursor = planck_tqu_cursor , planck_cov_cursor = planck_cov_cursor , region = <str> , verbose = verbose , tol = tol , sampletype = sampletype , testproj = testproj ) hp_psiMB = make_hp_map ( all_psiMB , all_ids , Nside = 2048 , nest = True ) hp_pMB = make_hp_map ( all_pMB , all_ids , Nside = 2048 , nest = True ) if local is True :          out_root = <str>  else :          out_root = <str>  if limitregion is False :          if region == <str> :              psiMB_out_fn = <str> + str ( adaptivep0 ) + <str> pMB_out_fn = <str> + str ( adaptivep0 ) + <str>  else :              psiMB_out_fn = <str> + str ( adaptivep0 ) + <str> pMB_out_fn = <str> + str ( adaptivep0 ) + <str>   elif limitregion is True :          if sampletype is <str> :              print ( <str> ) psiMB_out_fn = <str> + str ( adaptivep0 ) + <str> pMB_out_fn = <str> + str ( adaptivep0 ) + <str>  elif sampletype is <str> :              psiMB_out_fn = <str> + str ( adaptivep0 ) + <str> pMB_out_fn = <str> + str ( adaptivep0 ) + <str>   if testproj :          print ( <str> ) psiMB_out_fn = <str> pMB_out_fn = <str>  test = False if test is False :          hp . fitsfunc . write_map ( out_root + psiMB_out_fn , hp_psiMB , coord = <str> , nest = True ) hp . fitsfunc . write_map ( out_root + pMB_out_fn , hp_pMB , coord = <str> , nest = True )   def gauss_sample_sky ( region = <str> , useprior = <str> ) :      QRHT_cursor , URHT_cursor , sig_QRHT_cursor , sig_URHT_cursor = get_rht_QU_cursors ( ) all_ids_QRHT = get_all_rht_ids ( QRHT_cursor , <str> ) all_ids_URHT = get_all_rht_ids ( URHT_cursor , <str> ) all_ids_QRHTsq = get_all_rht_ids ( sig_QRHT_cursor , <str> ) all_ids_URHTsq = get_all_rht_ids ( sig_URHT_cursor , <str> ) all_ids = list ( set ( all_ids_QRHT ) . intersection ( all_ids_URHT ) . intersection ( all_ids_QRHTsq ) . intersection ( all_ids_URHTsq ) ) all_pMB , all_psiMB = sample_all_rht_points_ThetaRHTPrior ( all_ids , region = region , useprior = useprior ) hp_psiMB = make_hp_map ( all_psiMB , all_ids , Nside = 2048 , nest = True ) hp_pMB = make_hp_map ( all_pMB , all_ids , Nside = 2048 , nest = True ) out_root = <str> hp . fitsfunc . write_map ( out_root + <str> , hp_psiMB , coord = <str> , nest = True ) hp . fitsfunc . write_map ( out_root + <str> , hp_pMB , coord = <str> , nest = True )  def gauss_sample_region ( region = <str> , useprior = <str> , local = True ) :      QRHT_cursor , URHT_cursor , sig_QRHT_cursor , sig_URHT_cursor = get_rht_QU_cursors ( local = local ) all_ids_QRHT = get_all_rht_ids ( QRHT_cursor , <str> ) all_ids_URHT = get_all_rht_ids ( URHT_cursor , <str> ) all_ids_QRHTsq = get_all_rht_ids ( sig_QRHT_cursor , <str> ) all_ids_URHTsq = get_all_rht_ids ( sig_URHT_cursor , <str> ) all_ids = list ( set ( all_ids_QRHT ) . intersection ( all_ids_URHT ) . intersection ( all_ids_QRHTsq ) . intersection ( all_ids_URHTsq ) ) all_ids_SC = pickle . load ( open ( <str> , <str> ) ) all_ids_set = list ( set ( all_ids ) . intersection ( all_ids_SC ) ) all_pMB , all_psiMB = sample_all_rht_points_ThetaRHTPrior ( all_ids_set , region = region , useprior = useprior , local = local ) hp_psiMB = make_hp_map ( all_psiMB , all_ids_set , Nside = 2048 , nest = True ) hp_pMB = make_hp_map ( all_pMB , all_ids_set , Nside = 2048 , nest = True ) if local is True :          out_root = <str>  else :          out_root = <str>  hp . fitsfunc . write_map ( out_root + <str> , hp_psiMB , coord = <str> , nest = True ) hp . fitsfunc . write_map ( out_root + <str> , hp_pMB , coord = <str> , nest = True )  def map_all_sig_p ( limitregion = False , region = <str> ) :      rht_cursor , tablename = get_rht_cursor ( region = region ) all_ids = get_all_rht_ids ( rht_cursor , tablename ) planck_tqu_db = sqlite3 . connect ( <str> ) planck_tqu_cursor = planck_tqu_db . cursor ( ) planck_cov_db = sqlite3 . connect ( <str> ) planck_cov_cursor = planck_cov_db . cursor ( ) if limitregion is True :          print ( <str> ) all_ids_SC = pickle . load ( open ( <str> , <str> ) ) all_ids = list ( set ( all_ids ) . intersection ( all_ids_SC ) )  all_sigpGsq = np . zeros ( len ( all_ids ) ) update_progress ( 0.0 ) for i , hp_index in enumerate ( all_ids ) :          ( hp_index , T , Q , U ) = planck_tqu_cursor . execute ( <str> , hp_index ) . fetchone ( ) ( hp_index , TT , TQ , TU , TQa , QQ , QU , TUa , QUa , UU ) = planck_cov_cursor . execute ( <str> , ( hp_index , ) ) . fetchone ( ) sigma_p = np . zeros ( ( 2 , 2 ) , np . float_ ) sigma_p [ 0 , 0 ] = ( 1.0 / T ** 2 ) * QQ sigma_p [ 0 , 1 ] = ( 1.0 / T ** 2 ) * QU sigma_p [ 1 , 0 ] = ( 1.0 / T ** 2 ) * QU sigma_p [ 1 , 1 ] = ( 1.0 / T ** 2 ) * UU det_sigma_p = np . linalg . det ( sigma_p ) sigpGsq = np . sqrt ( det_sigma_p ) all_sigpGsq [ i ] = sigpGsq update_progress ( ( i + 1.0 ) / len ( all_ids ) , message = <str> , final_message = <str> )  hp_sigpGsq = make_hp_map ( all_sigpGsq , all_ids , Nside = 2048 , nest = True ) out_root = <str> if limitregion :          hp . fitsfunc . write_map ( out_root + <str> , hp_sigpGsq , coord = <str> , nest = True )  else :          hp . fitsfunc . write_map ( out_root + <str> , hp_sigpGsq , coord = <str> , nest = True )   def make_hp_map ( data , hp_indices , Nside = 2048 , nest = True ) :      print ( <str> . format ( len ( hp_indices ) ) ) hp_indices = np . array ( hp_indices ) print ( <str> . format ( hp_indices . shape ) ) hp_indices = np . squeeze ( hp_indices ) Npix = 12 * Nside ** 2 map_data = np . zeros ( Npix , np . float_ ) map_data [ hp_indices ] = data return map_data  def sampled_data_to_hp ( psiMB , pMB , hp_indices , nest = True ) :      hp_psiMB = make_hp_map ( psiMB , hp_indices , Nside = 2048 , nest = nest ) hp_pMB = make_hp_map ( pMB , hp_indices , Nside = 2048 , nest = nest ) out_root = <str> hp . fitsfunc . write_map ( out_root + <str> , hp_psiMB , coord = <str> , nest = nest ) hp . fitsfunc . write_map ( out_root + <str> , hp_pMB , coord = <str> , nest = nest )  def angle_residual ( ang1 , ang2 , degrees = True ) :      if degrees is True :          ang1 = np . radians ( ang1 ) ang2 = np . radians ( ang2 )  dang_num = ( np . sin ( 2 * ang1 ) * np . cos ( 2 * ang2 ) - np . cos ( 2 * ang1 ) * np . sin ( 2 * ang2 ) ) dang_denom = ( np . cos ( 2 * ang1 ) * np . cos ( 2 * ang2 ) + np . sin ( 2 * ang1 ) * np . sin ( 2 * ang2 ) ) dang = 0.5 * np . arctan2 ( dang_num , dang_denom ) if degrees is True :          dang = np . degrees ( dang )  return dang  def update_progress ( progress , message = <str> , final_message = <str> ) :      if not 0.0 <= progress <= 1.0 :          raise ValueError ( <str> )  global start_time global stop_time if 0.0 == progress :          start_time = time . time ( ) stop_time = None return  elif stop_time is None :          stop_time = start_time + ( time . time ( ) - start_time ) / progress  elif np . random . rand ( ) > 0.98 :          stop_time = start_time + ( time . time ( ) - start_time ) / progress  sec_remaining = int ( stop_time - time . time ( ) ) if sec_remaining >= 60 :          time_message = <str> + str ( sec_remaining // 60 + 1 ) + <str>  else :          time_message = <str> + str ( sec_remaining + 1 ) + <str>  TEXTWIDTH = 70 length = int ( 0.55 * TEXTWIDTH ) messlen = TEXTWIDTH - ( length + 3 ) - len ( time_message ) message = string . ljust ( message , messlen ) [ : messlen ] p = int ( length * progress / 1.0 ) sys . stdout . write ( <str> . format ( <str> * p , <str> * ( length - p ) , message , time_message ) ) sys . stdout . flush ( ) if p == length :          total = int ( time . time ( ) - start_time ) if total > 60 :              time_message = <str> + str ( total // 60 ) + <str>  else :              time_message = <str> + str ( total ) + <str>  final_offset = TEXTWIDTH - len ( time_message ) final_message = string . ljust ( final_message , final_offset ) [ : final_offset ] sys . stdout . write ( <str> . format ( final_message , time_message ) ) sys . stdout . flush ( ) start_time = None stop_time = None print ( <str> )   if __name__ == <str> :      import astropy import healpy print ( astropy . __version__ , healpy . __version__ ) fully_sample_sky ( region = <str> , limitregion = True , adaptivep0 = True , useprior = <str> , velrangestring = <str> , gausssmooth_prior = False , tol = 0 , sampletype = <str> , mcmc = False , testpsiproj = False , testthetas = False , save = True , baseprioramp = 0 )   