from __future__ import division , print_function import numpy as np import healpy as hp from numpy . linalg import lapack_lite import time import matplotlib . pyplot as plt from astropy . io import fits import cPickle as pickle import itertools import string import sqlite3 from mpl_toolkits . axes_grid1 import make_axes_locatable import matplotlib as mpl import matplotlib . ticker as ticker import copy import os import debias import rht_to_planck import sys sys . path . insert ( 0 , <str> ) import RHT_tools import galfa_name_lookup def plot_p ( tp ) :      fig = plt . figure ( ) ax1 = fig . add_subplot ( 111 ) ax_posterior ( ax1 , tp . sample_p0 , tp . sample_psi0 , tp . normed_posterior )  def ax_posterior ( ax , p0s , psi0s , B2D , cmap = <str> , colorbar = False ) :      obj = ax . pcolor ( p0s , psi0s , B2D , cmap = cmap ) maxval = np . nanmax ( B2D ) levels = np . asarray ( [ 0.001 , 0.01 , 0.05 , 0.1 , 0.2 , 0.5 , 0.7 , 0.9 ] ) * maxval obj = ax . contour ( p0s , psi0s , B2D , levels , extend = <str> , colors = <str> ) ax . set_xlim ( np . nanmin ( p0s ) , np . nanmax ( p0s ) ) ax . set_ylim ( np . nanmin ( psi0s ) , np . nanmax ( psi0s ) ) ax . set_xlabel ( <str> , size = 15 ) ax . set_ylabel ( <str> , size = 15 ) if colorbar == True :          plt . colorbar ( obj )   def plot_randomsample_posteriors ( pmeas , psimeas , p0s , psi0s , posteriors , cmap = <str> , overplotmeas = True , sigpGsq = None ) :      nposts , lpostssq = posteriors . shape lposts = np . round ( np . sqrt ( lpostssq ) ) fig = plt . figure ( figsize = ( 12 , 10 ) , facecolor = <str> ) for i in xrange ( 9 ) :          indx = np . random . randint ( nposts ) ax = fig . add_subplot ( 3 , 3 , i ) ax_posterior ( ax , p0s , psi0s , posteriors [ indx , : ] . reshape ( lposts , lposts ) , cmap = cmap ) if overplotmeas == True :              ax . plot ( [ pmeas [ indx ] , pmeas [ indx ] ] , [ 0 , np . pi ] , <str> , color = <str> , lw = 1 ) ax . plot ( [ 0 , 1 ] , [ psimeas [ indx ] , psimeas [ indx ] ] , <str> , color = <str> , lw = 1 )  if sigpGsq != None :              ax . set_title ( <str> + str ( indx ) + <str> + str ( np . round ( pmeas [ indx ] / np . sqrt ( sigpGsq [ indx ] ) , 1 ) ) + <str> , size = 15 )   plt . subplots_adjust ( hspace = 0.5 , wspace = 0.5 )  def plot_test_posteriors ( pmeas , psimeas , p0s , psi0s , posteriors , cmap = <str> , overplotmeas = True , sigpGsq = None , rollax = True ) :      nposts , lpostssq = posteriors . shape lposts = np . round ( np . sqrt ( lpostssq ) ) psi0s_rolled = psi0s - np . pi / 2.0 fig = plt . figure ( figsize = ( 12 , 10 ) , facecolor = <str> ) for i in xrange ( 20 ) :          ax = fig . add_subplot ( 4 , 5 , i + 1 ) post = posteriors [ i , : ] . reshape ( lposts , lposts ) if rollax == True :              post = np . roll ( post , np . int ( lposts / 2.0 ) , axis = 0 ) psi0s = psi0s_rolled  ax_posterior ( ax , p0s , psi0s , post , cmap = cmap ) if overplotmeas == True :              if rollax == True :                  ax . plot ( [ pmeas [ i ] , pmeas [ i ] ] , [ - np . pi / 2.0 , np . pi / 2.0 ] , <str> , color = <str> , lw = 1 )  else :                  ax . plot ( [ pmeas [ i ] , pmeas [ i ] ] , [ 0 , np . pi ] , <str> , color = <str> , lw = 1 )  ax . plot ( [ 0 , 1 ] , [ psimeas [ i ] , psimeas [ i ] ] , <str> , color = <str> , lw = 1 )  if sigpGsq != None :              ax . set_title ( <str> + str ( np . round ( pmeas [ i ] / sigpGsq [ i ] , 1 ) ) + <str> , size = 15 )  if i >= 10 :              ax . set_xlim ( 0 , 0.8 )  if i >= 15 :              ax . set_xlim ( 0 , 0.2 )  plt . yticks ( [ - np . pi / 2 , - np . pi / 4 , 0 , np . pi / 4 , np . pi / 2 ] , [ <str> , <str> , <str> , <str> , <str> ] ) plt . tick_params ( axis = <str> , which = <str> , labelsize = 10 )  plt . subplots_adjust ( hspace = 0.5 , wspace = 0.5 )  def eps_from_cov ( covmat , twoD = False ) :      if twoD == True :          eps = np . sqrt ( covmat [ 0 , 0 ] / covmat [ 1 , 1 ] )  else :          eps = np . sqrt ( covmat [ 1 , 1 ] / covmat [ 2 , 2 ] )  return eps  def rho_from_cov ( covmat , twoD = False ) :      if twoD == True :          rho = covmat [ 0 , 1 ] / ( np . sqrt ( covmat [ 1 , 1 ] ) * np . sqrt ( covmat [ 0 , 0 ] ) )  else :          rho = covmat [ 1 , 2 ] / ( np . sqrt ( covmat [ 2 , 2 ] ) * np . sqrt ( covmat [ 1 , 1 ] ) )  return rho  def get_Planck_data ( Nside = 2048 ) :      full_planck_fn = <str> + str ( Nside ) + <str> Npix = 12 * Nside ** 2 map353Gal = np . zeros ( ( 3 , Npix ) ) cov353Gal = np . zeros ( ( 3 , 3 , Npix ) ) map353Gal [ 0 ] , map353Gal [ 1 ] , map353Gal [ 2 ] , cov353Gal [ 0 , 0 ] , cov353Gal [ 0 , 1 ] , cov353Gal [ 0 , 2 ] , cov353Gal [ 1 , 1 ] , cov353Gal [ 1 , 2 ] , cov353Gal [ 2 , 2 ] , header353Gal = hp . fitsfunc . read_map ( full_planck_fn , field = ( 0 , 1 , 2 , 4 , 5 , 6 , 7 , 8 , 9 ) , h = True ) return map353Gal , cov353Gal  def test_posteriors ( ) :      Ncov = 5 eps = np . asarray ( [ 1.0 , 0.5 , 2.0 , 1.0 , 1.0 ] ) rho = np . asarray ( [ 0 , 0 , 0 , - 0.5 , 0.5 ] ) psimeas = np . repeat ( 0.0 , Ncov ) pmeas = np . repeat ( 0.1 , Ncov ) snrs = np . asarray ( [ 0.1 , 0.5 , 1.0 , 5.0 ] ) snrs = snrs . reshape ( len ( snrs ) , 1 ) sig_pG = ( pmeas . reshape ( 1 , Ncov ) / snrs ) . flatten ( ) pmeas = np . repeat ( pmeas , len ( snrs ) ) . flatten ( ) psimeas = np . repeat ( psimeas , len ( snrs ) ) . flatten ( ) eps = np . tile ( eps , len ( snrs ) ) . flatten ( ) rho = np . tile ( rho , len ( snrs ) ) . flatten ( ) snrs = np . repeat ( snrs , Ncov , axis = 1 ) . flatten ( ) Nex = len ( snrs ) covmatrix = np . zeros ( ( 2 , 2 , Nex ) , np . float_ ) for i in xrange ( Nex ) :          covmatrix [ 0 , 0 , i ] = ( sig_pG [ i ] ** 2 / np . sqrt ( 1 - rho [ i ] ** 2 ) ) * eps [ i ] covmatrix [ 0 , 1 , i ] = ( sig_pG [ i ] ** 2 / np . sqrt ( 1 - rho [ i ] ** 2 ) ) * rho [ i ] covmatrix [ 1 , 0 , i ] = ( sig_pG [ i ] ** 2 / np . sqrt ( 1 - rho [ i ] ** 2 ) ) * rho [ i ] covmatrix [ 1 , 1 , i ] = ( sig_pG [ i ] ** 2 / np . sqrt ( 1 - rho [ i ] ** 2 ) ) * 1.0 / eps [ i ]  invsig = np . linalg . inv ( covmatrix . swapaxes ( 0 , 2 ) ) print ( <str> ) nsample = 100 psi0_all = np . linspace ( 0 , np . pi , nsample ) p0_all = np . linspace ( 0 , 1.0 , nsample ) p0_psi0_grid = np . asarray ( np . meshgrid ( p0_all , psi0_all ) ) p0_psi0_pairs = zip ( p0_psi0_grid [ 0 , ... ] . ravel ( ) , p0_psi0_grid [ 1 , ... ] . ravel ( ) ) print ( <str> ) time0 = time . time ( ) out = np . zeros ( ( Nex , nsample * nsample ) , np . float_ ) rharr = np . zeros ( ( 2 , 1 ) , np . float_ ) lharr = np . zeros ( ( 1 , 2 ) , np . float_ ) for p , isig in enumerate ( invsig ) :          for ( i , ( p0 , psi0 ) ) in enumerate ( p0_psi0_pairs ) :              rharr [ 0 , 0 ] = pmeas [ p ] * np . cos ( 2 * psimeas [ p ] ) - p0 * np . cos ( 2 * psi0 ) rharr [ 1 , 0 ] = pmeas [ p ] * np . sin ( 2 * psimeas [ p ] ) - p0 * np . sin ( 2 * psi0 ) lharr = rharr . T out [ p , i ] = ( 1 / ( np . pi * np . sqrt ( sig_pG [ p ] ) ) ) * np . exp ( - 0.5 * np . dot ( lharr , np . dot ( isig , rharr ) ) )   time1 = time . time ( ) print ( <str> , time1 - time0 , <str> ) plot_test_posteriors ( pmeas , psimeas , p0_all , psi0_all , out , cmap = <str> ) return out , covmatrix  def Planck_posteriors ( map353Gal = None , cov353Gal = None , firstnpoints = 1000 , plotrandomsample = True ) :      Nside = 2048 Npix = 12 * Nside ** 2 if map353Gal == None :          map353Gal , cov353Gal = get_Planck_data ( Nside = Nside )  sigma_p = np . zeros ( ( 2 , 2 , Npix ) ) sigma_p [ 0 , 0 , : ] = ( 1.0 / map353Gal [ 0 , : ] ** 2 ) * cov353Gal [ 1 , 1 , : ] sigma_p [ 0 , 1 , : ] = ( 1.0 / map353Gal [ 0 , : ] ** 2 ) * cov353Gal [ 1 , 2 , : ] sigma_p [ 1 , 0 , : ] = ( 1.0 / map353Gal [ 0 , : ] ** 2 ) * cov353Gal [ 1 , 2 , : ] sigma_p [ 1 , 1 , : ] = ( 1.0 / map353Gal [ 0 , : ] ** 2 ) * cov353Gal [ 2 , 2 , : ] det_sigma_p = np . linalg . det ( sigma_p . swapaxes ( 0 , 2 ) ) sigpGsq = np . sqrt ( det_sigma_p ) psimeas = np . mod ( 0.5 * np . arctan2 ( map353Gal [ 2 , : ] , map353Gal [ 1 , : ] ) , np . pi ) pmeas = np . sqrt ( map353Gal [ 1 , : ] ** 2 + map353Gal [ 2 , : ] ** 2 ) / map353Gal [ 0 , : ] if firstnpoints != None :          Npix = firstnpoints  sigma_p = sigma_p [ : , : , 0 : Npix ] invsig = np . linalg . inv ( sigma_p . swapaxes ( 0 , 2 ) ) print ( <str> ) nsample = 100 psi0_all = np . linspace ( 0 , np . pi , nsample ) p0_all = np . linspace ( 0 , 1.0 , nsample ) p0_psi0_grid = np . asarray ( np . meshgrid ( p0_all , psi0_all ) ) print ( <str> ) time0 = time . time ( ) outfast = np . zeros ( ( Npix , nsample * nsample ) , np . float_ ) measpart0 = pmeas * np . cos ( 2 * psimeas ) measpart1 = pmeas * np . sin ( 2 * psimeas ) p0pairs = p0_psi0_grid [ 0 , ... ] . ravel ( ) psi0pairs = p0_psi0_grid [ 1 , ... ] . ravel ( ) truepart0 = p0pairs * np . cos ( 2 * psi0pairs ) truepart1 = p0pairs * np . sin ( 2 * psi0pairs ) rharrbig = np . zeros ( ( 2 , 1 , nsample * nsample ) , np . float_ ) lharrbig = np . zeros ( ( 1 , 2 , nsample * nsample ) , np . float_ ) print ( <str> ) for i in xrange ( Npix ) :          rharrbig [ 0 , 0 , : ] = measpart0 [ i ] - truepart0 rharrbig [ 1 , 0 , : ] = measpart1 [ i ] - truepart1 lharrbig [ 0 , 0 , : ] = measpart0 [ i ] - truepart0 lharrbig [ 0 , 1 , : ] = measpart1 [ i ] - truepart1 outfast [ i , : ] = ( 1 / ( np . pi * sigpGsq [ i ] ) ) * np . exp ( - 0.5 * np . einsum ( <str> , lharrbig , np . einsum ( <str> , invsig [ i , : , : ] , rharrbig ) ) )  time1 = time . time ( ) print ( <str> , time1 - time0 , <str> ) if plotrandomsample == True :          plot_randomsample_posteriors ( pmeas , psimeas , p0_all , psi0_all , outfast , cmap = <str> , overplotmeas = True , sigpGsq = sigpGsq )  return outfast , rharrbig , lharrbig , sigpGsq , invsig , i  def project_angles ( firstnpoints = 1000 ) :      zero_thetas = fits . getdata ( <str> ) thets = RHT_tools . get_thets ( 75 ) if firstnpoints > 0 :          Npix = firstnpoints  else :          Nside = 2048 Npix = 12 * Nside ** 2  thets_EquinGal = np . mod ( np . asarray ( zero_thetas [ : Npix ] ) . reshape ( Npix , 1 ) . astype ( np . float_ ) - thets , np . pi ) return thets_EquinGal  def project_angle0_db ( wlen = 75 , nest = True ) :      zero_thetas = hp . fitsfunc . read_map ( <str> , nest = False ) Nside = 2048 Npix = 12 * Nside ** 2 if nest :          zero_thetas = hp . pixelfunc . reorder ( zero_thetas , r2n = True )  tablename = <str> + str ( wlen ) createstatement = <str> + tablename + <str> if nest :          conn = sqlite3 . connect ( <str> )  else :          conn = sqlite3 . connect ( <str> )  c = conn . cursor ( ) c . execute ( createstatement ) conn . commit ( ) insertstatement = <str> + tablename + <str> for _hp_index in xrange ( Npix ) :          c . execute ( insertstatement , [ _hp_index , zero_thetas [ _hp_index ] ] )  conn . commit ( ) return c  def add_hthets ( data1 , data2 ) :      for key in data2 . keys ( ) :          try :              data1 [ key ] += data2 [ key ]  except KeyError :              data1 [ key ] = data2 [ key ]   return data1  def store_weights_as_dict ( ) :      projected_root = <str> projected_data_dictionary_fn = projected_root + <str> Nside = 2048 Npix = 12 * Nside ** 2 hp_index = np . arange ( Npix ) nthets = 165 total_weights = { } for _thetabin_i in xrange ( 1 ) :          time0 = time . time ( ) projected_fn = projected_root + <str> + str ( _thetabin_i ) + <str> projdata = fits . getdata ( projected_fn ) projdata [ projdata == - 999 ] = 0 nonzero_index = np . nonzero ( projdata ) [ 0 ] print ( <str> . format ( len ( nonzero_index ) ) ) rht_weights = np . zeros ( ( len ( nonzero_index ) , nthets ) , np . float_ ) rht_weights [ : , _thetabin_i ] = projdata [ nonzero_index ] indexed_weights = dict ( zip ( nonzero_index , rht_weights ) ) total_weights = add_hthets ( total_weights , indexed_weights ) time1 = time . time ( ) print ( <str> . format ( _thetabin_i , time1 - time0 ) )  pickle . dump ( total_weights , open ( projected_data_dictionary_fn , <str> ) )  def plasz_P_to_database ( Nside = 2048 ) :      Npix = 12 * Nside ** 2 usedata = np . zeros ( ( 2 , Npix ) , np . float_ ) data_root = <str> usedata [ 0 , : ] = hp . fitsfunc . read_map ( data_root + <str> ) usedata [ 1 , : ] = hp . fitsfunc . read_map ( data_root + <str> ) usedata_nest = hp . pixelfunc . reorder ( usedata , r2n = True ) tablename = <str> value_names = [ <str> , <str> ] createstatement = <str> + tablename + <str> conn = sqlite3 . connect ( <str> ) c = conn . cursor ( ) c . execute ( createstatement ) conn . commit ( ) insertstatement = <str> + tablename + <str> print ( <str> ) for _hp_index in xrange ( Npix ) :          c . execute ( insertstatement , [ i for i in itertools . chain ( [ _hp_index ] , usedata [ : , _hp_index ] ) ] )  conn . commit ( )  def QU_RHT_Gal_to_database ( sigma = 30 , smooth = True ) :      Nside = 2048 Npix = 12 * Nside ** 2 if smooth is True :          tqu_Gal_fn = <str> + str ( sigma ) + <str> tqu_sq_Gal_fn = <str> + str ( sigma ) + <str>  else :          tqu_Gal_fn = <str> tqu_sq_Gal_fn = <str>  TRHTGal_ring , QRHTGal_ring , URHTGal_ring = hp . fitsfunc . read_map ( tqu_Gal_fn , field = ( 0 , 1 , 2 ) ) TRHTsqGal_ring , QRHTsqGal_ring , URHTsqGal_ring = hp . fitsfunc . read_map ( tqu_sq_Gal_fn , field = ( 0 , 1 , 2 ) ) usedata = np . zeros ( ( 4 , Npix ) , np . float_ ) TRHTGal = hp . pixelfunc . reorder ( TRHTGal_ring , r2n = True ) usedata [ 0 , : ] = hp . pixelfunc . reorder ( QRHTGal_ring , r2n = True ) usedata [ 1 , : ] = hp . pixelfunc . reorder ( URHTGal_ring , r2n = True ) usedata [ 2 , : ] = hp . pixelfunc . reorder ( QRHTsqGal_ring , r2n = True ) usedata [ 3 , : ] = hp . pixelfunc . reorder ( URHTsqGal_ring , r2n = True ) Tmask = copy . copy ( TRHTGal ) Tmask [ np . where ( TRHTGal >= 0.5 ) ] = 1 Tmask [ np . where ( TRHTGal < 0.5 ) ] = 0 nonzero_index = np . nonzero ( Tmask ) [ 0 ] print ( <str> . format ( len ( nonzero_index ) ) ) if smooth is True :          tablename = <str> + str ( sigma )  else :          tablename = <str>  value_names = [ <str> , <str> , <str> , <str> ] column_names = <str> . join ( value_names ) createstatement = <str> + tablename + <str> + column_names + <str> numvalues = 5 insertstatement = <str> + tablename + <str> + <str> . join ( <str> * numvalues ) + <str> if smooth is True :          conn = sqlite3 . connect ( <str> + str ( sigma ) + <str> )  else :          conn = sqlite3 . connect ( <str> )  c = conn . cursor ( ) c . execute ( createstatement ) conn . commit ( ) print ( <str> ) for _hp_index in nonzero_index :          c . execute ( insertstatement , [ i for i in itertools . chain ( [ _hp_index ] , usedata [ : , _hp_index ] ) ] )  conn . commit ( )  def planck_data_to_database ( Nside = 2048 , covdata = True ) :      map353Gal , cov353Gal = get_Planck_data ( Nside = Nside ) Npix = 12 * Nside ** 2 if covdata is True :          usedata = np . asarray ( cov353Gal ) usedata = usedata . reshape ( 9 , Npix ) usedata = hp . pixelfunc . reorder ( usedata , r2n = True ) usedata = np . asarray ( usedata )  else :          usedata = hp . pixelfunc . reorder ( map353Gal , r2n = True ) usedata = np . asarray ( usedata )  if covdata is True :          tablename = <str>  else :          tablename = <str>  if covdata is True :          value_names = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ]  else :          value_names = [ <str> , <str> , <str> ]  column_names = <str> . join ( value_names ) createstatement = <str> + tablename + <str> + column_names + <str> if covdata is True :          conn = sqlite3 . connect ( <str> )  else :          conn = sqlite3 . connect ( <str> )  c = conn . cursor ( ) c . execute ( createstatement ) conn . commit ( ) if covdata is True :          numvalues = 10  else :          numvalues = 4  insertstatement = <str> + tablename + <str> + <str> . join ( <str> * numvalues ) + <str> print ( <str> ) for _hp_index in xrange ( Npix ) :          c . execute ( insertstatement , [ i for i in itertools . chain ( [ _hp_index ] , usedata [ : , _hp_index ] ) ] )  conn . commit ( )  def project_allsky_thetaweights_to_database ( update = False ) :      unprojected_root = <str> projected_data_dictionary_fn = unprojected_root + <str> galfa_fn = <str> galfa_hdr = fits . getheader ( galfa_fn ) nthets = 165 value_names = [ <str> . join ( i ) for i in itertools . permutations ( string . lowercase , 2 ) ] if <str> in value_names : value_names . remove ( <str> ) if <str> in value_names : value_names . remove ( <str> ) if <str> in value_names : value_names . remove ( <str> ) if <str> in value_names : value_names . remove ( <str> ) column_names = <str> . join ( value_names [ : nthets ] ) tablename = <str> createstatement = <str> + tablename + <str> + column_names + <str> conn = sqlite3 . connect ( <str> ) c = conn . cursor ( ) if update is True :          print ( <str> )  else :          c . execute ( createstatement ) conn . commit ( )  for _thetabin_i in range ( 23 , nthets , 1 ) :          time0 = time . time ( ) projected_fn = unprojected_root + <str> + str ( _thetabin_i ) + <str> projdata = fits . getdata ( projected_fn ) projdata [ projdata == - 999 ] = 0 nonzero_index = np . nonzero ( projdata ) [ 0 ] print ( <str> . format ( len ( nonzero_index ) , _thetabin_i ) ) c . executemany ( <str> + tablename + <str> + value_names [ _thetabin_i ] + <str> , [ ( i , projdata [ i ] ) for i in nonzero_index ] ) c . executemany ( <str> + tablename + <str> + value_names [ _thetabin_i ] + <str> , [ ( projdata [ i ] , i ) for i in nonzero_index ] ) conn . commit ( ) time1 = time . time ( ) print ( <str> . format ( _thetabin_i , time1 - time0 ) )  conn . close ( )  def write_allsky_singlevel_thetaweights_to_database_RADEC ( update = False , velstr = <str> ) :      unprojected_root = <str> + velstr + <str> nthets = 165 value_names = [ <str> . join ( i ) for i in itertools . permutations ( string . lowercase , 2 ) ] if <str> in value_names : value_names . remove ( <str> ) if <str> in value_names : value_names . remove ( <str> ) if <str> in value_names : value_names . remove ( <str> ) if <str> in value_names : value_names . remove ( <str> ) column_names = <str> . join ( value_names [ : nthets ] ) tablename = <str> + velstr createstatement = <str> + tablename + <str> + column_names + <str> conn = sqlite3 . connect ( unprojected_root + <str> + velstr + <str> ) c = conn . cursor ( ) if update is True :          print ( <str> )  else :          c . execute ( createstatement ) conn . commit ( )  for _thetabin_i in xrange ( nthets ) :          time0 = time . time ( ) unprojected_fn = unprojected_root + <str> + velstr + <str> + str ( _thetabin_i ) + <str> unprojdata = fits . getdata ( unprojected_fn ) nonzero_index = np . nonzero ( unprojdata ) [ 0 ] print ( <str> . format ( len ( nonzero_index ) , _thetabin_i ) ) c . executemany ( <str> + tablename + <str> + value_names [ _thetabin_i ] + <str> , [ ( i , unprojdata . flat [ i ] ) for i in nonzero_index ] ) c . executemany ( <str> + tablename + <str> + value_names [ _thetabin_i ] + <str> , [ ( unprojdata . flat [ i ] , i ) for i in nonzero_index ] ) conn . commit ( ) time1 = time . time ( ) print ( <str> . format ( _thetabin_i , ( time1 - time0 ) / 60. ) )  conn . close ( )  def write_allsky_singlevel_thetaweights_to_database_RADEC_indx ( update = False , velstr = <str> ) :      unprojected_root = <str> + velstr + <str> nthets = 165 value_names = [ <str> . join ( i ) for i in itertools . permutations ( string . lowercase , 2 ) ] if <str> in value_names : value_names . remove ( <str> ) if <str> in value_names : value_names . remove ( <str> ) if <str> in value_names : value_names . remove ( <str> ) if <str> in value_names : value_names . remove ( <str> ) if <str> in value_names : value_names . remove ( <str> ) if <str> in value_names : value_names . remove ( <str> ) column_names = <str> . join ( value_names [ : nthets ] ) tablename = <str> + velstr createstatement = <str> + tablename + <str> + column_names + <str> conn = sqlite3 . connect ( unprojected_root + <str> + velstr + <str> ) c = conn . cursor ( ) if update is True :          print ( <str> )  else :          c . execute ( createstatement ) conn . commit ( )  allpix = fits . getdata ( <str> ) for _thetabin_i in xrange ( nthets ) :          time0 = time . time ( ) unprojected_fn = unprojected_root + <str> + velstr + <str> + str ( _thetabin_i ) + <str> unprojdata = fits . getdata ( unprojected_fn ) nonzero_index = np . nonzero ( unprojdata . flatten ( ) ) [ 0 ] print ( <str> . format ( len ( nonzero_index ) , _thetabin_i ) ) c . executemany ( <str> + tablename + <str> + value_names [ _thetabin_i ] + <str> , [ ( allpix . flat [ i ] , unprojdata . flat [ i ] ) for i in nonzero_index ] ) c . executemany ( <str> + tablename + <str> + value_names [ _thetabin_i ] + <str> , [ ( unprojdata . flat [ i ] , allpix . flat [ i ] ) for i in nonzero_index ] ) conn . commit ( ) time1 = time . time ( ) print ( <str> . format ( _thetabin_i , ( time1 - time0 ) / 60. ) )  conn . close ( )  def project_allsky_singlevel_thetaweights_to_database ( update = False , velstr = <str> ) :      unprojected_root = <str> + velstr + <str> galfa_hdr = fits . getheader ( <str> ) nthets = 165 value_names = [ <str> . join ( i ) for i in itertools . permutations ( string . lowercase , 2 ) ] if <str> in value_names : value_names . remove ( <str> ) if <str> in value_names : value_names . remove ( <str> ) if <str> in value_names : value_names . remove ( <str> ) if <str> in value_names : value_names . remove ( <str> ) if <str> in value_names : value_names . remove ( <str> ) if <str> in value_names : value_names . remove ( <str> ) column_names = <str> . join ( value_names [ : nthets ] ) tablename = <str> + velstr createstatement = <str> + tablename + <str> + column_names + <str> conn = sqlite3 . connect ( unprojected_root + <str> + velstr + <str> ) c = conn . cursor ( ) if update is True :          print ( <str> )  else :          c . execute ( createstatement ) conn . commit ( )  for _thetabin_i in xrange ( nthets ) :          time0 = time . time ( ) proj_fn_out = unprojected_root + <str> + <str> + velstr + <str> + str ( _thetabin_i ) + <str> if os . path . isfile ( proj_fn_out ) :              projdata = hp . fitsfunc . read_map ( proj_fn_out ) print ( <str> . format ( projdata . shape , velstr ) )  else :              unprojected_fn = unprojected_root + <str> + velstr + <str> + str ( _thetabin_i ) + <str> unprojdata = fits . getdata ( unprojected_fn ) projdata , out_hdr = rht_to_planck . interpolate_data_to_hp_galactic ( unprojdata , galfa_hdr , local = False , nonedata = None ) print ( <str> ) hp . fitsfunc . write_map ( proj_fn_out , projdata )  projdata [ projdata == - 999 ] = 0 projdata [ np . where ( np . isnan ( projdata ) == True ) ] = 0 nonzero_index = np . nonzero ( projdata ) [ 0 ] print ( <str> . format ( len ( nonzero_index ) , _thetabin_i ) ) c . executemany ( <str> + tablename + <str> + value_names [ _thetabin_i ] + <str> , [ ( i , projdata [ i ] ) for i in nonzero_index ] ) c . executemany ( <str> + tablename + <str> + value_names [ _thetabin_i ] + <str> , [ ( projdata [ i ] , i ) for i in nonzero_index ] ) conn . commit ( ) time1 = time . time ( ) print ( <str> . format ( _thetabin_i , time1 - time0 ) )  conn . close ( )  def project_hp_singlevel_singletheta_data ( velstr = <str> ) :      unprojected_root = <str> + velstr + <str> galfa_hdr = fits . getheader ( <str> ) nthets = 165 for _thetabin_i in range ( 160 , 166 , 1 ) :          print ( <str> . format ( velstr , _thetabin_i ) ) time0 = time . time ( ) proj_fn_out = unprojected_root + <str> + <str> + velstr + <str> + str ( _thetabin_i ) + <str> if os . path . isfile ( proj_fn_out ) :              print ( <str> . format ( _thetabin_i ) )  else :              print ( <str> . format ( _thetabin_i ) ) unprojected_fn = unprojected_root + <str> + velstr + <str> + str ( _thetabin_i ) + <str> unprojdata = fits . getdata ( unprojected_fn ) projdata , out_hdr = rht_to_planck . interpolate_data_to_hp_galactic ( unprojdata , galfa_hdr , local = False , nonedata = None ) print ( <str> ) hp . fitsfunc . write_map ( proj_fn_out , projdata )  time1 = time . time ( ) print ( <str> . format ( _thetabin_i , time1 - time0 ) )   def project_allsky_vel_weighted_int_thetaweights_to_database ( update = False ) :      unprojected_root = <str> galfa_hdr = fits . getheader ( <str> ) nthets = 165 value_names = [ <str> . join ( i ) for i in itertools . permutations ( string . ascii_lowercase , 2 ) ] if <str> in value_names : value_names . remove ( <str> ) if <str> in value_names : value_names . remove ( <str> ) if <str> in value_names : value_names . remove ( <str> ) if <str> in value_names : value_names . remove ( <str> ) if <str> in value_names : value_names . remove ( <str> ) if <str> in value_names : value_names . remove ( <str> ) column_names = <str> . join ( value_names [ : nthets ] ) tablename = <str> createstatement = <str> + tablename + <str> + column_names + <str> conn = sqlite3 . connect ( unprojected_root + <str> ) c = conn . cursor ( ) if update is True :          print ( <str> )  else :          c . execute ( createstatement ) conn . commit ( )  for _thetabin_i in xrange ( nthets ) :          time0 = time . time ( ) projected_fn = unprojected_root + <str> + str ( _thetabin_i ) + <str> projdata = fits . getdata ( projected_fn ) projdata [ projdata == - 999 ] = 0 projdata [ projdata < 0 ] = 0 projdata [ np . isnan ( projdata ) ] = 0 projdata [ np . where ( projdata == None ) ] = 0 nonzero_index = np . nonzero ( projdata ) [ 0 ] print ( <str> . format ( len ( nonzero_index ) , _thetabin_i ) ) c . executemany ( <str> + tablename + <str> + value_names [ _thetabin_i ] + <str> , [ ( i , projdata [ i ] ) for i in nonzero_index ] ) c . executemany ( <str> + tablename + <str> + value_names [ _thetabin_i ] + <str> , [ ( projdata [ i ] , i ) for i in nonzero_index ] ) conn . commit ( ) time1 = time . time ( ) print ( <str> . format ( _thetabin_i , time1 - time0 ) )  conn . close ( )  def intRHT_QU_maps_per_vel ( velstr = <str> ) :      unprojected_root = <str> + velstr + <str> nyfull = 2432 nxfull = 21600 intRHT = np . zeros ( ( nyfull , nxfull ) , np . float_ ) QRHT = np . zeros ( ( nyfull , nxfull ) , np . float_ ) URHT = np . zeros ( ( nyfull , nxfull ) , np . float_ ) QRHTsq = np . zeros ( ( nyfull , nxfull ) , np . float_ ) URHTsq = np . zeros ( ( nyfull , nxfull ) , np . float_ ) thets = RHT_tools . get_thets ( 75 ) thetshist = np . zeros ( len ( thets ) ) for _thetabin_i in xrange ( 165 ) :          time0 = time . time ( ) unprojected_fn = unprojected_root + <str> + velstr + <str> + str ( _thetabin_i ) + <str> unprojdata = fits . getdata ( unprojected_fn ) intRHT += unprojdata QRHT += np . cos ( 2 * thets [ _thetabin_i ] ) * unprojdata URHT += np . sin ( 2 * thets [ _thetabin_i ] ) * unprojdata QRHTsq += np . cos ( 2 * thets [ _thetabin_i ] ) ** 2 * unprojdata URHTsq += np . sin ( 2 * thets [ _thetabin_i ] ) ** 2 * unprojdata thetshist [ _thetabin_i ] = np . nansum ( unprojdata ) time1 = time . time ( ) print ( <str> . format ( _thetabin_i , time1 - time0 ) )  hdr = fits . getheader ( unprojected_fn ) fits . writeto ( unprojected_root + <str> + velstr + <str> , intRHT , hdr ) fits . writeto ( unprojected_root + <str> + velstr + <str> , QRHT , hdr ) fits . writeto ( unprojected_root + <str> + velstr + <str> , URHT , hdr ) fits . writeto ( unprojected_root + <str> + velstr + <str> , QRHTsq , hdr ) fits . writeto ( unprojected_root + <str> + velstr + <str> , URHTsq , hdr ) np . save ( unprojected_root + <str> + velstr + <str> , thetshist )  def make_single_theta_int_vel_map ( thetabin = 0 ) :      velstrs = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] in_root = <str> out_root = in_root + <str> nyfull = 2432 nxfull = 21600 single_vel_map = np . zeros ( ( nyfull , nxfull ) , np . float_ ) for _velstr in velstrs :          single_theta_fn = in_root + _velstr + <str> + _velstr + <str> + str ( thetabin ) + <str> single_vel_map += fits . getdata ( single_theta_fn ) print ( _velstr , np . nansum ( single_vel_map ) )  hdr = fits . getheader ( single_theta_fn ) fits . writeto ( out_root + <str> + str ( thetabin ) + <str> , single_vel_map )  def get_RHT_Sstr ( starting_vel ) :      start_velstr = galfa_name_lookup . get_velstr ( starting_vel ) end_velstr = galfa_name_lookup . get_velstr ( starting_vel + 4 ) Sstr = <str> + start_velstr + <str> + end_velstr return Sstr  def make_vel_int_galfa_channel_maps ( ) :      begin_vel = 1074 end_vel = 1078 nyfull = 2432 nxfull = 21600 cdelt3 = 0.736122839600 galfa_root = <str> out_root = <str> rht_starting_vels = [ begin_vel + 5 * i for i in xrange ( ( end_vel - begin_vel ) // 5 + 1 ) ] for i , _vel in enumerate ( rht_starting_vels ) :          Sstr = get_RHT_Sstr ( _vel ) sumchans = np . zeros ( ( nyfull , nxfull ) , np . float_ ) for v in np . arange ( rht_starting_vels [ i ] , rht_starting_vels [ i ] + 5 ) :              print ( v ) galfa_fn = galfa_root + galfa_name_lookup . get_galfa_W_name ( v ) sumchans += fits . getdata ( galfa_fn ) hdr = fits . getheader ( galfa_fn )  fits . writeto ( out_root + <str> + Sstr + <str> , sumchans * cdelt3 , hdr )   def make_weighted_single_theta_int_vel_map ( thetabin = 0 ) :      velstrs = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] in_root = <str> in_channel_root = <str> out_root = <str> nyfull = 2432 nxfull = 21600 single_vel_map = np . zeros ( ( nyfull , nxfull ) , np . float_ ) begin_vel = 974 end_vel = 1073 rht_starting_vels = [ begin_vel + 5 * i for i in xrange ( ( end_vel - begin_vel ) // 5 + 1 ) ] for _velstr in velstrs :          single_theta_fn = in_root + _velstr + <str> + _velstr + <str> + str ( thetabin ) + <str> single_theta_map = fits . getdata ( single_theta_fn ) velocity_channel_fn = in_channel_root + <str> + _velstr + <str> velocity_channel_map = fits . getdata ( velocity_channel_fn ) single_vel_map += single_theta_map * velocity_channel_map print ( _velstr , <str> , np . nansum ( single_vel_map ) )  hdr = fits . getheader ( velocity_channel_fn ) fits . writeto ( out_root + <str> + str ( thetabin ) + <str> , single_vel_map )  def get_extra0_sstring ( cstart , cstop ) :      if cstart <= 999 :          s_string = <str> extra_0 = <str>  else :          s_string = <str> extra_0 = <str>  if cstart == 999 :          s_string = <str> extra_0 = <str>  return s_string , extra_0  def coadd_QU_maps ( ) :      wlen = 75 cstep = 5 nyfull = 2432 nxfull = 21600 Qdata = np . zeros ( ( nyfull , nxfull ) , np . float_ ) Udata = np . zeros ( ( nyfull , nxfull ) , np . float_ ) intdata = np . zeros ( ( nyfull , nxfull ) , np . float_ ) for velnum in np . arange ( - 10 , 10 ) :          cstart = 1024 + velnum * cstep cstop = cstart + cstep - 1 s_string , extra_0 = get_extra0_sstring ( cstart , cstop ) velrangestring = s_string + str ( cstart ) + <str> + extra_0 + str ( cstop ) in_root = <str> + velrangestring + <str> Qdata += fits . getdata ( in_root + <str> + velrangestring + <str> ) Udata += fits . getdata ( in_root + <str> + velrangestring + <str> ) intdata += fits . getdata ( in_root + <str> + velrangestring + <str> )  outhdr = fits . getheader ( in_root + <str> + velrangestring + <str> ) cbegin = 1024 + - 10 * cstep cend = 1024 + 9 * cstep fits . writeto ( <str> + str ( cbegin ) + <str> + str ( cend ) + <str> , intdata , outhdr ) fits . writeto ( <str> + str ( cbegin ) + <str> + str ( cend ) + <str> , Qdata , outhdr ) fits . writeto ( <str> + str ( cbegin ) + <str> + str ( cend ) + <str> , Udata , outhdr )  def reproject_allsky_data ( local = True ) :      if local :          unprojected_root = <str>  else :          unprojected_root = <str>  nthets = 165 galfa_fn = <str> galfa_hdr = fits . getheader ( galfa_fn ) for _thetabin_i in xrange ( 1 ) :          time0 = time . time ( ) unprojected_fn = unprojected_root + <str> + str ( _thetabin_i ) + <str> unprojdata = fits . getdata ( unprojected_fn ) projdata , out_hdr = rht_to_planck . interpolate_data_to_hp_galactic ( unprojdata , galfa_hdr , nonedata = None , local = local ) print ( <str> ) projected_fn = unprojected_root + <str> + str ( _thetabin_i ) + <str> out_hdr [ <str> ] = _thetabin_i out_hdr [ <str> ] = - 10 out_hdr [ <str> ] = 10 fits . writeto ( projected_fn , projdata , out_hdr ) time1 = time . time ( ) print ( <str> . format ( _thetabin_i , time1 - time0 ) )   def reproject_allsky_weighted_data ( local = True ) :      if local :          unprojected_root = <str>  else :          unprojected_root = <str>  nthets = 165 if local :          galfa_fn = <str>  else :          galfa_fn = <str>  galfa_hdr = fits . getheader ( galfa_fn ) for _thetabin_i in np . arange ( 150 , 166 ) :          time0 = time . time ( ) unprojected_fn = unprojected_root + <str> + str ( _thetabin_i ) + <str> unprojdata = fits . getdata ( unprojected_fn ) projdata , out_hdr = rht_to_planck . interpolate_data_to_hp_galactic ( unprojdata , galfa_hdr , local = local , nonedata = None ) print ( <str> ) projected_fn = unprojected_root + <str> + str ( _thetabin_i ) + <str> out_hdr [ <str> ] = _thetabin_i out_hdr [ <str> ] = 974 out_hdr [ <str> ] = 1073 fits . writeto ( projected_fn , projdata , out_hdr ) time1 = time . time ( ) print ( <str> . format ( _thetabin_i , time1 - time0 ) )   def test_faster_db_creation ( ) :      projected_root = <str> projected_data_dictionary_fn = projected_root + <str> nthets = 165 value_names = [ <str> . join ( i ) for i in itertools . permutations ( string . lowercase , 2 ) ] if <str> in value_names : value_names . remove ( <str> ) if <str> in value_names : value_names . remove ( <str> ) column_names = <str> . join ( value_names [ : nthets ] ) tablename = <str> createstatement = <str> + tablename + <str> + column_names + <str> conn = sqlite3 . connect ( <str> ) c = conn . cursor ( ) c . execute ( createstatement ) conn . commit ( ) for _thetabin_i in xrange ( nthets ) :          time0 = time . time ( ) projected_fn = projected_root + <str> + str ( _thetabin_i ) + <str> projdata = fits . getdata ( projected_fn ) projdata [ projdata == - 999 ] = 0 nonzero_index = np . nonzero ( projdata ) [ 0 ] print ( <str> . format ( len ( nonzero_index ) ) )   def projected_thetaweights_to_database ( ) :      projected_root = <str> projected_data_dictionary_fn = projected_root + <str> nthets = 165 value_names = [ <str> . join ( i ) for i in itertools . permutations ( string . lowercase , 2 ) ] if <str> in value_names : value_names . remove ( <str> ) if <str> in value_names : value_names . remove ( <str> ) column_names = <str> . join ( value_names [ : nthets ] ) tablename = <str> createstatement = <str> + tablename + <str> + column_names + <str> conn = sqlite3 . connect ( <str> ) c = conn . cursor ( ) c . execute ( createstatement ) conn . commit ( ) for _thetabin_i in xrange ( nthets ) :          time0 = time . time ( ) projected_fn = projected_root + <str> + str ( _thetabin_i ) + <str> projdata = fits . getdata ( projected_fn ) projdata [ projdata == - 999 ] = 0 nonzero_index = np . nonzero ( projdata ) [ 0 ] print ( <str> . format ( len ( nonzero_index ) ) ) c . executemany ( <str> + tablename + <str> + value_names [ _thetabin_i ] + <str> , [ ( i , projdata [ i ] ) for i in nonzero_index ] ) c . executemany ( <str> + tablename + <str> + value_names [ _thetabin_i ] + <str> , [ ( projdata [ i ] , i ) for i in nonzero_index ] ) conn . commit ( ) time1 = time . time ( ) print ( <str> . format ( _thetabin_i , time1 - time0 ) )  conn . close ( )  def get_largest_rht_id ( rht_cursor ) :      max_id = rht_cursor . execute ( <str> ) . fetchone ( ) return max_id  def get_all_rht_ids ( rht_cursor ) :      all_ids = rht_cursor . execute ( <str> ) . fetchall ( ) return all_ids  def get_all_P_sigP_debias ( plasz_P_cursor ) :      all_Pdebias = plasz_P_cursor . execute ( <str> ) . fetchall ( ) all_Pdebiassig = plasz_P_cursor . execute ( <str> ) . fetchall ( ) return all_Pdebias , all_Pdebiassig  def SC_241_posteriors ( map353Gal = None , cov353Gal = None , firstnpoints = 1000 ) :      Nside = 2048 Npix = 12 * Nside ** 2 nsample = 165 psi0_all = np . linspace ( 0 , np . pi , nsample ) p0_all = np . linspace ( 0 , 1.0 , nsample ) planck_tqu_db = sqlite3 . connect ( <str> ) planck_tqu_cursor = planck_tqu_db . cursor ( ) planck_cov_db = sqlite3 . connect ( <str> ) planck_cov_cursor = planck_cov_db . cursor ( ) rht_db = sqlite3 . connect ( <str> ) rht_cursor = rht_db . cursor ( ) tablename = <str> return likelihood  def latex_formatter ( x , pos ) :      return <str> . format ( x )  def plot_bayesian_components ( hp_index , rht_cursor , planck_tqu_cursor , planck_cov_cursor , p0_all , psi0_all , npsample = 165 , npsisample = 165 ) :      fig = plt . figure ( figsize = ( 14 , 4 ) , facecolor = <str> ) ax1 = fig . add_subplot ( 131 ) ax2 = fig . add_subplot ( 132 ) ax3 = fig . add_subplot ( 133 ) pp = Posterior ( hp_index , rht_cursor , planck_tqu_cursor , planck_cov_cursor , p0_all , psi0_all ) cmap = <str> im1 = ax1 . imshow ( pp . planck_likelihood , cmap = cmap ) ax1 . set_title ( <str> , size = 20 ) div = make_axes_locatable ( ax1 ) cax = div . append_axes ( <str> , size = <str> , pad = 0.05 ) cbar = plt . colorbar ( im1 , cax = cax , format = ticker . FuncFormatter ( latex_formatter ) ) im2 = ax2 . imshow ( pp . normed_prior , cmap = cmap ) ax2 . set_title ( <str> , size = 20 ) div = make_axes_locatable ( ax2 ) cax = div . append_axes ( <str> , size = <str> , pad = 0.05 ) cbar = plt . colorbar ( im2 , cax = cax , format = ticker . FuncFormatter ( latex_formatter ) ) im3 = ax3 . imshow ( pp . normed_posterior , cmap = cmap ) ax3 . set_title ( <str> , size = 20 ) div = make_axes_locatable ( ax3 ) cax = div . append_axes ( <str> , size = <str> , pad = 0.05 ) cbar = plt . colorbar ( im3 , cax = cax , format = ticker . FuncFormatter ( latex_formatter ) ) axs = [ ax1 , ax2 , ax3 ] for ax in axs :          ax . set_xlabel ( <str> , size = 20 ) ax . set_ylabel ( <str> , size = 20 ) ax . set_xticks ( np . arange ( len ( p0_all ) ) [ : : 30 ] ) ax . set_xticklabels ( [ <str> . format ( p0 ) for p0 in np . round ( p0_all [ : : 20 ] , decimals = 2 ) ] ) ax . set_yticks ( np . arange ( len ( psi0_all ) ) [ : : 20 ] ) ax . set_yticklabels ( [ <str> . format ( psi0 ) for psi0 in np . round ( np . degrees ( psi0_all [ : : 20 ] ) , decimals = 2 ) ] )  plt . subplots_adjust ( wspace = 0.8 )  def plot_bayesian_components_from_posterior ( pp ) :      fig = plt . figure ( figsize = ( 14 , 4 ) , facecolor = <str> ) ax1 = fig . add_subplot ( 131 ) ax2 = fig . add_subplot ( 132 ) ax3 = fig . add_subplot ( 133 ) psi0_all = pp . sample_psi0 p0_all = pp . sample_p0 cmap = <str> im1 = ax1 . imshow ( pp . planck_likelihood , cmap = cmap ) ax1 . set_title ( <str> , size = 20 ) div = make_axes_locatable ( ax1 ) cax = div . append_axes ( <str> , size = <str> , pad = 0.05 ) cbar = plt . colorbar ( im1 , cax = cax , format = ticker . FuncFormatter ( latex_formatter ) ) im2 = ax2 . imshow ( pp . normed_prior , cmap = cmap ) ax2 . set_title ( <str> , size = 20 ) div = make_axes_locatable ( ax2 ) cax = div . append_axes ( <str> , size = <str> , pad = 0.05 ) cbar = plt . colorbar ( im2 , cax = cax , format = ticker . FuncFormatter ( latex_formatter ) ) im3 = ax3 . pcolor ( p0_all , psi0_all , pp . normed_posterior , cmap = cmap ) ax3 . set_title ( <str> , size = 20 ) div = make_axes_locatable ( ax3 ) cax = div . append_axes ( <str> , size = <str> , pad = 0.05 ) cbar = plt . colorbar ( im3 , cax = cax , format = ticker . FuncFormatter ( latex_formatter ) ) axs = [ ax1 , ax2 ] for ax in axs :          ax . set_xlabel ( <str> , size = 20 ) ax . set_ylabel ( <str> , size = 20 ) ax . set_xticks ( np . arange ( len ( p0_all ) ) [ : : 30 ] ) ax . set_xticklabels ( [ <str> . format ( p0 ) for p0 in np . round ( p0_all [ : : 20 ] , decimals = 2 ) ] ) ax . set_yticks ( np . arange ( len ( psi0_all ) ) [ : : 20 ] ) ax . set_yticklabels ( [ <str> . format ( psi0 ) for psi0 in np . round ( np . degrees ( psi0_all [ : : 20 ] ) , decimals = 2 ) ] )  plt . subplots_adjust ( wspace = 0.8 ) return ax1 , ax2 , ax3  def plot_bayesian_posterior_from_posterior ( pp , ax , cmap = <str> ) :      psi0_all = pp . sample_psi0 p0_all = pp . sample_p0 im1 = ax . pcolor ( p0_all , psi0_all , pp . normed_posterior , cmap = cmap ) ax . set_title ( <str> , size = 20 ) div = make_axes_locatable ( ax ) cax = div . append_axes ( <str> , size = <str> , pad = 0.05 ) cbar = plt . colorbar ( im1 , cax = cax , format = ticker . FuncFormatter ( latex_formatter ) ) ax . set_xlabel ( <str> , size = 20 ) ax . set_ylabel ( <str> , size = 20 )  def single_posterior ( hp_index , wlen = 75 ) :      planck_cov_db = sqlite3 . connect ( <str> ) planck_cov_cursor = planck_cov_db . cursor ( ) planck_tqu_db = sqlite3 . connect ( <str> ) planck_tqu_cursor = planck_tqu_db . cursor ( ) rht_db = sqlite3 . connect ( <str> ) rht_cursor = rht_db . cursor ( ) psi0_sample_db = sqlite3 . connect ( <str> + str ( wlen ) + <str> ) psi0_sample_cursor = psi0_sample_db . cursor ( ) zero_theta = psi0_sample_cursor . execute ( <str> , ( hp_index , ) ) . fetchone ( ) thets = RHT_tools . get_thets ( wlen ) psi0_all = np . mod ( zero_theta - thets , np . pi ) plasz_P_db = sqlite3 . connect ( <str> ) plasz_P_cursor = plasz_P_db . cursor ( ) ( Pdebias , Pdebiassig ) = plasz_P_cursor . execute ( <str> , ( hp_index , ) ) . fetchone ( ) numsig = 7 beginP = Pdebias - numsig * Pdebiassig endP = Pdebias + numsig * Pdebiassig print ( beginP , endP , Pdebias , Pdebiassig ) sample_P = np . linspace ( beginP , endP , len ( psi0_all ) ) I0 = planck_tqu_cursor . execute ( <str> , ( hp_index , ) ) . fetchone ( ) p0_all = sample_P / I0 print ( I0 ) Qmeas = planck_tqu_cursor . execute ( <str> , ( hp_index , ) ) . fetchone ( ) Umeas = planck_tqu_cursor . execute ( <str> , ( hp_index , ) ) . fetchone ( ) Pnaive = np . sqrt ( Qmeas [ 0 ] ** 2 + Umeas [ 0 ] ** 2 ) print ( <str> . format ( Pnaive / I0 ) ) print ( <str> . format ( np . mod ( 0.5 * np . arctan2 ( Umeas , Qmeas ) , np . pi ) ) ) minPnaive = Pnaive - numsig * Pdebiassig maxPnaive = Pnaive + numsig * Pdebiassig beginP = max ( ( 0.0 , minPnaive ) ) endP = min ( ( 1.0 , maxPnaive ) ) print ( beginP , endP , maxPnaive , minPnaive , Pdebiassig ) sample_P = np . linspace ( beginP , endP , len ( psi0_all ) ) p0_all_naive = sample_P / I0 posterior_naive = Posterior ( hp_index , rht_cursor , planck_tqu_cursor , planck_cov_cursor , p0_all_naive , psi0_all ) plot_bayesian_components ( hp_index , rht_cursor , planck_tqu_cursor , planck_cov_cursor , p0_all_naive , psi0_all , npsample = 165 , npsisample = 165 ) return posterior_naive , p0_all_naive , psi0_all  def center_psi_measurement ( array , sample_psi , psi_meas ) :      psi_meas_indx = np . abs ( sample_psi - np . mod ( psi_meas - np . pi / 2 , np . pi ) ) . argmin ( ) print ( psi_meas_indx , sample_psi [ psi_meas_indx ] ) rolled_sample_psi = np . roll ( sample_psi , - psi_meas_indx ) rolled_array = np . roll ( array , - psi_meas_indx , axis = 0 ) return rolled_array , rolled_sample_psi  def roll_zero_to_pi ( array , sample_psi ) :      psi_0_indx = np . abs ( sample_psi ) . argmin ( ) print ( psi_0_indx , sample_psi [ psi_0_indx ] ) rolled_sample_psi = np . roll ( sample_psi , - psi_0_indx ) rolled_array = np . roll ( array , - psi_0_indx , axis = 0 ) return rolled_array , rolled_sample_psi  def roll_RHT_zero_to_pi ( rht_data , sample_psi ) :      psi_0_indx = np . abs ( sample_psi ) . argmin ( ) print ( <str> , psi_0_indx , sample_psi [ psi_0_indx ] ) rolled_sample_psi = np . roll ( sample_psi , - psi_0_indx ) rolled_array = np . roll ( rht_data , - psi_0_indx ) return rolled_array , rolled_sample_psi  def wrap_to_pi_over_2 ( angles ) :      while np . nanmax ( angles ) > np . pi / 2 :          angles [ np . where ( angles > np . pi / 2 ) ] = angles [ np . where ( angles > np . pi / 2 ) ] - np . pi  while np . nanmin ( angles ) < - np . pi / 2 :          angles [ np . where ( angles < - np . pi / 2 ) ] = angles [ np . where ( angles < - np . pi / 2 ) ] + np . pi  return angles  def make_gaussian ( len , fwhm = 3 , center = None ) :      x = np . arange ( 0 , len , 1 , float ) y = x [ : , np . newaxis ] if center is None :          x0 = y0 = size // 2  else :          x0 = center [ 0 ] y0 = center [ 1 ]  return np . exp ( - 4 * np . log ( 2 ) * ( ( x - x0 ) ** 2 + ( y - y0 ) ** 2 ) / fwhm ** 2 )  def test_estimator_gaussians ( ) :      fig = plt . figure ( ) ax1 = fig . add_subplot ( 131 ) ax2 = fig . add_subplot ( 132 ) ax3 = fig . add_subplot ( 133 ) axs = [ ax1 , ax2 , ax3 ] fwhms = [ 3 , 8 , 15 ] for i , fwhm in enumerate ( fwhms ) :          tp , testpMB , testpsiMB , testpMB1 , testpsiMB1 , testsample_psi0 , testrolled_grid_sample_psi0 , testrolled_posterior , p0moment1 , psi0moment1 = test_estimator ( fakeit = True , fwhm = fwhm ) tp . normed_posterior , tp . sample_psi0 = roll_zero_to_pi ( tp . normed_posterior , tp . sample_psi0 ) plot_bayesian_posterior_from_posterior ( tp , axs [ i ] )  plt . subplots_adjust ( wspace = 0.8 )  def test_estimator ( fakeit = True , fwhm = 3 ) :      tp , p0_all , psi0_all = single_posterior ( 24066112 ) print ( <str> ) if fakeit is True :          test_posterior = make_gaussian ( 165 , fwhm = fwhm , center = [ 100 , 5 ] ) test_sample_psi = np . linspace ( 0 , np . pi , 165 ) test_sample_p = np . linspace ( 0 , 1 , 165 ) print ( <str> . format ( test_sample_p [ 100 ] ) ) print ( <str> . format ( test_sample_psi [ 5 ] ) ) test_sample_psi = test_sample_psi [ : : - 1 ] test_posterior = test_posterior [ : : - 1 , : ] tp . sample_p0 = test_sample_p tp . sample_psi0 = test_sample_psi tp . psi_dx = test_sample_psi [ 1 ] - test_sample_psi [ 0 ] tp . p_dx = test_sample_p [ 1 ] - test_sample_p [ 0 ] if tp . psi_dx < 0 :              tp . psi_dx *= - 1  tp . posterior = test_posterior norm_factor = tp . integrate_highest_dimension ( test_posterior , dx = tp . psi_dx ) norm_factor = tp . integrate_highest_dimension ( norm_factor , dx = tp . p_dx ) print ( <str> . format ( norm_factor ) ) tp . normed_posterior = tp . posterior / norm_factor  else :          test_sample_psi = psi0_all test_sample_p = p0_all  testpMB , testpsiMB , testpMB1 , testpsiMB1 , testsample_psi0 , testrolled_grid_sample_psi0 , testrolled_posterior , p0moment1 , psi0moment1 = mean_bayesian_posterior ( tp , sample_psi0 = test_sample_psi , sample_p0 = test_sample_p ) print ( <str> . format ( testpMB ) ) print ( <str> . format ( testpsiMB ) ) return tp , testpMB , testpsiMB , testpMB1 , testpsiMB1 , testsample_psi0 , testrolled_grid_sample_psi0 , testrolled_posterior , p0moment1 , psi0moment1  def test_normalization ( posterior_obj , pdx , psidx ) :      norm_posterior_test = posterior_obj . integrate_highest_dimension ( posterior_obj . normed_posterior , dx = psidx ) norm_posterior_test = posterior_obj . integrate_highest_dimension ( norm_posterior_test , dx = pdx ) print ( <str> . format ( norm_posterior_test ) ) return norm_posterior_test  def mean_bayesian_posterior ( posterior_obj , sample_p0 = None , sample_psi0 = None ) :      posterior = posterior_obj . normed_posterior sample_p0 = posterior_obj . sample_p0 sample_psi0 = posterior_obj . sample_psi0 grid_sample_p0 = np . tile ( sample_p0 , ( len ( sample_p0 ) , 1 ) ) grid_sample_psi0 = np . tile ( np . reshape ( sample_psi0 , ( len ( sample_psi0 ) , 1 ) ) , ( 1 , len ( sample_psi0 ) ) ) p0moment1 = grid_sample_p0 * posterior pdx = posterior_obj . p_dx psidx = posterior_obj . psi_dx norm_posterior_test = test_normalization ( posterior_obj , pdx , psidx ) if norm_posterior_test < 1.0 :          print ( <str> )  print ( <str> . format ( pdx , psidx ) ) pMB1 = np . trapz ( p0moment1 , dx = pdx , axis = 0 ) pMB = np . trapz ( pMB1 , dx = psidx ) center_psi = False if center_psi is True :          rolled_posterior , rolled_sample_psi = center_psi_measurement ( posterior , sample_psi0 , posterior_obj . naive_psi )  else :          rolled_posterior = posterior rolled_sample_psi = sample_psi0  rolled_grid_sample_psi0 = np . tile ( np . reshape ( rolled_sample_psi , ( len ( rolled_sample_psi ) , 1 ) ) , ( 1 , len ( rolled_sample_psi ) ) ) psi0moment1 = rolled_grid_sample_psi0 * rolled_posterior psiMB1 = np . trapz ( psi0moment1 , dx = pdx , axis = 0 ) psiMB = np . trapz ( psiMB1 , dx = psidx ) print ( <str> . format ( pMB ) ) print ( <str> . format ( psiMB ) ) return pMB , psiMB , pMB1 , psiMB1 , sample_psi0 , rolled_grid_sample_psi0 , rolled_posterior , p0moment1 , psi0moment1  def plot_sampled_posterior ( hp_index ) :      posterior , posterior_naive , p0_all_naive , psi0_all = single_posterior ( hp_index ) pMB , psiMB = mean_bayesian_posterior ( posterior_naive . normed_posterior , sample_psi0 = psi0_all , sample_p0 = p0_all_naive ) ax1 , ax2 , ax3 = plot_bayesian_components_from_posterior ( posterior_naive ) ax3 . plot ( pMB , np . degrees ( psiMB ) , <str> , ms = 20 , color = <str> )  class BayesianComponent ( ) :      def __init__ ( self , hp_index ) :          self . hp_index = hp_index  def integrate_highest_dimension ( self , field , dx = 1 ) :          axis_num = field . ndim - 1 integrated_field = np . trapz ( field , dx = dx , axis = axis_num ) return integrated_field   class Prior ( BayesianComponent ) :      def __init__ ( self , hp_index , c , p0_all , psi0_all , reverse_RHT = False ) :          BayesianComponent . __init__ ( self , hp_index ) self . rht_data = c . execute ( <str> , ( self . hp_index , ) ) . fetchone ( ) self . rht_data = self . rht_data [ 1 : ] self . sample_psi0 = psi0_all self . sample_p0 = p0_all self . rht_data , self . sample_psi0 = roll_RHT_zero_to_pi ( self . rht_data , self . sample_psi0 ) try :              npsample = len ( self . sample_p0 ) if reverse_RHT is True :                  print ( <str> ) self . rht_data = self . rht_data [ : : - 1 ]  self . prior = ( np . array ( [ self . rht_data ] * npsample ) . T + 0.7 ) * 75 self . psi_dx = self . sample_psi0 [ 1 ] - self . sample_psi0 [ 0 ] self . p_dx = self . sample_p0 [ 1 ] - self . sample_p0 [ 0 ] if self . psi_dx < 0 :                  self . psi_dx *= - 1  print ( <str> . format ( self . psi_dx , self . p_dx ) ) self . integrated_over_psi = self . integrate_highest_dimension ( self . prior , dx = self . psi_dx ) self . integrated_over_p_and_psi = self . integrate_highest_dimension ( self . integrated_over_psi , dx = self . p_dx ) self . normed_prior = self . prior / self . integrated_over_p_and_psi  except TypeError :              if self . rht_data is None :                  print ( <str> . format ( hp_index ) )  else :                  print ( <str> )     class Likelihood ( BayesianComponent ) :      def __init__ ( self , hp_index , planck_tqu_cursor , planck_cov_cursor , p0_all , psi0_all ) :          BayesianComponent . __init__ ( self , hp_index ) ( self . hp_index , self . T , self . Q , self . U ) = planck_tqu_cursor . execute ( <str> , ( self . hp_index , ) ) . fetchone ( ) ( self . hp_index , self . TT , self . TQ , self . TU , self . TQa , self . QQ , self . QU , self . TUa , self . QUa , self . UU ) = planck_cov_cursor . execute ( <str> , ( self . hp_index , ) ) . fetchone ( ) self . naive_psi = np . mod ( 0.5 * np . arctan2 ( self . U , self . Q ) , np . pi ) self . sigma_p = np . zeros ( ( 2 , 2 ) , np . float_ ) self . sigma_p [ 0 , 0 ] = ( 1.0 / self . T ** 2 ) * self . QQ self . sigma_p [ 0 , 1 ] = ( 1.0 / self . T ** 2 ) * self . QU self . sigma_p [ 1 , 0 ] = ( 1.0 / self . T ** 2 ) * self . QU self . sigma_p [ 1 , 1 ] = ( 1.0 / self . T ** 2 ) * self . UU det_sigma_p = np . linalg . det ( self . sigma_p ) self . sigpGsq = np . sqrt ( det_sigma_p ) psimeas = np . mod ( 0.5 * np . arctan2 ( self . U , self . Q ) , np . pi ) pmeas = np . sqrt ( self . Q ** 2 + self . U ** 2 ) / self . T invsig = np . linalg . inv ( self . sigma_p ) nsample = len ( p0_all ) p0_psi0_grid = np . asarray ( np . meshgrid ( p0_all , psi0_all ) ) time0 = time . time ( ) outfast = np . zeros ( nsample * nsample , np . float_ ) measpart0 = pmeas * np . cos ( 2 * psimeas ) measpart1 = pmeas * np . sin ( 2 * psimeas ) p0pairs = p0_psi0_grid [ 0 , ... ] . ravel ( ) psi0pairs = p0_psi0_grid [ 1 , ... ] . ravel ( ) truepart0 = p0pairs * np . cos ( 2 * psi0pairs ) truepart1 = p0pairs * np . sin ( 2 * psi0pairs ) rharrbig = np . zeros ( ( 2 , 1 , nsample * nsample ) , np . float_ ) lharrbig = np . zeros ( ( 1 , 2 , nsample * nsample ) , np . float_ ) rharrbig [ 0 , 0 , : ] = measpart0 - truepart0 rharrbig [ 1 , 0 , : ] = measpart1 - truepart1 lharrbig [ 0 , 0 , : ] = measpart0 - truepart0 lharrbig [ 0 , 1 , : ] = measpart1 - truepart1 self . likelihood = ( 1.0 / ( np . pi * self . sigpGsq ) ) * np . exp ( - 0.5 * np . einsum ( <str> , lharrbig , np . einsum ( <str> , invsig , rharrbig ) ) ) self . likelihood = self . likelihood . reshape ( nsample , nsample )   class Posterior ( BayesianComponent ) :      def __init__ ( self , hp_index , rht_cursor , planck_tqu_cursor , planck_cov_cursor , p0_all , psi0_all , reverse_RHT = False ) :          BayesianComponent . __init__ ( self , hp_index ) self . sample_p0 = p0_all self . sample_psi0 = psi0_all p_dx = p0_all [ 1 ] - p0_all [ 0 ] psi_dx = psi0_all [ 1 ] - psi0_all [ 0 ] if psi_dx < 0 :              psi_dx *= - 1  self . p_dx = p_dx self . psi_dx = psi_dx print ( <str> . format ( psi_dx , p_dx ) ) self . reverse_RHT = reverse_RHT prior = Prior ( hp_index , rht_cursor , p0_all , psi0_all , reverse_RHT = reverse_RHT ) likelihood = Likelihood ( hp_index , planck_tqu_cursor , planck_cov_cursor , p0_all , psi0_all ) self . naive_psi = likelihood . naive_psi self . prior = prior . prior self . normed_prior = prior . normed_prior self . planck_likelihood = likelihood . likelihood self . posterior = self . planck_likelihood * self . normed_prior self . posterior_integrated_over_psi = self . integrate_highest_dimension ( self . posterior , dx = psi_dx ) self . posterior_integrated_over_p_and_psi = self . integrate_highest_dimension ( self . posterior_integrated_over_psi , dx = p_dx ) self . normed_posterior = self . posterior / self . posterior_integrated_over_p_and_psi   if __name__ == <str> :      make_vel_int_galfa_channel_maps ( )   