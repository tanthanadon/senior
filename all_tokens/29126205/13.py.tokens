from __future__ import division , print_function import numpy as np import healpy as hp import math from astropy . io import fits from astropy import wcs from astropy import units as u from astropy . coordinates import SkyCoord import copy import time import matplotlib . pyplot as plt import os import sys sys . path . insert ( 0 , <str> ) import RHT_tools def get_thets ( wlen , save = False ) :      ntheta = math . ceil ( ( np . pi * np . sqrt ( 2 ) * ( ( wlen - 1 ) / 2.0 ) ) ) print ( <str> , ntheta ) dtheta = np . pi / ntheta thetbins = dtheta * np . arange ( 0 , ntheta + 2 ) thetbins = thetbins - dtheta / 2 thets = np . arange ( 0 , np . pi , dtheta ) if save == True :          np . save ( <str> + str ( wlen ) + <str> , thets )  return thets  def transform_theta_bins ( ) :      Nside = 2048 Npix = 12 * Nside ** 2 thets = get_thets ( 75 ) thetaGal_Equ0 = hp . fitsfunc . read_map ( <str> ) thets_EquinGal = np . zeros ( ( Npix , len ( thets ) ) ) for i in xrange ( Npix ) :          for j in xrange ( len ( thets ) ) :              thets_EquinGal [ i , j ] = thetaGal_Equ0 [ i ] - thets [ j ] if ( thets_EquinGal [ i , j ] < 0.0 ) :                  thets_EquinGal [ i , j ] += np . pi    quit ( )  def interpolate_thetas ( vstart = 1019 , vstop = 1023 , wlen = 75 ) :      thets = get_thets ( wlen ) root_fn = <str> fgs_fn = root_fn + <str> + str ( vstart ) + <str> + str ( vstop ) + <str> fgs_hdr = fits . getheader ( fgs_fn ) Pfile = root_fn + <str> channel_data = np . zeros ( ( fgs_hdr [ <str> ] , fgs_hdr [ <str> ] ) , np . float_ ) channel_data [ : , : ] = thets [ 0 ] hdulist = fits . open ( Pfile ) tbdata = hdulist [ 1 ] . data hpq = tbdata . field ( <str> ) . flatten ( ) gwcs = wcs . WCS ( fgs_fn ) xax = np . linspace ( 1 , fgs_hdr [ <str> ] , fgs_hdr [ <str> ] ) . reshape ( fgs_hdr [ <str> ] , 1 ) yax = np . linspace ( 1 , fgs_hdr [ <str> ] , fgs_hdr [ <str> ] ) . reshape ( 1 , fgs_hdr [ <str> ] ) test = gwcs . all_pix2world ( xax , yax , 1 ) RA = test [ 0 ] Dec = test [ 1 ] c = SkyCoord ( ra = RA * u . degree , dec = Dec * u . degree , frame = <str> ) cg = c . galactic hppos = hp . pixelfunc . ang2pix ( hp . pixelfunc . npix2nside ( 50331648 ) , np . pi / 2 - np . asarray ( cg . b . rad ) , np . asarray ( cg . l . rad ) , nest = True ) flat_hppos = hppos . flatten ( ) final_data = np . zeros ( hpq . size ) . flatten ( ) - 999 channel_data = ( ( channel_data ) . T ) [ : , : ] . flatten ( ) alldata = zip ( flat_hppos , channel_data ) grouped_data = { } for k , v in alldata :          grouped_data . setdefault ( k , [ ] ) . append ( v )  for z in grouped_data . keys ( ) :          final_data [ z ] = np . nansum ( grouped_data [ z ] ) / np . count_nonzero ( ~ np . isnan ( grouped_data [ z ] ) )  final_data [ np . isnan ( final_data ) ] = - 999 final_data [ np . isinf ( final_data ) ] = - 999 out_hdr = hdulist [ 0 ] . header return final_data , out_hdr  def NHI_masks ( ) :      coldensname = <str> coldensmap = fits . getdata ( <str> + coldensname + <str> ) coldensmap_hdr = fits . getheader ( <str> + coldensname + <str> ) nhicuts = [ 30 , 50 , 70 ] for n in nhicuts :          nhipercentile = np . nanpercentile ( coldensmap , n ) cutmap = np . zeros ( coldensmap . shape , np . float_ ) cutmap [ np . where ( coldensmap > nhipercentile ) ] = 1 proj_data , proj_hdr = interpolate_data_to_hp_galactic ( cutmap , coldensmap_hdr ) fits . writeto ( <str> + coldensname + <str> . format ( n ) , proj_data )   def lensing_maps ( local = False ) :      if local is True :          root = <str>  else :          root = <str>  Qmap_fn = <str> Umap_fn = <str> Imap_fn = <str> Qmap = fits . getdata ( root + Qmap_fn ) Umap = fits . getdata ( root + Umap_fn ) Imap = fits . getdata ( root + Imap_fn ) coldensname = <str> if local is True :          nhiroot = <str>  else :          nhiroot = <str>  coldensmap_hdr = fits . getheader ( nhiroot + coldensname + <str> ) hp_Q , hp_hdr = interpolate_data_to_hp_galactic ( Qmap , coldensmap_hdr , local = False ) fits . writeto ( root + <str> , hp_Q , hp_hdr ) hp_U , hp_hdr = interpolate_data_to_hp_galactic ( Umap , coldensmap_hdr , local = False ) fits . writeto ( root + <str> , hp_U , hp_hdr ) hp_T , hp_hdr = interpolate_data_to_hp_galactic ( Imap , coldensmap_hdr , local = False ) fits . writeto ( root + <str> , hp_T , hp_hdr ) print ( len ( hp_Q ) ) TQU = np . zeros ( ( len ( hp_Q ) , 3 ) , np . float_ ) TQU [ : , 0 ] = hp_T TQU [ : , 1 ] = hp_Q TQU [ : , 2 ] = hp_U hp_hdr [ <str> ] = <str> fits . writeto ( root + <str> , TQU , hp_hdr )  def interpolate_data_to_hp_galactic ( data , data_hdr , local = True , Equ = False , nonedata = - 999 , countpix = False ) :      if local is True :          planck_root = <str>  else :          planck_root = <str>  Pfile = planck_root + <str> hdulist = fits . open ( Pfile ) tbdata = hdulist [ 1 ] . data hpq = tbdata . field ( <str> ) . flatten ( ) gwcs = wcs . WCS ( data_hdr ) xax = np . linspace ( 1 , data_hdr [ <str> ] , data_hdr [ <str> ] ) . reshape ( data_hdr [ <str> ] , 1 ) yax = np . linspace ( 1 , data_hdr [ <str> ] , data_hdr [ <str> ] ) . reshape ( 1 , data_hdr [ <str> ] ) test = gwcs . all_pix2world ( xax , yax , 1 ) RA = test [ 0 ] Dec = test [ 1 ] c = SkyCoord ( ra = RA * u . degree , dec = Dec * u . degree , frame = <str> ) if Equ is False :          if local :              hppos = np . load ( <str> )  else :              hppos = np . load ( <str> )   else :          hppos = hp . pixelfunc . ang2pix ( hp . pixelfunc . npix2nside ( 50331648 ) , np . pi / 2 - np . asarray ( c . dec . rad ) , np . asarray ( c . ra . rad ) , nest = True )  flat_hppos = hppos . flatten ( ) final_data = np . zeros ( hpq . size ) . flatten ( ) final_data [ : ] = nonedata if countpix :          data_count = np . zeros ( hpq . size ) . flatten ( )  data = ( ( data ) . T ) [ : , : ] . flatten ( ) flat_hppos = flat_hppos [ ~ ( np . isnan ( data ) ) ] data = data [ ~ ( np . isnan ( data ) ) ] alldata = zip ( flat_hppos , data ) grouped_data = { } for k , v in alldata :          grouped_data . setdefault ( k , [ ] ) . append ( v )  for z in grouped_data . keys ( ) :          final_data [ z ] = np . nansum ( grouped_data [ z ] ) / np . count_nonzero ( ~ np . isnan ( grouped_data [ z ] ) ) if countpix :              data_count [ z ] = np . count_nonzero ( ~ np . isnan ( grouped_data [ z ] ) )   final_data [ np . isnan ( final_data ) ] = nonedata final_data [ np . isinf ( final_data ) ] = nonedata out_hdr = hdulist [ 0 ] . header if countpix :          hp . fitsfunc . write_map ( <str> , data_count , nest = True )  return final_data , out_hdr  def get_RHT_data ( rht_fn , verbose = False ) :      ipoints , jpoints , rthetas , naxis1 , naxis2 = RHT_tools . get_RHT_data ( rht_fn ) npoints , nthetas = rthetas . shape if verbose :          print ( <str> % nthetas )  return ipoints , jpoints , rthetas , naxis1 , naxis2 , nthetas  def single_theta_slice ( theta_i , ipoints , jpoints , rthetas , naxis1 , naxis2 ) :      single_theta_backprojection = np . zeros ( ( naxis2 , naxis1 ) , np . float_ ) single_theta_backprojection [ jpoints , ipoints ] = rthetas [ : , theta_i ] return single_theta_backprojection  def reproject_by_thetabin ( ) :      vels = [ 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 ] root = <str> out_root = <str> wlen = 75 rht_fn = root + <str> + str ( vels [ 0 ] ) + <str> + str ( wlen ) + <str> ipoints16 , jpoints16 , rthetas16 , naxis1 , naxis2 , nthetas = get_RHT_data ( rht_fn ) rht_fn = root + <str> + str ( vels [ 1 ] ) + <str> + str ( wlen ) + <str> ipoints17 , jpoints17 , rthetas17 , naxis1 , naxis2 , nthetas = get_RHT_data ( rht_fn ) rht_fn = root + <str> + str ( vels [ 2 ] ) + <str> + str ( wlen ) + <str> ipoints18 , jpoints18 , rthetas18 , naxis1 , naxis2 , nthetas = get_RHT_data ( rht_fn ) rht_fn = root + <str> + str ( vels [ 3 ] ) + <str> + str ( wlen ) + <str> ipoints19 , jpoints19 , rthetas19 , naxis1 , naxis2 , nthetas = get_RHT_data ( rht_fn ) rht_fn = root + <str> + str ( vels [ 4 ] ) + <str> + str ( wlen ) + <str> ipoints20 , jpoints20 , rthetas20 , naxis1 , naxis2 , nthetas = get_RHT_data ( rht_fn ) rht_fn = root + <str> + str ( vels [ 5 ] ) + <str> + str ( wlen ) + <str> ipoints21 , jpoints21 , rthetas21 , naxis1 , naxis2 , nthetas = get_RHT_data ( rht_fn ) rht_fn = root + <str> + str ( vels [ 6 ] ) + <str> + str ( wlen ) + <str> ipoints22 , jpoints22 , rthetas22 , naxis1 , naxis2 , nthetas = get_RHT_data ( rht_fn ) rht_fn = root + <str> + str ( vels [ 7 ] ) + <str> + str ( wlen ) + <str> ipoints23 , jpoints23 , rthetas23 , naxis1 , naxis2 , nthetas = get_RHT_data ( rht_fn ) rht_fn = root + <str> + str ( vels [ 8 ] ) + <str> + str ( wlen ) + <str> ipoints24 , jpoints24 , rthetas24 , naxis1 , naxis2 , nthetas = get_RHT_data ( rht_fn ) galfa_fn = <str> galfa_hdr = fits . getheader ( galfa_fn ) for theta_index in xrange ( nthetas ) :          time0 = time . time ( ) single_theta_backprojection = single_theta_slice ( theta_index , ipoints16 , jpoints16 , rthetas16 , naxis1 , naxis2 ) single_theta_backprojection += single_theta_slice ( theta_index , ipoints17 , jpoints17 , rthetas17 , naxis1 , naxis2 ) single_theta_backprojection += single_theta_slice ( theta_index , ipoints18 , jpoints18 , rthetas18 , naxis1 , naxis2 ) single_theta_backprojection += single_theta_slice ( theta_index , ipoints19 , jpoints19 , rthetas19 , naxis1 , naxis2 ) single_theta_backprojection += single_theta_slice ( theta_index , ipoints20 , jpoints20 , rthetas20 , naxis1 , naxis2 ) single_theta_backprojection += single_theta_slice ( theta_index , ipoints21 , jpoints21 , rthetas21 , naxis1 , naxis2 ) single_theta_backprojection += single_theta_slice ( theta_index , ipoints22 , jpoints22 , rthetas22 , naxis1 , naxis2 ) single_theta_backprojection += single_theta_slice ( theta_index , ipoints23 , jpoints23 , rthetas23 , naxis1 , naxis2 ) single_theta_backprojection += single_theta_slice ( theta_index , ipoints24 , jpoints24 , rthetas24 , naxis1 , naxis2 ) single_theta_backprojection_galactic , out_hdr = interpolate_data_to_hp_galactic ( single_theta_backprojection , galfa_hdr ) time1 = time . time ( ) print ( <str> % ( theta_index , ( time1 - time0 ) / 60. ) ) out_fn = out_root + <str> + str ( vels [ 0 ] ) + <str> + str ( vels [ - 1 ] ) + <str> + str ( wlen ) + <str> + str ( theta_index ) + <str> out_hdr [ <str> ] = theta_index out_hdr [ <str> ] = vels [ 0 ] out_hdr [ <str> ] = vels [ - 1 ] fits . writeto ( out_fn , single_theta_backprojection_galactic , out_hdr )   def get_extra0_sstring ( cstart , cstop ) :      if cstart <= 999 :          s_string = <str> extra_0 = <str>  else :          s_string = <str> extra_0 = <str>  if cstart == 999 :          s_string = <str> extra_0 = <str>  return s_string , extra_0  def get_extra0_startstop ( cstart , cstop ) :      if cstart <= 999 :          start_0 = <str> end_0 = <str>  else :          start_0 = <str> end_0 = <str>  if cstart == 999 :          start_0 = <str> end_0 = <str>  return start_0 , end_0  def single_thetabin_single_vel_allsky ( velnum = - 8 ) :      wlen = 75 cstep = 5 cstart = 1024 + velnum * cstep cstop = cstart + cstep - 1 s_string , extra_0 = get_extra0_sstring ( cstart , cstop ) velrangestring = s_string + str ( cstart ) + <str> + extra_0 + str ( cstop ) root = <str> out_root = <str> + velrangestring + <str> if not os . path . exists ( out_root ) :          os . makedirs ( out_root )  step = 3600 filler_overlap = 60 normal_overlap = 50 leftstop = 111 rightstart = 21488 nyfull = 2432 nxfull = 21600 fulldata = np . zeros ( ( nyfull , nxfull ) , np . float_ ) for theta_index in np . arange ( 158 , 160 ) :          time0 = time . time ( ) fulldata = np . zeros ( fulldata . shape ) for num in [ 0 , 1 , 2 , 3 , 4 , 5 ] :              xstart0_normal = max ( ( step * num - normal_overlap ) , 0 ) xstop0_normal = step * ( num + 1 ) + normal_overlap if num == 3 :                  rht_fn = root + <str> + s_string + str ( cstart ) + <str> + extra_0 + str ( cstop ) + <str> + str ( num ) + <str> + str ( wlen ) + <str>  else :                  rht_fn = root + <str> + s_string + str ( cstart ) + <str> + extra_0 + str ( cstop ) + <str> + str ( num ) + <str> + str ( wlen ) + <str>  ipoints , jpoints , rthetas , naxis1 , naxis2 , nthetas = get_RHT_data ( rht_fn ) single_theta_backprojection_chunk = single_theta_slice ( theta_index , ipoints , jpoints , rthetas , naxis1 , naxis2 ) fulldata = place_normal_data ( fulldata , single_theta_backprojection_chunk , xstart0_normal , xstop0_normal ) if num > 0 :                  if num == 3 :                      rht_fn = root + <str> + s_string + str ( cstart ) + <str> + extra_0 + str ( cstop ) + <str> + str ( num ) + <str> + str ( wlen ) + <str>  else :                      rht_fn = root + <str> + s_string + str ( cstart ) + <str> + extra_0 + str ( cstop ) + <str> + str ( num ) + <str> + str ( wlen ) + <str>  ipoints , jpoints , rthetas , naxis1 , naxis2 , nthetas = get_RHT_data ( rht_fn ) single_theta_backprojection_chunk = single_theta_slice ( theta_index , ipoints , jpoints , rthetas , naxis1 , naxis2 ) fulldata = place_filler_data ( fulldata , single_theta_backprojection_chunk , num , filler_overlap )   rht_fn = root + <str> + s_string + str ( cstart ) + <str> + extra_0 + str ( cstop ) + <str> + str ( wlen ) + <str> ipoints , jpoints , rthetas , naxis1 , naxis2 , nthetas = get_RHT_data ( rht_fn ) single_theta_backprojection_chunk = single_theta_slice ( theta_index , ipoints , jpoints , rthetas , naxis1 , naxis2 ) fulldata = place_seam_data ( fulldata , single_theta_backprojection_chunk , leftstop , rightstart ) hdr = fits . getheader ( <str> ) hdr [ <str> ] = cstart hdr [ <str> ] = cstop hdr [ <str> ] = theta_index fits . writeto ( out_root + <str> + s_string + str ( cstart ) + <str> + extra_0 + str ( cstop ) + <str> + str ( wlen ) + <str> + str ( theta_index ) + <str> , fulldata , hdr ) time1 = time . time ( ) print ( np . nansum ( fulldata ) ) print ( <str> % ( theta_index , ( time1 - time0 ) / 60. ) )   def place_normal_data ( holey_data , filler_data , xstart0 , xstop0 ) :      filler_data [ np . where ( holey_data [ : , xstart0 : xstop0 ] != 0 ) ] = 0 holey_data [ : , xstart0 : xstop0 ] += filler_data return holey_data  def place_filler_data ( holey_data , filler_data , fillernum , overlap ) :      infiller0 , infiller1 , tofiller0 , tofiller1 = get_placement_from_fillernum ( fillernum , overlap ) holey_data [ : , tofiller0 : tofiller1 ] = filler_data [ : , infiller0 : infiller1 ] return holey_data  def place_seam_data ( holey_data , seam_data , leftstop , rightstart ) :      ny_left , nx_left = holey_data [ : , : leftstop ] . shape ny_right , nx_right = holey_data [ : , rightstart : ] . shape left_seam_data = seam_data [ : , : nx_right ] right_seam_data = seam_data [ : , nx_right : ] left_seam_data [ np . where ( holey_data [ : , rightstart : ] != 0 ) ] = 0 right_seam_data [ np . where ( holey_data [ : , : leftstop ] != 0 ) ] = 0 seam_data [ np . where ( np . isnan ( seam_data ) == True ) ] = 0 holey_data [ : , : leftstop ] += right_seam_data holey_data [ : , rightstart : ] += left_seam_data return holey_data  def get_start_stop_from_fillernum ( fillernum , overlap ) :      if fillernum == 1 :          xstart0 = 3598 - overlap xstop0 = 3601 + overlap  if fillernum == 2 :          xstart0 = 7198 - overlap xstop0 = 7201 + overlap  if fillernum == 3 :          xstart0 = 10798 - overlap xstop0 = 10801 + overlap  if fillernum == 4 :          xstart0 = 14398 - overlap xstop0 = 14401 + overlap  if fillernum == 5 :          xstart0 = 17998 - overlap xstop0 = 18001 + overlap  return xstart0 , xstop0  def get_placement_from_fillernum ( fillernum , overlap ) :      xstart0 , xstop0 = get_start_stop_from_fillernum ( fillernum , overlap ) infiller0 = overlap - 2 infiller1 = xstop0 - overlap + 2 - xstart0 tofiller0 = xstart0 + infiller0 tofiller1 = xstart0 + infiller1 return infiller0 , infiller1 , tofiller0 , tofiller1  def redo_local_intrhts ( velnum = - 10 ) :      wlen = 75 cstep = 5 filler_overlap = 60 leftstop = 111 rightstart = 21488 cstart = 1024 + velnum * cstep cstop = cstart + cstep - 1 start_0 , end_0 = get_extra0_startstop ( cstart , cstop ) velrangestring = start_0 + str ( cstart ) + <str> + end_0 + str ( cstop ) root = <str> holey_intrht = np . load ( root + <str> + velrangestring + <str> ) for num in [ 1 , 2 , 3 , 4 , 5 ] :          filler_intrht = np . load ( root + <str> + velrangestring + <str> + str ( num ) + <str> ) holey_intrht = place_filler_data ( holey_intrht , filler_intrht , num , filler_overlap )  seam_intrht = np . load ( root + <str> + velrangestring + <str> ) final_intrht = place_seam_data ( holey_intrht , seam_intrht , leftstop , rightstart ) np . save ( root + <str> + velrangestring + <str> , final_intrht )  def reproject_by_thetabin_allsky ( ) :      vels = np . arange ( - 10 , 11 , 1 ) root = <str> out_root = <str> wlen = 75 cstep = 5 step = 3600 overlap = 50 fulldata = fits . getdata ( <str> ) nyfull , nxfull = fulldata . shape for theta_index in xrange ( 1 ) :          time0 = time . time ( ) single_theta_backprojection = np . zeros ( fulldata . shape ) for v_ in vels :              cstart = 1024 + v_ * cstep cstop = cstart + cstep - 1 s_string , extra_0 = get_extra0_sstring ( cstart , cstop ) for num in [ 0 , 1 , 2 , 3 , 4 , 5 ] :                  time2 = time . time ( ) xstart0 = max ( ( step * num - overlap ) , 0 ) xstop0 = step * ( num + 1 ) + overlap rht_fn = root + <str> + s_string + str ( cstart ) + <str> + extra_0 + str ( cstop ) + <str> + str ( num ) + <str> + str ( wlen ) + <str> ipoints , jpoints , rthetas , naxis1 , naxis2 , nthetas = get_RHT_data ( rht_fn ) single_theta_backprojection_chunk = single_theta_slice ( theta_index , ipoints , jpoints , rthetas , naxis1 , naxis2 ) single_theta_backprojection_chunk [ np . where ( np . isnan ( single_theta_backprojection_chunk ) == True ) ] = 0 single_theta_backprojection [ : , xstart0 : xstop0 ] += single_theta_backprojection_chunk time3 = time . time ( ) print ( <str> % ( num , ( time3 - time2 ) / 60. ) )   time1 = time . time ( ) print ( <str> % ( theta_index , ( time1 - time0 ) / 60. ) )  return single_theta_backprojection  def plot_by_thetabin ( ) :      unprojected_root = <str> unprojected_fn = <str> vels = [ 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 ] wlen = 75 rht_fn = unprojected_root + <str> + str ( vels [ 0 ] ) + <str> + str ( wlen ) + <str> ipoints16 , jpoints16 , rthetas16 , naxis1 , naxis2 , nthetas = get_RHT_data ( rht_fn ) rht_fn = unprojected_root + <str> + str ( vels [ 1 ] ) + <str> + str ( wlen ) + <str> ipoints17 , jpoints17 , rthetas17 , naxis1 , naxis2 , nthetas = get_RHT_data ( rht_fn ) rht_fn = unprojected_root + <str> + str ( vels [ 2 ] ) + <str> + str ( wlen ) + <str> ipoints18 , jpoints18 , rthetas18 , naxis1 , naxis2 , nthetas = get_RHT_data ( rht_fn ) rht_fn = unprojected_root + <str> + str ( vels [ 3 ] ) + <str> + str ( wlen ) + <str> ipoints19 , jpoints19 , rthetas19 , naxis1 , naxis2 , nthetas = get_RHT_data ( rht_fn ) rht_fn = unprojected_root + <str> + str ( vels [ 4 ] ) + <str> + str ( wlen ) + <str> ipoints20 , jpoints20 , rthetas20 , naxis1 , naxis2 , nthetas = get_RHT_data ( rht_fn ) rht_fn = unprojected_root + <str> + str ( vels [ 5 ] ) + <str> + str ( wlen ) + <str> ipoints21 , jpoints21 , rthetas21 , naxis1 , naxis2 , nthetas = get_RHT_data ( rht_fn ) rht_fn = unprojected_root + <str> + str ( vels [ 6 ] ) + <str> + str ( wlen ) + <str> ipoints22 , jpoints22 , rthetas22 , naxis1 , naxis2 , nthetas = get_RHT_data ( rht_fn ) rht_fn = unprojected_root + <str> + str ( vels [ 7 ] ) + <str> + str ( wlen ) + <str> ipoints23 , jpoints23 , rthetas23 , naxis1 , naxis2 , nthetas = get_RHT_data ( rht_fn ) rht_fn = unprojected_root + <str> + str ( vels [ 8 ] ) + <str> + str ( wlen ) + <str> ipoints24 , jpoints24 , rthetas24 , naxis1 , naxis2 , nthetas = get_RHT_data ( rht_fn ) for theta_index in xrange ( 1 ) :          time0 = time . time ( ) single_theta_backprojection = single_theta_slice ( theta_index , ipoints16 , jpoints16 , rthetas16 , naxis1 , naxis2 ) single_theta_backprojection += single_theta_slice ( theta_index , ipoints17 , jpoints17 , rthetas17 , naxis1 , naxis2 ) single_theta_backprojection += single_theta_slice ( theta_index , ipoints18 , jpoints18 , rthetas18 , naxis1 , naxis2 ) single_theta_backprojection += single_theta_slice ( theta_index , ipoints19 , jpoints19 , rthetas19 , naxis1 , naxis2 ) single_theta_backprojection += single_theta_slice ( theta_index , ipoints20 , jpoints20 , rthetas20 , naxis1 , naxis2 ) single_theta_backprojection += single_theta_slice ( theta_index , ipoints21 , jpoints21 , rthetas21 , naxis1 , naxis2 ) single_theta_backprojection += single_theta_slice ( theta_index , ipoints22 , jpoints22 , rthetas22 , naxis1 , naxis2 ) single_theta_backprojection += single_theta_slice ( theta_index , ipoints23 , jpoints23 , rthetas23 , naxis1 , naxis2 ) single_theta_backprojection += single_theta_slice ( theta_index , ipoints24 , jpoints24 , rthetas24 , naxis1 , naxis2 )  projected_root = <str> projected_fn = <str> cmap = <str> projected_data = fits . getdata ( projected_root + projected_fn ) plot_projected = hp . mollview ( np . clip ( projected_data , 0 , np . nanmax ( projected_data ) ) , return_projected_map = True , nest = True ) fig = plt . figure ( figsize = ( 6 , 6.5 ) ) ax1 = fig . add_subplot ( 211 ) ny , nx = plot_projected . shape im1 = ax1 . imshow ( np . log10 ( plot_projected ) , cmap = cmap ) plt . colorbar ( im1 ) ax1 . set_ylim ( 200 , 400 ) ax1 . set_xlim ( 200 , 500 ) ax2 = fig . add_subplot ( 212 ) im2 = ax2 . imshow ( np . log10 ( single_theta_backprojection ) , cmap = cmap ) plt . colorbar ( im2 , orientation = <str> )  if __name__ == <str> :      galfa_fn = <str> dataones = fits . getdata ( galfa_fn ) data_hdr = fits . getheader ( galfa_fn ) interpolate_data_to_hp_galactic ( dataones , data_hdr , local = True , Equ = False , nonedata = 0 , countpix = False )   