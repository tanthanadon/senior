from __future__ import division from __future__ import print_function import numpy as np import scipy . special as spec import scipy . optimize as opt import sys import itertools as it import time import copy import ehtim . obsdata from ehtim . observing . obs_helpers import * import ehtim . imaging . imager_utils as iu from multiprocessing import cpu_count from multiprocessing import Pool from multiprocessing import Process , Value , Lock from ehtim . calibrating . cal_helpers import * import warnings warnings . filterwarnings ( <str> , message = <str> ) MAXIT = 10000 def self_cal ( obs , im , sites = [ ] , method = <str> , pol = <str> , minimizer_method = <str> , pad_amp = 0. , gain_tol = .2 , solution_interval = 0.0 , scan_solutions = False , ttype = <str> , fft_pad_factor = 2 , caltable = False , debias = True , copy_closure_tables = True , processes = - 1 , show_solution = False , msgtype = <str> ) :      if pol not in [ <str> , <str> , <str> , <str> , <str> , <str> ] :          raise Exception ( <str> )  if pol in [ <str> , <str> , <str> , <str> ] :          if obs . polrep != <str> :              raise Exception ( <str> )  im = im . switch_polrep ( <str> , pol )  elif pol in [ <str> , <str> , <str> ] :          if obs . polrep != <str> :              raise Exception ( <str> )  im = im . switch_polrep ( <str> , pol )  if len ( sites ) == 0 :          print ( <str> ) sites = obs . tarr [ <str> ]  print ( <str> + ttype + <str> ) obs_clean = im . observe_same_nonoise ( obs , ttype = ttype , fft_pad_factor = fft_pad_factor ) V = obs_clean . data [ vis_poldict [ pol ] ] scans = obs . tlist ( t_gather = solution_interval , scan_gather = scan_solutions ) scans_cal = copy . copy ( scans ) V_scans = [ o [ vis_poldict [ pol ] ] for o in obs_clean . tlist ( t_gather = solution_interval , scan_gather = scan_solutions ) ] if processes > 0 :          counter = Counter ( initval = 0 , maxval = len ( scans ) ) print ( <str> % processes ) pool = Pool ( processes = processes , initializer = init , initargs = ( counter , ) )  elif processes == 0 :          counter = Counter ( initval = 0 , maxval = len ( scans ) ) processes = int ( cpu_count ( ) ) print ( <str> % processes ) pool = Pool ( processes = processes , initializer = init , initargs = ( counter , ) )  else :          print ( <str> )  tstart = time . time ( ) if processes > 0 :          scans_cal = np . array ( pool . map ( get_selfcal_scan_cal , [ [ i , len ( scans ) , scans [ i ] , im , V_scans [ i ] , sites , obs . polrep , pol , method , minimizer_method , show_solution , pad_amp , gain_tol , caltable , debias , msgtype ] for i in range ( len ( scans ) ) ] ) )  else :          for i in range ( len ( scans ) ) :              prog_msg ( i , len ( scans ) , msgtype = msgtype , nscan_last = i - 1 ) scans_cal [ i ] = self_cal_scan ( scans [ i ] , im , V_scan = V_scans [ i ] , sites = sites , polrep = obs . polrep , pol = pol , method = method , minimizer_method = minimizer_method , show_solution = show_solution , debias = debias , pad_amp = pad_amp , gain_tol = gain_tol , caltable = caltable )   tstop = time . time ( ) print ( <str> % ( tstop - tstart ) ) if caltable :          allsites = obs . tarr [ <str> ] caldict = scans_cal [ 0 ] for i in range ( 1 , len ( scans_cal ) ) :              row = scans_cal [ i ] for site in allsites :                  try : dat = row [ site ] except KeyError : continue try : caldict [ site ] = np . append ( caldict [ site ] , row [ site ] ) except KeyError : caldict [ site ] = dat   caltable = ehtim . caltable . Caltable ( obs . ra , obs . dec , obs . rf , obs . bw , caldict , obs . tarr , source = obs . source , mjd = obs . mjd , timetype = obs . timetype ) out = caltable  else :          arglist , argdict = obs . obsdata_args ( ) arglist [ 4 ] = np . concatenate ( scans_cal ) out = ehtim . obsdata . Obsdata ( * arglist , ** argdict ) if copy_closure_tables :              out . camp = obs . camp out . logcamp = obs . logcamp out . cphase = obs . cphase   if processes != - 1 :          pool . close ( )  return out  def self_cal_scan ( scan , im , V_scan = [ ] , sites = [ ] , polrep = <str> , pol = <str> , method = <str> , minimizer_method = <str> , show_solution = False , pad_amp = 0. , gain_tol = .2 , debias = True , caltable = False ) :      if len ( sites ) == 0 :          print ( <str> ) sites = list ( set ( scan [ <str> ] ) . union ( set ( scan [ <str> ] ) ) )  if len ( V_scan ) < 1 :          uv = np . hstack ( ( scan [ <str> ] . reshape ( - 1 , 1 ) , scan [ <str> ] . reshape ( - 1 , 1 ) ) ) A = ftmatrix ( im . psize , im . xdim , im . ydim , uv , pulse = im . pulse ) V_scan = np . dot ( A , im . imvec )  if type ( gain_tol ) == float or type ( gain_tol ) == int :          gain_tol = [ gain_tol , gain_tol ]  tkey = { b : a for a , b in enumerate ( sites ) } g1_keys = [ ] g2_keys = [ ] scan_keys = [ ] for row in scan :          try :              g1_keys . append ( tkey [ row [ <str> ] ] )  except KeyError :              g1_keys . append ( - 1 )  try :              g2_keys . append ( tkey [ row [ <str> ] ] )  except KeyError :              g2_keys . append ( - 1 )   if np . all ( g1_keys == - 1 ) and np . all ( g2_keys == - 1 ) :          return scan  vis = scan [ vis_poldict [ pol ] ] sigma = scan [ sig_poldict [ pol ] ] if method == <str> :          if debias :              vis = amp_debias ( np . abs ( vis ) , np . abs ( sigma ) )  else :              vis = np . abs ( vis )   sigma_inv = 1.0 / np . sqrt ( sigma ** 2 + ( pad_amp * np . abs ( vis ) ) ** 2 ) gpar_guess = np . ones ( len ( sites ) , dtype = np . complex128 ) . view ( dtype = np . float64 ) def errfunc ( gpar ) :          g = gpar . astype ( np . float64 ) . view ( dtype = np . complex128 ) if method == <str> :              g = g / np . abs ( g )  if method == <str> :              g = np . abs ( np . real ( g ) )  g = np . append ( g , 1. ) g1 = g [ g1_keys ] g2 = g [ g2_keys ] if method == <str> :              verr = np . abs ( vis ) - g1 * g2 . conj ( ) * np . abs ( V_scan )  else :              verr = vis - g1 * g2 . conj ( ) * V_scan  nan_mask = [ not np . isnan ( v ) for v in verr ] verr = verr [ nan_mask ] chisq = np . sum ( ( verr . real * sigma_inv [ nan_mask ] ) ** 2 ) + np . sum ( ( verr . imag * sigma_inv [ nan_mask ] ) ** 2 ) chisq_g = np . sum ( np . log ( np . abs ( g ) ) ** 2 / ( ( np . abs ( g ) > 1 ) * gain_tol [ 0 ] + ( np . abs ( g ) <= 1 ) * gain_tol [ 1 ] ) ** 2 ) return chisq + chisq_g  optdict = { <str> : MAXIT } res = opt . minimize ( errfunc , gpar_guess , method = minimizer_method , options = optdict ) g_fit = res . x . view ( np . complex128 ) if show_solution == True :          print ( np . abs ( g_fit ) )  if method == <str> :          g_fit = g_fit / np . abs ( g_fit )  if method == <str> :          g_fit = np . abs ( np . real ( g_fit ) )  g_fit = np . append ( g_fit , 1. ) if caltable :          allsites = list ( set ( scan [ <str> ] ) . union ( set ( scan [ <str> ] ) ) ) caldict = { } for site in allsites :              if site in sites :                  site_key = tkey [ site ]  else :                  site_key = - 1  rscale = g_fit [ site_key ] ** - 1 lscale = g_fit [ site_key ] ** - 1 caldict [ site ] = np . array ( ( scan [ <str> ] [ 0 ] , rscale , lscale ) , dtype = DTCAL )  out = caldict  else :          g1_fit = g_fit [ g1_keys ] g2_fit = g_fit [ g2_keys ] gij_inv = ( g1_fit * g2_fit . conj ( ) ) ** ( - 1 ) if polrep == <str> :              for vistype in [ <str> , <str> , <str> , <str> ] :                  scan [ vistype ] *= gij_inv  for sigtype in [ <str> , <str> , <str> , <str> ] :                  scan [ sigtype ] *= np . abs ( gij_inv )   elif polrep == <str> :              for vistype in [ <str> , <str> , <str> , <str> ] :                  scan [ vistype ] *= gij_inv  for sigtype in [ <str> , <str> , <str> , <str> ] :                  scan [ sigtype ] *= np . abs ( gij_inv )   out = scan  return out  def init ( x ) :      global counter counter = x  def get_selfcal_scan_cal ( args ) :      return get_selfcal_scan_cal2 ( * args )  def get_selfcal_scan_cal2 ( i , n , scan , im , V_scan , sites , polrep , pol , method , minimizer_method , show_solution , pad_amp , gain_tol , caltable , debias , msgtype ) :      if n > 1 :          global counter counter . increment ( ) prog_msg ( counter . value ( ) , counter . maxval , msgtype , counter . value ( ) - 1 )  return self_cal_scan ( scan , im , V_scan = V_scan , sites = sites , polrep = polrep , pol = pol , method = method , minimizer_method = minimizer_method , show_solution = show_solution , pad_amp = pad_amp , gain_tol = gain_tol , caltable = caltable , debias = debias )   