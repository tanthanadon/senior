from __future__ import division from __future__ import print_function import numpy as np import scipy . special as spec import scipy . optimize as opt import sys import itertools as it import time import copy import ehtim . obsdata from ehtim . observing . obs_helpers import * from multiprocessing import cpu_count from multiprocessing import Pool from ehtim . calibrating . cal_helpers import * ZBLCUTOFF = 1.e7 ; MAXIT = 5000 def network_cal ( obs , zbl , sites = [ ] , zbl_uvdist_max = ZBLCUTOFF , method = <str> , minimizer_method = <str> , pol = <str> , pad_amp = 0. , gain_tol = .2 , solution_interval = 0.0 , scan_solutions = False , caltable = False , processes = - 1 , show_solution = False , debias = True , msgtype = <str> ) :      if pol not in [ <str> , <str> , <str> , <str> , <str> , <str> , <str> ] :          raise Exception ( <str> )  if pol in [ <str> , <str> , <str> , <str> ] :          if obs . polrep != <str> :              raise Exception ( <str> )   elif pol in [ <str> , <str> , <str> ] :          if obs . polrep != <str> :              raise Exception ( <str> )   if len ( sites ) == 0 :          print ( <str> ) sites = obs . tarr [ <str> ]  cluster_data = make_cluster_data ( obs , zbl_uvdist_max ) scans = obs . tlist ( t_gather = solution_interval , scan_gather = scan_solutions ) scans_cal = copy . copy ( scans ) if processes > 0 :          counter = Counter ( initval = 0 , maxval = len ( scans ) ) if processes > len ( scans ) :              processes = len ( scans )  print ( <str> % processes ) pool = Pool ( processes = processes , initializer = init , initargs = ( counter , ) )  elif processes == 0 :          counter = Counter ( initval = 0 , maxval = len ( scans ) ) processes = int ( cpu_count ( ) ) if processes > len ( scans ) :              processes = len ( scans )  print ( <str> % processes ) pool = Pool ( processes = processes , initializer = init , initargs = ( counter , ) )  else :          print ( <str> )  tstart = time . time ( ) if processes > 0 :          scans_cal = pool . map ( get_network_scan_cal , [ [ i , len ( scans ) , scans [ i ] , zbl , sites , cluster_data , obs . polrep , pol , method , pad_amp , gain_tol , caltable , show_solution , debias , msgtype ] for i in range ( len ( scans ) ) ] )  else :          for i in range ( len ( scans ) ) :              prog_msg ( i , len ( scans ) , msgtype = msgtype , nscan_last = i - 1 ) scans_cal [ i ] = network_cal_scan ( scans [ i ] , zbl , sites , cluster_data , polrep = obs . polrep , pol = pol , method = method , minimizer_method = minimizer_method , show_solution = show_solution , caltable = caltable , pad_amp = pad_amp , gain_tol = gain_tol , debias = debias )   tstop = time . time ( ) print ( <str> % ( tstop - tstart ) ) if caltable :          allsites = obs . tarr [ <str> ] caldict = { k : v . reshape ( 1 ) for k , v in scans_cal [ 0 ] . items ( ) } for i in range ( 1 , len ( scans_cal ) ) :              row = scans_cal [ i ] if len ( row ) == 0 :                  continue  for site in allsites :                  try : dat = row [ site ] except KeyError : continue try : caldict [ site ] = np . append ( caldict [ site ] , row [ site ] ) except KeyError : caldict [ site ] = [ dat ]   caltable = ehtim . caltable . Caltable ( obs . ra , obs . dec , obs . rf , obs . bw , caldict , obs . tarr , source = obs . source , mjd = obs . mjd , timetype = obs . timetype ) out = caltable  else :          arglist , argdict = obs . obsdata_args ( ) arglist [ 4 ] = np . concatenate ( scans_cal ) out = ehtim . obsdata . Obsdata ( * arglist , ** argdict )  if processes != - 1 :          pool . close ( )  return out  def network_cal_scan ( scan , zbl , sites , clustered_sites , polrep = <str> , pol = <str> , zbl_uvidst_max = ZBLCUTOFF , method = <str> , minimizer_method = <str> , show_solution = False , pad_amp = 0. , gain_tol = .2 , caltable = False , debias = True ) :      allclusters = clustered_sites [ 0 ] clusterdict = clustered_sites [ 1 ] clusterbls = clustered_sites [ 2 ] allsites = list ( set ( np . hstack ( ( scan [ <str> ] , scan [ <str> ] ) ) ) ) if len ( sites ) == 0 :          print ( <str> ) sites = allsites  sites = [ s for s in sites if s in allsites ] tkey = { b : a for a , b in enumerate ( sites ) } for cluster in allclusters :          if len ( cluster ) == 1 :              tkey [ cluster [ 0 ] ] = - 1   clusterkey = clusterdict clusterbls_scan = [ set ( [ clusterkey [ row [ <str> ] ] , clusterkey [ row [ <str> ] ] ] ) for row in scan if len ( set ( [ clusterkey [ row [ <str> ] ] , clusterkey [ row [ <str> ] ] ] ) ) == 2 ] clusterbls = [ cluster for cluster in clusterbls if cluster in clusterbls_scan ] g1_keys = [ ] g2_keys = [ ] scan_keys = [ ] for row in scan :          try :              g1_keys . append ( tkey [ row [ <str> ] ] )  except KeyError :              g1_keys . append ( - 1 )  try :              g2_keys . append ( tkey [ row [ <str> ] ] )  except KeyError :              g2_keys . append ( - 1 )  clusternum1 = clusterkey [ row [ <str> ] ] clusternum2 = clusterkey [ row [ <str> ] ] if clusternum1 == clusternum2 :              scan_keys . append ( - 1 )  else :              bl_index = clusterbls . index ( set ( ( clusternum1 , clusternum2 ) ) ) scan_keys . append ( bl_index )   vis_mask = [ ( ( row [ <str> ] in tkey . keys ( ) and tkey [ row [ <str> ] ] != - 1 ) or ( row [ <str> ] in tkey . keys ( ) and tkey [ row [ <str> ] ] != - 1 ) ) for row in scan ] if pol != <str> :          vis = scan [ vis_poldict [ pol ] ] sigma = scan [ sig_poldict [ pol ] ]  else :          vis = np . concatenate ( [ scan [ vis_poldict [ <str> ] ] , scan [ vis_poldict [ <str> ] ] ] ) sigma = np . concatenate ( [ scan [ sig_poldict [ <str> ] ] , scan [ sig_poldict [ <str> ] ] ] ) vis_mask = np . concatenate ( [ vis_mask , vis_mask ] )  if method == <str> :          if debias :              vis = amp_debias ( np . abs ( vis ) , np . abs ( sigma ) )  else :              vis = np . abs ( vis )   sigma_inv = 1.0 / np . sqrt ( sigma ** 2 + ( pad_amp * np . abs ( vis ) ) ** 2 ) n_gains = len ( sites ) n_clusterbls = len ( clusterbls ) if show_solution : print ( <str> % ( n_gains , n_clusterbls ) ) gpar_guess = np . ones ( n_gains , dtype = np . complex128 ) . view ( dtype = np . float64 ) vpar_guess = np . ones ( n_clusterbls , dtype = np . complex128 ) for i in range ( len ( scan_keys ) ) :          if scan_keys [ i ] < 0 : continue if np . isnan ( vis [ i ] ) : continue vpar_guess [ scan_keys [ i ] ] = vis [ i ]  vpar_guess = vpar_guess . view ( dtype = np . float64 ) gvpar_guess = np . hstack ( ( gpar_guess , vpar_guess ) ) def errfunc ( gvpar ) :          g = gvpar [ 0 : 2 * n_gains ] . astype ( np . float64 ) . view ( dtype = np . complex128 ) v = gvpar [ 2 * n_gains : ] . astype ( np . float64 ) . view ( dtype = np . complex128 ) if method == <str> :              g = g / np . abs ( g )  if method == <str> :              g = np . abs ( np . real ( g ) )  g = np . append ( g , 1. ) v = np . append ( v , zbl ) v_scan = v [ scan_keys ] g1 = g [ g1_keys ] g2 = g [ g2_keys ] if pol == <str> :              v_scan = np . concatenate ( [ v_scan , v_scan ] ) g1 = np . concatenate ( [ g1 , g1 ] ) g2 = np . concatenate ( [ g2 , g2 ] )  if method == <str> :              verr = np . abs ( vis ) - g1 * g2 . conj ( ) * np . abs ( v_scan )  else :              verr = vis - g1 * g2 . conj ( ) * v_scan  nan_mask = np . array ( [ not np . isnan ( viter ) for viter in verr ] ) * np . array ( [ not np . isnan ( viter ) for viter in sigma_inv ] ) verr = verr [ nan_mask * vis_mask ] chisq = np . sum ( ( verr . real * sigma_inv [ nan_mask * vis_mask ] ) ** 2 ) + np . sum ( ( verr . imag * sigma_inv [ nan_mask * vis_mask ] ) ** 2 ) g_fracerr = gain_tol chisq_g = np . sum ( ( np . log ( np . abs ( g ) ) ** 2 / g_fracerr ** 2 ) ) chisq_v = np . sum ( ( np . abs ( v ) / zbl ) ** 4 ) return chisq + chisq_g + chisq_v  if np . max ( g1_keys ) > - 1 or np . max ( g2_keys ) > - 1 :          optdict = { <str> : MAXIT } res = opt . minimize ( errfunc , gvpar_guess , method = minimizer_method , options = optdict ) g_fit = res . x [ 0 : 2 * n_gains ] . view ( np . complex128 ) v_fit = res . x [ 2 * n_gains : ] . view ( np . complex128 ) if method == <str> :              g_fit = g_fit / np . abs ( g_fit )  if method == <str> :              g_fit = np . abs ( np . real ( g_fit ) )  if show_solution == True :              print ( np . abs ( g_fit ) ) print ( np . abs ( v_fit ) )   else :          g_fit = [ ] v_fit = [ ]  g_fit = np . append ( g_fit , 1. ) v_fit = np . append ( v_fit , zbl ) if caltable :          allsites = list ( set ( scan [ <str> ] ) . union ( set ( scan [ <str> ] ) ) ) caldict = { } for site in allsites :              if site in sites :                  site_key = tkey [ site ]  else :                  site_key = - 1  rscale = g_fit [ site_key ] ** - 1 lscale = g_fit [ site_key ] ** - 1 caldict [ site ] = np . array ( ( scan [ <str> ] [ 0 ] , rscale , lscale ) , dtype = DTCAL )  out = caldict  else :          g1_fit = g_fit [ g1_keys ] g2_fit = g_fit [ g2_keys ] gij_inv = ( g1_fit * g2_fit . conj ( ) ) ** ( - 1 ) if polrep == <str> :              for vistype in [ <str> , <str> , <str> , <str> ] :                  scan [ vistype ] *= gij_inv  for sigtype in [ <str> , <str> , <str> , <str> ] :                  scan [ sigtype ] *= np . abs ( gij_inv )   elif polrep == <str> :              for vistype in [ <str> , <str> , <str> , <str> ] :                  scan [ vistype ] *= gij_inv  for sigtype in [ <str> , <str> , <str> , <str> ] :                  scan [ sigtype ] *= np . abs ( gij_inv )   out = scan  return out  def init ( x ) :      global counter counter = x  def get_network_scan_cal ( args ) :      return get_network_scan_cal2 ( * args )  def get_network_scan_cal2 ( i , n , scan , zbl , sites , cluster_data , polrep , pol , method , pad_amp , gain_tol , caltable , show_solution , debias , msgtype ) :      if n > 1 :          global counter counter . increment ( ) prog_msg ( counter . value ( ) , counter . maxval , msgtype , counter . value ( ) - 1 )  return network_cal_scan ( scan , zbl , sites , cluster_data , polrep = polrep , pol = pol , zbl_uvidst_max = ZBLCUTOFF , method = method , caltable = caltable , show_solution = show_solution , pad_amp = pad_amp , gain_tol = gain_tol , debias = debias )   