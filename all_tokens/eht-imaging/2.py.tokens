from __future__ import division from __future__ import print_function from builtins import str from builtins import range from builtins import object import string , copy import numpy as np import numpy . lib . recfunctions as rec import matplotlib as mpl import matplotlib . pyplot as plt import scipy . optimize as opt import itertools as it import sys import copy import ehtim . image import ehtim . io . save import ehtim . io . load import ehtim . observing . obs_simulate as simobs from ehtim . const_def import * from ehtim . observing . obs_helpers import * from ehtim . statistics . dataframes import * from ehtim . statistics . stats import * import scipy . spatial as spatial import scipy . optimize as opt import warnings warnings . filterwarnings ( <str> , message = <str> ) RAPOS = 0 DECPOS = 1 RFPOS = 2 BWPOS = 3 DATPOS = 4 TARRPOS = 5 class Obsdata ( object ) :      def __init__ ( self , ra , dec , rf , bw , datatable , tarr , scantable = None , polrep = <str> , source = SOURCE_DEFAULT , mjd = MJD_DEFAULT , timetype = <str> , ampcal = True , phasecal = True , opacitycal = True , dcal = True , frcal = True ) :          if len ( datatable ) == 0 :              raise Exception ( <str> )  if not ( datatable . dtype in [ DTPOL_STOKES , DTPOL_CIRC ] ) :              raise Exception ( <str> )  if polrep == <str> :              self . polrep = <str> self . poldict = POLDICT_STOKES self . poltype = DTPOL_STOKES  elif polrep == <str> :              self . polrep = <str> self . poldict = POLDICT_CIRC self . poltype = DTPOL_CIRC  else :              raise Exception ( <str> )  self . source = str ( source ) self . ra = float ( ra ) self . dec = float ( dec ) self . rf = float ( rf ) self . bw = float ( bw ) self . ampcal = bool ( ampcal ) self . phasecal = bool ( phasecal ) self . opacitycal = bool ( opacitycal ) self . dcal = bool ( dcal ) self . frcal = bool ( frcal ) if timetype not in [ <str> , <str> ] :              raise Exception ( <str> )  self . timetype = timetype self . data = datatable self . scans = scantable self . tarr = tarr self . tkey = { self . tarr [ i ] [ <str> ] : i for i in range ( len ( self . tarr ) ) } if np . any ( self . tarr [ <str> ] != 0 ) or np . any ( self . tarr [ <str> ] != 0 ) :              self . reorder_tarr_sefd ( )  self . reorder_baselines ( ) times = self . unpack ( [ <str> ] ) [ <str> ] self . tstart = times [ 0 ] self . mjd = int ( mjd ) self . tstop = times [ - 1 ] if self . tstop < self . tstart :              self . tstop += 24.0  self . amp = None self . bispec = None self . cphase = None self . camp = None self . logcamp = None  def obsdata_args ( self ) :          arglist = [ self . ra , self . dec , self . rf , self . bw , self . data , self . tarr ] argdict = { <str> : self . scans , <str> : self . polrep , <str> : self . source , <str> : self . mjd , <str> : self . timetype , <str> : self . ampcal , <str> : self . phasecal , <str> : self . opacitycal , <str> : self . dcal , <str> : self . frcal } return ( arglist , argdict )  def copy ( self ) :          newobs = copy . deepcopy ( self ) return newobs  def switch_polrep ( self , polrep_out = <str> , allow_singlepol = True , singlepol_hand = <str> ) :          if polrep_out not in [ <str> , <str> ] :              raise Exception ( <str> )  if polrep_out == self . polrep :              return self . copy ( )  elif polrep_out == <str> :              data = np . empty ( len ( self . data ) , dtype = DTPOL_STOKES ) rrmask = np . isnan ( self . data [ <str> ] ) llmask = np . isnan ( self . data [ <str> ] ) for f in DTPOL_STOKES :                  f = f [ 0 ] if f in [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] :                      data [ f ] = self . data [ f ]  elif f == <str> :                      data [ f ] = 0.5 * ( self . data [ <str> ] + self . data [ <str> ] )  elif f == <str> :                      data [ f ] = 0.5 * ( self . data [ <str> ] + self . data [ <str> ] )  elif f == <str> :                      data [ f ] = 0.5j * ( self . data [ <str> ] - self . data [ <str> ] )  elif f == <str> :                      data [ f ] = 0.5 * ( self . data [ <str> ] - self . data [ <str> ] )  elif f in [ <str> , <str> ] :                      data [ f ] = 0.5 * np . sqrt ( self . data [ <str> ] ** 2 + self . data [ <str> ] ** 2 )  elif f in [ <str> , <str> ] :                      data [ f ] = 0.5 * np . sqrt ( self . data [ <str> ] ** 2 + self . data [ <str> ] ** 2 )   if allow_singlepol :                  data [ <str> ] [ rrmask ] = self . data [ <str> ] [ rrmask ] data [ <str> ] [ rrmask ] = self . data [ <str> ] [ rrmask ] data [ <str> ] [ llmask ] = self . data [ <str> ] [ llmask ] data [ <str> ] [ llmask ] = self . data [ <str> ] [ llmask ]   elif polrep_out == <str> :              data = np . empty ( len ( self . data ) , dtype = DTPOL_CIRC ) Vmask = np . isnan ( self . data [ <str> ] ) for f in DTPOL_CIRC :                  f = f [ 0 ] if f in [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] :                      data [ f ] = self . data [ f ]  elif f == <str> :                      data [ f ] = ( self . data [ <str> ] + self . data [ <str> ] )  elif f == <str> :                      data [ f ] = ( self . data [ <str> ] - self . data [ <str> ] )  elif f == <str> :                      data [ f ] = ( self . data [ <str> ] + 1j * self . data [ <str> ] )  elif f == <str> :                      data [ f ] = ( self . data [ <str> ] - 1j * self . data [ <str> ] )  elif f in [ <str> , <str> ] :                      data [ f ] = np . sqrt ( self . data [ <str> ] ** 2 + self . data [ <str> ] ** 2 )  elif f in [ <str> , <str> ] :                      data [ f ] = np . sqrt ( self . data [ <str> ] ** 2 + self . data [ <str> ] ** 2 )   if allow_singlepol :                  prefix = singlepol_hand . lower ( ) + singlepol_hand . lower ( ) if prefix not in [ <str> , <str> ] :                      raise Exception ( <str> )  data [ prefix + <str> ] [ Vmask ] = self . data [ <str> ] [ Vmask ] data [ prefix + <str> ] [ Vmask ] = self . data [ <str> ] [ Vmask ]   arglist , argdict = self . obsdata_args ( ) arglist [ DATPOS ] = data argdict [ <str> ] = polrep_out newobs = Obsdata ( * arglist , ** argdict ) return newobs  def reorder_baselines ( self ) :          datatable = self . data . copy ( ) datalist = [ ] for key , group in it . groupby ( datatable , lambda x : x [ <str> ] ) :              datalist . append ( np . array ( [ obs for obs in group ] ) )  obsdata = [ ] for tlist in datalist :              blpairs = [ ] for dat in tlist :                  if not ( set ( ( dat [ <str> ] , dat [ <str> ] ) ) ) in blpairs :                       if ( self . tkey [ dat [ <str> ] ] < self . tkey [ dat [ <str> ] ] ) :                          ( dat [ <str> ] , dat [ <str> ] ) = ( dat [ <str> ] , dat [ <str> ] ) ( dat [ <str> ] , dat [ <str> ] ) = ( dat [ <str> ] , dat [ <str> ] ) dat [ <str> ] = - dat [ <str> ] dat [ <str> ] = - dat [ <str> ] if self . polrep == <str> :                              dat [ <str> ] = np . conj ( dat [ <str> ] ) dat [ <str> ] = np . conj ( dat [ <str> ] ) dat [ <str> ] = np . conj ( dat [ <str> ] ) dat [ <str> ] = np . conj ( dat [ <str> ] )  elif self . polrep == <str> :                              dat [ <str> ] = np . conj ( dat [ <str> ] ) dat [ <str> ] = np . conj ( dat [ <str> ] ) rl = dat [ <str> ] . copy ( ) lr = dat [ <str> ] . copy ( ) dat [ <str> ] = np . conj ( lr ) dat [ <str> ] = np . conj ( rl )  else :                              raise Exception ( <str> )   blpairs . append ( set ( ( dat [ <str> ] , dat [ <str> ] ) ) ) obsdata . append ( dat )    obsdata = np . array ( obsdata , dtype = self . poltype ) obsdata = obsdata [ np . argsort ( obsdata , order = [ <str> , <str> ] ) ] self . data = obsdata return  def reorder_tarr_sefd ( self ) :          sorted_list = sorted ( self . tarr , key = lambda x : np . sqrt ( x [ <str> ] ** 2 + x [ <str> ] ** 2 ) ) self . tarr = np . array ( sorted_list , dtype = DTARR ) self . tkey = { self . tarr [ i ] [ <str> ] : i for i in range ( len ( self . tarr ) ) } self . reorder_baselines ( ) return  def reorder_tarr_snr ( self ) :          snr = self . unpack ( [ <str> , <str> , <str> ] ) snr_median = [ np . median ( snr [ ( snr [ <str> ] == site ) + ( snr [ <str> ] == site ) ] [ <str> ] ) for site in self . tarr [ <str> ] ] idx = np . argsort ( snr_median ) [ : : - 1 ] self . tarr = self . tarr [ idx ] self . tkey = { self . tarr [ i ] [ <str> ] : i for i in range ( len ( self . tarr ) ) } self . reorder_baselines ( ) return  def reorder_tarr_random ( self ) :          idx = np . arange ( len ( self . tarr ) ) np . random . shuffle ( idx ) self . tarr = self . tarr [ idx ] self . tkey = { self . tarr [ i ] [ <str> ] : i for i in range ( len ( self . tarr ) ) } self . reorder_baselines ( ) return  def data_conj ( self ) :          data = np . empty ( 2 * len ( self . data ) , dtype = self . poltype ) for f in self . poltype :              f = f [ 0 ] if f in [ <str> , <str> , <str> , <str> ] :                  if f [ - 1 ] == <str> : f2 = f [ : - 1 ] + <str> else : f2 = f [ : - 1 ] + <str> data [ f ] = np . hstack ( ( self . data [ f ] , self . data [ f2 ] ) )  elif f in [ <str> , <str> ] :                  data [ f ] = np . hstack ( ( self . data [ f ] , - self . data [ f ] ) )  elif f in [ self . poldict [ <str> ] , self . poldict [ <str> ] , self . poldict [ <str> ] , self . poldict [ <str> ] ] :                  if self . polrep == <str> :                      data [ f ] = np . hstack ( ( self . data [ f ] , np . conj ( self . data [ f ] ) ) )  elif self . polrep == <str> :                      if f in [ <str> , <str> ] :                          data [ f ] = np . hstack ( ( self . data [ f ] , np . conj ( self . data [ f ] ) ) )  elif f == <str> :                          data [ f ] = np . hstack ( ( self . data [ <str> ] , np . conj ( self . data [ <str> ] ) ) )  elif f == <str> :                          data [ f ] = np . hstack ( ( self . data [ <str> ] , np . conj ( self . data [ <str> ] ) ) )   else :                      raise Exception ( <str> )   else :                  data [ f ] = np . hstack ( ( self . data [ f ] , self . data [ f ] ) )   data = data [ np . argsort ( data [ <str> ] ) ] return data  def tlist ( self , conj = False , t_gather = 0. , scan_gather = False ) :          if conj :              data = self . data_conj ( )  else :              data = self . data  datalist = [ ] if t_gather <= 0.0 and not scan_gather :              for key , group in it . groupby ( data , lambda x : x [ <str> ] ) :                  datalist . append ( np . array ( [ obs for obs in group ] ) )   elif t_gather > 0.0 and not scan_gather :              for key , group in it . groupby ( data , lambda x : int ( x [ <str> ] / ( t_gather / 3600.0 ) ) ) :                  datalist . append ( np . array ( [ obs for obs in group ] ) )   else :              if np . any ( self . scans == None ) or len ( self . scans ) == 0 :                  print ( <str> ) self . add_scans ( )  for key , group in it . groupby ( data , lambda x : np . searchsorted ( self . scans [ : , 0 ] , x [ <str> ] ) ) :                  datalist . append ( np . array ( [ obs for obs in group ] ) )   return np . array ( datalist )  def bllist ( self , conj = False ) :          if conj :              data = self . data_conj ( )  else :              data = self . data  datalist = [ ] idx = np . lexsort ( ( data [ <str> ] , data [ <str> ] ) ) for key , group in it . groupby ( data [ idx ] , lambda x : set ( ( x [ <str> ] , x [ <str> ] ) ) ) :              datalist . append ( np . array ( [ obs for obs in group ] ) )  return np . array ( datalist )  def unpack_bl ( self , site1 , site2 , fields , ang_unit = <str> , debias = False , timetype = False ) :          if timetype == False :              timetype = self . timetype  if timetype not in [ <str> , <str> , <str> , <str> ] :              raise Exception ( <str> )  allfields = [ <str> ] if not isinstance ( fields , list ) : allfields . append ( fields ) else :              for i in range ( len ( fields ) ) : allfields . append ( fields [ i ] )  allout = [ ] tlist = self . tlist ( conj = True ) for scan in tlist :              for obs in scan :                  if ( obs [ <str> ] , obs [ <str> ] ) == ( site1 , site2 ) :                      obs = np . array ( [ obs ] ) out = self . unpack_dat ( obs , allfields , ang_unit = ang_unit , debias = debias , timetype = timetype ) allout . append ( out )    return np . array ( allout )  def unpack ( self , fields , mode = <str> , ang_unit = <str> , debias = False , conj = False , timetype = False ) :          if not mode in ( <str> , <str> , <str> ) :              raise Exception ( <str> )  if not isinstance ( fields , list ) : fields = [ fields ] if mode == <str> :              if conj :                  data = self . data_conj ( )  else :                  data = self . data  allout = self . unpack_dat ( data , fields , ang_unit = ang_unit , debias = debias , timetype = timetype )  elif mode == <str> :              allout = [ ] tlist = self . tlist ( conj = True ) for scan in tlist :                  out = self . unpack_dat ( scan , fields , ang_unit = ang_unit , debias = debias , timetype = timetype ) allout . append ( out )   elif mode == <str> :              allout = [ ] bllist = self . bllist ( ) for bl in bllist :                  out = self . unpack_dat ( bl , fields , ang_unit = ang_unit , debias = debias , timetype = timetype ) allout . append ( out )   return allout  def unpack_dat ( self , data , fields , conj = False , ang_unit = <str> , debias = False , timetype = False ) :          if ang_unit == <str> : angle = DEGREE else : angle = 1.0 if type ( fields ) is str :              fields = [ fields ]  if not timetype :              timetype = self . timetype  if timetype not in [ <str> , <str> , <str> , <str> ] :              raise Exception ( <str> )  allout = [ ] for field in fields :              if field in [ <str> , <str> , <str> ] :                  out = data [ <str> ] ty = <str>  elif field in [ <str> , <str> , <str> , <str> , <str> ] :                  out = data [ field ] ty = <str>  elif field in [ <str> ] :                  out = np . abs ( data [ <str> ] + 1j * data [ <str> ] ) ty = <str>  elif field in [ <str> , <str> , <str> , <str> ] :                  sites = data [ <str> ] keys = [ self . tkey [ site ] for site in sites ] tdata = self . tarr [ keys ] out = sites ty = <str>  elif field in [ <str> , <str> , <str> , <str> ] :                  sites = data [ <str> ] keys = [ self . tkey [ site ] for site in sites ] tdata = self . tarr [ keys ] out = sites ty = <str>  elif field in [ <str> , <str> , <str> , <str> , <str> , <str> ] :                  ty = <str> if self . polrep == <str> :                      out = data [ <str> ] sig = data [ <str> ]  elif self . polrep == <str> :                      out = 0.5 * ( data [ <str> ] + data [ <str> ] ) sig = 0.5 * np . sqrt ( data [ <str> ] ** 2 + data [ <str> ] ** 2 )   elif field in [ <str> , <str> , <str> , <str> , <str> , <str> ] :                  ty = <str> if self . polrep == <str> :                      out = data [ <str> ] sig = data [ <str> ]  elif self . polrep == <str> :                      out = 0.5 * ( data [ <str> ] + data [ <str> ] ) sig = 0.5 * np . sqrt ( data [ <str> ] ** 2 + data [ <str> ] ** 2 )   elif field in [ <str> , <str> , <str> , <str> , <str> , <str> ] :                  ty = <str> if self . polrep == <str> :                      out = data [ <str> ] sig = data [ <str> ]  elif self . polrep == <str> :                      out = 0.5j * ( data [ <str> ] - data [ <str> ] ) sig = 0.5 * np . sqrt ( data [ <str> ] ** 2 + data [ <str> ] ** 2 )   elif field in [ <str> , <str> , <str> , <str> , <str> , <str> ] :                  ty = <str> if self . polrep == <str> :                      out = data [ <str> ] sig = data [ <str> ]  elif self . polrep == <str> :                      out = 0.5 * ( data [ <str> ] - data [ <str> ] ) sig = 0.5 * np . sqrt ( data [ <str> ] ** 2 + data [ <str> ] ** 2 )   elif field in [ <str> , <str> , <str> , <str> , <str> , <str> ] :                  ty = <str> if self . polrep == <str> :                      out = data [ <str> ] + 1j * data [ <str> ] sig = np . sqrt ( data [ <str> ] ** 2 + data [ <str> ] ** 2 )  elif self . polrep == <str> :                      out = data [ <str> ] sig = data [ <str> ]   elif field in [ <str> , <str> , <str> , <str> , <str> , <str> ] :                  ty = <str> if self . polrep == <str> :                      out = ( data [ <str> ] + 1j * data [ <str> ] ) / data [ <str> ] sig = merr ( data [ <str> ] , data [ <str> ] , data [ <str> ] , data [ <str> ] , out )  elif self . polrep == <str> :                      out = 2 * data [ <str> ] / ( data [ <str> ] + data [ <str> ] ) sig = merr2 ( data [ <str> ] , data [ <str> ] , data [ <str> ] , 0.5 * ( data [ <str> ] + data [ <str> ] ) , out )   elif field in [ <str> , <str> , <str> , <str> , <str> , <str> ] :                  ty = <str> if self . polrep == <str> :                      out = data [ <str> ] + data [ <str> ] sig = np . sqrt ( data [ <str> ] ** 2 + data [ <str> ] ** 2 )  elif self . polrep == <str> :                      out = data [ <str> ] sig = data [ <str> ]   elif field in [ <str> , <str> , <str> , <str> , <str> , <str> ] :                  ty = <str> if self . polrep == <str> :                      out = data [ <str> ] - data [ <str> ] sig = np . sqrt ( data [ <str> ] ** 2 + data [ <str> ] ** 2 )  elif self . polrep == <str> :                      out = data [ <str> ] sig = data [ <str> ]   elif field in [ <str> , <str> , <str> , <str> , <str> , <str> ] :                  ty = <str> if self . polrep == <str> :                      out = data [ <str> ] + 1j * data [ <str> ] sig = np . sqrt ( data [ <str> ] ** 2 + data [ <str> ] ** 2 )  elif self . polrep == <str> :                      out = data [ <str> ] sig = data [ <str> ]   elif field in [ <str> , <str> , <str> , <str> , <str> , <str> ] :                  ty = <str> if self . polrep == <str> :                      out = data [ <str> ] - 1j * data [ <str> ] sig = np . sqrt ( data [ <str> ] ** 2 + data [ <str> ] ** 2 )  elif self . polrep == <str> :                      out = data [ <str> ] sig = data [ <str> ]   else : raise Exception ( <str> % field + <str> + <str> . join ( FIELDS ) ) if field in [ <str> ] and timetype == <str> :                  out = gmst_to_utc ( out , self . mjd )  if field in [ <str> ] and timetype == <str> :                  out = utc_to_gmst ( out , self . mjd )  if field in [ <str> , <str> , <str> , <str> , <str> , <str> ] :                  if self . timetype == <str> :                      times_sid = data [ <str> ]  else :                      times_sid = utc_to_gmst ( data [ <str> ] , self . mjd )  thetas = np . mod ( ( times_sid - self . ra ) * HOUR , 2 * np . pi ) coords = recarr_to_ndarr ( tdata [ [ <str> , <str> , <str> ] ] , <str> ) el_angle = elev ( earthrot ( coords , thetas ) , self . sourcevec ( ) ) latlon = xyz_2_latlong ( coords ) hr_angles = hr_angle ( times_sid * HOUR , latlon [ : , 1 ] , self . ra * HOUR ) if field in [ <str> , <str> ] :                      out = el_angle / angle ty = <str>  if field in [ <str> , <str> ] :                      out = hr_angles / angle ty = <str>  if field in [ <str> , <str> ] :                      par_ang = par_angle ( hr_angles , latlon [ : , 0 ] , self . dec * DEGREE ) out = par_ang / angle ty = <str>   if field in [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] :                  out = np . abs ( out ) if debias :                      out = amp_debias ( out , sig )  ty = <str>  elif field in [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] :                  out = np . abs ( sig ) ty = <str>  elif field in [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] :                  out = np . angle ( out ) / angle ty = <str>  elif field in [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] :                  out = np . abs ( sig ) / np . abs ( out ) / angle ty = <str>  elif field in [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] :                  out = np . abs ( out ) / np . abs ( sig ) ty = <str>  out = np . array ( out , dtype = [ ( field , ty ) ] ) if len ( allout ) > 0 :                  allout = rec . merge_arrays ( ( allout , out ) , asrecarray = True , flatten = True )  else :                  allout = out   return allout  def sourcevec ( self ) :          sourcevec = np . array ( [ np . cos ( self . dec * DEGREE ) , 0 , np . sin ( self . dec * DEGREE ) ] ) return sourcevec  def res ( self ) :          res = 1.0 / np . max ( self . unpack ( <str> ) [ <str> ] ) return res  def split_obs ( self ) :          print ( <str> + str ( len ( self . tlist ( ) ) ) + <str> ) arglist , argdict = self . obsdata_args ( ) splitlist = [ ] for tdata in self . tlist ( ) :              arglist [ DATPOS ] = tdata splitlist . append ( Obsdata ( * arglist , ** argdict ) )  return splitlist  def chisq ( self , im , dtype = <str> , pol = <str> , ttype = <str> , mask = [ ] , ** kwargs ) :          import ehtim . imaging . imager_utils as iu if pol not in im . _imdict . keys ( ) :              raise Exception ( pol + <str> )  ( data , sigma , A ) = iu . chisqdata ( self , im , mask , dtype , pol = pol , ttype = ttype , ** kwargs ) chisq = iu . chisq ( im . _imdict [ pol ] , A , data , sigma , dtype , ttype = ttype , mask = mask ) return chisq  def recompute_uv ( self ) :          times = self . data [ <str> ] site1 = self . data [ <str> ] site2 = self . data [ <str> ] arr = ehtim . array . Array ( self . tarr ) print ( <str> % ( self . mjd , self . ra , self . dec , self . rf / 1.e9 ) ) ( timesout , uout , vout ) = compute_uv_coordinates ( arr , site1 , site2 , times , self . mjd , self . ra , self . dec , self . rf , timetype = self . timetype , elevmin = 0 , elevmax = 90 ) if len ( timesout ) != len ( times ) :              raise Exception ( <str> )  datatable = self . data . copy ( ) datatable [ <str> ] = uout datatable [ <str> ] = vout arglist , argdict = self . obsdata_args ( ) arglist [ DATPOS ] = np . array ( datatable ) out = Obsdata ( * arglist , ** argdict ) return out  def avg_coherent ( self , inttime , scan_avg = False ) :          if ( scan_avg == True ) & ( getattr ( self . scans , <str> , None ) is None or len ( self . scans ) == 0 ) :              print ( <str> ) scan_avg = False  if inttime <= 0.0 and scan_avg == False :              print ( <str> ) return self . copy ( )  vis_avg = coh_avg_vis ( self , dt = inttime , return_type = <str> , err_type = <str> , scan_avg = scan_avg ) arglist , argdict = self . obsdata_args ( ) arglist [ DATPOS ] = vis_avg out = Obsdata ( * arglist , ** argdict ) return out  def avg_incoherent ( self , inttime , scan_avg = False , debias = True , err_type = <str> ) :          print ( <str> ) amp_rec = incoh_avg_vis ( self , dt = inttime , debias = debias , scan_avg = scan_avg , return_type = <str> , rec_type = <str> , err_type = err_type ) arglist , argdict = self . obsdata_args ( ) arglist [ DATPOS ] = amp_rec out = Obsdata ( * arglist , ** argdict ) return out  def add_amp ( self , avg_time = 0 , scan_avg = False , debias = True , err_type = <str> , return_type = <str> , round_s = 0.1 , snrcut = 0. ) :          if len ( set ( [ x [ 0 ] for x in list ( self . unpack ( <str> ) ) ] ) ) > 1 :              tint0 = np . min ( np . diff ( np . asarray ( sorted ( list ( set ( [ x [ 0 ] for x in list ( self . unpack ( <str> ) ) ] ) ) ) ) ) ) * 3600.  else :              tint0 = 0.0  if avg_time <= tint0 :              adf = make_amp ( self , debias = debias , round_s = round_s ) if return_type == <str> :                  adf = df_to_rec ( adf , <str> )  print ( <str> )  else :              adf = incoh_avg_vis ( self , dt = avg_time , debias = debias , scan_avg = scan_avg , return_type = return_type , rec_type = <str> , err_type = err_type )  adf = adf [ adf [ <str> ] / adf [ <str> ] > snrcut ] self . amp = adf print ( <str> % avg_time ) return  def add_bispec ( self , avg_time = 0 , return_type = <str> , count = <str> , snrcut = 0. , err_type = <str> , num_samples = 1000 , round_s = 0.1 , uv_min = False ) :          if len ( set ( [ x [ 0 ] for x in list ( self . unpack ( <str> ) ) ] ) ) > 1 :              tint0 = np . min ( np . diff ( np . asarray ( sorted ( list ( set ( [ x [ 0 ] for x in list ( self . unpack ( <str> ) ) ] ) ) ) ) ) ) * 3600.  else :              tint0 = 0  if avg_time > tint0 :              cdf = make_bsp_df ( self , mode = <str> , round_s = round_s , count = count , snrcut = 0. , uv_min = uv_min ) cdf = average_bispectra ( cdf , avg_time , return_type = return_type , num_samples = num_samples , snrcut = snrcut )  else :              cdf = make_bsp_df ( self , mode = <str> , round_s = round_s , count = count , snrcut = snrcut , uv_min = uv_min ) print ( <str> ) if return_type == <str> :                  cdf = df_to_rec ( cdf , <str> )   self . bispec = cdf print ( <str> % avg_time ) return  def add_cphase ( self , avg_time = 0 , return_type = <str> , count = <str> , snrcut = 0. , err_type = <str> , num_samples = 1000 , round_s = 0.1 , uv_min = False ) :          if len ( set ( [ x [ 0 ] for x in list ( self . unpack ( <str> ) ) ] ) ) > 1 :              tint0 = np . min ( np . diff ( np . asarray ( sorted ( list ( set ( [ x [ 0 ] for x in list ( self . unpack ( <str> ) ) ] ) ) ) ) ) ) * 3600.  else :              tint0 = 0  if avg_time > tint0 :              cdf = make_cphase_df ( self , mode = <str> , round_s = round_s , count = count , snrcut = 0. , uv_min = uv_min ) cdf = average_cphases ( cdf , avg_time , return_type = return_type , err_type = err_type , num_samples = num_samples , snrcut = snrcut )  else :              cdf = make_cphase_df ( self , mode = <str> , round_s = round_s , count = count , snrcut = snrcut , uv_min = uv_min ) if return_type == <str> :                  cdf = df_to_rec ( cdf , <str> )  print ( <str> )  self . cphase = cdf print ( <str> % avg_time ) return  def add_camp ( self , avg_time = 0 , return_type = <str> , ctype = <str> , count = <str> , debias = True , snrcut = 0. , err_type = <str> , num_samples = 1000 , round_s = 0.1 ) :          if len ( set ( [ x [ 0 ] for x in list ( self . unpack ( <str> ) ) ] ) ) > 1 :              tint0 = np . min ( np . diff ( np . asarray ( sorted ( list ( set ( [ x [ 0 ] for x in list ( self . unpack ( <str> ) ) ] ) ) ) ) ) ) * 3600.  else :              tint0 = 0  if avg_time > tint0 :              foo = self . avg_incoherent ( avg_time , debias = debias , err_type = err_type )  else :              foo = self  cdf = make_camp_df ( foo , ctype = ctype , debias = False , count = count , round_s = round_s , snrcut = snrcut ) if ctype == <str> :              print ( <str> )  elif ctype == <str> :              print ( <str> )  if return_type == <str> :              cdf = df_to_rec ( cdf , <str> )  if ctype == <str> :              self . logcamp = cdf print ( <str> % avg_time )  elif ctype == <str> :              self . camp = cdf print ( <str> % avg_time )  return  def add_logcamp ( self , avg_time = 0 , return_type = <str> , ctype = <str> , count = <str> , debias = True , snrcut = 0. , err_type = <str> , num_samples = 1000 , round_s = 0.1 ) :          self . add_camp ( return_type = return_type , ctype = <str> , count = count , debias = debias , snrcut = snrcut , avg_time = avg_time , err_type = err_type , num_samples = num_samples , round_s = round_s ) return  def add_all ( self , avg_time = 0 , return_type = <str> , count = <str> , debias = True , snrcut = 0. , err_type = <str> , num_samples = 1000 , round_s = 0.1 ) :          self . add_amp ( return_type = return_type , avg_time = avg_time , debias = debias , err_type = err_type ) self . add_bispec ( return_type = return_type , count = count , avg_time = avg_time , snrcut = snrcut , err_type = err_type , num_samples = num_samples , round_s = round_s ) self . add_cphase ( return_type = return_type , count = count , avg_time = avg_time , snrcut = snrcut , err_type = err_type , num_samples = num_samples , round_s = round_s ) self . add_camp ( return_type = return_type , ctype = <str> , count = count , debias = debias , snrcut = snrcut , avg_time = avg_time , err_type = err_type , num_samples = num_samples , round_s = round_s ) self . add_camp ( return_type = return_type , ctype = <str> , count = count , debias = debias , snrcut = snrcut , avg_time = avg_time , err_type = err_type , num_samples = num_samples , round_s = round_s ) return  def add_scans ( self , info = <str> , filepath = <str> , dt = 0.0165 , margin = 0.0001 ) :          if info == <str> :              times_uni = np . asarray ( sorted ( list ( set ( self . data [ <str> ] ) ) ) ) scans = np . zeros_like ( times_uni ) scan_id = 0 for cou in range ( len ( times_uni ) - 1 ) :                  scans [ cou ] = scan_id if ( times_uni [ cou + 1 ] - times_uni [ cou ] > dt ) :                      scan_id += 1   scans [ - 1 ] = scan_id scanlist = np . asarray ( [ np . asarray ( [ np . min ( times_uni [ scans == cou ] ) - margin , np . max ( times_uni [ scans == cou ] ) + margin ] ) for cou in range ( int ( scans [ - 1 ] ) + 1 ) ] )  elif info == <str> :               scanlist = np . loadtxt ( filepath )  elif info == <str> :              vex0 = ehtim . vex . Vex ( filepath ) t_min = [ vex0 . sched [ x ] [ <str> ] for x in range ( len ( vex0 . sched ) ) ] duration = [ ] for x in range ( len ( vex0 . sched ) ) :                  duration_foo = max ( [ vex0 . sched [ x ] [ <str> ] [ y ] [ <str> ] for y in range ( len ( vex0 . sched [ x ] [ <str> ] ) ) ] ) duration . append ( duration_foo )  t_max = [ tmin + dur / 3600. for ( tmin , dur ) in zip ( t_min , duration ) ] scanlist = np . array ( [ [ tmin , tmax ] for ( tmin , tmax ) in zip ( t_min , t_max ) ] )  else :              print ( <str> ) scanlist = None  self . scans = scanlist return  def cleanbeam ( self , npix , fov , pulse = PULSE_DEFAULT ) :          im = ehtim . image . make_square ( self , npix , fov , pulse = pulse ) beamparams = self . fit_beam ( ) im = im . add_gauss ( 1.0 , beamparams ) return im  def fit_beam ( self , weighting = <str> , units = <str> ) :          def fit_chisq ( beamparams , db_coeff ) :              ( fwhm_maj2 , fwhm_min2 , theta ) = beamparams a = 4 * np . log ( 2 ) * ( np . cos ( theta ) ** 2 / fwhm_min2 + np . sin ( theta ) ** 2 / fwhm_maj2 ) b = 4 * np . log ( 2 ) * ( np . cos ( theta ) ** 2 / fwhm_maj2 + np . sin ( theta ) ** 2 / fwhm_min2 ) c = 8 * np . log ( 2 ) * np . cos ( theta ) * np . sin ( theta ) * ( 1.0 / fwhm_maj2 - 1.0 / fwhm_min2 ) gauss_coeff = np . array ( ( a , b , c ) ) chisq = np . sum ( ( np . array ( db_coeff ) - gauss_coeff ) ** 2 ) return chisq  u = self . unpack ( <str> ) [ <str> ] v = self . unpack ( <str> ) [ <str> ] sigma = self . unpack ( <str> ) [ <str> ] n = float ( len ( u ) ) weights = np . ones ( u . shape ) if weighting == <str> :              weights = 1. / sigma ** 2  abc = ( 2. * np . pi ** 2 / np . sum ( weights ) ) * np . array ( [ np . sum ( weights * u ** 2 ) , np . sum ( weights * v ** 2 ) , 2 * np . sum ( weights * u * v ) ] ) abc = 1e-20 * abc guess = [ ( 50 ) ** 2 , ( 50 ) ** 2 , 0.0 ] params = opt . minimize ( fit_chisq , guess , args = ( abc , ) , method = <str> ) if params . x [ 0 ] > params . x [ 1 ] :              fwhm_maj = 1e-10 * np . sqrt ( params . x [ 0 ] ) fwhm_min = 1e-10 * np . sqrt ( params . x [ 1 ] ) theta = np . mod ( params . x [ 2 ] , np . pi )  else :              fwhm_maj = 1e-10 * np . sqrt ( params . x [ 1 ] ) fwhm_min = 1e-10 * np . sqrt ( params . x [ 0 ] ) theta = np . mod ( params . x [ 2 ] + np . pi / 2.0 , np . pi )  gparams = np . array ( ( fwhm_maj , fwhm_min , theta ) ) if units == <str> :              gparams [ 0 ] /= RADPERUAS gparams [ 1 ] /= RADPERUAS gparams [ 2 ] *= 180. / np . pi  return gparams  def dirtybeam ( self , npix , fov , pulse = PULSE_DEFAULT , weighting = <str> ) :          pdim = fov / npix sigma = self . unpack ( <str> ) [ <str> ] u = self . unpack ( <str> ) [ <str> ] v = self . unpack ( <str> ) [ <str> ] if weighting == <str> :              weights = 1. / sigma ** 2  else :              weights = np . ones ( u . shape )  xlist = np . arange ( 0 , - npix , - 1 ) * pdim + ( pdim * npix ) / 2.0 - pdim / 2.0 im = np . array ( [ [ np . mean ( weights * np . cos ( - 2 * np . pi * ( i * u + j * v ) ) ) for i in xlist ] for j in xlist ] ) im = im [ 0 : npix , 0 : npix ] im = im / np . sum ( im ) src = self . source + <str> outim = ehtim . image . Image ( im , pdim , self . ra , self . dec , rf = self . rf , source = src , mjd = self . mjd , pulse = pulse ) return outim  def dirtyimage ( self , npix , fov , pulse = PULSE_DEFAULT , weighting = <str> ) :          pdim = fov / npix u = self . unpack ( <str> ) [ <str> ] v = self . unpack ( <str> ) [ <str> ] sigma = self . unpack ( <str> ) [ <str> ] xlist = np . arange ( 0 , - npix , - 1 ) * pdim + ( pdim * npix ) / 2.0 - pdim / 2.0 if weighting == <str> :              weights = 1. / sigma ** 2  else :              weights = np . ones ( u . shape )  dim = np . array ( [ [ np . mean ( weights * np . cos ( - 2 * np . pi * ( i * u + j * v ) ) ) for i in xlist ] for j in xlist ] ) normfac = 1. / np . sum ( dim ) for label in [ <str> , <str> , <str> , <str> ] :              visname = self . poldict [ label ] vis = self . unpack ( visname ) [ visname ] im = np . array ( [ [ np . mean ( weights * ( np . real ( vis ) * np . cos ( - 2 * np . pi * ( i * u + j * v ) ) - np . imag ( vis ) * np . sin ( - 2 * np . pi * ( i * u + j * v ) ) ) ) for i in xlist ] for j in xlist ] ) im = im * normfac im = im [ 0 : npix , 0 : npix ] if label == <str> :                  out = ehtim . image . Image ( im , pdim , self . ra , self . dec , polrep = self . polrep , rf = self . rf , source = self . source , mjd = self . mjd , pulse = pulse )  else :                  pol = { vis_poldict [ key ] : key for key in vis_poldict . keys ( ) } [ visname ] out . add_pol_image ( im , pol )   return out  def rescale_zbl ( self , totflux , uv_max , debias = True ) :          obs_zerobl = self . flag_uvdist ( uv_max = uv_max ) obs_zerobl . add_amp ( debias = True ) orig_totflux = np . sum ( obs_zerobl . amp [ <str> ] * ( 1 / obs_zerobl . amp [ <str> ] ** 2 ) ) / np . sum ( 1 / obs_zerobl . amp [ <str> ] ** 2 ) print ( <str> + str ( orig_totflux - totflux ) + <str> + str ( totflux ) + <str> ) obs = self . copy ( ) for j in range ( len ( obs . data ) ) :              if ( obs . data [ <str> ] [ j ] ** 2 + obs . data [ <str> ] [ j ] ** 2 ) ** 0.5 < uv_max :                  obs . data [ <str> ] [ j ] *= totflux / orig_totflux obs . data [ <str> ] [ j ] *= totflux / orig_totflux obs . data [ <str> ] [ j ] *= totflux / orig_totflux obs . data [ <str> ] [ j ] *= totflux / orig_totflux obs . data [ <str> ] [ j ] *= totflux / orig_totflux obs . data [ <str> ] [ j ] *= totflux / orig_totflux obs . data [ <str> ] [ j ] *= totflux / orig_totflux obs . data [ <str> ] [ j ] *= totflux / orig_totflux   return obs  def add_leakage_noise ( self , Dterm_amp = 0.1 , min_noise = 0.01 , debias = False ) :          amp = self . switch_polrep ( <str> ) . unpack ( <str> , debias = debias ) [ <str> ] rlamp = np . nan_to_num ( self . switch_polrep ( <str> ) . unpack ( <str> , debias = debias ) [ <str> ] ) lramp = np . nan_to_num ( self . switch_polrep ( <str> ) . unpack ( <str> , debias = debias ) [ <str> ] ) frac_noise = ( Dterm_amp * rlamp / amp ) ** 2 + ( Dterm_amp * lramp / amp ) ** 2 frac_noise = frac_noise * ( frac_noise > min_noise ) + min_noise * ( frac_noise < min_noise ) out = self . copy ( ) for sigma in [ <str> , <str> , <str> , <str> ] :              try :                  field = self . poldict [ sigma ] out . data [ field ] = ( self . data [ field ] ** 2 + np . abs ( frac_noise * amp ) ** 2 ) ** 0.5  except KeyError :                  continue   return out  def add_fractional_noise ( self , frac_noise , debias = False ) :          amp = self . switch_polrep ( <str> ) . unpack ( <str> , debias = debias ) [ <str> ] out = self . copy ( ) for sigma in [ <str> , <str> , <str> , <str> ] :              try :                  field = self . poldict [ sigma ] out . data [ field ] = ( self . data [ field ] ** 2 + np . abs ( frac_noise * amp ) ** 2 ) ** 0.5  except KeyError :                  continue   return out  def find_amt_fractional_noise ( self , im , dtype = <str> , target = 1.0 , debias = False , maxiter = 200 , ftol = 1e-20 , gtol = 1e-20 ) :          obs = self . copy ( ) def objfunc ( frac_noise ) :              obs_tmp = obs . add_fractional_noise ( frac_noise , debias = debias ) chisq = obs_tmp . chisq ( im , dtype = dtype ) return np . abs ( target - chisq )  optdict = { <str> : maxiter , <str> : ftol , <str> : gtol } res = opt . minimize ( objfunc , 0.0 , method = <str> , options = optdict ) return res . x  def rescale_noise ( self , noise_rescale_factor = 1.0 ) :          datatable = self . data . copy ( ) for d in datatable :              d [ - 4 ] = d [ - 4 ] * noise_rescale_factor d [ - 3 ] = d [ - 3 ] * noise_rescale_factor d [ - 2 ] = d [ - 2 ] * noise_rescale_factor d [ - 1 ] = d [ - 1 ] * noise_rescale_factor  arglist , argdict = self . obsdata_args ( ) arglist [ DATPOS ] = np . array ( datatable ) out = Obsdata ( * arglist , ** argdict ) return out  def estimate_noise_rescale_factor ( self , max_diff_sec = 0.0 , min_num = 10 , median_snr_cut = 0 , count = <str> , vtype = <str> , print_std = False , ) :          if max_diff_sec == 0.0 :              max_diff_sec = 5 * np . median ( self . unpack ( <str> ) [ <str> ] ) print ( <str> , max_diff_sec )  c_phases = self . c_phases ( vtype = vtype , mode = <str> , count = count , ang_unit = <str> ) all_triangles = [ ] for scan in c_phases :              for cphase in scan :                  all_triangles . append ( ( cphase [ 1 ] , cphase [ 2 ] , cphase [ 3 ] ) )   std_list = [ ] print ( <str> % len ( set ( all_triangles ) ) ) i_count = 0 for tri in set ( all_triangles ) :              i_count = i_count + 1 if print_std :                  sys . stdout . write ( <str> % ( i_count , len ( set ( all_triangles ) ) ) ) sys . stdout . flush ( )  all_tri = np . array ( [ [ ] ] ) for scan in c_phases :                  for cphase in scan :                      if cphase [ 1 ] == tri [ 0 ] and cphase [ 2 ] == tri [ 1 ] and cphase [ 3 ] == tri [ 2 ] and not np . isnan ( cphase [ - 2 ] ) and not np . isnan ( cphase [ - 2 ] ) :                          all_tri = np . append ( all_tri , ( ( cphase [ 0 ] , cphase [ - 2 ] , cphase [ - 1 ] ) ) )    all_tri = all_tri . reshape ( int ( len ( all_tri ) / 3 ) , 3 ) if np . median ( np . abs ( all_tri [ : , 1 ] / all_tri [ : , 2 ] ) ) < median_snr_cut :                  if print_std :                      print ( tri , <str> % np . median ( np . abs ( all_tri [ : , 1 ] / all_tri [ : , 2 ] ) ) )  continue  s_list = np . array ( [ ] ) for j in range ( len ( all_tri ) - 1 ) :                  if ( all_tri [ j + 1 , 0 ] - all_tri [ j , 0 ] ) * 3600.0 < max_diff_sec :                      diff = ( all_tri [ j + 1 , 1 ] - all_tri [ j , 1 ] ) % ( 2.0 * np . pi ) if diff > np . pi : diff -= 2.0 * np . pi s_list = np . append ( s_list , diff / ( all_tri [ j , 2 ] ** 2 + all_tri [ j + 1 , 2 ] ** 2 ) ** 0.5 )   if len ( s_list ) > min_num :                  std_list . append ( np . std ( s_list ) ) if print_std == True :                      print ( tri , <str> % ( np . std ( s_list ) , len ( s_list ) ) )   else :                  if print_std == True and len ( all_tri ) > 0 :                      print ( tri , <str> % ( len ( all_tri ) , len ( s_list ) , min_num ) )    if len ( std_list ) == 0 :              print ( <str> ) median = 1.0  else :              median = np . median ( std_list )  return median  def flag_elev ( self , elev_min = 0.0 , elev_max = 90 , output = <str> ) :          el_pairs = self . unpack ( [ <str> , <str> ] ) mask = ( np . min ( ( el_pairs [ <str> ] , el_pairs [ <str> ] ) , axis = 0 ) > elev_min ) * ( np . max ( ( el_pairs [ <str> ] , el_pairs [ <str> ] ) , axis = 0 ) < elev_max ) datatable_kept = self . data . copy ( ) datatable_flagged = self . data . copy ( ) datatable_kept = datatable_kept [ mask ] datatable_flagged = datatable_flagged [ np . invert ( mask ) ] print ( <str> % ( len ( datatable_flagged ) , len ( self . data ) ) ) obs_kept = self . copy ( ) obs_flagged = self . copy ( ) obs_kept . data = datatable_kept obs_flagged . data = datatable_flagged if output == <str> :              return obs_flagged  elif output == <str> :              return { <str> : obs_kept , <str> : obs_flagged }  else :              return obs_kept   def flag_large_fractional_pol ( self , max_fractional_pol = 1.0 , output = <str> ) :          m = np . nan_to_num ( self . unpack ( [ <str> ] ) [ <str> ] ) mask = m < max_fractional_pol datatable_kept = self . data . copy ( ) datatable_flagged = self . data . copy ( ) datatable_kept = datatable_kept [ mask ] datatable_flagged = datatable_flagged [ np . invert ( mask ) ] print ( <str> % ( len ( datatable_flagged ) , len ( self . data ) ) ) obs_kept = self . copy ( ) obs_flagged = self . copy ( ) obs_kept . data = datatable_kept obs_flagged . data = datatable_flagged if output == <str> :              return obs_flagged  elif output == <str> :              return { <str> : obs_kept , <str> : obs_flagged }  else :              return obs_kept   def flag_uvdist ( self , uv_min = 0.0 , uv_max = 1e12 , output = <str> ) :          uvdist_list = self . unpack ( <str> ) [ <str> ] mask = np . array ( [ uv_min <= uvdist_list [ j ] <= uv_max for j in range ( len ( uvdist_list ) ) ] ) datatable_kept = self . data . copy ( ) datatable_flagged = self . data . copy ( ) datatable_kept = datatable_kept [ mask ] datatable_flagged = datatable_flagged [ np . invert ( mask ) ] print ( <str> % ( len ( datatable_flagged ) , len ( self . data ) ) ) obs_kept = self . copy ( ) obs_flagged = self . copy ( ) obs_kept . data = datatable_kept obs_flagged . data = datatable_flagged if output == <str> :              return obs_flagged  elif output == <str> :              return { <str> : obs_kept , <str> : obs_flagged }  else :              return obs_kept   def flag_sites ( self , sites , output = <str> ) :          datatable = self . data . copy ( ) t1_list = self . unpack ( <str> ) [ <str> ] t2_list = self . unpack ( <str> ) [ <str> ] mask = np . array ( [ t1_list [ j ] not in sites and t2_list [ j ] not in sites for j in range ( len ( t1_list ) ) ] ) datatable_kept = self . data . copy ( ) datatable_flagged = self . data . copy ( ) datatable_kept = datatable_kept [ mask ] datatable_flagged = datatable_flagged [ np . invert ( mask ) ] print ( <str> % ( len ( datatable_flagged ) , len ( self . data ) ) ) obs_kept = self . copy ( ) obs_flagged = self . copy ( ) obs_kept . data = datatable_kept obs_flagged . data = datatable_flagged if output == <str> :              return obs_flagged  elif output == <str> :              return { <str> : obs_kept , <str> : obs_flagged }  else :              return obs_kept   def flag_bl ( self , sites , output = <str> ) :          obs_out = self . copy ( ) t1_list = obs_out . unpack ( <str> ) [ <str> ] t2_list = obs_out . unpack ( <str> ) [ <str> ] mask = np . array ( [ not ( t1_list [ j ] in sites and t2_list [ j ] in sites ) for j in range ( len ( t1_list ) ) ] ) datatable_kept = self . data . copy ( ) datatable_flagged = self . data . copy ( ) datatable_kept = datatable_kept [ mask ] datatable_flagged = datatable_flagged [ np . invert ( mask ) ] print ( <str> % ( len ( datatable_flagged ) , len ( self . data ) ) ) obs_kept = self . copy ( ) obs_flagged = self . copy ( ) obs_kept . data = datatable_kept obs_flagged . data = datatable_flagged if output == <str> :              return obs_flagged  elif output == <str> :              return { <str> : obs_kept , <str> : obs_flagged }  else :              return obs_kept   def flag_low_snr ( self , snr_cut = 3 , output = <str> ) :          datatable = self . data . copy ( ) mask = self . unpack ( <str> ) [ <str> ] > snr_cut datatable_kept = self . data . copy ( ) datatable_flagged = self . data . copy ( ) datatable_kept = datatable_kept [ mask ] datatable_flagged = datatable_flagged [ np . invert ( mask ) ] print ( <str> % ( len ( datatable_flagged ) , len ( self . data ) ) ) obs_kept = self . copy ( ) obs_flagged = self . copy ( ) obs_kept . data = datatable_kept obs_flagged . data = datatable_flagged if output == <str> :              return obs_flagged  elif output == <str> :              return { <str> : obs_kept , <str> : obs_flagged }  else :              return obs_kept   def flag_high_sigma ( self , sigma_cut = .005 , sigma_type = <str> , output = <str> ) :          datatable = self . data . copy ( ) mask = self . unpack ( sigma_type ) [ sigma_type ] < sigma_cut datatable_kept = self . data . copy ( ) datatable_flagged = self . data . copy ( ) datatable_kept = datatable_kept [ mask ] datatable_flagged = datatable_flagged [ np . invert ( mask ) ] print ( <str> % ( len ( datatable_flagged ) , len ( self . data ) ) ) obs_kept = self . copy ( ) obs_flagged = self . copy ( ) obs_kept . data = datatable_kept obs_flagged . data = datatable_flagged if output == <str> :              return obs_flagged  elif output == <str> :              return { <str> : obs_kept , <str> : obs_flagged }  else :              return obs_kept   def flag_UT_range ( self , UT_start_hour = 0. , UT_stop_hour = 0. , flag_type = <str> , flag_what = <str> , output = <str> ) :          datatable = self . data . copy ( ) UT_mask = self . unpack ( <str> ) [ <str> ] <= UT_start_hour UT_mask = UT_mask + ( self . unpack ( <str> ) [ <str> ] >= UT_stop_hour ) if flag_type != <str> :              t1_list = self . unpack ( <str> ) [ <str> ] t2_list = self . unpack ( <str> ) [ <str> ] if flag_type == <str> :                  station = flag_what what_mask = np . array ( [ not ( t1_list [ j ] == station or t2_list [ j ] == station ) for j in range ( len ( t1_list ) ) ] )  elif flag_type == <str> :                  station1 = flag_what . split ( <str> ) [ 0 ] station2 = flag_what . split ( <str> ) [ 1 ] stations = [ station1 , station2 ] what_mask = np . array ( [ not ( ( t1_list [ j ] in stations ) and ( t2_list [ j ] in stations ) ) for j in range ( len ( t1_list ) ) ] )   else :              what_mask = np . array ( [ False for j in range ( len ( UT_mask ) ) ] )  mask = UT_mask | what_mask datatable_kept = self . data . copy ( ) datatable_flagged = self . data . copy ( ) datatable_kept = datatable_kept [ mask ] datatable_flagged = datatable_flagged [ np . invert ( mask ) ] print ( <str> % ( len ( datatable_flagged ) , len ( self . data ) ) ) obs_kept = self . copy ( ) obs_flagged = self . copy ( ) obs_kept . data = datatable_kept obs_flagged . data = datatable_flagged if output == <str> :              return obs_flagged  elif output == <str> :              return { <str> : obs_kept , <str> : obs_flagged }  else :              return obs_kept   def flags_from_file ( self , flagfile , flag_type = <str> ) :          df = pd . read_csv ( flagfile ) mjd_start = list ( df [ <str> ] ) mjd_stop = list ( df [ <str> ] ) if flag_type == <str> :              whatL = list ( df [ <str> ] )  elif flag_type == <str> :              whatL = list ( df [ <str> ] )  elif flag_type == <str> :              whatL = [ <str> for cou in range ( len ( mjd_start ) ) ]  obs = self . copy ( ) for cou in range ( len ( mjd_start ) ) :              what = whatL [ cou ] starth = ( mjd_start [ cou ] % 1 ) * 24. stoph = ( mjd_stop [ cou ] % 1 ) * 24. obs = obs . flag_UT_range ( UT_start_hour = starth , UT_stop_hour = stoph , flag_type = flag_type , flag_what = what , output = <str> )  return obs  def flag_anomalous ( self , field = <str> , max_diff_seconds = 100 , robust_nsigma_cut = 5 , output = <str> ) :          stats = dict ( ) for t1 in set ( self . data [ <str> ] ) :              for t2 in set ( self . data [ <str> ] ) :                  vals = self . unpack_bl ( t1 , t2 , field ) if len ( vals ) > 0 :                      vals [ field ] = np . nan_to_num ( vals [ field ] )  for j in range ( len ( vals ) ) :                      near_vals_mask = np . abs ( vals [ <str> ] - vals [ <str> ] [ j ] ) < max_diff_seconds / 3600.0 fields = vals [ field ] [ np . abs ( vals [ <str> ] - vals [ <str> ] [ j ] ) < max_diff_seconds / 3600.0 ] dfields = np . median ( np . abs ( fields - np . median ( fields ) ) ) if dfields == 0.0 :                          dfields = 1.0  stats [ ( vals [ <str> ] [ j ] [ 0 ] , tuple ( sorted ( ( t1 , t2 ) ) ) ) ] = np . abs ( vals [ field ] [ j ] - np . median ( fields ) ) / dfields    mask = np . array ( [ stats [ ( rec [ 0 ] , tuple ( sorted ( ( rec [ 2 ] , rec [ 3 ] ) ) ) ) ] [ 0 ] < robust_nsigma_cut for rec in self . data ] ) datatable_kept = self . data . copy ( ) datatable_flagged = self . data . copy ( ) datatable_kept = datatable_kept [ mask ] datatable_flagged = datatable_flagged [ np . invert ( mask ) ] print ( <str> % ( field , len ( datatable_flagged ) , len ( self . data ) ) ) obs_kept = self . copy ( ) obs_flagged = self . copy ( ) obs_kept . data = datatable_kept obs_flagged . data = datatable_flagged if output == <str> :              return obs_flagged  elif output == <str> :              return { <str> : obs_kept , <str> : obs_flagged }  else :              return obs_kept   def filter_subscan_dropouts ( self , perc = 0 , return_type = <str> ) :          if type ( self . scans ) != np . ndarray :              print ( <str> )  else :              df = make_df ( self ) tot_points = np . shape ( df ) [ 0 ] bins , labs = get_bins_labels ( self . scans ) df [ <str> ] = list ( pd . cut ( df . time , bins , labels = labs ) ) df [ <str> ] = 1 hm1 = df . groupby ( [ <str> , <str> , <str> ] ) . agg ( { <str> : np . sum } ) . reset_index ( ) hm1 [ <str> ] = 1 hm2 = hm1 . groupby ( [ <str> , <str> ] ) . agg ( { <str> : lambda x : perc * np . median ( x ) , <str> : np . sum } ) . reset_index ( ) dict_elem_in_scan = dict ( zip ( hm2 . scan_id , hm2 . count_samples ) ) hm1 = hm1 [ list ( map ( lambda x : x [ 1 ] >= dict_elem_in_scan [ x [ 0 ] ] , list ( zip ( hm1 . scan_id , hm1 . count_samples ) ) ) ) ] list_good_scans_baselines = list ( zip ( hm1 . scan_id , hm1 . baseline ) ) df_filtered = df [ list ( map ( lambda x : x in list_good_scans_baselines , list ( zip ( df . scan_id , df . baseline ) ) ) ) ] df_filtered [ <str> ] = 1 hm3 = df_filtered . groupby ( [ <str> , <str> , <str> ] ) . agg ( { <str> : np . sum } ) . reset_index ( ) hm3 [ <str> ] = 1 hm4 = hm3 . groupby ( [ <str> , <str> ] ) . agg ( { <str> : np . sum } ) . reset_index ( ) dict_how_many_baselines = dict ( zip ( hm4 . scan_id , hm4 . count_baselines_after ) ) df_filtered [ <str> ] = 1 hm5 = df_filtered . groupby ( [ <str> , <str> , <str> ] ) . agg ( { <str> : np . sum } ) . reset_index ( ) dict_datetime_num_baselines = dict ( zip ( hm5 . datetime , hm5 . count_baselines_per_time ) ) df_filtered2 = df_filtered [ list ( map ( lambda x : dict_datetime_num_baselines [ x [ 1 ] ] == dict_how_many_baselines [ x [ 0 ] ] , list ( zip ( df_filtered . scan_id , df_filtered . datetime ) ) ) ) ] remaining_points = np . shape ( df_filtered2 ) [ 0 ] print ( <str> . format ( tot_points - remaining_points , tot_points ) ) if return_type == <str> :                  out_vis = df_to_rec ( df_filtered2 , <str> )  out = Obsdata ( self . ra , self . dec , self . rf , self . bw , out_vis , self . tarr , source = self . source , mjd = self . mjd , ampcal = self . ampcal , phasecal = self . phasecal , opacitycal = self . opacitycal , dcal = self . dcal , frcal = self . frcal , timetype = self . timetype , scantable = self . scans ) return out   def reverse_taper ( self , fwhm ) :          datatable = self . data . copy ( ) vis1 = datatable [ self . poldict [ <str> ] ] vis2 = datatable [ self . poldict [ <str> ] ] vis3 = datatable [ self . poldict [ <str> ] ] vis4 = datatable [ self . poldict [ <str> ] ] sigma1 = datatable [ self . poldict [ <str> ] ] sigma2 = datatable [ self . poldict [ <str> ] ] sigma3 = datatable [ self . poldict [ <str> ] ] sigma4 = datatable [ self . poldict [ <str> ] ] u = datatable [ <str> ] v = datatable [ <str> ] fwhm_sigma = fwhm / ( 2 * np . sqrt ( 2 * np . log ( 2 ) ) ) ker = np . exp ( - 2 * np . pi ** 2 * fwhm_sigma ** 2 * ( u ** 2 + v ** 2 ) ) datatable [ self . poldict [ <str> ] ] = vis1 / ker datatable [ self . poldict [ <str> ] ] = vis2 / ker datatable [ self . poldict [ <str> ] ] = vis3 / ker datatable [ self . poldict [ <str> ] ] = vis4 / ker datatable [ self . poldict [ <str> ] ] = sigma1 / ker datatable [ self . poldict [ <str> ] ] = sigma2 / ker datatable [ self . poldict [ <str> ] ] = sigma3 / ker datatable [ self . poldict [ <str> ] ] = sigma4 / ker arglist , argdict = self . obsdata_args ( ) arglist [ DATPOS ] = datatable obstaper = Obsdata ( * arglist , ** argdict ) return obstaper  def taper ( self , fwhm ) :          datatable = self . data . copy ( ) vis1 = datatable [ self . poldict [ <str> ] ] vis2 = datatable [ self . poldict [ <str> ] ] vis3 = datatable [ self . poldict [ <str> ] ] vis4 = datatable [ self . poldict [ <str> ] ] sigma1 = datatable [ self . poldict [ <str> ] ] sigma2 = datatable [ self . poldict [ <str> ] ] sigma3 = datatable [ self . poldict [ <str> ] ] sigma4 = datatable [ self . poldict [ <str> ] ] u = datatable [ <str> ] v = datatable [ <str> ] fwhm_sigma = fwhm / ( 2 * np . sqrt ( 2 * np . log ( 2 ) ) ) ker = np . exp ( - 2 * np . pi ** 2 * fwhm_sigma ** 2 * ( u ** 2 + v ** 2 ) ) datatable [ self . poldict [ <str> ] ] = vis1 * ker datatable [ self . poldict [ <str> ] ] = vis2 * ker datatable [ self . poldict [ <str> ] ] = vis3 * ker datatable [ self . poldict [ <str> ] ] = vis4 * ker datatable [ self . poldict [ <str> ] ] = sigma1 * ker datatable [ self . poldict [ <str> ] ] = sigma2 * ker datatable [ self . poldict [ <str> ] ] = sigma3 * ker datatable [ self . poldict [ <str> ] ] = sigma4 * ker arglist , argdict = self . obsdata_args ( ) arglist [ DATPOS ] = datatable obstaper = Obsdata ( * arglist , ** argdict ) return obstaper  def deblur ( self ) :          datatable = self . data . copy ( ) vis1 = datatable [ self . poldict [ <str> ] ] vis2 = datatable [ self . poldict [ <str> ] ] vis3 = datatable [ self . poldict [ <str> ] ] vis4 = datatable [ self . poldict [ <str> ] ] sigma1 = datatable [ self . poldict [ <str> ] ] sigma2 = datatable [ self . poldict [ <str> ] ] sigma3 = datatable [ self . poldict [ <str> ] ] sigma4 = datatable [ self . poldict [ <str> ] ] u = datatable [ <str> ] v = datatable [ <str> ] for i in range ( len ( vis1 ) ) :              ker = sgra_kernel_uv ( self . rf , u [ i ] , v [ i ] ) vis1 [ i ] = vis1 [ i ] / ker vis2 [ i ] = vis2 [ i ] / ker vis2 [ i ] = vis3 [ i ] / ker vis4 [ i ] = vis4 [ i ] / ker sigma1 [ i ] = sigma1 [ i ] / ker sigma2 [ i ] = sigma2 [ i ] / ker sigma3 [ i ] = sigma3 [ i ] / ker sigma4 [ i ] = sigma4 [ i ] / ker  datatable [ self . poldict [ <str> ] ] = vis1 datatable [ self . poldict [ <str> ] ] = vis2 datatable [ self . poldict [ <str> ] ] = vis3 datatable [ self . poldict [ <str> ] ] = vis4 datatable [ self . poldict [ <str> ] ] = sigma1 datatable [ self . poldict [ <str> ] ] = sigma2 datatable [ self . poldict [ <str> ] ] = sigma3 datatable [ self . poldict [ <str> ] ] = sigma4 arglist , argdict = self . obsdata_args ( ) arglist [ DATPOS ] = datatable obsdeblur = Obsdata ( * arglist , ** argdict ) return obsdeblur  def reweight ( self , uv_radius , weightdist = 1.0 ) :          obs_new = self . copy ( ) npts = len ( obs_new . data ) uvpoints = np . vstack ( ( obs_new . data [ <str> ] , obs_new . data [ <str> ] ) ) . transpose ( ) uvpoints_tree1 = spatial . cKDTree ( uvpoints ) uvpoints_tree2 = spatial . cKDTree ( - uvpoints ) for i in range ( npts ) :              matches1 = uvpoints_tree1 . query_ball_point ( uvpoints [ i , : ] , uv_radius ) matches2 = uvpoints_tree2 . query_ball_point ( uvpoints [ i , : ] , uv_radius ) nmatches = len ( matches1 ) + len ( matches2 ) for sigma in [ <str> , <str> , <str> , <str> ] :                  obs_new . data [ sigma ] [ i ] = np . sqrt ( nmatches )   scale = np . mean ( self . data [ <str> ] ) / np . mean ( obs_new . data [ <str> ] ) for sigma in [ <str> , <str> , <str> , <str> ] :              obs_new . data [ sigma ] *= scale * weightdist  if weightdist < 1.0 :              for i in range ( npts ) :                  for sigma in [ <str> , <str> , <str> , <str> ] :                      obs_new . data [ sigma ] [ i ] += ( 1 - weightdist ) * self . data [ sigma ] [ i ]    return obs_new  def fit_gauss ( self , flux = 1.0 , fittype = <str> , paramguess = ( 100 * RADPERUAS , 100 * RADPERUAS , 0. ) ) :          vis = self . data [ <str> ] u = self . data [ <str> ] v = self . data [ <str> ] sig = self . data [ <str> ] if fittype == <str> :              def errfunc ( p ) :                  vismodel = gauss_uv ( u , v , flux , p , x = 0. , y = 0. ) err = np . sum ( ( np . abs ( vis ) - np . abs ( vismodel ) ) ** 2 / sig ** 2 ) return err   else :              def errfunc ( p ) :                  vismodel = gauss_uv ( u , v , flux , p , x = 0. , y = 0. ) err = np . sum ( np . abs ( vis - vismodel ) ** 2 / sig ** 2 ) return err   optdict = { <str> : 5000 } res = opt . minimize ( errfunc , paramguess , method = <str> , options = optdict ) gparams = res . x return gparams  def bispectra ( self , vtype = <str> , mode = <str> , count = <str> , timetype = False , uv_min = False , snrcut = 0. ) :          if timetype == False :              timetype = self . timetype  if not mode in ( <str> , <str> ) :              raise Exception ( <str> )  if not count in ( <str> , <str> , <str> ) :              raise Exception ( <str> )  if not vtype in ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) :              raise Exception ( <str> )  if timetype not in [ <str> , <str> , <str> , <str> ] :              raise Exception ( <str> )  obsdata = self . copy ( ) if uv_min :              obsdata = obsdata . flag_uvdist ( uv_min = uv_min ) obsdata_flagged = self . copy ( ) obsdata_flagged = obsdata_flagged . flag_uvdist ( uv_max = uv_min )  tlist = obsdata . tlist ( conj = True ) out = [ ] bis = [ ] tt = 1 for tdata in tlist :              sys . stdout . write ( <str> % ( vtype , count , tt , len ( tlist ) ) ) sys . stdout . flush ( ) tt += 1 time = tdata [ 0 ] [ <str> ] if timetype in [ <str> , <str> ] and self . timetype == <str> :                  time = utc_to_gmst ( time , self . mjd )  if timetype in [ <str> , <str> ] and self . timetype == <str> :                  time = gmst_to_utc ( time , self . mjd )  sites = list ( set ( np . hstack ( ( tdata [ <str> ] , tdata [ <str> ] ) ) ) ) l_dict = { } for dat in tdata :                  l_dict [ ( dat [ <str> ] , dat [ <str> ] ) ] = dat  if count == <str> :                  tris = tri_minimal_set ( sites , self . tarr , self . tkey )  elif count == <str> :                  tris = list ( it . combinations ( sites , 3 ) )  elif count == <str> :                  tris = tri_minimal_set ( sites , self . tarr , self . tkey ) if uv_min :                      sites_ordered = [ x for x in self . tarr [ <str> ] if x in sites ] ref = sites_ordered [ 0 ] zerobls = np . vstack ( [ obsdata_flagged . data [ <str> ] , obsdata_flagged . data [ <str> ] ] ) if np . sum ( zerobls == ref ) :                          cutsites = np . unique ( np . hstack ( [ zerobls [ 1 ] [ zerobls [ 0 ] == ref ] , zerobls [ 0 ] [ zerobls [ 1 ] == ref ] ] ) ) if len ( cutsites ) > 1 :                              raise Exception ( <str> )  cutsite = cutsites [ 0 ] sites_remaining = np . array ( sites_ordered ) [ np . array ( sites_ordered ) != ref ] sites_remaining = sites_remaining [ np . array ( sites_remaining ) != cutsite ] second_ref = sites_remaining [ 0 ] for s2 in range ( 1 , len ( sites_remaining ) ) :                              tris . append ( ( cutsite , second_ref , sites_remaining [ s2 ] ) )     for tri in tris :                  try :                      l1 = l_dict [ ( tri [ 0 ] , tri [ 1 ] ) ] l2 = l_dict [ ( tri [ 1 ] , tri [ 2 ] ) ] l3 = l_dict [ ( tri [ 2 ] , tri [ 0 ] ) ]  except KeyError :                      continue  ( bi , bisig ) = make_bispectrum ( l1 , l2 , l3 , vtype , polrep = self . polrep ) if np . abs ( bi ) / bisig < snrcut :                      continue  bis . append ( np . array ( ( time , tri [ 0 ] , tri [ 1 ] , tri [ 2 ] , l1 [ <str> ] , l1 [ <str> ] , l2 [ <str> ] , l2 [ <str> ] , l3 [ <str> ] , l3 [ <str> ] , bi , bisig ) , dtype = DTBIS ) )  if mode == <str> and len ( bis ) > 0 :                  out . append ( np . array ( bis ) ) bis = [ ]   if mode == <str> :              out = np . array ( bis )  return out  def c_phases ( self , vtype = <str> , mode = <str> , count = <str> , ang_unit = <str> , timetype = False , uv_min = False , snrcut = 0. ) :          if timetype == False :              timetype = self . timetype  if not mode in ( <str> , <str> ) :              raise Exception ( <str> )  if not count in ( <str> , <str> , <str> ) :              raise Exception ( <str> )  if not vtype in ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) :              raise Exception ( <str> )  if timetype not in [ <str> , <str> , <str> , <str> ] :              raise Exception ( <str> )  if ang_unit == <str> : angle = DEGREE else : angle = 1.0 bispecs = self . bispectra ( vtype = vtype , mode = <str> , count = count , timetype = timetype , uv_min = uv_min , snrcut = snrcut ) out = [ ] cps = [ ] for bis in bispecs :              for bi in bis :                  if len ( bi ) == 0 : continue bi . dtype . names = ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) bi [ <str> ] = np . real ( bi [ <str> ] / np . abs ( bi [ <str> ] ) / angle ) bi [ <str> ] = np . real ( ( np . angle ( bi [ <str> ] ) / angle ) ) cps . append ( bi . astype ( np . dtype ( DTCPHASE ) ) )  if mode == <str> and len ( cps ) > 0 :                  out . append ( np . array ( cps ) ) cps = [ ]   if mode == <str> :              out = np . array ( cps )  print ( <str> ) return out  def bispectra_tri ( self , site1 , site2 , site3 , snrcut = 0. , vtype = <str> , timetype = False , bs = [ ] , force_recompute = False ) :          if timetype == False :              timetype = self . timetype  if ( len ( bs ) == 0 ) and not ( self . bispec is None ) and not ( len ( self . bispec ) == 0 ) and not force_recompute :              bs = self . bispec  elif ( len ( bs ) == 0 ) or force_recompute :              bs = self . bispectra ( mode = <str> , count = <str> , vtype = vtype , timetype = timetype , snrcut = snrcut )  tri = ( site1 , site2 , site3 ) outdata = [ ] for obs in bs :              obstri = ( obs [ <str> ] , obs [ <str> ] , obs [ <str> ] ) if set ( obstri ) == set ( tri ) :                  t1 = copy . deepcopy ( obs [ <str> ] ) t2 = copy . deepcopy ( obs [ <str> ] ) t3 = copy . deepcopy ( obs [ <str> ] ) u1 = copy . deepcopy ( obs [ <str> ] ) u2 = copy . deepcopy ( obs [ <str> ] ) u3 = copy . deepcopy ( obs [ <str> ] ) v1 = copy . deepcopy ( obs [ <str> ] ) v2 = copy . deepcopy ( obs [ <str> ] ) v3 = copy . deepcopy ( obs [ <str> ] ) if t1 == site1 :                      if t2 == site2 :                          pass  else :                          obs [ <str> ] = t3 obs [ <str> ] = t2 obs [ <str> ] = - u3 obs [ <str> ] = - v3 obs [ <str> ] = - u2 obs [ <str> ] = - v2 obs [ <str> ] = - u1 obs [ <str> ] = - v1 obs [ <str> ] = np . conjugate ( obs [ <str> ] )   elif t1 == site2 :                      if t2 == site3 :                          obs [ <str> ] = t3 obs [ <str> ] = t1 obs [ <str> ] = t2 obs [ <str> ] = u3 obs [ <str> ] = v3 obs [ <str> ] = u1 obs [ <str> ] = v1 obs [ <str> ] = u2 obs [ <str> ] = v2  else :                          obs [ <str> ] = t2 obs [ <str> ] = t1 obs [ <str> ] = - u1 obs [ <str> ] = - v1 obs [ <str> ] = - u3 obs [ <str> ] = - v3 obs [ <str> ] = - u2 obs [ <str> ] = - v2 obs [ <str> ] = np . conjugate ( obs [ <str> ] )   elif t1 == site3 :                      if t2 == site1 :                          obs [ <str> ] = t2 obs [ <str> ] = t3 obs [ <str> ] = t1 obs [ <str> ] = u2 obs [ <str> ] = v2 obs [ <str> ] = u3 obs [ <str> ] = v3 obs [ <str> ] = u1 obs [ <str> ] = v1  else :                          obs [ <str> ] = t3 obs [ <str> ] = t1 obs [ <str> ] = - u2 obs [ <str> ] = - v2 obs [ <str> ] = - u1 obs [ <str> ] = - v1 obs [ <str> ] = - u3 obs [ <str> ] = - v3 obs [ <str> ] = np . conjugate ( obs [ <str> ] )   outdata . append ( np . array ( obs , dtype = DTBIS ) ) continue   return np . array ( outdata )  def cphase_tri ( self , site1 , site2 , site3 , snrcut = 0. , vtype = <str> , ang_unit = <str> , timetype = False , cphases = [ ] , force_recompute = False ) :          if timetype == False :              timetype = self . timetype  if ( len ( cphases ) == 0 ) and not ( self . cphase is None ) and not ( len ( self . cphase ) == 0 ) and not force_recompute :              cphases = self . cphase  elif ( len ( cphases ) == 0 ) or force_recompute :              cphases = self . c_phases ( mode = <str> , count = <str> , vtype = vtype , ang_unit = ang_unit , timetype = timetype , snrcut = snrcut )  tri = ( site1 , site2 , site3 ) outdata = [ ] for obs in cphases :              obstri = ( obs [ <str> ] , obs [ <str> ] , obs [ <str> ] ) if set ( obstri ) == set ( tri ) :                  t1 = copy . deepcopy ( obs [ <str> ] ) t2 = copy . deepcopy ( obs [ <str> ] ) t3 = copy . deepcopy ( obs [ <str> ] ) u1 = copy . deepcopy ( obs [ <str> ] ) u2 = copy . deepcopy ( obs [ <str> ] ) u3 = copy . deepcopy ( obs [ <str> ] ) v1 = copy . deepcopy ( obs [ <str> ] ) v2 = copy . deepcopy ( obs [ <str> ] ) v3 = copy . deepcopy ( obs [ <str> ] ) if t1 == site1 :                      if t2 == site2 :                          pass  else :                          obs [ <str> ] = t3 obs [ <str> ] = t2 obs [ <str> ] = - u3 obs [ <str> ] = - v3 obs [ <str> ] = - u2 obs [ <str> ] = - v2 obs [ <str> ] = - u1 obs [ <str> ] = - v1 obs [ <str> ] *= - 1   elif t1 == site2 :                      if t2 == site3 :                          obs [ <str> ] = t3 obs [ <str> ] = t1 obs [ <str> ] = t2 obs [ <str> ] = u3 obs [ <str> ] = v3 obs [ <str> ] = u1 obs [ <str> ] = v1 obs [ <str> ] = u2 obs [ <str> ] = v2  else :                          obs [ <str> ] = t2 obs [ <str> ] = t1 obs [ <str> ] = - u1 obs [ <str> ] = - v1 obs [ <str> ] = - u3 obs [ <str> ] = - v3 obs [ <str> ] = - u2 obs [ <str> ] = - v2 obs [ <str> ] *= - 1   elif t1 == site3 :                      if t2 == site1 :                          obs [ <str> ] = t2 obs [ <str> ] = t3 obs [ <str> ] = t1 obs [ <str> ] = u2 obs [ <str> ] = v2 obs [ <str> ] = u3 obs [ <str> ] = v3 obs [ <str> ] = u1 obs [ <str> ] = v1  else :                          obs [ <str> ] = t3 obs [ <str> ] = t1 obs [ <str> ] = - u2 obs [ <str> ] = - v2 obs [ <str> ] = - u1 obs [ <str> ] = - v1 obs [ <str> ] = - u3 obs [ <str> ] = - v3 obs [ <str> ] *= - 1   outdata . append ( np . array ( obs , dtype = DTCPHASE ) ) continue   return np . array ( outdata )  def c_amplitudes ( self , vtype = <str> , mode = <str> , count = <str> , ctype = <str> , debias = True , timetype = False , snrcut = 0. ) :          if timetype == False :              timetype = self . timetype  if not mode in ( <str> , <str> ) :              raise Exception ( <str> )  if not count in ( <str> , <str> ) :              raise Exception ( <str> )  if not vtype in ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) :              raise Exception ( <str> )  if not ( ctype in [ <str> , <str> ] ) :              raise Exception ( <str> )  if timetype not in [ <str> , <str> , <str> , <str> ] :              raise Exception ( <str> )  tlist = self . tlist ( conj = True ) out = [ ] cas = [ ] tt = 1 for tdata in tlist :              sys . stdout . write ( <str> % ( vtype , ctype , count , tt , len ( tlist ) ) ) sys . stdout . flush ( ) tt += 1 time = tdata [ 0 ] [ <str> ] if timetype in [ <str> , <str> ] and self . timetype == <str> :                  time = utc_to_gmst ( time , self . mjd )  if timetype in [ <str> , <str> ] and self . timetype == <str> :                  time = gmst_to_utc ( time , self . mjd )  sites = np . array ( list ( set ( np . hstack ( ( tdata [ <str> ] , tdata [ <str> ] ) ) ) ) ) if len ( sites ) < 4 :                  continue  l_dict = { } for dat in tdata :                  l_dict [ ( dat [ <str> ] , dat [ <str> ] ) ] = dat  if count == <str> :                  quadsets = quad_minimal_set ( sites , self . tarr , self . tkey )  elif count == <str> :                  quadsets = list ( it . combinations ( sites , 4 ) ) quadsets = np . array ( [ ( q , [ q [ 0 ] , q [ 2 ] , q [ 1 ] , q [ 3 ] ] , [ q [ 0 ] , q [ 1 ] , q [ 3 ] , q [ 2 ] ] ) for q in quadsets ] ) . reshape ( ( - 1 , 4 ) )  for quad in quadsets :                  if ( quad [ 0 ] , quad [ 1 ] ) not in l_dict . keys ( ) :                      continue  if ( quad [ 2 ] , quad [ 3 ] ) not in l_dict . keys ( ) :                      continue  if ( quad [ 1 ] , quad [ 2 ] ) not in l_dict . keys ( ) :                      continue  if ( quad [ 0 ] , quad [ 3 ] ) not in l_dict . keys ( ) :                      continue  try :                      blue1 = l_dict [ quad [ 0 ] , quad [ 1 ] ] blue2 = l_dict [ quad [ 2 ] , quad [ 3 ] ] red1 = l_dict [ quad [ 0 ] , quad [ 3 ] ] red2 = l_dict [ quad [ 1 ] , quad [ 2 ] ]  except KeyError :                      continue  ( camp , camperr ) = make_closure_amplitude ( blue1 , blue2 , red1 , red2 , vtype , polrep = self . polrep , ctype = ctype , debias = debias ) if ctype == <str> :                      if camp / camperr < snrcut : continue  elif ctype == <str> :                      if 1. / camperr < snrcut : continue  cas . append ( np . array ( ( time , quad [ 0 ] , quad [ 1 ] , quad [ 2 ] , quad [ 3 ] , blue1 [ <str> ] , blue1 [ <str> ] , blue2 [ <str> ] , blue2 [ <str> ] , red1 [ <str> ] , red1 [ <str> ] , red2 [ <str> ] , red2 [ <str> ] , camp , camperr ) , dtype = DTCAMP ) )  if mode == <str> :                  out . append ( np . array ( cas ) ) cas = [ ]   if mode == <str> :              out = np . array ( cas )  print ( <str> ) return out  def camp_quad ( self , site1 , site2 , site3 , site4 , snrcut = 0. , vtype = <str> , ctype = <str> , debias = True , timetype = False , camps = [ ] , force_recompute = False ) :          if timetype == False :              timetype = self . timetype  quad = ( site1 , site2 , site3 , site4 ) b1 = set ( ( site1 , site2 ) ) b2 = set ( ( site3 , site4 ) ) r1 = set ( ( site1 , site4 ) ) r2 = set ( ( site2 , site3 ) ) outdata = [ ] if ( ( ctype == <str> ) and ( len ( camps ) == 0 ) ) and not ( self . camp is None ) and not ( len ( self . camp ) == 0 ) and not force_recompute :              camps = self . camp  elif ( ( ctype == <str> ) and ( len ( camps ) == 0 ) ) and not ( self . logcamp is None ) and not ( len ( self . logcamp ) == 0 ) and not force_recompute :              camps = self . logcamp  elif ( len ( camps ) == 0 ) or force_recompute :              camps = self . c_amplitudes ( mode = <str> , count = <str> , vtype = vtype , ctype = ctype , debias = debias , timetype = timetype , snrcut = snrcut )  for obs in camps :              num = [ set ( ( obs [ <str> ] , obs [ <str> ] ) ) , set ( ( obs [ <str> ] , obs [ <str> ] ) ) ] denom = [ set ( ( obs [ <str> ] , obs [ <str> ] ) ) , set ( ( obs [ <str> ] , obs [ <str> ] ) ) ] obsquad = ( obs [ <str> ] , obs [ <str> ] , obs [ <str> ] , obs [ <str> ] ) if set ( quad ) == set ( obsquad ) :                  rightup = ( b1 in num ) and ( b2 in num ) and ( r1 in denom ) and ( r2 in denom ) wrongup = ( b1 in denom ) and ( b2 in denom ) and ( r1 in num ) and ( r2 in num ) if not ( rightup or wrongup ) : continue if wrongup :                      t1old = copy . deepcopy ( obs [ <str> ] ) u1old = copy . deepcopy ( obs [ <str> ] ) v1old = copy . deepcopy ( obs [ <str> ] ) t2old = copy . deepcopy ( obs [ <str> ] ) u2old = copy . deepcopy ( obs [ <str> ] ) v2old = copy . deepcopy ( obs [ <str> ] ) t3old = copy . deepcopy ( obs [ <str> ] ) u3old = copy . deepcopy ( obs [ <str> ] ) v3old = copy . deepcopy ( obs [ <str> ] ) t4old = copy . deepcopy ( obs [ <str> ] ) u4old = copy . deepcopy ( obs [ <str> ] ) v4old = copy . deepcopy ( obs [ <str> ] ) campold = copy . deepcopy ( obs [ <str> ] ) csigmaold = copy . deepcopy ( obs [ <str> ] ) obs [ <str> ] = t1old obs [ <str> ] = t4old obs [ <str> ] = t3old obs [ <str> ] = t2old obs [ <str> ] = u3old obs [ <str> ] = v3old obs [ <str> ] = - u4old obs [ <str> ] = - v4old obs [ <str> ] = u1old obs [ <str> ] = v1old obs [ <str> ] = - u2old obs [ <str> ] = - v2old if ctype == <str> :                          obs [ <str> ] = - campold obs [ <str> ] = csigmaold  else :                          obs [ <str> ] = 1. / campold obs [ <str> ] = csigmaold / ( campold ** 2 )   t1old = copy . deepcopy ( obs [ <str> ] ) u1old = copy . deepcopy ( obs [ <str> ] ) v1old = copy . deepcopy ( obs [ <str> ] ) t2old = copy . deepcopy ( obs [ <str> ] ) u2old = copy . deepcopy ( obs [ <str> ] ) v2old = copy . deepcopy ( obs [ <str> ] ) t3old = copy . deepcopy ( obs [ <str> ] ) u3old = copy . deepcopy ( obs [ <str> ] ) v3old = copy . deepcopy ( obs [ <str> ] ) t4old = copy . deepcopy ( obs [ <str> ] ) u4old = copy . deepcopy ( obs [ <str> ] ) v4old = copy . deepcopy ( obs [ <str> ] ) if ( obs [ <str> ] , obs [ <str> ] , obs [ <str> ] , obs [ <str> ] ) == quad :                      obs [ <str> ] = t2old obs [ <str> ] = t1old obs [ <str> ] = t4old obs [ <str> ] = t3old obs [ <str> ] = - u1old obs [ <str> ] = - v1old obs [ <str> ] = - u2old obs [ <str> ] = - v2old obs [ <str> ] = u4old obs [ <str> ] = v4old obs [ <str> ] = u3old obs [ <str> ] = v3old  elif ( obs [ <str> ] , obs [ <str> ] , obs [ <str> ] , obs [ <str> ] ) == quad :                      obs [ <str> ] = t3old obs [ <str> ] = t4old obs [ <str> ] = t1old obs [ <str> ] = t2old obs [ <str> ] = u2old obs [ <str> ] = v2old obs [ <str> ] = u1old obs [ <str> ] = v1old obs [ <str> ] = - u4old obs [ <str> ] = - v4old obs [ <str> ] = - u3old obs [ <str> ] = - v3old  elif ( obs [ <str> ] , obs [ <str> ] , obs [ <str> ] , obs [ <str> ] ) == quad :                      obs [ <str> ] = t4old obs [ <str> ] = t3old obs [ <str> ] = t2old obs [ <str> ] = t1old obs [ <str> ] = - u2old obs [ <str> ] = - v2old obs [ <str> ] = - u1old obs [ <str> ] = - v1old obs [ <str> ] = - u3old obs [ <str> ] = - v3old obs [ <str> ] = - u4old obs [ <str> ] = - v4old  outdata . append ( np . array ( obs , dtype = DTCAMP ) )   return np . array ( outdata )  def plotall ( self , field1 , field2 , conj = False , debias = True , tag_bl = False , ang_unit = <str> , timetype = False , axis = False , rangex = False , rangey = False , snrcut = 0. , color = SCOLORS [ 0 ] , marker = <str> , markersize = MARKERSIZE , label = None , grid = True , ebar = True , axislabels = True , legend = False , show = True , export_pdf = <str> , ) :          if timetype == False :              timetype = self . timetype  if ( field1 not in FIELDS ) and ( field2 not in FIELDS ) :              raise Exception ( <str> + <str> . join ( FIELDS ) )  if <str> in [ field1 , field2 ] and not ( self . amp is None ) :              print ( <str> )  if tag_bl :              clist = SCOLORS cdict = { } ii = 0 baselines = list ( it . combinations ( self . tarr [ <str> ] , 2 ) ) for baseline in baselines :                  cdict [ ( baseline [ 0 ] , baseline [ 1 ] ) ] = clist [ ii % len ( clist ) ] cdict [ ( baseline [ 1 ] , baseline [ 0 ] ) ] = clist [ ii % len ( clist ) ] ii += 1  alldata = [ ] allsigx = [ ] allsigy = [ ] bllist = [ ] colors = [ ] bldata = self . bllist ( conj = conj ) for bl in bldata :                  t1 = bl [ <str> ] [ 0 ] t2 = bl [ <str> ] [ 1 ] bllist . append ( ( t1 , t2 ) ) colors . append ( cdict [ ( t1 , t2 ) ] ) dat = self . unpack_dat ( bl , [ field1 , field2 ] , ang_unit = ang_unit , debias = debias , timetype = timetype ) alldata . append ( dat ) if sigtype ( field1 ) :                      allsigx . append ( self . unpack_dat ( bl , [ sigtype ( field1 ) ] , ang_unit = ang_unit ) [ sigtype ( field1 ) ] )  else :                      allsigx . append ( None )  if sigtype ( field2 ) :                      allsigy . append ( self . unpack_dat ( bl , [ sigtype ( field2 ) ] , ang_unit = ang_unit ) [ sigtype ( field2 ) ] )  else :                      allsigy . append ( None )    else :              bllist = [ [ <str> , <str> ] ] colors = [ color ] alldata = [ self . unpack ( [ field1 , field2 ] , conj = conj , ang_unit = ang_unit , debias = debias ) ] if sigtype ( field1 ) :                  allsigx = [ self . unpack ( sigtype ( field2 ) , conj = conj , ang_unit = ang_unit ) [ sigtype ( field1 ) ] ]  else :                  allsigx = [ None ]  if sigtype ( field2 ) :                  allsigy = [ self . unpack ( sigtype ( field2 ) , conj = conj , ang_unit = ang_unit ) [ sigtype ( field2 ) ] ]  else :                  allsigy = [ None ]   if axis :              x = axis  else :              fig = plt . figure ( ) x = fig . add_subplot ( 1 , 1 , 1 )  xmins = [ ] xmaxes = [ ] ymins = [ ] ymaxes = [ ] for i in range ( len ( alldata ) ) :              data = alldata [ i ] sigy = allsigy [ i ] sigx = allsigx [ i ] color = colors [ i ] bl = bllist [ i ] mask = ~ ( np . isnan ( data [ field1 ] ) + np . isnan ( data [ field2 ] ) ) if snrcut > 0. :                  sigs = [ sigx , sigy ] for jj , field in enumerate ( [ field1 , field2 ] ) :                      if field in FIELDS_AMPS :                          fmask = data [ field ] / sigs [ jj ] > snrcut  elif field in FIELDS_PHASE :                          fmask = sigs [ jj ] < ( 180. / np . pi / snrcut )  elif field in FIELDS_SNRS :                          fmask = data [ field ] > snrcut  else :                          fmask = np . ones ( mask . shape ) . astype ( bool )  mask *= fmask   data = data [ mask ] if not sigy is None : sigy = sigy [ mask ] if not sigx is None : sigx = sigx [ mask ] if len ( data ) == 0 :                  continue  xmins . append ( np . min ( data [ field1 ] ) ) xmaxes . append ( np . max ( data [ field1 ] ) ) ymins . append ( np . min ( data [ field2 ] ) ) ymaxes . append ( np . max ( data [ field2 ] ) ) tolerance = len ( data [ field2 ] ) if label is None :                  labelstr = <str> % ( ( str ( bl [ 0 ] ) , str ( bl [ 1 ] ) ) )  else :                  labelstr = str ( label )  if ebar and ( np . any ( sigy ) or np . any ( sigx ) ) :                  x . errorbar ( data [ field1 ] , data [ field2 ] , xerr = sigx , yerr = sigy , label = labelstr , fmt = marker , markersize = markersize , color = color , picker = tolerance )  else :                  x . plot ( data [ field1 ] , data [ field2 ] , marker , markersize = markersize , color = color , label = labelstr , picker = tolerance )   if not rangex :              rangex = [ np . min ( xmins ) - 0.2 * np . abs ( np . min ( xmins ) ) , np . max ( xmaxes ) + 0.2 * np . abs ( np . max ( xmaxes ) ) ] if np . any ( np . isnan ( np . array ( rangex ) ) ) :                  print ( <str> ) rangex = [ - 100 , 100 ]   if not rangey :              rangey = [ np . min ( ymins ) - 0.2 * np . abs ( np . min ( ymins ) ) , np . max ( ymaxes ) + 0.2 * np . abs ( np . max ( ymaxes ) ) ] if np . any ( np . isnan ( np . array ( rangey ) ) ) :                  print ( <str> ) rangey = [ - 100 , 100 ]   x . set_xlim ( rangex ) x . set_ylim ( rangey ) if axislabels :              try :                  x . set_xlabel ( FIELD_LABELS [ field1 ] ) x . set_ylabel ( FIELD_LABELS [ field2 ] )  except :                  x . set_xlabel ( field1 . capitalize ( ) ) x . set_ylabel ( field2 . capitalize ( ) )   if legend and tag_bl :              plt . legend ( ncol = 2 )  elif legend :              plt . legend ( )  if grid :              x . grid ( )  if export_pdf != <str> and not axis :              fig . savefig ( export_pdf , bbox_inches = <str> )  if show :              plt . show ( block = False )  return x  def plot_bl ( self , site1 , site2 , field , debias = True , ang_unit = <str> , timetype = False , axis = False , rangex = False , rangey = False , snrcut = 0. , color = SCOLORS [ 0 ] , marker = <str> , markersize = MARKERSIZE , label = None , grid = True , ebar = True , axislabels = True , legend = False , show = True , export_pdf = <str> ) :          if timetype == False :              timetype = self . timetype  if ang_unit == <str> : angle = DEGREE else : angle = 1.0 if field == <str> and not ( self . amp is None ) :              print ( <str> )  if label is None :              label = str ( self . source )  else :              label = str ( label )  if field not in FIELDS :              raise Exception ( <str> + string . join ( FIELDS ) )  plotdata = self . unpack_bl ( site1 , site2 , field , ang_unit = ang_unit , debias = debias , timetype = timetype ) sigmatype = sigtype ( field ) if sigtype ( field ) :              errdata = self . unpack_bl ( site1 , site2 , sigtype ( field ) , ang_unit = ang_unit , debias = debias )  else :              errdata = None  mask = ~ np . isnan ( plotdata [ field ] [ : , 0 ] ) if snrcut > 0. :              if field in FIELDS_AMPS :                  fmask = plotdata [ field ] / errdata [ sigmatype ] > snrcut  elif field in FIELDS_PHASE :                  fmask = errdata [ sigmatype ] < ( 180. / np . pi / snrcut )  elif field in FIELDS_SNRS :                  fmask = plotdata [ field ] > snrcut  else :                  fmask = np . ones ( mask . shape ) . astype ( bool )  fmask = fmask [ : , 0 ] mask *= fmask  plotdata = plotdata [ mask ] if not errdata is None :              errdata = errdata [ mask ]  if not rangex :              rangex = [ self . tstart , self . tstop ] if np . any ( np . isnan ( np . array ( rangex ) ) ) :                  print ( <str> ) rangex = [ 0 , 24 ]   if not rangey :              rangey = [ np . min ( plotdata [ field ] ) - 0.2 * np . abs ( np . min ( plotdata [ field ] ) ) , np . max ( plotdata [ field ] ) + 0.2 * np . abs ( np . max ( plotdata [ field ] ) ) ] if np . any ( np . isnan ( np . array ( rangey ) ) ) :                  print ( <str> ) rangey = [ - 100 , 100 ]   if axis :              x = axis  else :              fig = plt . figure ( ) x = fig . add_subplot ( 1 , 1 , 1 )  if ebar and sigtype ( field ) != False :              x . errorbar ( plotdata [ <str> ] [ : , 0 ] , plotdata [ field ] [ : , 0 ] , yerr = errdata [ sigtype ( field ) ] [ : , 0 ] , fmt = marker , markersize = markersize , color = color , linestyle = <str> , label = label )  else :              x . plot ( plotdata [ <str> ] [ : , 0 ] , plotdata [ field ] [ : , 0 ] , marker , markersize = markersize , color = color , label = label , linestyle = <str> )  x . set_xlim ( rangex ) x . set_ylim ( rangey ) if axislabels :              x . set_xlabel ( self . timetype + <str> ) try :                  x . set_ylabel ( FIELD_LABELS [ field ] )  except :                  x . set_ylabel ( field . capitalize ( ) )  x . set_title ( <str> % ( site1 , site2 ) )  if grid :              x . grid ( )  if legend :              plt . legend ( )  if export_pdf != <str> and not axis :              fig . savefig ( export_pdf , bbox_inches = <str> )  if show :              plt . show ( block = False )  return x  def plot_cphase ( self , site1 , site2 , site3 , vtype = <str> , cphases = [ ] , force_recompute = False , ang_unit = <str> , timetype = False , snrcut = 0. , axis = False , rangex = False , rangey = False , color = SCOLORS [ 0 ] , marker = <str> , markersize = MARKERSIZE , label = None , grid = True , ebar = True , axislabels = True , legend = False , show = True , export_pdf = <str> ) :          if timetype == False :              timetype = self . timetype  if ang_unit == <str> : angle = 1.0 else : angle = DEGREE if label is None :              label = str ( self . source )  else :              label = str ( label )  if ( len ( cphases ) == 0 ) and not ( self . cphase is None ) and not force_recompute :              cphases = self . cphase  cpdata = self . cphase_tri ( site1 , site2 , site3 , vtype = vtype , timetype = timetype , cphases = cphases , force_recompute = force_recompute , snrcut = snrcut ) plotdata = np . array ( [ [ obs [ <str> ] , obs [ <str> ] * angle , obs [ <str> ] ] for obs in cpdata ] ) nan_mask = np . isnan ( plotdata [ : , 1 ] ) plotdata = plotdata [ ~ nan_mask ] if len ( plotdata ) == 0 :              print ( <str> % ( site1 , site2 , site3 ) ) return  if axis :              x = axis  else :              fig = plt . figure ( ) x = fig . add_subplot ( 1 , 1 , 1 )  if not rangex :              rangex = [ self . tstart , self . tstop ] if np . any ( np . isnan ( np . array ( rangex ) ) ) :                  print ( <str> ) rangex = [ 0 , 24 ]   if not rangey :              if ang_unit == <str> : rangey = [ - 190 , 190 ] else : rangey = [ - 1.1 * np . pi , 1.1 * np . pi ]  x . set_xlim ( rangex ) x . set_ylim ( rangey ) if ebar and np . any ( plotdata [ : , 2 ] ) :              x . errorbar ( plotdata [ : , 0 ] , plotdata [ : , 1 ] , yerr = plotdata [ : , 2 ] , fmt = marker , markersize = markersize , color = color , linestyle = <str> , label = label )  else :              x . plot ( plotdata [ : , 0 ] , plotdata [ : , 1 ] , marker , markersize = markersize , color = color , linestyle = <str> , label = label )  if axislabels :              x . set_xlabel ( self . timetype + <str> ) if ang_unit == <str> :                  x . set_ylabel ( <str> )  else :                  x . set_ylabel ( <str> )   x . set_title ( <str> % ( site1 , site2 , site3 ) ) if grid :              x . grid ( )  if legend :              plt . legend ( )  if export_pdf != <str> and not axis :              fig . savefig ( export_pdf , bbox_inches = <str> )  if show :              plt . show ( block = False )  return x  def plot_camp ( self , site1 , site2 , site3 , site4 , vtype = <str> , ctype = <str> , camps = [ ] , force_recompute = False , debias = False , timetype = False , snrcut = 0. , axis = False , rangex = False , rangey = False , color = SCOLORS [ 0 ] , marker = <str> , markersize = MARKERSIZE , label = None , grid = True , ebar = True , axislabels = True , legend = False , show = True , export_pdf = <str> ) :          if timetype == False :              timetype = self . timetype  if label is None :              label = str ( self . source )  else :              label = str ( label )  if ( ( ctype == <str> ) and ( len ( camps ) == 0 ) and not ( self . camp is None ) and not ( len ( self . camp ) == 0 ) and not force_recompute ) :              camps = self . camp  elif ( ( ctype == <str> ) and ( len ( camps ) == 0 ) and not ( self . logcamp is None ) and not ( len ( self . logcamp ) == 0 ) and not force_recompute ) :              camps = self . logcamp  cpdata = self . camp_quad ( site1 , site2 , site3 , site4 , vtype = vtype , ctype = ctype , snrcut = snrcut , debias = debias , timetype = timetype , camps = camps , force_recompute = force_recompute ) if len ( cpdata ) == 0 :              print ( <str> ) return  plotdata = np . array ( [ [ obs [ <str> ] , obs [ <str> ] , obs [ <str> ] ] for obs in cpdata ] ) plotdata = np . array ( plotdata ) nan_mask = np . isnan ( plotdata [ : , 1 ] ) plotdata = plotdata [ ~ nan_mask ] if len ( plotdata ) == 0 :              print ( <str> ) return  if not rangex :              rangex = [ self . tstart , self . tstop ] if np . any ( np . isnan ( np . array ( rangex ) ) ) :                  print ( <str> ) rangex = [ 0 , 24 ]   if not rangey :              rangey = [ np . min ( plotdata [ : , 1 ] ) - 0.2 * np . abs ( np . min ( plotdata [ : , 1 ] ) ) , np . max ( plotdata [ : , 1 ] ) + 0.2 * np . abs ( np . max ( plotdata [ : , 1 ] ) ) ] if np . any ( np . isnan ( np . array ( rangey ) ) ) :                  print ( <str> ) if ctype == <str> : rangey = [ 0 , 100 ] if ctype == <str> : rangey = [ - 10 , 10 ]   if axis :              x = axis  else :              fig = plt . figure ( ) x = fig . add_subplot ( 1 , 1 , 1 )  if ebar and np . any ( plotdata [ : , 2 ] ) :              x . errorbar ( plotdata [ : , 0 ] , plotdata [ : , 1 ] , yerr = plotdata [ : , 2 ] , fmt = marker , markersize = markersize , color = color , linestyle = <str> , label = label )  else :              x . plot ( plotdata [ : , 0 ] , plotdata [ : , 1 ] , marker , markersize = markersize , color = color , linestyle = <str> , label = label )  x . set_xlim ( rangex ) x . set_ylim ( rangey ) if axislabels :              x . set_xlabel ( self . timetype + <str> ) if ctype == <str> :                  x . set_ylabel ( <str> )  elif ctype == <str> :                  x . set_ylabel ( <str> )  x . set_title ( <str> % ( site1 , site2 , site3 , site4 , site1 , site4 , site2 , site3 ) )  if grid :              x . grid ( )  if legend :              plt . legend ( )  if export_pdf != <str> and not axis :              fig . savefig ( export_pdf , bbox_inches = <str> )  if show :              plt . show ( block = False ) return  else :              return x   def save_txt ( self , fname ) :          ehtim . io . save . save_obs_txt ( self , fname ) return  def save_uvfits ( self , fname , force_singlepol = False , polrep_out = <str> ) :          if force_singlepol != False and self . polrep != <str> :              raise Exception ( <str> )  ehtim . io . save . save_obs_uvfits ( self , fname , force_singlepol = force_singlepol , polrep_out = polrep_out ) return  def save_oifits ( self , fname , flux = 1.0 ) :          if self . polrep != <str> :              raise Exception ( <str> )  ehtim . io . save . save_obs_oifits ( self , fname , flux = flux ) return   def merge_obs ( obs_List ) :      if ( len ( set ( [ obs . polrep for obs in obs_List ] ) ) > 1 ) :          raise Exception ( <str> ) return  if ( len ( set ( [ obs . ra for obs in obs_List ] ) ) > 1 or len ( set ( [ obs . dec for obs in obs_List ] ) ) > 1 or len ( set ( [ obs . rf for obs in obs_List ] ) ) > 1 or len ( set ( [ obs . bw for obs in obs_List ] ) ) > 1 or len ( set ( [ obs . source for obs in obs_List ] ) ) > 1 or len ( set ( [ np . floor ( obs . mjd ) for obs in obs_List ] ) ) > 1 ) :          raise Exception ( <str> ) return  data_merge = np . hstack ( [ obs . data for obs in obs_List ] ) scan_merge = [ ] for obs in obs_List :          if not ( scan_merge is None ) :              scan_merge . append ( obs . scans )   scan_merge = np . hstack ( scan_merge ) tarr_merge = np . unique ( np . concatenate ( [ obs . tarr for obs in obs_List ] ) ) arglist , argdict = obs_List [ 0 ] . obsdata_args ( ) arglist [ DATPOS ] = data_merge arglist [ TARRPOS ] = tarr_merge argdict [ <str> ] = scan_merge mergeobs = Obsdata ( * arglist , ** argdict ) return mergeobs  def load_txt ( fname , polrep = <str> ) :      return ehtim . io . load . load_obs_txt ( fname , polrep = polrep )  def load_uvfits ( fname , flipbl = False , remove_nan = False , force_singlepol = None , channel = all , IF = all , polrep = <str> , allow_singlepol = True ) :      return ehtim . io . load . load_obs_uvfits ( fname , flipbl = flipbl , force_singlepol = force_singlepol , channel = channel , IF = IF , polrep = polrep , remove_nan = remove_nan , allow_singlepol = allow_singlepol )  def load_oifits ( fname , flux = 1.0 ) :      return ehtim . io . load . load_obs_oifits ( fname , flux = flux )  def load_maps ( arrfile , obsspec , ifile , qfile = 0 , ufile = 0 , vfile = 0 , src = SOURCE_DEFAULT , mjd = MJD_DEFAULT , ampcal = False , phasecal = False ) :      return ehtim . io . load . load_obs_maps ( arrfile , obsspec , ifile , qfile = qfile , ufile = ufile , vfile = vfile , src = src , mjd = mjd , ampcal = ampcal , phasecal = phasecal )   