import subprocess import sys import os from multiprocessing import cpu_count from multiprocessing import Pool from multiprocessing import Process , Value , Lock TIMEOUT = 31536000 class Parloop ( object ) :      def __init__ ( self , func ) :          self . func = func  def run_loop ( self , arglist , processes = - 1 ) :          processes = processes n = len ( arglist ) if not type ( arglist [ 0 ] ) is list :              arglist = [ [ arg ] for arg in arglist ]  if processes > 0 :              print ( <str> % processes )  elif processes == 0 :              processes = int ( cpu_count ( ) ) print ( <str> % processes )  else :              print ( <str> )  out = - 1 if processes > 0 :              counter = Counter ( initval = 0 , maxval = n ) pool = Pool ( processes = processes , initializer = self . _initcount , initargs = ( counter , ) ) try :                  print ( <str> ) self . prog_msg ( 0 , n , 0 ) out = pool . map_async ( self , arglist ) . get ( TIMEOUT ) pool . close ( )  except KeyboardInterrupt :                  print ( <str> ) pool . terminate ( ) print ( <str> )  except Exception as e :                  print ( <str> % ( e , ) ) pool . terminate ( ) print ( <str> )  finally :                  pool . join ( )   else :              out = [ ] for i in range ( n ) :                  self . prog_msg ( i , n , i - 1 ) args = arglist [ i ] out . append ( self . func ( * args ) )   return out  def _initcount ( self , x ) :          global counter counter = x  def __call__ ( self , args ) :          try :              outval = self . func ( * args ) counter . increment ( ) self . prog_msg ( counter . value ( ) , counter . maxval , counter . value ( ) - 1 ) return outval  except KeyboardInterrupt :              raise KeyboardInterruptError ( )   def prog_msg ( self , i , n , i_last = 0 ) :          complete_percent_last = int ( 100 * float ( i_last ) / float ( n ) ) complete_percent = int ( 100 * float ( i ) / float ( n ) ) ndigit = str ( len ( str ( n ) ) ) bar_width = 30 progress = int ( bar_width * complete_percent / float ( 100 ) ) barparams = ( i , n , ( <str> * progress ) + ( <str> * ( bar_width - progress ) ) , complete_percent ) printstr = <str> + ndigit + <str> sys . stdout . write ( printstr % barparams ) sys . stdout . flush ( )   class Counter ( object ) :      def __init__ ( self , initval = 0 , maxval = 0 ) :          self . val = Value ( <str> , initval ) self . maxval = maxval self . lock = Lock ( )  def increment ( self ) :          with self . lock :              self . val . value += 1   def value ( self ) :          with self . lock :              return self . val . value    class HiddenPrints :      def __enter__ ( self ) :          self . _original_stdout = sys . stdout sys . stdout = open ( os . devnull , <str> )  def __exit__ ( self , exc_type , exc_val , exc_tb ) :          sys . stdout . close ( ) sys . stdout = self . _original_stdout    