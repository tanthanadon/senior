import os import matplotlib . pyplot as plt import numpy as np import ehtim as eh image_pol = False SCRIPTNAME = <str> datafolder = <str> name = <str> pathtooutput = <str> pathtoscripts = <str> source = <str> zbl = 0.8 zbl_tot = 0.8 sys_noise = 0.01 prior_fwhm = 50 * eh . RADPERUAS fov = 120 * eh . RADPERUAS npix = 64 tag = name + <str> + str ( zbl ) flag_zbl = False fit_amps = True flag_amps = False snr_cut = 0 t_avg = 0 LZ_gauss = 40 * eh . RADPERUAS LMT_rescale = 1.5 systematic_noise = { <str> : 0.01 , <str> : 0.01 , <str> : 0.05 , <str> : 0.15 , <str> : 0.05 , <str> : 0.01 , <str> : 0.01 } reg_term = { <str> : 100 , <str> : 1 , <str> : 1 } if fit_amps :      data_term = { <str> : .2 , <str> : 1 , <str> : 1 }  else :      data_term = { <str> : 1 , <str> : 1 }  obs = eh . obsdata . load_uvfits ( datafolder + name + <str> ) obs_orig = obs . copy ( ) res = obs . res ( ) for j in range ( len ( obs . data ) ) :      if ( obs . data [ <str> ] [ j ] ** 2 + obs . data [ <str> ] [ j ] ** 2 ) ** 0.5 < 0.1e9 :          for k in range ( - 8 , 0 ) :              obs . data [ j ] [ k ] *= zbl / zbl_tot    print ( <str> ) obs . add_scans ( ) obs = obs . avg_coherent ( 0. , scan_avg = True ) if snr_cut > 0 :      print ( <str> ) obs = obs . flag_low_snr ( snr_cut )  if flag_amps :      print ( <str> ) obs = obs . flag_anomalous ( <str> , max_diff_seconds = 1200.0 )  if flag_zbl :      obs = obs . flag_uvdist ( uv_min = 0.1e9 )  obs . reorder_tarr_snr ( ) obs_sc = obs . copy ( ) for d in obs_sc . data :      d [ - 4 ] = ( d [ - 4 ] ** 2 + np . abs ( sys_noise * d [ - 8 ] ) ** 2 ) ** 0.5 d [ - 3 ] = ( d [ - 3 ] ** 2 + np . abs ( sys_noise * d [ - 8 ] ) ** 2 ) ** 0.5 d [ - 2 ] = ( d [ - 2 ] ** 2 + np . abs ( sys_noise * d [ - 8 ] ) ** 2 ) ** 0.5 d [ - 1 ] = ( d [ - 1 ] ** 2 + np . abs ( sys_noise * d [ - 8 ] ) ** 2 ) ** 0.5  def converge ( major = 5 ) :      for repeat in range ( major ) :          imgr . init_next = imgr . out_last ( ) . blur_circ ( res ) imgr . make_image_I ( show_updates = False )   obs_sc = obs . copy ( ) obs_sc_init = obs_sc . copy ( ) print ( <str> ) imgr = eh . imager . Imager ( obs_sc , gaussprior , prior_im = gaussprior , data_term = data_term , maxit = 150 , clipfloor = - 1. , norm_reg = True , systematic_noise = systematic_noise , reg_term = reg_term , ttype = <str> ) imgr . make_image_I ( show_updates = False ) converge ( ) im1 = imgr . out_last ( ) . copy ( ) obs_sc = eh . selfcal ( obs_sc , im1 , method = <str> , ttype = <str> ) print ( <str> ) imgr = eh . imager . Imager ( obs_sc , gaussprior , prior_im = gaussprior , data_term = { <str> : imgr . dat_terms_last ( ) [ <str> ] * 10 , <str> : imgr . dat_terms_last ( ) [ <str> ] * 10 , <str> : imgr . dat_terms_last ( ) [ <str> ] * 10 } , maxit = 100 , clipfloor = - 1. , norm_reg = True , systematic_noise = systematic_noise , reg_term = reg_term , ttype = <str> ) imgr . make_image_I ( show_updates = False ) converge ( ) im2 = imgr . out_last ( ) . copy ( ) obs_sc = eh . selfcal ( obs_sc , im2 , method = <str> , ttype = <str> ) im2 . display ( export_pdf = pathtooutput + SCRIPTNAME + tag + <str> ) im2 . save_fits ( pathtooutput + SCRIPTNAME + tag + <str> ) ct = eh . selfcal ( obs , im2 , method = <str> , ttype = <str> , processes = 0 , caltable = True ) ct . plot_gains ( list ( np . sort ( list ( ct . data . keys ( ) ) ) ) , yscale = <str> , export_pdf = pathtooutput + SCRIPTNAME + tag + <str> ) ct = ct . pad_scans ( ) ct . save_txt ( obs_sc , datadir = pathtooutput + SCRIPTNAME + <str> ) obs_sc_save = ct . applycal ( obs , interp = <str> , extrapolate = True ) obs_sc_save . save_uvfits ( pathtooutput + SCRIPTNAME + tag + <str> ) obs . save_uvfits ( pathtooutput + SCRIPTNAME + tag + <str> ) os . system ( <str> + pathtoscripts + <str> + pathtooutput + SCRIPTNAME + tag + <str> + pathtooutput + SCRIPTNAME + tag + <str> + pathtooutput + SCRIPTNAME + tag + <str> + <str> + pathtooutput ) if image_pol :      obs_sc_pol = obs_sc . flag_sites ( [ <str> ] ) if realdata :          datadict = { t [ <str> ] : np . array ( [ ( 0.0 , 0.0 + 1j * 1.0 , 1.0 + 1j * 0.0 ) ] , dtype = eh . DTCAL ) for t in obs_sc_pol . tarr } caltab = eh . caltable . Caltable ( obs_sc_pol . ra , obs_sc_pol . dec , obs_sc_pol . rf , obs_sc_pol . bw , datadict , obs_sc_pol . tarr , obs_sc_pol . source , obs_sc_pol . mjd ) obs_sc_pol = caltab . applycal ( obs_sc_pol , interp = <str> , extrapolate = True )  print ( <str> ) imgr . obs_next = obs_sc_pol imgr . init_next = im2 . blur_circ ( 0.25 * res ) imgr . prior_next = imgr . init_next imgr . transform_next = <str> imgr . dat_term_next = { <str> : 10 } imgr . reg_term_next = { <str> : 1 } imgr . make_image_P ( ) im4 = imgr . out_last ( ) . copy ( ) print ( <str> ) imgr . obs_next = obs_sc_pol imgr . init_next = im4 . blur_circ ( 0 , .5 * res ) imgr . prior_next = imgr . init_next imgr . transform_next = <str> imgr . dat_term_next = { <str> : 100 } imgr . reg_term_next = { <str> : 1 , <str> : 1.e2 } imgr . make_image_P ( ) im5 = imgr . out_last ( ) . copy ( ) im5 . display ( plotp = True )   