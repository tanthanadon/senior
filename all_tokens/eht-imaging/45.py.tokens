from __future__ import division from __future__ import print_function import matplotlib . pyplot as plt import numpy as np import ehtim as eh import scipy from builtins import range import os import glob from random import shuffle import sys import time import astropy . io . fits as fits import subprocess import scipy . stats import ehtim . imaging . dynamical_imaging as di from scipy . interpolate import UnivariateSpline from astropy . stats import median_absolute_deviation import time from ehtim . parloop import * from multiprocessing import cpu_count from multiprocessing import Pool from multiprocessing import Process , Value , Lock colors = eh . SCOLORS itercolors = iter ( colors ) EP = 1.e-16 BIG = 1. / EP IMSIZE = 250 * eh . RADPERUAS NPIX = 512 RMAX = 50 INNERTHRESH = 5 RPRIOR_MIN = 5. RPRIOR_MAX = 50. NRAYS_SEARCH = 25 NRS_SEARCH = 50 THRESH = 0.05 BLUR_VALUE_MIN = 2 FOVP_SEARCH = 0.1 NSEARCH = 10 NRAYS = 720 NRS = 200 NORMFLUX = 0.6 POSTPROCDIR = <str> def quad_interp_radius ( r_max , dr , val_list ) :      v_L = val_list [ 0 ] v_max = val_list [ 1 ] v_R = val_list [ 2 ] rpk = r_max + dr * ( v_L - v_R ) / ( 2 * ( v_L + v_R - 2 * v_max ) ) vpk = 8 * v_max * ( v_L + v_R ) - ( v_L - v_R ) ** 2 - 16 * v_max ** 2 vpk /= ( 8 * ( v_L + v_R - 2 * v_max ) ) return ( rpk , vpk )  class Profiles ( object ) :      def __init__ ( self , im , x0 , y0 , profs , thetas ) :          self . x0 = x0 self . y0 = y0 self . im = im deltay = - ( im . fovy ( ) / 2. - y0 * eh . RADPERUAS ) / im . psize deltax = ( im . fovx ( ) / 2. - x0 * eh . RADPERUAS ) / im . psize self . im_center = im . shift ( [ int ( np . round ( deltay ) ) , int ( np . round ( deltax ) ) ] ) self . flux = im . total_flux ( ) self . parea = ( im . psize / eh . RADPERUAS ) ** 2 self . normfactor = NORMFLUX / im . total_flux ( ) factor = 3.254e13 / ( im . rf ** 2 * im . psize ** 2 ) self . imarr = im . imvec . reshape ( im . ydim , im . xdim ) [ : : - 1 ] * factor self . xs = np . arange ( im . xdim ) * im . psize / eh . RADPERUAS self . ys = np . arange ( im . ydim ) * im . psize / eh . RADPERUAS self . interp = scipy . interpolate . interp2d ( self . ys , self . xs , self . imarr , kind = <str> ) self . profiles = np . array ( profs ) self . thetas = np . array ( thetas ) self . nang = len ( thetas ) self . nrs = len ( self . profiles [ 0 ] ) self . nthetas = len ( self . thetas ) self . rs = np . linspace ( 0 , RMAX , self . nrs ) self . dr = self . rs [ - 1 ] - self . rs [ - 2 ] self . pks = [ ] self . pk_vals = [ ] self . diameters = [ ] for prof in self . profiles :              pk , vpk = self . calc_pkrad_from_prof ( prof ) self . pks . append ( pk ) self . pk_vals . append ( vpk ) self . diameters . append ( 2 * np . abs ( pk ) )  self . pks = np . array ( self . pks ) self . pk_vals = np . array ( self . pk_vals ) self . diameters = np . array ( self . diameters ) self . RingSize1 = ( np . mean ( self . diameters ) , np . std ( self . diameters ) ) self . RingSize1_med = ( np . median ( self . diameters ) , median_absolute_deviation ( self . diameters ) )  def calc_pkrad_from_prof ( self , prof ) :          args = np . argsort ( prof ) pkpos = args [ - 1 ] pk = self . rs [ pkpos ] vpk = prof [ pkpos ] if pkpos > 0 and pkpos < self . nrs - 1 :              vals = [ prof [ pkpos - 1 ] , prof [ pkpos ] , prof [ pkpos + 1 ] ] pk , vpk = quad_interp_radius ( pk , self . dr , vals )  return ( pk , vpk )  def calc_meanprof_and_stats ( self ) :          self . meanprof = np . mean ( self . profiles , axis = 0 ) args = np . argsort ( self . meanprof ) self . pkloc = args [ - 1 ] self . pkrad = self . rs [ self . pkloc ] self . meanpk = self . meanprof [ self . pkloc ] profile_peak_loc = np . unravel_index ( np . argmax ( self . profiles ) , self . profiles . shape ) self . abspk_loc_rad = profile_peak_loc [ 1 ] self . abspk_rad = self . rs [ self . abspk_loc_rad ] self . abspk_loc_ang = profile_peak_loc [ 0 ] self . abspk_ang = self . thetas [ self . abspk_loc_ang ] inner_loc = np . argmin ( ( self . rs - INNERTHRESH ) ** 2 ) self . in_level = np . mean ( self . meanprof [ 0 : inner_loc ] ) outer_loc = np . argmin ( ( self . rs - ( RMAX - INNERTHRESH ) ) ** 2 ) self . out_level = np . mean ( self . meanprof [ outer_loc : ] ) meanprof_zeroed = self . meanprof - self . out_level ( lh_meanprof , rh_meanprof ) = self . calc_width ( meanprof_zeroed ) lhloc_meanprof = np . argmin ( ( self . rs - lh_meanprof ) ** 2 ) rhloc_meanprof = np . argmin ( ( self . rs - rh_meanprof ) ** 2 ) self . lh = lh_meanprof self . rh = rh_meanprof self . lhloc = lhloc_meanprof self . rhloc = rhloc_meanprof meanprof_diameter = 2 * self . pkrad meanprof_width = np . abs ( rh_meanprof - lh_meanprof ) self . RingSize2 = ( meanprof_diameter , meanprof_width ) ringwidths = [ ] for i in range ( self . nang ) :              rprof = self . profiles [ i ] rprof_zeroed = rprof - np . max ( ( np . min ( rprof ) , 0 ) ) ( lh , rh ) = self . calc_width ( rprof ) width = rh - lh if width <= 0 or width >= 2 * meanprof_width : continue ringwidths . append ( width )  self . RingWidth = ( np . mean ( ringwidths ) , np . std ( ringwidths ) ) ringangles = [ ] ringasyms = [ ] for i in range ( self . lhloc , self . rhloc + 1 ) :              angprof = self . profiles . T [ i ] if i == self . lhloc :                  prof_mean_r = angprof . reshape ( 1 , len ( self . profiles . T [ i ] ) )  else :                  prof_mean_r = np . vstack ( ( prof_mean_r , angprof ) )  angle_asym = self . calc_ringangle_asymmetry ( angprof ) ringangles . append ( angle_asym [ 0 ] ) ringasyms . append ( angle_asym [ 1 ] )  self . RingAngle1 = ( scipy . stats . circmean ( ringangles ) , scipy . stats . circstd ( ringangles ) ) prof_mean_r = np . mean ( np . array ( prof_mean_r ) , axis = 0 ) self . meanprof_theta = prof_mean_r ringangle2 = self . calc_ringangle_asymmetry ( prof_mean_r ) self . RingAngle2 = ( ringangle2 [ 0 ] , ringangle2 [ - 1 ] ) self . RingContrast1 = np . max ( self . profiles [ : , self . lhloc : self . rhloc + 1 ] ) / self . in_level self . RingContrast2 = self . meanpk / self . in_level self . RingAsym1 = ( np . mean ( ringasyms ) , np . std ( ringasyms ) ) mask_inner = self . im . copy ( ) mask_outer = self . im . copy ( ) immask = self . im . copy ( ) x0_c = self . im . fovx ( ) / 2. - self . x0 * eh . RADPERUAS y0_c = self . y0 * eh . RADPERUAS - self . im . fovy ( ) / 2. rad_inner = ( self . RingSize1 [ 0 ] / 2. - self . RingWidth [ 0 ] / 2. ) * eh . RADPERUAS rad_outer = ( self . RingSize1 [ 0 ] / 2. + self . RingWidth [ 0 ] / 2. ) * eh . RADPERUAS mask_inner . imvec *= 0 mask_outer . imvec *= 0 mask_inner = mask_inner . add_gauss ( 1 , [ 2 * rad_inner , 2 * rad_inner , 0 , x0_c , y0_c ] ) mask_inner = mask_inner . mask ( cutoff = .5 ) mask_outer = mask_outer . add_gauss ( 1 , [ 2 * rad_outer , 2 * rad_outer , 0 , x0_c , y0_c ] ) mask_outer = mask_outer . mask ( cutoff = .5 ) maskvec_annulus = np . logical_xor ( mask_inner . imvec . astype ( bool ) , mask_outer . imvec . astype ( bool ) ) xlist = np . arange ( 0 , - self . im . xdim , - 1 ) * self . im . psize + ( self . im . psize * self . im . xdim ) / 2.0 - self . im . psize / 2.0 ylist = np . arange ( 0 , - self . im . ydim , - 1 ) * self . im . psize + ( self . im . psize * self . im . ydim ) / 2.0 - self . im . psize / 2.0 cangle = self . RingAngle1 [ 0 ] def anglemask ( x , y ) :              ang = np . mod ( - np . arctan2 ( y - y0_c , x - x0_c ) + np . pi / 2. , 2 * np . pi ) if np . mod ( np . abs ( ang - cangle ) , 2 * np . pi ) > 0.5 * np . pi :                  return False  else :                  return True   immask2 = self . im . copy ( ) maskvec_ang = np . array ( [ [ anglemask ( i , j ) for i in xlist ] for j in ylist ] ) . flatten ( ) . astype ( bool ) maskvec_brighthalf = maskvec_annulus * maskvec_ang brightflux = np . sum ( immask . imvec [ ( maskvec_brighthalf ) ] ) maskvec_dimhalf = maskvec_annulus * ~ maskvec_ang dimflux = np . sum ( immask . imvec [ ( maskvec_dimhalf ) ] ) self . RingFlux = brightflux + dimflux self . RingAsym2 = ( ( brightflux - dimflux ) / ( brightflux + dimflux ) , brightflux / dimflux ) mask = self . im . copy ( ) immask = self . im . copy ( ) x0_c = mask . fovx ( ) / 2. - self . x0 * eh . RADPERUAS y0_c = self . y0 * eh . RADPERUAS - mask . fovy ( ) / 2. rad = self . RingSize1 [ 0 ] * eh . RADPERUAS mask . imvec *= 0 mask = mask . add_gauss ( 1 , [ 2 * rad , 2 * rad , 0 , x0_c , y0_c ] ) mask = mask . mask ( cutoff = .5 ) maskvec = mask . imvec . astype ( bool ) + ( immask . imvec < EP * self . flux ) offsource_vec = immask . imvec [ ~ ( maskvec ) ] self . impeak = np . max ( self . im . imvec ) self . std_offsource = np . std ( offsource_vec ) + EP self . mean_offsource = np . mean ( offsource_vec ) + EP self . dynamic_range = self . impeak / self . std_offsource  def calc_width ( self , prof ) :          pkrad , maxval = self . calc_pkrad_from_prof ( prof ) spline = UnivariateSpline ( self . rs , prof - 0.5 * maxval , s = 0 ) roots = spline . roots ( ) if len ( roots ) == 0 :              return ( self . rs [ 0 ] , self . rs [ - 1 ] )  lh = self . rs [ 0 ] rh = self . rs [ - 1 ] for root in np . sort ( roots ) :              if root < pkrad :                  lh = root  else :                  rh = root break   return ( lh , rh )  def calc_ringangle_asymmetry ( self , prof ) :          dtheta = self . thetas [ - 1 ] - self . thetas [ - 2 ] prof = prof / np . sum ( prof * dtheta ) x = np . sum ( prof * np . exp ( 1j * self . thetas ) * dtheta ) ang = np . mod ( np . angle ( x ) , 2 * np . pi ) asym = np . abs ( x ) std = np . sqrt ( - 2 * np . log ( np . abs ( x ) ) ) return ( ang , asym , std )  def plot_img ( self , save_png = False ) :          plt . figure ( ) plt . contour ( self . xs , self . ys , self . imarr , colors = <str> ) plt . xlabel ( <str> ) plt . ylabel ( <str> ) plt . plot ( self . x0 , self . y0 , <str> , markersize = 20 ) for theta in np . linspace ( 0 , 2 * np . pi , 100 ) :              plt . plot ( self . x0 + np . cos ( theta ) * self . RingSize1 [ 0 ] / 2 , self . y0 + np . sin ( theta ) * self . RingSize1 [ 0 ] / 2 , <str> , markersize = 1 )  plt . axes ( ) . set_aspect ( <str> , <str> ) if save_png :              dirname = os . path . basename ( os . path . dirname ( self . imname ) ) if not os . path . exists ( POSTPROCDIR + <str> + dirname ) :                  subprocess . call ( [ <str> , POSTPROCDIR + <str> + dirname ] )  basename = os . path . basename ( self . imname ) fname = POSTPROCDIR + <str> + dirname + <str> + basename [ : - 5 ] + <str> plt . savefig ( fname ) plt . close ( )  else :              plt . show ( )   def plot_unwrapped ( self , save_png = False , xlabel = True , ylabel = True , xticklabel = True , yticklabel = True , ax = False , imrange = [ ] , show = True , cfun = <str> , linecolor = <str> , labelsize = 14 ) :          angcolor = np . array ( [ 100 , 149 , 237 ] ) / 256. pkcolor = np . array ( [ 219 , 0. , 219 ] ) / 256. imarr = np . array ( self . profiles ) . T / 1.e9 if ax == False :              plt . figure ( ) ax = plt . gca ( )  if imrange :              plt . imshow ( imarr , cmap = plt . get_cmap ( cfun ) , origin = <str> , vmin = imrange [ 0 ] , vmax = imrange [ 1 ] , interpolation = <str> )  else :              plt . imshow ( imarr , cmap = plt . get_cmap ( cfun ) , origin = <str> , interpolation = <str> )  uas_to_pix = self . nrs / np . max ( self . rs ) rad_to_pix = self . nang / ( 2 * np . pi ) pkloc = self . RingSize1 [ 0 ] / 2. * uas_to_pix lhloc = ( self . RingSize1 [ 0 ] - self . RingSize1 [ 1 ] ) / 2. * uas_to_pix rhloc = ( self . RingSize1 [ 0 ] + self . RingSize1 [ 1 ] ) / 2. * uas_to_pix plt . axhline ( y = pkloc , color = linecolor , linewidth = 1 ) plt . axhline ( y = lhloc , color = linecolor , linewidth = 1 , linestyle = <str> ) plt . axhline ( y = rhloc , color = linecolor , linewidth = 1 , linestyle = <str> ) bandloc_sigma = np . sqrt ( ( self . RingWidth [ 1 ] / 2 ) ** 2 + ( self . RingSize1 [ 1 ] / 2 ) ** 2 ) rhloc = ( self . RingSize1 [ 0 ] / 2. + self . RingWidth [ 0 ] / 2. ) * uas_to_pix rhloc2 = ( self . RingSize1 [ 0 ] / 2. + self . RingWidth [ 0 ] / 2. + bandloc_sigma ) * uas_to_pix rhloc3 = ( self . RingSize1 [ 0 ] / 2. + self . RingWidth [ 0 ] / 2. - bandloc_sigma ) * uas_to_pix lhloc = ( self . RingSize1 [ 0 ] / 2. - self . RingWidth [ 0 ] / 2. ) * uas_to_pix lhloc2 = ( self . RingSize1 [ 0 ] / 2. - self . RingWidth [ 0 ] / 2. + bandloc_sigma ) * uas_to_pix lhloc3 = ( self . RingSize1 [ 0 ] / 2. - self . RingWidth [ 0 ] / 2. - bandloc_sigma ) * uas_to_pix plt . axhline ( y = lhloc , color = linecolor , linewidth = 1 , linestyle = <str> ) plt . axhline ( y = lhloc2 , color = linecolor , linewidth = 1 , linestyle = <str> ) plt . axhline ( y = lhloc3 , color = linecolor , linewidth = 1 , linestyle = <str> ) plt . axhline ( y = rhloc , color = linecolor , linewidth = 1 , linestyle = <str> ) plt . axhline ( y = rhloc2 , color = linecolor , linewidth = 1 , linestyle = <str> ) plt . axhline ( y = rhloc3 , color = linecolor , linewidth = 1 , linestyle = <str> ) pkloc = self . RingAngle1 [ 0 ] * rad_to_pix lhloc = ( self . RingAngle1 [ 0 ] + self . RingAngle1 [ 1 ] ) * rad_to_pix rhloc = ( self . RingAngle1 [ 0 ] - self . RingAngle1 [ 1 ] ) * rad_to_pix plt . axvline ( x = pkloc , color = angcolor , linewidth = 1 ) plt . axvline ( x = lhloc , color = angcolor , linewidth = 1 , linestyle = <str> ) plt . axvline ( x = rhloc , color = angcolor , linewidth = 1 , linestyle = <str> ) brightloc = ( self . abspk_loc_rad , self . abspk_loc_ang ) plt . plot ( [ self . abspk_loc_ang ] , [ self . abspk_loc_rad ] , <str> , mew = 2 , ms = 6 , color = pkcolor ) if xlabel :              plt . xlabel ( <str> , size = labelsize )  if ylabel :              plt . ylabel ( <str> , size = labelsize )  xticklabels = np . arange ( 0 , 360 , 60 ) xticks = ( 360 / imarr . shape [ 1 ] ) * xticklabels yticks = np . floor ( np . arange ( 0 , imarr . shape [ 0 ] , imarr . shape [ 0 ] / 5 ) ) . astype ( int ) yticklabels = [ <str> % r for r in self . rs [ yticks ] ] if not xticklabel :              xticklabels = [ ]  if not yticklabel :              yticklabels = [ ]  plt . xticks ( xticks , xticklabels ) plt . yticks ( yticks , yticklabels ) plt . tick_params ( axis = <str> , which = <str> , length = 6 ) if save_png :              dirname = os . path . basename ( os . path . dirname ( self . imname ) ) if not os . path . exists ( POSTPROCDIR + <str> + dirname ) :                  subprocess . call ( [ <str> , POSTPROCDIR + <str> + dirname ] )  basename = os . path . basename ( self . imname ) fname = POSTPROCDIR + <str> + dirname + <str> + basename [ : - 5 ] + <str> plt . savefig ( fname ) plt . close ( )  elif show :              plt . show ( )   def save_unwrapped ( self , fname ) :          imarr = np . array ( self . profiles ) . T header = fits . Header ( ) header [ <str> ] = <str> header [ <str> ] = <str> header [ <str> ] = 2 * np . pi / float ( len ( self . profiles ) ) header [ <str> ] = np . max ( self . rs ) / float ( len ( self . rs ) ) header [ <str> ] = <str> hdu = fits . PrimaryHDU ( imarr , header = header ) hdulist = [ hdu ] hdulist = fits . HDUList ( hdulist ) hdulist . writeto ( fname , overwrite = True )  def plot_profs ( self , colors = colors , save_png = False ) :          plt . figure ( ) plt . xlabel ( <str> ) plt . ylabel ( <str> ) plt . ylim ( [ 0 , 1 ] ) plt . xlim ( [ - 10 , 60 ] ) plt . title ( <str> ) for j in range ( len ( self . profiles ) ) :              plt . plot ( self . rs , self . profiles [ j ] , color = colors [ j % len ( colors ) ] , linestyle = <str> , linewidth = 1 )  if save_png :              dirname = os . path . basename ( os . path . dirname ( self . imname ) ) if not os . path . exists ( POSTPROCDIR + <str> + dirname ) :                  subprocess . call ( [ <str> , POSTPROCDIR + <str> + dirname ] )  basename = os . path . basename ( self . imname ) fname = POSTPROCDIR + <str> + dirname + <str> + basename [ : - 5 ] + <str> plt . savefig ( fname ) plt . close ( )  else :              plt . show ( )   def plot_prof_band ( self , color = <str> , save_png = False , fontsize = 14 , show = True , axis = None , xlabel = True , ylabel = False ) :          if axis is None :              plt . figure ( ) ax = plt . gca ( )  else :              ax = axis  if xlabel :              plt . xlabel ( <str> , size = fontsize )  yticks = [ 0 , 2 , 4 , 6 , 8 , 10 ] yticklabels = [ ] if ylabel :              plt . ylabel ( <str> , size = fontsize ) yticklabels = yticks  plt . yticks ( yticks , yticklabels ) plt . ylim ( [ 0 , 11 ] ) plt . xlim ( [ - 55 , 55 ] ) cutloc1 = np . argmin ( np . abs ( self . thetas - np . mod ( self . RingAngle1 [ 0 ] - np . pi / 2. , 2 * np . pi ) ) ) cutloc2 = np . argmin ( np . abs ( self . thetas - np . mod ( self . RingAngle1 [ 0 ] + np . pi / 2. , 2 * np . pi ) ) ) if cutloc1 < cutloc2 :              prof_half_1 = self . profiles [ cutloc1 : cutloc2 + 1 ] prof_half_2 = np . vstack ( ( self . profiles [ cutloc2 + 1 : ] , self . profiles [ 0 : cutloc1 ] ) )  else :              prof_half_1 = np . vstack ( ( self . profiles [ cutloc1 : ] , self . profiles [ 0 : cutloc2 + 1 ] ) ) prof_half_2 = self . profiles [ cutloc2 + 1 : cutloc1 ]  radii = - np . flip ( self . rs ) tho_m = np . flip ( np . median ( np . array ( prof_half_1 ) , axis = 0 ) ) tho_l = np . flip ( np . percentile ( np . array ( prof_half_1 ) , 0 , axis = 0 ) ) tho_u = np . flip ( np . percentile ( np . array ( prof_half_1 ) , 100 , axis = 0 ) ) tho_l1 = np . flip ( np . percentile ( np . array ( prof_half_1 ) , 25 , axis = 0 ) ) tho_u1 = np . flip ( np . percentile ( np . array ( prof_half_1 ) , 75 , axis = 0 ) ) ax . plot ( radii , tho_m / 1.e9 , <str> , linewidth = 2 , color = color ) ax . fill_between ( radii , tho_l / 1.e9 , tho_u / 1.e9 , alpha = .2 , edgecolor = None , facecolor = color ) ax . fill_between ( radii , tho_l1 / 1.e9 , tho_u1 / 1.e9 , alpha = .4 , edgecolor = None , facecolor = color ) radii = self . rs tho_m = np . median ( np . array ( prof_half_2 ) , axis = 0 ) tho_l = np . percentile ( np . array ( prof_half_2 ) , 0 , axis = 0 ) tho_u = np . percentile ( np . array ( prof_half_2 ) , 100 , axis = 0 ) tho_l1 = np . percentile ( np . array ( prof_half_2 ) , 25 , axis = 0 ) tho_u1 = np . percentile ( np . array ( prof_half_2 ) , 75 , axis = 0 ) ax . plot ( radii , tho_m / 1.e9 , <str> , linewidth = 2 , color = color ) ax . fill_between ( radii , tho_l / 1.e9 , tho_u / 1.e9 , alpha = .2 , edgecolor = None , facecolor = color ) ax . fill_between ( radii , tho_l1 / 1.e9 , tho_u1 / 1.e9 , alpha = .4 , edgecolor = None , facecolor = color ) if save_png :              dirname = os . path . basename ( os . path . dirname ( self . imname ) ) if not os . path . exists ( POSTPROCDIR + <str> + dirname ) :                  subprocess . call ( [ <str> , POSTPROCDIR + <str> + dirname ] )  basename = os . path . basename ( self . imname ) fname = POSTPROCDIR + <str> + dirname + <str> + basename [ : - 5 ] + <str> plt . savefig ( fname ) plt . close ( )  if show :              plt . show ( )   def plot_meanprof ( self , color = <str> , save_png = False ) :          fig = plt . figure ( ) plt . plot ( self . rs , self . meanprof , color = color , linestyle = <str> , linewidth = 1 ) plt . plot ( ( self . lh , self . rh ) , ( 0.5 * self . meanpk , 0.5 * self . meanpk ) , color = color , linestyle = <str> , linewidth = 1 ) plt . xlabel ( <str> ) plt . ylabel ( <str> ) plt . ylim ( [ 0 , 1 ] ) plt . xlim ( [ - 10 , 60 ] ) plt . title ( <str> ) if save_png :              dirname = os . path . basename ( os . path . dirname ( self . imname ) ) if not os . path . exists ( POSTPROCDIR + <str> + dirname ) :                  subprocess . call ( [ <str> , POSTPROCDIR + <str> + dirname ] )  basename = os . path . basename ( self . imname ) fname = POSTPROCDIR + <str> + dirname + <str> + basename [ : - 5 ] + <str> plt . savefig ( fname ) plt . close ( )  else :              plt . show ( )   def plot_meanprof_theta ( self , color = <str> , save_png = False ) :          fig = plt . figure ( ) plt . plot ( self . thetas / eh . DEGREE , self . meanprof_theta , color = color , linestyle = <str> , linewidth = 1 ) ang1 = self . RingAngle1 [ 0 ] / eh . DEGREE std1 = self . RingAngle1 [ 1 ] / eh . DEGREE up = np . mod ( ang1 + std1 , 360 ) down = np . mod ( ang1 - std1 , 360 ) plt . axvline ( x = ang1 , color = <str> , linewidth = 1 ) plt . axvline ( x = up , color = <str> , linewidth = 1 , linestyle = <str> ) plt . axvline ( x = down , color = <str> , linewidth = 1 , linestyle = <str> ) ang2 = self . RingAngle2 [ 0 ] / eh . DEGREE std2 = self . RingAngle2 [ 1 ] / eh . DEGREE up = np . mod ( ang2 + std2 , 360 ) down = np . mod ( ang2 - std2 , 360 ) plt . axvline ( x = ang2 , color = <str> , linewidth = 1 ) plt . axvline ( x = up , color = <str> , linewidth = 1 , linestyle = <str> ) plt . axvline ( x = down , color = <str> , linewidth = 1 , linestyle = <str> ) plt . xlabel ( <str> ) plt . ylabel ( <str> ) plt . title ( <str> ) if save_png :              dirname = os . path . basename ( os . path . dirname ( self . imname ) ) if not os . path . exists ( POSTPROCDIR + <str> + dirname ) :                  subprocess . call ( [ <str> , POSTPROCDIR + <str> + dirname ] )  basename = os . path . basename ( self . imname ) fname = POSTPROCDIR + <str> + dirname + <str> + basename [ : - 5 ] + <str> plt . savefig ( fname ) plt . close ( )  else :              plt . show ( )    def compute_ring_profile ( im , x0 , y0 , title = <str> , nrays = NRAYS , nrs = NRS ) :      rs = np . linspace ( 0 , RMAX , nrs ) thetas = np . linspace ( 0 , 2 * np . pi , nrays ) factor = 3.254e13 / ( im . rf ** 2 * im . psize ** 2 ) imarr = im . imvec . reshape ( im . ydim , im . xdim ) [ : : - 1 ] * factor xs = np . arange ( im . xdim ) * im . psize / eh . RADPERUAS ys = np . arange ( im . ydim ) * im . psize / eh . RADPERUAS interp = scipy . interpolate . interp2d ( ys , xs , imarr , kind = <str> ) def ringVals ( theta ) :          xxs = x0 - rs * np . sin ( theta ) yys = y0 + rs * np . cos ( theta ) vals = [ interp ( xxs [ i ] , yys [ i ] ) [ 0 ] for i in np . arange ( len ( rs ) ) ] return vals  profs = [ ] for j in range ( nrays ) :          vals = ringVals ( thetas [ j ] ) profs . append ( vals )  profiles = Profiles ( im , x0 , y0 , profs , thetas ) return profiles  def findCenter ( im ) :      def objFunc ( pos ) :          ( x0 , y0 ) = pos profiles = compute_ring_profile ( im , x0 , y0 , nrs = NRS_SEARCH , nrays = NRAYS_SEARCH ) mean , std = profiles . RingSize1 if mean < RPRIOR_MIN or mean > RPRIOR_MAX :              return np . inf  else :              J = np . abs ( std / mean ) return J   fovx = im . fovx ( ) / eh . RADPERUAS fovy = im . fovy ( ) / eh . RADPERUAS fovmin_x = ( .5 - FOVP_SEARCH ) * fovx fovmax_x = ( .5 + FOVP_SEARCH ) * fovx fovmin_y = ( .5 - FOVP_SEARCH ) * fovy fovmax_y = ( .5 + FOVP_SEARCH ) * fovy res = scipy . optimize . brute ( objFunc , ranges = ( ( fovmin_x , fovmax_x ) , ( fovmin_y , fovmax_y ) ) , Ns = NSEARCH ) return res  def FindProfileSingle ( imname , save_files = False , blur = 0 , aipscc = False , tag = <str> , rerun = True , return_pp = True ) :      dirname = os . path . basename ( os . path . dirname ( imname ) ) basename = os . path . basename ( imname ) txtname = POSTPROCDIR + <str> + dirname + <str> + basename [ : - 5 ] + tag + <str> if rerun == False and os . path . exists ( txtname ) :          return - 1  with HiddenPrints ( ) :          im_raw = eh . image . load_fits ( imname , aipscc = aipscc ) im = di . center_core ( im_raw ) im_search = im . regrid_image ( IMSIZE , NPIX ) im = im . regrid_image ( IMSIZE , NPIX ) if blur > 0 :              im_search = im_search . blur_circ ( blur * eh . RADPERUAS ) im = im . blur_circ ( blur * eh . RADPERUAS )  im_search . imvec [ im_search . imvec < THRESH * np . max ( im_search . imvec ) ] = 0 res = findCenter ( im_search ) pp = compute_ring_profile ( im , res [ 0 ] , res [ 1 ] , nrs = NRS , nrays = NRAYS ) pp . calc_meanprof_and_stats ( ) pp . imname = imname if save_files :              dirname = os . path . basename ( os . path . dirname ( imname ) ) if not os . path . exists ( POSTPROCDIR + <str> + dirname ) :                  subprocess . call ( [ <str> , POSTPROCDIR + <str> + dirname ] )  basename = os . path . basename ( imname ) txtname = POSTPROCDIR + <str> + dirname + <str> + basename [ : - 5 ] + tag + <str> radprof_name = POSTPROCDIR + <str> + dirname + <str> + basename [ : - 5 ] + tag + <str> angprof_name = POSTPROCDIR + <str> + dirname + <str> + basename [ : - 5 ] + tag + <str> fitsname = POSTPROCDIR + <str> + dirname + <str> + basename [ : - 5 ] + tag + <str> fitsname_centered = POSTPROCDIR + <str> + dirname + <str> + basename [ : - 5 ] + tag + <str> if os . path . exists ( txtname ) :                  os . remove ( txtname )  f = open ( txtname , <str> ) f . write ( <str> + str ( res [ 0 ] ) + <str> ) f . write ( <str> + str ( res [ 1 ] ) + <str> ) f . write ( <str> + str ( pp . RingSize1 [ 0 ] ) + <str> ) f . write ( <str> + str ( pp . RingSize1 [ 1 ] ) + <str> ) f . write ( <str> + str ( pp . RingSize2 [ 0 ] ) + <str> ) f . write ( <str> + str ( pp . RingSize2 [ 1 ] ) + <str> ) f . write ( <str> + str ( pp . RingAngle1 [ 0 ] ) + <str> ) f . write ( <str> + str ( pp . RingAngle1 [ 1 ] ) + <str> ) f . write ( <str> + str ( pp . RingAngle2 [ 0 ] ) + <str> ) f . write ( <str> + str ( pp . RingAngle2 [ 1 ] ) + <str> ) f . write ( <str> + str ( pp . RingWidth [ 0 ] ) + <str> ) f . write ( <str> + str ( pp . RingWidth [ 1 ] ) + <str> ) f . write ( <str> + str ( pp . flux ) + <str> ) f . write ( <str> + str ( pp . RingFlux ) + <str> ) f . write ( <str> + str ( pp . RingAsym1 [ 0 ] ) + <str> ) f . write ( <str> + str ( pp . RingAsym1 [ 1 ] ) + <str> ) f . write ( <str> + str ( pp . RingAsym2 [ 0 ] ) + <str> ) f . write ( <str> + str ( pp . RingAsym2 [ 1 ] ) + <str> ) f . write ( <str> + str ( pp . in_level ) + <str> ) f . write ( <str> + str ( pp . out_level ) + <str> ) f . write ( <str> + str ( pp . meanpk ) + <str> ) f . write ( <str> + str ( pp . RingContrast1 ) + <str> ) f . write ( <str> + str ( pp . RingContrast2 ) + <str> ) f . write ( <str> + str ( pp . dynamic_range ) + <str> ) f . write ( <str> + str ( pp . normfactor ) + <str> ) f . write ( <str> + str ( pp . RingSize1_med [ 0 ] ) + <str> ) f . write ( <str> + str ( pp . RingSize1_med [ 1 ] ) + <str> ) f . close ( ) pp . save_unwrapped ( fitsname ) pp . im_center . save_fits ( fitsname_centered ) data = np . hstack ( ( pp . rs . reshape ( pp . nrs , 1 ) , pp . meanprof . reshape ( pp . nrs , 1 ) , pp . normfactor * pp . meanprof . reshape ( pp . nrs , 1 ) ) ) np . savetxt ( radprof_name , data ) data = np . hstack ( ( pp . thetas . reshape ( pp . nthetas , 1 ) , pp . meanprof_theta . reshape ( pp . nthetas , 1 ) , pp . normfactor * pp . meanprof_theta . reshape ( pp . nthetas , 1 ) ) ) np . savetxt ( angprof_name , data )  if return_pp :              return pp  else :              del pp return    def FindProfiles ( foldername , processes = - 1 , save_files = False , blur = 0 , aipscc = False , tag = <str> , rerun = True , return_pp = True ) :      foldername = os . path . abspath ( foldername ) imlist = np . array ( glob . glob ( foldername + <str> ) ) imlist = np . sort ( imlist ) print ( <str> , len ( imlist ) , <str> , foldername ) if len ( imlist ) == 0 :          return [ ]  arglist = [ [ imlist [ i ] , save_files , blur , aipscc , tag , rerun , return_pp ] for i in range ( len ( imlist ) ) ] parloop = Parloop ( FindProfileSingle ) pplist = parloop . run_loop ( arglist , processes ) return pplist   