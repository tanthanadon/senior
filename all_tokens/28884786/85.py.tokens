import copy import re import logging from typing import List from cltk . prosody . latin . scansion_constants import ScansionConstants import cltk . prosody . latin . string_utils as string_utils LOG = logging . getLogger ( __name__ ) LOG . addHandler ( logging . NullHandler ( ) ) __author__ = [ <str> ] __license__ = <str> class Syllabifier :      def __init__ ( self , constants = ScansionConstants ( ) ) :          self . constants = constants self . consonant_matcher = re . compile ( <str> . format ( constants . CONSONANTS ) ) self . vowel_matcher = re . compile ( <str> . format ( constants . VOWELS + constants . ACCENTED_VOWELS ) ) self . consonantal_i_matcher = re . compile ( <str> . format ( constants . VOWELS + constants . ACCENTED_VOWELS ) ) self . remove_punct_map = string_utils . remove_punctuation_dict ( ) self . kw_matcher = re . compile ( <str> ) self . ACCEPTABLE_CHARS = constants . ACCENTED_VOWELS + constants . VOWELS + <str> + constants . CONSONANTS self . diphthongs = [ d for d in constants . DIPTHONGS if d not in [ <str> , <str> , <str> ] ]  def syllabify ( self , words : str ) -> List [ str ] :          cleaned = words . translate ( self . remove_punct_map ) cleaned = cleaned . replace ( <str> , <str> ) cleaned = cleaned . replace ( <str> , <str> ) cleaned = cleaned . replace ( <str> , <str> ) cleaned = cleaned . replace ( <str> , <str> ) cleaned = cleaned . replace ( <str> , <str> ) cleaned = cleaned . replace ( <str> , <str> ) cleaned = cleaned . replace ( <str> , <str> ) cleaned = cleaned . replace ( <str> , <str> ) cleaned = cleaned . replace ( <str> , <str> ) cleaned = cleaned . replace ( <str> , <str> ) cleaned = cleaned . replace ( <str> , <str> ) cleaned = cleaned . replace ( <str> , <str> ) cleaned = cleaned . replace ( <str> , <str> ) cleaned = cleaned . replace ( <str> , <str> ) cleaned = cleaned . replace ( <str> , <str> ) cleaned = cleaned . replace ( <str> , <str> ) cleaned = cleaned . replace ( <str> , <str> ) cleaned = cleaned . replace ( <str> , <str> ) cleaned = cleaned . replace ( <str> , <str> ) cleaned = cleaned . replace ( <str> , <str> ) cleaned = cleaned . replace ( <str> , <str> ) cleaned = cleaned . replace ( <str> , <str> ) items = cleaned . strip ( ) . split ( <str> ) for char in cleaned :              if not char in self . ACCEPTABLE_CHARS :                  LOG . error ( <str> % cleaned ) return items   syllables : list = [ ] for item in items :              syllables += self . _setup ( item )  for idx , syl in enumerate ( syllables ) :              if <str> in syl :                  syl = syl . replace ( <str> , <str> ) syllables [ idx ] = syl  if <str> in syl :                  syl = syl . replace ( <str> , <str> ) syllables [ idx ] = syl  if <str> in syl :                  syl = syl . replace ( <str> , <str> ) syllables [ idx ] = syl  if <str> in syl :                  syl = syl . replace ( <str> , <str> ) syllables [ idx ] = syl   return string_utils . remove_blank_spaces ( syllables )  def _setup ( self , word ) -> List [ str ] :          if len ( word ) == 1 :              return [ word ]  for prefix in self . constants . PREFIXES :              if word . startswith ( prefix ) :                  ( first , rest ) = string_utils . split_on ( word , prefix ) if self . _contains_vowels ( rest ) :                      return string_utils . remove_blank_spaces ( self . _process ( first ) + self . _process ( rest ) )  return string_utils . remove_blank_spaces ( self . _process ( word ) )   if word in self . constants . UI_EXCEPTIONS . keys ( ) :              return self . constants . UI_EXCEPTIONS [ word ]  return string_utils . remove_blank_spaces ( self . _process ( word ) )  def convert_consonantal_i ( self , word ) -> str :          match = list ( self . consonantal_i_matcher . finditer ( word ) ) if match :              if word [ 0 ] . isupper ( ) :                  return <str> + word [ 1 : ]  return <str> + word [ 1 : ]  return word  def _process ( self , word : str ) -> List [ str ] :          if len ( word . strip ( ) ) == 0 :              return [ ]  word = self . convert_consonantal_i ( word ) my_word = <str> + word + <str> letters = list ( my_word ) positions = [ ] for dipth in self . diphthongs :              if dipth in my_word :                  dipth_matcher = re . compile ( <str> . format ( dipth ) ) matches = dipth_matcher . finditer ( my_word ) for match in matches :                      ( start , end ) = match . span ( ) positions . append ( start )    matches = self . kw_matcher . finditer ( my_word ) for match in matches :              ( start , end ) = match . span ( ) positions . append ( start )  letters = string_utils . merge_next ( letters , positions ) letters = string_utils . remove_blanks ( letters ) positions . clear ( ) if not self . _contains_vowels ( <str> . join ( letters ) ) :              return [ <str> . join ( letters ) . strip ( ) ]  positions = self . _starting_consonants_only ( letters ) while len ( positions ) > 0 :              letters = string_utils . move_consonant_right ( letters , positions ) letters = string_utils . remove_blanks ( letters ) positions = self . _starting_consonants_only ( letters )  positions = self . _ending_consonants_only ( letters ) while len ( positions ) > 0 :              letters = string_utils . move_consonant_left ( letters , positions ) letters = string_utils . remove_blanks ( letters ) positions = self . _ending_consonants_only ( letters )  positions = self . _find_solo_consonant ( letters ) while len ( positions ) > 0 :              letters = self . _move_consonant ( letters , positions ) letters = string_utils . remove_blanks ( letters ) positions = self . _find_solo_consonant ( letters )  positions = self . _find_consonant_cluster ( letters ) while len ( positions ) > 0 :              letters = self . _move_consonant ( letters , positions ) letters = string_utils . remove_blanks ( letters ) positions = self . _find_consonant_cluster ( letters )  return letters  def _contains_consonants ( self , letter_group : str ) -> bool :          return self . consonant_matcher . search ( letter_group ) is not None  def _contains_vowels ( self , letter_group : str ) -> bool :          return self . vowel_matcher . search ( letter_group ) is not None  def _ends_with_vowel ( self , letter_group : str ) -> bool :          if len ( letter_group ) == 0 :              return False  return self . _contains_vowels ( letter_group [ - 1 ] )  def _starts_with_vowel ( self , letter_group : str ) -> bool :          if len ( letter_group ) == 0 :              return False  return self . _contains_vowels ( letter_group [ 0 ] )  def _starting_consonants_only ( self , letters : list ) -> list :          for idx , letter in enumerate ( letters ) :              if not self . _contains_vowels ( letter ) and self . _contains_consonants ( letter ) :                  return [ idx ]  if self . _contains_vowels ( letter ) :                  return [ ]  if self . _contains_vowels ( letter ) and self . _contains_consonants ( letter ) :                  return [ ]   return [ ]  def _ending_consonants_only ( self , letters : List [ str ] ) -> List [ int ] :          reversed_letters = list ( reversed ( letters ) ) length = len ( letters ) for idx , letter in enumerate ( reversed_letters ) :              if not self . _contains_vowels ( letter ) and self . _contains_consonants ( letter ) :                  return [ ( length - idx ) - 1 ]  if self . _contains_vowels ( letter ) :                  return [ ]  if self . _contains_vowels ( letter ) and self . _contains_consonants ( letter ) :                  return [ ]   return [ ]  def _find_solo_consonant ( self , letters : List [ str ] ) -> List [ int ] :          solos = [ ] for idx , letter in enumerate ( letters ) :              if len ( letter ) == 1 and self . _contains_consonants ( letter ) :                  solos . append ( idx )   return solos  def _find_consonant_cluster ( self , letters : List [ str ] ) -> List [ int ] :          for idx , letter_group in enumerate ( letters ) :              if self . _contains_consonants ( letter_group ) and not self . _contains_vowels ( letter_group ) :                  return [ idx ]   return [ ]  def _move_consonant ( self , letters : list , positions : List [ int ] ) -> List [ str ] :          for pos in positions :              previous_letter = letters [ pos - 1 ] consonant = letters [ pos ] next_letter = letters [ pos + 1 ] if self . _contains_vowels ( next_letter ) and self . _starts_with_vowel ( next_letter ) :                  return string_utils . move_consonant_right ( letters , [ pos ] )  if self . _contains_vowels ( previous_letter ) and self . _ends_with_vowel ( previous_letter ) and len ( previous_letter ) == 1 :                  return string_utils . move_consonant_left ( letters , [ pos ] )  if previous_letter + consonant in self . constants . ASPIRATES :                  return string_utils . move_consonant_left ( letters , [ pos ] )  if consonant + next_letter in self . constants . ASPIRATES :                  return string_utils . move_consonant_right ( letters , [ pos ] )  if next_letter [ 0 ] == consonant :                  return string_utils . move_consonant_left ( letters , [ pos ] )  if consonant in self . constants . MUTES and next_letter [ 0 ] in self . constants . LIQUIDS :                  return string_utils . move_consonant_right ( letters , [ pos ] )  if consonant in [ <str> , <str> ] and next_letter [ 0 ] in [ <str> , <str> ] :                  return string_utils . move_consonant_right ( letters , [ pos ] )  if self . _contains_consonants ( next_letter [ 0 ] ) and self . _starts_with_vowel ( previous_letter [ - 1 ] ) :                  return string_utils . move_consonant_left ( letters , [ pos ] )  if self . _contains_consonants ( next_letter [ 0 ] ) :                  return string_utils . move_consonant_right ( letters , [ pos ] )   return letters  def get_syllable_count ( self , syllables : List [ str ] ) -> int :          tmp_syllables = copy . deepcopy ( syllables ) return len ( string_utils . remove_blank_spaces ( string_utils . move_consonant_right ( tmp_syllables , self . _find_solo_consonant ( tmp_syllables ) ) ) )    