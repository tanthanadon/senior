import re from Levenshtein import distance from cltk . prosody . latin . verse import Verse from cltk . prosody . latin . metrical_validator import MetricalValidator from cltk . prosody . latin . scansion_constants import ScansionConstants from cltk . prosody . latin . scansion_formatter import ScansionFormatter from cltk . prosody . latin . syllabifier import Syllabifier import cltk . prosody . latin . string_utils as string_utils from cltk . prosody . latin . verse_scanner import VerseScanner __author__ = [ <str> ] __license__ = <str> class HexameterScanner ( VerseScanner ) :      def __init__ ( self , constants = ScansionConstants ( ) , syllabifier = Syllabifier ( ) , optional_transform = False , * args , ** kwargs ) :          super ( ) . __init__ ( * args , ** kwargs ) self . constants = constants self . remove_punct_map = string_utils . remove_punctuation_dict ( ) self . punctuation_substitutions = string_utils . punctuation_for_spaces_dict ( ) self . metrical_validator = MetricalValidator ( constants ) self . formatter = ScansionFormatter ( constants ) self . syllabifier = syllabifier self . inverted_amphibrach_re = re . compile ( <str> . format ( self . constants . STRESSED , self . constants . UNSTRESSED , self . constants . STRESSED ) ) self . syllable_matcher = re . compile ( <str> . format ( self . constants . VOWELS + self . constants . ACCENTED_VOWELS + self . constants . LIQUIDS + self . constants . MUTES ) ) self . optional_transform = optional_transform  def scan ( self , original_line : str , optional_transform : bool = False , dactyl_smoothing : bool = False ) -> Verse :          verse = Verse ( original_line , meter = <str> ) line = original_line . translate ( self . punctuation_substitutions ) line = self . transform_i_to_j ( line ) working_line = self . elide_all ( line ) working_line = self . accent_by_position ( working_line ) syllables = self . syllabifier . syllabify ( working_line ) if optional_transform :              working_line = self . transform_i_to_j_optional ( line ) working_line = self . elide_all ( working_line ) working_line = self . accent_by_position ( working_line ) syllables = self . syllabifier . syllabify ( working_line ) verse . scansion_notes += [ self . constants . NOTE_MAP [ <str> ] ]  verse . working_line = working_line verse . syllable_count = self . syllabifier . get_syllable_count ( syllables ) verse . syllables = syllables if verse . syllable_count < 12 :              verse . valid = False verse . scansion_notes += [ self . constants . NOTE_MAP [ <str> ] ] return verse  stresses = self . flag_dipthongs ( syllables ) syllables_wspaces = string_utils . to_syllables_with_trailing_spaces ( working_line , syllables ) offset_map = self . calc_offset ( syllables_wspaces ) for idx , syl in enumerate ( syllables ) :              for accented in self . constants . ACCENTED_VOWELS :                  if accented in syl :                      stresses . append ( idx )    stresses . append ( 0 ) stresses . append ( verse . syllable_count - 2 ) verse . scansion = self . produce_scansion ( stresses , syllables_wspaces , offset_map ) if len ( string_utils . stress_positions ( self . constants . STRESSED , verse . scansion ) ) != len ( set ( stresses ) ) :              verse . valid = False verse . scansion_notes += [ self . constants . NOTE_MAP [ <str> ] ] return verse  if self . metrical_validator . is_valid_hexameter ( verse . scansion ) :              verse . scansion_notes += [ self . constants . NOTE_MAP [ <str> ] ] return self . assign_candidate ( verse , verse . scansion )  if verse . syllable_count == 17 :              candidate = self . produce_scansion ( self . metrical_validator . hexameter_known_stresses ( ) , syllables_wspaces , offset_map ) verse . scansion_notes += [ self . constants . NOTE_MAP [ <str> ] ] if self . metrical_validator . is_valid_hexameter ( candidate ) :                  return self . assign_candidate ( verse , candidate )   if verse . syllable_count == 12 :              candidate = self . produce_scansion ( list ( range ( 12 ) ) , syllables_wspaces , offset_map ) if self . metrical_validator . is_valid_hexameter ( verse . scansion ) :                  verse . scansion_notes += [ self . constants . NOTE_MAP [ <str> ] ] return self . assign_candidate ( verse , candidate )   if verse . syllable_count == 13 :              known_unaccents = [ 9 , 10 ] last_syllable_accented = False for vowel in self . constants . ACCENTED_VOWELS :                  if vowel in verse . syllables [ 12 ] :                      last_syllable_accented = True   if not last_syllable_accented :                  known_unaccents . append ( 12 )  if set ( known_unaccents ) - set ( stresses ) != len ( known_unaccents ) :                  verse . scansion = self . produce_scansion ( [ x for x in range ( 13 ) if x not in known_unaccents ] , syllables_wspaces , offset_map ) verse . scansion_notes += [ self . constants . NOTE_MAP [ <str> ] ] if self . metrical_validator . is_valid_hexameter ( verse . scansion ) :                      return self . assign_candidate ( verse , verse . scansion )    if verse . syllable_count > 17 :              verse . valid = False verse . scansion_notes += [ self . constants . NOTE_MAP [ <str> ] ] return verse  smoothed = self . correct_inverted_amphibrachs ( verse . scansion ) if distance ( verse . scansion , smoothed ) > 0 :              verse . scansion_notes += [ self . constants . NOTE_MAP [ <str> ] ] verse . scansion = smoothed stresses += string_utils . differences ( verse . scansion , smoothed )  if self . metrical_validator . is_valid_hexameter ( verse . scansion ) :              return self . assign_candidate ( verse , verse . scansion )  smoothed = self . correct_first_two_dactyls ( verse . scansion ) if distance ( verse . scansion , smoothed ) > 0 :              verse . scansion_notes += [ self . constants . NOTE_MAP [ <str> ] ] verse . scansion = smoothed stresses += string_utils . differences ( verse . scansion , smoothed )  if self . metrical_validator . is_valid_hexameter ( verse . scansion ) :              return self . assign_candidate ( verse , verse . scansion )  smoothed = self . correct_invalid_fifth_foot ( verse . scansion ) if distance ( verse . scansion , smoothed ) > 0 :              verse . scansion_notes += [ self . constants . NOTE_MAP [ <str> ] ] verse . scansion = smoothed stresses += string_utils . differences ( verse . scansion , smoothed )  if self . metrical_validator . is_valid_hexameter ( verse . scansion ) :              return self . assign_candidate ( verse , verse . scansion )  feet = self . metrical_validator . hexameter_feet ( verse . scansion . replace ( <str> , <str> ) ) if feet :              invalid_feet_in_hexameter = [ self . constants . IAMB , self . constants . TROCHEE ] current_foot = 0 ending = feet . pop ( ) scanned_line = <str> for foot in feet :                  if foot . replace ( <str> , <str> ) in invalid_feet_in_hexameter :                      scanned_line = self . invalid_foot_to_spondee ( feet , foot , current_foot ) scanned_line = scanned_line + ending  current_foot += 1  smoothed = self . produce_scansion ( stresses + string_utils . stress_positions ( self . constants . STRESSED , scanned_line ) , syllables_wspaces , offset_map ) if self . metrical_validator . is_valid_hexameter ( smoothed ) :                  verse . scansion_notes += [ self . constants . NOTE_MAP [ <str> ] ] return self . assign_candidate ( verse , smoothed )   smoothed = self . correct_inverted_amphibrachs ( verse . scansion ) if distance ( verse . scansion , smoothed ) > 0 :              verse . scansion_notes += [ self . constants . NOTE_MAP [ <str> ] ] verse . scansion = smoothed stresses += string_utils . differences ( verse . scansion , smoothed )  if self . metrical_validator . is_valid_hexameter ( verse . scansion ) :              return self . assign_candidate ( verse , verse . scansion )  candidates = self . metrical_validator . closest_hexameter_patterns ( verse . scansion ) if candidates is not None :              if len ( candidates ) == 1 and len ( verse . scansion . replace ( <str> , <str> ) ) == len ( candidates [ 0 ] ) and len ( string_utils . differences ( verse . scansion , candidates [ 0 ] ) ) == 1 :                  tmp_scansion = self . produce_scansion ( string_utils . differences ( verse . scansion , candidates [ 0 ] ) , syllables_wspaces , offset_map ) if self . metrical_validator . is_valid_hexameter ( tmp_scansion ) :                      verse . scansion_notes += [ self . constants . NOTE_MAP [ <str> ] ] return self . assign_candidate ( verse , tmp_scansion )    smoothed = self . correct_inverted_amphibrachs ( smoothed ) if self . metrical_validator . is_valid_hexameter ( smoothed ) :              verse . scansion_notes += [ self . constants . NOTE_MAP [ <str> ] ] return self . assign_candidate ( verse , smoothed )  if dactyl_smoothing :              smoothed = self . correct_dactyl_chain ( smoothed ) if distance ( verse . scansion , smoothed ) > 0 :                  verse . scansion_notes += [ self . constants . NOTE_MAP [ <str> ] ] verse . scansion = smoothed  if self . metrical_validator . is_valid_hexameter ( verse . scansion ) :                  return self . assign_candidate ( verse , verse . scansion )   if self . optional_transform and not verse . valid :              return self . scan ( original_line , optional_transform = True , dactyl_smoothing = True )  return verse  def correct_invalid_fifth_foot ( self , scansion : str ) -> str :          scansion_wo_spaces = scansion . replace ( <str> , <str> ) [ : - 1 ] + self . constants . OPTIONAL_ENDING if scansion_wo_spaces . endswith ( self . constants . DACTYL + self . constants . IAMB + self . constants . OPTIONAL_ENDING ) :              matches = list ( re . compile ( <str> . format ( self . constants . STRESSED , self . constants . UNSTRESSED , self . constants . UNSTRESSED , self . constants . UNSTRESSED , self . constants . STRESSED ) ) . finditer ( scansion ) ) ( start , end ) = matches [ len ( matches ) - 1 ] . span ( ) unstressed_idx = scansion . index ( self . constants . UNSTRESSED , start ) new_line = scansion [ : unstressed_idx ] + self . constants . STRESSED + scansion [ unstressed_idx + 1 : ] return new_line  return scansion  def invalid_foot_to_spondee ( self , feet : list , foot : str , idx : int ) -> str :          new_foot = foot . replace ( self . constants . UNSTRESSED , self . constants . STRESSED ) feet [ idx ] = new_foot return <str> . join ( feet )  def correct_dactyl_chain ( self , scansion : str ) -> str :          mark_list = string_utils . mark_list ( scansion ) vals = list ( scansion . replace ( <str> , <str> ) ) feet = [ vals . pop ( ) , vals . pop ( ) ] length = len ( vals ) idx = length - 1 while idx > 0 :              one = vals [ idx ] two = vals [ idx - 1 ] if idx > 1 :                  three = vals [ idx - 2 ]  else :                  three = <str>  if one == self . constants . UNSTRESSED and two == self . constants . UNSTRESSED and three == self . constants . STRESSED :                  feet += [ one ] feet += [ two ] feet += [ three ] idx -= 3 continue  if one == self . constants . STRESSED and two == self . constants . STRESSED :                  feet += [ one ] feet += [ two ] idx -= 2 continue  if one == self . constants . UNSTRESSED and two == self . constants . UNSTRESSED and three == self . constants . UNSTRESSED :                  feet += [ one ] feet += [ two ] feet += [ self . constants . STRESSED ] idx -= 3 continue  if one == self . constants . STRESSED and two == self . constants . UNSTRESSED and three == self . constants . UNSTRESSED :                  feet += [ self . constants . STRESSED ] feet += [ self . constants . STRESSED ] idx -= 2 continue  if one == self . constants . UNSTRESSED and two == self . constants . STRESSED :                  feet += [ self . constants . STRESSED ] feet += [ two ] idx -= 2 continue   corrected = <str> . join ( feet [ : : - 1 ] ) new_line = list ( <str> * len ( scansion ) ) for idx , car in enumerate ( corrected ) :              new_line [ mark_list [ idx ] ] = car  return <str> . join ( new_line )  def correct_inverted_amphibrachs ( self , scansion : str ) -> str :          new_line = scansion while list ( self . inverted_amphibrach_re . finditer ( new_line ) ) :              matches = list ( self . inverted_amphibrach_re . finditer ( new_line ) ) for match in matches :                  ( start , end ) = match . span ( ) unstressed_idx = new_line . index ( self . constants . UNSTRESSED , start ) new_line = new_line [ : unstressed_idx ] + self . constants . STRESSED + new_line [ unstressed_idx + 1 : ]   return new_line    