__author__ = [ <str> , <str> ] __license__ = <str> import unicodedata from cltk . phonology . arabic . romanization import transliterate as AarabicTransliterate from cltk . phonology . greek import transcription as grc from cltk . phonology . latin import transcription as lat from cltk . phonology . middle_high_german import transcription as mhg from cltk . phonology . middle_english . transcription import Word as word_me from cltk . phonology . akkadian import stress as AkkadianStress from cltk . phonology . old_norse import transcription as ont from cltk . phonology . gothic import transcription as gothic from cltk . phonology . old_swedish import transcription as old_swedish from cltk . phonology import utils as ut from cltk . phonology . syllabify import Syllabifier , Syllable from cltk . tokenize . word import WordTokenizer from cltk . corpus . old_norse . syllabifier import invalid_onsets import unittest class TestSequenceFunctions ( unittest . TestCase ) :      @ classmethod def setUpClass ( self ) :          self . greek_transcriber = grc . Transcriber ( <str> , <str> ) self . latin_transcriber = lat . Transcriber ( <str> , <str> )  def test_greek_refresh ( self ) :          test_word = grc . Word ( <str> , grc . GREEK [ <str> ] [ <str> ] ) test_word . _refresh ( ) contexts = [ test_word . phones [ 0 ] . left . ipa , test_word . phones [ 1 ] . left . ipa , test_word . phones [ 1 ] . right . ipa , test_word . phones [ - 1 ] . right . ipa ] target = [ grc . Phone ( <str> ) . ipa , grc . Phone ( <str> ) . ipa , grc . Phone ( <str> ) . ipa , grc . Phone ( <str> ) . ipa ] self . assertEqual ( contexts , target )  def test_greek_r_devoice ( self ) :          condition_1 = grc . Word ( <str> , grc . GREEK [ <str> ] [ <str> ] ) condition_1 . _refresh ( ) condition_1 . _r_devoice ( ) condition_2 = grc . Word ( <str> , grc . GREEK [ <str> ] [ <str> ] ) condition_2 . _refresh ( ) condition_2 . _r_devoice ( ) outputs = [ <str> . join ( p . ipa for p in condition_1 . phones ) , <str> . join ( p . ipa for p in condition_2 . phones ) ] target = [ unicodedata . normalize ( <str> , y ) for y in [ <str> , <str> ] ] self . assertEqual ( outputs , target )  def test_greek_s_voice_assimilation ( self ) :          condition = grc . Word ( <str> , grc . GREEK [ <str> ] [ <str> ] ) condition . _refresh ( ) condition . _s_voice_assimilation ( ) output = <str> . join ( [ p . ipa for p in condition . phones ] ) target = unicodedata . normalize ( <str> , <str> ) self . assertEqual ( output , target )  def test_greek_nasal_place_assimilation ( self ) :          condition_1 = grc . Word ( <str> , grc . GREEK [ <str> ] [ <str> ] ) condition_1 . _refresh ( ) condition_1 . _nasal_place_assimilation ( ) condition_2 = grc . Word ( <str> , grc . GREEK [ <str> ] [ <str> ] ) condition_2 . _refresh ( ) condition_2 . _nasal_place_assimilation ( ) outputs = [ <str> . join ( [ p . ipa for p in condition_1 . phones ] ) , <str> . join ( [ p . ipa for p in condition_2 . phones ] ) ] target = [ unicodedata . normalize ( <str> , y ) for y in [ <str> , <str> ] ] self . assertEqual ( outputs , target )  def test_greek_g_nasality_assimilation ( self ) :          condition = grc . Word ( <str> , grc . GREEK [ <str> ] [ <str> ] ) condition . _refresh ( ) condition . _g_nasality_assimilation ( ) output = <str> . join ( [ p . ipa for p in condition . phones ] ) target = unicodedata . normalize ( <str> , <str> ) self . assertEqual ( output , target )  def test_greek_alternate ( self ) :          raw_inputs = [ <str> , <str> , <str> , <str> , <str> , <str> ] outputs = [ ] for i in raw_inputs :              w = grc . Word ( i , grc . GREEK [ <str> ] [ <str> ] ) w . _alternate ( ) outputs . append ( <str> . join ( [ p . ipa for p in w . phones ] ) )  target = [ unicodedata . normalize ( <str> , y ) for y in [ <str> , <str> , <str> , <str> , <str> , <str> ] ] self . assertEqual ( outputs , target )  def test_greek_syllabify ( self ) :          raw_inputs = [ <str> , <str> , <str> , <str> ] outputs = [ ] for i in raw_inputs :              w = grc . Word ( i , grc . GREEK [ <str> ] [ <str> ] ) w . _alternate ( ) outputs . append ( [ <str> . join ( [ p . ipa for l in n for p in l ] ) for n in w . _syllabify ( ) ] )  target = [ [ unicodedata . normalize ( <str> , s ) for s in y ] for y in [ [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] ] ] self . assertEqual ( outputs , target )  def test_greek_print_ipa ( self ) :          w = grc . Word ( <str> , grc . GREEK [ <str> ] [ <str> ] ) output = [ w . _print_ipa ( True ) , w . _print_ipa ( False ) ] target = [ unicodedata . normalize ( <str> , <str> ) , unicodedata . normalize ( <str> , <str> ) ] self . assertEqual ( output , target )  def test_greek_parse_diacritics ( self ) :          inputs = [ <str> , <str> , <str> , <str> , <str> , <str> ] outputs = [ self . greek_transcriber . _parse_diacritics ( char ) for char in inputs ] target = [ unicodedata . normalize ( <str> , c ) for c in [ <str> + grc . chars . ACUTE + <str> , <str> , <str> + grc . chars . CIRCUMFLEX + <str> + grc . chars . IOTA_SUBSCRIPT + <str> , <str> , <str> + grc . chars . DIAERESIS + <str> , <str> + grc . chars . LONG + <str> ] ] self . assertEqual ( outputs , target )  def test_greek_prep_text ( self ) :          inputs = [ <str> , <str> ] outputs = [ self . greek_transcriber . _prep_text ( w ) for w in inputs ] target = [ [ ( <str> , <str> , <str> ) , ( <str> , <str> , <str> ) , ( <str> , <str> , <str> ) , ( <str> , <str> , <str> ) , ( <str> , <str> , <str> ) ] , [ ( <str> , <str> , <str> ) , ( <str> , <str> , <str> ) , ( <str> , <str> , <str> ) , ( <str> , <str> , <str> ) , ( <str> , <str> , <str> ) ] ] self . assertEqual ( outputs , target )  def test_transcriber_probert ( self ) :          transcriber = self . greek_transcriber . transcribe transcription = [ transcriber ( x ) for x in [ unicodedata . normalize ( <str> , y ) for y in [ <str> , <str> , <str> , <str> ] ] ] target = [ unicodedata . normalize ( <str> , y ) for y in [ <str> , <str> , <str> , <str> ] ] self . assertEqual ( transcription , target )  def test_latin_refresh ( self ) :          test_word = lat . Word ( <str> , lat . LATIN [ <str> ] [ <str> ] ) test_word . _refresh ( ) contexts = [ test_word . phones [ 0 ] . left . ipa , test_word . phones [ 1 ] . left . ipa , test_word . phones [ 1 ] . right . ipa , test_word . phones [ - 1 ] . right . ipa ] target = [ grc . Phone ( <str> ) . ipa , grc . Phone ( <str> ) . ipa , grc . Phone ( <str> ) . ipa , grc . Phone ( <str> ) . ipa ] self . assertEqual ( contexts , target )  def test_latin_j_maker ( self ) :          condition = lat . Word ( <str> , lat . LATIN [ <str> ] [ <str> ] ) condition . _refresh ( ) condition . _j_maker ( ) output = <str> . join ( [ p . ipa for p in condition . phones ] ) target = unicodedata . normalize ( <str> , <str> ) self . assertEqual ( output , target )  def test_latin_w_maker ( self ) :          condition = lat . Word ( <str> , lat . LATIN [ <str> ] [ <str> ] ) condition . _refresh ( ) condition . _w_maker ( ) output = <str> . join ( [ p . ipa for p in condition . phones ] ) target = unicodedata . normalize ( <str> , <str> ) self . assertEqual ( output , target )  def test_latin_wj_block ( self ) :          condition = lat . Word ( <str> , lat . LATIN [ <str> ] [ <str> ] ) condition . _refresh ( ) condition . _wj_block ( ) output = <str> . join ( [ p . ipa for p in condition . phones ] ) target = unicodedata . normalize ( <str> , <str> ) self . assertEqual ( output , target )  def test_latin_uj_diph_maker ( self ) :          condition = lat . Word ( <str> , lat . LATIN [ <str> ] [ <str> ] ) condition . _refresh ( ) condition . _uj_diph_maker ( ) output = <str> . join ( [ p . ipa for p in condition . phones ] ) target = unicodedata . normalize ( <str> , <str> ) self . assertEqual ( output , target )  def test_latin_b_devoice ( self ) :          condition_1 = lat . Word ( <str> , lat . LATIN [ <str> ] [ <str> ] ) condition_1 . _refresh ( ) condition_1 . _b_devoice ( ) condition_2 = lat . Word ( <str> , lat . LATIN [ <str> ] [ <str> ] ) condition_2 . _refresh ( ) condition_2 . _b_devoice ( ) outputs = [ <str> . join ( [ p . ipa for p in condition_1 . phones ] ) , <str> . join ( [ p . ipa for p in condition_2 . phones ] ) ] target = [ unicodedata . normalize ( <str> , y ) for y in [ <str> , <str> ] ] self . assertEqual ( outputs , target )  def test_latin_final_m_drop ( self ) :          condition = lat . Word ( <str> , lat . LATIN [ <str> ] [ <str> ] ) condition . _refresh ( ) condition . _final_m_drop ( ) output = <str> . join ( [ p . ipa for p in condition . phones ] ) target = unicodedata . normalize ( <str> , <str> ) self . assertEqual ( output , target )  def test_latin_n_place_assimilation ( self ) :          condition = lat . Word ( <str> , lat . LATIN [ <str> ] [ <str> ] ) condition . _refresh ( ) condition . _n_place_assimilation ( ) output = <str> . join ( [ p . ipa for p in condition . phones ] ) target = unicodedata . normalize ( <str> , <str> ) self . assertEqual ( output , target )  def test_latin_g_n_nasality_assimilation ( self ) :          condition = lat . Word ( <str> , lat . LATIN [ <str> ] [ <str> ] ) condition . _refresh ( ) condition . _g_n_nasality_assimilation ( ) output = <str> . join ( [ p . ipa for p in condition . phones ] ) target = unicodedata . normalize ( <str> , <str> ) self . assertEqual ( output , target )  def test_latin_ns_nf_lengthening ( self ) :          condition_1 = lat . Word ( <str> , lat . LATIN [ <str> ] [ <str> ] ) condition_1 . _refresh ( ) condition_1 . _ns_nf_lengthening ( ) condition_2 = lat . Word ( <str> , lat . LATIN [ <str> ] [ <str> ] ) condition_2 . _refresh ( ) condition_2 . _ns_nf_lengthening ( ) outputs = [ <str> . join ( [ p . ipa for p in condition_1 . phones ] ) , <str> . join ( [ p . ipa for p in condition_2 . phones ] ) ] target = [ unicodedata . normalize ( <str> , y ) for y in [ <str> , <str> ] ] self . assertEqual ( outputs , target )  def test_latin_l_darken ( self ) :          condition_1 = lat . Word ( <str> , lat . LATIN [ <str> ] [ <str> ] ) condition_1 . _refresh ( ) condition_1 . _l_darken ( ) condition_2 = lat . Word ( <str> , lat . LATIN [ <str> ] [ <str> ] ) condition_2 . _refresh ( ) condition_2 . _l_darken ( ) outputs = [ <str> . join ( [ p . ipa for p in condition_1 . phones ] ) , <str> . join ( [ p . ipa for p in condition_2 . phones ] ) ] target = [ unicodedata . normalize ( <str> , y ) for y in [ <str> , <str> ] ] self . assertEqual ( outputs , target )  def test_latin_j_z_doubling ( self ) :          condition_1 = lat . Word ( <str> , lat . LATIN [ <str> ] [ <str> ] ) condition_1 . _refresh ( ) condition_1 . _j_z_doubling ( ) condition_2 = lat . Word ( <str> , lat . LATIN [ <str> ] [ <str> ] ) condition_2 . _refresh ( ) condition_2 . _j_z_doubling ( ) outputs = [ <str> . join ( [ p . ipa for p in condition_1 . phones ] ) , <str> . join ( [ p . ipa for p in condition_2 . phones ] ) ] target = [ unicodedata . normalize ( <str> , y ) for y in [ <str> , <str> ] ] self . assertEqual ( outputs , target )  def test_latin_long_vowel_catcher ( self ) :          conditions = [ lat . Word ( s , lat . LATIN [ <str> ] [ <str> ] ) for s in [ <str> , <str> , <str> , <str> , <str> , <str> ] ] for w in conditions :              w . _long_vowel_catcher ( )  outputs = [ <str> . join ( [ p . ipa for p in c . phones ] ) for c in conditions ] target = [ unicodedata . normalize ( <str> , y ) for y in [ <str> , <str> , <str> , <str> , <str> , <str> ] ] self . assertEqual ( outputs , target )  def test_latin_e_i_closer_before_vowel ( self ) :          condition_1 = lat . Word ( <str> , lat . LATIN [ <str> ] [ <str> ] ) condition_1 . _refresh ( ) condition_1 . _e_i_closer_before_vowel ( ) condition_2 = lat . Word ( <str> , lat . LATIN [ <str> ] [ <str> ] ) condition_2 . _refresh ( ) condition_2 . _e_i_closer_before_vowel ( ) outputs = [ <str> . join ( [ p . ipa for p in condition_1 . phones ] ) , <str> . join ( [ p . ipa for p in condition_2 . phones ] ) ] target = [ unicodedata . normalize ( <str> , y ) for y in [ <str> , <str> ] ] self . assertEqual ( outputs , target )  def test_latin_intervocalic_j ( self ) :          condition = lat . Word ( <str> , lat . LATIN [ <str> ] [ <str> ] ) condition . _refresh ( ) condition . _intervocalic_j ( ) outputs = <str> . join ( [ p . ipa for p in condition . phones ] ) target = unicodedata . normalize ( <str> , <str> ) self . assertEqual ( outputs , target )  def test_latin_alternate ( self ) :          raw_inputs = [ <str> , <str> , <str> ] outputs = [ ] for i in raw_inputs :              w = lat . Word ( i , lat . LATIN [ <str> ] [ <str> ] ) w . _alternate ( ) outputs . append ( <str> . join ( [ p . ipa for p in w . phones ] ) )  target = [ unicodedata . normalize ( <str> , y ) for y in [ <str> , <str> , <str> ] ] self . assertEqual ( outputs , target )  def test_latin_syllabify ( self ) :          raw_inputs = [ <str> , <str> , <str> , <str> ] outputs = [ ] for i in raw_inputs :              w = lat . Word ( i , lat . LATIN [ <str> ] [ <str> ] ) w . _syllabify ( ) outputs . append ( [ <str> . join ( [ p . ipa for l in n for p in l ] ) for n in w . _syllabify ( ) ] )  target = [ [ unicodedata . normalize ( <str> , s ) for s in y ] for y in [ [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> , <str> ] ] ] self . assertEqual ( outputs , target )  def test_latin_print_ipa ( self ) :          inputs = [ lat . Word ( w , lat . LATIN [ <str> ] [ <str> ] ) for w in [ <str> , <str> ] ] output = [ [ w . _print_ipa ( syllabify = False , accentuate = False ) , w . _print_ipa ( syllabify = True , accentuate = False ) , w . _print_ipa ( syllabify = True , accentuate = True ) ] for w in inputs ] target = [ [ unicodedata . normalize ( <str> , x ) for x in [ <str> , <str> , <str> ] ] , [ unicodedata . normalize ( <str> , x ) for x in [ <str> , <str> , <str> ] ] ] self . assertEqual ( output , target )  def test_latin_parse_diacritics ( self ) :          inputs = [ <str> , <str> , <str> ] outputs = [ self . latin_transcriber . _parse_diacritics ( char ) for char in inputs ] target = [ unicodedata . normalize ( <str> , c ) for c in [ <str> , <str> + lat . chars . LONG + <str> , <str> + lat . chars . DIAERESIS + <str> ] ] self . assertEqual ( outputs , target )  def test_latin_prep_text ( self ) :          inputs = [ <str> , <str> , <str> ] outputs = [ self . latin_transcriber . _prep_text ( w ) for w in inputs ] target = [ [ ( <str> , <str> , <str> ) , ( <str> , <str> , <str> ) , ( <str> , <str> , <str> ) , ( <str> , <str> , <str> ) ] , [ ( <str> , <str> , <str> ) , ( <str> , <str> , <str> ) ] , [ ( <str> , <str> , <str> ) , ( <str> , <str> , <str> ) , ( <str> , <str> , <str> ) , ( <str> , <str> , <str> ) , ( <str> , <str> , <str> ) ] ] self . assertEqual ( outputs , target )  def test_transcriber_allen_without_macronizer ( self ) :          transcriber = self . latin_transcriber . transcribe transcription = [ transcriber ( x , macronize = False ) for x in [ unicodedata . normalize ( <str> , y ) for y in [ <str> , <str> , <str> , <str> , <str> , <str> ] ] ] target = [ unicodedata . normalize ( <str> , y ) for y in [ <str> , <str> , <str> , <str> , <str> , <str> ] ] self . assertEqual ( transcription , target )  def test_transcriber_allen_with_macronizer ( self ) :          transcriber = self . latin_transcriber . transcribe transcription = transcriber ( <str> , macronize = True ) target = ( <str> + <str> ) self . assertEqual ( transcription , target )  def test_akkadian_stress ( self ) :          word = <str> target = [ <str> , <str> , <str> , <str> , <str> ] stresser = AkkadianStress . StressFinder ( ) stress = stresser . find_stress ( word ) self . assertEqual ( target , stress )  def test_arabic_transliterate ( self ) :          ar_string = <str> buckwalter_string = <str> iso2332_string = <str> mode = <str> ignore = <str> reverse = True assert AarabicTransliterate ( mode , ar_string , ignore , reverse ) == <str> reverse = False assert AarabicTransliterate ( mode , buckwalter_string , ignore , reverse ) == <str> mode = <str> reverse = True assert AarabicTransliterate ( mode , ar_string , ignore , reverse ) == <str> reverse = False assert AarabicTransliterate ( mode , iso2332_string , ignore , reverse ) == <str>  def test_middle_high_german_transcriber ( self ) :          inputs = <str> transcriber = mhg . Transcriber ( ) . transcribe transcription = [ unicodedata . normalize ( <str> , x ) for x in transcriber ( inputs ) ] target = [ unicodedata . normalize ( <str> , x ) for x in <str> ] self . assertEqual ( target , transcription )  def test_middle_high_german_soundex ( self ) :          w1 = mhg . Word ( <str> ) . phonetic_indexing ( p = <str> ) w2 = mhg . Word ( <str> ) . phonetic_indexing ( p = <str> ) target = [ <str> , <str> ] self . assertEqual ( [ w1 , w2 ] , target )  def test_middle_high_german_ascii_encoding ( self ) :          s1 = mhg . Word ( <str> ) . ASCII_encoding ( ) s2 = mhg . Word ( <str> ) . ASCII_encoding ( ) target = [ <str> , <str> ] self . assertEqual ( [ s1 , s2 ] , target )  def test_middle_english_syllabify ( self ) :          words = [ <str> , <str> , <str> , <str> , <str> ] syllabified = [ word_me ( w ) . syllabify ( ) for w in words ] target_syllabified = [ [ <str> , <str> ] , [ <str> , <str> ] , [ <str> ] , [ <str> ] , [ <str> , <str> , <str> ] ] assert syllabified == target_syllabified syllabified_str = [ word_me ( w ) . syllabified_str ( ) for w in words ] target_syllabified_str = [ <str> , <str> , <str> , <str> , <str> ] assert syllabified_str == target_syllabified_str  def test_old_norse_transcriber ( self ) :          example_sentence = <str> <str> <str> tr = ut . Transcriber ( ont . DIPHTHONGS_IPA , ont . DIPHTHONGS_IPA_class , ont . IPA_class , ont . old_norse_rules ) transcribed_sentence = tr . text_to_phonetic_representation ( example_sentence ) target = <str> <str> self . assertEqual ( target , transcribed_sentence )  def test_gothic_transcriber ( self ) :          example_sentence = <str> tr = ut . Transcriber ( gothic . DIPHTHONGS_IPA , gothic . DIPHTHONGS_IPA_class , gothic . IPA_class , gothic . gothic_rules ) transcribed_sentence = tr . text_to_phonetic_representation ( example_sentence ) target = <str> self . assertEqual ( target , transcribed_sentence )  def test_old_swedish ( self ) :          sentence = <str> tr = ut . Transcriber ( old_swedish . DIPHTHONGS_IPA , old_swedish . DIPHTHONGS_IPA_class , old_swedish . IPA_class , old_swedish . old_swedish_rules ) transcribed_sentence = tr . text_to_phonetic_representation ( sentence ) self . assertEqual ( <str> , transcribed_sentence )  def test_utils ( self ) :          a = ut . Vowel ( ut . Height . open , ut . Backness . front , False , ut . Length . short , <str> ) self . assertListEqual ( [ a . ipar , a . backness , a . height , a . length , a . rounded ] , [ <str> , ut . Backness . front , ut . Height . open , ut . Length . short , False ] )  def test_vowel_lengthening_utils ( self ) :          a = ut . Vowel ( ut . Height . open , ut . Backness . front , False , ut . Length . short , <str> ) aa = a . lengthen ( ) self . assertEqual ( aa . ipar , <str> )  def test_consonant_utils ( self ) :          b = ut . Consonant ( ut . Place . bilabial , ut . Manner . stop , True , <str> , False ) self . assertListEqual ( [ b . ipar , b . manner , b . place , b . voiced , b . geminate ] , [ <str> , ut . Manner . stop , ut . Place . bilabial , True , False ] )  def test_add_consonants_utils ( self ) :          k = ut . Consonant ( ut . Place . velar , ut . Manner . stop , False , <str> , False ) s = ut . Consonant ( ut . Place . alveolar , ut . Manner . fricative , False , <str> , False ) x = k + s self . assertEqual ( x . ipar , <str> )  def test_rule1_utils ( self ) :          a = ut . Vowel ( ut . Height . open , ut . Backness . front , False , ut . Length . short , <str> ) th = ut . Consonant ( ut . Place . dental , ut . Manner . fricative , False , <str> , False ) dh = ut . Consonant ( ut . Place . dental , ut . Manner . fricative , True , <str> , False ) rule = ut . Rule ( ut . AbstractPosition ( ut . Rank . inner , [ ut . AbstractVowel ( ) ] , [ ut . AbstractVowel ( ) ] ) , th , dh ) pos = ut . Position ( ut . Rank . inner , a , a ) self . assertEqual ( rule . can_apply ( pos ) , True )  def test_rule2_utils ( self ) :          k = ut . Consonant ( ut . Place . velar , ut . Manner . stop , False , <str> , False ) a = ut . Vowel ( ut . Height . open , ut . Backness . front , False , ut . Length . short , <str> ) th = ut . Consonant ( ut . Place . dental , ut . Manner . fricative , False , <str> , False ) dh = ut . Consonant ( ut . Place . dental , ut . Manner . fricative , True , <str> , False ) rule = ut . Rule ( ut . AbstractPosition ( ut . Rank . inner , [ ut . AbstractVowel ( ) ] , [ ut . AbstractVowel ( ) ] ) , th , dh ) pos = ut . Position ( ut . Rank . inner , k , a ) self . assertEqual ( rule . can_apply ( pos ) , False )  def test_rule3_utils ( self ) :          s = ut . Consonant ( ut . Place . alveolar , ut . Manner . fricative , False , <str> , False ) a = ut . Vowel ( ut . Height . open , ut . Backness . front , False , ut . Length . short , <str> ) th = ut . Consonant ( ut . Place . dental , ut . Manner . fricative , False , <str> , False ) dh = ut . Consonant ( ut . Place . dental , ut . Manner . fricative , True , <str> , False ) rule = ut . Rule ( ut . AbstractPosition ( ut . Rank . inner , [ ut . AbstractVowel ( ) ] , [ ut . AbstractVowel ( ) ] ) , th , dh ) pos = ut . Position ( ut . Rank . inner , a , s ) self . assertEqual ( rule . can_apply ( pos ) , False )  def test_rule4_utils ( self ) :          a = ut . Vowel ( ut . Height . open , ut . Backness . front , False , ut . Length . short , <str> ) th = ut . Consonant ( ut . Place . dental , ut . Manner . fricative , False , <str> , False ) dh = ut . Consonant ( ut . Place . dental , ut . Manner . fricative , True , <str> , False ) rule = ut . Rule ( ut . AbstractPosition ( ut . Rank . inner , [ ut . AbstractConsonant ( voiced = True ) ] , [ ut . AbstractConsonant ( voiced = True ) ] ) , th , dh ) pos = ut . Position ( ut . Rank . inner , a , a ) self . assertEqual ( rule . can_apply ( pos ) , False )  def test_rule5_utils ( self ) :          k = ut . Consonant ( ut . Place . velar , ut . Manner . stop , False , <str> , False ) a = ut . Vowel ( ut . Height . open , ut . Backness . front , False , ut . Length . short , <str> ) th = ut . Consonant ( ut . Place . dental , ut . Manner . fricative , False , <str> , False ) dh = ut . Consonant ( ut . Place . dental , ut . Manner . fricative , True , <str> , False ) rule = ut . Rule ( ut . AbstractPosition ( ut . Rank . inner , [ ut . AbstractConsonant ( voiced = True ) ] , [ ut . AbstractConsonant ( voiced = True ) ] ) , th , dh ) pos = ut . Position ( ut . Rank . inner , k , a ) self . assertEqual ( rule . can_apply ( pos ) , False )  def test_rule6_utils ( self ) :          s = ut . Consonant ( ut . Place . alveolar , ut . Manner . fricative , False , <str> , False ) a = ut . Vowel ( ut . Height . open , ut . Backness . front , False , ut . Length . short , <str> ) th = ut . Consonant ( ut . Place . dental , ut . Manner . fricative , False , <str> , False ) dh = ut . Consonant ( ut . Place . dental , ut . Manner . fricative , True , <str> , False ) pos = ut . Position ( ut . Rank . inner , a , s ) rule = ut . Rule ( ut . AbstractPosition ( ut . Rank . inner , [ ut . AbstractConsonant ( voiced = True ) ] , [ ut . AbstractConsonant ( voiced = True ) ] ) , th , dh ) self . assertEqual ( rule . can_apply ( pos ) , False )  def test_rule7_utils ( self ) :          b = ut . Consonant ( ut . Place . bilabial , ut . Manner . stop , True , <str> , False ) th = ut . Consonant ( ut . Place . dental , ut . Manner . fricative , False , <str> , False ) dh = ut . Consonant ( ut . Place . dental , ut . Manner . fricative , True , <str> , False ) rule = ut . Rule ( ut . AbstractPosition ( ut . Rank . inner , [ ut . AbstractConsonant ( voiced = True ) ] , [ ut . AbstractConsonant ( voiced = True ) ] ) , th , dh ) pos = ut . Position ( ut . Rank . inner , b , b ) self . assertEqual ( rule . can_apply ( pos ) , True )  def test_rule_conversion1 ( self ) :          a = ut . Vowel ( ut . Height . open , ut . Backness . front , False , ut . Length . short , <str> ) e = ut . Vowel ( ut . Height . close_mid , ut . Backness . front , False , ut . Length . short , <str> ) i = ut . Vowel ( ut . Height . close , ut . Backness . front , False , ut . Length . short , <str> ) o = ut . Vowel ( ut . Height . close_mid , ut . Backness . back , True , ut . Length . short , <str> ) u = ut . Vowel ( ut . Height . close , ut . Backness . back , True , ut . Length . short , <str> ) b = ut . Consonant ( ut . Place . bilabial , ut . Manner . stop , True , <str> , False ) d = ut . Consonant ( ut . Place . alveolar , ut . Manner . stop , True , <str> , False ) f = ut . Consonant ( ut . Place . labio_dental , ut . Manner . fricative , False , <str> , False ) g = ut . Consonant ( ut . Place . velar , ut . Manner . stop , True , <str> , False ) k = ut . Consonant ( ut . Place . velar , ut . Manner . stop , False , <str> , False ) p = ut . Consonant ( ut . Place . bilabial , ut . Manner . stop , False , <str> , False ) s = ut . Consonant ( ut . Place . alveolar , ut . Manner . fricative , False , <str> , False ) t = ut . Consonant ( ut . Place . alveolar , ut . Manner . stop , False , <str> , False ) v = ut . Consonant ( ut . Place . labio_dental , ut . Manner . fricative , True , <str> , False ) th = ut . Consonant ( ut . Place . dental , ut . Manner . fricative , False , <str> , False ) dh = ut . Consonant ( ut . Place . dental , ut . Manner . fricative , True , <str> , False ) phonology = [ a , e , i , o , u , b , d , f , g , k , p , s , t , v , th , dh ] ru1 = ut . Rule ( ut . AbstractPosition ( ut . Rank . inner , [ ut . AbstractConsonant ( voiced = False ) ] , [ ut . AbstractConsonant ( voiced = True ) ] ) , th , th ) self . assertEqual ( ru1 . ipa_to_regular_expression ( phonology ) , <str> )  def test_rule_conversion2 ( self ) :          a = ut . Vowel ( ut . Height . open , ut . Backness . front , False , ut . Length . short , <str> ) e = ut . Vowel ( ut . Height . close_mid , ut . Backness . front , False , ut . Length . short , <str> ) i = ut . Vowel ( ut . Height . close , ut . Backness . front , False , ut . Length . short , <str> ) o = ut . Vowel ( ut . Height . close_mid , ut . Backness . back , True , ut . Length . short , <str> ) u = ut . Vowel ( ut . Height . close , ut . Backness . back , True , ut . Length . short , <str> ) b = ut . Consonant ( ut . Place . bilabial , ut . Manner . stop , True , <str> , False ) d = ut . Consonant ( ut . Place . alveolar , ut . Manner . stop , True , <str> , False ) f = ut . Consonant ( ut . Place . labio_dental , ut . Manner . fricative , False , <str> , False ) g = ut . Consonant ( ut . Place . velar , ut . Manner . stop , True , <str> , False ) k = ut . Consonant ( ut . Place . velar , ut . Manner . stop , False , <str> , False ) p = ut . Consonant ( ut . Place . bilabial , ut . Manner . stop , False , <str> , False ) s = ut . Consonant ( ut . Place . alveolar , ut . Manner . fricative , False , <str> , False ) t = ut . Consonant ( ut . Place . alveolar , ut . Manner . stop , False , <str> , False ) v = ut . Consonant ( ut . Place . labio_dental , ut . Manner . fricative , True , <str> , False ) th = ut . Consonant ( ut . Place . dental , ut . Manner . fricative , False , <str> , False ) dh = ut . Consonant ( ut . Place . dental , ut . Manner . fricative , True , <str> , False ) phonology = [ a , e , i , o , u , b , d , f , g , k , p , s , t , v , th , dh ] ru2 = ut . Rule ( ut . AbstractPosition ( ut . Rank . first , None , [ ut . AbstractConsonant ( place = ut . Place . velar ) ] ) , p , k ) self . assertEqual ( ru2 . ipa_to_regular_expression ( phonology ) , <str> )  def test_rule_conversion3 ( self ) :          a = ut . Vowel ( ut . Height . open , ut . Backness . front , False , ut . Length . short , <str> ) e = ut . Vowel ( ut . Height . close_mid , ut . Backness . front , False , ut . Length . short , <str> ) i = ut . Vowel ( ut . Height . close , ut . Backness . front , False , ut . Length . short , <str> ) o = ut . Vowel ( ut . Height . close_mid , ut . Backness . back , True , ut . Length . short , <str> ) u = ut . Vowel ( ut . Height . close , ut . Backness . back , True , ut . Length . short , <str> ) b = ut . Consonant ( ut . Place . bilabial , ut . Manner . stop , True , <str> , False ) d = ut . Consonant ( ut . Place . alveolar , ut . Manner . stop , True , <str> , False ) f = ut . Consonant ( ut . Place . labio_dental , ut . Manner . fricative , False , <str> , False ) g = ut . Consonant ( ut . Place . velar , ut . Manner . stop , True , <str> , False ) k = ut . Consonant ( ut . Place . velar , ut . Manner . stop , False , <str> , False ) p = ut . Consonant ( ut . Place . bilabial , ut . Manner . stop , False , <str> , False ) s = ut . Consonant ( ut . Place . alveolar , ut . Manner . fricative , False , <str> , False ) t = ut . Consonant ( ut . Place . alveolar , ut . Manner . stop , False , <str> , False ) v = ut . Consonant ( ut . Place . labio_dental , ut . Manner . fricative , True , <str> , False ) th = ut . Consonant ( ut . Place . dental , ut . Manner . fricative , False , <str> , False ) dh = ut . Consonant ( ut . Place . dental , ut . Manner . fricative , True , <str> , False ) phonology = [ a , e , i , o , u , b , d , f , g , k , p , s , t , v , th , dh ] ru3 = ut . Rule ( ut . AbstractPosition ( ut . Rank . last , [ ut . AbstractConsonant ( manner = ut . Manner . stop ) ] , None ) , dh , th ) self . assertEqual ( ru3 . ipa_to_regular_expression ( phonology ) , <str> )  def test_rule_conversion4 ( self ) :          a = ut . Vowel ( ut . Height . open , ut . Backness . front , False , ut . Length . short , <str> ) e = ut . Vowel ( ut . Height . close_mid , ut . Backness . front , False , ut . Length . short , <str> ) i = ut . Vowel ( ut . Height . close , ut . Backness . front , False , ut . Length . short , <str> ) o = ut . Vowel ( ut . Height . close_mid , ut . Backness . back , True , ut . Length . short , <str> ) u = ut . Vowel ( ut . Height . close , ut . Backness . back , True , ut . Length . short , <str> ) b = ut . Consonant ( ut . Place . bilabial , ut . Manner . stop , True , <str> , False ) d = ut . Consonant ( ut . Place . alveolar , ut . Manner . stop , True , <str> , False ) f = ut . Consonant ( ut . Place . labio_dental , ut . Manner . fricative , False , <str> , False ) g = ut . Consonant ( ut . Place . velar , ut . Manner . stop , True , <str> , False ) k = ut . Consonant ( ut . Place . velar , ut . Manner . stop , False , <str> , False ) p = ut . Consonant ( ut . Place . bilabial , ut . Manner . stop , False , <str> , False ) s = ut . Consonant ( ut . Place . alveolar , ut . Manner . fricative , False , <str> , False ) t = ut . Consonant ( ut . Place . alveolar , ut . Manner . stop , False , <str> , False ) v = ut . Consonant ( ut . Place . labio_dental , ut . Manner . fricative , True , <str> , False ) th = ut . Consonant ( ut . Place . dental , ut . Manner . fricative , False , <str> , False ) dh = ut . Consonant ( ut . Place . dental , ut . Manner . fricative , True , <str> , False ) phonology = [ a , e , i , o , u , b , d , f , g , k , p , s , t , v , th , dh ] ipa_class = { <str> : a , <str> : e , <str> : i , <str> : o , <str> : u , <str> : b , <str> : d , <str> : f , <str> : g , <str> : k , <str> : p , <str> : s , <str> : t , <str> : v , <str> : th , <str> : dh , } example = <str> ru4 = ut . Rule . from_regular_expression ( example , <str> , ipa_class ) self . assertEqual ( ru4 . ipa_to_regular_expression ( phonology ) , example )  def test_syllabification_old_norse ( self ) :          old_norse_syllabifier = Syllabifier ( language = <str> , break_geminants = True ) text = <str> <str> tokenizer = WordTokenizer ( <str> ) words = tokenizer . tokenize ( text ) old_norse_syllabifier . set_invalid_onsets ( invalid_onsets ) syllabified_words = [ old_norse_syllabifier . syllabify_ssp ( word . lower ( ) ) for word in words if word not in <str> ] target = [ [ <str> , <str> ] , [ <str> ] , [ <str> ] , [ <str> , <str> ] , [ <str> ] , [ <str> , <str> , <str> ] , [ <str> , <str> ] , [ <str> ] , [ <str> ] , [ <str> ] , [ <str> , <str> , <str> , <str> ] , [ <str> ] , [ <str> , <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> ] , [ <str> ] , [ <str> , <str> ] , [ <str> , <str> , <str> ] , [ <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] , [ <str> , <str> ] ] self . assertListEqual ( syllabified_words , target )  def test_syllabify_phonemes ( self ) :          vowels = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] ipa_hierarchy = [ vowels , [ <str> ] , [ <str> ] , [ <str> , <str> ] , [ <str> , <str> , <str> , <str> , <str> , <str> ] , [ <str> , <str> , <str> , <str> , <str> , <str> ] ] syllabifier = Syllabifier ( ) syllabifier . set_hierarchy ( ipa_hierarchy ) syllabifier . set_vowels ( vowels ) word = [ ont . a , ont . s , ont . g , ont . a , ont . r , ont . dh , ont . r ] syllabified_word = syllabifier . syllabify_phonemes ( word ) self . assertListEqual ( syllabified_word , [ [ ont . a , ont . s ] , [ ont . g , ont . a , ont . r , ont . dh , ont . r ] ] )  def test_syllable1 ( self ) :          sylla1 = Syllable ( <str> , [ <str> ] , [ <str> , <str> ] ) self . assertListEqual ( sylla1 . nucleus , [ <str> ] ) self . assertLessEqual ( sylla1 . onset , [ ] ) self . assertLessEqual ( sylla1 . coda , [ <str> , <str> , <str> ] )  def test_syllable2 ( self ) :          sylla2 = Syllable ( <str> , [ <str> ] , [ <str> , <str> , <str> ] ) self . assertLessEqual ( sylla2 . onset , [ <str> ] ) self . assertLessEqual ( sylla2 . nucleus , [ <str> ] ) self . assertLessEqual ( sylla2 . coda , [ <str> , <str> , <str> ] )  def test_syllable3 ( self ) :          self . assertRaises ( ValueError , Syllable , <str> , [ ] , [ <str> ] )  def test_syllable4 ( self ) :          self . assertRaises ( ValueError , Syllable , <str> , [ ] , [ ] )  def test_syllable5 ( self ) :          self . assertRaises ( ValueError , Syllable , <str> , [ <str> ] , [ <str> ] )  def test_syllable6 ( self ) :          self . assertRaises ( ValueError , Syllable , <str> , [ <str> ] , [ <str> , <str> ] )   if __name__ == <str> :      unittest . main ( )   