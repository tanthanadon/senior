from typing import List import logging import unicodedata from collections import defaultdict from cltk . exceptions import InputError from cltk . corpus . middle_english . syllabifier import Syllabifier as ME_Syllabifier from cltk . corpus . middle_high_german . syllabifier import Syllabifier as MHG_Syllabifier from cltk . corpus . old_english . syllabifier import Syllabifier as OE_Syllabifier from cltk . corpus . old_norse . syllabifier import hierarchy as old_norse_hierarchy from cltk . corpus . old_norse . syllabifier import ipa_hierarchy as ipa_old_norse_hierarchy __author__ = [ <str> , <str> ] __license__ = <str> LOG = logging . getLogger ( __name__ ) LOG . addHandler ( logging . NullHandler ( ) ) def get_onsets ( text , vowels = <str> , threshold = 0.0002 ) :      onset_dict = defaultdict ( lambda : 0 ) n = len ( text ) for word in text :          onset = <str> candidates = [ ] for l in word :              if l not in vowels :                  onset += l  else :                  if onset != <str> :                      candidates . append ( onset ) onset = <str>    for c in candidates :              onset_dict [ c ] += 1   return [ onset for onset , i in onset_dict . items ( ) if i / n > threshold ]  class Syllabifier :      def __init__ ( self , low_vowels = None , mid_vowels = None , high_vowels = None , flaps = None , laterals = None , nasals = None , fricatives = None , plosives = None , language = None , break_geminants = False ) :          self . break_geminants = break_geminants self . invalid_onsets = [ ] self . invalid_ultima = [ ] if language == <str> :              hierarchy = [ [ ] for _ in range ( len ( set ( ME_Syllabifier . values ( ) ) ) ) ] for k in ME_Syllabifier :                  hierarchy [ ME_Syllabifier [ k ] - 1 ] . append ( k )  self . set_hierarchy ( hierarchy ) self . set_vowels ( hierarchy [ 0 ] ) self . invalid_ultima = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ]  elif language == <str> :              hierarchy = [ [ ] for _ in range ( len ( set ( OE_Syllabifier . values ( ) ) ) ) ] for k in OE_Syllabifier :                  hierarchy [ OE_Syllabifier [ k ] - 1 ] . append ( k )  self . set_hierarchy ( hierarchy ) self . set_vowels ( hierarchy [ 0 ] )  elif language == <str> :              hierarchy = [ [ ] for _ in range ( len ( set ( MHG_Syllabifier . values ( ) ) ) ) ] for k in MHG_Syllabifier :                  hierarchy [ MHG_Syllabifier [ k ] - 1 ] . append ( k )  self . set_hierarchy ( hierarchy ) self . set_vowels ( hierarchy [ 0 ] )  elif language == <str> :              self . set_hierarchy ( old_norse_hierarchy ) self . set_vowels ( old_norse_hierarchy [ 0 ] )  elif language == <str> :              self . set_hierarchy ( ipa_old_norse_hierarchy ) self . set_vowels ( ipa_old_norse_hierarchy [ 0 ] )  else :              self . low_vowels = [ ] if low_vowels is None else low_vowels self . mid_vowels = [ ] if mid_vowels is None else mid_vowels self . high_vowels = [ ] if high_vowels is None else high_vowels self . vowels = self . low_vowels + self . mid_vowels + self . high_vowels self . flaps = [ ] if flaps is None else flaps self . laterals = [ ] if laterals is None else laterals self . nasals = [ ] if nasals is None else nasals self . fricatives = [ ] if fricatives is None else fricatives self . plosives = [ ] if plosives is None else plosives self . consonants = self . flaps + self . laterals + self . fricatives + self . plosives self . hierarchy = { key : 0 for key in self . low_vowels } self . hierarchy . update ( { key : 1 for key in self . mid_vowels } ) self . hierarchy . update ( { key : 2 for key in self . high_vowels } ) self . hierarchy . update ( { key : 3 for key in self . flaps } ) self . hierarchy . update ( { key : 4 for key in self . laterals } ) self . hierarchy . update ( { key : 5 for key in self . nasals } ) self . hierarchy . update ( { key : 6 for key in self . fricatives } ) self . hierarchy . update ( { key : 7 for key in self . plosives } )   def set_invalid_onsets ( self , invalid_onsets ) :          self . invalid_onsets = invalid_onsets  def set_invalid_ultima ( self , invalid_ultima ) :          self . invalid_ultima = invalid_ultima  def set_hierarchy ( self , hierarchy ) :          self . hierarchy = dict ( [ ( k , i ) for i , j in enumerate ( hierarchy ) for k in j ] )  def set_vowels ( self , vowels ) :          self . vowels = vowels  def syllabify ( self , word , mode = <str> ) :          if mode == <str> :              return self . syllabify_ssp ( word )   def syllabify_ssp ( self , word ) :          syllables = [ ] find_nucleus = True i = 0 try :              encoded = list ( map ( lambda x : self . hierarchy [ x ] , word ) )  except KeyError :              LOG . error ( <str> <str> ) raise InputError  while i < len ( word ) - 1 :              while word [ i ] not in self . vowels and i < len ( word ) - 1 and find_nucleus :                  i += 1  if find_nucleus is True :                  i += 1  if i >= len ( word ) - 1 :                  break  else :                  if self . break_geminants and word [ i - 1 ] == word [ i ] :                      syllables . append ( i - 1 ) find_nucleus = True  elif encoded [ i - 1 ] == encoded [ i ] == encoded [ i + 1 ] :                      syllables . append ( i ) find_nucleus = True  elif encoded [ i ] > encoded [ i - 1 ] and encoded [ i ] > encoded [ i + 1 ] :                      syllables . append ( i ) find_nucleus = True  elif encoded [ i ] < encoded [ i - 1 ] and encoded [ i ] < encoded [ i + 1 ] :                      syllables . append ( i ) find_nucleus = True  else :                      find_nucleus = False  i += 1   for n , k in enumerate ( syllables ) :              word = word [ : k + n + 1 ] + <str> + word [ k + n + 1 : ]  word = word . split ( <str> ) if sum ( [ x in self . vowels for x in word [ - 1 ] ] ) == 0 :              word [ - 2 ] += word [ - 1 ] word = word [ : - 1 ]  return self . onset_maximization ( word )  def onset_maximization ( self , syllables ) :          for i , syl in enumerate ( syllables ) :              if i != len ( syllables ) - 1 :                  if syllables [ i + 1 ] [ 0 ] in self . vowels and syllables [ i + 1 ] [ - 1 ] not in self . vowels :                      syllables [ i + 1 ] = syllables [ i ] [ - 1 ] + syllables [ i + 1 ] syllables [ i ] = syllables [ i ] [ : - 1 ]    return self . legal_onsets ( syllables )  def legal_onsets ( self , syllables ) :          vowels = self . vowels for i in range ( 1 , len ( syllables ) ) :              onset = <str> for letter in syllables [ i ] :                  if letter in vowels :                      break  onset += letter  for j in range ( len ( onset ) ) :                  if onset [ j : ] not in self . invalid_onsets :                      syllables [ i - 1 ] += onset [ : j ] syllables [ i ] = syllables [ i ] [ j : ] break    if syllables [ - 1 ] in self . invalid_ultima :              syllables [ - 2 ] += syllables [ - 1 ] syllables = syllables [ : - 1 ]  return syllables  def syllabify_ipa ( self , word ) :          word = word [ 1 : - 1 ] word = <str> . join ( l for l in unicodedata . normalize ( <str> , word ) if unicodedata . category ( l ) != <str> ) return self . syllabify_ssp ( word )  def syllabify_phonemes ( self , phonological_word ) :          phoneme_lengths = [ ] l_transcribed_word = [ ] for phoneme in phonological_word :              phoneme_lengths . append ( len ( phoneme . ipar ) ) l_transcribed_word . append ( phoneme . ipar )  transcribed_word = <str> . join ( l_transcribed_word ) transcribed_word = transcribed_word . replace ( <str> , <str> ) syllabified_transcribed_word = self . syllabify_ssp ( transcribed_word ) syllabified_phonological_word = [ ] counter = 0 for i , sts in enumerate ( syllabified_transcribed_word ) :              syllabified_phonological_word . append ( [ ] ) syllable_len = len ( sts ) somme = 0 while somme < syllable_len :                  somme += phoneme_lengths [ counter ] syllabified_phonological_word [ i ] . append ( phonological_word [ counter ] ) counter += 1   return syllabified_phonological_word   class Syllable :      def __init__ ( self , text : str , vowels : List [ str ] , consonants : List [ str ] ) :          self . onset = [ ] self . nucleus = [ ] self . coda = [ ] self . text = text self . consonants = consonants self . vowels = vowels self . _compute_syllable ( text )  def _compute_syllable ( self , text ) :          is_in_onset = True is_in_nucleus = False is_in_coda = False if len ( text ) > 0 :              for c in text :                  if is_in_onset and c in self . consonants :                      self . onset . append ( c )  elif is_in_onset and c in self . vowels :                      is_in_onset = False is_in_nucleus = True self . nucleus . append ( c )  elif is_in_nucleus and c in self . vowels :                      self . nucleus . append ( c )  elif is_in_nucleus and c in self . consonants :                      is_in_nucleus = False is_in_coda = True self . coda . append ( c )  elif is_in_coda and c in self . consonants :                      self . coda . append ( c )  elif is_in_coda and c in self . vowels :                      raise ValueError ( <str> <str> . format ( c ) )  else :                      raise ValueError ( <str> . format ( c ) )   if len ( self . nucleus ) == 0 :                  raise ValueError ( <str> )   else :              raise ValueError ( <str> )   def __str__ ( self ) :          return <str> . join ( self . onset ) + <str> . join ( self . nucleus ) + <str> . join ( self . coda )    