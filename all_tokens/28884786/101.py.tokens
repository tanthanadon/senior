from enum import IntEnum , auto from copy import deepcopy from functools import reduce import re __author__ = [ <str> , <str> ] class PhonologicalFeature ( IntEnum ) :      def __sub__ ( self , other ) :          return make_phoneme ( self ) - other  def __rshift__ ( self , other ) :          return make_phoneme ( self ) >> other  def __le__ ( self , other ) :          return make_phoneme ( self ) <= other  def __ge__ ( self , other ) :          return make_phoneme ( self ) >= other  def matches ( self , other ) :          return make_phoneme ( self ) . matches ( other )  def __eq__ ( self , other ) :          return False if type ( self ) != type ( other ) else IntEnum . __eq__ ( self , other )  def __floordiv__ ( self , other ) :          return make_phoneme ( self ) // other   class Consonantal ( PhonologicalFeature ) :      neg = auto ( ) pos = auto ( )  class Voiced ( PhonologicalFeature ) :      neg = auto ( ) pos = auto ( )  class Aspirated ( PhonologicalFeature ) :      neg = auto ( ) pos = auto ( )  class Geminate ( PhonologicalFeature ) :      neg = auto ( ) pos = auto ( )  class Roundedness ( PhonologicalFeature ) :      neg = auto ( ) pos = auto ( )  class Length ( PhonologicalFeature ) :      short = auto ( ) long = auto ( ) overlong = auto ( )  class Height ( PhonologicalFeature ) :      close = auto ( ) near_close = auto ( ) close_mid = auto ( ) mid = auto ( ) open_mid = auto ( ) near_open = auto ( ) open = auto ( )  class Backness ( PhonologicalFeature ) :      front = auto ( ) central = auto ( ) back = auto ( )  class Manner ( PhonologicalFeature ) :      stop = auto ( ) fricative = auto ( ) affricate = auto ( ) nasal = auto ( ) lateral = auto ( ) trill = auto ( ) spirant = auto ( ) approximant = auto ( )  class Place ( PhonologicalFeature ) :      bilabial = auto ( ) labio_dental = auto ( ) dental = auto ( ) alveolar = auto ( ) post_alveolar = auto ( ) retroflex = auto ( ) palatal = auto ( ) velar = auto ( ) uvular = auto ( ) glottal = auto ( )  class AbstractPhoneme :      def __init__ ( self , features = None , ipa = None ) :          features = { } if features is None else features if len ( set ( features . keys ( ) ) ) != len ( features . keys ( ) ) :              raise ValueError ( <str> )  for feature_name , feature_value in features . items ( ) :              if not issubclass ( feature_name , PhonologicalFeature ) :                  raise TypeError ( str ( feature_name ) + <str> )  if type ( feature_value ) != feature_name :                  raise TypeError ( str ( feature_value ) + <str> + str ( feature_name ) )   self . features = features self . ipa = ipa  def is_vowel ( self ) :          return self [ Consonantal ] == Consonantal . neg  def merge ( self , other ) :          phoneme = deepcopy ( self ) if isinstance ( other , list ) and len ( other ) > 0 and isinstance ( other [ 0 ] , AbstractPhoneme ) :              return other  if isinstance ( other , AbstractPhoneme ) :              feature_values = other . features . values ( )  elif type ( other ) != list and type ( other ) != tuple :              feature_values = [ other ]  else :              feature_values = other  for f in feature_values :              if type ( f ) == list :                  for inner_f in f :                      phoneme [ type ( inner_f ) ] = inner_f   elif isinstance ( f , AbstractPhoneme ) :                  phoneme = phoneme << f  else :                  phoneme [ type ( f ) ] = f   if isinstance ( other , AbstractPhoneme ) and other . ipa is not None :              phoneme . ipa = other . ipa  return phoneme  def is_equal ( self , other ) :          return other is not None and self . features == other . features  def matches ( self , other ) :          if other is None :              return False  if isinstance ( other , PhonemeDisjunction ) :              return any ( [ self <= phoneme for phoneme in other ] )  if isinstance ( other , list ) or isinstance ( other , PhonologicalFeature ) :              other = make_phoneme ( other )  return other . features . items ( ) >= self . features . items ( )  def __getitem__ ( self , feature_name ) :          if not issubclass ( feature_name , PhonologicalFeature ) :              raise TypeError ( str ( feature_name ) + <str> )  return self . features . get ( feature_name , None )  def __setitem__ ( self , feature_name , feature_value ) :          if not issubclass ( feature_name , PhonologicalFeature ) :              raise TypeError ( str ( feature_name ) + <str> )  if type ( feature_value ) != feature_name :              raise TypeError ( str ( feature_value ) + <str> + str ( feature_name ) )  self . features [ feature_name ] = feature_value return self  def __str__ ( self ) :          return ( <str> . format ( self . ipa ) if self . ipa is not None else <str> ) + <str> . join ( [ str ( v ) for v in self . features . values ( ) ] )  __repr__ = __str__ def __eq__ ( self , other ) :          return self . is_equal ( other )  def __le__ ( self , other ) :          return self . matches ( other )  def __ge__ ( self , other ) :          if type ( other ) == list :              other = make_phoneme ( other )  return other . matches ( self )  def __lt__ ( self , other ) :          return other . is_more_sonorous ( self )  def __gt__ ( self , other ) :          return self . is_more_sonorous ( other )  def __rshift__ ( self , other ) :          return PhonologicalRule ( condition = lambda _ , target , __ : self <= target , action = lambda target : target << other )  def __lshift__ ( self , other ) :          return self . merge ( other )  def __sub__ ( self , other ) :          other = make_phoneme ( other ) if not ( isinstance ( other , AbstractPhoneme ) or isinstance ( other , PhonemeDisjunction ) ) else other env_start = PositionedPhoneme ( self , env_start = True ) env_end = PositionedPhoneme ( other , env_end = True ) return lambda before , _ , after : env_start <= before and env_end <= after  def __floordiv__ ( self , other ) :          return PhonemeDisjunction ( self , other )   def make_phoneme ( * feature_values ) :      phoneme = AbstractPhoneme ( { } ) phoneme = phoneme << feature_values return phoneme  def PositionedPhoneme ( phoneme , word_initial = False , word_final = False , syllable_initial = False , syllable_final = False , env_start = False , env_end = False ) :      pos_phoneme = deepcopy ( phoneme ) pos_phoneme . word_initial = word_initial pos_phoneme . word_final = word_final pos_phoneme . syllable_initial = syllable_initial pos_phoneme . syllable_final = syllable_final pos_phoneme . env_start = env_start pos_phoneme . env_end = env_end return pos_phoneme  class AlwaysMatchingPseudoPhoneme ( AbstractPhoneme ) :      def __init__ ( self ) :          AbstractPhoneme . __init__ ( self , ipa = <str> )  def matches ( self , other ) :          return True   class WordBoundaryPseudoPhoneme ( AbstractPhoneme ) :      def __init__ ( self ) :          AbstractPhoneme . __init__ ( self , ipa = <str> )  def matches ( self , other ) :          return other is None  def is_equal ( self , other ) :          return self is other   class SyllableBoundaryPseudoPhoneme ( AbstractPhoneme ) :      def __init__ ( self ) :          AbstractPhoneme . __init__ ( self , ipa = <str> )  def matches ( self , other ) :          if other is None :              return True  elif getattr ( self , <str> , False ) and getattr ( other , <str> , False ) :              return True  elif getattr ( self , <str> , False ) and getattr ( other , <str> , False ) :              return True  else :              return False    ANY = AlwaysMatchingPseudoPhoneme ( ) W = WordBoundaryPseudoPhoneme ( ) S = SyllableBoundaryPseudoPhoneme ( ) class PhonemeDisjunction ( list ) :      def __init__ ( self , * phonemes ) :          super ( ) . __init__ ( self ) if any ( [ not isinstance ( p , AbstractPhoneme ) and not isinstance ( p , PhonologicalFeature ) and not isinstance ( p , list ) for p in phonemes ] ) :              raise TypeError ( phonemes )  true_phonemes = [ make_phoneme ( p ) if not isinstance ( p , AbstractPhoneme ) else p for p in phonemes ] self . extend ( true_phonemes )  def __floordiv__ ( self , other ) :          other = make_phoneme ( other ) if ( isinstance ( other , PhonologicalFeature ) or isinstance ( other , list ) ) else other if isinstance ( other , AbstractPhoneme ) :              self . append ( other ) return self  else :              raise TypeError ( other )   def __rshift__ ( self , other ) :          return PhonologicalRule ( condition = lambda _ , target , __ : any ( [ phoneme <= target for phoneme in self ] ) , action = lambda target : target << other )  def matches ( self , other ) :          if other is None :              return False  if isinstance ( other , PhonemeDisjunction ) :              return any ( [ phoneme . matches ( other ) for phoneme in self ] )  if isinstance ( other , list ) or isinstance ( other , PhonologicalFeature ) :              other = make_phoneme ( other )  return any ( [ phoneme <= other for phoneme in self ] )  def __sub__ ( self , other ) :          other = make_phoneme ( other ) if not ( isinstance ( other , AbstractPhoneme ) or isinstance ( other , PhonemeDisjunction ) ) else other env_start = [ PositionedPhoneme ( phoneme , env_start = True ) for phoneme in self ] env_end = PositionedPhoneme ( other , env_end = True ) return lambda before , _ , after : any ( [ phoneme <= before for phoneme in env_start ] ) and env_end <= after  def __le__ ( self , other ) :          return False if other is None else self . matches ( other )  def __ge__ ( self , other ) :          return False if other is None else other . matches ( self )   class Consonant ( AbstractPhoneme ) :      def __init__ ( self , place , manner , voiced , ipa , geminate = Geminate . neg , aspirated = Aspirated . neg ) :          assert place is not None assert manner is not None assert voiced is not None assert geminate is not None assert ipa is not None AbstractPhoneme . __init__ ( self , { Consonantal : Consonantal . pos , Place : place , Manner : manner , Voiced : voiced , Aspirated : aspirated , Geminate : geminate } , ipa )  def is_more_sonorous ( self , other ) :          return True if isinstance ( other , Consonant ) and self [ Manner ] > other [ Manner ] else False  def merge ( self , other ) :          if isinstance ( other , Vowel ) :              return other  else :              return AbstractPhoneme . merge ( self , other )   def geminate ( self ) :          consonant = deepcopy ( self ) if consonant [ Geminate ] == Geminate . neg :              consonant [ Geminate ] = Geminate . pos consonant . ipa += <str>  return consonant   class Vowel ( AbstractPhoneme ) :      def __init__ ( self , height , backness , rounded , length , ipa ) :          assert height is not None assert backness is not None assert rounded is not None assert length is not None assert ipa is not None AbstractPhoneme . __init__ ( self , { Consonantal : Consonantal . neg , Height : height , Backness : backness , Roundedness : rounded , Length : length } , ipa )  def __add__ ( self , other ) :          diphthong = deepcopy ( self ) diphthong . ipa += other . ipa return diphthong  def lengthen ( self ) :          vowel = deepcopy ( self ) if vowel [ Length ] == Length . short :              vowel [ Length ] = Length . long  elif vowel [ Length ] == Length . long :              vowel [ Length ] = Length . overlong  vowel . ipa += <str> return vowel  def is_more_sonorous ( self , other ) :          if isinstance ( other , Consonant ) :              return True  elif self [ Height ] > other [ Height ] :              return True  elif self [ Height ] == other [ Height ] :              return self [ Backness ] > other [ Backness ]  else :              return False   def merge ( self , other ) :          if isinstance ( other , Consonant ) :              return other  else :              return AbstractPhoneme . merge ( self , other )    class BasePhonologicalRule :      def __init__ ( self , condition , action ) :          self . condition = condition self . action = action  def perform_action ( self , phonemes , pos ) :          return self . action ( phonemes [ pos ] )  def __call__ ( self , phonemes , pos ) :          return self . perform_action ( phonemes , pos )  def __or__ ( self , other_condition ) :          prev_function = self . condition self . condition = lambda before , target , after : prev_function ( before , target , after ) and other_condition ( before , target , after ) return self   class PhonologicalRule ( BasePhonologicalRule ) :      def check_environment ( self , phonemes , pos ) :          if pos >= len ( phonemes ) :              return False  before = None if pos == 0 else phonemes [ pos - 1 ] after = None if pos == len ( phonemes ) - 1 else phonemes [ pos + 1 ] return self . condition ( before , phonemes [ pos ] , after )   class PhonemeNotFound ( Exception ) :      def __init__ ( self , phoneme ) :          self . unfound_phoneme = phoneme   class LetterNotFound ( Exception ) :      def __init__ ( self , letter ) :          self . unfound_letter = letter   ipa_to_pde = { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } pde_phonotactics = [ ( <str> , <str> ) , ( <str> , <str> ) ] class Orthophonology :      def __init__ ( self , sound_inventory , alphabet , diphthongs , digraphs , to_modern = ( ipa_to_pde , pde_phonotactics ) ) :          self . sound_inventory = sound_inventory self . alphabet = alphabet self . diphthongs = diphthongs self . digraphs = digraphs self . di = { ** self . diphthongs , ** self . digraphs } self . rules = [ ] self . to_modern = to_modern  def add_rule ( self , rule ) :          self . rules . append ( rule )  def is_syllable_initial ( self , phonemes , pos ) :          if pos == len ( phonemes ) - 1 :              return False  return pos == 0 or ( phonemes [ pos - 1 ] . is_more_sonorous ( phonemes [ pos ] ) and not phonemes [ pos ] . is_more_sonorous ( phonemes [ pos + 1 ] ) )  def is_syllable_final ( self , phonemes , pos ) :          return pos == len ( phonemes ) - 1 or self . is_syllable_initial ( phonemes , pos + 1 )  @ staticmethod def _tokenize ( text ) :          text = text . lower ( ) text = re . sub ( <str> , <str> , text ) return text . split ( <str> )  def _position_phonemes ( self , phonemes ) :          for i in range ( len ( phonemes ) ) :              phonemes [ i ] = PositionedPhoneme ( phonemes [ i ] ) phonemes [ i ] . syllable_initial = self . is_syllable_initial ( phonemes , i ) phonemes [ i ] . syllable_final = self . is_syllable_final ( phonemes , i )  return phonemes  def _find_sound ( self , phoneme ) :          for sound in self . sound_inventory :              if sound . is_equal ( phoneme ) :                  return sound   raise PhonemeNotFound ( phoneme )  def transcribe_word ( self , word ) :          phonemes = [ ] i = 0 while i < len ( word ) :              if i < len ( word ) - 1 and word [ i : i + 2 ] in self . di :                  letter_pair = word [ i : i + 2 ] replacement = self . di [ letter_pair ] replacement = replacement if isinstance ( replacement , list ) else [ replacement ] phonemes . extend ( replacement ) i += 2  else :                  phonemes . append ( self [ word [ i ] ] ) i += 1   i = 0 while i < len ( phonemes ) :              for rule in self . rules :                  phonemes = self . _position_phonemes ( phonemes ) if rule . check_environment ( phonemes , i ) :                      replacement = rule ( phonemes , i ) replacement = [ replacement ] if not isinstance ( replacement , list ) else replacement new_phonemes = [ self . _find_sound ( p ) for p in replacement ] phonemes [ i : i + 1 ] = new_phonemes i += len ( replacement ) - 1 break   i += 1  return phonemes  def transcribe ( self , text , as_phonemes = False ) :          phoneme_words = [ self . transcribe_word ( word ) for word in self . _tokenize ( text ) ] if not as_phonemes :              words = [ <str> . join ( [ phoneme . ipa for phoneme in word ] ) for word in phoneme_words ] return <str> . join ( words )  else :              return phoneme_words   def transcribe_to_modern ( self , text ) :          phoneme_words = self . transcribe ( text , as_phonemes = True ) words = [ <str> . join ( [ self . to_modern [ 0 ] [ phoneme . ipa ] for phoneme in word ] ) for word in phoneme_words ] modern_text = <str> . join ( words ) for regexp , replacement in self . to_modern [ 1 ] :              modern_text = re . sub ( regexp , replacement , modern_text )  return modern_text  def voice ( self , consonant ) :          voiced_consonant = deepcopy ( consonant ) voiced_consonant [ Voiced ] = Voiced . pos return self . _find_sound ( voiced_consonant )  def aspirate ( self , consonant ) :          aspirated_consonant = deepcopy ( consonant ) aspirated_consonant [ Aspirated ] = Aspirated . pos return self . _find_sound ( aspirated_consonant )  def geminate ( self , consonant ) :          geminate_consonant = deepcopy ( consonant ) geminate_consonant [ Geminate ] = Geminate . pos return self . _find_sound ( geminate_consonant )  @ staticmethod def lengthen ( vowel ) :          return vowel . lengthen ( )  def __call__ ( self , text , as_phonemes = False ) :          return self . transcribe ( text , as_phonemes )  def __getitem__ ( self , letter ) :          phoneme = self . alphabet . get ( letter , None ) if phoneme is not None :              return phoneme  else :              raise LetterNotFound ( letter )   def __lshift__ ( self , rule ) :          self . add_rule ( rule )    