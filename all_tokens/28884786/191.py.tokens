import logging import re from collections import Counter from typing import Any , Dict , List , Set from cltk . stem . latin . j_v import JVReplacer from cltk . prosody . latin . string_utils import punctuation_for_spaces_dict , remove_punctuation_dict from cltk . prosody . latin . scansion_constants import ScansionConstants __author__ = [ <str> ] __license__ = <str> LOG = logging . getLogger ( __name__ ) LOG . addHandler ( logging . NullHandler ( ) ) _lower_alpha_pattern = re . compile ( <str> ) def drop_all_caps ( string_matrix : List [ List [ str ] ] ) -> List [ List [ str ] ] :      return [ [ word for word in sentence if _lower_alpha_pattern . match ( word ) ] for sentence in string_matrix ]  _arabic_numeric_pattern = re . compile ( <str> ) def drop_arabic_numeric ( string_matrix : List [ List [ str ] ] ) -> List [ List [ str ] ] :      return [ [ word for word in sentence if not _arabic_numeric_pattern . match ( word ) ] for sentence in string_matrix ]  def drop_empty_lists ( string_matrix : List [ List [ str ] ] ) -> List [ List [ str ] ] :      return [ sentence for sentence in string_matrix if sentence ]  def drop_non_lower ( string_matrix : List [ List [ str ] ] ) -> List [ List [ str ] ] :      return [ [ word for word in sentence if word . upper ( ) != word ] for sentence in string_matrix ]  def clean_latin_text ( string_matrix : List [ List [ str ] ] ) -> List [ List [ str ] ] :      return drop_empty_lists ( drop_probable_entities ( drop_all_caps ( drop_arabic_numeric ( drop_non_lower ( ( string_matrix ) ) ) ) ) )  def drop_probable_entities ( string_matrix : List [ List [ str ] ] ) -> List [ List [ str ] ] :      return [ [ word for word in sentence if word [ 0 ] . lower ( ) == word [ 0 ] ] for sentence in string_matrix ]  _jvreplacer = JVReplacer ( ) def jv_transform ( string_matrix : List [ List [ str ] ] ) -> List [ List [ str ] ] :      return [ [ _jvreplacer . replace ( word ) for word in sentence ] for sentence in string_matrix ]  def drop_enclitics ( string_matrix : List [ List [ str ] ] ) -> List [ List [ str ] ] :      return [ [ word for word in sentence if not word . startswith ( <str> ) ] for sentence in string_matrix ]  def drop_short_sentences ( string_matrix : List [ List [ str ] ] , min_len : int = 2 ) -> List [ List [ str ] ] :      return [ sentence for sentence in string_matrix if len ( sentence ) > min_len ]  def drop_empty_strings ( string_matrix : List [ List [ str ] ] ) -> List [ List [ str ] ] :      return [ [ word for word in sentence if len ( word ) > 0 ] for sentence in string_matrix ]  def drop_edge_punct ( word : str ) -> str :      if not word :          return word  try :          if not word [ 0 ] . isalpha ( ) :              word = word [ 1 : ]  if not word [ - 1 ] . isalpha ( ) :              word = word [ : - 1 ]   except :          pass  return word  def profile_chars ( string_matrix : List [ List [ str ] ] ) -> Dict [ str , int ] :      char_counter = Counter ( ) for sentence in string_matrix :          for word in sentence :              for car in word :                  char_counter . update ( { car : 1 } )    return char_counter  _camel_pattern = re . compile ( <str> ) def split_camel ( word : str ) -> str :      m = _camel_pattern . match ( word ) if m :          _ , end = m . span ( ) return word [ : end - 2 ] + <str> + word [ end - 2 : ]  return word  def separate_camel_cases ( string_matrix : List [ List [ str ] ] ) -> List [ List [ str ] ] :      return [ [ split_camel ( word ) for word in sentence ] for sentence in string_matrix ]  def demacronize ( string_matrix : List [ List [ str ] ] ) -> List [ List [ str ] ] :      scansion = ScansionConstants ( ) accent_dropper = str . maketrans ( scansion . ACCENTED_VOWELS , scansion . VOWELS ) return [ [ word . translate ( accent_dropper ) for word in sentence ] for sentence in string_matrix ]  def drop_all_punctuation ( string_matrix : List [ List [ str ] ] ) -> List [ List [ str ] ] :      punct_spaces = remove_punctuation_dict ( ) return [ [ drop_punctuation ( word , transformation_table = punct_spaces ) for word in sentence ] for sentence in string_matrix ]  def splice_hyphenated_word ( word : str ) -> str :      hyphen_codes = [ 45 , 8212 ] hyphens = [ chr ( val ) for val in hyphen_codes ] return re . sub ( <str> . format ( <str> . join ( hyphens ) ) , <str> , word )  def splice_hyphens ( string_matrix : List [ List [ str ] ] ) -> List [ List [ str ] ] :      return [ [ splice_hyphenated_word ( word ) for word in sentence ] for sentence in string_matrix ]  _plus_tilde_pattern = re . compile ( <str> ) _multispaces_pattern = re . compile ( <str> ) def drop_punctuation ( word : str , transformation_table : Dict [ int , Any ] = None ) -> str :      word = _plus_tilde_pattern . sub ( <str> , word ) if transformation_table :          word = word . translate ( transformation_table )  return _multispaces_pattern . sub ( <str> , word ) . strip ( )  def divide_separate_words ( string_matrix : List [ List [ str ] ] ) -> List [ List [ str ] ] :      new_X = [ ] for sentence in string_matrix :          data_row = [ ] for word in sentence :              if <str> in word :                  data_row += word . split ( )  else :                  data_row . append ( word )   new_X . append ( data_row )  return new_X  def drop_fringe_punctuation ( string_matrix : List [ List [ str ] ] ) -> List [ List [ str ] ] :      return [ [ drop_edge_punct ( word ) for word in sentence ] for sentence in string_matrix ]  _editorial_pattern = re . compile ( <str> ) def drop_editorial ( string_matrix : List [ List [ str ] ] ) -> List [ List [ str ] ] :      return [ [ _editorial_pattern . sub ( <str> , word ) for word in sentence ] for sentence in string_matrix ]  _editorial_start_pattern = re . compile ( <str> ) _editorial_end_pattern = re . compile ( <str> ) def accept_editorial ( string_matrix : List [ List [ str ] ] ) -> List [ List [ str ] ] :      return [ [ _editorial_end_pattern . sub ( <str> , _editorial_start_pattern . sub ( <str> , word ) ) for word in sentence ] for sentence in string_matrix ]  def distinct_words ( string_matrix : List [ List [ str ] ] ) -> Set [ str ] :      return set ( [ word for sentence in string_matrix for word in sentence ] )  def distinct_letters ( string_matrix : List [ List [ str ] ] ) -> Set [ str ] :      return set ( [ letter for sentence in string_matrix for word in sentence for letter in word ] )  def word_for_char ( string_matrix : List [ List [ str ] ] , character : str ) -> List [ str ] :      return [ word for sentence in string_matrix for word in sentence if character in word ]   