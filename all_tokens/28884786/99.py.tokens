import re from enum import Enum , auto from cltk . utils . cltk_logger import logger __author__ = [ <str> , ] class AutoName ( Enum ) :      def _generate_next_value_ ( name , a , b , d ) :          return name   class Manner ( AutoName ) :      nasal = auto ( ) stop = auto ( ) lateral = auto ( ) fricative = auto ( ) trill = auto ( ) spirant = auto ( ) affricate = auto ( ) approximant = auto ( )  class Place ( AutoName ) :      bilabial = auto ( ) labio_dental = auto ( ) dental = auto ( ) alveolar = auto ( ) post_alveolar = auto ( ) retroflex = auto ( ) palatal = auto ( ) velar = auto ( ) uvular = auto ( ) glottal = auto ( )  class AbstractConsonant :      def __init__ ( self , place = None , manner = None , voiced = None , ipar = None , geminate = None ) :          if isinstance ( place , Place ) or place is None :              self . place = place  else :              logger . error ( <str> )  if isinstance ( manner , Manner ) or manner is None :              self . manner = manner  else :              logger . error ( <str> ) raise ValueError  if type ( voiced ) == bool or voiced is None :              self . voiced = voiced  else :              logger . error ( <str> ) raise TypeError  if type ( geminate ) == bool or geminate is None :              self . geminate = geminate  else :              logger . error ( <str> ) raise TypeError  self . ipar = ipar  def __str__ ( self ) :          return self . ipar   class Consonant ( AbstractConsonant ) :      def __init__ ( self , place , manner , voiced , ipar , geminate ) :          assert place is not None assert manner is not None assert voiced is not None assert ipar is not None assert geminate is not None AbstractConsonant . __init__ ( self , place , manner , voiced , ipar , geminate )  def match ( self , abstract_consonant : AbstractConsonant ) -> bool :          if isinstance ( abstract_consonant , AbstractConsonant ) :              res = True if abstract_consonant . place is not None :                  res = res and abstract_consonant . place == self . place  if abstract_consonant . manner is not None :                  res = res and abstract_consonant . manner == self . manner  if abstract_consonant . voiced is not None :                  res = res and abstract_consonant . voiced == self . voiced  if abstract_consonant . geminate is not None :                  res = res and abstract_consonant . geminate == self . geminate  return res  elif abstract_consonant is None :              return True  else :              return False   def match_list ( self , abstract_consonant_list ) :          if type ( abstract_consonant_list ) == list :              if len ( abstract_consonant_list ) == 0 :                  return True  else :                  res = False for ac in abstract_consonant_list :                      if isinstance ( ac , AbstractConsonant ) :                          res = self . match ( ac ) or res   return res   else :              return False   def lengthen ( self ) :          geminate = True if not self . geminate :              ipar = self . ipar + <str>  else :              ipar = self . ipar  return Consonant ( self . place , self . manner , self . voiced , ipar , geminate )  def to_abstract ( self ) :          return AbstractConsonant ( self . place , self . manner , self . voiced , self . ipar , self . geminate )  def __add__ ( self , other ) :          return Consonant ( self . place , self . manner , self . voiced , self . ipar + other . ipar , False )  def __str__ ( self ) :          return self . ipar  __repr__ = __str__ def is_equal ( self , other_consonnant ) :          return self . place == other_consonnant . place and self . manner == other_consonnant . manner and self . voiced == other_consonnant . voiced and self . geminate == other_consonnant . geminate   class Height ( AutoName ) :      open = auto ( ) near_open = auto ( ) open_mid = auto ( ) mid = auto ( ) close_mid = auto ( ) near_close = auto ( ) close = auto ( )  class Backness ( AutoName ) :      front = auto ( ) central = auto ( ) back = auto ( )  class Length ( AutoName ) :      short = auto ( ) long = auto ( ) overlong = auto ( )  class AbstractVowel :      def __init__ ( self , height = None , backness = None , rounded = None , length = None , ipar = None ) :          if isinstance ( height , Height ) or height is None :              self . height = height  else :              logger . error ( <str> ) raise ValueError  if isinstance ( backness , Backness ) or backness is None :              self . backness = backness  else :              logger . error ( <str> ) raise ValueError  if type ( rounded ) == bool or rounded is None :              self . rounded = rounded  else :              logger . error ( <str> ) raise TypeError  if isinstance ( length , Length ) or length is None :              self . length = length  else :              logger . error ( <str> ) raise ValueError  self . ipar = ipar  def __str__ ( self ) :          return self . ipar   class Vowel ( AbstractVowel ) :      def __init__ ( self , height , backness , rounded , length , ipar ) :          assert height is not None assert backness is not None assert rounded is not None assert length is not None assert ipar is not None AbstractVowel . __init__ ( self , height , backness , rounded , length , ipar )  def lengthen ( self ) :          if self . length == Length . short :              length = Length . long ipar = self . ipar + <str>  else :              ipar = self . ipar length = Length . short  return Vowel ( self . height , self . backness , self . rounded , length , ipar )  def match ( self , abstract_vowel ) :          if isinstance ( abstract_vowel , AbstractVowel ) :              res = True if abstract_vowel . height is not None :                  res = res and abstract_vowel . height == self . height  if abstract_vowel . backness is not None :                  res = res and abstract_vowel . backness == self . backness  if abstract_vowel . rounded is not None :                  res = res and abstract_vowel . rounded == self . rounded  if abstract_vowel . length is not None :                  res = res and abstract_vowel . length == self . length  return res  elif abstract_vowel is None :              return True  else :              return False   def match_list ( self , abstract_vowel_list ) :          if type ( abstract_vowel_list ) == list :              if len ( abstract_vowel_list ) == 0 :                  return True  else :                  res = False for av in abstract_vowel_list :                      if isinstance ( av , AbstractVowel ) :                          res = self . match ( av ) or res   return res   else :              return False   def to_abstract ( self ) :          return AbstractVowel ( self . height , self . backness , self . rounded , self . length , self . ipar )  def i_umlaut ( self ) :          pass  def u_umlaut ( self ) :          pass  def __str__ ( self ) :          return self . ipar  __repr__ = __str__ def is_equal ( self , other_sound ) :          return self . height == other_sound . height and self . backness == other_sound . backness and self . rounded == other_sound . rounded and self . length == other_sound . length  def __add__ ( self , other ) :          return Vowel ( self . height , self . backness , self . rounded , self . length , self . ipar + other . ipar )   class Rank ( AutoName ) :      first = auto ( ) inner = auto ( ) last = auto ( )  class AbstractPosition :      def __init__ ( self , position , before , after ) :          assert isinstance ( position , Rank ) self . position = position self . before = before self . after = after  def __eq__ ( self , other ) :          assert isinstance ( other , AbstractPosition ) return self . position == other . position and self . before == other . before and self . after == other . after  def same_place ( self , other ) :          assert isinstance ( other , AbstractPosition ) return self . position == other . position  def __add__ ( self , other ) :          assert self . position == other . position if self . before is None and other . before :              before = None  elif self . before is None :              before = other . before  elif other . before is None :              before = self . before  else :              before = [ ] before . extend ( self . before ) before . extend ( other . before )  if self . after is None and other . after is None :              after = None  elif self . after is None :              after = other . after  elif other . after is None :              after = self . after  else :              after = [ ] after . extend ( self . after ) after . extend ( other . after )  return AbstractPosition ( self . position , before , after )   class Position :      def __init__ ( self , position , before , after ) :          assert isinstance ( position , Rank ) self . position = position assert isinstance ( before , Consonant ) or isinstance ( before , Vowel ) or before is None self . before = before assert isinstance ( after , Consonant ) or isinstance ( after , Vowel ) or after is None self . after = after  def real_sound_match_abstract_sound ( self , abstract_pos : AbstractPosition ) -> bool :          assert isinstance ( abstract_pos , AbstractPosition ) if self . before is not None and self . after is not None :              return self . position == abstract_pos . position and self . before . match_list ( abstract_pos . before ) and self . after . match_list ( abstract_pos . after )  elif self . before is None and self . after is None :              return self . position == abstract_pos . position  elif self . before is None :              return self . position == abstract_pos . position and self . after . match_list ( abstract_pos . after )  else :              return self . position == abstract_pos . position and self . before . match_list ( abstract_pos . before )    class Rule :      def __init__ ( self , position , temp_sound , estimated_sound ) :          assert isinstance ( position , AbstractPosition ) self . position = position assert isinstance ( temp_sound , Vowel ) or isinstance ( temp_sound , Consonant ) self . temp_sound = temp_sound assert isinstance ( estimated_sound , Vowel ) or isinstance ( estimated_sound , Consonant ) self . estimated_sound = estimated_sound  def can_apply ( self , current_position : Position ) -> bool :          return current_position . real_sound_match_abstract_sound ( self . position )  def ipa_to_regular_expression ( self , phonology ) :          if self . position . position == Rank . first :              re_before = <str>  elif self . position . before is None :              re_before = <str>  else :              re_before = <str> for phoneme in phonology :                  if phoneme . match_list ( self . position . before ) :                      re_before += phoneme . ipar   re_before += <str>  if self . position . position == Rank . last :              re_after = <str>  elif self . position . after is None :              re_after = <str>  else :              re_after = <str> for phoneme in phonology :                  if phoneme . match_list ( self . position . after ) :                      re_after += phoneme . ipar   re_after += <str>  return re_before + self . temp_sound . ipar + re_after  @ staticmethod def from_regular_expression ( re_rule , estimated_sound , ipa_class ) :          assert len ( re_rule ) > 0 if re_rule [ 0 ] == <str> :              place = Rank . first  elif re_rule [ - 1 ] == <str> :              place = Rank . last  else :              place = Rank . inner  before_pattern = <str> core_pattern = <str> after_pattern = <str> before_search = re . search ( before_pattern , re_rule ) core_search = re . search ( core_pattern , re_rule ) after_search = re . search ( after_pattern , re_rule ) if before_search is None :              before = None  else :              before = [ ipa_class [ ipar ] . to_abstract ( ) for ipar in before_search . group ( 0 ) ]  if core_search is not None :              core = ipa_class [ core_search . group ( 0 ) ]  else :              logger . error ( <str> ) raise ValueError  if after_search is None :              after = None  else :              after = [ ipa_class [ ipar ] . to_abstract ( ) for ipar in after_search . group ( 0 ) ]  abstract_position = AbstractPosition ( place , before , after ) return Rule ( abstract_position , core , ipa_class [ estimated_sound ] )  def __add__ ( self , other ) :          assert isinstance ( other , Rule ) assert self . position . same_place ( other . position ) assert self . temp_sound . ipar == other . temp_sound . ipar assert self . estimated_sound . ipar == other . estimated_sound . ipar position = self . position + other . position return Rule ( position , self . temp_sound , self . estimated_sound )   class Transcriber :      def __init__ ( self , diphthongs_ipa : dict , diphthongs_ipa_class : dict , ipa_class : dict , rules : list ) :          self . diphthongs_ipa = diphthongs_ipa self . diphthongs_ipa_class = diphthongs_ipa_class self . ipa_class = ipa_class self . rules = rules  def text_to_phonetic_representation ( self , sentence : str ) -> str :          transliterated = [ ] sentence = sentence . lower ( ) sentence = re . sub ( <str> , <str> , sentence ) for word in sentence . split ( <str> ) :              phonemes = self . text_to_phonemes ( word ) phonetic_representation = self . phonemes_to_phonetic_representation ( phonemes ) transliterated . append ( phonetic_representation )  return <str> + <str> . join ( transliterated ) + <str>  def text_to_phonemes ( self , word : str ) -> list :          phonemes = [ ] is_repeted = False if len ( word ) >= 2 :              for index in range ( len ( word ) - 1 ) :                  if is_repeted :                      is_repeted = False continue  if word [ index : index + 2 ] in self . diphthongs_ipa :                      phonemes . append ( self . diphthongs_ipa_class [ word [ index ] + word [ index + 1 ] ] ) is_repeted = True  elif word [ index ] == word [ index + 1 ] :                      phonemes . append ( self . ipa_class [ word [ index ] ] . lengthen ( ) ) is_repeted = True  else :                      phonemes . append ( self . ipa_class [ word [ index ] ] )   if not is_repeted :                  phonemes . append ( self . ipa_class [ word [ len ( word ) - 1 ] ] )   else :              phonemes . append ( self . ipa_class [ word [ 0 ] ] )  return phonemes  def phonemes_to_phonetic_representation ( self , phonemes : list ) -> str :          phonetic_representation = [ ] if len ( phonemes ) >= 2 :              for i in range ( len ( phonemes ) ) :                  if i == 0 :                      current_pos = Position ( Rank . first , None , phonemes [ i ] )  elif i < len ( phonemes ) - 1 :                      current_pos = Position ( Rank . inner , phonemes [ i - 1 ] , phonemes [ i + 1 ] )  else :                      current_pos = Position ( Rank . last , phonemes [ i - 1 ] , None )  found = False for rule in self . rules :                      if rule . temp_sound . ipar == phonemes [ i ] . ipar :                          if rule . can_apply ( current_pos ) :                              phonetic_representation . append ( rule . estimated_sound . ipar ) found = True break    if not found :                      phonetic_representation . append ( phonemes [ i ] . ipar )    else :              phonetic_representation . append ( phonemes [ 0 ] . ipar )  return <str> . join ( phonetic_representation )   class BasePhonologicalRule :      def __init__ ( self , condition , action ) :          self . condition = condition self . action = action  def perform_action ( self , phonemes , pos ) :          return self . action ( phonemes [ pos ] )  def __call__ ( self , phonemes , pos ) :          return self . perform_action ( phonemes , pos )   class PhonologicalRule ( BasePhonologicalRule ) :      def check_environment ( self , phonemes , pos ) :          before = phonemes [ pos - 1 ] if pos > 0 else None after = phonemes [ pos + 1 ] if pos < len ( phonemes ) - 1 else None return self . condition ( before , phonemes [ pos ] , after )   class WordInitialPhonologicalRule ( BasePhonologicalRule ) :      def check_environment ( self , phonemes , pos ) :          return self . condition ( phonemes [ 0 ] , phonemes [ 1 ] ) if pos == 0 and len ( phonemes ) > 1 else False  def perform_action ( self , phonemes , _ ) :          return self . action ( phonemes [ 0 ] )   class WordFinalPhonologicalRule ( BasePhonologicalRule ) :      def check_environment ( self , phonemes , pos ) :          last = len ( phonemes ) - 1 return self . condition ( phonemes [ last - 1 ] , phonemes [ last ] ) if pos == last and len ( phonemes ) > 1 else False  def perform_action ( self , phonemes , _ ) :          return self . action ( phonemes [ len ( phonemes ) - 2 ] )   class IPATranscriber :      def __init__ ( self , digraphs : dict , dipthongs : dict , alphabet : dict , rules : list ) :          self . digraphs = digraphs self . dipthongs = dipthongs self . alphabet = alphabet self . rules = rules  @ staticmethod def tokenize ( text ) :          text = text . lower ( ) text = re . sub ( <str> , <str> , text ) return text . split ( <str> )  def transcribe_word ( self , word ) :          phonemes = [ self . alphabet [ letter ] for letter in word ] for i in range ( len ( phonemes ) ) :              for rule in self . rules :                  if rule . check_environment ( phonemes , i ) :                      phonemes [ i ] = rule ( phonemes , i )    return phonemes  def transcribe ( self , text ) :          return [ self . transcribe_word ( word ) for word in self . tokenize ( text ) ]    