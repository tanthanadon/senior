import re import logging from typing import List , Dict , Any from cltk . prosody . latin . verse import Verse from cltk . prosody . latin . metrical_validator import MetricalValidator from cltk . prosody . latin . scansion_constants import ScansionConstants from cltk . prosody . latin . scansion_formatter import ScansionFormatter from cltk . prosody . latin . syllabifier import Syllabifier import cltk . prosody . latin . string_utils as string_utils LOG = logging . getLogger ( __name__ ) LOG . addHandler ( logging . NullHandler ( ) ) __author__ = [ <str> ] __license__ = <str> class VerseScanner :      def __init__ ( self , constants = ScansionConstants ( ) , syllabifier = Syllabifier ( ) , ** kwargs ) :          self . constants = constants self . remove_punct_map = string_utils . remove_punctuation_dict ( ) self . punctuation_substitutions = string_utils . punctuation_for_spaces_dict ( ) self . metrical_validator = MetricalValidator ( constants ) self . formatter = ScansionFormatter ( constants ) self . syllabifier = syllabifier self . inverted_amphibrach_re = re . compile ( <str> . format ( self . constants . STRESSED , self . constants . UNSTRESSED , self . constants . STRESSED ) ) self . syllable_matcher = re . compile ( <str> . format ( self . constants . VOWELS + self . constants . ACCENTED_VOWELS + self . constants . LIQUIDS + self . constants . MUTES ) )  def transform_i_to_j ( self , line : str ) -> str :          words = line . split ( <str> ) space_list = string_utils . space_list ( line ) corrected_words = [ ] for word in words :              found = False for prefix in self . constants . PREFIXES :                  if word . startswith ( prefix ) and word != prefix :                      corrected_words . append ( self . syllabifier . convert_consonantal_i ( prefix ) ) corrected_words . append ( self . syllabifier . convert_consonantal_i ( word [ len ( prefix ) : ] ) ) found = True break   if not found :                  corrected_words . append ( self . syllabifier . convert_consonantal_i ( word ) )   new_line = string_utils . join_syllables_spaces ( corrected_words , space_list ) char_list = string_utils . overwrite ( list ( new_line ) , <str> . format ( self . constants . VOWELS + self . constants . ACCENTED_VOWELS ) , <str> ) char_list = string_utils . overwrite ( char_list , <str> . format ( self . constants . VOWELS_WO_I ) , <str> ) char_list = string_utils . overwrite ( char_list , <str> . format ( self . constants . VOWELS_WO_I , self . constants . VOWELS ) , <str> , 1 ) return <str> . join ( char_list )  def transform_i_to_j_optional ( self , line : str ) -> str :          words = line . split ( <str> ) space_list = string_utils . space_list ( line ) corrected_words = [ ] for word in words :              found = False for prefix in self . constants . PREFIXES :                  if word . startswith ( prefix ) and word != prefix :                      corrected_words . append ( self . syllabifier . convert_consonantal_i ( prefix ) ) corrected_words . append ( self . syllabifier . convert_consonantal_i ( word [ len ( prefix ) : ] ) ) found = True break   if not found :                  corrected_words . append ( self . syllabifier . convert_consonantal_i ( word ) )   new_line = string_utils . join_syllables_spaces ( corrected_words , space_list ) char_list = string_utils . overwrite ( list ( new_line ) , <str> . format ( self . constants . VOWELS_WO_I ) , <str> , 1 ) char_list = string_utils . overwrite ( char_list , <str> . format ( self . constants . LIQUIDS , self . constants . VOWELS_WO_I ) , <str> , 1 ) return <str> . join ( char_list )  def accent_by_position ( self , verse_line : str ) -> str :          line = verse_line . translate ( self . punctuation_substitutions ) line = self . transform_i_to_j ( line ) marks = list ( line ) dipthong_positions = [ ] for dipth in self . constants . DIPTHONGS :              if dipth in line :                  dipthong_positions . append ( line . find ( dipth ) )   marks = string_utils . overwrite ( marks , <str> . format ( self . constants . VOWELS , self . constants . CONSONANTS , self . constants . CONSONANTS_WO_H ) , self . constants . STRESSED ) marks = string_utils . overwrite ( marks , <str> . format ( self . constants . VOWELS , self . constants . CONSONANTS , self . constants . CONSONANTS_WO_H ) , self . constants . STRESSED ) marks = string_utils . overwrite ( marks , <str> . format ( self . constants . VOWELS , self . constants . CONSONANTS , self . constants . CONSONANTS_WO_H ) , self . constants . STRESSED ) marks = string_utils . overwrite ( marks , <str> . format ( self . constants . VOWELS ) , self . constants . STRESSED ) marks = string_utils . overwrite ( marks , <str> . format ( self . constants . VOWELS ) , self . constants . STRESSED ) original_verse = list ( line ) for idx , word in enumerate ( original_verse ) :              if marks [ idx ] == self . constants . STRESSED :                  original_verse [ idx ] = self . constants . VOWELS_TO_ACCENTS [ original_verse [ idx ] ]   for idx in dipthong_positions :              if original_verse [ idx + 1 ] in self . constants . ACCENTS_TO_VOWELS :                  original_verse [ idx + 1 ] = self . constants . ACCENTS_TO_VOWELS [ original_verse [ idx + 1 ] ]   return <str> . join ( original_verse )  def elide_all ( self , line : str ) -> str :          marks = list ( line . translate ( self . remove_punct_map ) ) all_vowels = self . constants . VOWELS + self . constants . ACCENTED_VOWELS tmp = <str> . join ( marks ) candidates = [ tmp , self . elide ( tmp , <str> . format ( self . constants . CONSONANTS , all_vowels , all_vowels ) , 1 , 1 ) , self . elide ( tmp , <str> . format ( self . constants . CONSONANTS , all_vowels ) , 1 , 1 ) , self . elide ( tmp , <str> . format ( all_vowels ) , 2 ) , self . elide ( tmp , <str> . format ( all_vowels ) , 2 ) , self . elide ( tmp , <str> . format ( all_vowels , all_vowels ) , 1 ) , self . elide ( tmp , <str> , 2 ) ] results = string_utils . merge_elisions ( candidates ) return results  def calc_offset ( self , syllables_spaces : List [ str ] ) -> Dict [ int , int ] :          line = string_utils . flatten ( syllables_spaces ) mydict = { } for idx , syl in enumerate ( syllables_spaces ) :              target_syllable = syllables_spaces [ idx ] skip_qu = string_utils . starts_with_qu ( target_syllable ) matches = list ( self . syllable_matcher . finditer ( target_syllable ) ) for position , possible in enumerate ( matches ) :                  if skip_qu :                      skip_qu = False continue  ( start , end ) = possible . span ( ) if target_syllable [ start : end ] in self . constants . VOWELS + self . constants . ACCENTED_VOWELS :                      part = line [ : len ( <str> . join ( syllables_spaces [ : idx ] ) ) ] offset = len ( part ) + start if line [ offset ] not in self . constants . VOWELS + self . constants . ACCENTED_VOWELS :                          LOG . error ( <str> . format ( line , offset ) )  mydict [ idx ] = offset    return mydict  def produce_scansion ( self , stresses : list , syllables_wspaces : List [ str ] , offset_map : Dict [ int , int ] ) -> str :          scansion = list ( <str> * len ( string_utils . flatten ( syllables_wspaces ) ) ) unstresses = string_utils . get_unstresses ( stresses , len ( syllables_wspaces ) ) try :              for idx in unstresses :                  location = offset_map . get ( idx ) if location is not None :                      scansion [ location ] = self . constants . UNSTRESSED   for idx in stresses :                  location = offset_map . get ( idx ) if location is not None :                      scansion [ location ] = self . constants . STRESSED    except Exception as e :              LOG . error ( <str> . format ( syllables_wspaces , e ) )  return <str> . join ( scansion )  def flag_dipthongs ( self , syllables : List [ str ] ) -> List [ int ] :          long_positions = [ ] for idx , syl in enumerate ( syllables ) :              for dipthong in self . constants . DIPTHONGS :                  if dipthong in syllables [ idx ] :                      if not string_utils . starts_with_qu ( syllables [ idx ] ) :                          long_positions . append ( idx )     return long_positions  def elide ( self , line : str , regexp : str , quantity : int = 1 , offset : int = 0 ) -> str :          matcher = re . compile ( regexp ) positions = matcher . finditer ( line ) new_line = line for match in positions :              ( start , end ) = match . span ( ) if ( start > 0 ) and new_line [ start - 1 : start + 1 ] in self . constants . DIPTHONGS :                  vowel_to_coerce = new_line [ end - 1 ] new_line = new_line [ : ( start - 1 ) + offset ] + ( <str> * ( quantity + 2 ) ) + self . constants . stress_accent_dict [ vowel_to_coerce ] + new_line [ end : ]  else :                  new_line = new_line [ : start + offset ] + ( <str> * quantity ) + new_line [ start + quantity + offset : ]   return new_line  def correct_invalid_start ( self , scansion : str ) -> str :          mark_list = string_utils . mark_list ( scansion ) raw_scansion = scansion . replace ( <str> , <str> ) if raw_scansion . startswith ( self . constants . SPONDEE + self . constants . UNSTRESSED ) :              new_scansion = list ( self . constants . SPONDEE + self . constants . SPONDEE + raw_scansion [ 4 : ] ) corrected = <str> . join ( new_scansion ) new_sequence = list ( <str> * len ( scansion ) ) for idx , car in enumerate ( corrected ) :                  new_sequence [ mark_list [ idx ] ] = car  return <str> . join ( new_sequence )  return scansion  def correct_first_two_dactyls ( self , scansion : str ) -> str :          mark_list = string_utils . mark_list ( scansion ) new_line = self . correct_invalid_start ( scansion ) raw_scansion = new_line . replace ( <str> , <str> ) if raw_scansion . startswith ( self . constants . SPONDEE + self . constants . TROCHEE + self . constants . STRESSED ) :              new_scansion = list ( self . constants . SPONDEE + self . constants . SPONDEE + self . constants . STRESSED + raw_scansion [ 5 : ] ) corrected = <str> . join ( new_scansion ) new_sequence = list ( <str> * len ( scansion ) ) for idx , car in enumerate ( corrected ) :                  new_sequence [ mark_list [ idx ] ] = car  return <str> . join ( new_sequence )  return new_line  def assign_candidate ( self , verse : Verse , candidate : str ) -> Verse :          verse . scansion = candidate verse . valid = True verse . accented = self . formatter . merge_line_scansion ( verse . original , verse . scansion ) return verse    