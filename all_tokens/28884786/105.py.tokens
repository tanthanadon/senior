from cltk . utils . cltk_logger import logger from cltk . prosody . latin import macronizer as m from nltk . tokenize import wordpunct_tokenize import re import unicodedata try :      from greek_accentuation import characters as chars  except ImportError as import_error :      message = <str> <str> logger . error ( message ) logger . error ( import_error ) raise  __author__ = [ <str> ] __license__ = <str> LATIN = { <str> : { <str> : { <str> : { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } , <str> : [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] , <str> : [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] , <str> : [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , ] } } } IPA = { <str> : [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> <str> , <str> , <str> , <str> ] , <str> : [ <str> , <str> , <str> , <str> ] , <str> : [ <str> , <str> ] , <str> : [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] , <str> : [ <str> , <str> , <str> , <str> , <str> , <str> ] , <str> : [ <str> , <str> , <str> , <str> ] , <str> : [ <str> , <str> , <str> , <str> , <str> ] , <str> : [ <str> , <str> , <str> , <str> , <str> , <str> , <str> ] , <str> : [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] , <str> : [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] , <str> : [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] , <str> : [ <str> , <str> , <str> , <str> ] , <str> : [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] , <str> : [ <str> , <str> , <str> , <str> ] , <str> : [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] , <str> : [ <str> ] } class Phone :      <str> def __init__ ( self , ipa_ch ) :          self . ipa = unicodedata . normalize ( <str> , ipa_ch ) self . left = <str> self . right = <str> self . vce = self . ipa in IPA [ <str> ] self . lab = self . ipa in IPA [ <str> ] self . lbd = self . ipa in IPA [ <str> ] self . cor = self . ipa in IPA [ <str> ] self . vel = self . ipa in IPA [ <str> ] self . nas = self . ipa in IPA [ <str> ] self . app = self . ipa in IPA [ <str> ] self . cont = self . ipa in IPA [ <str> ] self . vow = self . ipa in IPA [ <str> ] self . hi = self . ipa in IPA [ <str> ] self . mid = self . ipa in IPA [ <str> ] self . lo = self . ipa in IPA [ <str> ] self . fr = self . ipa in IPA [ <str> ] self . ctr = self . ipa in IPA [ <str> ] self . bk = self . ipa in IPA [ <str> ] self . bound = self . ipa in IPA [ <str> ]   class Word :      <str> def __init__ ( self , ipa_str , root ) :          self . string = unicodedata . normalize ( <str> , ipa_str ) self . root = root self . alts = self . root [ <str> ] self . phones = [ Phone ( c ) for c in re . findall ( <str> , self . string ) ]  def _refresh ( self ) :          for n in range ( len ( self . phones ) ) :              p = self . phones [ n ] if n != 0 :                  p . left = self . phones [ n - 1 ]  else :                  p . left = Phone ( <str> )  if n != len ( self . phones ) - 1 :                  p . right = self . phones [ n + 1 ]  else :                  p . right = Phone ( <str> )    def _j_maker ( self ) :          out_phones = self . phones target = Phone ( <str> ) for n in range ( len ( self . phones ) ) :              p = self . phones [ n ] if p . ipa == <str> and ( ( p . left . bound and p . right . vow ) or ( p . left . vow and p . right . vow ) ) :                  out_phones [ n ] = target   self . phones = out_phones self . _refresh ( )  def _w_maker ( self ) :          out_phones = self . phones target = Phone ( <str> ) for n in range ( len ( self . phones ) ) :              p = self . phones [ n ] if ( ( ( p . ipa == <str> ) or ( p . ipa == <str> ) ) and ( ( p . left . bound and ( p . right . vow or p . right . ipa == <str> ) ) or ( p . left . vow and p . right . vow ) ) ) :                  out_phones [ n ] = target   self . phones = out_phones self . _refresh ( )  def _wj_block ( self ) :          out_phones = self . phones target = Phone ( <str> ) for n in range ( len ( self . phones ) ) :              p = self . phones [ n ] if p . left . ipa == <str> and p . ipa == <str> :                  out_phones [ n ] = target   self . phones = out_phones self . _refresh ( )  def _uj_diph_maker ( self ) :          out_phones = self . phones for n in range ( len ( self . phones ) ) :              p = self . phones [ n ] if p . left . ipa == <str> and p . ipa == <str> :                  out_phones [ n - 1 ] = Phone ( <str> ) out_phones [ n ] = Phone ( <str> )   self . phones = out_phones self . _refresh ( )  def _b_devoice ( self ) :          out_phones = self . phones target = Phone ( <str> ) for n in range ( len ( self . phones ) ) :              p = self . phones [ n ] if p . ipa == <str> and ( p . right . ipa == <str> or p . right . ipa == <str> ) :                  out_phones [ n ] = target   self . phones = out_phones self . _refresh ( )  def _final_m_drop ( self ) :          out_phones = self . phones for n in range ( len ( self . phones ) ) :              p = self . phones [ n ] if p . left . vow and p . ipa == <str> and p . right . bound :                  out_phones [ n - 1 ] = Phone ( p . left . ipa + <str> ) del out_phones [ n ]   self . phones = out_phones self . _refresh ( )  def _n_place_assimilation ( self ) :          out_phones = self . phones target = Phone ( <str> ) for n in range ( len ( self . phones ) ) :              p = self . phones [ n ] if p . ipa == <str> and p . right . vel :                  out_phones [ n ] = target   self . phones = out_phones self . _refresh ( )  def _g_n_nasality_assimilation ( self ) :          out_phones = self . phones target = Phone ( <str> ) for n in range ( len ( self . phones ) ) :              p = self . phones [ n ] if p . ipa == <str> and p . right . ipa == <str> :                  out_phones [ n ] = target   self . phones = out_phones self . _refresh ( )  def _ns_nf_lengthening ( self ) :          out_phones = self . phones for n in range ( len ( self . phones ) ) :              p = self . phones [ n ] if ( p . left . vow and <str> not in p . left . ipa and p . ipa == <str> and ( p . right . ipa == <str> or p . right . ipa == <str> ) ) :                  out_phones [ n - 1 ] = Phone ( p . left . ipa + <str> )   self . phones = out_phones self . _refresh ( )  def _l_darken ( self ) :          out_phones = self . phones target = Phone ( <str> ) for n in range ( len ( self . phones ) ) :              p = self . phones [ n ] if p . ipa == <str> and ( ( not p . right . vow ) or p . right . bound ) :                  out_phones [ n ] = target   self . phones = out_phones self . _refresh ( )  def _j_z_doubling ( self ) :          out_phones = self . phones dupl = [ ] for n in range ( len ( self . phones ) ) :              p = self . phones [ n ] if p . right . vow and ( p . ipa == <str> or p . ipa == <str> ) and p . left . vow :                  dupl . append ( ( True , n - len ( self . phones ) , p . ipa ) )  else : dupl . append ( ( False , n - len ( self . phones ) , None ) )  for t in sorted ( dupl , key = lambda tup : tup [ 1 ] ) :              if t [ 0 ] :                  out_phones . insert ( t [ 1 ] , Phone ( t [ 2 ] ) )   self . phones = out_phones self . _refresh ( )  def _long_vowel_catcher ( self ) :          out_phones = self . phones target_dict = { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } for n in range ( len ( self . phones ) ) :              p = self . phones [ n ] if p . ipa in target_dict . keys ( ) :                  out_phones [ n ] = Phone ( target_dict [ p . ipa ] )   self . phones = out_phones self . _refresh ( )  def _e_i_closer_before_vowel ( self ) :          out_phones = self . phones for n in range ( len ( self . phones ) ) :              p = self . phones [ n ] if ( p . ipa == <str> or p . ipa == <str> ) and p . right . vow :                  out_phones [ n ] = Phone ( p . ipa + <str> )   self . phones = out_phones self . _refresh ( )  def _intervocalic_j ( self ) :          out_phones = self . phones target = Phone ( <str> ) j = [ ] for n in range ( len ( self . phones ) ) :              p = self . phones [ n ] if p . left . vow and p . vow :                  j . append ( ( True , n - len ( self . phones ) ) )  else : j . append ( ( False , n - len ( self . phones ) ) )  for t in sorted ( j , key = lambda tup : tup [ 1 ] ) :              if t [ 0 ] :                  out_phones . insert ( t [ 1 ] , target )   self . phones = out_phones self . _refresh ( )  ALTERNATIONS = [ ( <str> , _j_maker ) , ( <str> , _w_maker ) , ( <str> , _wj_block ) , ( <str> , _uj_diph_maker ) , ( <str> , _b_devoice ) , ( <str> , _final_m_drop ) , ( <str> , _n_place_assimilation ) , ( <str> , _g_n_nasality_assimilation ) , ( <str> , _ns_nf_lengthening ) , ( <str> , _l_darken ) , ( <str> , _j_z_doubling ) , ( <str> , _long_vowel_catcher ) , ( <str> , _e_i_closer_before_vowel ) , ( <str> , _intervocalic_j ) ] def _alternate ( self ) :          self . _refresh ( ) for a in Word . ALTERNATIONS :              if a [ 0 ] in self . alts :                  a [ 1 ] ( self )    def _syllabify ( self ) :          nuclei = [ ] for n in range ( len ( self . phones ) ) :              p = self . phones [ n ] if p . vow :                  nuclei . append ( n )   syllables = [ [ self . phones [ 0 : nuclei [ 0 ] ] , [ self . phones [ nuclei [ 0 ] ] ] , [ ] ] ] for x in range ( len ( nuclei ) - 1 ) :              i = nuclei [ x + 1 ] onset = self . phones [ nuclei [ x ] + 1 : i ] nucleus = [ self . phones [ i ] ] syllables . append ( [ onset , nucleus , [ ] ] )  syllables [ - 1 ] [ 2 ] = self . phones [ nuclei [ - 1 ] + 1 : ] for x in range ( len ( syllables ) - 1 ) :              onset = syllables [ x + 1 ] [ 0 ] nucleus = syllables [ x + 1 ] [ 1 ] coda = syllables [ x + 1 ] [ 2 ] if len ( onset ) > 2 :                  trim = onset [ : - 2 ] del onset [ : - 2 ] syllables [ x ] [ 2 ] = trim  if len ( onset ) == 2 :                  if ( ( not onset [ 0 ] . cont ) and ( not onset [ 0 ] . app ) and ( onset [ 1 ] . nas or onset [ 1 ] . app ) ) :                      break  else :                      trim = onset [ 0 ] del onset [ 0 ] syllables [ x ] [ 2 ] += [ trim ]    self . syllables = syllables return ( syllables )  def _print_ipa ( self , syllabify , accentuate ) :          out = <str> if syllabify :              syllables = self . _syllabify ( ) ultima = syllables [ - 1 ] if accentuate :                  if len ( syllables ) == 1 :                      accent = - 1  elif len ( syllables ) == 2 :                      accent = - 2  else :                      penult = syllables [ - 2 ] if len ( penult [ 1 ] ) > 1 :                          accent = - 2  elif <str> in penult [ 1 ] [ 0 ] . ipa :                          accent = - 2  elif len ( penult [ 2 ] ) > 0 :                          accent = - 2  else :                          accent = - 3   for x in range ( len ( syllables ) ) :                      s = syllables [ x ] if x - len ( syllables ) == accent :                          out += <str>  for n in s :                          for p in n :                              out += p . ipa   if s != ultima :                          out += <str>    else :                  for s in syllables :                      for n in s :                          for p in n :                              out += p . ipa   if s != ultima :                          out += <str>     else :              for p in self . phones :                  out += p . ipa   return out   class Transcriber :      <str> def __init__ ( self , dialect , reconstruction ) :          self . lect = dialect self . recon = reconstruction self . root = LATIN [ self . lect ] [ self . recon ] self . table = self . root [ <str> ] self . diphs = self . root [ <str> ] self . punc = self . root [ <str> ] self . macronizer = m . Macronizer ( <str> )  def _parse_diacritics ( self , ch ) :          out = chars . base ( ch ) . lower ( ) length = chars . length ( ch ) dia = chars . diaeresis ( ch ) out += <str> if length != None :              out += length  out += <str> if dia != None :              out += dia  out += <str> return out  def _prep_text ( self , text ) :          string_in = <str> . join ( [ self . _parse_diacritics ( ch ) for ch in text ] ) for d in self . diphs :              d1 = d [ 0 ] d2 = d [ 1 ] pattern = <str> + d1 + <str> + d2 + <str> string_in = re . sub ( pattern , <str> , string_in )  tup_out = re . findall ( <str> , string_in ) return tup_out  def transcribe ( self , text , macronize = True , syllabify = True , accentuate = True ) :          if macronize :              text = self . macronizer . macronize_text ( text )  inp = [ self . _prep_text ( w ) for w in wordpunct_tokenize ( text ) if w not in self . punc ] words = [ ] for w in inp :              out = <str> for c in w :                  if <str> in c [ 1 ] :                      macron_added = c [ 0 ] + <str> ipa = self . table . get ( macron_added , macron_added )  else :                      ipa = self . table . get ( c [ 0 ] , c [ 0 ] )  out += ipa  transcription = Word ( out , self . root ) transcription . _alternate ( ) words . append ( transcription )  return <str> + <str> . join ( [ w . _print_ipa ( syllabify , accentuate ) for w in words ] ) + <str>   if __name__ == <str> :      allen_transcriber = Transcriber ( <str> , <str> ) example = allen_transcriber . transcribe ( <str> + <str> ) print ( example )   