import odl import numpy as np space = odl . uniform_discr ( min_pt = [ - 20 , - 20 ] , max_pt = [ 20 , 20 ] , shape = [ 256 , 256 ] , dtype = <str> ) angle_partition = odl . uniform_partition ( 0 , np . pi , 300 ) detector_partition = odl . uniform_partition ( - 30 , 30 , 300 ) geometry = odl . tomo . Parallel2dGeometry ( angle_partition , detector_partition ) ray_trafo = odl . tomo . RayTransform ( space , geometry ) discr_phantom = odl . phantom . shepp_logan ( space , modified = True ) data = ray_trafo ( discr_phantom ) data += odl . phantom . white_noise ( ray_trafo . range ) * np . mean ( data ) * 0.1 W = odl . trafos . WaveletTransform ( space , wavelet = <str> , nlevels = 5 ) scales = W . scales ( ) Wtrafoinv = W . inverse * ( 1 / ( np . power ( 1.7 , scales ) ) ) regularizer = 0.0005 * odl . solvers . L1Norm ( W . range ) l2_norm_sq = odl . solvers . L2NormSquared ( ray_trafo . range ) . translated ( data ) data_discrepancy = l2_norm_sq * ray_trafo * Wtrafoinv gamma = 0.2 callback = ( odl . solvers . CallbackPrintIteration ( ) & odl . solvers . CallbackShow ( step = 5 ) ) def callb ( x ) :      callback ( Wtrafoinv ( x ) )  x = data_discrepancy . domain . zero ( ) odl . solvers . accelerated_proximal_gradient ( x , f = regularizer , g = data_discrepancy , niter = 400 , gamma = gamma , callback = callb ) data . show ( title = <str> ) x . show ( title = <str> ) Wtrafoinv ( x ) . show ( <str> , force_show = True )  