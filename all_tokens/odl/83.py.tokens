from __future__ import division , print_function import os import odl import odl . contrib . solvers . spdhg as spdhg import odl . contrib . datasets . images as images import odl . contrib . fom as fom import brewer2mpl import matplotlib . pyplot as plt import matplotlib import numpy as np folder_out = <str> filename = <str> nepoch = 300 niter_target = 2000 subfolder = <str> . format ( nepoch ) simage = [ 408 , 544 ] image_raw = images . rings ( shape = simage , gray = True ) filename = <str> . format ( filename , simage [ 0 ] , simage [ 1 ] ) folder_main = <str> . format ( folder_out , filename ) if not os . path . exists ( folder_main ) :      os . makedirs ( folder_main )  folder_today = <str> . format ( folder_main , subfolder ) if not os . path . exists ( folder_today ) :      os . makedirs ( folder_today )  folder_npy = <str> . format ( folder_today ) if not os . path . exists ( folder_npy ) :      os . makedirs ( folder_npy )  X = odl . uniform_discr ( [ 0 , 0 ] , simage , simage ) groundtruth = 100 * X . element ( image_raw ) clim = [ 0 , 100 ] tol_norm = 1.05 Dx = odl . PartialDerivative ( X , 0 , pad_mode = <str> ) Dy = odl . PartialDerivative ( X , 1 , pad_mode = <str> ) kernel = images . blurring_kernel ( shape = [ 15 , 15 ] ) convolution = spdhg . Blur2D ( X , kernel ) K = odl . uniform_discr ( [ 0 , 0 ] , kernel . shape , kernel . shape ) kernel = K . element ( kernel ) scale = 1e+3 A = odl . BroadcastOperator ( Dx , Dy , scale / clim [ 1 ] * convolution ) Y = A . range background = 200 * Y [ 2 ] . one ( ) data = odl . phantom . poisson_noise ( A [ 2 ] ( groundtruth ) + background , seed = 1807 ) if not os . path . exists ( <str> . format ( folder_main ) ) :      spdhg . save_image ( groundtruth , <str> , folder_main , 1 , clim = clim ) spdhg . save_image ( data - background , <str> , folder_main , 2 , clim = [ 0 , scale ] ) spdhg . save_image ( kernel , <str> , folder_main , 3 )  alpha = 0.1 gamma = 0.99 f = odl . solvers . SeparableSum ( odl . solvers . Huber ( A [ 0 ] . range , gamma = 1 ) , odl . solvers . Huber ( A [ 1 ] . range , gamma = 1 ) , 1 / alpha * spdhg . KullbackLeiblerSmooth ( A [ 2 ] . range , data , background ) ) g = odl . solvers . IndicatorBox ( X , clim [ 0 ] , clim [ 1 ] ) obj_fun = f * A + g mu_i = [ 1 / fi . grad_lipschitz for fi in f ] mu_f = min ( mu_i ) file_target = <str> . format ( folder_main ) if not os . path . exists ( file_target ) :      normA = tol_norm * A . norm ( estimate = True , xstart = odl . phantom . white_noise ( X ) ) sigma , tau = [ gamma / normA ] * 2 x_opt , y_opt = X . zero ( ) , Y . zero ( ) callback = ( odl . solvers . CallbackPrintIteration ( step = 10 , end = <str> ) & odl . solvers . CallbackPrintTiming ( step = 10 , cumulative = True ) ) odl . solvers . pdhg ( x_opt , f , g , A , tau , sigma , niter_target , y = y_opt , callback = callback ) subx_opt = - A . adjoint ( y_opt ) suby_opt = A ( x_opt ) obj_opt = obj_fun ( x_opt ) np . save ( file_target , ( x_opt , y_opt , subx_opt , suby_opt , obj_opt , normA ) ) spdhg . save_image ( x_opt , <str> , folder_main , 1 , clim = clim ) spdhg . save_image ( y_opt [ 0 ] , <str> , folder_main , 2 ) spdhg . save_image ( y_opt [ 1 ] , <str> , folder_main , 3 ) spdhg . save_image ( y_opt [ 2 ] , <str> , folder_main , 4 ) spdhg . save_image ( subx_opt , <str> , folder_main , 5 ) spdhg . save_image ( suby_opt [ 0 ] , <str> , folder_main , 6 ) spdhg . save_image ( suby_opt [ 1 ] , <str> , folder_main , 7 ) spdhg . save_image ( suby_opt [ 2 ] , <str> , folder_main , 8 )  else :      ( x_opt , y_opt , subx_opt , suby_opt , obj_opt , normA ) = np . load ( file_target )  dist_x = odl . solvers . L2NormSquared ( X ) . translated ( x_opt ) dist_y = odl . solvers . L2NormSquared ( Y ) . translated ( y_opt ) class CallbackStore ( odl . solvers . Callback ) :      def __init__ ( self , alg , iter_save , iter_plot ) :          self . iter_save = iter_save self . iter_plot = iter_plot self . iter = 0 self . alg = alg self . out = [ ]  def __call__ ( self , w ) :          if self . iter in self . iter_save :              obj = obj_fun ( w [ 0 ] ) psnr = fom . psnr ( w [ 0 ] , groundtruth ) psnr_opt = fom . psnr ( w [ 0 ] , x_opt ) dx = dist_x ( w [ 0 ] ) dy = dist_y ( w [ 1 ] ) dist = dx + dy self . out . append ( { <str> : obj , <str> : dist , <str> : dx , <str> : dy , <str> : psnr , <str> : psnr_opt , <str> : self . iter } )  if self . iter in self . iter_plot :              fname = <str> . format ( self . alg , self . iter ) spdhg . save_image ( w [ 0 ] , fname , folder_today , 1 , clim = clim )  self . iter += 1   nsub = { <str> : 1 , <str> : 1 , <str> : 3 } niter , iter_save , iter_plot = { } , { } , { } for a in nsub . keys ( ) :      niter [ a ] = nepoch * nsub [ a ] iter_save [ a ] = range ( 0 , niter [ a ] + 1 , nsub [ a ] ) iter_plot [ a ] = list ( np . array ( [ 10 , 30 , 50 , 70 , 100 , 300 ] ) * nsub [ a ] )  for alg in [ <str> , <str> , <str> ] :      print ( <str> + alg + <str> ) prob_subset , prob , sigma , sigma_tilde , tau , theta = [ None ] * 6 np . random . seed ( 1807 ) n = nsub [ alg ] ( sub2ind , ind2sub ) = spdhg . divide_1Darray_equally ( range ( len ( Y ) ) , n ) if alg in [ <str> , <str> ] :          file_normA = <str> . format ( folder_main , 1 ) if not os . path . exists ( file_normA ) :              xstart = odl . phantom . white_noise ( X ) norm_estimate = A . norm ( estimate = True , xstart = xstart ) normA = [ tol_norm * norm_estimate ] np . save ( file_normA , normA )  else :              normA = np . load ( file_normA )   elif alg in [ <str> ] :          file_normA = <str> . format ( folder_main , n ) if not os . path . exists ( file_normA ) :              xstart = odl . phantom . white_noise ( X ) norm_estimate = A [ 2 ] . norm ( estimate = True , xstart = xstart ) normA = [ 2 , 2 , tol_norm * norm_estimate ] np . save ( file_normA , normA )  else :              normA = np . load ( file_normA )   if alg == <str> :          prob_subset = [ 1 ] * n prob = [ 1 ] * len ( Y ) sigma = [ gamma / normA [ 0 ] ] * len ( Y ) tau = gamma / normA [ 0 ]  elif alg == <str> :          prob_subset = [ 1 ] * n prob = [ 1 ] * len ( Y ) tau = gamma / normA [ 0 ] mu = [ mu_f ] * len ( Y ) sigma_tilde = mu_f / normA [ 0 ]  elif alg in [ <str> ] :          prob = [ 1 / n ] * n prob_subset = prob tau = gamma / ( n * max ( normA ) ) mu = mu_i sigma_tilde = min ( [ m * p ** 2 / ( tau * normAi ** 2 + 2 * m * p * ( 1 - p ) ) for p , m , normAi in zip ( prob , mu_i , normA ) ] )  else :          assert False , <str>  def fun_select ( k ) :          return sub2ind [ int ( np . random . choice ( n , 1 , p = prob_subset ) ) ]  callback = ( odl . solvers . CallbackPrintIteration ( fmt = <str> , step = n , end = <str> ) & odl . solvers . CallbackPrintTiming ( fmt = <str> , cumulative = True , step = n ) & CallbackStore ( alg , iter_save [ alg ] , iter_plot [ alg ] ) ) x , y = X . zero ( ) , Y . zero ( ) callback ( [ x , y ] ) if alg . startswith ( <str> ) :          spdhg . spdhg ( x , f , g , A , tau , sigma , niter [ alg ] , y = y , prob = prob , fun_select = fun_select , callback = callback )  elif alg . startswith ( <str> ) or alg . startswith ( <str> ) :          spdhg . da_spdhg ( x , f , g , A , tau , sigma_tilde , niter [ alg ] , mu , prob = prob , fun_select = fun_select , y = y , callback = callback )  else :          assert False , <str>  out = callback . callbacks [ 1 ] . out np . save ( <str> . format ( folder_npy , alg ) , ( iter_save [ alg ] , niter [ alg ] , x , out , nsub [ alg ] ) )  algs = [ <str> , <str> , <str> ] ( iter_save_v , niter_v , image_v , out_v , nsub_v ) = { } , { } , { } , { } , { } for a in algs :      ( iter_save_v [ a ] , niter_v [ a ] , image_v [ a ] , out_v [ a ] , nsub_v [ a ] ) = np . load ( <str> . format ( folder_npy , a ) )  epochs_save = { a : np . array ( iter_save_v [ a ] ) / np . float ( nsub_v [ a ] ) for a in algs } out_resorted = { } for a in algs :      print ( <str> + a ) out_resorted [ a ] = { } K = len ( iter_save_v [ a ] ) for meas in out_v [ a ] [ 0 ] . keys ( ) :          print ( <str> + meas ) out_resorted [ a ] [ meas ] = np . nan * np . ones ( K ) for k in range ( K ) :              out_resorted [ a ] [ meas ] [ k ] = out_v [ a ] [ k ] [ meas ]    for a in algs :      meas = <str> print ( <str> + meas ) out_resorted [ a ] [ meas ] = np . nan * np . ones ( K ) for k in range ( K ) :          out_resorted [ a ] [ meas ] [ k ] = ( ( out_v [ a ] [ k ] [ <str> ] - obj_opt ) / ( out_v [ a ] [ 0 ] [ <str> ] - obj_opt ) )   for a in algs :      for meas in out_resorted [ a ] . keys ( ) :          for k in range ( K ) :              if out_resorted [ a ] [ meas ] [ k ] <= 0 :                  out_resorted [ a ] [ meas ] [ k ] = np . nan     fig = plt . figure ( ) markers = plt . Line2D . filled_markers all_plots = out_resorted [ algs [ 0 ] ] . keys ( ) logy_plot = [ <str> , <str> , <str> , <str> ] fig = plt . figure ( ) for plotx in [ <str> , <str> ] :      for meas in all_plots :          print ( <str> . format ( plotx , meas ) ) plt . clf ( ) if plotx == <str> :              if meas in logy_plot :                  for a in algs :                      x = epochs_save [ a ] y = out_resorted [ a ] [ meas ] plt . semilogy ( x , y , linewidth = 3 , label = a )   else :                  for j , a in enumerate ( algs ) :                      x = epochs_save [ a ] y = out_resorted [ a ] [ meas ] plt . plot ( x , y , linewidth = 3 , marker = markers [ j ] , markersize = 7 , markevery = .1 , label = a )    elif plotx == <str> :              if meas in logy_plot :                  for a in algs :                      x = epochs_save [ a ] [ 1 : ] y = out_resorted [ a ] [ meas ] [ 1 : ] plt . loglog ( x , y , linewidth = 3 , label = a )   else :                  for j , a in enumerate ( algs ) :                      x = epochs_save [ a ] [ 1 : ] y = out_resorted [ a ] [ meas ] [ 1 : ] plt . semilogx ( x , y , linewidth = 3 , marker = markers [ j ] , markersize = 7 , markevery = .1 , label = a )    plt . title ( <str> . format ( meas ) ) h = plt . gca ( ) h . set_xlabel ( <str> ) plt . legend ( loc = <str> ) fig . savefig ( <str> . format ( folder_today , plotx , meas ) , bbox_inches = <str> )   lwidth = 2 lwidth_help = 2 lstyle = <str> lstyle_help = <str> bmap = brewer2mpl . get_map ( <str> , <str> , 6 ) colors = bmap . mpl_colors colors . pop ( 1 ) matplotlib . rc ( <str> , usetex = True ) matplotlib . rcParams [ <str> ] = [ <str> ] fsize = 15 font = { <str> : <str> , <str> : fsize } matplotlib . rc ( <str> , ** font ) matplotlib . rc ( <str> , labelsize = fsize ) matplotlib . rc ( <str> , labelsize = fsize ) matplotlib . rc ( <str> , labelsize = fsize ) matplotlib . rc ( <str> , fontsize = fsize ) marker = ( <str> , <str> , <str> , <str> , <str> ) mevery = [ ( i / 30. , .15 ) for i in range ( 10 ) ] msize = 9 algs = [ <str> , <str> , <str> ] label = [ <str> , <str> , <str> ] fig = [ ] fig . append ( plt . figure ( 0 ) ) plt . clf ( ) xlim = [ 5 , 300 ] ylim = [ 1e-4 , 5e+2 ] meas = <str> for k , a in enumerate ( algs ) :      x = epochs_save [ a ] y = out_resorted [ a ] [ meas ] / out_resorted [ a ] [ meas ] [ 0 ] i = ( np . less_equal ( x , xlim [ 1 ] ) & np . greater_equal ( x , xlim [ 0 ] ) & np . less_equal ( y , ylim [ 1 ] ) & np . greater_equal ( y , ylim [ 0 ] ) ) plt . loglog ( x [ i ] , y [ i ] , color = colors [ k ] , linestyle = lstyle , linewidth = lwidth , marker = marker [ k ] , markersize = msize , markevery = mevery [ k ] , label = label [ k ] )  y = 3e+3 / x ** 2 plt . loglog ( x [ i ] , y [ i ] , color = <str> , linestyle = lstyle_help , linewidth = lwidth_help , label = <str> ) plt . gca ( ) . set_xlabel ( <str> ) plt . gca ( ) . set_ylabel ( <str> ) plt . gca ( ) . yaxis . set_ticks ( np . logspace ( - 3 , 1 , 3 ) ) plt . legend ( frameon = False ) fig . append ( plt . figure ( 1 ) ) plt . clf ( ) ylim = [ 5e-5 , 1e-0 ] meas = <str> for k , a in enumerate ( algs ) :      x = epochs_save [ a ] y = out_resorted [ a ] [ meas ] / out_resorted [ a ] [ meas ] [ 0 ] i = ( np . less_equal ( x , xlim [ 1 ] ) & np . greater_equal ( x , xlim [ 0 ] ) & np . less_equal ( y , ylim [ 1 ] ) & np . greater_equal ( y , ylim [ 0 ] ) ) plt . semilogy ( x [ i ] , y [ i ] , color = colors [ k ] , linestyle = lstyle , linewidth = lwidth , label = label [ k ] , marker = marker [ k ] , markersize = msize , markevery = mevery [ k ] )  plt . gca ( ) . set_xlabel ( <str> ) plt . gca ( ) . set_ylabel ( <str> ) plt . gca ( ) . yaxis . set_ticks ( np . logspace ( - 5 , - 1 , 3 ) ) plt . legend ( frameon = False ) for i , fi in enumerate ( fig ) :      fi . savefig ( <str> . format ( folder_today , i ) , bbox_inches = <str> )   