from __future__ import print_function , division , absolute_import import numpy as np from odl . operator import Operator __all__ = ( <str> , <str> ) def pdhg ( x , f , g , L , niter , tau = None , sigma = None , ** kwargs ) :      <str> if not isinstance ( L , Operator ) :          raise TypeError ( <str> <str> . format ( L ) )  if x not in L . domain :          raise TypeError ( <str> <str> . format ( x , L . domain ) )  if f . domain != L . domain :          raise TypeError ( <str> <str> . format ( f . domain , L . domain ) )  tau , sigma = pdhg_stepsize ( L , tau , sigma ) if not isinstance ( niter , int ) or niter < 0 :          raise ValueError ( <str> <str> . format ( niter ) )  theta = kwargs . pop ( <str> , 1 ) theta , theta_in = float ( theta ) , theta if not 0 <= theta <= 1 :          raise ValueError ( <str> <str> . format ( theta_in ) )  gamma_primal = kwargs . pop ( <str> , None ) if gamma_primal is not None :          gamma_primal , gamma_primal_in = float ( gamma_primal ) , gamma_primal if gamma_primal < 0 :              raise ValueError ( <str> <str> . format ( gamma_primal_in ) )   gamma_dual = kwargs . pop ( <str> , None ) if gamma_dual is not None :          gamma_dual , gamma_dual_in = float ( gamma_dual ) , gamma_dual if gamma_dual < 0 :              raise ValueError ( <str> <str> . format ( gamma_dual_in ) )   if gamma_primal is not None and gamma_dual is not None :          raise ValueError ( <str> )  callback = kwargs . pop ( <str> , None ) if callback is not None and not callable ( callback ) :          raise TypeError ( <str> <str> . format ( callback ) )  x_relax = kwargs . pop ( <str> , None ) if x_relax is None :          x_relax = x . copy ( )  elif x_relax not in L . domain :          raise TypeError ( <str> <str> . format ( x_relax . space , L . domain ) )  y = kwargs . pop ( <str> , None ) if y is None :          y = L . range . zero ( )  elif y not in L . range :          raise TypeError ( <str> <str> . format ( y . space , L . range ) )  proximal_primal = f . proximal proximal_dual = g . convex_conj . proximal proximal_constant = ( gamma_primal is None ) and ( gamma_dual is None ) if proximal_constant :          proximal_dual_sigma = proximal_dual ( sigma ) proximal_primal_tau = proximal_primal ( tau )  x_old = x . space . element ( ) dual_tmp = L . range . element ( ) primal_tmp = L . domain . element ( ) for _ in range ( niter ) :          x_old . assign ( x ) L ( x_relax , out = dual_tmp ) dual_tmp . lincomb ( 1 , y , sigma , dual_tmp ) if not proximal_constant :              proximal_dual_sigma = proximal_dual ( sigma )  proximal_dual_sigma ( dual_tmp , out = y ) L . derivative ( x ) . adjoint ( y , out = primal_tmp ) primal_tmp . lincomb ( 1 , x , - tau , primal_tmp ) if not proximal_constant :              proximal_primal_tau = proximal_primal ( tau )  proximal_primal_tau ( primal_tmp , out = x ) if gamma_primal is not None :              theta = float ( 1 / np . sqrt ( 1 + 2 * gamma_primal * tau ) ) tau *= theta sigma /= theta  if gamma_dual is not None :              theta = float ( 1 / np . sqrt ( 1 + 2 * gamma_dual * sigma ) ) tau /= theta sigma *= theta  x_relax . lincomb ( 1 + theta , x , - theta , x_old ) if callback is not None :              callback ( x )    def pdhg_stepsize ( L , tau = None , sigma = None ) :      <str> if tau is not None and sigma is not None :          return float ( tau ) , float ( sigma )  L_norm = L . norm ( estimate = True ) if isinstance ( L , Operator ) else float ( L ) if tau is None and sigma is None :          tau = sigma = np . sqrt ( 0.9 ) / L_norm return tau , sigma  elif tau is None :          tau = 0.9 / ( sigma * L_norm ** 2 ) return tau , float ( sigma )  else :          sigma = 0.9 / ( tau * L_norm ** 2 ) return float ( tau ) , sigma   if __name__ == <str> :      from odl . util . testutils import run_doctests run_doctests ( )   