from __future__ import division import numpy as np import odl import pytest from odl . discr . lp_discr import DiscreteLp , DiscreteLpElement from odl . space . base_tensors import TensorSpace from odl . space . npy_tensors import NumpyTensor from odl . space . weighting import ConstWeighting from odl . util . testutils import ( all_almost_equal , all_equal , noise_elements , simple_fixture ) exponent = simple_fixture ( <str> , [ 2.0 , 1.0 , float ( <str> ) , 0.5 , 1.5 ] ) power = simple_fixture ( <str> , [ 1.0 , 2.0 , 0.5 , - 0.5 , - 1.0 , - 2.0 ] ) shape = simple_fixture ( <str> , [ ( 2 , 3 , 4 ) , ( 3 , 4 ) , ( 2 , ) , ( 1 , ) , ( 1 , 1 , 1 ) ] ) power = simple_fixture ( <str> , [ 1.0 , 2.0 , 0.5 , - 0.5 , - 1.0 , - 2.0 ] ) def test_discretelp_init ( ) :      fspace = odl . FunctionSpace ( odl . IntervalProd ( [ 0 , 0 ] , [ 1 , 1 ] ) ) part = odl . uniform_partition_fromintv ( fspace . domain , ( 2 , 4 ) ) tspace = odl . rn ( part . shape ) discr = DiscreteLp ( fspace , part , tspace ) assert discr . fspace == fspace assert discr . tspace == tspace assert discr . partition == part assert discr . interp == <str> assert discr . interp_byaxis == ( <str> , <str> ) assert discr . exponent == tspace . exponent assert discr . axis_labels == ( <str> , <str> ) assert discr . is_real discr = DiscreteLp ( fspace , part , tspace , interp = <str> ) assert discr . interp == <str> assert discr . interp_byaxis == ( <str> , <str> ) discr = DiscreteLp ( fspace , part , tspace , interp = [ <str> , <str> ] ) assert discr . interp == ( <str> , <str> ) assert discr . interp_byaxis == ( <str> , <str> ) fspace_c = odl . FunctionSpace ( odl . IntervalProd ( [ 0 , 0 ] , [ 1 , 1 ] ) , out_dtype = complex ) tspace_c = odl . cn ( part . shape ) discr = DiscreteLp ( fspace_c , part , tspace_c ) assert discr . is_complex assert repr ( discr ) with pytest . raises ( ValueError ) :          DiscreteLp ( fspace , part , tspace_c )  with pytest . raises ( ValueError ) :          DiscreteLp ( fspace_c , part , tspace )  part_1d = odl . uniform_partition ( 0 , 1 , 2 ) with pytest . raises ( ValueError ) :          DiscreteLp ( fspace , part_1d , tspace )  part_diffshp = odl . uniform_partition_fromintv ( fspace . domain , ( 3 , 4 ) ) with pytest . raises ( ValueError ) :          DiscreteLp ( fspace , part_diffshp , tspace )   def test_empty ( ) :      discr = odl . uniform_discr ( [ ] , [ ] , ( ) ) assert discr . interp == <str> assert discr . axis_labels == ( ) assert discr . tangent_bundle == odl . ProductSpace ( field = odl . RealNumbers ( ) ) assert discr . complex_space == odl . uniform_discr ( [ ] , [ ] , ( ) , dtype = complex ) hash ( discr ) assert repr ( discr ) != <str> elem = discr . element ( 1.0 ) assert np . array_equal ( elem . asarray ( ) , 1.0 ) assert np . array_equal ( elem . real , 1.0 ) assert np . array_equal ( elem . imag , 0.0 ) assert np . array_equal ( elem . conj ( ) , 1.0 )  def test_factory_dtypes ( odl_tspace_impl ) :      impl = odl_tspace_impl real_float_dtypes = [ np . float32 , np . float64 ] nonfloat_dtypes = [ np . int8 , np . int16 , np . int32 , np . int64 , np . uint8 , np . uint16 , np . uint32 , np . uint64 ] complex_float_dtypes = [ np . complex64 , np . complex128 ] for dtype in real_float_dtypes :          try :              discr = odl . uniform_discr ( 0 , 1 , 10 , impl = impl , dtype = dtype )  except TypeError :              continue  else :              assert isinstance ( discr . tspace , TensorSpace ) assert discr . tspace . impl == impl assert discr . is_real   for dtype in nonfloat_dtypes :          try :              discr = odl . uniform_discr ( 0 , 1 , 10 , impl = impl , dtype = dtype )  except TypeError :              continue  else :              assert isinstance ( discr . tspace , TensorSpace ) assert discr . tspace . impl == impl assert discr . tspace . element ( ) . space . dtype == dtype   for dtype in complex_float_dtypes :          try :              discr = odl . uniform_discr ( 0 , 1 , 10 , impl = impl , dtype = dtype )  except TypeError :              continue  else :              assert isinstance ( discr . tspace , TensorSpace ) assert discr . tspace . impl == impl assert discr . is_complex assert discr . tspace . element ( ) . space . dtype == dtype    def test_uniform_discr_init_real ( odl_tspace_impl ) :      impl = odl_tspace_impl discr = odl . uniform_discr ( 0 , 1 , 10 , impl = impl ) assert isinstance ( discr , DiscreteLp ) assert isinstance ( discr . tspace , TensorSpace ) assert discr . impl == impl assert discr . is_real assert discr . tspace . exponent == 2.0 assert discr . dtype == discr . tspace . default_dtype ( odl . RealNumbers ( ) ) assert discr . is_real assert not discr . is_complex assert all_equal ( discr . min_pt , [ 0 ] ) assert all_equal ( discr . max_pt , [ 1 ] ) assert discr . shape == ( 10 , ) assert repr ( discr ) discr = odl . uniform_discr ( 0 , 1 , 10 , impl = impl , exponent = 1.0 ) assert discr . exponent == 1.0 discr = odl . uniform_discr ( 0 , 1 , 10 , impl = impl , interp = <str> ) assert discr . interp == <str> discr = odl . uniform_discr ( [ 0 , 0 ] , [ 1 , 1 ] , ( 5 , 5 ) ) assert all_equal ( discr . min_pt , np . array ( [ 0 , 0 ] ) ) assert all_equal ( discr . max_pt , np . array ( [ 1 , 1 ] ) ) assert discr . shape == ( 5 , 5 ) discr = odl . uniform_discr ( [ 0 ] * 10 , [ 1 ] * 10 , ( 5 , ) * 10 ) assert all_equal ( discr . min_pt , np . zeros ( 10 ) ) assert all_equal ( discr . max_pt , np . ones ( 10 ) ) assert discr . shape == ( 5 , ) * 10  def test_uniform_discr_init_complex ( odl_tspace_impl ) :      impl = odl_tspace_impl if impl != <str> :          pytest . xfail ( reason = <str> )  discr = odl . uniform_discr ( 0 , 1 , 10 , dtype = <str> , impl = impl ) assert discr . is_complex assert discr . dtype == discr . tspace . default_dtype ( odl . ComplexNumbers ( ) )  def test_discretelp_element ( ) :      discr = odl . uniform_discr ( 0 , 1 , 3 ) weight = 1.0 if exponent == float ( <str> ) else discr . cell_volume tspace = odl . rn ( 3 , weighting = weight ) elem = discr . element ( ) assert elem in discr assert elem . tensor in tspace discr = odl . uniform_discr ( [ 0 , 0 ] , [ 1 , 1 ] , ( 3 , 3 ) ) weight = 1.0 if exponent == float ( <str> ) else discr . cell_volume tspace = odl . rn ( ( 3 , 3 ) , weighting = weight ) elem = discr . element ( ) assert elem in discr assert elem . tensor in tspace  def test_discretelp_element_from_array ( ) :      discr = odl . uniform_discr ( 0 , 1 , 3 ) elem = discr . element ( [ 1 , 2 , 3 ] ) assert np . array_equal ( elem . tensor , [ 1 , 2 , 3 ] ) assert isinstance ( elem , DiscreteLpElement ) assert isinstance ( elem . tensor , NumpyTensor ) assert all_equal ( elem . tensor , [ 1 , 2 , 3 ] )  def test_element_from_array_2d ( odl_elem_order ) :      order = odl_elem_order discr = odl . uniform_discr ( [ 0 , 0 ] , [ 1 , 1 ] , [ 2 , 2 ] ) elem = discr . element ( [ [ 1 , 2 ] , [ 3 , 4 ] ] , order = order ) assert isinstance ( elem , DiscreteLpElement ) assert isinstance ( elem . tensor , NumpyTensor ) assert all_equal ( elem , [ [ 1 , 2 ] , [ 3 , 4 ] ] ) if order is None :          assert elem . tensor . data . flags [ discr . default_order + <str> ]  else :          assert elem . tensor . data . flags [ order + <str> ]  with pytest . raises ( ValueError ) :          discr . element ( [ 1 , 2 , 3 ] )  with pytest . raises ( ValueError ) :          discr . element ( [ 1 , 2 , 3 , 4 ] )  with pytest . raises ( ValueError ) :          discr . element ( [ [ 1 ] , [ 2 ] , [ 3 ] , [ 4 ] ] )   def test_element_from_function_1d ( ) :      space = odl . uniform_discr ( - 1 , 1 , 4 ) points = space . points ( ) . squeeze ( ) def f ( x ) :          return x * 2 + np . maximum ( x , 0 )  elem_f = space . element ( f ) true_elem = [ x * 2 + max ( x , 0 ) for x in points ] assert all_equal ( elem_f , true_elem ) def f ( x ) :          return x [ 0 ] * 2 + np . maximum ( x [ 0 ] , 0 )  elem_f = space . element ( f ) true_elem = [ x * 2 + max ( x , 0 ) for x in points ] assert all_equal ( elem_f , true_elem ) def f ( x , ** kwargs ) :          c = kwargs . pop ( <str> , 0 ) return x * c + np . maximum ( x , 0 )  elem_f_default = space . element ( f ) true_elem = [ x * 0 + max ( x , 0 ) for x in points ] assert all_equal ( elem_f_default , true_elem ) elem_f_2 = space . element ( f , c = 2 ) true_elem = [ x * 2 + max ( x , 0 ) for x in points ] assert all_equal ( elem_f_2 , true_elem ) elem_lam = space . element ( lambda x : - x ** 2 ) true_elem = [ - x ** 2 for x in points ] assert all_equal ( elem_lam , true_elem ) elem_lam = space . element ( lambda x : 1.0 ) true_elem = [ 1.0 for x in points ] assert all_equal ( elem_lam , true_elem ) elem_lam = space . element ( lambda x : x [ 0 ] , vectorized = False ) assert all_equal ( elem_lam , points )  def test_element_from_function_2d ( ) :      space = odl . uniform_discr ( [ - 1 , - 1 ] , [ 1 , 1 ] , ( 2 , 3 ) ) points = space . points ( ) def f ( x ) :          return x [ 0 ] ** 2 + np . maximum ( x [ 1 ] , 0 )  elem_f = space . element ( f ) true_elem = np . reshape ( [ x [ 0 ] ** 2 + max ( x [ 1 ] , 0 ) for x in points ] , space . shape ) assert all_equal ( elem_f , true_elem ) def f ( x , ** kwargs ) :          c = kwargs . pop ( <str> , 0 ) return x [ 0 ] ** 2 + np . maximum ( x [ 1 ] , c )  elem_f_default = space . element ( f ) true_elem = np . reshape ( [ x [ 0 ] ** 2 + max ( x [ 1 ] , 0 ) for x in points ] , space . shape ) assert all_equal ( elem_f_default , true_elem ) elem_f_2 = space . element ( f , c = 1 ) true_elem = np . reshape ( [ x [ 0 ] ** 2 + max ( x [ 1 ] , 1 ) for x in points ] , space . shape ) assert all_equal ( elem_f_2 , true_elem ) elem_lam = space . element ( lambda x : x [ 0 ] - x [ 1 ] ) true_elem = np . reshape ( [ x [ 0 ] - x [ 1 ] for x in points ] , space . shape ) assert all_equal ( elem_lam , true_elem ) elem_lam = space . element ( lambda x : x [ 0 ] ) true_elem = np . reshape ( [ x [ 0 ] for x in points ] , space . shape ) assert all_equal ( elem_lam , true_elem ) elem_lam = space . element ( lambda x : x [ 1 ] ) true_elem = np . reshape ( [ x [ 1 ] for x in points ] , space . shape ) assert all_equal ( elem_lam , true_elem ) elem_lam = space . element ( lambda x : 1.0 ) true_elem = np . reshape ( [ 1.0 for x in points ] , space . shape ) assert all_equal ( elem_lam , true_elem ) elem_lam = space . element ( lambda x : x [ 0 ] + x [ 1 ] , vectorized = False ) true_elem = np . reshape ( [ x [ 0 ] + x [ 1 ] for x in points ] , space . shape ) assert all_equal ( elem_lam , true_elem )  def test_discretelp_zero_one ( ) :      discr = odl . uniform_discr ( 0 , 1 , 3 ) zero = discr . zero ( ) assert zero in discr assert np . array_equal ( zero , [ 0 , 0 , 0 ] ) one = discr . one ( ) assert one in discr assert np . array_equal ( one , [ 1 , 1 , 1 ] )  def test_equals_space ( exponent , odl_tspace_impl ) :      impl = odl_tspace_impl x1 = odl . uniform_discr ( 0 , 1 , 3 , exponent = exponent , impl = impl ) x2 = odl . uniform_discr ( 0 , 1 , 3 , exponent = exponent , impl = impl ) y = odl . uniform_discr ( 0 , 1 , 4 , exponent = exponent , impl = impl ) assert x1 is x1 assert x1 is not x2 assert x1 is not y assert x1 == x1 assert x1 == x2 assert x1 != y assert hash ( x1 ) == hash ( x2 ) assert hash ( x1 ) != hash ( y )  def test_equals_vec ( exponent , odl_tspace_impl ) :      impl = odl_tspace_impl discr = odl . uniform_discr ( 0 , 1 , 3 , exponent = exponent , impl = impl ) discr2 = odl . uniform_discr ( 0 , 1 , 4 , exponent = exponent , impl = impl ) x1 = discr . element ( [ 1 , 2 , 3 ] ) x2 = discr . element ( [ 1 , 2 , 3 ] ) y = discr . element ( [ 2 , 2 , 3 ] ) z = discr2 . element ( [ 1 , 2 , 3 , 4 ] ) assert x1 is x1 assert x1 is not x2 assert x1 is not y assert x1 == x1 assert x1 == x2 assert x1 != y assert x1 != z  def _test_unary_operator ( discr , function ) :      x_arr , x = noise_elements ( discr ) y_arr = function ( x_arr ) y = function ( x ) assert all_almost_equal ( [ x , y ] , [ x_arr , y_arr ] )  def _test_binary_operator ( discr , function ) :      [ x_arr , y_arr ] , [ x , y ] = noise_elements ( discr , 2 ) z_arr = function ( x_arr , y_arr ) z = function ( x , y ) assert all_almost_equal ( [ x , y , z ] , [ x_arr , y_arr , z_arr ] )  def test_operators ( odl_tspace_impl ) :      impl = odl_tspace_impl discr = odl . uniform_discr ( 0 , 1 , 10 , impl = impl ) _test_unary_operator ( discr , lambda x : + x ) _test_unary_operator ( discr , lambda x : - x ) for scalar in [ - 31.2 , - 1 , 0 , 1 , 2.13 ] :          def iadd ( x ) :              x += scalar  _test_unary_operator ( discr , iadd ) _test_unary_operator ( discr , lambda x : x + scalar )  for scalar in [ - 31.2 , - 1 , 0 , 1 , 2.13 ] :          def isub ( x ) :              x -= scalar  _test_unary_operator ( discr , isub ) _test_unary_operator ( discr , lambda x : x - scalar )  for scalar in [ - 31.2 , - 1 , 0 , 1 , 2.13 ] :          def imul ( x ) :              x *= scalar  _test_unary_operator ( discr , imul ) _test_unary_operator ( discr , lambda x : x * scalar )  for scalar in [ - 31.2 , - 1 , 1 , 2.13 ] :          def idiv ( x ) :              x /= scalar  _test_unary_operator ( discr , idiv ) _test_unary_operator ( discr , lambda x : x / scalar )  def iadd ( x , y ) :          x += y  def isub ( x , y ) :          x -= y  def imul ( x , y ) :          x *= y  def idiv ( x , y ) :          x /= y  _test_binary_operator ( discr , iadd ) _test_binary_operator ( discr , isub ) _test_binary_operator ( discr , imul ) _test_binary_operator ( discr , idiv ) def iadd_aliased ( x ) :          x += x  def isub_aliased ( x ) :          x -= x  def imul_aliased ( x ) :          x *= x  def idiv_aliased ( x ) :          x /= x  _test_unary_operator ( discr , iadd_aliased ) _test_unary_operator ( discr , isub_aliased ) _test_unary_operator ( discr , imul_aliased ) _test_unary_operator ( discr , idiv_aliased ) _test_binary_operator ( discr , lambda x , y : x + y ) _test_binary_operator ( discr , lambda x , y : x - y ) _test_binary_operator ( discr , lambda x , y : x * y ) _test_binary_operator ( discr , lambda x , y : x / y ) _test_unary_operator ( discr , lambda x : x + x ) _test_unary_operator ( discr , lambda x : x - x ) _test_unary_operator ( discr , lambda x : x * x ) _test_unary_operator ( discr , lambda x : x / x )  def test_interp ( ) :      discr = odl . uniform_discr ( 0 , 1 , 3 , interp = <str> ) assert isinstance ( discr . interpolation , odl . NearestInterpolation ) discr = odl . uniform_discr ( 0 , 1 , 3 , interp = <str> ) assert isinstance ( discr . interpolation , odl . LinearInterpolation ) discr = odl . uniform_discr ( [ 0 , 0 ] , [ 1 , 1 ] , ( 3 , 3 ) , interp = [ <str> , <str> ] ) assert isinstance ( discr . interpolation , odl . PerAxisInterpolation ) with pytest . raises ( ValueError ) :          discr = odl . uniform_discr ( 0 , 1 , 3 , interp = [ <str> , <str> ] )  with pytest . raises ( ValueError ) :          discr = odl . uniform_discr ( [ 0 ] * 3 , [ 1 ] * 3 , ( 3 , ) * 3 , interp = [ <str> , <str> ] )   def test_getitem ( ) :      discr = odl . uniform_discr ( 0 , 1 , 3 ) elem = discr . element ( [ 1 , 2 , 3 ] ) assert all_equal ( elem , [ 1 , 2 , 3 ] )  def test_getslice ( ) :      discr = odl . uniform_discr ( 0 , 1 , 3 ) elem = discr . element ( [ 1 , 2 , 3 ] ) assert isinstance ( elem [ : ] , NumpyTensor ) assert all_equal ( elem [ : ] , [ 1 , 2 , 3 ] ) discr = odl . uniform_discr ( 0 , 1 , 3 , dtype = <str> ) elem = discr . element ( [ 1 + 2j , 2 - 2j , 3 ] ) assert isinstance ( elem [ : ] , NumpyTensor ) assert all_equal ( elem [ : ] , [ 1 + 2j , 2 - 2j , 3 ] )  def test_setitem ( ) :      discr = odl . uniform_discr ( 0 , 1 , 3 ) elem = discr . element ( [ 1 , 2 , 3 ] ) elem [ 0 ] = 4 elem [ 1 ] = 5 elem [ 2 ] = 6 assert all_equal ( elem , [ 4 , 5 , 6 ] )  def test_setitem_nd ( ) :      discr = odl . uniform_discr ( 0 , 1 , 3 ) elem = discr . element ( [ 1 , 2 , 3 ] ) elem [ : ] = [ 4 , 5 , 6 ] assert all_equal ( elem , [ 4 , 5 , 6 ] ) elem [ : ] = np . array ( [ 3 , 2 , 1 ] ) assert all_equal ( elem , [ 3 , 2 , 1 ] ) elem [ : ] = 0 assert all_equal ( elem , [ 0 , 0 , 0 ] ) elem [ : ] = [ 1 ] assert all_equal ( elem , [ 1 , 1 , 1 ] ) with pytest . raises ( ValueError ) :          elem [ : ] = [ 0 , 0 ]  with pytest . raises ( ValueError ) :          elem [ : ] = [ 0 , 0 , 1 , 2 ]  discr = odl . uniform_discr ( [ 0 , 0 ] , [ 1 , 1 ] , [ 3 , 2 ] ) elem = discr . element ( [ [ 1 , 2 ] , [ 3 , 4 ] , [ 5 , 6 ] ] ) elem [ : ] = [ [ - 1 , - 2 ] , [ - 3 , - 4 ] , [ - 5 , - 6 ] ] assert all_equal ( elem , [ [ - 1 , - 2 ] , [ - 3 , - 4 ] , [ - 5 , - 6 ] ] ) arr = np . arange ( 6 , 12 ) . reshape ( [ 3 , 2 ] ) elem [ : ] = arr assert all_equal ( elem , arr ) elem [ : ] = 0 assert all_equal ( elem , np . zeros ( elem . shape ) ) elem [ : ] = [ 1 ] assert all_equal ( elem , np . ones ( elem . shape ) ) elem [ : ] = [ 0 , 0 ] assert all_equal ( elem , np . zeros ( elem . shape ) ) with pytest . raises ( ValueError ) :          elem [ : ] = [ 0 , 0 , 0 ]  with pytest . raises ( ValueError ) :          elem [ : ] = np . arange ( 6 )  with pytest . raises ( ValueError ) :          elem [ : ] = np . ones ( ( 2 , 3 ) ) [ ... , np . newaxis ]  with pytest . raises ( ValueError ) :          arr = np . arange ( 6 , 12 ) . reshape ( [ 3 , 2 ] ) elem [ : ] = arr . T  shape = ( 3 , ) * 3 + ( 4 , ) * 3 discr = odl . uniform_discr ( [ 0 ] * 6 , [ 1 ] * 6 , shape ) size = np . prod ( shape ) elem = discr . element ( np . zeros ( shape ) ) arr = np . arange ( size ) . reshape ( shape ) elem [ : ] = arr assert all_equal ( elem , arr ) elem [ : ] = 0 assert all_equal ( elem , np . zeros ( elem . shape ) ) elem [ : ] = [ 1 ] assert all_equal ( elem , np . ones ( elem . shape ) ) with pytest . raises ( ValueError ) :          elem [ : ] = np . arange ( size ) . reshape ( ( 4 , ) * 3 + ( 3 , ) * 3 )   def test_setslice ( ) :      discr = odl . uniform_discr ( 0 , 1 , 3 ) elem = discr . element ( [ 1 , 2 , 3 ] ) elem [ : ] = [ 4 , 5 , 6 ] assert all_equal ( elem , [ 4 , 5 , 6 ] )  def test_asarray_2d ( odl_elem_order ) :      order = odl_elem_order discr = odl . uniform_discr ( [ 0 , 0 ] , [ 1 , 1 ] , [ 2 , 2 ] ) elem = discr . element ( [ [ 1 , 2 ] , [ 3 , 4 ] ] , order = order ) arr = elem . asarray ( ) assert all_equal ( arr , [ [ 1 , 2 ] , [ 3 , 4 ] ] ) if order is None :          assert arr . flags [ discr . default_order + <str> ]  else :          assert arr . flags [ order + <str> ]  out_c = np . empty ( [ 2 , 2 ] , order = <str> ) result_c = elem . asarray ( out = out_c ) assert result_c is out_c assert all_equal ( out_c , [ [ 1 , 2 ] , [ 3 , 4 ] ] ) out_f = np . empty ( [ 2 , 2 ] , order = <str> ) result_f = elem . asarray ( out = out_f ) assert result_f is out_f assert all_equal ( out_f , [ [ 1 , 2 ] , [ 3 , 4 ] ] ) out_wrong_shape = np . empty ( [ 2 , 3 ] ) with pytest . raises ( ValueError ) :          elem . asarray ( out = out_wrong_shape )   def test_transpose ( ) :      discr = odl . uniform_discr ( [ 0 , 0 ] , [ 1 , 1 ] , [ 2 , 2 ] ) x = discr . element ( [ [ 1 , 2 ] , [ 3 , 4 ] ] ) y = discr . element ( [ [ 5 , 6 ] , [ 7 , 8 ] ] ) assert isinstance ( x . T , odl . Operator ) assert x . T . is_linear assert x . T ( y ) == x . inner ( y ) assert x . T . T == x assert all_equal ( x . T . adjoint ( 1.0 ) , x )  def test_cell_sides ( ) :      discr = odl . uniform_discr ( [ 0 , 0 ] , [ 1 , 1 ] , [ 2 , 2 ] ) elem = discr . element ( ) assert all_equal ( discr . cell_sides , [ 0.5 ] * 2 ) assert all_equal ( elem . cell_sides , [ 0.5 ] * 2 ) discr = odl . uniform_discr ( [ 0 , 0 ] , [ 1 , 1 ] , [ 2 , 1 ] ) elem = discr . element ( ) assert all_equal ( discr . cell_sides , [ 0.5 , 1 ] ) assert all_equal ( elem . cell_sides , [ 0.5 , 1 ] )  def test_cell_volume ( ) :      discr = odl . uniform_discr ( [ 0 , 0 ] , [ 1 , 1 ] , [ 2 , 2 ] ) elem = discr . element ( ) assert discr . cell_volume == 0.25 assert elem . cell_volume == 0.25 discr = odl . uniform_discr ( [ 0 , 0 ] , [ 1 , 1 ] , [ 2 , 1 ] ) elem = discr . element ( ) assert discr . cell_volume == 0.5 assert elem . cell_volume == 0.5  def test_astype ( ) :      rdiscr = odl . uniform_discr ( [ 0 , 0 ] , [ 1 , 1 ] , [ 2 , 2 ] , dtype = <str> ) cdiscr = odl . uniform_discr ( [ 0 , 0 ] , [ 1 , 1 ] , [ 2 , 2 ] , dtype = <str> ) rdiscr_s = odl . uniform_discr ( [ 0 , 0 ] , [ 1 , 1 ] , [ 2 , 2 ] , dtype = <str> ) cdiscr_s = odl . uniform_discr ( [ 0 , 0 ] , [ 1 , 1 ] , [ 2 , 2 ] , dtype = <str> ) assert rdiscr . astype ( <str> ) == rdiscr_s assert rdiscr . astype ( <str> ) is rdiscr assert rdiscr . real_space is rdiscr assert rdiscr . astype ( <str> ) == cdiscr_s assert rdiscr . astype ( <str> ) == cdiscr assert rdiscr . complex_space == cdiscr assert cdiscr . astype ( <str> ) == cdiscr_s assert cdiscr . astype ( <str> ) is cdiscr assert cdiscr . complex_space is cdiscr assert cdiscr . astype ( <str> ) == rdiscr_s assert cdiscr . astype ( <str> ) == rdiscr assert cdiscr . real_space == rdiscr discr = odl . uniform_discr ( [ 0 , 0 ] , [ 1 , 1 ] , [ 2 , 2 ] , dtype = bool ) as_float = discr . astype ( float ) assert as_float . dtype == float assert not as_float . is_weighted as_complex = discr . astype ( complex ) assert as_complex . dtype == complex assert not as_complex . is_weighted  def test_ufuncs ( odl_tspace_impl , odl_ufunc ) :      impl = odl_tspace_impl space = odl . uniform_discr ( [ 0 , 0 ] , [ 1 , 1 ] , ( 2 , 3 ) , impl = impl ) name = odl_ufunc npy_ufunc = getattr ( np , name ) nin = npy_ufunc . nin nout = npy_ufunc . nout if ( np . issubsctype ( space . dtype , np . floating ) and name in [ <str> , <str> , <str> , <str> , <str> , <str> ] ) :          return  arrays , elements = noise_elements ( space , nin + nout ) in_arrays = arrays [ : nin ] out_arrays = arrays [ nin : ] data_elem = elements [ 0 ] out_elems = elements [ nin : ] if nout == 1 :          out_arr_kwargs = { <str> : out_arrays [ 0 ] } out_elem_kwargs = { <str> : out_elems [ 0 ] }  elif nout > 1 :          out_arr_kwargs = { <str> : out_arrays [ : nout ] } out_elem_kwargs = { <str> : out_elems [ : nout ] }  elem_fun_old = getattr ( data_elem . ufuncs , name ) in_elems_old = elements [ 1 : nin ] elem_fun_new = npy_ufunc in_elems_new = elements [ : nin ] with np . errstate ( all = <str> ) :          npy_result = npy_ufunc ( * in_arrays ) odl_result_old = elem_fun_old ( * in_elems_old ) assert all_almost_equal ( npy_result , odl_result_old ) odl_result_new = elem_fun_new ( * in_elems_new ) assert all_almost_equal ( npy_result , odl_result_new )  if nout == 1 :          assert isinstance ( odl_result_old , space . element_type ) assert isinstance ( odl_result_new , space . element_type )  elif nout > 1 :          for i in range ( nout ) :              assert isinstance ( odl_result_old [ i ] , space . element_type ) assert isinstance ( odl_result_new [ i ] , space . element_type )   with np . errstate ( all = <str> ) :          npy_result = npy_ufunc ( * in_arrays , ** out_arr_kwargs ) odl_result_old = elem_fun_old ( * in_elems_old , ** out_elem_kwargs ) assert all_almost_equal ( npy_result , odl_result_old ) odl_result_new = elem_fun_new ( * in_elems_new , ** out_elem_kwargs ) assert all_almost_equal ( npy_result , odl_result_new )  if nout == 1 :          assert odl_result_old is out_elems [ 0 ] assert odl_result_new is out_elems [ 0 ]  elif nout > 1 :          for i in range ( nout ) :              assert odl_result_old [ i ] is out_elems [ i ] assert odl_result_new [ i ] is out_elems [ i ]   out_arrays_new = tuple ( np . empty_like ( arr ) for arr in out_arrays ) if nout == 1 :          out_arr_kwargs_new = { <str> : out_arrays_new [ 0 ] }  elif nout > 1 :          out_arr_kwargs_new = { <str> : out_arrays_new [ : nout ] }  with np . errstate ( all = <str> ) :          odl_result_arr_new = elem_fun_new ( * in_elems_new , ** out_arr_kwargs_new )  assert all_almost_equal ( npy_result , odl_result_arr_new ) if nout == 1 :          assert odl_result_arr_new is out_arrays_new [ 0 ]  elif nout > 1 :          for i in range ( nout ) :              assert odl_result_arr_new [ i ] is out_arrays_new [ i ]   out_tensors_new = tuple ( space . tspace . element ( np . empty_like ( arr ) ) for arr in out_arrays ) if nout == 1 :          out_tens_kwargs_new = { <str> : out_tensors_new [ 0 ] }  elif nout > 1 :          out_tens_kwargs_new = { <str> : out_tensors_new [ : nout ] }  with np . errstate ( all = <str> ) :          odl_result_tens_new = elem_fun_new ( * in_elems_new , ** out_tens_kwargs_new )  assert all_almost_equal ( npy_result , odl_result_tens_new ) if nout == 1 :          assert odl_result_tens_new is out_tensors_new [ 0 ]  elif nout > 1 :          for i in range ( nout ) :              assert odl_result_tens_new [ i ] is out_tensors_new [ i ]   indices = ( [ 0 , 0 , 1 ] , [ 0 , 1 , 2 ] ) mod_array = in_arrays [ 0 ] . copy ( ) mod_elem = in_elems_new [ 0 ] . copy ( ) if nout > 1 :          return  if nin == 1 :          with np . errstate ( all = <str> ) :              npy_result = npy_ufunc . at ( mod_array , indices ) odl_result = npy_ufunc . at ( mod_elem , indices )   elif nin == 2 :          other_array = in_arrays [ 1 ] [ indices ] other_elem = in_elems_new [ 1 ] [ indices ] with np . errstate ( all = <str> ) :              npy_result = npy_ufunc . at ( mod_array , indices , other_array ) odl_result = npy_ufunc . at ( mod_elem , indices , other_elem )   assert all_almost_equal ( odl_result , npy_result ) if nin == 2 and nout == 1 :          in_array = in_arrays [ 0 ] in_elem = in_elems_new [ 0 ] with np . errstate ( all = <str> ) :              npy_result = npy_ufunc . reduce ( in_array ) odl_result = npy_ufunc . reduce ( in_elem ) assert all_almost_equal ( odl_result , npy_result ) out_elem = odl_result . space . element ( ) out_array = np . empty ( odl_result . shape , dtype = odl_result . dtype ) npy_ufunc . reduce ( in_elem , out = out_elem ) npy_ufunc . reduce ( in_elem , out = out_array ) assert all_almost_equal ( out_elem , odl_result ) assert all_almost_equal ( out_array , odl_result ) try :                  npy_result = npy_ufunc . reduce ( in_array , dtype = complex )  except TypeError :                  return  else :                  odl_result = npy_ufunc . reduce ( in_elem , dtype = complex ) assert odl_result . dtype == npy_result . dtype assert all_almost_equal ( odl_result , npy_result )     def test_ufunc_corner_cases ( odl_tspace_impl ) :      impl = odl_tspace_impl space = odl . uniform_discr ( [ 0 , 0 ] , [ 1 , 1 ] , ( 2 , 3 ) , impl = impl ) x = space . element ( [ [ - 1 , 0 , 1 ] , [ 1 , 2 , 3 ] ] ) space_no_w = odl . uniform_discr ( [ 0 , 0 ] , [ 1 , 1 ] , ( 2 , 3 ) , impl = impl , weighting = 1.0 ) with pytest . raises ( ValueError ) :          x . __array_ufunc__ ( np . sin , <str> , x , np . ones ( ( 2 , 3 ) ) )  res = x . __array_ufunc__ ( np . sin , <str> , x , out = ( None , ) ) assert all_almost_equal ( res , np . sin ( x . asarray ( ) ) ) assert res . space == space for order in ( <str> , <str> ) :          res = x . __array_ufunc__ ( np . sin , <str> , x , order = order ) assert all_almost_equal ( res , np . sin ( x . asarray ( ) ) ) assert res . tensor . data . flags [ order + <str> ]  res = x . __array_ufunc__ ( np . sin , <str> , x , dtype = complex ) assert all_almost_equal ( res , np . sin ( x . asarray ( ) , dtype = complex ) ) assert res . dtype == complex y = space_no_w . one ( ) res = y . __array_ufunc__ ( np . sin , <str> , y ) assert res . space . weighting == space_no_w . weighting y = space_no_w . one ( ) res = y . __array_ufunc__ ( np . sin , <str> , y ) assert res . space . weighting == space_no_w . weighting with pytest . raises ( ValueError ) :          x . __array_ufunc__ ( np . add , <str> , x )  with pytest . raises ( ValueError ) :          out1 , out2 = np . empty_like ( x ) , np . empty_like ( x ) x . __array_ufunc__ ( np . add , <str> , x , x , out = ( out1 , out2 ) )  arr = np . ones ( ( 2 , 3 ) ) arr += x assert all_almost_equal ( arr , x . asarray ( ) + 1 ) arr = np . ones ( ( 2 , 3 ) ) res = x . __array_ufunc__ ( np . add , <str> , arr , x , out = ( arr , ) ) assert all_almost_equal ( arr , x . asarray ( ) + 1 ) assert res is arr res = x . __array_ufunc__ ( np . add , <str> , x ) assert all_almost_equal ( res , np . add . accumulate ( x . asarray ( ) ) ) assert res . space == space arr = np . empty_like ( x ) res = x . __array_ufunc__ ( np . add , <str> , x , out = ( arr , ) ) assert all_almost_equal ( arr , np . add . accumulate ( x . asarray ( ) ) ) assert res is arr res = x . __array_ufunc__ ( np . add , <str> , x , dtype = <str> ) assert res . dtype == <str> with pytest . raises ( ValueError ) :          out1 , out2 = np . empty_like ( x ) , np . empty_like ( x ) x . __array_ufunc__ ( np . add , <str> , x , out = ( out1 , out2 ) )  res = x . __array_ufunc__ ( np . add , <str> , x ) assert all_almost_equal ( res , np . add . reduce ( x . asarray ( ) ) ) with pytest . raises ( ValueError ) :          x . __array_ufunc__ ( np . add , <str> , x , keepdims = True )  out_ax0 = np . empty ( 3 ) res = x . __array_ufunc__ ( np . add , <str> , x , axis = 0 , out = ( out_ax0 , ) ) assert all_almost_equal ( out_ax0 , np . add . reduce ( x . asarray ( ) , axis = 0 ) ) assert res is out_ax0 out_ax1 = odl . rn ( 2 ) . element ( ) res = x . __array_ufunc__ ( np . add , <str> , x , axis = 1 , out = ( out_ax1 , ) ) assert all_almost_equal ( out_ax1 , np . add . reduce ( x . asarray ( ) , axis = 1 ) ) assert res is out_ax1 res = x . __array_ufunc__ ( np . add , <str> , x , axis = ( 0 , 1 ) ) assert res == pytest . approx ( np . add . reduce ( x . asarray ( ) , axis = ( 0 , 1 ) ) ) y = space . one ( ) res = y . __array_ufunc__ ( np . add , <str> , y , axis = 0 ) assert res . space . weighting . const == pytest . approx ( space . cell_sides [ 1 ] ) space_1 = odl . uniform_discr ( [ 0 , 0 ] , [ 1 , 1 ] , ( 2 , 3 ) , impl = impl , exponent = 1 ) z = space_1 . one ( ) res = z . __array_ufunc__ ( np . add , <str> , z , axis = 0 ) assert res . space . exponent == 1 x = y = space . one ( ) res = x . __array_ufunc__ ( np . add , <str> , x , y ) assert isinstance ( res . space . weighting , ConstWeighting ) assert res . space . weighting . const == pytest . approx ( x . space . weighting . const * y . space . weighting . const ) x = space . one ( ) y = space_no_w . one ( ) res = x . __array_ufunc__ ( np . add , <str> , x , y ) assert isinstance ( res . space . weighting , ConstWeighting ) assert res . space . weighting . const == pytest . approx ( x . space . weighting . const ) x = y = space_no_w . one ( ) res = x . __array_ufunc__ ( np . add , <str> , x , y ) assert not res . space . is_weighted  def test_real_imag ( odl_tspace_impl , odl_elem_order ) :      impl = odl_tspace_impl order = odl_elem_order tspace_cls = odl . space . entry_points . tensor_space_impl ( impl ) for dtype in filter ( odl . util . is_complex_floating_dtype , tspace_cls . available_dtypes ( ) ) :          cdiscr = odl . uniform_discr ( [ 0 , 0 ] , [ 1 , 1 ] , [ 2 , 2 ] , dtype = dtype , impl = impl ) rdiscr = cdiscr . real_space x = cdiscr . element ( [ [ 1 - 1j , 2 - 2j ] , [ 3 - 3j , 4 - 4j ] ] , order = order ) assert x . real in rdiscr assert all_equal ( x . real , [ [ 1 , 2 ] , [ 3 , 4 ] ] ) assert x . imag in rdiscr assert all_equal ( x . imag , [ [ - 1 , - 2 ] , [ - 3 , - 4 ] ] ) for assigntype in ( lambda x : x , tuple , rdiscr . element ) :              x = cdiscr . zero ( ) x . real = assigntype ( [ [ 2 , 3 ] , [ 4 , 5 ] ] ) assert all_equal ( x . real , [ [ 2 , 3 ] , [ 4 , 5 ] ] ) x = cdiscr . zero ( ) x . imag = assigntype ( [ [ 4 , 5 ] , [ 6 , 7 ] ] ) assert all_equal ( x . imag , [ [ 4 , 5 ] , [ 6 , 7 ] ] ) x = cdiscr . zero ( ) x . real [ : ] = assigntype ( [ [ 2 , 3 ] , [ 4 , 5 ] ] ) assert all_equal ( x . real , [ [ 2 , 3 ] , [ 4 , 5 ] ] ) x = cdiscr . zero ( ) x . imag [ : ] = assigntype ( [ [ 2 , 3 ] , [ 4 , 5 ] ] ) assert all_equal ( x . imag , [ [ 2 , 3 ] , [ 4 , 5 ] ] )  x = cdiscr . zero ( ) x . real = 1 assert all_equal ( x . real , [ [ 1 , 1 ] , [ 1 , 1 ] ] ) x = cdiscr . zero ( ) x . imag = - 1 assert all_equal ( x . imag , [ [ - 1 , - 1 ] , [ - 1 , - 1 ] ] )  with pytest . raises ( ValueError ) :          x . real = [ 4 , 5 , 6 , 7 ]  with pytest . raises ( ValueError ) :          x . imag = [ 4 , 5 , 6 , 7 ]   def test_reduction ( odl_tspace_impl , odl_reduction ) :      impl = odl_tspace_impl name = odl_reduction space = odl . uniform_discr ( [ 0 , 0 ] , [ 1 , 1 ] , [ 2 , 2 ] , impl = impl ) reduction = getattr ( np , name ) x_arr , x = noise_elements ( space , 1 ) assert reduction ( x_arr ) == pytest . approx ( getattr ( x . ufuncs , name ) ( ) )  def test_power ( odl_tspace_impl , power ) :      impl = odl_tspace_impl space = odl . uniform_discr ( [ 0 , 0 ] , [ 1 , 1 ] , [ 2 , 2 ] , impl = impl ) x_arr , x = noise_elements ( space , 1 ) x_pos_arr = np . abs ( x_arr ) x_neg_arr = - x_pos_arr x_pos = np . abs ( x ) x_neg = - x_pos if int ( power ) != power :          for y in [ x_pos_arr , x_neg_arr , x_pos , x_neg ] :              y += 0.1   with np . errstate ( invalid = <str> ) :          true_pos_pow = np . power ( x_pos_arr , power ) true_neg_pow = np . power ( x_neg_arr , power )  if int ( power ) != power and impl == <str> :          with pytest . raises ( ValueError ) :              x_pos ** power  with pytest . raises ( ValueError ) :              x_pos **= power   else :          with np . errstate ( invalid = <str> ) :              assert all_almost_equal ( x_pos ** power , true_pos_pow ) assert all_almost_equal ( x_neg ** power , true_neg_pow ) x_pos **= power x_neg **= power assert all_almost_equal ( x_pos , true_pos_pow ) assert all_almost_equal ( x_neg , true_neg_pow )    def test_inner_nonuniform ( ) :      fspace = odl . FunctionSpace ( odl . IntervalProd ( 0 , 5 ) ) part = odl . nonuniform_partition ( [ 0 , 2 , 3 , 5 ] , min_pt = 0 , max_pt = 5 ) weights = part . cell_sizes_vecs [ 0 ] tspace = odl . rn ( part . size , weighting = weights ) discr = odl . DiscreteLp ( fspace , part , tspace ) one = discr . one ( ) linear = discr . element ( lambda x : x ) exact_inner = 5 ** 2 / 2.0 inner = one . inner ( linear ) assert inner == pytest . approx ( exact_inner )  def test_norm_nonuniform ( ) :      fspace = odl . FunctionSpace ( odl . IntervalProd ( 0 , 5 ) ) part = odl . nonuniform_partition ( [ 0 , 2 , 3 , 5 ] , min_pt = 0 , max_pt = 5 ) weights = part . cell_sizes_vecs [ 0 ] tspace = odl . rn ( part . size , weighting = weights ) discr = odl . DiscreteLp ( fspace , part , tspace ) sqrt = discr . element ( lambda x : np . sqrt ( x ) ) exact_norm = np . sqrt ( 5 ** 2 / 2.0 ) norm = sqrt . norm ( ) assert norm == pytest . approx ( exact_norm )  def test_norm_interval ( exponent ) :      p = exponent fspace = odl . FunctionSpace ( odl . IntervalProd ( 0 , 1 ) ) lpdiscr = odl . uniform_discr_fromspace ( fspace , 10 , exponent = p ) testfunc = fspace . element ( lambda x : x ** 2 ) discr_testfunc = lpdiscr . element ( testfunc ) if p == float ( <str> ) :          assert discr_testfunc . norm ( ) <= 1  else :          true_norm = ( 1 + 2 * p ) ** ( - 1 / p ) assert discr_testfunc . norm ( ) == pytest . approx ( true_norm , rel = 1e-2 )   def test_norm_rectangle ( exponent ) :      p = exponent fspace = odl . FunctionSpace ( odl . IntervalProd ( [ 0 , - 1 ] , [ 1 , 1 ] ) ) lpdiscr = odl . uniform_discr_fromspace ( fspace , ( 20 , 30 ) , exponent = p ) testfunc = fspace . element ( lambda x : x [ 0 ] ** 2 * x [ 1 ] ** 3 ) discr_testfunc = lpdiscr . element ( testfunc ) if p == float ( <str> ) :          assert discr_testfunc . norm ( ) <= 1  else :          true_norm = ( ( 1 + 2 * p ) * ( 1 + 3 * p ) / 2 ) ** ( - 1 / p ) assert discr_testfunc . norm ( ) == pytest . approx ( true_norm , rel = 1e-2 )   def test_norm_rectangle_boundary ( odl_tspace_impl , exponent ) :      impl = odl_tspace_impl dtype = <str> rect = odl . IntervalProd ( [ - 1 , - 2 ] , [ 1 , 2 ] ) fspace = odl . FunctionSpace ( rect , out_dtype = dtype ) discr = odl . uniform_discr_fromspace ( fspace , ( 4 , 8 ) , impl = impl , exponent = exponent ) if exponent == float ( <str> ) :          assert discr . one ( ) . norm ( ) == 1  else :          assert ( discr . one ( ) . norm ( ) == pytest . approx ( rect . volume ** ( 1 / exponent ) ) )  discr = odl . uniform_discr_fromspace ( fspace , ( 4 , 8 ) , exponent = exponent , impl = impl , nodes_on_bdry = True ) if exponent == float ( <str> ) :          assert discr . one ( ) . norm ( ) == 1  else :          assert ( discr . one ( ) . norm ( ) == pytest . approx ( rect . volume ** ( 1 / exponent ) ) )  discr = odl . uniform_discr_fromspace ( fspace , ( 4 , 8 ) , exponent = exponent , impl = impl , nodes_on_bdry = ( ( False , True ) , False ) ) if exponent == float ( <str> ) :          assert discr . one ( ) . norm ( ) == 1  else :          assert ( discr . one ( ) . norm ( ) == pytest . approx ( rect . volume ** ( 1 / exponent ) ) )  discr = odl . uniform_discr_fromspace ( fspace , ( 4 , 8 ) , exponent = exponent , impl = impl , nodes_on_bdry = ( False , ( True , False ) ) ) if exponent == float ( <str> ) :          assert discr . one ( ) . norm ( ) == 1  else :          assert ( discr . one ( ) . norm ( ) == pytest . approx ( rect . volume ** ( 1 / exponent ) ) )  grid = odl . uniform_grid ( [ 0 , 0 ] , [ 1 , 1 ] , ( 4 , 4 ) ) part = odl . RectPartition ( rect , grid ) weight = 1.0 if exponent == float ( <str> ) else part . cell_volume tspace = odl . rn ( part . shape , dtype = dtype , impl = impl , exponent = exponent , weighting = weight ) discr = DiscreteLp ( fspace , part , tspace ) if exponent == float ( <str> ) :          assert discr . one ( ) . norm ( ) == 1  else :          assert ( discr . one ( ) . norm ( ) == pytest . approx ( rect . volume ** ( 1 / exponent ) ) )   def test_uniform_discr_fromdiscr_one_attr ( ) :      discr = odl . uniform_discr ( [ 0 , - 1 ] , [ 1 , 1 ] , [ 10 , 5 ] ) new_min_pt = [ 3 , 7 ] true_new_max_pt = [ 4 , 9 ] new_discr = odl . uniform_discr_fromdiscr ( discr , min_pt = new_min_pt ) assert all_almost_equal ( new_discr . min_pt , new_min_pt ) assert all_almost_equal ( new_discr . max_pt , true_new_max_pt ) assert all_equal ( new_discr . shape , discr . shape ) assert all_almost_equal ( new_discr . cell_sides , discr . cell_sides ) new_max_pt = [ 3 , 7 ] true_new_min_pt = [ 2 , 5 ] new_discr = odl . uniform_discr_fromdiscr ( discr , max_pt = new_max_pt ) assert all_almost_equal ( new_discr . min_pt , true_new_min_pt ) assert all_almost_equal ( new_discr . max_pt , new_max_pt ) assert all_equal ( new_discr . shape , discr . shape ) assert all_almost_equal ( new_discr . cell_sides , discr . cell_sides ) new_shape = ( 5 , 20 ) true_new_csides = [ 0.2 , 0.1 ] new_discr = odl . uniform_discr_fromdiscr ( discr , shape = new_shape ) assert all_almost_equal ( new_discr . min_pt , discr . min_pt ) assert all_almost_equal ( new_discr . max_pt , discr . max_pt ) assert all_equal ( new_discr . shape , new_shape ) assert all_almost_equal ( new_discr . cell_sides , true_new_csides ) new_csides = [ 0.5 , 0.2 ] true_new_shape = ( 2 , 10 ) new_discr = odl . uniform_discr_fromdiscr ( discr , cell_sides = new_csides ) assert all_almost_equal ( new_discr . min_pt , discr . min_pt ) assert all_almost_equal ( new_discr . max_pt , discr . max_pt ) assert all_equal ( new_discr . shape , true_new_shape ) assert all_almost_equal ( new_discr . cell_sides , new_csides )  def test_uniform_discr_fromdiscr_two_attrs ( ) :      discr = odl . uniform_discr ( [ 0 , - 1 ] , [ 1 , 1 ] , [ 10 , 5 ] ) new_min_pt = [ - 2 , 1 ] new_max_pt = [ 4 , 2 ] true_new_csides = [ 0.6 , 0.2 ] new_discr = odl . uniform_discr_fromdiscr ( discr , min_pt = new_min_pt , max_pt = new_max_pt ) assert all_almost_equal ( new_discr . min_pt , new_min_pt ) assert all_almost_equal ( new_discr . max_pt , new_max_pt ) assert all_equal ( new_discr . shape , discr . shape ) assert all_almost_equal ( new_discr . cell_sides , true_new_csides ) new_min_pt = [ - 2 , 1 ] new_shape = ( 5 , 20 ) true_new_max_pt = [ - 1.5 , 9 ] new_discr = odl . uniform_discr_fromdiscr ( discr , min_pt = new_min_pt , shape = new_shape ) assert all_almost_equal ( new_discr . min_pt , new_min_pt ) assert all_almost_equal ( new_discr . max_pt , true_new_max_pt ) assert all_equal ( new_discr . shape , new_shape ) assert all_almost_equal ( new_discr . cell_sides , discr . cell_sides ) new_min_pt = [ - 2 , 1 ] new_csides = [ 0.6 , 0.2 ] true_new_max_pt = [ 4 , 2 ] new_discr = odl . uniform_discr_fromdiscr ( discr , min_pt = new_min_pt , cell_sides = new_csides ) assert all_almost_equal ( new_discr . min_pt , new_min_pt ) assert all_almost_equal ( new_discr . max_pt , true_new_max_pt ) assert all_equal ( new_discr . shape , discr . shape ) assert all_almost_equal ( new_discr . cell_sides , new_csides ) new_max_pt = [ 4 , 2 ] new_shape = ( 5 , 20 ) true_new_min_pt = [ 3.5 , - 6 ] new_discr = odl . uniform_discr_fromdiscr ( discr , max_pt = new_max_pt , shape = new_shape ) assert all_almost_equal ( new_discr . min_pt , true_new_min_pt ) assert all_almost_equal ( new_discr . max_pt , new_max_pt ) assert all_equal ( new_discr . shape , new_shape ) assert all_almost_equal ( new_discr . cell_sides , discr . cell_sides ) new_max_pt = [ 4 , 2 ] new_csides = [ 0.6 , 0.2 ] true_new_min_pt = [ - 2 , 1 ] new_discr = odl . uniform_discr_fromdiscr ( discr , max_pt = new_max_pt , cell_sides = new_csides ) assert all_almost_equal ( new_discr . min_pt , true_new_min_pt ) assert all_almost_equal ( new_discr . max_pt , new_max_pt ) assert all_equal ( new_discr . shape , discr . shape ) assert all_almost_equal ( new_discr . cell_sides , new_csides )  def test_uniform_discr_fromdiscr_per_axis ( ) :      discr = odl . uniform_discr ( [ 0 , - 1 ] , [ 1 , 1 ] , [ 10 , 5 ] ) new_min_pt = [ - 2 , None ] new_max_pt = [ 4 , 2 ] new_shape = ( None , 20 ) new_csides = [ None , None ] true_new_min_pt = [ - 2 , - 6 ] true_new_max_pt = [ 4 , 2 ] true_new_shape = ( 10 , 20 ) true_new_csides = [ 0.6 , 0.4 ] new_discr = odl . uniform_discr_fromdiscr ( discr , min_pt = new_min_pt , max_pt = new_max_pt , shape = new_shape , cell_sides = new_csides ) assert all_almost_equal ( new_discr . min_pt , true_new_min_pt ) assert all_almost_equal ( new_discr . max_pt , true_new_max_pt ) assert all_equal ( new_discr . shape , true_new_shape ) assert all_almost_equal ( new_discr . cell_sides , true_new_csides ) new_min_pt = None new_max_pt = [ None , 2 ] new_shape = ( 5 , None ) new_csides = [ None , 0.2 ] true_new_min_pt = [ 0 , 1 ] true_new_max_pt = [ 1 , 2 ] true_new_shape = ( 5 , 5 ) true_new_csides = [ 0.2 , 0.2 ] new_discr = odl . uniform_discr_fromdiscr ( discr , min_pt = new_min_pt , max_pt = new_max_pt , shape = new_shape , cell_sides = new_csides ) assert all_almost_equal ( new_discr . min_pt , true_new_min_pt ) assert all_almost_equal ( new_discr . max_pt , true_new_max_pt ) assert all_equal ( new_discr . shape , true_new_shape ) assert all_almost_equal ( new_discr . cell_sides , true_new_csides )  if __name__ == <str> :      odl . util . test_file ( __file__ )   