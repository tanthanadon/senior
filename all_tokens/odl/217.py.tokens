from __future__ import division import numpy as np import pytest import odl from odl . trafos . backends import pyfftw_call , PYFFTW_AVAILABLE from odl . util import ( is_real_dtype , complex_dtype ) from odl . util . testutils import ( all_almost_equal , simple_fixture ) pytestmark = pytest . mark . skipif ( not PYFFTW_AVAILABLE , reason = <str> ) planning = simple_fixture ( <str> , [ <str> , <str> , <str> , <str> ] ) direction = simple_fixture ( <str> , [ <str> , <str> ] ) def _random_array ( shape , dtype ) :      if is_real_dtype ( dtype ) :          return np . random . rand ( * shape ) . astype ( dtype )  else :          return ( np . random . rand ( * shape ) . astype ( dtype ) + 1j * np . random . rand ( * shape ) . astype ( dtype ) )   def _params_from_dtype ( dtype ) :      if is_real_dtype ( dtype ) :          halfcomplex = True  else :          halfcomplex = False  return halfcomplex , complex_dtype ( dtype )  def _halfcomplex_shape ( shape , axes = None ) :      if axes is None :          axes = tuple ( range ( len ( shape ) ) )  try :          axes = ( int ( axes ) , )  except TypeError :          pass  shape = list ( shape ) shape [ axes [ - 1 ] ] = shape [ axes [ - 1 ] ] // 2 + 1 return shape  def test_pyfftw_call_forward ( odl_floating_dtype ) :      dtype = odl_floating_dtype if dtype == np . dtype ( <str> ) :          return  halfcomplex , out_dtype = _params_from_dtype ( dtype ) for shape in [ ( 10 , ) , ( 3 , 4 , 5 ) ] :          arr = _random_array ( shape , dtype ) if halfcomplex :              true_dft = np . fft . rfftn ( arr ) dft_arr = np . empty ( _halfcomplex_shape ( shape ) , dtype = out_dtype )  else :              true_dft = np . fft . fftn ( arr ) dft_arr = np . empty ( shape , dtype = out_dtype )  pyfftw_call ( arr , dft_arr , direction = <str> , halfcomplex = halfcomplex , preserve_input = False ) assert all_almost_equal ( dft_arr , true_dft )   def test_pyfftw_call_threads ( ) :      shape = ( 3 , 4 , 5 ) arr = _random_array ( shape , dtype = <str> ) true_dft = np . fft . fftn ( arr ) dft_arr = np . empty ( shape , dtype = <str> ) pyfftw_call ( arr , dft_arr , direction = <str> , preserve_input = False , threads = 4 ) assert all_almost_equal ( dft_arr , true_dft ) shape = ( 1000 , ) arr = _random_array ( shape , dtype = <str> ) true_dft = np . fft . fftn ( arr ) dft_arr = np . empty ( shape , dtype = <str> ) pyfftw_call ( arr , dft_arr , direction = <str> , preserve_input = False ) assert all_almost_equal ( dft_arr , true_dft )  def test_pyfftw_call_backward ( odl_floating_dtype ) :      dtype = odl_floating_dtype if dtype == np . dtype ( <str> ) :          return  halfcomplex , in_dtype = _params_from_dtype ( dtype ) for shape in [ ( 10 , ) , ( 3 , 4 , 5 ) ] :          idft_scaling = np . prod ( shape ) if halfcomplex :              arr = _random_array ( _halfcomplex_shape ( shape ) , in_dtype ) true_idft = np . fft . irfftn ( arr , shape ) * idft_scaling  else :              arr = _random_array ( shape , in_dtype ) true_idft = np . fft . ifftn ( arr ) * idft_scaling  idft_arr = np . empty ( shape , dtype = dtype ) pyfftw_call ( arr , idft_arr , direction = <str> , halfcomplex = halfcomplex ) assert all_almost_equal ( idft_arr , true_idft )   def test_pyfftw_call_bad_input ( direction ) :      dtype_in = np . dtype ( <str> ) arr_in = np . empty ( 3 , dtype = dtype_in ) bad_dtypes_out = np . sctypes [ <str> ] + np . sctypes [ <str> ] if dtype_in in bad_dtypes_out :          bad_dtypes_out . remove ( dtype_in )  for bad_dtype in bad_dtypes_out :          arr_out = np . empty ( 3 , dtype = bad_dtype ) with pytest . raises ( ValueError ) :              pyfftw_call ( arr_in , arr_out , halfcomplex = False , direction = direction )   shape = ( 3 , 4 ) arr_in = np . empty ( shape , dtype = <str> ) bad_shapes_out = [ ( 3 , 3 ) , ( 3 , ) , ( 4 , ) , ( 3 , 4 , 5 ) , ( ) ] for bad_shape in bad_shapes_out :          arr_out = np . empty ( bad_shape , dtype = <str> ) with pytest . raises ( ValueError ) :              pyfftw_call ( arr_in , arr_out , halfcomplex = False , direction = direction )   arr_in = np . empty ( ( 3 , 4 , 5 ) , dtype = <str> ) arr_out = np . empty_like ( arr_in ) bad_axes_list = [ ( 0 , 0 , 1 ) , ( 1 , 1 , 1 ) , ( - 1 , - 1 ) ] for bad_axes in bad_axes_list :          with pytest . raises ( ValueError ) :              pyfftw_call ( arr_in , arr_out , axes = bad_axes , direction = direction )   arr_in = np . empty ( ( 3 , 4 , 5 ) , dtype = <str> ) arr_out = np . empty_like ( arr_in ) bad_axes_list = [ ( 0 , 3 ) , ( - 4 , ) ] for bad_axes in bad_axes_list :          with pytest . raises ( ValueError ) :              pyfftw_call ( arr_in , arr_out , axes = bad_axes , direction = direction )   arr_in = np . empty ( ( 3 , 4 , 5 ) , dtype = <str> ) arr_out = np . empty_like ( arr_in ) with pytest . raises ( ValueError ) :          pyfftw_call ( arr_in , arr_out , halfcomplex = True , direction = direction )  arr_in = np . empty ( ( 3 , 4 , 5 ) , dtype = <str> ) arr_out = np . empty_like ( arr_in , dtype = <str> ) with pytest . raises ( ValueError ) :          pyfftw_call ( arr_in , arr_out , direction = direction )  dtype_in = <str> arr_in = np . empty ( 10 , dtype = dtype_in ) bad_dtypes_out = np . sctypes [ <str> ] + np . sctypes [ <str> ] try :          bad_dtypes_out . remove ( np . dtype ( <str> ) )  except ValueError :          pass  for bad_dtype in bad_dtypes_out :          arr_out = np . empty ( 6 , dtype = bad_dtype ) with pytest . raises ( ValueError ) :              if direction == <str> :                  pyfftw_call ( arr_in , arr_out , halfcomplex = True , direction = <str> )  else :                  pyfftw_call ( arr_out , arr_in , halfcomplex = True , direction = <str> )    shape = ( 3 , 4 , 5 ) axes_list = [ None , ( 0 , 1 ) , ( 1 , ) , ( 1 , 2 ) , ( 2 , 1 ) , ( - 1 , - 2 , - 3 ) ] arr_in = np . empty ( shape , dtype = <str> ) bad_shapes_out = [ ( 3 , 4 , 2 ) , ( 3 , 4 , 3 ) , ( 2 , 3 , 5 ) , ( 3 , 2 , 3 ) , ( 3 , 4 , 3 ) , ( 3 , 4 , 3 ) ] always_bad_shapes = [ ( 3 , 4 ) , ( 3 , 4 , 5 ) ] for bad_shape , axes in zip ( bad_shapes_out , axes_list ) :          for always_bad_shape in always_bad_shapes :              arr_out = np . empty ( always_bad_shape , dtype = <str> ) with pytest . raises ( ValueError ) :                  if direction == <str> :                      pyfftw_call ( arr_in , arr_out , axes = axes , halfcomplex = True , direction = <str> )  else :                      pyfftw_call ( arr_out , arr_in , axes = axes , halfcomplex = True , direction = <str> )    arr_out = np . empty ( bad_shape , dtype = <str> ) with pytest . raises ( ValueError ) :              if direction == <str> :                  pyfftw_call ( arr_in , arr_out , axes = axes , halfcomplex = True , direction = <str> )  else :                  pyfftw_call ( arr_out , arr_in , axes = axes , halfcomplex = True , direction = <str> )     def test_pyfftw_call_forward_real_not_halfcomplex ( ) :      for shape in [ ( 10 , ) , ( 3 , 4 , 5 ) ] :          arr = _random_array ( shape , dtype = <str> ) true_dft = np . fft . fftn ( arr ) dft_arr = np . empty ( shape , dtype = <str> ) pyfftw_call ( arr , dft_arr , direction = <str> , halfcomplex = False ) assert all_almost_equal ( dft_arr , true_dft )   def test_pyfftw_call_backward_real_not_halfcomplex ( ) :      for shape in [ ( 10 , ) , ( 3 , 4 , 5 ) ] :          idft_scaling = np . prod ( shape ) arr = _random_array ( shape , dtype = <str> ) true_idft = np . fft . ifftn ( arr ) * idft_scaling idft_arr = np . empty ( shape , dtype = <str> ) pyfftw_call ( arr , idft_arr , direction = <str> , halfcomplex = False ) assert all_almost_equal ( idft_arr , true_idft )   def test_pyfftw_call_plan_preserve_input ( planning ) :      for shape in [ ( 10 , ) , ( 3 , 4 ) ] :          arr = _random_array ( shape , dtype = <str> ) arr_cpy = arr . copy ( ) idft_scaling = np . prod ( shape ) true_idft = np . fft . ifftn ( arr ) * idft_scaling idft_arr = np . empty ( shape , dtype = <str> ) pyfftw_call ( arr , idft_arr , direction = <str> , halfcomplex = False , planning = planning ) assert all_almost_equal ( arr , arr_cpy ) assert all_almost_equal ( idft_arr , true_idft )   def test_pyfftw_call_forward_with_axes ( odl_floating_dtype ) :      dtype = odl_floating_dtype if dtype == np . dtype ( <str> ) :          return  halfcomplex , out_dtype = _params_from_dtype ( dtype ) shape = ( 3 , 4 , 5 ) test_axes = [ ( 0 , 1 ) , [ 1 ] , ( - 1 , ) , ( 1 , 0 ) , ( - 1 , - 2 , - 3 ) ] for axes in test_axes :          arr = _random_array ( shape , dtype ) if halfcomplex :              true_dft = np . fft . rfftn ( arr , axes = axes ) dft_arr = np . empty ( _halfcomplex_shape ( shape , axes ) , dtype = out_dtype )  else :              true_dft = np . fft . fftn ( arr , axes = axes ) dft_arr = np . empty ( shape , dtype = out_dtype )  pyfftw_call ( arr , dft_arr , direction = <str> , axes = axes , halfcomplex = halfcomplex ) assert all_almost_equal ( dft_arr , true_dft )   def test_pyfftw_call_backward_with_axes ( odl_floating_dtype ) :      dtype = odl_floating_dtype if dtype == np . dtype ( <str> ) :          return  halfcomplex , in_dtype = _params_from_dtype ( dtype ) shape = ( 3 , 4 , 5 ) test_axes = [ ( 0 , 1 ) , [ 1 ] , ( - 1 , ) , ( 1 , 0 ) , ( - 1 , - 2 , - 3 ) ] for axes in test_axes :          active_shape = np . take ( shape , axes ) idft_scaling = np . prod ( active_shape ) if halfcomplex :              arr = _random_array ( _halfcomplex_shape ( shape , axes ) , in_dtype ) true_idft = ( np . fft . irfftn ( arr , s = active_shape , axes = axes ) * idft_scaling )  else :              arr = _random_array ( shape , in_dtype ) true_idft = ( np . fft . ifftn ( arr , s = active_shape , axes = axes ) * idft_scaling )  idft_arr = np . empty ( shape , dtype = dtype ) pyfftw_call ( arr , idft_arr , direction = <str> , axes = axes , halfcomplex = halfcomplex ) assert all_almost_equal ( idft_arr , true_idft )   def test_pyfftw_call_forward_with_plan ( ) :      for shape in [ ( 10 , ) , ( 3 , 4 , 5 ) ] :          arr = _random_array ( shape , dtype = <str> ) arr_cpy = arr . copy ( ) true_dft = np . fft . fftn ( arr ) dft_arr = np . empty ( shape , dtype = <str> ) plan = pyfftw_call ( arr , dft_arr , direction = <str> , halfcomplex = False , planning_effort = <str> ) dft_arr = np . empty ( shape , dtype = <str> ) pyfftw_call ( arr , dft_arr , direction = <str> , fftw_plan = plan , halfcomplex = False ) assert all_almost_equal ( arr , arr_cpy ) assert all_almost_equal ( dft_arr , true_dft )   def test_pyfftw_call_backward_with_plan ( ) :      for shape in [ ( 10 , ) , ( 3 , 4 , 5 ) ] :          arr = _random_array ( shape , dtype = <str> ) arr_cpy = arr . copy ( ) idft_scaling = np . prod ( shape ) true_idft = np . fft . ifftn ( arr ) * idft_scaling idft_arr = np . empty ( shape , dtype = <str> ) plan = pyfftw_call ( arr , idft_arr , direction = <str> , halfcomplex = False , planning_effort = <str> ) idft_arr = np . empty ( shape , dtype = <str> ) pyfftw_call ( arr , idft_arr , direction = <str> , fftw_plan = plan , halfcomplex = False ) assert all_almost_equal ( arr , arr_cpy ) assert all_almost_equal ( idft_arr , true_idft )   if __name__ == <str> :      odl . util . test_file ( __file__ )   