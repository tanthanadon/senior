from __future__ import division import numpy as np import pytest import odl from odl . util import ( apply_on_boundary , fast_1d_tensor_mult , resize_array , is_real_dtype ) from odl . util . numerics import _SUPPORTED_RESIZE_PAD_MODES from odl . util . testutils import all_equal , dtype_tol , simple_fixture paddings = list ( _SUPPORTED_RESIZE_PAD_MODES ) paddings . remove ( <str> ) paddings . extend ( [ ( <str> , 0 ) , ( <str> , 1 ) ] ) padding_ids = [ <str> . format ( * p ) if isinstance ( p , tuple ) else <str> . format ( p ) for p in paddings ] @ pytest . fixture ( scope = <str> , ids = padding_ids , params = paddings ) def padding ( request ) :      if isinstance ( request . param , tuple ) :          pad_mode , pad_const = request . param  else :          pad_mode = request . param pad_const = 0  return pad_mode , pad_const  variant = simple_fixture ( <str> , [ <str> , <str> , <str> ] ) @ pytest . fixture ( scope = <str> ) def resize_setup ( padding , variant ) :      array_in = [ [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] , [ 9 , 10 , 11 , 12 ] ] pad_mode , pad_const = padding if variant == <str> :          newshp = ( 4 , 7 ) offset = ( 1 , 2 ) if pad_mode == <str> and pad_const == 0 :              true_out = [ [ 0 , 0 , 0 , 0 , 0 , 0 , 0 ] , [ 0 , 0 , 1 , 2 , 3 , 4 , 0 ] , [ 0 , 0 , 5 , 6 , 7 , 8 , 0 ] , [ 0 , 0 , 9 , 10 , 11 , 12 , 0 ] ]  elif pad_mode == <str> and pad_const == 1 :              true_out = [ [ 1 , 1 , 1 , 1 , 1 , 1 , 1 ] , [ 1 , 1 , 1 , 2 , 3 , 4 , 1 ] , [ 1 , 1 , 5 , 6 , 7 , 8 , 1 ] , [ 1 , 1 , 9 , 10 , 11 , 12 , 1 ] ]  elif pad_mode == <str> :              true_out = [ [ 11 , 12 , 9 , 10 , 11 , 12 , 9 ] , [ 3 , 4 , 1 , 2 , 3 , 4 , 1 ] , [ 7 , 8 , 5 , 6 , 7 , 8 , 5 ] , [ 11 , 12 , 9 , 10 , 11 , 12 , 9 ] ]  elif pad_mode == <str> :              true_out = [ [ 7 , 6 , 5 , 6 , 7 , 8 , 7 ] , [ 3 , 2 , 1 , 2 , 3 , 4 , 3 ] , [ 7 , 6 , 5 , 6 , 7 , 8 , 7 ] , [ 11 , 10 , 9 , 10 , 11 , 12 , 11 ] ]  elif pad_mode == <str> :              true_out = [ [ 1 , 1 , 1 , 2 , 3 , 4 , 4 ] , [ 1 , 1 , 1 , 2 , 3 , 4 , 4 ] , [ 5 , 5 , 5 , 6 , 7 , 8 , 8 ] , [ 9 , 9 , 9 , 10 , 11 , 12 , 12 ] ]  elif pad_mode == <str> :              true_out = [ [ - 5 , - 4 , - 3 , - 2 , - 1 , 0 , 1 ] , [ - 1 , 0 , 1 , 2 , 3 , 4 , 5 ] , [ 3 , 4 , 5 , 6 , 7 , 8 , 9 ] , [ 7 , 8 , 9 , 10 , 11 , 12 , 13 ] ]   elif variant == <str> :          newshp = ( 2 , 1 ) offset = ( 1 , 2 ) true_out = [ [ 7 ] , [ 11 ] ]  elif variant == <str> :          newshp = ( 2 , 7 ) offset = ( 1 , 2 ) if pad_mode == <str> and pad_const == 0 :              true_out = [ [ 0 , 0 , 5 , 6 , 7 , 8 , 0 ] , [ 0 , 0 , 9 , 10 , 11 , 12 , 0 ] ]  elif pad_mode == <str> and pad_const == 1 :              true_out = [ [ 1 , 1 , 5 , 6 , 7 , 8 , 1 ] , [ 1 , 1 , 9 , 10 , 11 , 12 , 1 ] ]  elif pad_mode == <str> :              true_out = [ [ 7 , 8 , 5 , 6 , 7 , 8 , 5 ] , [ 11 , 12 , 9 , 10 , 11 , 12 , 9 ] ]  elif pad_mode == <str> :              true_out = [ [ 7 , 6 , 5 , 6 , 7 , 8 , 7 ] , [ 11 , 10 , 9 , 10 , 11 , 12 , 11 ] ]  elif pad_mode == <str> :              true_out = [ [ 5 , 5 , 5 , 6 , 7 , 8 , 8 ] , [ 9 , 9 , 9 , 10 , 11 , 12 , 12 ] ]  elif pad_mode == <str> :              true_out = [ [ 3 , 4 , 5 , 6 , 7 , 8 , 9 ] , [ 7 , 8 , 9 , 10 , 11 , 12 , 13 ] ]  else :              raise ValueError ( <str> )   else :          raise ValueError ( <str> )  return pad_mode , pad_const , newshp , offset , array_in , true_out  def test_apply_on_boundary_default ( ) :      arr = np . ones ( 5 ) result = apply_on_boundary ( arr , lambda x : x * 2 ) assert all_equal ( arr , [ 1 , 1 , 1 , 1 , 1 ] ) assert all_equal ( result , [ 2 , 1 , 1 , 1 , 2 ] ) arr = np . ones ( ( 3 , 4 , 5 ) ) result = apply_on_boundary ( arr , lambda x : x * 2 ) true_arr = 2 * np . ones ( ( 3 , 4 , 5 ) ) true_arr [ 1 : - 1 , 1 : - 1 , 1 : - 1 ] = 1 assert all_equal ( result , true_arr )  def test_apply_on_boundary_func_sequence_2d ( ) :      arr = np . ones ( ( 3 , 5 ) ) result = apply_on_boundary ( arr , [ lambda x : x * 2 , lambda x : x * 3 ] ) assert all_equal ( result , [ [ 2 , 2 , 2 , 2 , 2 ] , [ 3 , 1 , 1 , 1 , 3 ] , [ 2 , 2 , 2 , 2 , 2 ] ] )  def test_apply_on_boundary_multiple_times_2d ( ) :      arr = np . ones ( ( 3 , 5 ) ) result = apply_on_boundary ( arr , lambda x : x * 2 , only_once = False ) assert all_equal ( result , [ [ 4 , 2 , 2 , 2 , 4 ] , [ 2 , 1 , 1 , 1 , 2 ] , [ 4 , 2 , 2 , 2 , 4 ] ] )  def test_apply_on_boundary_which_boundaries ( ) :      arr = np . ones ( 5 ) which = ( ( True , False ) , ) result = apply_on_boundary ( arr , lambda x : x * 2 , which_boundaries = which ) assert all_equal ( result , [ 2 , 1 , 1 , 1 , 1 ] ) arr = np . ones ( ( 3 , 5 ) ) which = ( ( True , False ) , True ) result = apply_on_boundary ( arr , lambda x : x * 2 , which_boundaries = which ) assert all_equal ( result , [ [ 2 , 2 , 2 , 2 , 2 ] , [ 2 , 1 , 1 , 1 , 2 ] , [ 2 , 1 , 1 , 1 , 2 ] ] )  def test_apply_on_boundary_which_boundaries_multiple_times_2d ( ) :      arr = np . ones ( ( 3 , 5 ) ) which = ( ( True , False ) , True ) result = apply_on_boundary ( arr , lambda x : x * 2 , which_boundaries = which , only_once = False ) assert all_equal ( result , [ [ 4 , 2 , 2 , 2 , 4 ] , [ 2 , 1 , 1 , 1 , 2 ] , [ 2 , 1 , 1 , 1 , 2 ] ] )  def test_apply_on_boundary_axis_order_2d ( ) :      arr = np . ones ( ( 3 , 5 ) ) axis_order = ( - 1 , - 2 ) result = apply_on_boundary ( arr , [ lambda x : x * 3 , lambda x : x * 2 ] , axis_order = axis_order ) assert all_equal ( result , [ [ 3 , 2 , 2 , 2 , 3 ] , [ 3 , 1 , 1 , 1 , 3 ] , [ 3 , 2 , 2 , 2 , 3 ] ] )  def test_fast_1d_tensor_mult ( ) :      def simple_mult_3 ( x , y , z ) :          return x [ : , None , None ] * y [ None , : , None ] * z [ None , None , : ]  shape = ( 2 , 3 , 4 ) x , y , z = ( np . arange ( size , dtype = <str> ) for size in shape ) true_result = simple_mult_3 ( x , y , z ) test_arr = np . ones ( shape ) out = fast_1d_tensor_mult ( test_arr , [ x , y , z ] ) assert all_equal ( out , true_result ) assert all_equal ( test_arr , np . ones ( shape ) ) test_arr = np . ones ( shape ) out = fast_1d_tensor_mult ( test_arr , [ x , y , z ] , axes = ( 0 , 1 , 2 ) ) assert all_equal ( out , true_result ) test_arr = np . ones ( shape ) fast_1d_tensor_mult ( test_arr , [ x , y , z ] , out = test_arr ) assert all_equal ( test_arr , true_result ) test_arr = np . ones ( shape ) out = np . empty ( shape ) fast_1d_tensor_mult ( test_arr , [ x , y , z ] , out = out ) assert all_equal ( out , true_result ) test_arr = np . ones ( shape ) out = fast_1d_tensor_mult ( test_arr , [ y , x , z ] , axes = ( 1 , 0 , 2 ) ) assert all_equal ( out , true_result ) test_arr = np . ones ( shape ) out = fast_1d_tensor_mult ( test_arr , [ x , z , y ] , axes = ( 0 , 2 , 1 ) ) assert all_equal ( out , true_result ) test_arr = np . ones ( shape ) out = fast_1d_tensor_mult ( test_arr , [ z , x , y ] , axes = ( 2 , 0 , 1 ) ) assert all_equal ( out , true_result ) test_arr = np . ones ( shape ) out = fast_1d_tensor_mult ( test_arr , [ z , x , y , np . ones ( 3 ) ] , axes = ( 2 , 0 , 1 , 1 ) ) assert all_equal ( out , true_result ) test_arr = np . ones ( shape ) out = fast_1d_tensor_mult ( test_arr , [ x , y , z [ None , : ] ] ) assert all_equal ( out , true_result ) shape = ( 1 , 3 , 4 ) test_arr = np . ones ( shape ) out = fast_1d_tensor_mult ( test_arr , [ 2 , y , z ] ) assert all_equal ( out , simple_mult_3 ( np . ones ( 1 ) * 2 , y , z ) ) def simple_mult_2 ( y , z , nx ) :          return np . ones ( ( nx , 1 , 1 ) ) * y [ None , : , None ] * z [ None , None , : ]  shape = ( 2 , 3 , 4 ) x , y , z = ( np . arange ( size , dtype = <str> ) for size in shape ) true_result = simple_mult_2 ( y , z , 2 ) test_arr = np . ones ( shape ) out = fast_1d_tensor_mult ( test_arr , [ y , z ] , axes = ( 1 , 2 ) ) assert all_equal ( out , true_result ) test_arr = np . ones ( shape ) out = fast_1d_tensor_mult ( test_arr , [ z , y ] , axes = ( 2 , 1 ) ) assert all_equal ( out , true_result )  def test_fast_1d_tensor_mult_error ( ) :      shape = ( 2 , 3 , 4 ) test_arr = np . ones ( shape ) x , y , z = ( np . arange ( size , dtype = <str> ) for size in shape ) with pytest . raises ( TypeError ) :          fast_1d_tensor_mult ( [ [ 0 , 0 ] , [ 0 , 0 ] ] , [ x , x ] )  with pytest . raises ( ValueError ) :          fast_1d_tensor_mult ( test_arr , [ ] )  with pytest . raises ( ValueError ) :          fast_1d_tensor_mult ( test_arr , [ x , y ] )  with pytest . raises ( ValueError ) :          fast_1d_tensor_mult ( test_arr , [ x , y ] , ( 1 , 2 , 0 ) )  with pytest . raises ( ValueError ) :          fast_1d_tensor_mult ( test_arr , [ x , x , y , z ] )  with pytest . raises ( ValueError ) :          fast_1d_tensor_mult ( test_arr , [ x , y , z ] , ( 1 , 2 , 3 ) )  with pytest . raises ( ValueError ) :          fast_1d_tensor_mult ( test_arr , [ x , y , z ] , ( - 2 , - 3 , - 4 ) )  with pytest . raises ( ValueError ) :          fast_1d_tensor_mult ( test_arr , [ x , y , np . ones ( ( 4 , 2 ) ) ] , ( - 2 , - 3 , - 4 ) )   def test_resize_array_fwd ( resize_setup , odl_scalar_dtype ) :      dtype = odl_scalar_dtype pad_mode , pad_const , newshp , offset , array_in , true_out = resize_setup array_in = np . array ( array_in , dtype = dtype ) true_out = np . array ( true_out , dtype = dtype ) resized = resize_array ( array_in , newshp , offset , pad_mode , pad_const , direction = <str> ) out = np . empty ( newshp , dtype = dtype ) resize_array ( array_in , newshp , offset , pad_mode , pad_const , direction = <str> , out = out ) assert np . array_equal ( resized , true_out ) assert np . array_equal ( out , true_out )  def test_resize_array_adj ( resize_setup , odl_floating_dtype ) :      dtype = odl_floating_dtype pad_mode , pad_const , newshp , offset , array , _ = resize_setup if pad_const != 0 :          return  array = np . array ( array , dtype = dtype ) if is_real_dtype ( dtype ) :          other_arr = np . random . uniform ( - 10 , 10 , size = newshp )  else :          other_arr = ( np . random . uniform ( - 10 , 10 , size = newshp ) + 1j * np . random . uniform ( - 10 , 10 , size = newshp ) )  resized = resize_array ( array , newshp , offset , pad_mode , pad_const , direction = <str> ) resized_adj = resize_array ( other_arr , array . shape , offset , pad_mode , pad_const , direction = <str> ) assert ( np . vdot ( resized . ravel ( ) , other_arr . ravel ( ) ) == pytest . approx ( np . vdot ( array . ravel ( ) , resized_adj . ravel ( ) ) , rel = dtype_tol ( dtype ) ) )  def test_resize_array_corner_cases ( odl_scalar_dtype , padding ) :      dtype = odl_scalar_dtype pad_mode , pad_const = padding arr = np . arange ( 12 , dtype = dtype ) . reshape ( ( 3 , 4 ) ) squashed_arr = resize_array ( arr , ( 3 , 0 ) , pad_mode = pad_mode ) assert squashed_arr . size == 0 squashed_arr = resize_array ( arr , ( 0 , 0 ) , pad_mode = pad_mode ) assert squashed_arr . size == 0 if pad_mode == <str> :          true_blownup_arr = np . empty_like ( arr ) true_blownup_arr . fill ( pad_const ) blownup_arr = resize_array ( np . ones ( ( 3 , 0 ) , dtype = dtype ) , ( 3 , 4 ) , pad_mode = pad_mode , pad_const = pad_const ) assert np . array_equal ( blownup_arr , true_blownup_arr ) blownup_arr = resize_array ( np . ones ( ( 0 , 0 ) , dtype = dtype ) , ( 3 , 4 ) , pad_mode = pad_mode , pad_const = pad_const ) assert np . array_equal ( blownup_arr , true_blownup_arr )  zero_axes_arr = resize_array ( np . array ( 0 , dtype = dtype ) , ( ) , pad_mode = pad_mode ) assert zero_axes_arr == np . array ( 0 , dtype = dtype ) if pad_mode == <str> :          max_per_shape = ( 9 , 12 ) res_arr = resize_array ( arr , max_per_shape , pad_mode = <str> , offset = arr . shape ) assert np . array_equal ( res_arr , np . tile ( arr , ( 3 , 3 ) ) )  elif pad_mode == <str> :          arr = np . arange ( 6 ) . reshape ( ( 2 , 3 ) ) max_sym_shape = ( 4 , 7 ) res_arr = resize_array ( arr , max_sym_shape , pad_mode = <str> , offset = [ 1 , 2 ] ) true_arr = np . array ( [ [ 5 , 4 , 3 , 4 , 5 , 4 , 3 ] , [ 2 , 1 , 0 , 1 , 2 , 1 , 0 ] , [ 5 , 4 , 3 , 4 , 5 , 4 , 3 ] , [ 2 , 1 , 0 , 1 , 2 , 1 , 0 ] ] ) assert np . array_equal ( res_arr , true_arr )   def test_resize_array_raise ( ) :      arr_1d = np . arange ( 6 ) arr_2d = np . arange ( 6 ) . reshape ( ( 2 , 3 ) ) with pytest . raises ( TypeError ) :          resize_array ( arr_1d , 19 )  with pytest . raises ( TypeError ) :          resize_array ( arr_1d , ( 10 , ) , out = [ ] )  with pytest . raises ( ValueError ) :          out = np . empty ( ( 4 , 5 ) ) resize_array ( arr_2d , ( 5 , 5 ) , out = out )  with pytest . raises ( ValueError ) :          out = np . empty ( ( 4 , 5 ) ) resize_array ( arr_1d , ( 4 , 5 ) )  with pytest . raises ( ValueError ) :          out = np . empty ( ( 4 , 5 ) ) resize_array ( arr_1d , ( 4 , 5 ) , out = out )  with pytest . raises ( ValueError ) :          resize_array ( arr_1d , ( 10 , ) , pad_mode = <str> )  with pytest . raises ( ValueError ) :          resize_array ( arr_1d , ( 10 , ) , pad_const = 1.0 )  with pytest . raises ( ValueError ) :          arr_1d_float = arr_1d . astype ( float ) resize_array ( arr_1d_float , ( 10 , ) , pad_const = 1.0j )  empty_arr = np . ones ( ( 3 , 0 ) ) with pytest . raises ( ValueError ) :          resize_array ( empty_arr , ( 3 , 1 ) , pad_mode = <str> )  small_arr = np . ones ( ( 3 , 1 ) ) with pytest . raises ( ValueError ) :          resize_array ( small_arr , ( 3 , 3 ) , pad_mode = <str> )  small_arr = np . ones ( ( 3 , 1 ) ) with pytest . raises ( ValueError ) :          resize_array ( small_arr , ( 3 , 2 ) , pad_mode = <str> )  with pytest . raises ( ValueError ) :          resize_array ( small_arr , ( 6 , 1 ) , pad_mode = <str> )  with pytest . raises ( ValueError ) :          resize_array ( small_arr , ( 4 , 3 ) , offset = ( 0 , 1 ) , pad_mode = <str> )  small_arr = np . ones ( ( 3 , 1 ) ) with pytest . raises ( ValueError ) :          resize_array ( small_arr , ( 3 , 3 ) , pad_mode = <str> )  with pytest . raises ( ValueError ) :          resize_array ( small_arr , ( 7 , 1 ) , pad_mode = <str> )  with pytest . raises ( ValueError ) :          resize_array ( small_arr , ( 3 , 4 ) , offset = ( 0 , 1 ) , pad_mode = <str> )   if __name__ == <str> :      odl . util . test_file ( __file__ )   