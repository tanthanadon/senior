from __future__ import print_function , division , absolute_import from odl . operator import Operator from odl . set . sets import Set from odl . space . base_tensors import TensorSpace , Tensor from odl . space . entry_points import tensor_space_impl from odl . set import RealNumbers , ComplexNumbers from odl . util import ( is_real_floating_dtype , is_complex_floating_dtype , is_numeric_dtype ) __all__ = ( <str> , ) class DiscretizedSpace ( TensorSpace ) :      def __init__ ( self , fspace , tspace , sampling = None , interpol = None ) :          if not isinstance ( fspace , Set ) :              raise TypeError ( <str> <str> . format ( fspace ) )  if not isinstance ( tspace , TensorSpace ) :              raise TypeError ( <str> <str> . format ( tspace ) )  if sampling is not None :              if not isinstance ( sampling , Operator ) :                  raise TypeError ( <str> <str> . format ( sampling ) )  if sampling . domain != fspace :                  raise ValueError ( <str> <str> <str> . format ( sampling . domain , tspace ) )  if sampling . range != tspace :                  raise ValueError ( <str> <str> <str> . format ( sampling . range , tspace ) )   if interpol is not None :              if not isinstance ( interpol , Operator ) :                  raise TypeError ( <str> <str> . format ( interpol ) )  if interpol . domain != tspace :                  raise ValueError ( <str> <str> <str> . format ( interpol . domain , tspace ) )  if interpol . range != fspace :                  raise ValueError ( <str> <str> <str> . format ( interpol . range , fspace ) )   super ( DiscretizedSpace , self ) . __init__ ( tspace . shape , tspace . dtype ) self . __fspace = fspace self . __tspace = tspace self . __sampling = sampling self . __interpolation = interpol  @ property def fspace ( self ) :          return self . __fspace  @ property def tspace ( self ) :          return self . __tspace  @ property def tspace_type ( self ) :          return type ( self . tspace )  @ property def sampling ( self ) :          if self . __sampling is not None :              return self . __sampling  else :              raise NotImplementedError ( <str> )   @ property def interpolation ( self ) :          if self . __interpolation is not None :              return self . __interpolation  else :              raise NotImplementedError ( <str> )   def element ( self , inp = None , order = None , ** kwargs ) :          if inp is None :              return self . element_type ( self , self . tspace . element ( order = order ) )  elif inp in self and order is None :              return inp  elif callable ( inp ) :              sampled = self . sampling ( inp , ** kwargs ) return self . element_type ( self , self . tspace . element ( sampled , order = order ) )  else :              return self . element_type ( self , self . tspace . element ( inp , order = order ) )   def __eq__ ( self , other ) :          if other is self :              return True  elif other is None :              return False  else :              return ( super ( DiscretizedSpace , self ) . __eq__ ( other ) and other . fspace == self . fspace and other . tspace == self . tspace and ( getattr ( other , <str> , None ) == getattr ( self , <str> , None ) ) and ( getattr ( other , <str> , None ) == getattr ( self , <str> , None ) ) )   def __hash__ ( self ) :          prop_list = [ super ( DiscretizedSpace , self ) . __hash__ ( ) , self . fspace , self . tspace ] try :              prop_list . append ( self . sampling )  except NotImplementedError :              pass  try :              prop_list . append ( self . interpolation )  except NotImplementedError :              pass  return hash ( tuple ( prop_list ) )  @ property def domain ( self ) :          return self . fspace . domain  def zero ( self ) :          return self . element_type ( self , self . tspace . zero ( ) )  def one ( self ) :          return self . element_type ( self , self . tspace . one ( ) )  @ property def weighting ( self ) :          return self . tspace . weighting  @ property def is_weighted ( self ) :          return getattr ( self . tspace , <str> , False )  @ property def impl ( self ) :          return self . tspace . impl  def _lincomb ( self , a , x1 , b , x2 , out ) :          self . tspace . _lincomb ( a , x1 . tensor , b , x2 . tensor , out . tensor )  def _dist ( self , x1 , x2 ) :          return self . tspace . _dist ( x1 . tensor , x2 . tensor )  def _norm ( self , x ) :          return self . tspace . _norm ( x . tensor )  def _inner ( self , x1 , x2 ) :          return self . tspace . _inner ( x1 . tensor , x2 . tensor )  def _multiply ( self , x1 , x2 , out ) :          self . tspace . _multiply ( x1 . tensor , x2 . tensor , out . tensor )  def _divide ( self , x1 , x2 , out ) :          self . tspace . _divide ( x1 . tensor , x2 . tensor , out . tensor )  @ property def examples ( self ) :          for name , elem in self . fspace . examples :              yield ( name , self . element ( elem ) )   @ property def element_type ( self ) :          return DiscretizedSpaceElement   class DiscretizedSpaceElement ( Tensor ) :      def __init__ ( self , space , tensor ) :          super ( DiscretizedSpaceElement , self ) . __init__ ( space ) self . __tensor = tensor  @ property def tensor ( self ) :          return self . __tensor  @ property def dtype ( self ) :          return self . tensor . dtype  @ property def size ( self ) :          return self . tensor . size  def __len__ ( self ) :          return self . size  def copy ( self ) :          return self . space . element ( self . tensor . copy ( ) )  def asarray ( self , out = None ) :          return self . tensor . asarray ( out = out )  def astype ( self , dtype ) :          return self . space . astype ( dtype ) . element ( self . tensor . astype ( dtype ) )  def __eq__ ( self , other ) :          return ( other in self . space and self . tensor == other . tensor )  def __getitem__ ( self , indices ) :          if isinstance ( indices , type ( self ) ) :              indices = indices . tensor  return self . tensor [ indices ]  def __setitem__ ( self , indices , values ) :          if isinstance ( indices , type ( self ) ) :              indices = indices . tensor  if isinstance ( values , type ( self ) ) :              values = values . tensor  self . tensor . __setitem__ ( indices , values )  def sampling ( self , ufunc , ** kwargs ) :          self . space . sampling ( ufunc , out = self . tensor , ** kwargs )  @ property def interpolation ( self ) :          return self . space . interpolation ( self . tensor )  def __ipow__ ( self , p ) :          self . tensor . __ipow__ ( p ) return self   def tspace_type ( space , impl , dtype = None ) :      field_type = type ( getattr ( space , <str> , None ) ) if dtype is None :          pass  elif is_real_floating_dtype ( dtype ) :          if field_type is None or field_type == ComplexNumbers :              raise TypeError ( <str> <str> <str> . format ( dtype , field_type ) )   elif is_complex_floating_dtype ( dtype ) :          if field_type is None or field_type == RealNumbers :              raise TypeError ( <str> <str> <str> . format ( dtype , field_type ) )   elif is_numeric_dtype ( dtype ) :          if field_type == ComplexNumbers :              raise TypeError ( <str> <str> . format ( dtype , field_type ) )   try :          return tensor_space_impl ( impl )  except ValueError :          raise NotImplementedError ( <str> <str> <str> . format ( space , impl ) )   if __name__ == <str> :      from odl . util . testutils import run_doctests run_doctests ( )   