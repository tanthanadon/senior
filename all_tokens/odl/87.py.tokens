import numpy as np import odl import odl . contrib . solvers model = <str> impl = <str> space = odl . uniform_discr ( min_pt = [ - 20 , - 20 ] , max_pt = [ 20 , 20 ] , shape = [ 256 , 256 ] , dtype = <str> ) geometry = odl . tomo . parallel_beam_geometry ( space ) ray_trafo = odl . tomo . RayTransform ( space , geometry ) phantom = odl . phantom . forbild ( space ) phantom . show ( <str> , clim = [ 1.0 , 1.1 ] ) data = ray_trafo ( phantom ) data += odl . phantom . white_noise ( ray_trafo . range ) * np . mean ( data ) * 0.01 gradient = odl . Gradient ( space ) l1_norm = odl . solvers . GroupL1Norm ( gradient . range ) nlm_func = odl . contrib . solvers . NLMRegularizer ( space , h = 0.02 , impl = impl , patch_size = 5 , patch_distance = 11 ) f = odl . solvers . IndicatorBox ( space , 0 , 2 ) if model == <str> :      lin_ops = [ gradient ] g = [ 0.004 * l1_norm ] sigma = [ 0.05 ]  elif model == <str> :      lin_ops = [ odl . IdentityOperator ( space ) ] g = [ nlm_func ] sigma = [ 2.0 ]  elif model == <str> :      lin_ops = [ gradient , odl . IdentityOperator ( space ) ] g = [ 0.002 * l1_norm , nlm_func ] sigma = [ 0.05 , 2.0 ]  else :      raise RuntimeError ( <str> )  l2_norm = odl . solvers . L2NormSquared ( ray_trafo . range ) h = l2_norm . translated ( data ) * ray_trafo callback = ( odl . solvers . CallbackShow ( step = 10 , clim = [ 1.0 , 1.1 ] ) & odl . solvers . CallbackPrintIteration ( ) ) fbp_op = odl . tomo . fbp_op ( ray_trafo , filter_type = <str> ) fbp = fbp_op ( data ) fbp . show ( <str> , clim = [ 1.0 , 1.1 ] ) x = fbp . copy ( ) odl . solvers . forward_backward_pd ( x , f , g , lin_ops , h , tau = 0.005 , sigma = sigma , niter = 1000 , callback = callback ) x . show ( <str> . format ( model ) , clim = [ 1.0 , 1.1 ] )  