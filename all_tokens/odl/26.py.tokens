from __future__ import print_function , division , absolute_import from builtins import object import numpy as np import re __all__ = ( <str> , <str> ) RAW_UFUNCS = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] UFUNCS = [ ] for name in RAW_UFUNCS :      ufunc = getattr ( np , name ) n_in , n_out = ufunc . nin , ufunc . nout descr = ufunc . __doc__ . splitlines ( ) [ 2 ] descr = re . sub ( <str> , <str> , descr ) doc = descr + . format ( name ) UFUNCS . append ( ( name , n_in , n_out , doc ) )  def wrap_ufunc_base ( name , n_in , n_out , doc ) :      ufunc = getattr ( np , name ) if n_in == 1 :          if n_out == 1 :              def wrapper ( self , out = None , ** kwargs ) :                  if out is None or isinstance ( out , ( type ( self . elem ) , type ( self . elem . data ) ) ) :                      out = ( out , )  return self . elem . __array_ufunc__ ( ufunc , <str> , self . elem , out = out , ** kwargs )   elif n_out == 2 :              def wrapper ( self , out = None , ** kwargs ) :                  if out is None :                      out = ( None , None )  return self . elem . __array_ufunc__ ( ufunc , <str> , self . elem , out = out , ** kwargs )   else :              raise NotImplementedError   elif n_in == 2 :          if n_out == 1 :              def wrapper ( self , x2 , out = None , ** kwargs ) :                  return self . elem . __array_ufunc__ ( ufunc , <str> , self . elem , x2 , out = ( out , ) , ** kwargs )   else :              raise NotImplementedError   else :          raise NotImplementedError  wrapper . __name__ = wrapper . __qualname__ = name wrapper . __doc__ = doc return wrapper  class TensorSpaceUfuncs ( object ) :      def __init__ ( self , elem ) :          self . elem = elem  def sum ( self , axis = None , dtype = None , out = None , keepdims = False ) :          return self . elem . __array_ufunc__ ( np . add , <str> , self . elem , axis = axis , dtype = dtype , out = ( out , ) , keepdims = keepdims )  def prod ( self , axis = None , dtype = None , out = None , keepdims = False ) :          return self . elem . __array_ufunc__ ( np . multiply , <str> , self . elem , axis = axis , dtype = dtype , out = ( out , ) , keepdims = keepdims )  def min ( self , axis = None , dtype = None , out = None , keepdims = False ) :          return self . elem . __array_ufunc__ ( np . minimum , <str> , self . elem , axis = axis , dtype = dtype , out = ( out , ) , keepdims = keepdims )  def max ( self , axis = None , dtype = None , out = None , keepdims = False ) :          return self . elem . __array_ufunc__ ( np . maximum , <str> , self . elem , axis = axis , dtype = dtype , out = ( out , ) , keepdims = keepdims )   for name , n_in , n_out , doc in UFUNCS :      method = wrap_ufunc_base ( name , n_in , n_out , doc ) setattr ( TensorSpaceUfuncs , name , method )  def wrap_ufunc_productspace ( name , n_in , n_out , doc ) :      if n_in == 1 :          if n_out == 1 :              def wrapper ( self , out = None , ** kwargs ) :                  if out is None :                      result = [ getattr ( x . ufuncs , name ) ( ** kwargs ) for x in self . elem ] return self . elem . space . element ( result )  else :                      for x , out_x in zip ( self . elem , out ) :                          getattr ( x . ufuncs , name ) ( out = out_x , ** kwargs )  return out    elif n_out == 2 :              def wrapper ( self , out1 = None , out2 = None , ** kwargs ) :                  if out1 is None :                      out1 = self . elem . space . element ( )  if out2 is None :                      out2 = self . elem . space . element ( )  for x , out1_x , out2_x in zip ( self . elem , out1 , out2 ) :                      getattr ( x . ufuncs , name ) ( out1 = out1_x , out2 = out2_x , ** kwargs )  return out1 , out2   else :              raise NotImplementedError   elif n_in == 2 :          if n_out == 1 :              def wrapper ( self , x2 , out = None , ** kwargs ) :                  if x2 in self . elem . space :                      if out is None :                          result = [ getattr ( x . ufuncs , name ) ( x2p , ** kwargs ) for x , x2p in zip ( self . elem , x2 ) ] return self . elem . space . element ( result )  else :                          for x , x2p , outp in zip ( self . elem , x2 , out ) :                              getattr ( x . ufuncs , name ) ( x2p , out = outp , ** kwargs )  return out   else :                      if out is None :                          result = [ getattr ( x . ufuncs , name ) ( x2 , ** kwargs ) for x in self . elem ] return self . elem . space . element ( result )  else :                          for x , outp in zip ( self . elem , out ) :                              getattr ( x . ufuncs , name ) ( x2 , out = outp , ** kwargs )  return out     else :              raise NotImplementedError   else :          raise NotImplementedError  wrapper . __name__ = wrapper . __qualname__ = name wrapper . __doc__ = doc return wrapper  class ProductSpaceUfuncs ( object ) :      def __init__ ( self , elem ) :          self . elem = elem  def sum ( self ) :          results = [ x . ufuncs . sum ( ) for x in self . elem ] return np . sum ( results )  def prod ( self ) :          results = [ x . ufuncs . prod ( ) for x in self . elem ] return np . prod ( results )  def min ( self ) :          results = [ x . ufuncs . min ( ) for x in self . elem ] return np . min ( results )  def max ( self ) :          results = [ x . ufuncs . max ( ) for x in self . elem ] return np . max ( results )   for name , n_in , n_out , doc in UFUNCS :      method = wrap_ufunc_productspace ( name , n_in , n_out , doc ) setattr ( ProductSpaceUfuncs , name , method )   