import numpy as np import odl reco_space = odl . uniform_discr ( min_pt = [ - 20 , - 20 ] , max_pt = [ 20 , 20 ] , shape = [ 200 , 200 ] ) angle_partition = odl . uniform_partition ( 0 , np . pi , 400 ) detector_partition = odl . uniform_partition ( - 30 , 30 , 400 ) geometry = odl . tomo . Parallel2dGeometry ( angle_partition , detector_partition ) ray_trafo = odl . tomo . RayTransform ( reco_space , geometry ) discr_phantom = odl . phantom . shepp_logan ( reco_space , modified = True ) data = ray_trafo ( discr_phantom ) data += odl . phantom . white_noise ( ray_trafo . range ) * np . mean ( data ) * 0.1 l2_norm = odl . solvers . L2NormSquared ( ray_trafo . range ) data_discrepancy = l2_norm * ( ray_trafo - data ) gradient = odl . Gradient ( reco_space ) l1_norm = odl . solvers . GroupL1Norm ( gradient . range ) smoothed_l1 = odl . solvers . MoreauEnvelope ( l1_norm , sigma = 0.03 ) regularizer = smoothed_l1 * gradient obj_fun = data_discrepancy + 0.03 * regularizer opnorm = odl . power_method_opnorm ( ray_trafo ) hessinv_estimate = odl . ScalingOperator ( reco_space , 1 / opnorm ** 2 ) callback = ( odl . solvers . CallbackPrintIteration ( ) & odl . solvers . CallbackShow ( ) ) maxiter = 30 num_store = 5 x = ray_trafo . domain . zero ( ) odl . solvers . bfgs_method ( obj_fun , x , maxiter = maxiter , num_store = num_store , hessinv_estimate = hessinv_estimate , callback = callback ) discr_phantom . show ( title = <str> ) data . show ( title = <str> ) x . show ( title = <str> , force_show = True )  