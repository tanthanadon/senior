from __future__ import division , print_function import os import odl . contrib . solvers . spdhg as spdhg import odl . contrib . datasets . images as images import matplotlib . pyplot as plt import matplotlib import numpy as np import odl import brewer2mpl folder_out = <str> filename = <str> nepoch = 300 niter_target = 2000 subfolder = <str> . format ( nepoch ) folder_main = <str> . format ( folder_out , filename ) if not os . path . exists ( folder_main ) :      os . makedirs ( folder_main )  folder_today = <str> . format ( folder_main , subfolder ) if not os . path . exists ( folder_today ) :      os . makedirs ( folder_today )  folder_npy = <str> . format ( folder_today ) if not os . path . exists ( folder_npy ) :      os . makedirs ( folder_npy )  image_gray = images . building ( gray = True ) X = odl . uniform_discr ( [ 0 , 0 ] , image_gray . shape , image_gray . shape ) groundtruth = X . element ( image_gray ) clim = [ 0 , 1 ] data = odl . phantom . white_noise ( X , mean = groundtruth , stddev = 0.1 , seed = 1807 ) if not os . path . exists ( <str> . format ( folder_main ) ) :      spdhg . save_image ( groundtruth , <str> , folder_main , 1 , clim = clim ) spdhg . save_image ( data , <str> , folder_main , 2 , clim = clim )  alpha = .12 gamma = 0.99 Dx = odl . PartialDerivative ( X , 0 , pad_mode = <str> ) Dy = odl . PartialDerivative ( X , 1 , pad_mode = <str> ) A = odl . BroadcastOperator ( Dx , Dy ) Y = A . range f = odl . solvers . SeparableSum ( * [ odl . solvers . L1Norm ( Yi ) for Yi in Y ] ) g = 1 / ( 2 * alpha ) * odl . solvers . L2NormSquared ( X ) . translated ( data ) obj_fun = f * A + g mu_g = 1 / alpha file_target = <str> . format ( folder_main ) if not os . path . exists ( file_target ) :      callback = ( odl . solvers . CallbackPrintIteration ( step = 10 , end = <str> ) & odl . solvers . CallbackPrintTiming ( step = 10 , cumulative = True ) ) x_opt , y_opt = X . zero ( ) , Y . zero ( ) normA = np . sqrt ( 8 ) sigma , tau = ( gamma / normA , ) * 2 odl . solvers . pdhg ( x_opt , f , g , A , tau , sigma , niter_target , y = y_opt , callback = callback ) subx_opt = - A . adjoint ( y_opt ) suby_opt = A ( x_opt ) obj_opt = obj_fun ( x_opt ) np . save ( file_target , ( x_opt , y_opt , subx_opt , suby_opt , obj_opt , normA ) ) spdhg . save_image ( x_opt , <str> , folder_main , 1 , clim = clim ) spdhg . save_image ( y_opt [ 0 ] , <str> , folder_main , 2 ) spdhg . save_image ( subx_opt , <str> , folder_main , 3 ) spdhg . save_image ( suby_opt [ 0 ] , <str> , folder_main , 4 )  else :      ( x_opt , y_opt , subx_opt , suby_opt , obj_opt , normA ) = np . load ( file_target )  dist_x = odl . solvers . L2NormSquared ( X ) . translated ( x_opt ) dist_y = odl . solvers . L2NormSquared ( Y ) . translated ( y_opt ) bregman_g = spdhg . bregman ( g , x_opt , subx_opt ) bregman_f = odl . solvers . SeparableSum ( * [ spdhg . bregman ( fi . convex_conj , yi , ri ) for fi , yi , ri in zip ( f , y_opt , suby_opt ) ] ) class CallbackStore ( odl . solvers . util . callback . Callback ) :      def __init__ ( self , alg , iter_save , iter_plot ) :          self . iter_save = iter_save self . iter_plot = iter_plot self . iter = 0 self . alg = alg self . ex , self . ey = X . zero ( ) , Y . zero ( ) self . out = [ ]  def __call__ ( self , w ) :          if self . iter > 0 :              k = self . iter self . ex = 1 / k * ( ( k - 1 ) * self . ex + w [ 0 ] ) self . ey = 1 / k * ( ( k - 1 ) * self . ey + w [ 1 ] )  if self . iter in self . iter_save :              obj = obj_fun ( w [ 0 ] ) breg_x = bregman_g ( w [ 0 ] ) breg_y = bregman_f ( w [ 1 ] ) breg = breg_x + breg_y breg_ex = bregman_g ( self . ex ) breg_ey = bregman_f ( self . ey ) breg_erg = breg_ex + breg_ey dx = dist_x ( w [ 0 ] ) dy = dist_y ( w [ 1 ] ) dist = dx + dy dex = dist_x ( self . ex ) dey = dist_y ( self . ey ) dist_erg = dex + dey self . out . append ( { <str> : obj , <str> : breg , <str> : breg_x , <str> : breg_y , <str> : breg_erg , <str> : breg_ex , <str> : breg_ey , <str> : dist , <str> : dx , <str> : dy , <str> : dist_erg , <str> : dex , <str> : dey , <str> : self . iter } )  if self . iter in self . iter_plot :              fname = <str> . format ( self . alg , self . iter ) spdhg . save_image ( w [ 0 ] , fname , folder_today , 1 , clim = clim )  self . iter += 1   nsub = { <str> : 1 , <str> : 1 , <str> : 2 , <str> : 2 , <str> : 2 , <str> : 1 , <str> : 1 } niter , iter_save , iter_plot = { } , { } , { } for alg in nsub . keys ( ) :      niter [ alg ] = nepoch * nsub [ alg ] iter_save [ alg ] = range ( 0 , niter [ alg ] + 1 , nsub [ alg ] ) iter_plot [ alg ] = list ( np . array ( [ 10 , 20 , 30 , 40 , 100 , 300 ] ) * nsub [ alg ] )  for alg in [ <str> , <str> , <str> , <str> , <str> ] :      print ( <str> + alg + <str> ) prob , sigma , tau , theta = [ None ] * 4 n = nsub [ alg ] ( sub2ind , ind2sub ) = spdhg . divide_1Darray_equally ( range ( 2 ) , n ) np . random . seed ( 1807 ) if alg == <str> or alg == <str> :          prob_subset = [ 1 ] * n prob = [ 1 ] * len ( Y ) sigma = [ gamma / normA ] * len ( Y ) tau = gamma / normA  elif alg == <str> or alg == <str> :          sigma = gamma / normA tau = gamma / normA  elif alg == <str> :          prob_subset = [ 1 / n ] * n prob = [ 1 / n ] * len ( Y ) sigma = [ gamma / normA ] * len ( Y ) tau = gamma / normA  elif alg in [ <str> ] or alg in [ <str> ] :          normAi = [ 2 ] * n prob_subset = [ 1 / n ] * n prob = [ 1 / n ] * len ( Y ) sigma = [ gamma / nA for nA in normAi ] tau = gamma / ( n * max ( normAi ) )  else :          assert False , <str>  def fun_select ( k ) :          return sub2ind [ int ( np . random . choice ( n , 1 , p = prob_subset ) ) ]  callback = ( odl . solvers . CallbackPrintIteration ( fmt = <str> , step = n , end = <str> ) & odl . solvers . CallbackPrintTiming ( fmt = <str> , step = n , end = <str> ) & odl . solvers . CallbackPrintTiming ( fmt = <str> , cumulative = True , step = n ) & CallbackStore ( alg , iter_save [ alg ] , iter_plot [ alg ] ) ) x , y = X . zero ( ) , Y . zero ( ) callback ( [ x , y ] ) if alg . startswith ( <str> ) or alg . startswith ( <str> ) :          spdhg . spdhg ( x , f , g , A , tau , sigma , niter [ alg ] , prob = prob , y = y , fun_select = fun_select , callback = callback )  elif alg . startswith ( <str> ) or alg . startswith ( <str> ) :          spdhg . pa_spdhg ( x , f , g , A , tau , sigma , niter [ alg ] , mu_g , prob = prob , y = y , fun_select = fun_select , callback = callback )  elif alg . startswith ( <str> ) :          odl . solvers . pdhg ( x , f , g , A , tau , sigma , niter [ alg ] , y = y , callback = callback )  elif alg . startswith ( <str> ) :          odl . solvers . pdhg ( x , f , g , A , tau , sigma , niter [ alg ] , y = y , callback = callback , gamma_primal = mu_g )  elif alg . startswith ( <str> ) :          spdhg . spdhg_pesquet ( x , f , g , A , tau , sigma , niter [ alg ] , fun_select = fun_select , y = y , callback = callback )  else :          assert False , <str>  out = callback . callbacks [ 1 ] . out np . save ( <str> . format ( folder_npy , alg ) , ( iter_save [ alg ] , niter [ alg ] , x , out , nsub [ alg ] ) )  algs = [ <str> , <str> , <str> , <str> , <str> ] iter_save_v , niter_v , image_v , out_v , nsub_v = { } , { } , { } , { } , { } for a in algs :      ( iter_save_v [ a ] , niter_v [ a ] , image_v [ a ] , out_v [ a ] , nsub_v [ a ] ) = np . load ( <str> . format ( folder_npy , a ) )  epochs_save = { a : np . array ( iter_save_v [ a ] ) / np . float ( nsub_v [ a ] ) for a in algs } out_resorted = { } for a in algs :      print ( <str> + a ) out_resorted [ a ] = { } K = len ( iter_save_v [ a ] ) for meas in out_v [ a ] [ 0 ] . keys ( ) :          print ( <str> + meas ) out_resorted [ a ] [ meas ] = np . nan * np . ones ( K ) for k in range ( K ) :              out_resorted [ a ] [ meas ] [ k ] = out_v [ a ] [ k ] [ meas ]   meas = <str> print ( <str> + meas ) out_resorted [ a ] [ meas ] = np . nan * np . ones ( K ) for k in range ( K ) :          out_resorted [ a ] [ meas ] [ k ] = ( ( out_v [ a ] [ k ] [ <str> ] - obj_opt ) / ( out_v [ a ] [ 0 ] [ <str> ] - obj_opt ) )   for a in algs :      for meas in out_resorted [ a ] . keys ( ) :          for k in range ( K ) :              if out_resorted [ a ] [ meas ] [ k ] <= 0 :                  out_resorted [ a ] [ meas ] [ k ] = np . nan     fig = plt . figure ( ) markers = plt . Line2D . filled_markers all_plots = out_resorted [ algs [ 0 ] ] . keys ( ) logy_plot = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] for plotx in [ <str> , <str> ] :      for meas in all_plots :          print ( <str> + plotx + <str> + meas + <str> ) fig = plt . figure ( 1 ) plt . clf ( ) if plotx == <str> :              if meas in logy_plot :                  for a in algs :                      x = epochs_save [ a ] y = out_resorted [ a ] [ meas ] plt . semilogy ( x , y , linewidth = 3 , label = a )   else :                  for j , a in enumerate ( algs ) :                      x = epochs_save [ a ] y = out_resorted [ a ] [ meas ] plt . plot ( x , y , linewidth = 3 , marker = markers [ j ] , markersize = 7 , markevery = .1 , label = a )    elif plotx == <str> :              if meas in logy_plot :                  for a in algs :                      x = epochs_save [ a ] [ 1 : ] y = out_resorted [ a ] [ meas ] [ 1 : ] plt . loglog ( x , y , linewidth = 3 , label = a )   else :                  for j , a in enumerate ( algs ) :                      x = epochs_save [ a ] [ 1 : ] y = out_resorted [ a ] [ meas ] [ 1 : ] plt . semilogx ( x , y , linewidth = 3 , marker = markers [ j ] , markersize = 7 , markevery = .1 , label = a )    plt . title ( <str> . format ( meas ) ) h = plt . gca ( ) h . set_xlabel ( <str> ) plt . legend ( loc = <str> ) fig . savefig ( <str> . format ( folder_today , plotx , meas ) , bbox_inches = <str> )   lwidth = 2 lwidth_help = 2 lstyle = <str> lstyle_help = <str> bmap = brewer2mpl . get_map ( <str> , <str> , 5 ) colors = bmap . mpl_colors matplotlib . rc ( <str> , usetex = True ) matplotlib . rcParams [ <str> ] = [ <str> ] fsize = 15 font = { <str> : <str> , <str> : fsize } matplotlib . rc ( <str> , ** font ) matplotlib . rc ( <str> , labelsize = fsize ) matplotlib . rc ( <str> , labelsize = fsize ) matplotlib . rc ( <str> , labelsize = fsize ) matplotlib . rc ( <str> , fontsize = fsize ) marker = ( <str> , <str> , <str> , <str> , <str> ) mevery = [ ( i / 30. , .1 ) for i in range ( 20 ) ] msize = 9 algs = [ <str> , <str> , <str> , <str> , <str> ] label = [ <str> , <str> , <str> , <str> , <str> ] fig = [ ] fig . append ( plt . figure ( 1 ) ) plt . clf ( ) xlim = [ 1 , 300 ] ylim = [ 2e-1 , 1e+3 ] meas = <str> alg_i = [ 0 , 1 , 3 ] for j in alg_i :      a = algs [ j ] x = epochs_save [ a ] y = out_resorted [ a ] [ meas ] i = ( np . less_equal ( x , xlim [ 1 ] ) & np . greater_equal ( x , xlim [ 0 ] ) & np . less_equal ( y , ylim [ 1 ] ) & np . greater_equal ( y , ylim [ 0 ] ) ) plt . loglog ( x [ i ] , y [ i ] , color = colors [ j ] , linestyle = lstyle , linewidth = lwidth , marker = marker [ j ] , markersize = msize , markevery = mevery [ j ] , label = label [ j ] )  y = 5e+4 / np . array ( iter_save_v [ alg ] ) ** 2 plt . loglog ( x [ i ] , y [ i ] , color = <str> , linestyle = lstyle_help , linewidth = lwidth_help , label = <str> ) plt . gca ( ) . set_xlabel ( <str> ) plt . gca ( ) . set_ylabel ( <str> ) plt . gca ( ) . yaxis . set_ticks ( np . logspace ( 0 , 2 , 3 ) ) plt . ylim ( ( 5e-1 , 1e+3 ) ) plt . legend ( ncol = 1 , frameon = False ) fig . append ( plt . figure ( 2 ) ) plt . clf ( ) ylim = [ 1e-5 , 100 ] meas = <str> alg_i = [ 0 , 1 , 2 , 3 , 4 ] for j in alg_i :      a = algs [ j ] x = epochs_save [ a ] y = out_resorted [ a ] [ meas ] i = ( np . less_equal ( x , xlim [ 1 ] ) & np . greater_equal ( x , xlim [ 0 ] ) & np . less_equal ( y , ylim [ 1 ] ) & np . greater_equal ( y , ylim [ 0 ] ) ) plt . loglog ( x [ i ] , y [ i ] , color = colors [ j ] , linestyle = lstyle , linewidth = lwidth , marker = marker [ j ] , markersize = msize , markevery = mevery [ j ] , label = label [ j ] )  plt . gca ( ) . set_xlabel ( <str> ) plt . gca ( ) . set_ylabel ( <str> ) plt . gca ( ) . yaxis . set_ticks ( np . logspace ( - 5 , - 1 , 3 ) ) plt . legend ( frameon = False ) for i , fi in enumerate ( fig ) :      fi . savefig ( <str> . format ( folder_today , i ) , bbox_inches = <str> )   