from __future__ import division from __future__ import print_function from builtins import str from builtins import range import astropy . time as at import time as ttime import scipy . ndimage as nd import numpy as np import datetime try :      import ephem  except ImportError :      print ( <str> )  import astropy . coordinates as coords import copy try :      from pynfft . nfft import NFFT  except ImportError :      print ( <str> )  from ehtim . const_def import * from ehtim . observing . obs_helpers import * def make_uvpoints ( array , ra , dec , rf , bw , tint , tadv , tstart , tstop , polrep = <str> , mjd = MJD_DEFAULT , tau = TAUDEF , elevmin = ELEV_LOW , elevmax = ELEV_HIGH , timetype = <str> , fix_theta_GMST = False ) :      if polrep == <str> :          poltype = DTPOL_STOKES  elif polrep == <str> :          poltype = DTPOL_CIRC  else :          raise Exception ( <str> )  tstep = tadv / 3600.0 if tstop < tstart :          tstop = tstop + 24.0 ;  times = np . arange ( tstart , tstop , tstep ) if timetype not in [ <str> , <str> ] :          print ( <str> ) timetype = <str>  outlist = [ ] blpairs = [ ] for i1 in range ( len ( array . tarr ) ) :          for i2 in range ( len ( array . tarr ) ) :              if ( i1 != i2 and i1 < i2 and not ( ( i2 , i1 ) in blpairs ) ) :                  blpairs . append ( ( i1 , i2 ) ) site1 = array . tarr [ i1 ] [ <str> ] site2 = array . tarr [ i2 ] [ <str> ] coord1 = ( ( array . tarr [ i1 ] [ <str> ] , array . tarr [ i1 ] [ <str> ] , array . tarr [ i1 ] [ <str> ] ) ) coord2 = ( ( array . tarr [ i2 ] [ <str> ] , array . tarr [ i2 ] [ <str> ] , array . tarr [ i2 ] [ <str> ] ) ) if type ( tau ) == dict :                      try :                          tau1 = tau [ i1 ] tau2 = tau [ i2 ]  except KeyError :                          tau1 = tau2 = TAUDEF   else :                      tau1 = tau2 = tau  if coord1 == ( 0. , 0. , 0. ) : tau1 = 0. if coord2 == ( 0. , 0. , 0. ) : tau2 = 0. if np . any ( array . tarr [ <str> ] <= 0 ) or np . any ( array . tarr [ <str> ] <= 0 ) :                      print ( <str> )  sig_rr = blnoise ( array . tarr [ i1 ] [ <str> ] , array . tarr [ i2 ] [ <str> ] , tint , bw ) sig_ll = blnoise ( array . tarr [ i1 ] [ <str> ] , array . tarr [ i2 ] [ <str> ] , tint , bw ) sig_rl = blnoise ( array . tarr [ i1 ] [ <str> ] , array . tarr [ i2 ] [ <str> ] , tint , bw ) sig_lr = blnoise ( array . tarr [ i1 ] [ <str> ] , array . tarr [ i2 ] [ <str> ] , tint , bw ) if polrep == <str> :                      sig_iv = 0.5 * np . sqrt ( sig_rr ** 2 + sig_ll ** 2 ) sig_qu = 0.5 * np . sqrt ( sig_rl ** 2 + sig_lr ** 2 ) sig1 = sig_iv sig2 = sig_qu sig3 = sig_qu sig4 = sig_iv  elif polrep == <str> :                      sig1 = sig_rr sig2 = sig_ll sig3 = sig_rl sig4 = sig_lr  ( timesout , uout , vout ) = compute_uv_coordinates ( array , site1 , site2 , times , mjd , ra , dec , rf , timetype = timetype , elevmin = elevmin , elevmax = elevmax , fix_theta_GMST = fix_theta_GMST ) for k in range ( len ( timesout ) ) :                      outlist . append ( np . array ( ( timesout [ k ] , tint , site1 , site2 , tau1 , tau2 , uout [ k ] , vout [ k ] , 0.0 , 0.0 , 0.0 , 0.0 , sig1 , sig2 , sig3 , sig4 ) , dtype = poltype ) )     obsarr = np . array ( outlist ) if not len ( obsarr ) :          raise Exception ( <str> )  return obsarr  def sample_vis ( im_org , uv , sgrscat = False , polrep_obs = <str> , ttype = <str> , cache = False , fft_pad_factor = 2 , zero_empty_pol = True ) :      from ehtim . obsdata import Obsdata if polrep_obs == <str> :          im = im_org . switch_polrep ( <str> , <str> ) pollist = [ <str> , <str> , <str> , <str> ]  elif polrep_obs == <str> :          im = im_org . switch_polrep ( <str> , <str> ) pollist = [ <str> , <str> , <str> , <str> ]  else :          raise Exception ( <str> )  uv = np . array ( uv ) if uv . shape [ 1 ] != 2 :          raise Exception ( <str> )  if im . pa != 0.0 :          c = np . cos ( im . pa ) s = np . sin ( im . pa ) u = uv [ : , 0 ] v = uv [ : , 1 ] uv = np . column_stack ( [ c * u - s * v , s * u + c * v ] )  obsdata = [ ] if ttype == <str> :          npad = fft_pad_factor * np . max ( ( im . xdim , im . ydim ) ) npad = power_of_two ( npad ) padvalx1 = padvalx2 = int ( np . floor ( ( npad - im . xdim ) / 2.0 ) ) if im . xdim % 2 :              padvalx2 += 1  padvaly1 = padvaly2 = int ( np . floor ( ( npad - im . ydim ) / 2.0 ) ) if im . ydim % 2 :              padvaly2 += 1  imarr = im . imvec . reshape ( im . ydim , im . xdim ) imarr = np . pad ( imarr , ( ( padvalx1 , padvalx2 ) , ( padvaly1 , padvaly2 ) ) , <str> , constant_values = 0.0 ) npad = imarr . shape [ 0 ] if imarr . shape [ 0 ] != imarr . shape [ 1 ] :              raise Exception ( <str> )  du = 1.0 / ( npad * im . psize ) uv2 = np . hstack ( ( uv [ : , 1 ] . reshape ( - 1 , 1 ) , uv [ : , 0 ] . reshape ( - 1 , 1 ) ) ) uv2 = ( uv2 / du + 0.5 * npad ) . T phase = np . exp ( - 1j * np . pi * im . psize * ( ( 1 + im . xdim % 2 ) * uv [ : , 0 ] + ( 1 + im . ydim % 2 ) * uv [ : , 1 ] ) ) pulsefac = np . fromiter ( ( im . pulse ( 2 * np . pi * uvpt [ 0 ] , 2 * np . pi * uvpt [ 1 ] , im . psize , dom = <str> ) for uvpt in uv ) , <str> ) for i in range ( 4 ) :              pol = pollist [ i ] imvec = im . _imdict [ pol ] if imvec is None or len ( imvec ) == 0 :                  if zero_empty_pol :                      obsdata . append ( np . zeros ( len ( uv ) ) )  else :                      obsdata . append ( None )   else :                  if pol in im_org . cached_fft :                      vis_im = im_org . cached_fft [ pol ]  else :                      imarr = imvec . reshape ( im . ydim , im . xdim ) imarr = np . pad ( imarr , ( ( padvalx1 , padvalx2 ) , ( padvaly1 , padvaly2 ) ) , <str> , constant_values = 0.0 ) vis_im = np . fft . fftshift ( np . fft . fft2 ( np . fft . ifftshift ( imarr ) ) ) if cache == <str> :                          im_org . cached_fft [ pol ] = vis_im   visre = nd . map_coordinates ( np . real ( vis_im ) , uv2 ) visim = nd . map_coordinates ( np . imag ( vis_im ) , uv2 ) vis = visre + 1j * visim vis = vis * phase * pulsefac obsdata . append ( vis )    elif ttype == <str> :          uvdim = len ( uv ) if ( im . xdim % 2 or im . ydim % 2 ) :              raise Exception ( <str> )  npad = fft_pad_factor * np . max ( ( im . xdim , im . ydim ) ) nker = np . floor ( np . min ( ( im . xdim , im . ydim ) ) / 5 ) if ( nker > 50 ) :              nker = 50  elif ( im . xdim < 50 or im . ydim < 50 ) :              nker = np . min ( ( im . xdim , im . ydim ) ) / 2  plan = NFFT ( [ im . xdim , im . ydim ] , uvdim , m = nker , n = [ npad , npad ] ) uvlist = uv * im . psize plan . x = uvlist plan . precompute ( ) phase = np . exp ( - 1j * np . pi * ( uvlist [ : , 0 ] + uvlist [ : , 1 ] ) ) pulsefac = np . fromiter ( ( im . pulse ( 2 * np . pi * uvlist [ i , 0 ] , 2 * np . pi * uvlist [ i , 1 ] , 1. , dom = <str> ) for i in range ( uvdim ) ) , <str> ) for i in range ( 4 ) :              pol = pollist [ i ] imvec = im . _imdict [ pol ] if imvec is None or len ( imvec ) == 0 :                  if zero_empty_pol :                      obsdata . append ( np . zeros ( len ( uv ) ) )  else :                      obsdata . append ( None )   else :                  plan . f_hat = imvec . copy ( ) . reshape ( ( im . ydim , im . xdim ) ) . T plan . trafo ( ) vis = plan . f . copy ( ) * phase * pulsefac obsdata . append ( vis )    else :          mat = ftmatrix ( im . psize , im . xdim , im . ydim , uv , pulse = im . pulse ) for i in range ( 4 ) :              pol = pollist [ i ] imvec = im . _imdict [ pol ] if imvec is None or len ( imvec ) == 0 :                  if zero_empty_pol :                      obsdata . append ( np . zeros ( len ( uv ) ) )  else :                      obsdata . append ( None )   else :                  vis = np . dot ( mat , imvec ) obsdata . append ( vis )    if sgrscat :          print ( <str> ) ker = np . fromiter ( ( sgra_kernel_uv ( im . rf , uv [ i , 0 ] , uv [ i , 1 ] ) for i in range ( len ( vis ) ) ) , <str> ) for data in obsdata :              if data is None : continue data *= ker   return obsdata  def make_jones ( obs , opacitycal = True , ampcal = True , phasecal = True , dcal = True , frcal = True , rlgaincal = True , stabilize_scan_phase = False , stabilize_scan_amp = False , neggains = False , taup = GAINPDEF , gainp = GAINPDEF , gain_offset = GAINPDEF , dterm_offset = DTERMPDEF , caltable_path = None , seed = False ) :      obs_tmp = obs . copy ( ) tlist = obs_tmp . tlist ( ) tarr = obs_tmp . tarr ra = obs_tmp . ra dec = obs_tmp . dec sourcevec = np . array ( [ np . cos ( dec * DEGREE ) , 0 , np . sin ( dec * DEGREE ) ] ) tproc = str ( ttime . time ( ) ) nsites = len ( obs_tmp . tarr [ <str> ] ) taudict = { site : np . array ( [ ] ) for site in obs_tmp . tarr [ <str> ] } times = np . array ( [ ] ) for scan in tlist :          time = scan [ <str> ] [ 0 ] times = np . append ( times , time ) sites_in = np . array ( [ ] ) for bl in scan :              if len ( sites_in ) >= nsites : break if ( not len ( sites_in ) ) or ( not bl [ <str> ] in sites_in ) :                  taudict [ bl [ <str> ] ] = np . append ( taudict [ bl [ <str> ] ] , bl [ <str> ] ) sites_in = np . append ( sites_in , bl [ <str> ] )  if ( not len ( sites_in ) ) or ( not bl [ <str> ] in sites_in ) :                  taudict [ bl [ <str> ] ] = np . append ( taudict [ bl [ <str> ] ] , bl [ <str> ] ) sites_in = np . append ( sites_in , bl [ <str> ] )   if len ( sites_in ) < nsites :              for site in obs_tmp . tarr [ <str> ] :                  if site not in sites_in :                      taudict [ site ] = np . append ( taudict [ site ] , 0.0 )     times_stable_phase = times . copy ( ) times_stable_amp = times . copy ( ) times_stable = times . copy ( ) if stabilize_scan_phase == True or stabilize_scan_amp == True :          scans = obs_tmp . scans if np . all ( scans ) == None or len ( scans ) == 0 :              obs_scans = obs . copy ( ) obs_scans . add_scans ( ) scans = obs_scans . scans  for j in range ( len ( times_stable ) ) :              for scan in scans :                  if scan [ 0 ] <= times_stable [ j ] and scan [ 1 ] >= times_stable [ j ] :                      times_stable [ j ] = scan [ 0 ] break     if stabilize_scan_phase == True : times_stable_phase = times_stable . copy ( ) if stabilize_scan_amp == True : times_stable_amp = times_stable . copy ( ) if obs . timetype == <str> :          times_sid = times  else :          times_sid = utc_to_gmst ( times , obs . mjd )  if seed == False :          seed = str ( ttime . time ( ) )  out = { } datatables = { } for i in range ( len ( tarr ) ) :          site = tarr [ i ] [ <str> ] coords = np . array ( [ tarr [ i ] [ <str> ] , tarr [ i ] [ <str> ] , tarr [ i ] [ <str> ] ] ) latlon = xyz_2_latlong ( coords ) thetas = np . mod ( ( times_sid - ra ) * HOUR , 2 * np . pi ) el_angles = elev ( earthrot ( coords , thetas ) , sourcevec ) hr_angles = hr_angle ( times_sid * HOUR , latlon [ : , 1 ] , ra * HOUR ) par_angles = par_angle ( hr_angles , latlon [ : , 0 ] , dec * DEGREE ) gainR = gainL = np . ones ( len ( times ) ) if not ampcal :              if type ( gain_offset ) == dict :                  goff = gain_offset [ site ]  else :                  goff = gain_offset  if type ( gainp ) == dict :                  gain_mult = gainp [ site ]  else :                  gain_mult = gainp  if rlgaincal :                  gainr_string = <str> gainl_string = <str>  else :                  gainr_string = <str> gainl_string = <str>  gainR_constant = goff * hashrandn ( site , gainr_string , str ( goff ) , seed ) gainL_constant = goff * hashrandn ( site , gainl_string , str ( goff ) , seed ) if neggains :                  gainR_constant = - np . abs ( gainR_constant ) gainL_constant = - np . abs ( gainL_constant )  gainR = np . sqrt ( np . abs ( np . fromiter ( ( ( 1.0 + gainR_constant ) * ( 1.0 + gain_mult * hashrandn ( site , <str> , str ( time ) , str ( gain_mult ) , seed ) ) for time in times_stable_amp ) , float ) ) ) gainL = np . sqrt ( np . abs ( np . fromiter ( ( ( 1.0 + gainL_constant ) * ( 1.0 + gain_mult * hashrandn ( site , <str> , str ( time ) , str ( gain_mult ) , seed ) ) for time in times_stable_amp ) , float ) ) )  if not opacitycal :              taus = np . abs ( np . fromiter ( ( taudict [ site ] [ j ] * ( 1.0 + taup * hashrandn ( site , <str> , times_stable_amp [ j ] , seed ) ) for j in range ( len ( times ) ) ) , float ) ) atten = np . exp ( - taus / ( EP + 2.0 * np . sin ( el_angles ) ) ) gainR = gainR * atten gainL = gainL * atten  if not phasecal :              phase = np . fromiter ( ( 2 * np . pi * hashrand ( site , <str> , time , seed ) for time in times_stable_phase ) , float ) gainR = gainR * np . exp ( 1j * phase ) gainL = gainL * np . exp ( 1j * phase )  dR = dL = 0.0 if not dcal :              if type ( dterm_offset ) == dict :                  doff = dterm_offset [ site ]  else :                  doff = dterm_offset  dR = tarr [ i ] [ <str> ] dL = tarr [ i ] [ <str> ] dR += doff * ( hashrandn ( site , <str> , seed ) + 1j * hashrandn ( site , <str> , seed ) ) dL += doff * ( hashrandn ( site , <str> , seed ) + 1j * hashrandn ( site , <str> , seed ) )  fr_angle = np . zeros ( len ( times ) ) fr_angle_D = np . zeros ( len ( times ) ) if not frcal :              fr_angle = tarr [ i ] [ <str> ] * el_angles + tarr [ i ] [ <str> ] * par_angles + tarr [ i ] [ <str> ] * DEGREE  elif frcal and not dcal :              fr_angle_D = 2.0 * ( tarr [ i ] [ <str> ] * el_angles + tarr [ i ] [ <str> ] * par_angles + tarr [ i ] [ <str> ] * DEGREE )  j_matrices = { times [ j ] : np . array ( [ [ np . exp ( - 1j * fr_angle [ j ] ) * gainR [ j ] , np . exp ( 1j * ( fr_angle [ j ] + fr_angle_D [ j ] ) ) * dR * gainR [ j ] ] , [ np . exp ( - 1j * ( fr_angle [ j ] + fr_angle_D [ j ] ) ) * dL * gainL [ j ] , np . exp ( 1j * fr_angle [ j ] ) * gainL [ j ] ] ] ) for j in range ( len ( times ) ) } out [ site ] = j_matrices if caltable_path :              obs_tmp . tarr [ i ] [ <str> ] = dR obs_tmp . tarr [ i ] [ <str> ] = dL datatable = [ ] for j in range ( len ( times ) ) :                  datatable . append ( np . array ( ( times [ j ] , gainR [ j ] , gainL [ j ] ) , dtype = DTCAL ) )  datatables [ site ] = np . array ( datatable )   if caltable_path and len ( datatables ) > 0 :          caltable = ehtim . caltable . Caltable ( obs_tmp . ra , obs_tmp . dec , obs_tmp . rf , obs_tmp . bw , datatables , obs_tmp . tarr , source = obs_tmp . source , mjd = obs_tmp . mjd , timetype = obs_tmp . timetype ) caltable . save_txt ( obs_tmp , datadir = caltable_path + <str> )  return out  def make_jones_inverse ( obs , opacitycal = True , dcal = True , frcal = True ) :      tlist = obs . tlist ( ) tarr = obs . tarr ra = obs . ra dec = obs . dec sourcevec = np . array ( [ np . cos ( dec * DEGREE ) , 0 , np . sin ( dec * DEGREE ) ] ) nsites = len ( obs . tarr [ <str> ] ) taudict = { site : np . array ( [ ] ) for site in obs . tarr [ <str> ] } times = np . array ( [ ] ) for scan in tlist :          time = scan [ <str> ] [ 0 ] times = np . append ( times , time ) sites_in = np . array ( [ ] ) for bl in scan :              if len ( sites_in ) >= nsites : break if ( not len ( sites_in ) ) or ( not bl [ <str> ] in sites_in ) :                  taudict [ bl [ <str> ] ] = np . append ( taudict [ bl [ <str> ] ] , bl [ <str> ] ) sites_in = np . append ( sites_in , bl [ <str> ] )  if ( not len ( sites_in ) ) or ( not bl [ <str> ] in sites_in ) :                  taudict [ bl [ <str> ] ] = np . append ( taudict [ bl [ <str> ] ] , bl [ <str> ] ) sites_in = np . append ( sites_in , bl [ <str> ] )   if len ( sites_in ) < nsites :              for site in obs . tarr [ <str> ] :                  if site not in sites_in :                      taudict [ site ] = np . append ( taudict [ site ] , 0.0 )     if obs . timetype == <str> :          times_sid = times  else :          times_sid = utc_to_gmst ( times , obs . mjd )  out = { } for i in range ( len ( tarr ) ) :          site = tarr [ i ] [ <str> ] coords = np . array ( [ tarr [ i ] [ <str> ] , tarr [ i ] [ <str> ] , tarr [ i ] [ <str> ] ] ) latlon = xyz_2_latlong ( coords ) thetas = np . mod ( ( times_sid - ra ) * HOUR , 2 * np . pi ) el_angles = elev ( earthrot ( coords , thetas ) , sourcevec ) hr_angles = hr_angle ( times_sid * HOUR , latlon [ : , 1 ] , ra * HOUR ) par_angles = par_angle ( hr_angles , latlon [ : , 0 ] , dec * DEGREE ) gainR = gainL = np . ones ( len ( times ) ) if not opacitycal :              taus = np . abs ( np . array ( taudict [ site ] ) ) atten = np . exp ( - taus / ( EP + 2.0 * np . sin ( el_angles ) ) ) gainR = gainR * atten gainL = gainL * atten  dR = dL = 0.0 if not dcal :              dR = tarr [ i ] [ <str> ] dL = tarr [ i ] [ <str> ]  fr_angle = np . zeros ( len ( times ) ) fr_angle_D = np . zeros ( len ( times ) ) if not frcal :              fr_angle = tarr [ i ] [ <str> ] * el_angles + tarr [ i ] [ <str> ] * par_angles + tarr [ i ] [ <str> ] * DEGREE  elif frcal and not dcal :              fr_angle_D = 2.0 * ( tarr [ i ] [ <str> ] * el_angles + tarr [ i ] [ <str> ] * par_angles + tarr [ i ] [ <str> ] * DEGREE )  pref = 1.0 / ( gainL * gainR * ( 1.0 - dL * dR ) ) j_matrices_inv = { times [ j ] : pref [ j ] * np . array ( [ [ np . exp ( 1j * fr_angle [ j ] ) * gainL [ j ] , - np . exp ( 1j * ( fr_angle [ j ] + fr_angle_D [ j ] ) ) * dR * gainR [ j ] ] , [ - np . exp ( - 1j * ( fr_angle [ j ] + fr_angle_D [ j ] ) ) * dL * gainL [ j ] , np . exp ( - 1j * fr_angle [ j ] ) * gainR [ j ] ] ] ) for j in range ( len ( times ) ) } out [ site ] = j_matrices_inv  return out  def add_jones_and_noise ( obs , add_th_noise = True , opacitycal = True , ampcal = True , phasecal = True , dcal = True , frcal = True , rlgaincal = True , stabilize_scan_phase = False , stabilize_scan_amp = False , neggains = False , taup = GAINPDEF , gainp = GAINPDEF , gain_offset = GAINPDEF , dterm_offset = DTERMPDEF , caltable_path = None , seed = False ) :      print ( <str> ) jm_dict = make_jones ( obs , ampcal = ampcal , opacitycal = opacitycal , phasecal = phasecal , dcal = dcal , frcal = frcal , rlgaincal = rlgaincal , stabilize_scan_phase = stabilize_scan_phase , stabilize_scan_amp = stabilize_scan_amp , neggains = neggains , gainp = gainp , taup = taup , gain_offset = gain_offset , dterm_offset = dterm_offset , caltable_path = caltable_path , seed = seed ) obs_circ = obs . switch_polrep ( <str> ) obsdata = copy . copy ( obs_circ . data ) times = obsdata [ <str> ] t1 = obsdata [ <str> ] t2 = obsdata [ <str> ] tints = obsdata [ <str> ] rr = obsdata [ <str> ] ll = obsdata [ <str> ] rl = obsdata [ <str> ] lr = obsdata [ <str> ] if np . any ( obs . tarr [ <str> ] <= 0 ) or np . any ( obs . tarr [ <str> ] <= 0 ) :          print ( <str> ) sig_rr = obsdata [ <str> ] sig_ll = obsdata [ <str> ] sig_rl = obsdata [ <str> ] sig_lr = obsdata [ <str> ]  else :          sig_rr = np . fromiter ( ( blnoise ( obs . tarr [ obs . tkey [ t1 [ i ] ] ] [ <str> ] , obs . tarr [ obs . tkey [ t2 [ i ] ] ] [ <str> ] , tints [ i ] , obs . bw ) for i in range ( len ( rr ) ) ) , float ) sig_ll = np . fromiter ( ( blnoise ( obs . tarr [ obs . tkey [ t1 [ i ] ] ] [ <str> ] , obs . tarr [ obs . tkey [ t2 [ i ] ] ] [ <str> ] , tints [ i ] , obs . bw ) for i in range ( len ( ll ) ) ) , float ) sig_rl = np . fromiter ( ( blnoise ( obs . tarr [ obs . tkey [ t1 [ i ] ] ] [ <str> ] , obs . tarr [ obs . tkey [ t2 [ i ] ] ] [ <str> ] , tints [ i ] , obs . bw ) for i in range ( len ( rl ) ) ) , float ) sig_lr = np . fromiter ( ( blnoise ( obs . tarr [ obs . tkey [ t1 [ i ] ] ] [ <str> ] , obs . tarr [ obs . tkey [ t2 [ i ] ] ] [ <str> ] , tints [ i ] , obs . bw ) for i in range ( len ( lr ) ) ) , float )  if not opacitycal :          print ( <str> )  if not ampcal :          print ( <str> )  if not phasecal :          print ( <str> )  if not dcal :          print ( <str> )  if not frcal :          print ( <str> )  if add_th_noise :          print ( <str> )  for i in range ( len ( times ) ) :          corr_matrix = np . array ( [ [ rr [ i ] , rl [ i ] ] , [ lr [ i ] , ll [ i ] ] ] ) j1 = jm_dict [ t1 [ i ] ] [ times [ i ] ] j2 = jm_dict [ t2 [ i ] ] [ times [ i ] ] corr_matrix_corrupt = np . dot ( j1 , np . dot ( corr_matrix , np . conjugate ( j2 . T ) ) ) if add_th_noise :              noise_matrix = np . array ( [ [ cerror ( sig_rr [ i ] ) , cerror ( sig_rl [ i ] ) ] , [ cerror ( sig_lr [ i ] ) , cerror ( sig_ll [ i ] ) ] ] ) corr_matrix_corrupt += noise_matrix  obsdata [ <str> ] [ i ] = corr_matrix_corrupt [ 0 ] [ 0 ] obsdata [ <str> ] [ i ] = corr_matrix_corrupt [ 1 ] [ 1 ] obsdata [ <str> ] [ i ] = corr_matrix_corrupt [ 0 ] [ 1 ] obsdata [ <str> ] [ i ] = corr_matrix_corrupt [ 1 ] [ 0 ] obsdata [ <str> ] [ i ] = sig_rr [ i ] obsdata [ <str> ] [ i ] = sig_ll [ i ] obsdata [ <str> ] [ i ] = sig_rl [ i ] obsdata [ <str> ] [ i ] = sig_lr [ i ]  obs_circ . data = obsdata obs_back = obs_circ . switch_polrep ( obs . polrep ) obsdata_back = obs_back . data return obsdata_back  def apply_jones_inverse ( obs , opacitycal = True , dcal = True , frcal = True , verbose = True ) :      if verbose : print ( <str> ) jm_dict = make_jones_inverse ( obs , opacitycal = opacitycal , dcal = dcal , frcal = frcal ) obs_circ = obs . switch_polrep ( <str> ) ampcal = obs . ampcal phasecal = obs . phasecal obsdata = copy . deepcopy ( obs_circ . data ) times = obsdata [ <str> ] t1 = obsdata [ <str> ] t2 = obsdata [ <str> ] tints = obsdata [ <str> ] rr = obsdata [ <str> ] ll = obsdata [ <str> ] rl = obsdata [ <str> ] lr = obsdata [ <str> ] if np . any ( obs . tarr [ <str> ] <= 0 ) or np . any ( obs . tarr [ <str> ] <= 0 ) :          if verbose : print ( <str> ) if verbose : print ( <str> ) sig_rr = obsdata [ <str> ] sig_ll = obsdata [ <str> ] sig_rl = obsdata [ <str> ] sig_lr = obsdata [ <str> ]  else :          sig_rr = np . fromiter ( ( blnoise ( obs . tarr [ obs . tkey [ t1 [ i ] ] ] [ <str> ] , obs . tarr [ obs . tkey [ t2 [ i ] ] ] [ <str> ] , tints [ i ] , obs . bw ) for i in range ( len ( rr ) ) ) , float ) sig_ll = np . fromiter ( ( blnoise ( obs . tarr [ obs . tkey [ t1 [ i ] ] ] [ <str> ] , obs . tarr [ obs . tkey [ t2 [ i ] ] ] [ <str> ] , tints [ i ] , obs . bw ) for i in range ( len ( ll ) ) ) , float ) sig_rl = np . fromiter ( ( blnoise ( obs . tarr [ obs . tkey [ t1 [ i ] ] ] [ <str> ] , obs . tarr [ obs . tkey [ t2 [ i ] ] ] [ <str> ] , tints [ i ] , obs . bw ) for i in range ( len ( rl ) ) ) , float ) sig_lr = np . fromiter ( ( blnoise ( obs . tarr [ obs . tkey [ t1 [ i ] ] ] [ <str> ] , obs . tarr [ obs . tkey [ t2 [ i ] ] ] [ <str> ] , tints [ i ] , obs . bw ) for i in range ( len ( lr ) ) ) , float )  if not opacitycal :          if verbose : print ( <str> ) opacitycal = True  if not dcal :          if verbose : print ( <str> ) dcal = True  if not frcal :          if verbose : print ( <str> ) frcal = True  for i in range ( len ( times ) ) :          inv_j1 = jm_dict [ t1 [ i ] ] [ times [ i ] ] inv_j2 = jm_dict [ t2 [ i ] ] [ times [ i ] ] corr_matrix = np . array ( [ [ rr [ i ] , rl [ i ] ] , [ lr [ i ] , ll [ i ] ] ] ) sig_rr_matrix = np . array ( [ [ sig_rr [ i ] , 0.0 ] , [ 0.0 , 0.0 ] ] ) sig_ll_matrix = np . array ( [ [ 0.0 , 0.0 ] , [ 0.0 , sig_ll [ i ] ] ] ) sig_rl_matrix = np . array ( [ [ 0.0 , sig_rl [ i ] ] , [ 0.0 , 0.0 ] ] ) sig_lr_matrix = np . array ( [ [ 0.0 , 0.0 ] , [ sig_lr [ i ] , 0.0 ] ] ) corr_matrix_new = np . dot ( inv_j1 , np . dot ( corr_matrix , np . conjugate ( inv_j2 . T ) ) ) sig_rr_matrix_new = np . dot ( inv_j1 , np . dot ( sig_rr_matrix , np . conjugate ( inv_j2 . T ) ) ) sig_ll_matrix_new = np . dot ( inv_j1 , np . dot ( sig_ll_matrix , np . conjugate ( inv_j2 . T ) ) ) sig_rl_matrix_new = np . dot ( inv_j1 , np . dot ( sig_rl_matrix , np . conjugate ( inv_j2 . T ) ) ) sig_lr_matrix_new = np . dot ( inv_j1 , np . dot ( sig_lr_matrix , np . conjugate ( inv_j2 . T ) ) ) sig_matrix_new = np . sqrt ( np . abs ( sig_rr_matrix_new ) ** 2 + np . abs ( sig_ll_matrix_new ) ** 2 + np . abs ( sig_rl_matrix_new ) ** 2 + np . abs ( sig_lr_matrix_new ) ** 2 ) obsdata [ <str> ] [ i ] = corr_matrix_new [ 0 ] [ 0 ] obsdata [ <str> ] [ i ] = corr_matrix_new [ 1 ] [ 1 ] obsdata [ <str> ] [ i ] = corr_matrix_new [ 0 ] [ 1 ] obsdata [ <str> ] [ i ] = corr_matrix_new [ 1 ] [ 0 ] obsdata [ <str> ] [ i ] = sig_matrix_new [ 0 ] [ 0 ] obsdata [ <str> ] [ i ] = sig_matrix_new [ 1 ] [ 1 ] obsdata [ <str> ] [ i ] = sig_matrix_new [ 0 ] [ 1 ] obsdata [ <str> ] [ i ] = sig_matrix_new [ 1 ] [ 0 ]  obs_circ . data = obsdata obs_back = obs_circ . switch_polrep ( obs . polrep ) obsdata_back = obs_back . data return obsdata_back  def add_noise ( obs , add_th_noise = True , opacitycal = True , ampcal = True , phasecal = True , stabilize_scan_amp = False , stabilize_scan_phase = False , taup = GAINPDEF , gainp = GAINPDEF , gain_offset = GAINPDEF , seed = False ) :      print ( <str> ) if not opacitycal :          print ( <str> )  if not ampcal :          print ( <str> )  if not phasecal :          print ( <str> )  if add_th_noise :          print ( <str> )  obsdata = copy . deepcopy ( obs . data ) sites = recarr_to_ndarr ( obsdata [ [ <str> , <str> ] ] , <str> ) uv = recarr_to_ndarr ( obsdata [ [ <str> , <str> ] ] , <str> ) taus = np . abs ( recarr_to_ndarr ( obsdata [ [ <str> , <str> ] ] , <str> ) ) elevs = recarr_to_ndarr ( obs . unpack ( [ <str> , <str> ] , ang_unit = <str> ) , <str> ) times = obsdata [ <str> ] tint = obsdata [ <str> ] vis1 = obsdata [ obs . poldict [ <str> ] ] vis2 = obsdata [ obs . poldict [ <str> ] ] vis3 = obsdata [ obs . poldict [ <str> ] ] vis4 = obsdata [ obs . poldict [ <str> ] ] times_stable_phase = times . copy ( ) times_stable_amp = times . copy ( ) times_stable = times . copy ( ) if stabilize_scan_phase == True or stabilize_scan_amp == True :          scans = obs . scans if np . all ( scans ) == None or len ( scans ) == 0 :              print ( <str> ) obs_scans = obs . copy ( ) obs_scans . add_scans ( ) scans = obs_scans . scans  for j in range ( len ( times_stable ) ) :              for scan in scans :                  if scan [ 0 ] <= times_stable [ j ] and scan [ 1 ] >= times_stable [ j ] :                      times_stable [ j ] = scan [ 0 ] break     if stabilize_scan_phase == True : times_stable_phase = times_stable . copy ( ) if stabilize_scan_amp == True : times_stable_amp = times_stable . copy ( ) bw = obs . bw if np . any ( obs . tarr [ <str> ] <= 0 ) :          print ( <str> ) sigma_perf1 = obsdata [ obs . poldict [ <str> ] ] sigma_perf2 = obsdata [ obs . poldict [ <str> ] ] sigma_perf3 = obsdata [ obs . poldict [ <str> ] ] sigma_perf4 = obsdata [ obs . poldict [ <str> ] ]  else :          sig_rr = np . fromiter ( ( blnoise ( obs . tarr [ obs . tkey [ sites [ i ] [ 0 ] ] ] [ <str> ] , obs . tarr [ obs . tkey [ sites [ i ] [ 1 ] ] ] [ <str> ] , tint [ i ] , bw ) for i in range ( len ( tint ) ) ) , float ) sig_ll = np . fromiter ( ( blnoise ( obs . tarr [ obs . tkey [ sites [ i ] [ 0 ] ] ] [ <str> ] , obs . tarr [ obs . tkey [ sites [ i ] [ 1 ] ] ] [ <str> ] , tint [ i ] , bw ) for i in range ( len ( tint ) ) ) , float ) sig_rl = np . fromiter ( ( blnoise ( obs . tarr [ obs . tkey [ sites [ i ] [ 0 ] ] ] [ <str> ] , obs . tarr [ obs . tkey [ sites [ i ] [ 1 ] ] ] [ <str> ] , tint [ i ] , bw ) for i in range ( len ( tint ) ) ) , float ) sig_lr = np . fromiter ( ( blnoise ( obs . tarr [ obs . tkey [ sites [ i ] [ 0 ] ] ] [ <str> ] , obs . tarr [ obs . tkey [ sites [ i ] [ 1 ] ] ] [ <str> ] , tint [ i ] , bw ) for i in range ( len ( tint ) ) ) , float ) if obs . polrep == <str> :              sig_iv = 0.5 * np . sqrt ( sig_rr ** 2 + sig_ll ** 2 ) sig_qu = 0.5 * np . sqrt ( sig_rl ** 2 + sig_lr ** 2 ) sigma_perf1 = sig_iv sigma_perf2 = sig_qu sigma_perf3 = sig_qu sigma_perf4 = sig_iv  elif obs . polrep == <str> :              sigma_perf1 = sig_rr sigma_perf2 = sig_ll sigma_perf3 = sig_rl sigma_perf4 = sig_lr   if seed == False :          seed = str ( ttime . time ( ) )  if not ampcal :          if type ( gain_offset ) == dict :              goff1 = np . fromiter ( ( gain_offset [ sites [ i , 0 ] ] for i in range ( len ( times ) ) ) , float ) goff2 = np . fromiter ( ( gain_offset [ sites [ i , 1 ] ] for i in range ( len ( times ) ) ) , float )  else :              goff1 = np . fromiter ( ( gain_offset for i in range ( len ( times ) ) ) , float ) goff2 = np . fromiter ( ( gain_offset for i in range ( len ( times ) ) ) , float )  if type ( gainp ) is dict :              gain_mult_1 = np . fromiter ( ( gainp [ sites [ i , 0 ] ] for i in range ( len ( times ) ) ) , float ) gain_mult_2 = np . fromiter ( ( gainp [ sites [ i , 1 ] ] for i in range ( len ( times ) ) ) , float )  else :              gain_mult_1 = np . fromiter ( ( gainp for i in range ( len ( times ) ) ) , float ) gain_mult_2 = np . fromiter ( ( gainp for i in range ( len ( times ) ) ) , float )  gain1 = np . abs ( np . fromiter ( ( ( 1.0 + goff1 [ i ] * np . abs ( hashrandn ( sites [ i , 0 ] , <str> , seed ) ) ) * ( 1.0 + gain_mult_1 [ i ] * hashrandn ( sites [ i , 0 ] , <str> , times_stable_amp [ i ] , seed ) ) for i in range ( len ( times ) ) ) , float ) ) gain2 = np . abs ( np . fromiter ( ( ( 1.0 + goff2 [ i ] * np . abs ( hashrandn ( sites [ i , 1 ] , <str> , seed ) ) ) * ( 1.0 + gain_mult_2 [ i ] * hashrandn ( sites [ i , 1 ] , <str> , times_stable_amp [ i ] , seed ) ) for i in range ( len ( times ) ) ) , float ) ) gain_true = np . sqrt ( gain1 * gain2 )  else :          gain_true = 1  if not opacitycal :          tau_est = np . sqrt ( np . exp ( taus [ : , 0 ] / ( EP + np . sin ( elevs [ : , 0 ] * DEGREE ) ) + taus [ : , 1 ] / ( EP + np . sin ( elevs [ : , 1 ] * DEGREE ) ) ) ) tau1 = np . abs ( np . fromiter ( ( taus [ i , 0 ] * ( 1.0 + taup * hashrandn ( sites [ i , 0 ] , <str> , times_stable_amp [ i ] , seed ) ) for i in range ( len ( times ) ) ) , float ) ) tau2 = np . abs ( np . fromiter ( ( taus [ i , 1 ] * ( 1.0 + taup * hashrandn ( sites [ i , 1 ] , <str> , times_stable_amp [ i ] , seed ) ) for i in range ( len ( times ) ) ) , float ) ) tau_true = np . sqrt ( np . exp ( tau1 / ( EP + np . sin ( elevs [ : , 0 ] * DEGREE ) ) + tau2 / ( EP + np . sin ( elevs [ : , 1 ] * DEGREE ) ) ) )  else :          tau_true = tau_est = 1  sigma_true1 = sigma_perf1 sigma_true2 = sigma_perf2 sigma_true3 = sigma_perf3 sigma_true4 = sigma_perf4 sigma_est1 = sigma_perf1 * gain_true * tau_est sigma_est2 = sigma_perf2 * gain_true * tau_est sigma_est3 = sigma_perf3 * gain_true * tau_est sigma_est4 = sigma_perf4 * gain_true * tau_est if add_th_noise :          vis1 = ( vis1 + cerror ( sigma_true1 ) ) vis2 = ( vis2 + cerror ( sigma_true2 ) ) vis3 = ( vis3 + cerror ( sigma_true3 ) ) vis4 = ( vis4 + cerror ( sigma_true4 ) )  vis1 = vis1 * gain_true * tau_est / tau_true vis2 = vis2 * gain_true * tau_est / tau_true vis3 = vis3 * gain_true * tau_est / tau_true vis4 = vis4 * gain_true * tau_est / tau_true if not phasecal :          phase1 = np . fromiter ( ( 2 * np . pi * hashrand ( sites [ i , 0 ] , <str> , times_stable_phase [ i ] , seed ) for i in range ( len ( times ) ) ) , float ) phase2 = np . fromiter ( ( 2 * np . pi * hashrand ( sites [ i , 1 ] , <str> , times_stable_phase [ i ] , seed ) for i in range ( len ( times ) ) ) , float ) vis1 *= np . exp ( 1j * ( phase2 - phase1 ) ) vis2 *= np . exp ( 1j * ( phase2 - phase1 ) ) vis3 *= np . exp ( 1j * ( phase2 - phase1 ) ) vis4 *= np . exp ( 1j * ( phase2 - phase1 ) )  obsdata [ obs . poldict [ <str> ] ] = vis1 obsdata [ obs . poldict [ <str> ] ] = vis2 obsdata [ obs . poldict [ <str> ] ] = vis3 obsdata [ obs . poldict [ <str> ] ] = vis4 obsdata [ obs . poldict [ <str> ] ] = sigma_est1 obsdata [ obs . poldict [ <str> ] ] = sigma_est2 obsdata [ obs . poldict [ <str> ] ] = sigma_est3 obsdata [ obs . poldict [ <str> ] ] = sigma_est4 return obsdata   