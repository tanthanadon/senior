from __future__ import division from __future__ import print_function from builtins import str from builtins import range import numpy as np import string import astropy . io . fits as fits import astropy . time import datetime import os import copy import sys import time as ttime import ehtim . obsdata import ehtim . image import ehtim . array import ehtim . movie import ehtim . vex import ehtim . observing import ehtim . io . oifits from astropy . time import Time from ehtim . const_def import * from ehtim . observing . obs_helpers import * import warnings warnings . filterwarnings ( <str> , message = <str> ) warnings . filterwarnings ( <str> , message = <str> ) def load_vex ( fname ) :      print ( <str> , fname ) return ehtim . vex . Vex ( fname )  def load_im_txt ( filename , pulse = PULSE_DEFAULT , polrep = <str> , pol_prim = <str> , zero_pol = True ) :      print ( <str> , filename ) file = open ( filename ) src = <str> . join ( file . readline ( ) . split ( ) [ 2 : ] ) ra = file . readline ( ) . split ( ) ra = float ( ra [ 2 ] ) + float ( ra [ 4 ] ) / 60.0 + float ( ra [ 6 ] ) / 3600.0 dec = file . readline ( ) . split ( ) dec = np . sign ( float ( dec [ 2 ] ) ) * ( abs ( float ( dec [ 2 ] ) ) + float ( dec [ 4 ] ) / 60.0 + float ( dec [ 6 ] ) / 3600.0 ) mjd_float = float ( file . readline ( ) . split ( ) [ 2 ] ) mjd = int ( mjd_float ) time = ( mjd_float - mjd ) * 24 rf = float ( file . readline ( ) . split ( ) [ 2 ] ) * 1e9 xdim = file . readline ( ) . split ( ) xdim_p = int ( xdim [ 2 ] ) psize_x = float ( xdim [ 4 ] ) * RADPERAS / xdim_p ydim = file . readline ( ) . split ( ) ydim_p = int ( ydim [ 2 ] ) psize_y = float ( ydim [ 4 ] ) * RADPERAS / ydim_p file . close ( ) if psize_x != psize_y :          raise Exception ( <str> )  datatable = np . loadtxt ( filename , dtype = float ) image = datatable [ : , 2 ] . reshape ( ydim_p , xdim_p ) outim = ehtim . image . Image ( image , psize_x , ra , dec , rf = rf , source = src , mjd = mjd , time = time , pulse = pulse , polrep = <str> , pol_prim = <str> ) qimage = uimage = vimage = np . zeros ( image . shape ) if datatable . shape [ 1 ] == 6 :          qimage = datatable [ : , 3 ] . reshape ( ydim_p , xdim_p ) uimage = datatable [ : , 4 ] . reshape ( ydim_p , xdim_p ) vimage = datatable [ : , 5 ] . reshape ( ydim_p , xdim_p )  elif datatable . shape [ 1 ] == 5 :          qimage = datatable [ : , 3 ] . reshape ( ydim_p , xdim_p ) uimage = datatable [ : , 4 ] . reshape ( ydim_p , xdim_p )  if np . any ( ( qimage != 0 ) + ( uimage != 0 ) ) and np . any ( ( vimage != 0 ) ) :          outim . add_qu ( qimage , uimage ) outim . add_v ( vimage )  elif np . any ( ( vimage != 0 ) ) :          outim . add_v ( vimage ) if zero_pol :              outim . add_qu ( 0 * vimage , 0 * vimage )   elif np . any ( ( qimage != 0 ) + ( uimage != 0 ) ) :          outim . add_qu ( qimage , uimage ) if zero_pol :              outim . add_v ( 0 * qimage )   else :          if zero_pol :              outim . add_qu ( 0 * image , 0 * image ) outim . add_v ( 0 * image )   if not ( polrep == <str> and pol_prim == <str> ) :          outim = outim . switch_polrep ( polrep_out = polrep , pol_prim_out = pol_prim )  return outim  def load_im_fits ( filename , aipscc = False , pulse = PULSE_DEFAULT , punit = <str> , polrep = <str> , pol_prim = None , zero_pol = True ) :      print ( <str> , filename ) if punit == <str> :          pscl = DEGREE  elif punit == <str> :          pscl = 1.0  elif punit == <str> :          pscl = RADPERUAS  elif punit == <str> :          pscl = RADPERUAS * 1000.0  hdulist = fits . open ( filename ) header = hdulist [ 0 ] . header xdim_p = header [ <str> ] psize_x = np . abs ( header [ <str> ] ) * pscl ydim_p = header [ <str> ] psize_y = np . abs ( header [ <str> ] ) * pscl if <str> in list ( header . keys ( ) ) : ra = header [ <str> ] * 12 / 180. elif <str> in list ( header . keys ( ) ) : ra = header [ <str> ] * 12 / 180. else : ra = 0. if <str> in list ( header . keys ( ) ) : dec = header [ <str> ] elif <str> in list ( header . keys ( ) ) : dec = header [ <str> ] else : dec = 0. if <str> in list ( header . keys ( ) ) : rf = header [ <str> ] elif <str> in list ( header . keys ( ) ) : rf = header [ <str> ] else : rf = 0. if <str> in list ( header . keys ( ) ) : mjd_float = header [ <str> ] else : mjd_float = 0. mjd = int ( mjd_float ) time = ( mjd_float - mjd ) * 24 if <str> in list ( header . keys ( ) ) : src = header [ <str> ] else : src = <str> data = hdulist [ 0 ] . data stokes_in_hdu0 = False if len ( data . shape ) == 4 :          print ( <str> ) stokesdata = data data = stokesdata [ 0 , 0 ] stokes_in_hdu0 = True  data = data . reshape ( ( data . shape [ - 2 ] , data . shape [ - 1 ] ) ) if aipscc :          try :              aipscctab = hdulist [ <str> ]  except :              print ( <str> ) aipscc = False   if aipscc :          print ( <str> ) print ( <str> ) pulse = ehtim . observing . pulses . deltaPulse2D flux = aipscctab . data [ <str> ] deltax = aipscctab . data [ <str> ] deltay = aipscctab . data [ <str> ] checkmtype = np . abs ( np . unique ( aipscctab . data [ <str> ] ) ) < 1.0 if False in checkmtype . tolist ( ) :              errmsg = <str> errmsg += <str> raise ValueError ( errmsg )  try :              Nxref = header . get ( <str> )  except :              Nxref = header . get ( <str> ) // 2 + 1  try :              Nyref = header . get ( <str> )  except :              Nyref = header . get ( <str> ) // 2 + 1  ix = np . int64 ( np . round ( deltax / header . get ( <str> ) + Nxref - 1 ) ) iy = np . int64 ( np . round ( deltay / header . get ( <str> ) + Nyref - 1 ) ) data [ : , : ] = 0. Noutcomp = 0 for i in range ( len ( flux ) ) :              try :                  data [ iy [ i ] , ix [ i ] ] += flux [ i ]  except :                  Noutcomp += 1   print ( <str> % ( len ( flux ) ) ) if Noutcomp > 0 :              print ( <str> % ( Noutcomp ) )   image = data [ : : - 1 , : ] normalizer = 1.0 ; if <str> in list ( header . keys ( ) ) :          if header [ <str> ] . lower ( ) == <str> . lower ( ) :              print ( <str> ) if <str> in list ( header . keys ( ) ) :                  bmaj = header [ <str> ] bmin = header [ <str> ]  elif <str> in list ( header . keys ( ) ) :                  print ( <str> ) for line in header [ <str> ] :                      if <str> in line :                          bmaj = float ( line . split ( ) [ 3 ] ) bmin = float ( line . split ( ) [ 5 ] )    else :                  print ( <str> ) bmaj = bmin = 1.0  beamarea = ( 2.0 * np . pi * bmaj * bmin / ( 8.0 * np . log ( 2 ) ) ) normalizer = ( header [ <str> ] ) ** 2 / beamarea   if aipscc :          print ( <str> )  else :          image *= normalizer  outim = ehtim . image . Image ( image , psize_x , ra , dec , rf = rf , source = src , mjd = mjd , time = time , pulse = pulse , polrep = <str> , pol_prim = <str> ) qimage = uimage = vimage = np . array ( [ ] ) if stokes_in_hdu0 :              try :                  qdata = stokesdata [ 1 , 0 ] . reshape ( ( data . shape [ - 2 ] , data . shape [ - 1 ] ) ) qimage = normalizer * qdata [ : : - 1 , : ]  except IndexError : pass try :                  udata = stokesdata [ 2 , 0 ] . reshape ( ( data . shape [ - 2 ] , data . shape [ - 1 ] ) ) uimage = normalizer * udata [ : : - 1 , : ]  except IndexError : pass try :                  vdata = stokesdata [ 3 , 0 ] . reshape ( ( data . shape [ - 2 ] , data . shape [ - 1 ] ) ) vimage = normalizer * vdata [ : : - 1 , : ]  except IndexError : pass  else :          for hdu in hdulist [ 1 : ] :              header = hdu . header data = hdu . data try : data = data . reshape ( ( data . shape [ - 2 ] , data . shape [ - 1 ] ) ) except IndexError : continue if <str> in list ( header . keys ( ) ) and header [ <str> ] == <str> :                  qimage = normalizer * data [ : : - 1 , : ]  if <str> in list ( header . keys ( ) ) and header [ <str> ] == <str> :                  uimage = normalizer * data [ : : - 1 , : ]  if <str> in list ( header . keys ( ) ) and header [ <str> ] == <str> :                  vimage = normalizer * data [ : : - 1 , : ]    if qimage . shape == uimage . shape == vimage . shape == image . shape :          outim . add_qu ( qimage , uimage ) outim . add_v ( vimage )  elif vimage . shape == image . shape :          outim . add_v ( vimage ) if zero_pol :              outim . add_qu ( 0 * vimage , 0 * vimage )   elif qimage . shape == uimage . shape == image . shape :          outim . add_qu ( qimage , uimage ) if zero_pol :              outim . add_v ( 0 * qimage )   else :          if zero_pol :              outim . add_qu ( 0 * image , 0 * image ) outim . add_v ( 0 * image )   if not ( polrep == <str> and pol_prim == <str> ) :          outim = outim . switch_polrep ( polrep_out = polrep , pol_prim_out = pol_prim )  return outim  def load_movie_hdf5 ( file_name , framedur_sec = - 1 , psize = - 1 , ra = 17.761122472222223 , dec = - 28.992189444444445 , rf = 230e9 , source = <str> , pulse = PULSE_DEFAULT , polrep = <str> , pol_prim = None , zero_pol = True ) :      import h5py file = h5py . File ( file_name , <str> ) name = list ( file . keys ( ) ) [ 0 ] d = file [ str ( name ) ] frames = d [ : ] file . close ( ) movie = Movie ( frames , framedur_sec , psize , ra , dec , rf = rf , polrep = polrep , pol_prim = pol_prim , start_hr = 0 , source = source , mjd = MJD_DEFAULT , pulse = pulse ) if zero_pol :          for pol in list ( movie . _movdict . keys ( ) ) :              if pol == movie . pol_prim : continue polframes = np . zeros ( frames . shape ) newmov . add_pol_movie ( polframes , pol )   return movie  def load_movie_txt ( basename , nframes , framedur = - 1 , pulse = PULSE_DEFAULT , polrep = <str> , pol_prim = None , zero_pol = True ) :      imlist = [ ] for i in range ( nframes ) :          filename = basename + <str> % i sys . stdout . write ( <str> % ( i , nframes ) ) sys . stdout . flush ( ) im = load_im_txt ( filename , pulse = pulse , polrep = polrep , pol_prim = pol_prim , zero_pol = zero_pol ) imlist . append ( im ) hour = im . time if i == 0 :              hour0 = im . time  else :              pass   if framedur == - 1 :          framedur = ( ( hour - hour0 ) / float ( nframes ) ) * 3600.0  out_mov = ehtim . movie . merge_im_list ( imlist , framedur = framedur ) return out_mov  def load_movie_fits ( basename , nframes , framedur = - 1 , pulse = PULSE_DEFAULT , polrep = <str> , pol_prim = None , zero_pol = True ) :      imlist = [ ] for i in range ( nframes ) :          filename = basename + <str> % i sys . stdout . write ( <str> % ( i , nframes ) ) sys . stdout . flush ( ) im = load_im_fits ( filename , pulse = pulse , polrep = polrep , pol_prim = pol_prim , zero_pol = zero_pol ) imlist . append ( im ) hour = im . time if i == 0 :              hour0 = im . time  else :              pass   if framedur == - 1 :          framedur = ( ( hour - hour0 ) / float ( nframes ) ) * 3600.0  out_mov = ehtim . movie . merge_im_list ( imlist , framedur = framedur ) return out_mov  def load_array_txt ( filename , ephemdir = <str> ) :      tdata = np . loadtxt ( filename , dtype = bytes , comments = <str> ) . astype ( str ) path = os . path . dirname ( filename ) tdataout = [ ] if ( tdata . shape [ 1 ] != 5 and tdata . shape [ 1 ] != 13 ) :          raise Exception ( <str> + <str> + <str> + <str> )  elif tdata . shape [ 1 ] == 5 :     	 tdataout = [ np . array ( ( x [ 0 ] , float ( x [ 1 ] ) , float ( x [ 2 ] ) , float ( x [ 3 ] ) , float ( x [ 4 ] ) , float ( x [ 4 ] ) , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ) , dtype = DTARR ) for x in tdata ]  elif tdata . shape [ 1 ] == 13 :     	 tdataout = [ np . array ( ( x [ 0 ] , float ( x [ 1 ] ) , float ( x [ 2 ] ) , float ( x [ 3 ] ) , float ( x [ 4 ] ) , float ( x [ 5 ] ) , float ( x [ 9 ] ) + 1j * float ( x [ 10 ] ) , float ( x [ 11 ] ) + 1j * float ( x [ 12 ] ) , float ( x [ 6 ] ) , float ( x [ 7 ] ) , float ( x [ 8 ] ) ) , dtype = DTARR ) for x in tdata ]  tdataout = np . array ( tdataout ) edata = { } for line in tdataout :          if np . all ( np . array ( [ line [ <str> ] , line [ <str> ] , line [ <str> ] ] ) == ( 0. , 0. , 0. ) ) :              sitename = str ( line [ <str> ] ) ephempath = path + <str> + ephemdir + <str> + sitename try :                  edata [ sitename ] = np . loadtxt ( ephempath , dtype = bytes , comments = <str> , delimiter = <str> ) . astype ( str ) print ( <str> % ephempath )  except IOError :                  raise Exception ( <str> % ephempath )    return ehtim . array . Array ( tdataout , ephem = edata )  def load_obs_txt ( filename , polrep = <str> ) :      if not ( polrep in [ <str> , <str> ] ) :          raise Exception ( <str> )  print ( <str> , filename ) file = open ( filename ) src = <str> . join ( file . readline ( ) . split ( ) [ 2 : ] ) ra = file . readline ( ) . split ( ) ra = float ( ra [ 2 ] ) + float ( ra [ 4 ] ) / 60.0 + float ( ra [ 6 ] ) / 3600.0 dec = file . readline ( ) . split ( ) dec = np . sign ( float ( dec [ 2 ] ) ) * ( abs ( float ( dec [ 2 ] ) ) + float ( dec [ 4 ] ) / 60.0 + float ( dec [ 6 ] ) / 3600.0 ) mjd = float ( file . readline ( ) . split ( ) [ 2 ] ) rf = float ( file . readline ( ) . split ( ) [ 2 ] ) * 1e9 bw = float ( file . readline ( ) . split ( ) [ 2 ] ) * 1e9 phasecal = bool ( file . readline ( ) . split ( ) [ 2 ] ) ampcal = bool ( file . readline ( ) . split ( ) [ 2 ] ) x = file . readline ( ) . split ( ) if x [ 1 ] == <str> :          opacitycal = bool ( x [ 2 ] ) dcal = bool ( file . readline ( ) . split ( ) [ 2 ] ) frcal = bool ( file . readline ( ) . split ( ) [ 2 ] ) file . readline ( )  else :          opacitycal = True dcal = True frcal = True  file . readline ( ) line = file . readline ( ) . split ( ) tarr = [ ] while line [ 1 ] [ 0 ] != <str> :          if len ( line ) == 6 :         	 tarr . append ( np . array ( ( line [ 1 ] , line [ 2 ] , line [ 3 ] , line [ 4 ] , line [ 5 ] , line [ 5 ] , 0 , 0 , 0 , 0 , 0 ) , dtype = DTARR ) )  elif len ( line ) == 14 :         	 tarr . append ( np . array ( ( line [ 1 ] , line [ 2 ] , line [ 3 ] , line [ 4 ] , line [ 5 ] , line [ 6 ] , float ( line [ 10 ] ) + 1j * float ( line [ 11 ] ) , float ( line [ 12 ] ) + 1j * float ( line [ 13 ] ) , line [ 7 ] , line [ 8 ] , line [ 9 ] ) , dtype = DTARR ) )  else : raise Exception ( <str> ) line = file . readline ( ) . split ( )  tarr = np . array ( tarr , dtype = DTARR ) line = file . readline ( ) . split ( ) if line [ 12 ] == <str> :          polrep_orig = <str>  elif line [ 12 ] == <str> :          polrep_orig = <str>  else : raise Exception ( <str> ) file . close ( ) datatable = np . loadtxt ( filename , dtype = bytes ) . astype ( str ) datatable2 = [ ] for row in datatable :          time = float ( row [ 0 ] ) tint = float ( row [ 1 ] ) t1 = row [ 2 ] t2 = row [ 3 ] if datatable . shape [ 1 ] < 20 :              tau1 = float ( row [ 6 ] ) tau2 = float ( row [ 7 ] ) u = float ( row [ 8 ] ) v = float ( row [ 9 ] ) vis1 = float ( row [ 10 ] ) * np . exp ( 1j * float ( row [ 11 ] ) * DEGREE ) if datatable . shape [ 1 ] == 19 :                  vis2 = float ( row [ 12 ] ) * np . exp ( 1j * float ( row [ 13 ] ) * DEGREE ) vis3 = float ( row [ 14 ] ) * np . exp ( 1j * float ( row [ 15 ] ) * DEGREE ) vis4 = float ( row [ 16 ] ) * np . exp ( 1j * float ( row [ 17 ] ) * DEGREE ) sigma1 = sigma2 = sigma3 = sigma4 = float ( row [ 18 ] )  elif datatable . shape [ 1 ] == 17 :                  vis2 = float ( row [ 12 ] ) * np . exp ( 1j * float ( row [ 13 ] ) * DEGREE ) vis3 = float ( row [ 14 ] ) * np . exp ( 1j * float ( row [ 15 ] ) * DEGREE ) vis4 = 0 + 0j sigma1 = sigma2 = sigma3 = sigma4 = float ( row [ 16 ] )  elif datatable . shape [ 1 ] == 15 :                  vis2 = 0 + 0j vis3 = 0 + 0j vis4 = 0 + 0j sigma1 = sigma2 = sigma3 = sigma4 = float ( row [ 12 ] )  else :                  raise Exception ( <str> )   elif datatable . shape [ 1 ] == 20 :              tau1 = float ( row [ 4 ] ) tau2 = float ( row [ 5 ] ) u = float ( row [ 6 ] ) v = float ( row [ 7 ] ) vis1 = float ( row [ 8 ] ) * np . exp ( 1j * float ( row [ 9 ] ) * DEGREE ) vis2 = float ( row [ 10 ] ) * np . exp ( 1j * float ( row [ 11 ] ) * DEGREE ) vis3 = float ( row [ 12 ] ) * np . exp ( 1j * float ( row [ 13 ] ) * DEGREE ) vis4 = float ( row [ 14 ] ) * np . exp ( 1j * float ( row [ 15 ] ) * DEGREE ) sigma1 = float ( row [ 16 ] ) sigma2 = float ( row [ 17 ] ) sigma3 = float ( row [ 18 ] ) sigma4 = float ( row [ 19 ] )  else :              raise Exception ( <str> )  if polrep_orig == <str> :              datatable2 . append ( np . array ( ( time , tint , t1 , t2 , tau1 , tau2 , u , v , vis1 , vis2 , vis3 , vis4 , sigma1 , sigma2 , sigma3 , sigma4 ) , dtype = DTPOL_STOKES ) )  elif polrep_orig == <str> :              datatable2 . append ( np . array ( ( time , tint , t1 , t2 , tau1 , tau2 , u , v , vis1 , vis2 , vis3 , vis4 , sigma1 , sigma2 , sigma3 , sigma4 ) , dtype = DTPOL_CIRC ) )   datatable2 = np . array ( datatable2 ) out = ehtim . obsdata . Obsdata ( ra , dec , rf , bw , datatable2 , tarr , polrep = polrep_orig , source = src , mjd = mjd , ampcal = ampcal , phasecal = phasecal , opacitycal = opacitycal , dcal = dcal , frcal = frcal ) out = out . switch_polrep ( polrep_out = polrep ) return out  def load_obs_maps ( arrfile , obsspec , ifile , qfile = 0 , ufile = 0 , vfile = 0 , src = SOURCE_DEFAULT , mjd = MJD_DEFAULT , ampcal = False , phasecal = False ) :      tdata = np . loadtxt ( arrfile , dtype = bytes ) . astype ( str ) tdata = [ np . array ( ( x [ 0 ] , float ( x [ 1 ] ) , float ( x [ 2 ] ) , float ( x [ 3 ] ) , float ( x [ - 1 ] ) , float ( x [ - 1 ] ) , 0. , 0. , 0. , 0. , 0. ) , dtype = DTARR ) for x in tdata ] tdata = np . array ( tdata ) f = open ( obsspec ) stop = False while not stop :          line = f . readline ( ) . split ( ) if line == [ ] or line [ 0 ] == <str> :              continue  elif line [ 0 ] == <str> :              x = line [ 2 ] . split ( <str> ) ra = float ( x [ 0 ] ) + float ( x [ 1 ] ) / 60.0 + float ( x [ 2 ] ) / 3600.0  elif line [ 0 ] == <str> :              x = line [ 2 ] . split ( <str> ) dec = np . sign ( float ( x [ 0 ] ) ) * ( abs ( float ( x [ 0 ] ) ) + float ( x [ 1 ] ) / 60.0 + float ( x [ 2 ] ) / 3600.0 )  elif line [ 0 ] == <str> :              tint = float ( line [ 2 ] )  elif line [ 0 ] == <str> :              bw = float ( line [ 2 ] ) * 1e6  elif line [ 0 ] == <str> :              rf = float ( line [ 2 ] . split ( <str> ) [ 0 ] ) * 1e6  elif line [ 0 ] == <str> :              x = line [ 2 ] . split ( <str> )  elif line [ 0 ] == <str> :              stop = True   f . close ( ) datatable = [ ] f = open ( ifile ) for line in f :          line = line . split ( ) if not ( line [ 0 ] in [ <str> , <str> , <str> ] ) :              time = line [ 0 ] . split ( <str> ) time = float ( time [ 2 ] ) + float ( time [ 3 ] ) / 60.0 + float ( time [ 4 ] ) / 3600.0 u = float ( line [ 1 ] ) * 1000 v = float ( line [ 2 ] ) * 1000 bl = line [ 4 ] . split ( <str> ) t1 = tdata [ int ( bl [ 0 ] ) - 1 ] [ <str> ] t2 = tdata [ int ( bl [ 1 ] ) - 1 ] [ <str> ] tau1 = 0. tau2 = 0. vis = float ( line [ 7 ] [ : - 1 ] ) * np . exp ( 1j * float ( line [ 8 ] [ : - 1 ] ) * DEGREE ) sigma = float ( line [ 10 ] ) datatable . append ( np . array ( ( time , tint , t1 , t2 , tau1 , tau2 , u , v , vis , 0.0 , 0.0 , 0.0 , sigma , 0.0 , 0.0 , 0.0 ) , dtype = DTPOL_STOKES ) )   datatable = np . array ( datatable ) if not qfile == 0 :          f = open ( qfile ) i = 0 for line in f :              line = line . split ( ) if not ( line [ 0 ] in [ <str> , <str> , <str> ] ) :                  datatable [ i ] [ <str> ] = float ( line [ 7 ] [ : - 1 ] ) * np . exp ( 1j * float ( line [ 8 ] [ : - 1 ] ) * DEGREE ) datatable [ i ] [ <str> ] = float ( line [ 10 ] ) i += 1    if not ufile == 0 :          f = open ( ufile ) i = 0 for line in f :              line = line . split ( ) if not ( line [ 0 ] in [ <str> , <str> , <str> ] ) :                  datatable [ i ] [ <str> ] = float ( line [ 7 ] [ : - 1 ] ) * np . exp ( 1j * float ( line [ 8 ] [ : - 1 ] ) * DEGREE ) datatable [ i ] [ <str> ] = float ( line [ 10 ] ) i += 1    if not vfile == 0 :          f = open ( vfile ) i = 0 for line in f :              line = line . split ( ) if not ( line [ 0 ] in [ <str> , <str> , <str> ] ) :                  datatable [ i ] [ <str> ] = float ( line [ 7 ] [ : - 1 ] ) * np . exp ( 1j * float ( line [ 8 ] [ : - 1 ] ) * DEGREE ) datatable [ i ] [ <str> ] = float ( line [ 10 ] ) i += 1    return ehtim . obsdata . Obsdata ( ra , dec , rf , bw , datatable , tdata , source = src , mjd = mjd , polrep = <str> )  def load_obs_uvfits ( filename , polrep = <str> , flipbl = False , allow_singlepol = True , force_singlepol = None , channel = all , IF = all , remove_nan = False ) :      if not ( polrep in [ <str> , <str> ] ) :          raise Exception ( <str> )  if not ( force_singlepol is None or force_singlepol == False ) and polrep != <str> :          raise Exception ( <str> )  print ( <str> , filename ) hdulist = fits . open ( filename ) header = hdulist [ 0 ] . header data = hdulist [ 0 ] . data tnames = hdulist [ <str> ] . data [ <str> ] tnums = hdulist [ <str> ] . data [ <str> ] - 1 xyz = np . real ( hdulist [ <str> ] . data [ <str> ] ) try :          sefdr = np . real ( hdulist [ <str> ] . data [ <str> ] ) sefdl = np . real ( hdulist [ <str> ] . data [ <str> ] )  except KeyError :          sefdr = np . zeros ( len ( tnames ) ) sefdl = np . zeros ( len ( tnames ) )  fr_par = np . zeros ( len ( tnames ) ) fr_el = np . zeros ( len ( tnames ) ) fr_off = np . zeros ( len ( tnames ) ) dr = np . zeros ( len ( tnames ) ) + 1j * np . zeros ( len ( tnames ) ) dl = np . zeros ( len ( tnames ) ) + 1j * np . zeros ( len ( tnames ) ) tarr = [ np . array ( ( str ( tnames [ i ] ) , xyz [ i ] [ 0 ] , xyz [ i ] [ 1 ] , xyz [ i ] [ 2 ] , sefdr [ i ] , sefdl [ i ] , dr [ i ] , dl [ i ] , fr_par [ i ] , fr_el [ i ] , fr_off [ i ] ) , dtype = DTARR ) for i in range ( len ( tnames ) ) ] tarr = np . array ( tarr ) try :          ra = header [ <str> ] * 12. / 180. dec = header [ <str> ]  except KeyError :          if header [ <str> ] == <str> :              ra = header [ <str> ] * 12. / 180.  else : raise Exception ( <str> ) if header [ <str> ] == <str> :              dec = header [ <str> ]  else : raise Exception ( <str> )  src = header [ <str> ] rf = hdulist [ <str> ] . header [ <str> ] if header [ <str> ] == <str> :          ch1_freq = header [ <str> ] ch_bw = header [ <str> ] nchan = header [ <str> ]  else : raise Exception ( <str> ) nif = 1 try :          if header [ <str> ] == <str> :              nif = header [ <str> ]   except KeyError :          print ( <str> )  try :          if header [ <str> ] == <str> :              if header [ <str> ] == 1 :                  polrep_uvfits = <str>  elif header [ <str> ] == - 1 :                  polrep_uvfits = <str>  else :                  raise Exception ( <str> )    except :          raise Exception ( <str> )  print ( <str> , polrep_uvfits ) if polrep_uvfits == <str> and not ( force_singlepol is None ) :          raise Exception ( <str> )  bw = ch_bw * nchan * nif num_corr = data [ <str> ] . shape [ 5 ] print ( <str> , num_corr ) if num_corr == 1 and force_singlepol != None :          print ( <str> ) force_singlepol = None  if not force_singlepol is None and polrep == <str> :          allow_singlepol = True  nvis = data [ <str> ] . shape [ 0 ] full_nchannels = data [ <str> ] . shape [ 4 ] full_nifs = data [ <str> ] . shape [ 3 ] if channel == all :          channel = np . arange ( 0 , full_nchannels , 1 ) nchannels = full_nchannels  else :          try :              nchannels = len ( np . array ( channel ) ) channel = np . array ( channel ) . reshape ( - 1 )  except TypeError :              channel = np . array ( [ channel ] ) . reshape ( - 1 ) nchannels = len ( np . array ( channel ) )   if IF == all :          IF = np . arange ( 0 , full_nifs , 1 ) nifs = full_nifs  else :          try :              nifs = len ( IF ) IF = np . array ( IF ) . reshape ( - 1 )  except TypeError :              IF = np . array ( [ IF ] ) . reshape ( - 1 ) nifs = len ( np . array ( IF ) )   if ( np . max ( channel ) >= full_nchannels ) or ( np . min ( channel ) < 0 ) :          raise Exception ( <str> )  if ( np . max ( IF ) >= full_nifs ) or ( np . min ( IF ) < 0 ) :          raise Exception ( <str> )  rrweight = data [ <str> ] [ : , 0 , 0 , IF , channel , 0 , 2 ] . reshape ( nvis , nifs , nchannels ) if num_corr >= 2 :          llweight = data [ <str> ] [ : , 0 , 0 , IF , channel , 1 , 2 ] . reshape ( nvis , nifs , nchannels )  else :          llweight = rrweight * 0.0  if num_corr >= 3 :          rlweight = data [ <str> ] [ : , 0 , 0 , IF , channel , 2 , 2 ] . reshape ( nvis , nifs , nchannels )  else :          rlweight = rrweight * 0.0  if num_corr >= 4 :          lrweight = data [ <str> ] [ : , 0 , 0 , IF , channel , 3 , 2 ] . reshape ( nvis , nifs , nchannels )  else :          lrweight = rrweight * 0.0  if polrep_uvfits == <str> :          if force_singlepol in [ <str> or <str> ] :              rrweight = rrweight * 0.0 rlweight = rlweight * 0.0 lrweight = lrweight * 0.0  elif force_singlepol in [ <str> or <str> ] :              llweight = llweight * 0.0 rlweight = rlweight * 0.0 lrweight = lrweight * 0.0  elif force_singlepol == <str> :              print ( <str> ) rrweight = copy . deepcopy ( lrweight ) llweight = llweight * 0.0 rlweight = rlweight * 0.0 lrweight = lrweight * 0.0  elif force_singlepol == <str> :              print ( <str> ) rrweight = copy . deepcopy ( rlweight ) llweight = llweight * 0.0 rlweight = rlweight * 0.0 lrweight = lrweight * 0.0   rrnanmask_2d = ( np . isnan ( rrweight ) ) llnanmask_2d = ( np . isnan ( llweight ) ) rlnanmask_2d = ( np . isnan ( rlweight ) ) lrnanmask_2d = ( np . isnan ( lrweight ) ) rrweight [ rrnanmask_2d ] = 0. llweight [ llnanmask_2d ] = 0. rlweight [ rlnanmask_2d ] = 0. lrweight [ lrnanmask_2d ] = 0. rrmask_2d = ( rrweight > 0. ) llmask_2d = ( llweight > 0. ) rlmask_2d = ( rlweight > 0. ) lrmask_2d = ( lrweight > 0. ) rrmask = np . any ( np . any ( rrmask_2d , axis = 2 ) , axis = 1 ) llmask = np . any ( np . any ( llmask_2d , axis = 2 ) , axis = 1 ) rlmask = np . any ( np . any ( rlmask_2d , axis = 2 ) , axis = 1 ) lrmask = np . any ( np . any ( rlmask_2d , axis = 2 ) , axis = 1 ) if polrep_uvfits == <str> :          mask = rrmask + llmask  elif polrep_uvfits == <str> :          mask = rrmask  if not np . any ( mask ) :          raise Exception ( <str> )  if np . any ( ~ ( rrmask * llmask ) ) :          print ( <str> )  jds = data [ <str> ] [ mask ] . astype ( <str> ) + data [ <str> ] [ mask ] . astype ( <str> ) mjd = int ( np . min ( jds ) - 2400000.5 ) times = ( jds - 2400000.5 - mjd ) * 24.0 try :          scantable = [ ] nxtable = hdulist [ <str> ] for scan in nxtable . data :              reftime = astropy . time . Time ( hdulist [ <str> ] . header [ <str> ] , format = <str> , scale = <str> ) . jd scan_start = scan [ <str> ] scan_dur = scan [ <str> ] startvis = scan [ <str> ] - 1 endvis = scan [ <str> ] - 1 scantable . append ( [ scan_start - 0.5 * scan_dur , scan_start + 0.5 * scan_dur ] )  scantable = np . array ( scantable * 24 )  except :          print ( <str> ) scantable = None  try :          tints = data [ <str> ] [ mask ]  except KeyError :          tints = np . zeros ( len ( mask ) )  t1 = data [ <str> ] [ mask ] . astype ( int ) // 256 t2 = data [ <str> ] [ mask ] . astype ( int ) - t1 * 256 t1 = t1 - 1 t2 = t2 - 1 scopes_num = np . sort ( list ( set ( np . hstack ( ( t1 , t2 ) ) ) ) ) t1 = np . array ( [ tarr [ i ] [ <str> ] for i in t1 ] ) t2 = np . array ( [ tarr [ i ] [ <str> ] for i in t2 ] ) try :          tau1 = data [ <str> ] [ mask ] tau2 = data [ <str> ] [ mask ]  except KeyError :          tau1 = tau2 = np . zeros ( len ( t1 ) )  try :          u = data [ <str> ] [ mask ] * rf v = data [ <str> ] [ mask ] * rf  except KeyError :          try :              u = data [ <str> ] [ mask ] * rf v = data [ <str> ] [ mask ] * rf  except KeyError :              try :                  u = data [ <str> ] [ mask ] * rf v = data [ <str> ] [ mask ] * rf  except KeyError :                  raise Exception ( <str> )    rr_2d = data [ <str> ] [ : , 0 , 0 , IF , channel , 0 , 0 ] + 1j * data [ <str> ] [ : , 0 , 0 , IF , channel , 0 , 1 ] rr_2d = rr_2d . reshape ( nvis , nifs , nchannels ) if num_corr >= 2 :          ll_2d = data [ <str> ] [ : , 0 , 0 , IF , channel , 1 , 0 ] + 1j * data [ <str> ] [ : , 0 , 0 , IF , channel , 1 , 1 ] ll_2d = ll_2d . reshape ( nvis , nifs , nchannels )  else :          ll_2d = rr_2d * 0.0  if num_corr >= 3 :          rl_2d = data [ <str> ] [ : , 0 , 0 , IF , channel , 2 , 0 ] + 1j * data [ <str> ] [ : , 0 , 0 , IF , channel , 2 , 1 ] rl_2d = rl_2d . reshape ( nvis , nifs , nchannels )  else :          rl_2d = rr_2d * 0.0  if num_corr >= 4 :          lr_2d = data [ <str> ] [ : , 0 , 0 , IF , channel , 3 , 0 ] + 1j * data [ <str> ] [ : , 0 , 0 , IF , channel , 3 , 1 ] lr_2d = lr_2d . reshape ( nvis , nifs , nchannels )  else :          lr_2d = rr_2d * 0.0  if polrep_uvfits == <str> :          if force_singlepol == <str> :              rr_2d = copy . deepcopy ( lr_2d )  elif force_singlepol == <str> :              rr_2d = copy . deepcopy ( rl_2d )   rr_2d [ ~ rrmask_2d ] = np . nan ll_2d [ ~ llmask_2d ] = np . nan rl_2d [ ~ rlmask_2d ] = np . nan lr_2d [ ~ lrmask_2d ] = np . nan rr = np . nanmean ( np . nanmean ( rr_2d , axis = 2 ) , axis = 1 ) [ mask ] ll = np . nanmean ( np . nanmean ( ll_2d , axis = 2 ) , axis = 1 ) [ mask ] rl = np . nanmean ( np . nanmean ( rl_2d , axis = 2 ) , axis = 1 ) [ mask ] lr = np . nanmean ( np . nanmean ( lr_2d , axis = 2 ) , axis = 1 ) [ mask ] rrweight [ ~ rrmask_2d ] = np . nan llweight [ ~ llmask_2d ] = np . nan rlweight [ ~ rlmask_2d ] = np . nan lrweight [ ~ lrmask_2d ] = np . nan nsig_rr = np . sum ( np . sum ( rrmask_2d , axis = 2 ) , axis = 1 ) . astype ( float ) nsig_rr [ ~ rrmask ] = np . nan rrsig = np . sqrt ( np . nansum ( np . nansum ( 1. / rrweight , axis = 2 ) , axis = 1 ) ) / nsig_rr rrsig = rrsig [ mask ] nsig_ll = np . sum ( np . sum ( llmask_2d , axis = 2 ) , axis = 1 ) . astype ( float ) nsig_ll [ ~ llmask ] = np . nan llsig = np . sqrt ( np . nansum ( np . nansum ( 1. / llweight , axis = 2 ) , axis = 1 ) ) / nsig_ll llsig = llsig [ mask ] nsig_rl = np . sum ( np . sum ( rlmask_2d , axis = 2 ) , axis = 1 ) . astype ( float ) nsig_rl [ ~ rlmask ] = np . nan rlsig = np . sqrt ( np . nansum ( np . nansum ( 1. / rlweight , axis = 2 ) , axis = 1 ) ) / nsig_rl rlsig = rlsig [ mask ] nsig_lr = np . sum ( np . sum ( lrmask_2d , axis = 2 ) , axis = 1 ) . astype ( float ) nsig_lr [ ~ lrmask ] = np . nan lrsig = np . sqrt ( np . nansum ( np . nansum ( 1. / lrweight , axis = 2 ) , axis = 1 ) ) / nsig_lr lrsig = lrsig [ mask ] if flipbl :          u = - u v = - v  if polrep_uvfits == <str> :          dtpol_out = DTPOL_CIRC  elif polrep_uvfits == <str> :          dtpol_out = DTPOL_STOKES  datatable = [ ] for i in range ( len ( times ) ) :          datatable . append ( np . array ( ( times [ i ] , tints [ i ] , t1 [ i ] , t2 [ i ] , tau1 [ i ] , tau2 [ i ] , u [ i ] , v [ i ] , rr [ i ] , ll [ i ] , rl [ i ] , lr [ i ] , rrsig [ i ] , llsig [ i ] , rlsig [ i ] , lrsig [ i ] ) , dtype = dtpol_out ) )  datatable = np . array ( datatable ) obs = ehtim . obsdata . Obsdata ( ra , dec , rf , bw , datatable , tarr , polrep = polrep_uvfits , source = src , mjd = mjd , scantable = scantable ) if remove_nan :          if polrep_uvfits == <str> :              for j in range ( len ( obs . data ) ) :                  if np . isnan ( obs . data [ j ] [ <str> ] ) :                      obs . data [ j ] [ <str> ] = obs . data [ j ] [ <str> ]  if np . isnan ( obs . data [ j ] [ <str> ] ) :                      obs . data [ j ] [ <str> ] = obs . data [ j ] [ <str> ]  if np . isnan ( obs . data [ j ] [ <str> ] ) :                      obs . data [ j ] [ <str> ] = obs . data [ j ] [ <str> ]  if np . isnan ( obs . data [ j ] [ <str> ] ) :                      obs . data [ j ] [ <str> ] = obs . data [ j ] [ <str> ]    else :              print ( <str> )   obs = obs . switch_polrep ( polrep , allow_singlepol = allow_singlepol ) return obs  def load_obs_oifits ( filename , flux = 1.0 ) :      print ( <str> ) oidata = ehtim . io . oifits . open ( filename ) vis_data = oidata . vis src = oidata . target [ 0 ] . target ra = oidata . target [ 0 ] . raep0 . angle dec = oidata . target [ 0 ] . decep0 . angle nAntennas = len ( oidata . array [ list ( oidata . array . keys ( ) ) [ 0 ] ] . station ) sites = np . array ( [ oidata . array [ list ( oidata . array . keys ( ) ) [ 0 ] ] . station [ i ] . sta_name for i in range ( nAntennas ) ] ) arrayX = oidata . array [ list ( oidata . array . keys ( ) ) [ 0 ] ] . arrxyz [ 0 ] arrayY = oidata . array [ list ( oidata . array . keys ( ) ) [ 0 ] ] . arrxyz [ 1 ] arrayZ = oidata . array [ list ( oidata . array . keys ( ) ) [ 0 ] ] . arrxyz [ 2 ] x = np . array ( [ arrayX + oidata . array [ list ( oidata . array . keys ( ) ) [ 0 ] ] . station [ i ] . staxyz [ 0 ] for i in range ( nAntennas ) ] ) y = np . array ( [ arrayY + oidata . array [ list ( oidata . array . keys ( ) ) [ 0 ] ] . station [ i ] . staxyz [ 1 ] for i in range ( nAntennas ) ] ) z = np . array ( [ arrayZ + oidata . array [ list ( oidata . array . keys ( ) ) [ 0 ] ] . station [ i ] . staxyz [ 2 ] for i in range ( nAntennas ) ] ) wavelength = oidata . wavelength [ list ( oidata . wavelength . keys ( ) ) [ 0 ] ] . eff_wave nWavelengths = wavelength . shape [ 0 ] bandpass = oidata . wavelength [ list ( oidata . wavelength . keys ( ) ) [ 0 ] ] . eff_band frequency = C / wavelength bw = np . mean ( 2 * ( np . sqrt ( bandpass ** 2 * frequency ** 2 + C ** 2 ) - C ) / bandpass ) rf = np . mean ( frequency ) u = np . array ( [ vis_data [ i ] . ucoord / wavelength for i in range ( len ( vis_data ) ) ] ) v = np . array ( [ vis_data [ i ] . vcoord / wavelength for i in range ( len ( vis_data ) ) ] ) amp = np . array ( [ vis_data [ i ] . _visamp for i in range ( len ( vis_data ) ) ] ) phase = np . array ( [ vis_data [ i ] . _visphi for i in range ( len ( vis_data ) ) ] ) amperr = np . array ( [ vis_data [ i ] . _visamperr for i in range ( len ( vis_data ) ) ] ) visphierr = np . array ( [ vis_data [ i ] . _visphierr for i in range ( len ( vis_data ) ) ] ) timeobs = np . array ( [ vis_data [ i ] . timeobs for i in range ( len ( vis_data ) ) ] ) time = np . transpose ( np . tile ( np . array ( [ ( ttime . mktime ( ( timeobs [ i ] + datetime . timedelta ( days = 1 ) ) . timetuple ( ) ) ) / ( 60.0 * 60.0 ) for i in range ( len ( timeobs ) ) ] ) , [ nWavelengths , 1 ] ) ) tint = np . array ( [ vis_data [ i ] . int_time for i in range ( len ( vis_data ) ) ] ) tint = tint [ 0 ] tint = tint * np . ones ( amp . shape ) t1 = np . transpose ( np . tile ( np . array ( [ vis_data [ i ] . station [ 0 ] . sta_name for i in range ( len ( vis_data ) ) ] ) , [ nWavelengths , 1 ] ) ) t2 = np . transpose ( np . tile ( np . array ( [ vis_data [ i ] . station [ 1 ] . sta_name for i in range ( len ( vis_data ) ) ] ) , [ nWavelengths , 1 ] ) ) tau1 = np . zeros ( amp . shape ) tau2 = np . zeros ( amp . shape ) qvis = np . zeros ( amp . shape ) uvis = np . zeros ( amp . shape ) vvis = np . zeros ( amp . shape ) sefdr = np . zeros ( x . shape ) sefdl = np . zeros ( x . shape ) fr_par = np . zeros ( x . shape ) fr_el = np . zeros ( x . shape ) fr_off = np . zeros ( x . shape ) dr = np . zeros ( x . shape ) + 1j * np . zeros ( x . shape ) dl = np . zeros ( x . shape ) + 1j * np . zeros ( x . shape ) time = time . ravel ( ) tint = tint . ravel ( ) t1 = t1 . ravel ( ) t2 = t2 . ravel ( ) tau1 = tau1 . ravel ( ) tau2 = tau2 . ravel ( ) u = u . ravel ( ) v = v . ravel ( ) vis = amp . ravel ( ) * np . exp ( - 1j * phase . ravel ( ) * np . pi / 180.0 ) qvis = qvis . ravel ( ) uvis = uvis . ravel ( ) vvis = vvis . ravel ( ) amperr = amperr . ravel ( ) datatable = np . array ( [ ( time [ i ] , tint [ i ] , t1 [ i ] , t2 [ i ] , tau1 [ i ] , tau2 [ i ] , u [ i ] , v [ i ] , flux * vis [ i ] , qvis [ i ] , uvis [ i ] , vvis [ i ] , flux * amperr [ i ] , flux * amperr [ i ] , flux * amperr [ i ] , flux * amperr [ i ] ) for i in range ( len ( vis ) ) ] , dtype = DTPOL_STOKES ) tarr = np . array ( [ ( sites [ i ] , x [ i ] , y [ i ] , z [ i ] , sefdr [ i ] , sefdl [ i ] , dr [ i ] , dl [ i ] , fr_par [ i ] , fr_el [ i ] , fr_off [ i ] , ) for i in range ( nAntennas ) ] , dtype = DTARR ) return ehtim . obsdata . Obsdata ( ra , dec , rf , bw , datatable , tarr , polrep = <str> , source = src , mjd = time [ 0 ] )  def load_dtype_txt ( obs , filename , dtype = <str> ) :      print ( <str> , filename ) file = open ( filename ) src = <str> . join ( file . readline ( ) . split ( ) [ 2 : ] ) ra = file . readline ( ) . split ( ) ra = float ( ra [ 2 ] ) + float ( ra [ 4 ] ) / 60.0 + float ( ra [ 6 ] ) / 3600.0 dec = file . readline ( ) . split ( ) dec = np . sign ( float ( dec [ 2 ] ) ) * ( abs ( float ( dec [ 2 ] ) ) + float ( dec [ 4 ] ) / 60.0 + float ( dec [ 6 ] ) / 3600.0 ) mjd = float ( file . readline ( ) . split ( ) [ 2 ] ) rf = float ( file . readline ( ) . split ( ) [ 2 ] ) * 1e9 bw = float ( file . readline ( ) . split ( ) [ 2 ] ) * 1e9 phasecal = bool ( file . readline ( ) . split ( ) [ 2 ] ) ampcal = bool ( file . readline ( ) . split ( ) [ 2 ] ) datatable = np . loadtxt ( filename , dtype = bytes ) . astype ( str ) if dtype == <str> :          datatable2 = [ ] for row in datatable :              time = float ( row [ 0 ] ) t1 = row [ 1 ] t2 = row [ 2 ] t3 = row [ 3 ] u1 = float ( row [ 4 ] ) v1 = float ( row [ 5 ] ) u2 = float ( row [ 6 ] ) v2 = float ( row [ 7 ] ) u3 = float ( row [ 8 ] ) v3 = float ( row [ 9 ] ) cphase = float ( row [ 10 ] ) sigmacp = float ( row [ 11 ] ) datatable2 . append ( np . array ( ( time , t1 , t2 , t3 , u1 , v1 , u2 , v2 , u3 , v3 , cphase , sigmacp ) , dtype = DTCPHASE ) )  obs . cphase = np . array ( datatable2 )  elif dtype == <str> :          datatable2 = [ ] for row in datatable :              time = float ( row [ 0 ] ) t1 = row [ 1 ] t2 = row [ 2 ] t3 = row [ 3 ] t4 = row [ 4 ] u1 = float ( row [ 5 ] ) v1 = float ( row [ 6 ] ) u2 = float ( row [ 7 ] ) v2 = float ( row [ 8 ] ) u3 = float ( row [ 9 ] ) v3 = float ( row [ 10 ] ) u4 = float ( row [ 11 ] ) v4 = float ( row [ 12 ] ) logcamp = float ( row [ 13 ] ) sigmalogcamp = float ( row [ 14 ] ) datatable2 . append ( np . array ( ( time , t1 , t2 , t3 , t4 , u1 , v1 , u2 , v2 , u3 , v3 , u4 , v4 , logcamp , sigmalogcamp ) , dtype = DTCAMP ) )  obs . logcamp = np . array ( datatable2 )  elif dtype == <str> :          datatable2 = [ ] for row in datatable :              time = float ( row [ 0 ] ) t1 = row [ 1 ] t2 = row [ 2 ] t3 = row [ 3 ] t4 = row [ 4 ] u1 = float ( row [ 5 ] ) v1 = float ( row [ 6 ] ) u2 = float ( row [ 7 ] ) v2 = float ( row [ 8 ] ) u3 = float ( row [ 9 ] ) v3 = float ( row [ 10 ] ) u4 = float ( row [ 11 ] ) v4 = float ( row [ 12 ] ) camp = float ( row [ 13 ] ) sigmacamp = float ( row [ 14 ] ) datatable2 . append ( np . array ( ( time , t1 , t2 , t3 , t4 , u1 , v1 , u2 , v2 , u3 , v3 , u4 , v4 , camp , sigmacamp ) , dtype = DTCAMP ) )  obs . camp = np . array ( datatable2 )  elif dtype == <str> :          datatable2 = [ ] for row in datatable :              time = float ( row [ 0 ] ) t1 = row [ 1 ] t2 = row [ 2 ] t3 = row [ 3 ] u1 = float ( row [ 4 ] ) v1 = float ( row [ 5 ] ) u2 = float ( row [ 6 ] ) v2 = float ( row [ 7 ] ) u3 = float ( row [ 8 ] ) v3 = float ( row [ 9 ] ) bispec = float ( row [ 10 ] ) sigmab = float ( row [ 11 ] ) datatable2 . append ( np . array ( ( time , t1 , t2 , t3 , u1 , v1 , u2 , v2 , u3 , v3 , bispec , sigmab ) , dtype = DTBIS ) )  obs . bispec = np . array ( datatable2 )  elif dtype == <str> :          datatable2 = [ ] for row in datatable :              time = float ( row [ 0 ] ) tint = float ( row [ 1 ] ) t1 = row [ 2 ] t2 = row [ 3 ] u = float ( row [ 4 ] ) v = float ( row [ 5 ] ) amp = float ( row [ 6 ] ) sigmaamp = float ( row [ 7 ] ) datatable2 . append ( np . array ( ( time , tint , t1 , t2 , u , v , amp , sigmaamp ) , dtype = DTAMP ) )  obs . amp = np . array ( datatable2 )  else :          raise Exception ( dtype + <str> )  return   