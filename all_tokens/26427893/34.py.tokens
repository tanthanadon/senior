from __future__ import division import math import numpy as np import scipy . special as spec def deltaPulse2D ( x , y , pdim , dom = <str> ) :      if dom == <str> :          if x == y == 0.0 : return 1.0 else : return 0.0  elif dom == <str> :          return 1.0   def rectPulse2D ( x , y , pdim , dom = <str> ) :      if dom == <str> :          return rectPulse_I ( x , pdim ) * rectPulse_I ( y , pdim )  elif dom == <str> :          return rectPulse_F ( x , pdim ) * rectPulse_F ( y , pdim )   def rectPulse_I ( x , pdim ) :      if abs ( x ) >= pdim / 2.0 :          return 0.0  else :          return 1.0 / pdim   def rectPulse_F ( omega , pdim ) :      if ( omega == 0 ) :          return 1.0  else :          return ( 2.0 / ( pdim * omega ) ) * math . sin ( ( pdim * omega ) / 2.0 )   def trianglePulse2D ( x , y , pdim , dom = <str> ) :      if dom == <str> :          return trianglePulse_I ( x , pdim ) * trianglePulse_I ( y , pdim )  elif dom == <str> :          return trianglePulse_F ( x , pdim ) * trianglePulse_F ( y , pdim )   def trianglePulse_I ( x , pdim ) :      if abs ( x ) > pdim : return 0.0 else : return - ( 1.0 / ( pdim ** 2 ) ) * abs ( x ) + 1.0 / pdim  def trianglePulse_F ( omega , pdim ) :      if ( omega == 0 ) :          return 1.0  else :          return ( 4.0 / ( pdim ** 2 * omega ** 2 ) ) * ( math . sin ( ( pdim * omega ) / 2.0 ) ) ** 2   def GaussPulse2D ( x , y , pdim , dom = <str> ) :      sigma = pdim / 3. a = 1. / 2. / sigma / sigma if dom == <str> :          return ( a / np . pi ) * np . exp ( - a * ( x ** 2 + y ** 2 ) )  elif dom == <str> :          return np . exp ( - ( x ** 2 + y ** 2 ) / 4. / a )   def cubicPulse2D ( x , y , pdim , dom = <str> ) :      if dom == <str> :          return cubicPulse_I ( x , pdim ) * cubicPulse_I ( y , pdim )  elif dom == <str> :          return cubicPulse_F ( x , pdim ) * cubicPulse_F ( y , pdim )   def cubicPulse_I ( x , pdim ) :      if abs ( x ) < pdim : return ( 1.5 * ( abs ( x ) / pdim ) ** 3 - 2.5 * ( x / pdim ) ** 2 + 1. ) / pdim elif abs ( abs ( x ) - 1.5 * pdim ) <= 0.5 * pdim : return ( - 0.5 * ( abs ( x ) / pdim ) ** 3 + 2.5 * ( x / pdim ) ** 2 - 4. * ( abs ( x ) / pdim ) + 2. ) / pdim else : return 0.  def cubicPulse_F ( omega , pdim ) :      if ( omega == 0 ) :          return 1.0  else :          return 2. * ( ( 3. / omega / pdim ) * math . sin ( omega * pdim / 2. ) - math . cos ( omega * pdim / 2. ) ) * ( ( 2. / omega / pdim ) * math . sin ( omega * pdim / 2. ) ) ** 3   def sincPulse2D ( x , y , pdim , dom = <str> ) :      if dom == <str> :          return sincPulse_I ( x , pdim ) * sincPulse_I ( y , pdim )  elif dom == <str> :          return sincPulse_F ( x , pdim ) * sincPulse_F ( y , pdim )   def sincPulse_I ( x , pdim ) :      if ( x == 0 ) :          return 1. / pdim  else : return ( 1. / pdim ) * math . sin ( np . pi * x / pdim ) / ( np . pi * x / pdim )  def sincPulse_F ( omega , pdim ) :      if ( abs ( omega ) < np . pi / pdim ) :          return 1.0  else :          return 0.    