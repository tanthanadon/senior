from __future__ import division from __future__ import print_function from builtins import str from builtins import range from builtins import object import numpy as np import numpy . matlib as matlib import matplotlib as mpl import matplotlib . pyplot as plt import scipy . optimize as opt import scipy . signal import scipy . ndimage . filters as filt import scipy . interpolate from scipy import ndimage as ndi from skimage . feature import canny from skimage . transform import hough_circle , hough_circle_peaks import ehtim . observing . obs_simulate as simobs import ehtim . observing . pulses import ehtim . io . save import ehtim . io . load from ehtim . const_def import * from ehtim . observing . obs_helpers import * class Image ( object ) :      def __init__ ( self , image , psize , ra , dec , pa = 0.0 , polrep = <str> , pol_prim = None , rf = RF_DEFAULT , pulse = PULSE_DEFAULT , source = SOURCE_DEFAULT , mjd = MJD_DEFAULT , time = 0. ) :          if len ( image . shape ) != 2 :              raise Exception ( <str> )  if not polrep in [ <str> , <str> ] :              raise Exception ( <str> )  imvec = image . flatten ( ) if polrep == <str> :              if pol_prim is None : pol_prim = <str> if pol_prim == <str> :                  self . _imdict = { <str> : imvec , <str> : [ ] , <str> : [ ] , <str> : [ ] }  elif pol_prim == <str> :                  self . _imdict = { <str> : [ ] , <str> : [ ] , <str> : [ ] , <str> : imvec }  elif pol_prim == <str> :                  self . _imdict = { <str> : [ ] , <str> : imvec , <str> : [ ] , <str> : [ ] }  elif pol_prim == <str> :                  self . _imdict = { <str> : [ ] , <str> : [ ] , <str> : imvec , <str> : [ ] }  else :                  raise Exception ( <str> )   elif polrep == <str> :              if pol_prim is None :                  print ( <str> ) pol_prim = <str>  if pol_prim == <str> :                  self . _imdict = { <str> : imvec , <str> : [ ] , <str> : [ ] , <str> : [ ] }  elif pol_prim == <str> :                  self . _imdict = { <str> : [ ] , <str> : imvec , <str> : [ ] , <str> : [ ] }  else :                  raise Exception ( <str> )   else :              raise Excpetion ( <str> )  self . pol_prim = pol_prim self . polrep = polrep self . pulse = pulse self . psize = float ( psize ) self . xdim = image . shape [ 1 ] self . ydim = image . shape [ 0 ] self . ra = float ( ra ) self . dec = float ( dec ) self . pa = float ( pa ) self . rf = float ( rf ) self . source = str ( source ) self . mjd = int ( mjd ) self . cached_fft = { } if time > 24 :              self . mjd += int ( ( time - time % 24 ) / 24 ) self . time = float ( time % 24 )  else :              self . time = time   @ property def imvec ( self ) :          imvec = self . _imdict [ self . pol_prim ] return imvec  @ imvec . setter def imvec ( self , vec ) :          if len ( vec ) != self . xdim * self . ydim :              raise Exception ( <str> )  self . _imdict [ self . pol_prim ] = vec  @ property def ivec ( self ) :          if self . polrep != <str> :              raise Exception ( <str> )  ivec = self . _imdict [ <str> ] return ivec  @ ivec . setter def ivec ( self , vec ) :          if len ( vec ) != self . xdim * self . ydim :              raise Exception ( <str> )  self . _imdict [ <str> ] = vec  @ property def qvec ( self ) :          if self . polrep != <str> :              raise Exception ( <str> )  qvec = self . _imdict [ <str> ] return qvec  @ qvec . setter def qvec ( self , vec ) :          if len ( vec ) != self . xdim * self . ydim :              raise Exception ( <str> )  self . _imdict [ <str> ] = vec  @ property def uvec ( self ) :          if self . polrep != <str> :              raise Exception ( <str> )  uvec = self . _imdict [ <str> ] return uvec  @ uvec . setter def uvec ( self , vec ) :          if len ( vec ) != self . xdim * self . ydim :              raise Exception ( <str> )  self . _imdict [ <str> ] = vec  @ property def vvec ( self ) :          if self . polrep != <str> :              raise Exception ( <str> )  vvec = self . _imdict [ <str> ] return vvec  @ vvec . setter def vvec ( self , vec ) :          if len ( vec ) != self . xdim * self . ydim :              raise Exception ( <str> )  self . _imdict [ <str> ] = vec  @ property def rrvec ( self ) :          if self . polrep != <str> :              raise Exception ( <str> )  rrvec = self . _imdict [ <str> ] return rrvec  @ rrvec . setter def rrvec ( self , vec ) :          if len ( vec ) != self . xdim * self . ydim :              raise Exception ( <str> )  self . _imdict [ <str> ] = vec  @ property def llvec ( self ) :          if self . polrep != <str> :              raise Exception ( <str> )  llvec = self . _imdict [ <str> ] return llvec  @ llvec . setter def llvec ( self , vec ) :          if len ( vec ) != self . xdim * self . ydim :              raise Exception ( <str> )  self . _imdict [ <str> ] = vec  @ property def rlvec ( self ) :          if self . polrep != <str> :              raise Exception ( <str> )  rlvec = self . _imdict [ <str> ] return rlvec  @ rlvec . setter def rlvec ( self , vec ) :          if len ( vec ) != self . xdim * self . ydim :              raise Exception ( <str> )  self . _imdict [ <str> ] = vec  @ property def lrvec ( self ) :          if self . polrep != <str> :              raise Exception ( <str> )  lrvec = self . _imdict [ <str> ] return lrvec  @ lrvec . setter def lrvec ( self , vec ) :          if len ( vec ) != self . xdim * self . ydim :              raise Exception ( <str> )  self . _imdict [ <str> ] = vec  def copy ( self ) :          newim = Image ( self . imvec . reshape ( self . ydim , self . xdim ) , self . psize , self . ra , self . dec , self . pa , polrep = self . polrep , pol_prim = self . pol_prim , time = self . time , rf = self . rf , source = self . source , mjd = self . mjd , pulse = self . pulse ) newim . copy_pol_images ( self ) return newim  def copy_pol_images ( self , old_image ) :          for pol in list ( self . _imdict . keys ( ) ) :              if ( pol == self . pol_prim ) :                  continue  polvec = old_image . _imdict [ pol ] if len ( polvec ) :                  self . add_pol_image ( polvec . reshape ( self . ydim , self . xdim ) , pol )    def add_pol_image ( self , image , pol ) :          if pol == self . pol_prim :              raise Exception ( <str> )  if image . shape != ( self . ydim , self . xdim ) :              raise Exception ( <str> )  if not ( pol in list ( self . _imdict . keys ( ) ) ) :              raise Exception ( <str> % self . polrep + <str> . join ( list ( self . _imdict . keys ( ) ) ) )  if self . polrep == <str> :              if pol == <str> : self . ivec = image . flatten ( ) elif pol == <str> : self . qvec = image . flatten ( ) elif pol == <str> : self . uvec = image . flatten ( ) elif pol == <str> : self . vvec = image . flatten ( )  elif self . polrep == <str> :              if pol == <str> : self . rrvec = image . flatten ( ) elif pol == <str> : self . llvec = image . flatten ( ) elif pol == <str> : self . rlvec = image . flatten ( ) elif pol == <str> : self . lrvec = image . flatten ( )  return  def add_qu ( self , qimage , uimage ) :          if self . polrep != <str> :              raise Exception ( <str> )  self . add_pol_image ( qimage , <str> ) self . add_pol_image ( uimage , <str> ) return  def add_v ( self , vimage ) :          if self . polrep != <str> :              raise Exception ( <str> )  self . add_pol_image ( vimage , <str> ) return  def switch_polrep ( self , polrep_out = <str> , pol_prim_out = None ) :          if polrep_out not in [ <str> , <str> ] :              raise Exception ( <str> )  if pol_prim_out is None :              if polrep_out == <str> : pol_prim_out = <str> elif polrep_out == <str> : pol_prim_out = <str>  if polrep_out == self . polrep and pol_prim_out == self . pol_prim :              return self . copy ( )  if polrep_out == <str> :              if self . polrep == <str> :                  imdict = { <str> : self . ivec , <str> : self . qvec , <str> : self . uvec , <str> : self . vvec }  else :                  if len ( self . rrvec ) == 0 or len ( self . llvec ) == 0 :                      ivec = [ ] vvec = [ ]  else :                      ivec = 0.5 * ( self . rrvec + self . llvec ) vvec = 0.5 * ( self . rrvec - self . llvec )  if len ( self . rlvec ) == 0 or len ( self . lrvec ) == 0 :                      qvec = [ ] uvec = [ ]  else :                      qvec = np . real ( 0.5 * ( self . lrvec + self . rlvec ) ) uvec = np . real ( 0.5j * ( self . lrvec - self . rlvec ) )  imdict = { <str> : ivec , <str> : qvec , <str> : uvec , <str> : vvec }   elif polrep_out == <str> :              if self . polrep == <str> :                  imdict = { <str> : self . rrvec , <str> : self . llvec , <str> : self . rlvec , <str> : self . lrvec }  else :                  if len ( self . ivec ) == 0 or len ( self . vvec ) == 0 :                      rrvec = [ ] llvec = [ ]  else :                      rrvec = ( self . ivec + self . vvec ) llvec = ( self . ivec - self . vvec )  if len ( self . qvec ) == 0 or len ( self . uvec ) == 0 :                      rlvec = [ ] lrvec = [ ]  else :                      rlvec = ( self . qvec + 1j * self . uvec ) lrvec = ( self . qvec - 1j * self . uvec )  imdict = { <str> : rrvec , <str> : llvec , <str> : rlvec , <str> : lrvec }   imvec = imdict [ pol_prim_out ] if len ( imvec ) == 0 :              raise Exception ( <str> % ( polrep_out , pol_prim_out ) + <str> )  newim = Image ( imvec . reshape ( self . ydim , self . xdim ) , self . psize , self . ra , self . dec , self . pa , polrep = polrep_out , pol_prim = pol_prim_out , time = self . time , rf = self . rf , source = self . source , mjd = self . mjd , pulse = self . pulse ) for pol in list ( imdict . keys ( ) ) :              if pol == newim . pol_prim : continue polvec = imdict [ pol ] if len ( polvec ) :                  newim . add_pol_image ( polvec . reshape ( self . ydim , self . xdim ) , pol )   return newim  def flip_chi ( self ) :          im = self . copy ( ) if im . polrep == <str> :              im . qvec *= - 1  elif im . polrep == <str> :              im . lrvec = - np . conjugate ( im . lrvec ) im . rlvec = - np . conjugate ( im . rlvec )  return im  def orth_chi ( self ) :          im = self . copy ( ) if im . polrep == <str> :              im . uvec *= - 1  elif im . polrep == <str> :              im . lrvec = np . conjugate ( im . rlvec ) im . rlvec = np . conjugate ( im . rlvec )  return im  def imarr ( self , pol = None ) :          if pol is None : pol = self . pol_prim imarr = np . array ( [ ] ) if self . polrep == <str> :              if pol == <str> and len ( self . ivec ) : imarr = self . ivec . reshape ( self . ydim , self . xdim ) elif pol == <str> and len ( self . qvec ) : imarr = self . qvec . reshape ( self . ydim , self . xdim ) elif pol == <str> and len ( self . uvec ) : imarr = self . uvec . reshape ( self . ydim , self . xdim ) elif pol == <str> and len ( self . vvec ) : imarr = self . vvec . reshape ( self . ydim , self . xdim )  elif self . polrep == <str> :              if pol == <str> and len ( self . rrvec ) : imarr = self . rrvec . reshape ( self . ydim , self . xdim ) elif pol == <str> and len ( self . llvec ) : imarr = self . llvec . reshape ( self . ydim , self . xdim ) elif pol == <str> and len ( self . rlvec ) : imarr = self . rlvec . reshape ( self . ydim , self . xdim ) elif pol == <str> and len ( self . lrvec ) : imarr = self . lrvec . reshape ( self . ydim , self . xdim )  return imarr  def sourcevec ( self ) :          sourcevec = np . array ( [ np . cos ( self . dec * DEGREE ) , 0 , np . sin ( self . dec * DEGREE ) ] ) return sourcevec  def fovx ( self ) :          return self . psize * self . xdim  def fovy ( self ) :          return self . psize * self . ydim  def total_flux ( self ) :          if self . polrep == <str> :              flux = np . sum ( self . ivec )  elif self . polrep == <str> :              flux = 0.5 * ( np . sum ( self . rrvec ) + np . sum ( self . llvec ) )  return flux  def lin_polfrac ( self ) :          if self . polrep == <str> :              frac = np . abs ( np . sum ( self . qvec + 1j * self . uvec ) ) / np . abs ( np . sum ( self . ivec ) )  elif self . polrep == <str> :              frac = 2 * np . abs ( np . sum ( self . rlvec ) ) / np . abs ( np . sum ( self . rrvec + self . llvec ) )  return frac  def circ_polfrac ( self ) :          if self . polrep == <str> :              frac = np . sum ( self . vvec ) / np . abs ( np . sum ( self . ivec ) )  elif self . polrep == <str> :              frac = np . sum ( self . rrvec - self . llvec ) / np . abs ( np . sum ( self . rrvec + self . llvec ) )  return frac  def centroid ( self , pol = None ) :          if pol is None : pol = self . pol_prim if not ( pol in list ( self . _imdict . keys ( ) ) ) :              raise Exception ( <str> % self . polrep + <str> . join ( list ( self . _imdict . keys ( ) ) ) )  pdim = self . psize imvec = self . _imdict [ pol ] if len ( imvec ) :              xlist = np . arange ( 0 , - self . xdim , - 1 ) * pdim + ( pdim * self . xdim ) / 2.0 - pdim / 2.0 ylist = np . arange ( 0 , - self . ydim , - 1 ) * pdim + ( pdim * self . ydim ) / 2.0 - pdim / 2.0 x0 = np . sum ( np . outer ( 0.0 * ylist + 1.0 , xlist ) . ravel ( ) * imvec ) / np . sum ( imvec ) y0 = np . sum ( np . outer ( ylist , 0.0 * xlist + 1.0 ) . ravel ( ) * imvec ) / np . sum ( imvec ) centroid = np . array ( [ x0 , y0 ] )  else :              raise Exception ( <str> % pol )  return centroid  def pad ( self , fovx , fovy ) :          fovoldx = self . fovx ( ) fovoldy = self . fovy ( ) padx = int ( 0.5 * ( fovx - fovoldx ) / self . psize ) pady = int ( 0.5 * ( fovy - fovoldy ) / self . psize ) imarr = self . imvec . reshape ( self . ydim , self . xdim ) imarr = np . pad ( imarr , ( ( pady , pady ) , ( padx , padx ) ) , <str> ) outim = Image ( imarr , self . psize , self . ra , self . dec , self . pa , polrep = self . polrep , pol_prim = self . pol_prim , time = self . time , rf = self . rf , source = self . source , mjd = self . mjd , pulse = self . pulse ) for pol in list ( self . _imdict . keys ( ) ) :              if pol == self . pol_prim : continue polvec = self . _imdict [ pol ] if len ( polvec ) :                  polarr = polvec . reshape ( self . ydim , self . xdim ) polarr = np . pad ( polarr , ( ( pady , pady ) , ( padx , padx ) ) , <str> ) outim . add_pol_image ( polarr , pol )   return outim  def resample_square ( self , xdim_new , ker_size = 5 ) :          im = self if self . xdim != self . ydim :              raise Exception ( <str> )  if self . pulse == ehtim . observing . pulses . deltaPulse2D :              raise Exception ( <str> )  ydim_new = xdim_new fov = self . xdim * self . psize psize_new = float ( fov ) / float ( xdim_new ) ij = np . array ( [ [ [ i * self . psize + ( self . psize * self . xdim ) / 2.0 - self . psize / 2.0 , j * self . psize + ( self . psize * self . ydim ) / 2.0 - self . psize / 2.0 ] for i in np . arange ( 0 , - self . xdim , - 1 ) ] for j in np . arange ( 0 , - self . ydim , - 1 ) ] ) . reshape ( ( self . xdim * self . ydim , 2 ) ) def im_new_val ( imvec , x_idx , y_idx ) :              x = x_idx * psize_new + ( psize_new * xdim_new ) / 2.0 - psize_new / 2.0 y = y_idx * psize_new + ( psize_new * ydim_new ) / 2.0 - psize_new / 2.0 mask = ( ( ( x - ker_size * self . psize / 2.0 ) < ij [ : , 0 ] ) * ( ij [ : , 0 ] < ( x + ker_size * self . psize / 2.0 ) ) * ( ( y - ker_size * self . psize / 2.0 ) < ij [ : , 1 ] ) * ( ij [ : , 1 ] < ( y + ker_size * self . psize / 2.0 ) ) ) . flatten ( ) interp = np . sum ( [ imvec [ n ] * self . pulse ( x - ij [ n , 0 ] , y - ij [ n , 1 ] , self . psize , dom = <str> ) for n in np . arange ( len ( imvec ) ) [ mask ] ] ) return interp  def im_new ( imvec ) :              imarr_new = np . array ( [ [ im_new_val ( imvec , x_idx , y_idx ) for x_idx in np . arange ( 0 , - xdim_new , - 1 ) ] for y_idx in np . arange ( 0 , - ydim_new , - 1 ) ] ) return imarr_new  imarr_new = im_new ( self . imvec ) scaling = np . sum ( self . imvec ) / np . sum ( imarr_new ) imarr_new *= scaling outim = Image ( imarr_new , psize_new , self . ra , self . dec , self . pa , polrep = self . polrep , pol_prim = self . pol_prim , time = self . time , rf = self . rf , source = self . source , mjd = self . mjd , pulse = self . pulse ) for pol in list ( self . _imdict . keys ( ) ) :              if pol == self . pol_prim : continue polvec = self . _imdict [ pol ] if len ( polvec ) :                  polarr_new = im_new ( polvec ) polarr_new *= scaling outim . add_pol_image ( polarr_new , pol )   return outim  def regrid_image ( self , targetfov , npix , interp = <str> ) :          psize_new = float ( targetfov ) / float ( npix ) fov_x = self . fovx ( ) fov_y = self . fovy ( ) x = np . linspace ( - fov_x / 2 , fov_x / 2 , self . xdim ) y = np . linspace ( - fov_y / 2 , fov_y / 2 , self . ydim ) xtarget = np . linspace ( - targetfov / 2 , targetfov / 2 , npix ) ytarget = np . linspace ( - targetfov / 2 , targetfov / 2 , npix ) def interp_imvec ( imvec ) :              if np . any ( np . imag ( imvec ) != 0 ) :                  return interp_imvec ( np . real ( imvec ) ) + 1j * interp_imvec ( np . imag ( imvec ) )  interpfunc = scipy . interpolate . interp2d ( y , x , np . reshape ( imvec , ( self . ydim , self . xdim ) ) , kind = interp ) tmpimg = interpfunc ( ytarget , xtarget ) tmpimg [ np . abs ( xtarget ) > fov_x / 2. , : ] = 0.0 tmpimg [ : , np . abs ( ytarget ) > fov_y / 2. ] = 0.0 tmpimg = tmpimg * ( psize_new ) ** 2 / self . psize ** 2 return tmpimg  imarr_new = interp_imvec ( self . imvec ) outim = Image ( imarr_new , psize_new , self . ra , self . dec , self . pa , polrep = self . polrep , pol_prim = self . pol_prim , time = self . time , rf = self . rf , source = self . source , mjd = self . mjd , pulse = self . pulse ) for pol in list ( self . _imdict . keys ( ) ) :              if pol == self . pol_prim : continue polvec = self . _imdict [ pol ] if len ( polvec ) :                  polarr_new = interp_imvec ( polvec ) outim . add_pol_image ( polarr_new , pol )   return outim  def rotate ( self , angle , interp = <str> ) :          order = 3 if interp == <str> : order = 1 elif interp == <str> : order = 3 elif interp == <str> : order = 5 def rot_imvec ( imvec ) :              if np . any ( np . imag ( imvec ) != 0 ) :                  return rot_imvec ( np . real ( imvec ) ) + 1j * rot_imvec ( np . imag ( imvec ) )  imarr_rot = scipy . ndimage . interpolation . rotate ( imvec . reshape ( ( self . ydim , self . xdim ) ) , angle * 180.0 / np . pi , reshape = False , order = order , mode = <str> , cval = 0.0 , prefilter = True ) return imarr_rot  imarr_rot = rot_imvec ( self . imvec ) outim = Image ( imarr_rot , self . psize , self . ra , self . dec , self . pa , polrep = self . polrep , pol_prim = self . pol_prim , time = self . time , rf = self . rf , source = self . source , mjd = self . mjd , pulse = self . pulse ) for pol in list ( self . _imdict . keys ( ) ) :              if pol == self . pol_prim : continue polvec = self . _imdict [ pol ] if len ( polvec ) :                  polarr_rot = rot_imvec ( polvec ) outim . add_pol_image ( polarr_rot , pol )   return outim  def shift ( self , shiftidx ) :          def shift_imvec ( imvec ) :              im_shift = np . roll ( imvec . reshape ( self . ydim , self . xdim ) , shiftidx [ 0 ] , axis = 0 ) im_shift = np . roll ( im_shift , shiftidx [ 1 ] , axis = 1 ) return im_shift  imarr_shift = shift_imvec ( self . imvec ) outim = Image ( imarr_shift , self . psize , self . ra , self . dec , self . pa , polrep = self . polrep , pol_prim = self . pol_prim , time = self . time , rf = self . rf , source = self . source , mjd = self . mjd , pulse = self . pulse ) for pol in list ( self . _imdict . keys ( ) ) :              if pol == self . pol_prim : continue polvec = self . _imdict [ pol ] if len ( polvec ) :                  polarr_shift = shift_imvec ( polvec ) outim . add_pol_image ( polarr_shift , pol )   return outim  def blur_gauss ( self , beamparams , frac = 1. , frac_pol = 0 ) :          if frac <= 0.0 or beamparams [ 0 ] <= 0 :              return self . copy ( )  xlist = np . arange ( 0 , - self . xdim , - 1 ) * self . psize + ( self . psize * self . xdim ) / 2.0 - self . psize / 2.0 ylist = np . arange ( 0 , - self . ydim , - 1 ) * self . psize + ( self . psize * self . ydim ) / 2.0 - self . psize / 2.0 sigma_maj = beamparams [ 0 ] / ( 2. * np . sqrt ( 2. * np . log ( 2. ) ) ) sigma_min = beamparams [ 1 ] / ( 2. * np . sqrt ( 2. * np . log ( 2. ) ) ) cth = np . cos ( beamparams [ 2 ] ) sth = np . sin ( beamparams [ 2 ] ) def gaussim ( blurfrac ) :              gauss = np . array ( [ [ np . exp ( - ( j * cth + i * sth ) ** 2 / ( 2 * ( blurfrac * sigma_maj ) ** 2 ) - ( i * cth - j * sth ) ** 2 / ( 2. * ( blurfrac * sigma_min ) ** 2 ) ) for i in xlist ] for j in ylist ] ) gauss = gauss [ 0 : self . ydim , 0 : self . xdim ] gauss = gauss / np . sum ( gauss ) return gauss  gauss = gaussim ( frac ) if frac_pol :              gausspol = gaussim ( frac_pol )  def blur ( imarr , gauss ) :              imarr_blur = scipy . signal . fftconvolve ( gauss , imarr , mode = <str> ) return imarr_blur  imarr = ( self . imvec ) . reshape ( self . ydim , self . xdim ) outim = Image ( blur ( imarr , gauss ) , self . psize , self . ra , self . dec , self . pa , polrep = self . polrep , pol_prim = self . pol_prim , time = self . time , rf = self . rf , source = self . source , mjd = self . mjd , pulse = self . pulse ) for pol in list ( self . _imdict . keys ( ) ) :              if pol == self . pol_prim : continue polvec = self . _imdict [ pol ] if len ( polvec ) :                  polarr = polvec . reshape ( self . ydim , self . xdim ) if frac_pol :                      polarr = blur ( polarr , gauss )  outim . add_pol_image ( polarr , pol )   return outim  def blur_circ ( self , fwhm_i , fwhm_pol = 0 ) :          sigma = fwhm_i / ( 2. * np . sqrt ( 2. * np . log ( 2. ) ) ) sigmap = sigma / self . psize def blur ( imarr , sigma ) :              if np . any ( np . imag ( imarr ) != 0 ) :                  return blur ( np . real ( imarr ) , sigma ) + 1j * blur ( np . imag ( imarr ) , sigma )  imarr_blur = filt . gaussian_filter ( imarr , ( sigma , sigma ) ) return imarr_blur  imarr = self . imvec . reshape ( self . ydim , self . xdim ) imarr = blur ( imarr , sigmap ) outim = Image ( imarr , self . psize , self . ra , self . dec , self . pa , polrep = self . polrep , pol_prim = self . pol_prim , time = self . time , rf = self . rf , source = self . source , mjd = self . mjd , pulse = self . pulse ) for pol in list ( self . _imdict . keys ( ) ) :              if pol == self . pol_prim : continue polvec = self . _imdict [ pol ] if len ( polvec ) :                  polarr = polvec . reshape ( self . ydim , self . xdim ) if fwhm_pol :                      print ( <str> ) sigma = fwhm_pol / ( 2. * np . sqrt ( 2. * np . log ( 2. ) ) ) sigmap = sigma / self . psize polarr = blur ( polarr , sigmap )  outim . add_pol_image ( polarr , pol )   return outim  def grad ( self , gradtype = <str> ) :          def gradim ( imvec ) :              if np . any ( np . imag ( imvec ) != 0 ) :                  return gradim ( np . real ( imvec ) ) + 1j * gradim ( np . imag ( imvec ) )  imarr = imvec . reshape ( self . ydim , self . xdim ) sx = ndi . sobel ( imarr , axis = 0 , mode = <str> ) sy = ndi . sobel ( imarr , axis = 1 , mode = <str> ) if gradtype == <str> :                  gradarr = sx  if gradtype == <str> :                  gradarr = sy  else :                  gradarr = np . hypot ( sx , sy )  return gradarr  gradarr = gradim ( self . imvec ) outim = Image ( gradarr , self . psize , self . ra , self . dec , self . pa , polrep = self . polrep , pol_prim = self . pol_prim , time = self . time , rf = self . rf , source = self . source , mjd = self . mjd , pulse = self . pulse ) for pol in list ( self . _imdict . keys ( ) ) :              if pol == self . pol_prim : continue polvec = self . _imdict [ pol ] if len ( polvec ) :                  gradarr = gradim ( polvec ) outim . add_pol_image ( gradarr , pol )   return outim  def mask ( self , cutoff = 0.05 , beamparams = None , frac = 0.0 ) :          if not beamparams is None :              try : len ( beamparams ) except TypeError :                  beamparams = [ beamparams , beamparams , 0 ]  if len ( beamparams ) == 3 :                  mask = self . blur_gauss ( beamparams , frac )  else :                  raise Exception ( <str> )   else :              mask = self . copy ( )  maxval = np . max ( mask . imvec ) minval = np . min ( mask . imvec ) intensityrange = maxval - minval thresh = intensityrange * cutoff + minval maskvec = ( mask . imvec > thresh ) . astype ( int ) maskarr = maskvec . reshape ( mask . ydim , mask . xdim ) mask = Image ( maskarr , self . psize , self . ra , self . dec , self . pa , polrep = self . polrep , pol_prim = self . pol_prim , time = self . time , rf = self . rf , source = self . source , mjd = self . mjd , pulse = self . pulse ) for pol in list ( self . _imdict . keys ( ) ) :              if pol == self . pol_prim : continue mask . add_pol_image ( maskarr , pol )  return mask  def apply_mask ( self , mask_im , fill_val = 0. ) :          if ( self . psize != mask_im . psize ) or ( self . xdim != mask_im . xdim ) or ( self . ydim != mask_im . ydim ) :              raise Exception ( <str> )  maskvec = mask_im . imvec . astype ( bool ) maskvec [ maskvec <= 0 ] = 0 maskvec [ maskvec > 0 ] = 1 imvec = self . imvec imvec [ ~ maskvec ] = fill_val outim = Image ( imvec . reshape ( self . ydim , self . xdim ) , self . psize , self . ra , self . dec , self . pa , polrep = self . polrep , pol_prim = self . pol_prim , time = self . time , rf = self . rf , source = self . source , mjd = self . mjd , pulse = self . pulse ) for pol in list ( self . _imdict . keys ( ) ) :              if pol == self . pol_prim : continue polvec = self . _imdict [ pol ] if len ( polvec ) :                  polvec [ ~ maskvec ] = fill_val outim . add_pol_image ( polvec . reshape ( self . ydim , self . xdim ) , pol )   return outim  def threshold ( self , cutoff = 0.05 , frac_i = None , beamparams = None , frac = 0.0 , fill_val = None ) :          if not ( frac_i is None ) :              cutoff = frac_i print ( <str> )  if fill_val is None or fill_val == False :              maxval = np . max ( self . imvec ) minval = np . min ( self . imvec ) intensityrange = maxval - minval fill_val = ( intensityrange * cutoff + minval )  mask = self . mask ( cutoff = cutoff , beamparams = beamparams , frac = frac ) out = self . apply_mask ( mask , fill_val = fill_val ) return out  def add_flat ( self , flux , pol = None ) :          if pol is None : pol = self . pol_prim if not ( pol in list ( self . _imdict . keys ( ) ) ) :              raise Exception ( <str> % self . polrep + <str> . join ( list ( self . _imdict . keys ( ) ) ) )  if not len ( self . _imdict [ pol ] ) :              raise Exception ( <str> % pol )  flatarr = ( ( flux / float ( len ( self . imvec ) ) ) * np . ones ( len ( self . imvec ) ) ) . reshape ( self . ydim , self . xdim ) imarr = self . imvec . reshape ( self . ydim , self . xdim ) . copy ( ) if pol == self . pol_prim :              imarr += flatarr  outim = Image ( imarr , self . psize , self . ra , self . dec , self . pa , polrep = self . polrep , pol_prim = self . pol_prim , time = self . time , rf = self . rf , source = self . source , mjd = self . mjd , pulse = self . pulse ) for pol2 in list ( self . _imdict . keys ( ) ) :              if pol2 == self . pol_prim : continue polvec = self . _imdict [ pol2 ] if len ( polvec ) :                  polarr = polvec . reshape ( self . ydim , self . xdim ) . copy ( ) if pol2 == pol :                      polarr += flatarr  outim . add_pol_image ( polarr , pol2 )   return outim  def add_tophat ( self , flux , radius , pol = None ) :          if pol is None : pol = self . pol_prim if not ( pol in list ( self . _imdict . keys ( ) ) ) :              raise Exception ( <str> % self . polrep + <str> . join ( list ( self . _imdict . keys ( ) ) ) )  if not len ( self . _imdict [ pol ] ) :              raise Exception ( <str> % pol )  xlist = np . arange ( 0 , - self . xdim , - 1 ) * self . psize + ( self . psize * self . xdim ) / 2.0 - self . psize / 2.0 ylist = np . arange ( 0 , - self . ydim , - 1 ) * self . psize + ( self . psize * self . ydim ) / 2.0 - self . psize / 2.0 hatarr = np . array ( [ [ 1.0 if np . sqrt ( i ** 2 + j ** 2 ) <= radius else 0. for i in xlist ] for j in ylist ] ) hatarr = hatarr [ 0 : self . ydim , 0 : self . xdim ] hatarr *= flux / np . sum ( hatarr ) imarr = self . imvec . reshape ( self . ydim , self . xdim ) . copy ( ) if pol == self . pol_prim :              imarr += hatarr  outim = Image ( imarr , self . psize , self . ra , self . dec , self . pa , polrep = self . polrep , pol_prim = self . pol_prim , time = self . time , rf = self . rf , source = self . source , mjd = self . mjd , pulse = self . pulse ) for pol2 in list ( self . _imdict . keys ( ) ) :              if pol2 == self . pol_prim : continue polvec = self . _imdict [ pol2 ] if len ( polvec ) :                  polarr = polvec . reshape ( self . ydim , self . xdim ) . copy ( ) if pol2 == pol :                      polarr += hatarr  outim . add_pol_image ( polarr , pol2 )   return outim  def add_gauss ( self , flux , beamparams , pol = None ) :          if pol is None : pol = self . pol_prim if not ( pol in list ( self . _imdict . keys ( ) ) ) :              raise Exception ( <str> % self . polrep + <str> . join ( list ( self . _imdict . keys ( ) ) ) )  if not len ( self . _imdict [ pol ] ) :              raise Exception ( <str> % pol )  try :              x = beamparams [ 3 ] y = beamparams [ 4 ]  except IndexError :              x = y = 0.0  sigma_maj = beamparams [ 0 ] / ( 2. * np . sqrt ( 2. * np . log ( 2. ) ) ) sigma_min = beamparams [ 1 ] / ( 2. * np . sqrt ( 2. * np . log ( 2. ) ) ) cth = np . cos ( beamparams [ 2 ] ) sth = np . sin ( beamparams [ 2 ] ) xlist = np . arange ( 0 , - self . xdim , - 1 ) * self . psize + ( self . psize * self . xdim ) / 2.0 - self . psize / 2.0 ylist = np . arange ( 0 , - self . ydim , - 1 ) * self . psize + ( self . psize * self . ydim ) / 2.0 - self . psize / 2.0 def gaussian ( x2 , y2 ) :              gauss = np . exp ( - ( ( y2 ) * cth + ( x2 ) * sth ) ** 2 / ( 2 * sigma_maj ** 2 ) + - ( ( x2 ) * cth - ( y2 ) * sth ) ** 2 / ( 2 * sigma_min ** 2 ) ) return gauss  gaussarr = np . array ( [ [ gaussian ( i - x , j - y ) for i in xlist ] for j in ylist ] ) gaussarr = gaussarr [ 0 : self . ydim , 0 : self . xdim ] gaussarr *= flux / np . sum ( gaussarr ) imarr = self . imvec . reshape ( self . ydim , self . xdim ) . copy ( ) if pol == self . pol_prim :              imarr += gaussarr  outim = Image ( imarr , self . psize , self . ra , self . dec , self . pa , polrep = self . polrep , pol_prim = self . pol_prim , time = self . time , rf = self . rf , source = self . source , mjd = self . mjd , pulse = self . pulse ) for pol2 in list ( self . _imdict . keys ( ) ) :              if pol2 == self . pol_prim : continue polvec = self . _imdict [ pol2 ] if len ( polvec ) :                  polarr = polvec . reshape ( self . ydim , self . xdim ) . copy ( ) if pol2 == pol :                      polarr += gaussarr  outim . add_pol_image ( polarr , pol2 )   return outim  def add_crescent ( self , flux , Rp , Rn , a , b , x = 0 , y = 0 , pol = None ) :          if pol is None : pol = self . pol_prim if not ( pol in list ( self . _imdict . keys ( ) ) ) :              raise Exception ( <str> % self . polrep + <str> . join ( list ( self . _imdict . keys ( ) ) ) )  if not len ( self . _imdict [ pol ] ) :              raise Exception ( <str> % pol )  xlist = np . arange ( 0 , - self . xdim , - 1 ) * self . psize + ( self . psize * self . xdim ) / 2.0 - self . psize / 2.0 ylist = np . arange ( 0 , - self . ydim , - 1 ) * self . psize + ( self . psize * self . ydim ) / 2.0 - self . psize / 2.0 def crescent ( x2 , y2 ) :              if ( x2 - a ) ** 2 + ( y2 - b ) ** 2 > Rn ** 2 and x2 ** 2 + y2 ** 2 < Rp ** 2 :                  return 1.0  else :                  return 0.0   crescarr = np . array ( [ [ crescent ( i - x , j - y ) for i in xlist ] for j in ylist ] ) crescarr = crescarr [ 0 : self . ydim , 0 : self . xdim ] crescarr *= flux / np . sum ( crescarr ) imarr = self . imvec . reshape ( self . ydim , self . xdim ) . copy ( ) if pol == self . pol_prim :              imarr += crescarr  outim = Image ( imarr , self . psize , self . ra , self . dec , self . pa , polrep = self . polrep , pol_prim = self . pol_prim , time = self . time , rf = self . rf , source = self . source , mjd = self . mjd , pulse = self . pulse ) for pol2 in list ( self . _imdict . keys ( ) ) :              if pol2 == self . pol_prim : continue polvec = self . _imdict [ pol2 ] if len ( polvec ) :                  polarr = polvec . reshape ( self . ydim , self . xdim ) . copy ( ) if pol2 == pol :                      polarr += crescarr  outim . add_pol_image ( polarr , pol2 )   return outim  def add_ring_m1 ( self , I0 , I1 , r0 , phi , sigma , x = 0 , y = 0 , pol = None ) :          if pol is None : pol = self . pol_prim if not ( pol in list ( self . _imdict . keys ( ) ) ) :              raise Exception ( <str> % self . polrep + <str> . join ( list ( self . _imdict . keys ( ) ) ) )  if not len ( self . _imdict [ pol ] ) :              raise Exception ( <str> % pol )  flux = I0 - 0.5 * I1 phi = phi + np . pi psize = self . psize xlist = np . arange ( 0 , - self . xdim , - 1 ) * self . psize + ( self . psize * self . xdim ) / 2.0 - self . psize / 2.0 ylist = np . arange ( 0 , - self . ydim , - 1 ) * self . psize + ( self . psize * self . ydim ) / 2.0 - self . psize / 2.0 def ringm1 ( x2 , y2 ) :              if ( x2 ** 2 + y2 ** 2 ) > ( r0 - psize ) ** 2 and ( x2 ** 2 + y2 ** 2 ) < ( r0 + psize ) ** 2 :                  theta = np . arctan2 ( y2 , x2 ) flux = ( I0 - 0.5 * I1 * ( 1 + np . cos ( theta - phi ) ) ) / ( 2 * np . pi * r0 ) return flux  else :                  return 0.0   ringarr = np . array ( [ [ ringm1 ( i - x , j - y ) for i in xlist ] for j in ylist ] ) ringarr = ringarr [ 0 : self . ydim , 0 : self . xdim ] tmp = Image ( ringarr , self . psize , self . ra , self . dec , self . pa , rf = self . rf , source = self . source , mjd = self . mjd , pulse = self . pulse ) tmp = tmp . blur_circ ( sigma ) tmp . imvec *= flux / ( tmp . total_flux ( ) ) ringarr = tmp . imvec . reshape ( self . ydim , self . xdim ) imarr = self . imvec . reshape ( self . ydim , self . xdim ) . copy ( ) if pol == self . pol_prim :              imarr += ringarr  outim = Image ( imarr , self . psize , self . ra , self . dec , self . pa , polrep = self . polrep , pol_prim = self . pol_prim , time = self . time , rf = self . rf , source = self . source , mjd = self . mjd , pulse = self . pulse ) for pol2 in list ( self . _imdict . keys ( ) ) :              if pol2 == self . pol_prim : continue polvec = self . _imdict [ pol2 ] if len ( polvec ) :                  polarr = polvec . reshape ( self . ydim , self . xdim ) . copy ( ) if pol2 == pol :                      polarr += ringarr  outim . add_pol_image ( polarr , pol2 )   return outim  def add_const_pol ( self , mag , angle , cmag = 0 , csign = 1 ) :          if not ( 0 <= mag < 1 ) :              raise Exception ( <str> )  if not ( 0 <= cmag < 1 ) :              raise Exception ( <str> )  im = self if self . polrep == <str> :              im_stokes = self  elif self . polrep == <str> :              im_stokes = self . switch_polrep ( polrep_out = <str> )  ivec = im_stokes . ivec . copy ( ) qvec = qimage ( ivec , mag * np . ones ( len ( ivec ) ) , angle * np . ones ( len ( ivec ) ) ) uvec = uimage ( ivec , mag * np . ones ( len ( ivec ) ) , angle * np . ones ( len ( ivec ) ) ) vvec = cmag * np . sign ( csign ) * ivec iarr = ivec . reshape ( im . ydim , im . xdim ) . copy ( ) outim = Image ( iarr , self . psize , self . ra , self . dec , self . pa , polrep = <str> , pol_prim = <str> , time = self . time , rf = self . rf , source = self . source , mjd = self . mjd , pulse = self . pulse ) imdict = { <str> : ivec , <str> : qvec , <str> : uvec , <str> : vvec } for pol in list ( imdict . keys ( ) ) :              if pol == <str> : continue polvec = imdict [ pol ] if len ( polvec ) :                  polarr = polvec . reshape ( self . ydim , self . xdim ) . copy ( ) outim . add_pol_image ( polarr , pol )   return outim  def add_random_pol ( self , mag , corr , cmag = 0. , ccorr = 0. , seed = 0 ) :          import ehtim . scattering . stochastic_optics as so if not ( 0 <= mag < 1 ) :              raise Exception ( <str> )  if not ( 0 <= cmag < 1 ) :              raise Exception ( <str> )  im = self if self . polrep == <str> :              im_stokes = self  elif self . polrep == <str> :              im_stokes = self . switch_polrep ( polrep_out = <str> )  ivec = im_stokes . ivec . copy ( ) iarr = ivec . reshape ( im . ydim , im . xdim ) . copy ( ) outim = Image ( iarr , self . psize , self . ra , self . dec , self . pa , polrep = <str> , pol_prim = <str> , time = self . time , rf = self . rf , source = self . source , mjd = self . mjd , pulse = self . pulse ) dist = 1.0 * 3.086e21 rdiff = np . abs ( corr ) * dist / 1e3 theta_mas = 0.37 * 1.0 / rdiff * 1000. * 3600. * 180. / np . pi sm = so . ScatteringModel ( scatt_alpha = 1.67 , observer_screen_distance = dist , source_screen_distance = 1.e5 * dist , theta_maj_mas_ref = theta_mas , theta_min_mas_ref = theta_mas , r_in = rdiff * 2 , r_out = 1e30 ) ep = so . MakeEpsilonScreen ( im . xdim , im . ydim , rngseed = seed ) ps = np . array ( sm . MakePhaseScreen ( ep , im , obs_frequency_Hz = 29.979e9 ) . imvec ) / 1000 ** ( 1.66 / 2 ) qvec = ivec * mag * np . sin ( ps ) uvec = ivec * mag * np . cos ( ps ) if cmag != 0.0 and ccorr > 0.0 :              dist = 1.0 * 3.086e21 rdiff = np . abs ( ccorr ) * dist / 1e3 theta_mas = 0.37 * 1.0 / rdiff * 1000. * 3600. * 180. / np . pi sm = so . ScatteringModel ( scatt_alpha = 1.67 , observer_screen_distance = dist , source_screen_distance = 1.e5 * dist , theta_maj_mas_ref = theta_mas , theta_min_mas_ref = theta_mas , r_in = rdiff * 2 , r_out = 1e30 ) ep = so . MakeEpsilonScreen ( im . xdim , im . ydim , rngseed = seed * 2 ) ps = np . array ( sm . MakePhaseScreen ( ep , im , obs_frequency_Hz = 29.979e9 ) . imvec ) / 1000 ** ( 1.66 / 2 ) vvec = ivec * cmag * np . sin ( ps )  else :              vvec = ivec * cmag  imdict = { <str> : ivec , <str> : qvec , <str> : uvec , <str> : vvec } for pol in list ( imdict . keys ( ) ) :              if pol == <str> : continue polvec = imdict [ pol ] if len ( polvec ) :                  polarr = polvec . reshape ( self . ydim , self . xdim ) . copy ( ) outim . add_pol_image ( polarr , pol )   return outim  def add_zblterm ( self , obs , uv_min , zblval = None , new_fov = False , gauss_sz = False , gauss_sz_factor = 0.75 , debias = True ) :          if gauss_sz == False :              obs_flag = obs . flag_uvdist ( uv_min = uv_min ) minuvdist = np . min ( np . sqrt ( obs_flag . data [ <str> ] ** 2 + obs_flag . data [ <str> ] ** 2 ) ) gauss_sz_sigma = ( 1 / ( gauss_sz_factor * minuvdist ) ) gauss_sz = gauss_sz_sigma * 2.355  factor = 5.0 if new_fov == False :              im_fov = np . max ( ( self . xdim * self . psize , self . ydim * self . psize ) ) new_fov = np . max ( ( factor * ( gauss_sz / 2.355 ) , im_fov ) )  if new_fov < factor * ( gauss_sz / 2.355 ) :              print ( <str> )  obs_zerobl = obs . flag_uvdist ( uv_max = uv_min ) obs_zerobl . add_amp ( debias = debias ) orig_totflux = np . sum ( obs_zerobl . amp [ <str> ] * ( 1 / obs_zerobl . amp [ <str> ] ** 2 ) ) / np . sum ( 1 / obs_zerobl . amp [ <str> ] ** 2 ) if zblval == None :              addedflux = orig_totflux - np . sum ( self . imvec )  else :              addedflux = orig_totflux - zblval  print ( <str> + str ( addedflux ) + <str> + str ( gauss_sz / RADPERUAS ) + <str> ) im_new = self . copy ( ) im_new = im_new . pad ( new_fov , new_fov ) im_new = im_new . add_gauss ( addedflux , ( gauss_sz , gauss_sz , 0 , 0 , 0 ) ) return im_new  def sample_uv ( self , uv , sgrscat = False , polrep_obs = <str> , ttype = <str> , cache = False , fft_pad_factor = 2 ) :          if polrep_obs not in [ <str> , <str> ] :              raise Exception ( <str> )  data = simobs . sample_vis ( self , uv , sgrscat = sgrscat , polrep_obs = polrep_obs , ttype = ttype , cache = cache , fft_pad_factor = fft_pad_factor ) return data  def observe_same_nonoise ( self , obs , sgrscat = False , ttype = <str> , cache = False , fft_pad_factor = 2 ) :          tolerance = 1e-8 if ( np . abs ( self . ra - obs . ra ) > tolerance ) or ( np . abs ( self . dec - obs . dec ) > tolerance ) :              raise Exception ( <str> )  if ( np . abs ( self . rf - obs . rf ) / obs . rf > tolerance ) :              raise Exception ( <str> )  if ttype == <str> or ttype == <str> or ttype == <str> :              print ( <str> + ttype + <str> )  else :              raise Exception ( <str> % ttype )  obsdata = copy . deepcopy ( obs . data ) uv = recarr_to_ndarr ( obsdata [ [ <str> , <str> ] ] , <str> ) data = simobs . sample_vis ( self , uv , sgrscat = sgrscat , polrep_obs = obs . polrep , ttype = ttype , cache = cache , fft_pad_factor = fft_pad_factor ) if obs . polrep == <str> :              obsdata [ <str> ] = data [ 0 ] if not ( data [ 1 ] is None ) :                  obsdata [ <str> ] = data [ 1 ] obsdata [ <str> ] = data [ 2 ] obsdata [ <str> ] = data [ 3 ]   elif obs . polrep == <str> :              obsdata [ <str> ] = data [ 0 ] if not ( data [ 1 ] is None ) :                  obsdata [ <str> ] = data [ 1 ]  if not ( data [ 2 ] is None ) :                  obsdata [ <str> ] = data [ 2 ] obsdata [ <str> ] = data [ 3 ]   obs_no_noise = ehtim . obsdata . Obsdata ( self . ra , self . dec , obs . rf , obs . bw , obsdata , obs . tarr , source = self . source , mjd = self . mjd , polrep = obs . polrep , ampcal = True , phasecal = True , opacitycal = True , dcal = True , frcal = True , timetype = obs . timetype , scantable = obs . scans ) return obs_no_noise  def observe_same ( self , obs_in , ttype = <str> , fft_pad_factor = 2 , sgrscat = False , add_th_noise = True , opacitycal = True , ampcal = True , phasecal = True , dcal = True , frcal = True , rlgaincal = True , stabilize_scan_phase = False , stabilize_scan_amp = False , neggains = False , jones = False , inv_jones = False , tau = TAUDEF , taup = GAINPDEF , gain_offset = GAINPDEF , gainp = GAINPDEF , dterm_offset = DTERMPDEF , caltable_path = None , seed = False ) :          if seed != False :              np . random . seed ( seed = seed )  obs = self . observe_same_nonoise ( obs_in , sgrscat = sgrscat , ttype = ttype , fft_pad_factor = fft_pad_factor ) if jones :              obsdata = simobs . add_jones_and_noise ( obs , add_th_noise = add_th_noise , opacitycal = opacitycal , ampcal = ampcal , phasecal = phasecal , dcal = dcal , frcal = frcal , rlgaincal = rlgaincal , stabilize_scan_phase = stabilize_scan_phase , stabilize_scan_amp = stabilize_scan_amp , neggains = neggains , gainp = gainp , taup = taup , gain_offset = gain_offset , dterm_offset = dterm_offset , caltable_path = caltable_path , seed = seed ) obs = ehtim . obsdata . Obsdata ( obs . ra , obs . dec , obs . rf , obs . bw , obsdata , obs . tarr , source = obs . source , mjd = obs . mjd , polrep = obs_in . polrep , ampcal = ampcal , phasecal = phasecal , opacitycal = opacitycal , dcal = dcal , frcal = frcal , timetype = obs . timetype , scantable = obs . scans ) if inv_jones :                  obsdata = simobs . apply_jones_inverse ( obs , opacitycal = opacitycal , dcal = dcal , frcal = frcal ) obs = ehtim . obsdata . Obsdata ( obs . ra , obs . dec , obs . rf , obs . bw , obsdata , obs . tarr , source = obs . source , mjd = obs . mjd , polrep = obs_in . polrep , ampcal = ampcal , phasecal = phasecal , opacitycal = True , dcal = True , frcal = True , timetype = obs . timetype , scantable = obs . scans )   else :              if caltable_path :                  print ( <str> )  obsdata = simobs . add_noise ( obs , add_th_noise = add_th_noise , ampcal = ampcal , phasecal = phasecal , opacitycal = opacitycal , stabilize_scan_phase = stabilize_scan_phase , stabilize_scan_amp = stabilize_scan_amp , gainp = gainp , taup = taup , gain_offset = gain_offset , seed = seed ) obs = ehtim . obsdata . Obsdata ( obs . ra , obs . dec , obs . rf , obs . bw , obsdata , obs . tarr , source = obs . source , mjd = obs . mjd , polrep = obs_in . polrep , ampcal = ampcal , phasecal = phasecal , opacitycal = True , dcal = True , frcal = True , timetype = obs . timetype , scantable = obs . scans )  return obs  def observe ( self , array , tint , tadv , tstart , tstop , bw , mjd = None , timetype = <str> , polrep_obs = None , elevmin = ELEV_LOW , elevmax = ELEV_HIGH , ttype = <str> , fft_pad_factor = 2 , fix_theta_GMST = False , sgrscat = False , add_th_noise = True , opacitycal = True , ampcal = True , phasecal = True , dcal = True , frcal = True , rlgaincal = True , stabilize_scan_phase = False , stabilize_scan_amp = False , jones = False , inv_jones = False , tau = TAUDEF , taup = GAINPDEF , gainp = GAINPDEF , gain_offset = GAINPDEF , dterm_offset = DTERMPDEF , seed = False ) :          print ( <str> ) if mjd == None :              mjd = self . mjd  if polrep_obs is None :              polrep_obs = self . polrep  obs = array . obsdata ( self . ra , self . dec , self . rf , bw , tint , tadv , tstart , tstop , mjd = mjd , polrep = polrep_obs , tau = tau , timetype = timetype , elevmin = elevmin , elevmax = elevmax , fix_theta_GMST = fix_theta_GMST ) obs = self . observe_same ( obs , ttype = ttype , fft_pad_factor = fft_pad_factor , sgrscat = sgrscat , add_th_noise = add_th_noise , opacitycal = opacitycal , ampcal = ampcal , phasecal = phasecal , dcal = dcal , frcal = frcal , rlgaincal = rlgaincal , stabilize_scan_phase = stabilize_scan_phase , stabilize_scan_amp = stabilize_scan_amp , gainp = gainp , gain_offset = gain_offset , tau = tau , taup = taup , dterm_offset = dterm_offset , jones = jones , inv_jones = inv_jones , seed = seed ) return obs  def observe_vex ( self , vex , source , t_int = 0.0 , tight_tadv = False , polrep_obs = None , ttype = <str> , fft_pad_factor = 2 , sgrscat = False , add_th_noise = True , opacitycal = True , ampcal = True , phasecal = True , frcal = True , dcal = True , rlgaincal = True , stabilize_scan_phase = False , stabilize_scan_amp = False , jones = False , inv_jones = False , tau = TAUDEF , taup = GAINPDEF , gainp = GAINPDEF , gain_offset = GAINPDEF , dterm_offset = DTERMPDEF ) :          if polrep_obs is None :              polrep_obs = self . polrep  t_int_flag = False if t_int == 0.0 :              t_int_flag = True  obs_List = [ ] for i_scan in range ( len ( vex . sched ) ) :              if t_int_flag :                   t_int = vex . sched [ i_scan ] [ <str> ] [ 0 ] [ <str> ]  if tight_tadv :                  t_adv = t_int  else :                  t_adv = 2.0 * vex . sched [ i_scan ] [ <str> ] [ 0 ] [ <str> ]  if vex . sched [ i_scan ] [ <str> ] != source :                  continue  scankeys = list ( vex . sched [ i_scan ] [ <str> ] . keys ( ) ) subarray = vex . array . make_subarray ( [ vex . sched [ i_scan ] [ <str> ] [ key ] [ <str> ] for key in scankeys ] ) t_start = vex . sched [ i_scan ] [ <str> ] t_stop = vex . sched [ i_scan ] [ <str> ] + vex . sched [ i_scan ] [ <str> ] [ 0 ] [ <str> ] / 3600.0 obs = self . observe ( subarray , t_int , t_adv , t_start , t_stop , vex . bw_hz , mjd = vex . sched [ i_scan ] [ <str> ] , elevmin = .01 , elevmax = 89.99 , polrep_obs = polrep_obs , ttype = ttype , fft_pad_factor = fft_pad_factor , sgrscat = sgrscat , add_th_noise = add_th_noise , opacitycal = opacitycal , ampcal = ampcal , phasecal = phasecal , dcal = dcal , frcal = frcal , rlgaincal = rlgaincal , stabilize_scan_phase = stabilize_scan_phase , stabilize_scan_amp = stabilize_scan_amp , taup = taup , gainp = gainp , gain_offset = gain_offset , dterm_offset = dterm_offset , jones = jones , inv_jones = inv_jones ) obs_List . append ( obs )  obs = ehtim . obsdata . merge_obs ( obs_List ) return obs  def compare_images ( self , im2 , psize = None , target_fov = None , blur_frac = 0.0 , beamparams = [ 1. , 1. , 1. ] , metric = [ <str> , <str> , <str> ] , blursmall = False , shift = True ) :          im1 = self . copy ( ) if im1 . polrep != im2 . polrep :              raise Exception ( <str> )  if im1 . pol_prim != im2 . pol_prim :              raise Exception ( <str> )  [ idx , xcorr , im1_pad , im2_pad ] = im1 . find_shift ( im2 , psize = psize , target_fov = target_fov , beamparams = beamparams , blur_frac = blur_frac , blursmall = blursmall ) if type ( shift ) != bool :              idx = shift  im2_shift = im2_pad . shift ( idx ) error = [ ] if <str> in metric :              error . append ( xcorr [ idx [ 0 ] , idx [ 1 ] ] / ( im1_pad . xdim * im1_pad . ydim ) )  if <str> in metric :              error . append ( np . sqrt ( np . sum ( ( ( im1_pad . imvec - im2_shift . imvec ) ** 2 * im1_pad . psize ** 2 ) ) / np . sum ( ( im1_pad . imvec ) ** 2 * im1_pad . psize ** 2 ) ) )  if <str> in metric :              error . append ( np . sqrt ( np . sum ( ( im1_pad . imvec - im2_shift . imvec ) ** 2 ) * im1_pad . psize ** 2 ) )  return ( error , im1_pad , im2_shift )  def align_images ( self , im_list , shift = True , final_fov = False , scale = <str> , gamma = 0.5 , dynamic_range = [ 1.e3 ] ) :          im0 = self . copy ( ) if not np . all ( im0 . polrep == np . array ( [ im . polrep for im in im_list ] ) ) :              raise Exception ( <str> )  if not np . all ( im0 . pol_prim == np . array ( [ im . pol_prim for im in im_list ] ) ) :              raise Exception ( <str> )  if len ( dynamic_range ) == 1 :              dynamic_range = dynamic_range * np . ones ( len ( im_list ) + 1 )  useshift = True if type ( shift ) == bool :              useshift = False  psize = im0 . psize max_fov = np . max ( [ im0 . xdim * im0 . psize , im0 . ydim * im0 . psize ] ) for i in range ( 0 , len ( im_list ) ) :              psize = np . min ( [ psize , im_list [ i ] . psize ] ) max_fov = np . max ( [ max_fov , im_list [ i ] . xdim * im_list [ i ] . psize , im_list [ i ] . ydim * im_list [ i ] . psize ] )  if not final_fov :              final_fov = max_fov  im_list_shift = [ ] shifts = [ ] for i in range ( 0 , len ( im_list ) ) :              ( idx , _ , im0_pad_orig , im_pad ) = im0 . find_shift ( im_list [ i ] , target_fov = 2 * max_fov , psize = psize , scale = scale , gamma = gamma , dynamic_range = dynamic_range [ i + 1 ] ) if i == 0 :                  npix = int ( im0_pad_orig . xdim / 2 ) im0_pad = im0_pad_orig . regrid_image ( final_fov , npix )  if useshift :                  idx = shift [ i ]  tmp = im_pad . shift ( idx ) shifts . append ( idx ) im_list_shift . append ( tmp . regrid_image ( final_fov , npix ) )  return ( im_list_shift , shifts , im0_pad )  def find_shift ( self , im2 , psize = None , target_fov = None , beamparams = [ 1. , 1. , 1. ] , blur_frac = 0.0 , blursmall = False , scale = <str> , gamma = 0.5 , dynamic_range = 1.e3 ) :          im1 = self . copy ( ) if im1 . polrep != im2 . polrep :              raise Exception ( <str> )  if im1 . pol_prim != im2 . pol_prim :              raise Exception ( <str> )  if target_fov == None :              max_fov = np . max ( [ im1 . fovx ( ) , im1 . fovy ( ) , im2 . fovx ( ) , im2 . fovy ( ) ] ) target_fov = 2 * max_fov  if psize == None :              psize = np . min ( [ im1 . psize , im2 . psize ] )  npix = int ( target_fov / psize ) if ( ( blur_frac > 0.0 ) * ( blursmall == True ) ) :              im1 = im1 . blur_gauss ( beamparams , blur_frac ) im2 = im2 . blur_gauss ( beamparams , blur_frac )  im1_pad = im1 . regrid_image ( target_fov , npix ) im2_pad = im2 . regrid_image ( target_fov , npix ) if ( ( blur_frac > 0.0 ) * ( blursmall == False ) ) :              im1_pad = im1_pad . blur_gauss ( beamparams , blur_frac ) im2_pad = im2_pad . blur_gauss ( beamparams , blur_frac )  im1_pad_vec = im1_pad . imvec im2_pad_vec = im2_pad . imvec if scale == <str> :              im1_pad_vec [ im1_pad_vec < 0.0 ] = 0.0 im1_pad_vec = np . log ( im1_pad_vec + np . max ( im1_pad_vec ) / dynamic_range ) im2_pad_vec [ im2_pad_vec < 0.0 ] = 0.0 im2_pad_vec = np . log ( im2_pad_vec + np . max ( im2_pad_vec ) / dynamic_range )  if scale == <str> :              im1_pad_vec [ im1_pad_vec < 0.0 ] = 0.0 im1_pad_vec = ( im1_pad_vec + np . max ( im1_pad_vec ) / dynamic_range ) ** ( gamma ) im2_pad_vec [ im2_pad_vec < 0.0 ] = 0.0 im2_pad_vec = ( im2_pad_vec + np . max ( im2_pad_vec ) / dynamic_range ) ** ( gamma )  im1_norm = ( im1_pad_vec . reshape ( im1_pad . ydim , im1_pad . xdim ) - np . mean ( im1_pad_vec ) ) / np . std ( im1_pad_vec ) im2_norm = ( im2_pad_vec . reshape ( im2_pad . ydim , im2_pad . xdim ) - np . mean ( im2_pad_vec ) ) / np . std ( im2_pad_vec ) fft_im1 = np . fft . fft2 ( im1_norm ) fft_im2 = np . fft . fft2 ( im2_norm ) xcorr = np . real ( np . fft . ifft2 ( fft_im1 * np . conj ( fft_im2 ) ) ) idx = np . unravel_index ( xcorr . argmax ( ) , xcorr . shape ) return [ idx , xcorr , im1_pad , im2_pad ]  def hough_ring ( self , edgetype = <str> , thresh = 0.2 , num_circles = 3 , radius_range = None , return_type = <str> , display_results = True ) :          pdim = self . psize xlist = np . arange ( 0 , - self . xdim , - 1 ) * pdim + ( pdim * self . xdim ) / 2.0 - pdim / 2.0 ylist = np . arange ( 0 , - self . ydim , - 1 ) * pdim + ( pdim * self . ydim ) / 2.0 - pdim / 2.0 im = self . copy ( ) maxval = np . max ( im . imvec ) meanval = np . mean ( im . imvec ) im_norm = im . imvec / ( maxval + .01 * meanval ) im_norm = im_norm . astype ( <str> ) im_norm [ np . isnan ( im . imvec ) ] = 0 im . imvec = im_norm if edgetype == <str> :              imarr = im . imvec . reshape ( self . ydim , self . xdim ) edges = canny ( imarr , sigma = 0 , high_threshold = thresh , low_threshold = 0.01 ) im_edges = self . copy ( ) im_edges . imvec = edges . flatten ( )  elif edgetype == <str> :              im_edges = self . grad ( ) if not ( thresh is None ) :                  thresh_val = thresh * np . max ( im_edges . imvec ) mask = im_edges . imvec > thresh_val im_edges . imvec [ ~ mask ] = 0 edges = im_edges . imvec . reshape ( self . ydim , self . xdim )   else :              im_edges = im . copy ( ) if not ( thresh is None ) :                  thresh_val = thresh * np . max ( im_edges . imvec ) mask = im_edges . imvec > thresh_val im_edges . imvec [ ~ mask ] = 0 edges = im_edges . imvec . reshape ( self . ydim , self . xdim )   if radius_range is None :              hough_radii = np . arange ( int ( 10 * RADPERUAS / self . psize ) , int ( 50 * RADPERUAS / self . psize ) )  else :              hough_radii = np . linspace ( radius_range [ 0 ] / self . psize , radius_range [ 0 ] / self . psize , 25 )  hough_res = hough_circle ( edges , hough_radii ) accums , cy , cx , radii = hough_circle_peaks ( hough_res , hough_radii , total_num_peaks = num_circles ) accum_tot = np . sum ( accums ) outlist = [ ] if display_results :              plt . ion ( ) fig = self . display ( ) ax = fig . gca ( )  i = 0 colors = [ <str> , <str> , <str> , <str> , <str> , <str> ] for accum , center_y , center_x , radius in zip ( accums , cy , cx , radii ) :              accum_frac = accum / accum_tot if return_type == <str> :                  x_rad = xlist [ int ( np . round ( center_x ) ) ] y_rad = ylist [ int ( np . round ( center_y ) ) ] r_rad = radius * self . psize outlist . append ( [ x_rad , y_rad , r_rad , accum_frac ] )  else :                  outlist . append ( [ center_x , center_y , radius , accum_frac ] )  print ( accum_frac ) print ( <str> % ( i , 2 * radius * pdim / RADPERUAS ) ) if display_results :                  if i > len ( colors ) : color = colors [ - 1 ] else : color = colors [ i ] circ = mpl . patches . Circle ( ( center_y , center_x ) , radius , fill = False , color = color ) ax . add_patch ( circ )  i += 1  return outlist  def fit_gauss ( self , units = <str> ) :          ( x1 , y1 ) = self . centroid ( ) pdim = self . psize im = self . imvec xlist = np . arange ( 0 , - self . xdim , - 1 ) * pdim + ( pdim * self . xdim ) / 2.0 - pdim / 2.0 ylist = np . arange ( 0 , - self . ydim , - 1 ) * pdim + ( pdim * self . ydim ) / 2.0 - pdim / 2.0 x2 = ( np . sum ( np . outer ( 0.0 * ylist + 1.0 , ( xlist - x1 ) ** 2 ) . ravel ( ) * im ) / np . sum ( im ) ) y2 = ( np . sum ( np . outer ( ( ylist - y1 ) ** 2 , 0.0 * xlist + 1.0 ) . ravel ( ) * im ) / np . sum ( im ) ) xy = ( np . sum ( np . outer ( ylist - y1 , xlist - x1 ) . ravel ( ) * im ) / np . sum ( im ) ) eig = np . linalg . eigh ( np . array ( ( ( x2 , xy ) , ( xy , y2 ) ) ) ) gauss_params = np . array ( ( eig [ 0 ] [ 1 ] ** 0.5 * ( 8. * np . log ( 2. ) ) ** 0.5 , eig [ 0 ] [ 0 ] ** 0.5 * ( 8. * np . log ( 2. ) ) ** 0.5 , np . mod ( np . arctan2 ( eig [ 1 ] [ 1 ] [ 0 ] , eig [ 1 ] [ 1 ] [ 1 ] ) + np . pi , np . pi ) ) ) if units == <str> :              gauss_params [ 0 ] /= RADPERUAS gauss_params [ 1 ] /= RADPERUAS gauss_params [ 2 ] *= 180. / np . pi  return gauss_params  def fit_gauss_empirical ( self , paramguess = None ) :          u_max = 1.0 / ( self . psize * self . xdim ) / 5.0 uv = np . array ( [ [ u , v ] for u in np . arange ( - u_max , u_max * 1.001 , u_max / 4.0 ) for v in np . arange ( - u_max , u_max * 1.001 , u_max / 4.0 ) ] ) u = uv [ : , 0 ] v = uv [ : , 1 ] vis = np . dot ( ehtim . obsdata . ftmatrix ( self . psize , self . xdim , self . ydim , uv , pulse = self . pulse ) , self . imvec ) if paramguess == None :              paramguess = ( self . psize * self . xdim / 4.0 , self . psize * self . xdim / 4.0 , 0. )  def errfunc ( p ) :              vismodel = gauss_uv ( u , v , self . total_flux ( ) , p , x = 0. , y = 0. ) err = np . sum ( ( np . abs ( vis ) - np . abs ( vismodel ) ) ** 2 ) return err  optdict = { <str> : 5000 , <str> : 5000 , <str> : paramguess [ 0 ] / 1e9 , <str> : 1e-10 } res = opt . minimize ( errfunc , paramguess , method = <str> , options = optdict ) x = res . x x [ 0 ] = np . abs ( x [ 0 ] ) x [ 1 ] = np . abs ( x [ 1 ] ) x [ 2 ] = np . mod ( x [ 2 ] , np . pi ) if x [ 0 ] < x [ 1 ] :              maj = x [ 1 ] x [ 1 ] = x [ 0 ] x [ 0 ] = maj x [ 2 ] = np . mod ( x [ 2 ] + np . pi / 2.0 , np . pi )  return x  def contour ( self , contour_levels = [ 0.1 , 0.25 , 0.5 , 0.75 ] , contour_cfun = None , color = <str> , legend = True , show_im = True , cfun = <str> , scale = <str> , interp = <str> , gamma = 0.5 , dynamic_range = 1.e3 , plotp = False , nvec = 20 , pcut = 0.01 , label_type = <str> , has_title = True , has_cbar = True , cbar_lims = ( ) , cbar_unit = ( <str> , <str> ) , contour_im = False , power = 0 , beamcolor = <str> , export_pdf = <str> , show = True , beamparams = None , cbar_orientation = <str> , scale_lw = 1 , beam_lw = 1 , cbar_fontsize = 12 , axis = None , scale_fontsize = 12 ) :          image = self . copy ( ) y = np . linspace ( 0 , image . ydim , image . ydim ) x = np . linspace ( 0 , image . xdim , image . xdim ) z = image . imvec . reshape ( ( image . ydim , image . xdim ) ) maxz = max ( image . imvec ) if axis is None :              ax = plt . gca ( )  elif axis is not None :              ax = axis plt . sca ( axis )  if show_im :              if axis is not None :                  axis = image . display ( cfun = cfun , scale = scale , interp = interp , gamma = gamma , dynamic_range = dynamic_range , plotp = plotp , nvec = nvec , pcut = pcut , label_type = label_type , has_title = has_title , has_cbar = has_cbar , cbar_lims = cbar_lims , cbar_unit = cbar_unit , beamparams = beamparams , cbar_orientation = cbar_orientation , scale_lw = 1 , beam_lw = 1 , cbar_fontsize = cbar_fontsize , axis = axis , scale_fontsize = scale_fontsize , power = power , beamcolor = beamcolor )  else :                  image . display ( cfun = cfun , scale = scale , interp = interp , gamma = gamma , dynamic_range = dynamic_range , plotp = plotp , nvec = nvec , pcut = pcut , label_type = label_type , has_title = has_title , has_cbar = has_cbar , cbar_lims = cbar_lims , cbar_unit = cbar_unit , beamparams = beamparams , cbar_orientation = cbar_orientation , scale_lw = 1 , beam_lw = 1 , cbar_fontsize = cbar_fontsize , axis = None , scale_fontsize = scale_fontsize , power = power , beamcolor = beamcolor )   else :              if contour_im == False :                  image . imvec = 0.0 * image . imvec  else :                  image = contour_im . copy ( )  if axis is not None :                  axis = image . display ( cfun = cfun , scale = scale , interp = interp , gamma = gamma , dynamic_range = dynamic_range , plotp = plotp , nvec = nvec , pcut = pcut , label_type = label_type , has_title = has_title , has_cbar = has_cbar , cbar_lims = cbar_lims , cbar_unit = cbar_unit , beamparams = beamparams , cbar_orientation = cbar_orientation , scale_lw = 1 , beam_lw = 1 , cbar_fontsize = cbar_fontsize , axis = axis , scale_fontsize = scale_fontsize , power = power , beamcolor = beamcolor )  else :                  image . display ( cfun = cfun , scale = scale , interp = interp , gamma = gamma , dynamic_range = dynamic_range , plotp = plotp , nvec = nvec , pcut = pcut , label_type = label_type , has_title = has_title , has_cbar = has_cbar , cbar_lims = cbar_lims , cbar_unit = cbar_unit , beamparams = beamparams , cbar_orientation = cbar_orientation , scale_lw = 1 , beam_lw = 1 , cbar_fontsize = cbar_fontsize , axis = None , scale_fontsize = scale_fontsize , power = power , beamcolor = beamcolor )   if axis is None : ax = plt . gcf ( ) if axis is not None : ax = axis if axis is not None :              ax = axis plt . sca ( axis )  count = 0. for level in contour_levels :              if not ( contour_cfun is None ) :                  rgbval = contour_cfun ( count / len ( contour_levels ) ) rgbstring = <str> % ( rgbval [ 0 ] * 256 , rgbval [ 1 ] * 256 , rgbval [ 2 ] * 256 )  else :                  rgbstring = color  cs = plt . contour ( x , y , z , levels = [ level * maxz ] , colors = rgbstring , cmap = None ) count += 1 cs . collections [ 0 ] . set_label ( str ( int ( level * 100 ) ) + <str> )  if legend :              plt . legend ( )  if show :              plt . ion ( ) plt . show ( block = False )  if export_pdf != <str> :              ax . savefig ( export_pdf , bbox_inches = <str> , pad_inches = 0 )  elif axis is not None :              return axis  return ax  def display ( self , pol = None , cfun = <str> , interp = <str> , scale = <str> , gamma = 0.5 , dynamic_range = 1.e3 , plotp = False , nvec = 20 , pcut = 0.1 , log_offset = False , label_type = <str> , has_title = True , alpha = 1 , has_cbar = True , only_cbar = False , cbar_lims = ( ) , cbar_unit = ( <str> , <str> ) , export_pdf = <str> , pdf_pad_inches = 0.0 , show = True , beamparams = None , cbar_orientation = <str> , scinot = False , scale_lw = 1 , beam_lw = 1 , cbar_fontsize = 12 , axis = None , scale_fontsize = 12 , power = 0 , beamcolor = <str> , dpi = 500 ) :          if ( interp in [ <str> , <str> , <str> , <str> ] ) :              interp = <str>  else :              interp = <str>  if not ( beamparams is None or beamparams is False ) :              if beamparams [ 0 ] > self . fovx ( ) or beamparams [ 1 ] > self . fovx ( ) :                  raise Exception ( <str> )   if self . polrep == <str> and pol is None : pol = <str> elif self . polrep == <str> and pol is None : pol = <str> if only_cbar :              has_cbar = True label_type = <str> has_title = False  if axis is None :              f = plt . figure ( ) plt . clf ( )  if axis is not None :              plt . sca ( axis )  factor = 1. fluxunit = <str> areaunit = <str> if cbar_unit [ 0 ] in [ <str> , <str> ] :              fluxunit = <str> factor *= 1.e3  elif cbar_unit [ 0 ] in [ <str> , <str> , <str> ] :              fluxunit = <str> factor *= 1.e6  elif cbar_unit [ 0 ] == <str> :              factor = 3.254e13 / ( self . rf ** 2 * self . psize ** 2 ) fluxunit = <str> areaunit = <str> if power != 0 :                  fluxunit = ( <str> + str ( power ) + <str> )  else :                  fluxunit = <str>   elif cbar_unit [ 0 ] in [ <str> ] :              fluxunit = <str> factor *= 1.  else :              factor = 1 fluxunit = cbar_unit [ 0 ] areaunit = <str>  if len ( cbar_unit ) == 1 or cbar_unit [ 0 ] == <str> :              factor *= 1.  elif cbar_unit [ 1 ] == <str> :              factor *= 1. if power != 0 :                  areaunit = areaunit + ( <str> + str ( power ) + <str> )   elif cbar_unit [ 1 ] in [ <str> , <str> , <str> ] :              areaunit = <str> fovfactor = self . xdim * self . psize * ( 1 / RADPERAS ) factor *= ( 1. / fovfactor ) ** 2 / ( 1. / self . xdim ) ** 2 if power != 0 :                  areaunit = areaunit + ( <str> + str ( power ) + <str> )   elif cbar_unit [ 1 ] in [ <str> , <str> , <str> ] :              areaunit = <str> fovfactor = self . xdim * self . psize * ( 1 / RADPERUAS ) / 1000. factor *= ( 1. / fovfactor ) ** 2 / ( 1. / self . xdim ) ** 2 if power != 0 :                  areaunit = areaunit + ( <str> + str ( power ) + <str> )   elif cbar_unit [ 1 ] in [ <str> , <str> , <str> ] :              areaunit = <str> fovfactor = self . xdim * self . psize * ( 1 / RADPERUAS ) factor *= ( 1. / fovfactor ) ** 2 / ( 1. / self . xdim ) ** 2 if power != 0 :                  areaunit = areaunit + ( <str> + str ( power ) + <str> )   elif cbar_unit [ 1 ] == <str> :              if ( beamparams is None or beamparams == False ) :                  print ( <str> )  else :                  areaunit = <str> beamarea = ( 2.0 * np . pi * beamparams [ 0 ] * beamparams [ 1 ] / ( 8.0 * np . log ( 2 ) ) ) factor = beamarea / ( self . psize ** 2 ) if power != 0 :                      areaunit = areaunit + ( <str> + str ( power ) + <str> )    else :              raise ValueError ( <str> + cbar_unit [ 1 ] + <str> )  if not plotp :              try :                  imvec = np . array ( self . _imdict [ pol ] ) . reshape ( - 1 ) / ( 10. ** power )  except KeyError :                  try :                      if self . polrep == <str> : im2 = self . switch_polrep ( <str> ) elif self . polrep == <str> : im2 = self . switch_polrep ( <str> ) imvec = np . array ( im2 . _imdict [ pol ] ) . reshape ( - 1 ) / ( 10. ** power )  except KeyError :                      raise Exception ( <str> % pol )   if np . any ( np . imag ( imvec ) ) :                  print ( <str> ) imvec = np . real ( imvec )  imvec = imvec * factor imarr = imvec . reshape ( self . ydim , self . xdim ) unit = fluxunit if areaunit != <str> :                  unit += <str> + areaunit  if scale == <str> :                  if ( imarr < 0.0 ) . any ( ) :                      print ( <str> ) imarr [ imarr < 0.0 ] = 0.0  if log_offset :                      imarr = np . log10 ( imarr + log_offset / dynamic_range )  else :                      imarr = np . log10 ( imarr + np . max ( imarr ) / dynamic_range )  unit = <str> + unit + <str>  if scale == <str> :                  if ( imarr < 0.0 ) . any ( ) :                      print ( <str> ) imarr [ imarr < 0.0 ] = 0.0  imarr = ( imarr + np . max ( imarr ) / dynamic_range ) ** ( gamma ) unit = <str> + unit + <str> + str ( gamma )  if cbar_lims :                  cbar_lims [ 0 ] = cbar_lims [ 0 ] / ( 10. ** power ) cbar_lims [ 1 ] = cbar_lims [ 1 ] / ( 10. ** power ) imarr [ imarr > cbar_lims [ 1 ] ] = cbar_lims [ 1 ] imarr [ imarr < cbar_lims [ 0 ] ] = cbar_lims [ 0 ]  if has_title :                  plt . title ( <str> % ( self . source , self . rf / 1e9 , pol ) , fontsize = 16 )  if cbar_lims :                  im = plt . imshow ( imarr , alpha = alpha , cmap = plt . get_cmap ( cfun ) , interpolation = interp , vmin = cbar_lims [ 0 ] , vmax = cbar_lims [ 1 ] )  else :                  im = plt . imshow ( imarr , alpha = alpha , cmap = plt . get_cmap ( cfun ) , interpolation = interp )  if not ( beamparams is None or beamparams is False ) :                  beamparams = [ beamparams [ 0 ] , beamparams [ 1 ] , beamparams [ 2 ] , - .35 * self . fovx ( ) , - .35 * self . fovy ( ) ] beamimage = self . copy ( ) beamimage . imvec *= 0 beamimage = beamimage . add_gauss ( 1 , beamparams ) halflevel = 0.5 * np . max ( beamimage . imvec ) beamimarr = ( beamimage . imvec ) . reshape ( beamimage . ydim , beamimage . xdim ) plt . contour ( beamimarr , levels = [ halflevel ] , colors = beamcolor , linewidths = beam_lw )  if has_cbar :                  if only_cbar : im . set_visible ( False ) cb = plt . colorbar ( im , fraction = 0.046 , pad = 0.04 , orientation = cbar_orientation ) cb . set_label ( unit , fontsize = float ( cbar_fontsize ) ) if cbar_fontsize != 12 : cb . set_label ( unit , fontsize = float ( cbar_fontsize ) / 1.5 ) cb . ax . tick_params ( labelsize = cbar_fontsize ) if cbar_lims :                      plt . clim ( cbar_lims [ 0 ] , cbar_lims [ 1 ] )  if scinot :                      cb . formatter . set_powerlimits ( ( 0 , 0 ) ) cb . update_ticks ( )    else :              im_stokes = self . switch_polrep ( polrep_out = <str> ) imvec = np . array ( im_stokes . imvec ) . reshape ( - 1 ) / ( 10 ** power ) qvec = np . array ( im_stokes . qvec ) . reshape ( - 1 ) / ( 10 ** power ) uvec = np . array ( im_stokes . uvec ) . reshape ( - 1 ) / ( 10 ** power ) vvec = np . array ( im_stokes . vvec ) . reshape ( - 1 ) / ( 10 ** power ) if len ( imvec ) == 0 : imvec = np . zeros ( im_stokes . ydim * im_stokes . xdim ) if len ( qvec ) == 0 : qvec = np . zeros ( im_stokes . ydim * im_stokes . xdim ) if len ( uvec ) == 0 : uvec = np . zeros ( im_stokes . ydim * im_stokes . xdim ) if len ( vvec ) == 0 : vvec = np . zeros ( im_stokes . ydim * im_stokes . xdim ) imvec *= factor qvec *= factor uvec *= factor vvec *= factor imarr = ( imvec ) . reshape ( im_stokes . ydim , im_stokes . xdim ) qarr = ( qvec ) . reshape ( im_stokes . ydim , im_stokes . xdim ) uarr = ( uvec ) . reshape ( im_stokes . ydim , im_stokes . xdim ) varr = ( vvec ) . reshape ( im_stokes . ydim , im_stokes . xdim ) unit = fluxunit + <str> + areaunit imarr2 = imarr . copy ( ) if scale == <str> :                  if ( imarr2 < 0.0 ) . any ( ) :                      print ( <str> ) imarr2 [ imarr2 < 0.0 ] = 0.0  imarr2 = np . log10 ( imarr2 + np . max ( imarr2 ) / dynamic_range ) unit = <str> + unit + <str>  if scale == <str> :                  if ( imarr2 < 0.0 ) . any ( ) :                      print ( <str> ) imarr2 [ imarr2 < 0.0 ] = 0.0  imarr2 = ( imarr2 + np . max ( imarr2 ) / dynamic_range ) ** ( gamma ) unit = <str> + unit + <str>  if cbar_lims :                  cbar_lims [ 0 ] = cbar_lims [ 0 ] / ( 10. ** power ) cbar_lims [ 1 ] = cbar_lims [ 1 ] / ( 10. ** power ) imarr2 [ imarr2 > cbar_lims [ 1 ] ] = cbar_lims [ 1 ] imarr2 [ imarr2 < cbar_lims [ 0 ] ] = cbar_lims [ 0 ]  thin = self . xdim // nvec mask = ( imvec ) . reshape ( self . ydim , self . xdim ) > pcut * np . max ( imvec ) mask2 = mask [ : : thin , : : thin ] x = ( np . array ( [ [ i for i in range ( self . xdim ) ] for j in range ( self . ydim ) ] ) [ : : thin , : : thin ] ) [ mask2 ] y = ( np . array ( [ [ j for i in range ( self . xdim ) ] for j in range ( self . ydim ) ] ) [ : : thin , : : thin ] ) [ mask2 ] a = ( - np . sin ( np . angle ( qvec + 1j * uvec ) / 2 ) . reshape ( self . ydim , self . xdim ) [ : : thin , : : thin ] ) [ mask2 ] b = ( np . cos ( np . angle ( qvec + 1j * uvec ) / 2 ) . reshape ( self . ydim , self . xdim ) [ : : thin , : : thin ] ) [ mask2 ] m = ( np . abs ( qvec + 1j * uvec ) / imvec ) . reshape ( self . ydim , self . xdim ) m [ np . logical_not ( mask ) ] = 0 voi = ( vvec / imvec ) . reshape ( self . ydim , self . xdim ) voi [ np . logical_not ( mask ) ] = 0 maxval = 1.1 * np . max ( ( np . max ( np . abs ( uarr ) ) , np . max ( np . abs ( qarr ) ) , np . max ( np . abs ( varr ) ) ) ) ax = plt . subplot2grid ( ( 2 , 5 ) , ( 0 , 0 ) ) plt . imshow ( imarr , cmap = plt . get_cmap ( <str> ) , interpolation = interp , vmin = - maxval , vmax = maxval ) plt . contour ( imarr , colors = <str> , linewidth = .25 ) ax . set_xticks ( [ ] ) ax . set_yticks ( [ ] ) if has_title : plt . title ( <str> ) ax = plt . subplot2grid ( ( 2 , 5 ) , ( 0 , 1 ) ) plt . imshow ( varr , cmap = plt . get_cmap ( <str> ) , interpolation = interp , vmin = - maxval , vmax = maxval ) ax . set_xticks ( [ ] ) ax . set_yticks ( [ ] ) if has_title : plt . title ( <str> ) ax = plt . subplot2grid ( ( 2 , 5 ) , ( 1 , 0 ) ) plt . imshow ( qarr , cmap = plt . get_cmap ( <str> ) , interpolation = interp , vmin = - maxval , vmax = maxval ) plt . contour ( qarr , colors = <str> , linewidth = .25 ) ax . set_xticks ( [ ] ) ax . set_yticks ( [ ] ) if has_title : plt . title ( <str> ) ax = plt . subplot2grid ( ( 2 , 5 ) , ( 1 , 1 ) ) plt . imshow ( uarr , cmap = plt . get_cmap ( <str> ) , interpolation = interp , vmin = - maxval , vmax = maxval ) plt . contour ( uarr , colors = <str> , linewidth = .25 ) ax . set_xticks ( [ ] ) ax . set_yticks ( [ ] ) if has_title : plt . title ( <str> ) ax = plt . subplot2grid ( ( 2 , 5 ) , ( 0 , 2 ) ) plt . imshow ( voi , cmap = plt . get_cmap ( <str> ) , interpolation = interp , vmin = - 1 , vmax = 1 ) if has_title : plt . title ( <str> ) ax . set_xticks ( [ ] ) ax . set_yticks ( [ ] ) ax = plt . subplot2grid ( ( 2 , 5 ) , ( 1 , 2 ) ) plt . imshow ( m , cmap = plt . get_cmap ( <str> ) , interpolation = interp , vmin = - 1 , vmax = 1 ) ax . set_xticks ( [ ] ) ax . set_yticks ( [ ] ) if has_title : plt . title ( <str> ) plt . quiver ( x , y , a , b , headaxislength = 20 , headwidth = 1 , headlength = .01 , minlength = 0 , minshaft = 1 , width = .01 * self . xdim , units = <str> , pivot = <str> , color = <str> , angles = <str> , scale = 1.0 / thin ) plt . quiver ( x , y , a , b , headaxislength = 20 , headwidth = 1 , headlength = .01 , minlength = 0 , minshaft = 1 , width = .005 * self . xdim , units = <str> , pivot = <str> , color = <str> , angles = <str> , scale = 1.1 / thin ) ax = plt . subplot2grid ( ( 2 , 5 ) , ( 0 , 3 ) , rowspan = 2 , colspan = 2 ) if cbar_lims :                  im = plt . imshow ( imarr2 , cmap = plt . get_cmap ( cfun ) , interpolation = interp , vmin = cbar_lims [ 0 ] , vmax = cbar_lims [ 1 ] )  else :                  im = plt . imshow ( imarr2 , cmap = plt . get_cmap ( cfun ) , interpolation = interp )  plt . quiver ( x , y , a , b , headaxislength = 20 , headwidth = 1 , headlength = .01 , minlength = 0 , minshaft = 1 , width = .01 * self . xdim , units = <str> , pivot = <str> , color = <str> , angles = <str> , scale = 1.0 / thin ) plt . quiver ( x , y , a , b , headaxislength = 20 , headwidth = 1 , headlength = .01 , minlength = 0 , minshaft = 1 , width = .005 * self . xdim , units = <str> , pivot = <str> , color = <str> , angles = <str> , scale = 1.1 / thin ) if not ( beamparams is None or beamparams == False ) :                  beamparams = [ beamparams [ 0 ] , beamparams [ 1 ] , beamparams [ 2 ] , - .35 * self . fovx ( ) , - .35 * self . fovy ( ) ] beamimage = self . copy ( ) beamimage . imvec *= 0 beamimage = beamimage . add_gauss ( 1 , beamparams ) halflevel = 0.5 * np . max ( beamimage . imvec ) beamimarr = ( beamimage . imvec ) . reshape ( beamimage . ydim , beamimage . xdim ) plt . contour ( beamimarr , levels = [ halflevel ] , colors = beamcolor , linewidths = beam_lw )  if has_cbar :                  cbar = plt . colorbar ( im , fraction = 0.046 , pad = 0.04 , label = unit , orientation = cbar_orientation ) cbar . ax . tick_params ( labelsize = cbar_fontsize ) if cbar_lims :                      plt . clim ( cbar_lims [ 0 ] , cbar_lims [ 1 ] )   if has_title :                  plt . title ( <str> % ( self . source , self . rf / 1e9 , <str> ) , fontsize = 12 )  f . subplots_adjust ( hspace = - .5 , wspace = 0.1 )  ax = plt . gca ( ) if label_type == <str> :              xticks = ticks ( self . xdim , self . psize / RADPERAS / 1e-6 ) yticks = ticks ( self . ydim , self . psize / RADPERAS / 1e-6 ) plt . xticks ( xticks [ 0 ] , xticks [ 1 ] ) plt . yticks ( yticks [ 0 ] , yticks [ 1 ] ) plt . xlabel ( <str> ) plt . ylabel ( <str> )  elif label_type == <str> :              plt . axis ( <str> ) fov_uas = self . xdim * self . psize / RADPERUAS roughfactor = 1. / 3. fov_scale = int ( math . ceil ( fov_uas * roughfactor / 10.0 ) ) * 10 start = self . xdim * roughfactor / 3.0 end = start + fov_scale / fov_uas * self . xdim plt . plot ( [ start , end ] , [ self . ydim - start - 5 , self . ydim - start - 5 ] , color = <str> , lw = scale_lw ) plt . text ( x = ( start + end ) / 2.0 , y = self . ydim - start + self . ydim / 30 , s = str ( fov_scale ) + <str> , color = <str> , ha = <str> , va = <str> , fontsize = scale_fontsize ) ax = plt . gca ( ) if axis is None :                  ax . axes . get_xaxis ( ) . set_visible ( False ) ax . axes . get_yaxis ( ) . set_visible ( False )   elif label_type == <str> :              plt . axis ( <str> ) ax = plt . gca ( ) if axis is None :                  ax . axes . get_xaxis ( ) . set_visible ( False ) ax . axes . get_yaxis ( ) . set_visible ( False )   if axis is not None :              return axis  if show :              plt . show ( block = False )  if export_pdf != <str> :              f . savefig ( export_pdf , bbox_inches = <str> , pad_inches = pdf_pad_inches , dpi = dpi )  return f  def overlay_display ( self , im_list , color_coding = np . array ( [ [ 1 , 0 , 1 ] , [ 0 , 1 , 0 ] ] ) , export_pdf = <str> , show = True , f = False , shift = [ 0 , 0 ] , final_fov = False , interp = <str> , scale = <str> , gamma = 0.5 , dynamic_range = [ 1.e3 ] , rescale = True ) :          if not f :              f = plt . figure ( )  plt . clf ( ) if len ( dynamic_range ) == 1 :              dynamic_range = dynamic_range * np . ones ( len ( im_list ) + 1 )  if type ( shift ) != np . ndarray and type ( shift ) != bool :              shift = matlib . repmat ( shift , len ( im_list ) , 1 )  psize = self . psize max_fov = np . max ( [ self . xdim * self . psize , self . ydim * self . psize ] ) for i in range ( 0 , len ( im_list ) ) :              psize = np . min ( [ psize , im_list [ i ] . psize ] ) max_fov = np . max ( [ max_fov , im_list [ i ] . xdim * im_list [ i ] . psize , im_list [ i ] . ydim * im_list [ i ] . psize ] )  if not final_fov :              final_fov = max_fov  ( im_list_shift , shifts , im0_pad ) = self . align_images ( im_list , shift = shift , final_fov = final_fov , scale = scale , gamma = gamma , dynamic_range = dynamic_range ) unit = <str> if scale == <str> :              unit = <str> im0_pad . imvec = np . log10 ( im0_pad . imvec + np . max ( im0_pad . imvec ) / dynamic_range [ 0 ] ) for i in range ( 0 , len ( im_list ) ) :                  im_list_shift [ i ] . imvec = np . log10 ( im_list_shift [ i ] . imvec + np . max ( im_list_shift [ i ] . imvec ) / dynamic_range [ i + 1 ] )   if scale == <str> :              unit = <str> im0_pad . imvec = ( im0_pad . imvec + np . max ( im0_pad . imvec ) / dynamic_range [ 0 ] ) ** ( gamma ) for i in range ( 0 , len ( im_list ) ) :                  im_list_shift [ i ] . imvec = ( im_list_shift [ i ] . imvec + np . max ( im_list_shift [ i ] . imvec ) / dynamic_range [ i + 1 ] ) ** ( gamma )   composite_img = np . zeros ( ( im0_pad . ydim , im0_pad . xdim , 3 ) ) for i in range ( - 1 , len ( im_list ) ) :              if i == - 1 :                  immtx = im0_pad . imvec . reshape ( im0_pad . ydim , im0_pad . xdim )  else :                  immtx = im_list_shift [ i ] . imvec . reshape ( im0_pad . ydim , im0_pad . xdim )  if rescale :                  immtx = immtx - np . min ( np . min ( immtx ) ) immtx = immtx / np . max ( np . max ( immtx ) )  for c in range ( 0 , 3 ) :                  composite_img [ : , : , c ] = composite_img [ : , : , c ] + ( color_coding [ i + 1 , c ] * immtx )   if rescale == False :              composite_img = composite_img - np . min ( np . min ( np . min ( composite_img ) ) ) composite_img = composite_img / np . max ( np . max ( np . max ( composite_img ) ) )  plt . subplot ( 111 ) plt . title ( <str> % ( self . source , self . mjd , self . rf / 1e9 ) , fontsize = 20 ) im = plt . imshow ( composite_img , interpolation = interp ) xticks = ticks ( im0_pad . xdim , im0_pad . psize / RADPERAS / 1e-6 ) yticks = ticks ( im0_pad . ydim , im0_pad . psize / RADPERAS / 1e-6 ) plt . xticks ( xticks [ 0 ] , xticks [ 1 ] ) plt . yticks ( yticks [ 0 ] , yticks [ 1 ] ) plt . xlabel ( <str> ) plt . ylabel ( <str> ) if show :              plt . show ( block = False )  if export_pdf != <str> :              f . savefig ( export_pdf , bbox_inches = <str> )  return ( f , shift )  def save_txt ( self , fname ) :          ehtim . io . save . save_im_txt ( self , fname ) return  def save_fits ( self , fname ) :          ehtim . io . save . save_im_fits ( self , fname ) return   def make_square ( obs , npix , fov , pulse = PULSE_DEFAULT , polrep = <str> , pol_prim = None ) :      outim = make_empty ( npix , fov , obs . ra , obs . dec , rf = obs . rf , source = obs . source , polrep = polrep , pol_prim = pol_prim , pulse = pulse , mjd = obs . mjd , time = obs . tstart ) return outim  def make_empty ( npix , fov , ra , dec , rf = RF_DEFAULT , source = SOURCE_DEFAULT , polrep = <str> , pol_prim = None , pulse = PULSE_DEFAULT , mjd = MJD_DEFAULT , time = 0. ) :      pdim = fov / float ( npix ) npix = int ( npix ) imarr = np . zeros ( ( npix , npix ) ) outim = Image ( imarr , pdim , ra , dec , polrep = polrep , pol_prim = pol_prim , rf = rf , source = source , mjd = mjd , time = time , pulse = pulse ) return outim  def load_image ( image , display = False , aipscc = False ) :      if type ( image ) == type ( <str> ) :        if image . endswith ( <str> ) :          im = ehtim . io . load . load_im_fits ( image , aipscc = aipscc )  elif image . endswith ( <str> ) :          im = ehtim . io . load . load_im_txt ( image )  else :          print ( <str> . format ( image . split ( <str> ) [ - 1 ] ) ) return False   elif isinstance ( image , ehtim . image . Image ) :        im = image  else :        print ( <str> . format ( type ( image ) ) ) return False  if display :        im . display ( )  return im  def load_txt ( fname , polrep = <str> , pol_prim = None , pulse = PULSE_DEFAULT , zero_pol = True ) :      return ehtim . io . load . load_im_txt ( fname , pulse = pulse , polrep = polrep , pol_prim = pol_prim , zero_pol = True )  def load_fits ( fname , aipscc = False , pulse = PULSE_DEFAULT , polrep = <str> , pol_prim = None , zero_pol = False ) :      return ehtim . io . load . load_im_fits ( fname , aipscc = aipscc , pulse = pulse , polrep = polrep , pol_prim = pol_prim , zero_pol = zero_pol )   