from __future__ import division from __future__ import print_function import numpy as np import sys import itertools as it import copy import os import ehtim . obsdata from ehtim . observing . obs_helpers import * from multiprocessing import Process , Value , Lock ZBLCUTOFF = 1.e7 ; class Counter ( object ) :      def __init__ ( self , initval = 0 , maxval = 0 ) :          self . val = Value ( <str> , initval ) self . maxval = maxval self . lock = Lock ( )  def increment ( self ) :          with self . lock :              self . val . value += 1   def value ( self ) :          with self . lock :              return self . val . value    def make_cluster_data ( obs , zbl_uvdist_max = ZBLCUTOFF ) :      clusters = [ ] clustered_sites = [ ] for i1 in range ( len ( obs . tarr ) ) :          t1 = obs . tarr [ i1 ] if t1 [ <str> ] in clustered_sites :              continue  csites = [ t1 [ <str> ] ] clustered_sites . append ( t1 [ <str> ] ) for i2 in range ( len ( obs . tarr ) ) [ i1 : ] :              t2 = obs . tarr [ i2 ] if t2 [ <str> ] in clustered_sites :                  continue  site1coord = np . array ( [ t1 [ <str> ] , t1 [ <str> ] , t1 [ <str> ] ] ) site2coord = np . array ( [ t2 [ <str> ] , t2 [ <str> ] , t2 [ <str> ] ] ) uvdist = np . sqrt ( np . sum ( ( site1coord - site2coord ) ** 2 ) ) / ( C / obs . rf ) if uvdist < zbl_uvdist_max :                  csites . append ( t2 [ <str> ] ) clustered_sites . append ( t2 [ <str> ] )   clusters . append ( csites )  clusterdict = { } for site in obs . tarr [ <str> ] :          for k in range ( len ( clusters ) ) :              if site in clusters [ k ] :                  clusterdict [ site ] = k    clusterbls = [ set ( comb ) for comb in it . combinations ( range ( len ( clusterdict ) ) , 2 ) ] cluster_data = ( clusters , clusterdict , clusterbls ) return cluster_data   