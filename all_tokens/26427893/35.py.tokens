from __future__ import division from builtins import str from builtins import map from builtins import range try :      import ephem  except ImportError :      print ( <str> )  try :      from pynfft . nfft import NFFT  except ImportError :      print ( <str> )  import astropy . time as at import astropy . coordinates as coords import numpy as np import scipy . special as ss import itertools as it import copy import sys import os import ehtim . const_def from ehtim . const_def import * import scipy . ndimage as nd import warnings warnings . filterwarnings ( <str> , message = <str> ) def compute_uv_coordinates ( array , site1 , site2 , time , mjd , ra , dec , rf , timetype = <str> , elevmin = ELEV_LOW , elevmax = ELEV_HIGH , fix_theta_GMST = False ) :      if not isinstance ( time , np . ndarray ) : time = np . array ( [ time ] ) . flatten ( ) if not isinstance ( site1 , np . ndarray ) : site1 = np . array ( [ site1 ] ) . flatten ( ) if not isinstance ( site2 , np . ndarray ) : site2 = np . array ( [ site2 ] ) . flatten ( ) if len ( site1 ) == len ( site2 ) == 1 :          site1 = np . array ( [ site1 [ 0 ] for i in range ( len ( time ) ) ] ) site2 = np . array ( [ site2 [ 0 ] for i in range ( len ( time ) ) ] )  elif not ( len ( site1 ) == len ( site2 ) == len ( time ) ) :          raise Exception ( <str> )  sourcevec = np . array ( [ np . cos ( dec * DEGREE ) , 0 , np . sin ( dec * DEGREE ) ] ) projU = np . cross ( np . array ( [ 0 , 0 , 1 ] ) , sourcevec ) projU = projU / np . linalg . norm ( projU ) projV = - np . cross ( projU , sourcevec ) l = C / rf if timetype == <str> :          time_sidereal = time time_utc = gmst_to_utc ( time , mjd )  elif timetype == <str> :          time_sidereal = utc_to_gmst ( time , mjd ) time_utc = time  else : raise Exception ( <str> ) fracmjd = np . floor ( mjd ) + time / 24. dto = ( at . Time ( fracmjd , format = <str> ) ) . datetime theta = np . mod ( ( time_sidereal - ra ) * HOUR , 2 * np . pi ) if type ( fix_theta_GMST ) != bool :          theta = np . mod ( ( fix_theta_GMST - ra ) * HOUR , 2 * np . pi )  i1 = np . array ( [ array . tkey [ site ] for site in site1 ] ) i2 = np . array ( [ array . tkey [ site ] for site in site2 ] ) coord1 = np . vstack ( ( array . tarr [ i1 ] [ <str> ] , array . tarr [ i1 ] [ <str> ] , array . tarr [ i1 ] [ <str> ] ) ) . T coord2 = np . vstack ( ( array . tarr [ i2 ] [ <str> ] , array . tarr [ i2 ] [ <str> ] , array . tarr [ i2 ] [ <str> ] ) ) . T spacemask1 = [ np . all ( coord == ( 0. , 0. , 0. ) ) for coord in coord1 ] if np . any ( spacemask1 ) :          if timetype == <str> :              raise Exception ( <str> )  site1space_list = site1 [ spacemask1 ] site1space_dtolist = dto [ spacemask1 ] coord1space = [ ] for k in range ( len ( site1space_list ) ) :              site1space = site1space_list [ k ] dto_now = site1space_dtolist [ k ] sat = ephem . readtle ( array . ephem [ site1space ] [ 0 ] , array . ephem [ site1space ] [ 1 ] , array . ephem [ site1space ] [ 2 ] ) sat . compute ( dto_now ) elev = sat . elevation lat = sat . sublat / DEGREE lon = sat . sublong / DEGREE c1 = coords . EarthLocation . from_geodetic ( lon , lat , elev , ellipsoid = None ) c1 = np . array ( ( c1 . x . value , c1 . y . value , c1 . z . value ) ) coord1space . append ( c1 )  coord1space = np . array ( coord1space ) coord1 [ spacemask1 ] = coord1space  spacemask2 = [ np . all ( coord == ( 0. , 0. , 0. ) ) for coord in coord2 ] if np . any ( spacemask2 ) :          if timetype == <str> :              raise Exception ( <str> )  site2space_list = site2 [ spacemask2 ] site2space_dtolist = dto [ spacemask2 ] coord2space = [ ] for k in range ( len ( site2space_list ) ) :              site2space = site2space_list [ k ] dto_now = site2space_dtolist [ k ] sat = ephem . readtle ( array . ephem [ site2space ] [ 0 ] , array . ephem [ site2space ] [ 1 ] , array . ephem [ site2space ] [ 2 ] ) sat . compute ( dto_now ) elev = sat . elevation lat = sat . sublat / DEGREE lon = sat . sublong / DEGREE c2 = coords . EarthLocation . from_geodetic ( lon , lat , elev , ellipsoid = None ) c2 = np . array ( ( c2 . x . value , c2 . y . value , c2 . z . value ) ) coord2space . append ( c2 )  coord2space = np . array ( coord2space ) coord2 [ spacemask2 ] = coord2space  coord1 = earthrot ( coord1 , theta ) coord2 = earthrot ( coord2 , theta ) u = np . dot ( ( coord1 - coord2 ) / l , projU ) v = np . dot ( ( coord1 - coord2 ) / l , projV ) mask = ( elevcut ( coord1 , sourcevec , elevmin = elevmin , elevmax = elevmax ) * elevcut ( coord2 , sourcevec , elevmin = elevmin , elevmax = elevmax ) ) time = time [ mask ] u = u [ mask ] v = v [ mask ] return ( time , u , v )  def make_bispectrum ( l1 , l2 , l3 , vtype , polrep = <str> ) :      if polrep == <str> :          if vtype in [ <str> , <str> , <str> , <str> ] :              if vtype == <str> : sigmatype = <str> if vtype == <str> : sigmatype = <str> if vtype == <str> : sigmatype = <str> if vtype == <str> : sigmatype = <str> p1 = l1 [ vtype ] p2 = l2 [ vtype ] p3 = l3 [ vtype ] var1 = l1 [ sigmatype ] ** 2 var2 = l2 [ sigmatype ] ** 2 var3 = l3 [ sigmatype ] ** 2  elif vtype == <str> :              p1 = l1 [ <str> ] + l1 [ <str> ] p2 = l2 [ <str> ] + l2 [ <str> ] p3 = l3 [ <str> ] + l3 [ <str> ] var1 = l1 [ <str> ] ** 2 + l1 [ <str> ] ** 2 var2 = l2 [ <str> ] ** 2 + l2 [ <str> ] ** 2 var3 = l3 [ <str> ] ** 2 + l3 [ <str> ] ** 2  elif vtype == <str> :              p1 = l1 [ <str> ] - l1 [ <str> ] p2 = l2 [ <str> ] - l2 [ <str> ] p3 = l3 [ <str> ] - l3 [ <str> ] var1 = l1 [ <str> ] ** 2 + l1 [ <str> ] ** 2 var2 = l2 [ <str> ] ** 2 + l2 [ <str> ] ** 2 var3 = l3 [ <str> ] ** 2 + l3 [ <str> ] ** 2  elif vtype == <str> :              p1 = l1 [ <str> ] - 1j * l1 [ <str> ] p2 = l2 [ <str> ] - 1j * l2 [ <str> ] p3 = l3 [ <str> ] - 1j * l3 [ <str> ] var1 = l1 [ <str> ] ** 2 + l1 [ <str> ] ** 2 var2 = l2 [ <str> ] ** 2 + l2 [ <str> ] ** 2 var3 = l3 [ <str> ] ** 2 + l3 [ <str> ] ** 2  elif vtype in [ <str> , <str> ] :              p1 = l1 [ <str> ] + 1j * l1 [ <str> ] p2 = l2 [ <str> ] + 1j * l2 [ <str> ] p3 = l3 [ <str> ] + 1j * l3 [ <str> ] var1 = l1 [ <str> ] ** 2 + l1 [ <str> ] ** 2 var2 = l2 [ <str> ] ** 2 + l2 [ <str> ] ** 2 var3 = l3 [ <str> ] ** 2 + l3 [ <str> ] ** 2   elif polrep == <str> :          if vtype in [ <str> , <str> , <str> , <str> , <str> ] :              if vtype == <str> : vtype = <str> if vtype == <str> : sigmatype = <str> if vtype == <str> : sigmatype = <str> if vtype == <str> : sigmatype = <str> if vtype == <str> : sigmatype = <str> p1 = l1 [ vtype ] p2 = l2 [ vtype ] p3 = l3 [ vtype ] var1 = l1 [ sigmatype ] ** 2 var2 = l2 [ sigmatype ] ** 2 var3 = l3 [ sigmatype ] ** 2  elif vtype == <str> :              p1 = 0.5 * ( l1 [ <str> ] + l1 [ <str> ] ) p2 = 0.5 * ( l2 [ <str> ] + l2 [ <str> ] ) p3 = 0.5 * ( l3 [ <str> ] + l3 [ <str> ] ) var1 = 0.25 * ( l1 [ <str> ] ** 2 + l1 [ <str> ] ** 2 ) var2 = 0.25 * ( l2 [ <str> ] ** 2 + l2 [ <str> ] ** 2 ) var3 = 0.25 * ( l3 [ <str> ] ** 2 + l3 [ <str> ] ** 2 )  elif vtype == <str> :              p1 = 0.5 * ( l1 [ <str> ] - l1 [ <str> ] ) p2 = 0.5 * ( l2 [ <str> ] - l2 [ <str> ] ) p3 = 0.5 * ( l3 [ <str> ] - l3 [ <str> ] ) var1 = 0.25 * ( l1 [ <str> ] ** 2 + l1 [ <str> ] ** 2 ) var2 = 0.25 * ( l2 [ <str> ] ** 2 + l2 [ <str> ] ** 2 ) var3 = 0.25 * ( l3 [ <str> ] ** 2 + l3 [ <str> ] ** 2 )  elif vtype == <str> :              p1 = 0.5 * ( l1 [ <str> ] + l1 [ <str> ] ) p2 = 0.5 * ( l2 [ <str> ] + l2 [ <str> ] ) p3 = 0.5 * ( l3 [ <str> ] + l3 [ <str> ] ) var1 = 0.25 * ( l1 [ <str> ] ** 2 + l1 [ <str> ] ** 2 ) var2 = 0.25 * ( l2 [ <str> ] ** 2 + l2 [ <str> ] ** 2 ) var3 = 0.25 * ( l3 [ <str> ] ** 2 + l3 [ <str> ] ** 2 )  elif vtype == <str> :              p1 = 0.5j * ( l1 [ <str> ] - l1 [ <str> ] ) p2 = 0.5j * ( l2 [ <str> ] - l2 [ <str> ] ) p3 = 0.5j * ( l3 [ <str> ] - l3 [ <str> ] ) var1 = 0.25 * ( l1 [ <str> ] ** 2 + l1 [ <str> ] ** 2 ) var2 = 0.25 * ( l2 [ <str> ] ** 2 + l2 [ <str> ] ** 2 ) var3 = 0.25 * ( l3 [ <str> ] ** 2 + l3 [ <str> ] ** 2 )   else :          raise Exception ( <str> )  bi = p1 * p2 * p3 bisig = np . abs ( bi ) * np . sqrt ( var1 / np . abs ( p1 ) ** 2 + var2 / np . abs ( p2 ) ** 2 + var3 / np . abs ( p3 ) ** 2 ) return ( bi , bisig )  def make_closure_amplitude ( blue1 , blue2 , red1 , red2 , vtype , ctype = <str> , debias = True , polrep = <str> ) :      if not ( ctype in [ <str> , <str> ] ) :          raise Exception ( <str> )  if polrep == <str> :          if vtype in [ <str> , <str> , <str> , <str> ] :              if vtype == <str> : sigmatype = <str> if vtype == <str> : sigmatype = <str> if vtype == <str> : sigmatype = <str> if vtype == <str> : sigmatype = <str> sig1 = blue1 [ sigmatype ] sig2 = blue2 [ sigmatype ] sig3 = red1 [ sigmatype ] sig4 = red2 [ sigmatype ] p1 = np . abs ( blue1 [ vtype ] ) p2 = np . abs ( blue2 [ vtype ] ) p3 = np . abs ( red1 [ vtype ] ) p4 = np . abs ( red2 [ vtype ] )  elif vtype == <str> :              sig1 = np . sqrt ( blue1 [ <str> ] ** 2 + blue1 [ <str> ] ** 2 ) sig2 = np . sqrt ( blue2 [ <str> ] ** 2 + blue2 [ <str> ] ** 2 ) sig3 = np . sqrt ( red1 [ <str> ] ** 2 + red1 [ <str> ] ** 2 ) sig4 = np . sqrt ( red2 [ <str> ] ** 2 + red2 [ <str> ] ** 2 ) p1 = np . abs ( blue1 [ <str> ] + blue1 [ <str> ] ) p2 = np . abs ( blue2 [ <str> ] + blue2 [ <str> ] ) p3 = np . abs ( red1 [ <str> ] + red1 [ <str> ] ) p4 = np . abs ( red2 [ <str> ] + red2 [ <str> ] )  elif vtype == <str> :              sig1 = np . sqrt ( blue1 [ <str> ] ** 2 + blue1 [ <str> ] ** 2 ) sig2 = np . sqrt ( blue2 [ <str> ] ** 2 + blue2 [ <str> ] ** 2 ) sig3 = np . sqrt ( red1 [ <str> ] ** 2 + red1 [ <str> ] ** 2 ) sig4 = np . sqrt ( red2 [ <str> ] ** 2 + red2 [ <str> ] ** 2 ) p1 = np . abs ( blue1 [ <str> ] - blue1 [ <str> ] ) p2 = np . abs ( blue2 [ <str> ] - blue2 [ <str> ] ) p3 = np . abs ( red1 [ <str> ] - red1 [ <str> ] ) p4 = np . abs ( red2 [ <str> ] - red2 [ <str> ] )  elif vtype == <str> :              sig1 = np . sqrt ( blue1 [ <str> ] ** 2 + blue1 [ <str> ] ** 2 ) sig2 = np . sqrt ( blue2 [ <str> ] ** 2 + blue2 [ <str> ] ** 2 ) sig3 = np . sqrt ( red1 [ <str> ] ** 2 + red1 [ <str> ] ** 2 ) sig4 = np . sqrt ( red2 [ <str> ] ** 2 + red2 [ <str> ] ** 2 ) p1 = np . abs ( blue1 [ <str> ] - 1j * blue1 [ <str> ] ) p2 = np . abs ( blue2 [ <str> ] - 1j * blue2 [ <str> ] ) p3 = np . abs ( red1 [ <str> ] - 1j * red1 [ <str> ] ) p4 = np . abs ( red2 [ <str> ] - 1j * red2 [ <str> ] )  elif vtype in [ <str> , <str> ] :              sig1 = np . sqrt ( blue1 [ <str> ] ** 2 + blue1 [ <str> ] ** 2 ) sig2 = np . sqrt ( blue2 [ <str> ] ** 2 + blue2 [ <str> ] ** 2 ) sig3 = np . sqrt ( red1 [ <str> ] ** 2 + red1 [ <str> ] ** 2 ) sig4 = np . sqrt ( red2 [ <str> ] ** 2 + red2 [ <str> ] ** 2 ) p1 = np . abs ( blue1 [ <str> ] + 1j * blue1 [ <str> ] ) p2 = np . abs ( blue2 [ <str> ] + 1j * blue2 [ <str> ] ) p3 = np . abs ( red1 [ <str> ] + 1j * red1 [ <str> ] ) p4 = np . abs ( red2 [ <str> ] + 1j * red2 [ <str> ] )   elif polrep == <str> :          if vtype in [ <str> , <str> , <str> , <str> , <str> ] :              if vtype == <str> : vtype = <str> if vtype == <str> : sigmatype = <str> if vtype == <str> : sigmatype = <str> if vtype == <str> : sigmatype = <str> if vtype == <str> : sigmatype = <str> sig1 = blue1 [ sigmatype ] sig2 = blue2 [ sigmatype ] sig3 = red1 [ sigmatype ] sig4 = red2 [ sigmatype ] p1 = np . abs ( blue1 [ vtype ] ) p2 = np . abs ( blue2 [ vtype ] ) p3 = np . abs ( red1 [ vtype ] ) p4 = np . abs ( red2 [ vtype ] )  elif vtype == <str> :              sig1 = 0.5 * np . sqrt ( blue1 [ <str> ] ** 2 + blue1 [ <str> ] ** 2 ) sig2 = 0.5 * np . sqrt ( blue2 [ <str> ] ** 2 + blue2 [ <str> ] ** 2 ) sig3 = 0.5 * np . sqrt ( red1 [ <str> ] ** 2 + red1 [ <str> ] ** 2 ) sig4 = 0.5 * np . sqrt ( red2 [ <str> ] ** 2 + red2 [ <str> ] ** 2 ) p1 = 0.5 * np . abs ( blue1 [ <str> ] + blue1 [ <str> ] ) p2 = 0.5 * np . abs ( blue2 [ <str> ] + blue2 [ <str> ] ) p3 = 0.5 * np . abs ( red1 [ <str> ] + red1 [ <str> ] ) p4 = 0.5 * np . abs ( red2 [ <str> ] + red2 [ <str> ] )  elif vtype == <str> :              sig1 = 0.5 * np . sqrt ( blue1 [ <str> ] ** 2 + blue1 [ <str> ] ** 2 ) sig2 = 0.5 * np . sqrt ( blue2 [ <str> ] ** 2 + blue2 [ <str> ] ** 2 ) sig3 = 0.5 * np . sqrt ( red1 [ <str> ] ** 2 + red1 [ <str> ] ** 2 ) sig4 = 0.5 * np . sqrt ( red2 [ <str> ] ** 2 + red2 [ <str> ] ** 2 ) p1 = 0.5 * np . abs ( blue1 [ <str> ] - blue1 [ <str> ] ) p2 = 0.5 * np . abs ( blue2 [ <str> ] - blue2 [ <str> ] ) p3 = 0.5 * np . abs ( red1 [ <str> ] - red1 [ <str> ] ) p4 = 0.5 * np . abs ( red2 [ <str> ] - red2 [ <str> ] )  elif vtype == <str> :              sig1 = 0.5 * np . sqrt ( blue1 [ <str> ] ** 2 + blue1 [ <str> ] ** 2 ) sig2 = 0.5 * np . sqrt ( blue2 [ <str> ] ** 2 + blue2 [ <str> ] ** 2 ) sig3 = 0.5 * np . sqrt ( red1 [ <str> ] ** 2 + red1 [ <str> ] ** 2 ) sig4 = 0.5 * np . sqrt ( red2 [ <str> ] ** 2 + red2 [ <str> ] ** 2 ) p1 = 0.5 * np . abs ( blue1 [ <str> ] + blue1 [ <str> ] ) p2 = 0.5 * np . abs ( blue2 [ <str> ] + blue2 [ <str> ] ) p3 = 0.5 * np . abs ( red1 [ <str> ] + red1 [ <str> ] ) p4 = 0.5 * np . abs ( red2 [ <str> ] + red2 [ <str> ] )  elif vtype == <str> :              sig1 = 0.5 * np . sqrt ( blue1 [ <str> ] ** 2 + blue1 [ <str> ] ** 2 ) sig2 = 0.5 * np . sqrt ( blue2 [ <str> ] ** 2 + blue2 [ <str> ] ** 2 ) sig3 = 0.5 * np . sqrt ( red1 [ <str> ] ** 2 + red1 [ <str> ] ** 2 ) sig4 = 0.5 * np . sqrt ( red2 [ <str> ] ** 2 + red2 [ <str> ] ** 2 ) p1 = 0.5 * np . abs ( blue1 [ <str> ] - blue1 [ <str> ] ) p2 = 0.5 * np . abs ( blue2 [ <str> ] - blue2 [ <str> ] ) p3 = 0.5 * np . abs ( red1 [ <str> ] - red1 [ <str> ] ) p4 = 0.5 * np . abs ( red2 [ <str> ] - red2 [ <str> ] )   else :          raise Exception ( <str> )  if debias :          p1 = amp_debias ( p1 , sig1 , force_nonzero = True ) p2 = amp_debias ( p2 , sig2 , force_nonzero = True ) p3 = amp_debias ( p3 , sig3 , force_nonzero = True ) p4 = amp_debias ( p4 , sig4 , force_nonzero = True )  else :          p1 = np . abs ( p1 ) p2 = np . abs ( p2 ) p3 = np . abs ( p3 ) p4 = np . abs ( p4 )  snr1 = p1 / sig1 snr2 = p2 / sig2 snr3 = p3 / sig3 snr4 = p4 / sig4 if ctype == <str> :          camp = np . abs ( ( p1 * p2 ) / ( p3 * p4 ) ) camperr = camp * np . sqrt ( 1. / ( snr1 ** 2 ) + 1. / ( snr2 ** 2 ) + 1. / ( snr3 ** 2 ) + 1. / ( snr4 ** 2 ) ) if debias :              camp = camp_debias ( camp , snr3 , snr4 )   elif ctype == <str> :          camp = np . log ( np . abs ( p1 ) ) + np . log ( np . abs ( p2 ) ) - np . log ( np . abs ( p3 ) ) - np . log ( np . abs ( p4 ) ) camperr = np . sqrt ( 1. / ( snr1 ** 2 ) + 1. / ( snr2 ** 2 ) + 1. / ( snr3 ** 2 ) + 1. / ( snr4 ** 2 ) ) if debias :              camp = logcamp_debias ( camp , snr1 , snr2 , snr3 , snr4 )   return ( camp , camperr )  def amp_debias ( amp , sigma , force_nonzero = False ) :      deb2 = np . abs ( amp ) ** 2 - np . abs ( sigma ) ** 2 deb2 *= ( np . nan_to_num ( np . abs ( amp ) ) > np . nan_to_num ( np . abs ( sigma ) ) ) if force_nonzero :          deb2 += ( np . nan_to_num ( np . abs ( amp ) ) < np . nan_to_num ( np . abs ( sigma ) ) ) * np . abs ( sigma ) ** 2  out = np . sqrt ( deb2 ) return out  def camp_debias ( camp , snr3 , snr4 ) :      camp_debias = camp / ( 1 + 1. / ( snr3 ** 2 ) + 1. / ( snr4 ** 2 ) ) return camp_debias  def logcamp_debias ( log_camp , snr1 , snr2 , snr3 , snr4 ) :      log_camp_debias = log_camp + 0.5 * ( 1. / ( snr1 ** 2 ) + 1. / ( snr2 ** 2 ) - 1. / ( snr3 ** 2 ) - 1. / ( snr4 ** 2 ) ) return log_camp_debias  def gauss_uv ( u , v , flux , beamparams , x = 0. , y = 0. ) :      sigma_maj = beamparams [ 0 ] / ( 2 * np . sqrt ( 2 * np . log ( 2 ) ) ) sigma_min = beamparams [ 1 ] / ( 2 * np . sqrt ( 2 * np . log ( 2 ) ) ) theta = - beamparams [ 2 ] a = ( sigma_min * np . cos ( theta ) ) ** 2 + ( sigma_maj * np . sin ( theta ) ) ** 2 b = ( sigma_maj * np . cos ( theta ) ) ** 2 + ( sigma_min * np . sin ( theta ) ) ** 2 c = ( sigma_min ** 2 - sigma_maj ** 2 ) * np . cos ( theta ) * np . sin ( theta ) m = np . array ( [ [ a , c ] , [ c , b ] ] ) uv = np . array ( [ [ u [ i ] , v [ i ] ] for i in range ( len ( u ) ) ] ) x2 = np . array ( [ np . dot ( uvi , np . dot ( m , uvi ) ) for uvi in uv ] ) g = np . exp ( - 2 * np . pi ** 2 * x2 ) p = np . exp ( - 2j * np . pi * ( u * x + v * y ) ) return flux * g * p  def sgra_kernel_uv ( rf , u , v ) :      lcm = ( C / rf ) * 100 sigma_maj = FWHM_MAJ * ( lcm ** 2 ) / ( 2 * np . sqrt ( 2 * np . log ( 2 ) ) ) * RADPERUAS sigma_min = FWHM_MIN * ( lcm ** 2 ) / ( 2 * np . sqrt ( 2 * np . log ( 2 ) ) ) * RADPERUAS theta = - POS_ANG * DEGREE a = ( sigma_min * np . cos ( theta ) ) ** 2 + ( sigma_maj * np . sin ( theta ) ) ** 2 b = ( sigma_maj * np . cos ( theta ) ) ** 2 + ( sigma_min * np . sin ( theta ) ) ** 2 c = ( sigma_min ** 2 - sigma_maj ** 2 ) * np . cos ( theta ) * np . sin ( theta ) m = np . array ( [ [ a , c ] , [ c , b ] ] ) uv = np . array ( [ u , v ] ) x2 = np . dot ( uv , np . dot ( m , uv ) ) g = np . exp ( - 2 * np . pi ** 2 * x2 ) return g  def sgra_kernel_params ( rf ) :      lcm = ( C / rf ) * 100 fwhm_maj_rf = FWHM_MAJ * ( lcm ** 2 ) * RADPERUAS fwhm_min_rf = FWHM_MIN * ( lcm ** 2 ) * RADPERUAS theta = POS_ANG * DEGREE return np . array ( [ fwhm_maj_rf , fwhm_min_rf , theta ] )  def blnoise ( sefd1 , sefd2 , tint , bw ) :      noise = np . sqrt ( sefd1 * sefd2 / ( 2 * bw * tint ) ) / 0.88 return noise  def merr ( sigma , qsigma , usigma , I , m ) :      err = np . sqrt ( ( qsigma ** 2 + usigma ** 2 + ( sigma * np . abs ( m ) ) ** 2 ) / ( np . abs ( I ) ** 2 ) ) return err  def merr2 ( rlsigma , rrsigma , llsigma , I , m ) :      err = np . sqrt ( ( rlsigma ** 2 + ( rrsigma ** 2 + llsigma ** 2 ) * np . abs ( m ) ** 2 ) / ( np . abs ( I ) ** 2 ) ) return err  def cerror ( sigma ) :      noise = np . random . normal ( loc = 0 , scale = sigma ) + 1j * np . random . normal ( loc = 0 , scale = sigma ) return noise  def cerror_hash ( sigma , * args ) :      reargs = list ( args ) reargs . append ( <str> ) np . random . seed ( hash ( <str> . join ( map ( repr , reargs ) ) ) % 4294967295 ) re = np . random . randn ( ) imargs = list ( args ) imargs . append ( <str> ) np . random . seed ( hash ( <str> . join ( map ( repr , imargs ) ) ) % 4294967295 ) im = np . random . randn ( ) err = sigma * ( re + 1j * im ) return err  def hashrandn ( * args ) :      np . random . seed ( hash ( <str> . join ( map ( repr , args ) ) ) % 4294967295 ) noise = np . random . randn ( ) return noise  def hashrand ( * args ) :      np . random . seed ( hash ( <str> . join ( map ( repr , args ) ) ) % 4294967295 ) noise = np . random . rand ( ) return noise  def image_centroid ( im ) :      xlist = np . arange ( 0 , - im . xdim , - 1 ) * im . psize + ( im . psize * im . xdim ) / 2.0 - im . psize / 2.0 ylist = np . arange ( 0 , - im . ydim , - 1 ) * im . psize + ( im . psize * im . ydim ) / 2.0 - im . psize / 2.0 x0 = np . sum ( np . outer ( 0.0 * ylist + 1.0 , xlist ) . ravel ( ) * im . imvec ) / np . sum ( im . imvec ) y0 = np . sum ( np . outer ( ylist , 0.0 * xlist + 1.0 ) . ravel ( ) * im . imvec ) / np . sum ( im . imvec ) return np . array ( [ x0 , y0 ] )  def ftmatrix ( pdim , xdim , ydim , uvlist , pulse = PULSE_DEFAULT , mask = [ ] ) :      xlist = np . arange ( 0 , - xdim , - 1 ) * pdim + ( pdim * xdim ) / 2.0 - pdim / 2.0 ylist = np . arange ( 0 , - ydim , - 1 ) * pdim + ( pdim * ydim ) / 2.0 - pdim / 2.0 ftmatrices = [ pulse ( 2 * np . pi * uv [ 0 ] , 2 * np . pi * uv [ 1 ] , pdim , dom = <str> ) * np . outer ( np . exp ( 2j * np . pi * ylist * uv [ 1 ] ) , np . exp ( 2j * np . pi * xlist * uv [ 0 ] ) ) for uv in uvlist ] ftmatrices = np . reshape ( np . array ( ftmatrices ) , ( len ( uvlist ) , xdim * ydim ) ) if len ( mask ) :          ftmatrices = ftmatrices [ : , mask ]  return ftmatrices  def ftmatrix_centered ( im , pdim , xdim , ydim , uvlist , pulse = PULSE_DEFAULT ) :      xlist = np . arange ( 0 , - xdim , - 1 ) * pdim + ( pdim * xdim ) / 2.0 - pdim / 2.0 ylist = np . arange ( 0 , - ydim , - 1 ) * pdim + ( pdim * ydim ) / 2.0 - pdim / 2.0 x0 = np . sum ( np . outer ( 0.0 * ylist + 1.0 , xlist ) . ravel ( ) * im ) / np . sum ( im ) y0 = np . sum ( np . outer ( ylist , 0.0 * xlist + 1.0 ) . ravel ( ) * im ) / np . sum ( im ) xlist = xlist - x0 ylist = ylist - y0 ftmatrices = [ pulse ( 2 * np . pi * uv [ 0 ] , 2 * np . pi * uv [ 1 ] , pdim , dom = <str> ) * np . outer ( np . exp ( - 2j * np . pi * ylist * uv [ 1 ] ) , np . exp ( - 2j * np . pi * xlist * uv [ 0 ] ) ) for uv in uvlist ] ftmatrices = np . reshape ( np . array ( ftmatrices ) , ( len ( uvlist ) , xdim * ydim ) ) return ftmatrices  def ticks ( axisdim , psize , nticks = 8 ) :      axisdim = int ( axisdim ) nticks = int ( nticks ) if not axisdim % 2 : axisdim += 1 if nticks % 2 : nticks -= 1 tickspacing = float ( ( axisdim - 1 ) ) / nticks ticklocs = np . arange ( 0 , axisdim + 1 , tickspacing ) - 0.5 ticklabels = np . around ( psize * np . arange ( ( axisdim - 1 ) / 2.0 , - ( axisdim ) / 2.0 , - tickspacing ) , decimals = 1 ) return ( ticklocs , ticklabels )  def power_of_two ( target ) :      cur = 1 if target > 1 :          for i in range ( 0 , int ( target ) ) :              if ( cur >= target ) :                  return cur  else : cur *= 2   else :          return 1   def paritycompare ( perm1 , perm2 ) :      perm2 = list ( perm2 ) perm2_map = dict ( ( v , i ) for i , v in enumerate ( perm2 ) ) transCount = 0 for loc , p1 in enumerate ( perm1 ) :          p2 = perm2 [ loc ] if p1 != p2 :              sloc = perm2_map [ p1 ] perm2 [ loc ] , perm2 [ sloc ] = p1 , p2 perm2_map [ p1 ] , perm2_map [ p2 ] = sloc , loc transCount += 1   if not ( transCount % 2 ) : return 1 else : return - 1  def sigtype ( datatype ) :      datatype = str ( datatype ) if datatype in [ <str> , <str> ] : sigmatype = <str> elif datatype in [ <str> , <str> ] : sigmatype = <str> elif datatype in [ <str> , <str> ] : sigmatype = <str> elif datatype in [ <str> , <str> ] : sigmatype = <str> elif datatype in [ <str> , <str> ] : sigmatype = <str> elif datatype in [ <str> , <str> ] : sigmatype = <str> elif datatype in [ <str> , <str> ] : sigmatype = <str> elif datatype in [ <str> , <str> ] : sigmatype = <str> elif datatype in [ <str> , <str> ] : sigmatype = <str> elif datatype in [ <str> , <str> ] : sigmatype = <str> elif datatype in [ <str> , <str> ] : sigmatype = <str> elif datatype in [ <str> ] : sigmatype = <str> elif datatype in [ <str> ] : sigmatype = <str> elif datatype in [ <str> ] : sigmatype = <str> elif datatype in [ <str> ] : sigmatype = <str> elif datatype in [ <str> ] : sigmatype = <str> elif datatype in [ <str> ] : sigmatype = <str> elif datatype in [ <str> ] : sigmatype = <str> elif datatype in [ <str> ] : sigmatype = <str> elif datatype in [ <str> ] : sigmatype = <str> elif datatype in [ <str> ] : sigmatype = <str> else : sigmatype = False return sigmatype  def rastring ( ra ) :      h = int ( ra ) m = int ( ( ra - h ) * 60. ) s = ( ra - h - m / 60. ) * 3600. out = <str> % ( h , m , s ) return out  def decstring ( dec ) :      deg = int ( dec ) m = int ( ( abs ( dec ) - abs ( deg ) ) * 60. ) s = ( abs ( dec ) - abs ( deg ) - m / 60. ) * 3600. out = <str> % ( deg , m , s ) return out  def gmtstring ( gmt ) :      if gmt > 24.0 : gmt = gmt - 24.0 h = int ( gmt ) m = int ( ( gmt - h ) * 60. ) s = ( gmt - h - m / 60. ) * 3600. out = <str> % ( h , m , s ) return out  def gmst_to_utc ( gmst , mjd ) :      mjd = int ( mjd ) time_obj_ref = at . Time ( mjd , format = <str> , scale = <str> ) time_sidereal_ref = time_obj_ref . sidereal_time ( <str> , <str> ) . hour time_utc = ( gmst - time_sidereal_ref ) * 0.9972695601848 return time_utc  def utc_to_gmst ( utc , mjd ) :      mjd = int ( mjd ) time_obj = at . Time ( utc / 24.0 + np . floor ( mjd ) , format = <str> , scale = <str> ) time_sidereal = time_obj . sidereal_time ( <str> , <str> ) . hour return time_sidereal  def earthrot ( vecs , thetas ) :      if len ( vecs . shape ) == 1 :          vecs = np . array ( [ vecs ] )  if np . isscalar ( thetas ) :          thetas = np . array ( [ thetas for i in range ( len ( vecs ) ) ] )  if len ( thetas ) == len ( vecs ) :          rotvec = np . array ( [ np . dot ( np . array ( ( ( np . cos ( thetas [ i ] ) , - np . sin ( thetas [ i ] ) , 0 ) , ( np . sin ( thetas [ i ] ) , np . cos ( thetas [ i ] ) , 0 ) , ( 0 , 0 , 1 ) ) ) , vecs [ i ] ) for i in range ( len ( vecs ) ) ] )  elif len ( thetas ) == 1 :          rotvec = np . array ( [ np . dot ( np . array ( ( ( np . cos ( thetas [ 0 ] ) , - np . sin ( thetas [ 0 ] ) , 0 ) , ( np . sin ( thetas [ 0 ] ) , np . cos ( thetas [ 0 ] ) , 0 ) , ( 0 , 0 , 1 ) ) ) , vecs [ i ] ) for i in range ( len ( vecs ) ) ] )  elif len ( vecs ) == 1 :          rotvec = np . array ( [ np . dot ( np . array ( ( ( np . cos ( thetas [ i ] ) , - np . sin ( thetas [ i ] ) , 0 ) , ( np . sin ( thetas [ i ] ) , np . cos ( thetas [ i ] ) , 0 ) , ( 0 , 0 , 1 ) ) ) , vecs [ 0 ] ) for i in range ( len ( thetas ) ) ] )  else :          raise Exception ( <str> )  return rotvec  def elev ( obsvecs , sourcevec ) :      if len ( obsvecs . shape ) == 1 :          obsvecs = np . array ( [ obsvecs ] )  anglebtw = np . array ( [ np . dot ( obsvec , sourcevec ) / np . linalg . norm ( obsvec ) / np . linalg . norm ( sourcevec ) for obsvec in obsvecs ] ) el = 0.5 * np . pi - np . arccos ( anglebtw ) return el  def elevcut ( obsvecs , sourcevec , elevmin = ELEV_LOW , elevmax = ELEV_HIGH ) :      angles = elev ( obsvecs , sourcevec ) / DEGREE return ( angles > elevmin ) * ( angles < elevmax )  def hr_angle ( gst , lon , ra ) :      hr_angle = np . mod ( gst + lon - ra , 2 * np . pi ) return hr_angle  def par_angle ( hr_angle , lat , dec ) :      num = np . sin ( hr_angle ) * np . cos ( lat ) denom = np . sin ( lat ) * np . cos ( dec ) - np . cos ( lat ) * np . sin ( dec ) * np . cos ( hr_angle ) return np . arctan2 ( num , denom )  def xyz_2_latlong ( obsvecs ) :      if len ( obsvecs . shape ) == 1 :          obsvecs = np . array ( [ obsvecs ] )  out = [ ] for obsvec in obsvecs :          x = obsvec [ 0 ] y = obsvec [ 1 ] z = obsvec [ 2 ] lon = np . array ( np . arctan2 ( y , x ) ) lat = np . array ( np . arctan2 ( z , np . sqrt ( x ** 2 + y ** 2 ) ) ) out . append ( [ lat , lon ] )  out = np . array ( out ) return out  def tri_minimal_set ( sites , tarr , tkey ) :      sites_ordered = [ x for x in tarr [ <str> ] if x in sites ] ref = sites_ordered [ 0 ] sites_ordered . remove ( ref ) tris = list ( it . combinations ( sites_ordered , 2 ) ) tris = [ ( ref , t [ 0 ] , t [ 1 ] ) for t in tris ] return tris  def quad_minimal_set ( sites , tarr , tkey ) :      sites_ordered = np . array ( [ x for x in tarr [ <str> ] if x in sites ] ) ref = sites_ordered [ 0 ] quads = [ ] for i in range ( 3 , len ( sites_ordered ) ) :          for j in range ( 1 , i ) :              if j == i - 1 : k = 1 else : k = j + 1 quad = ( ref , sites_ordered [ i ] , sites_ordered [ j ] , sites_ordered [ k ] ) quads . append ( quad )   return quads  def reduce_tri_minimal ( obs , datarr ) :      if not ( type ( datarr ) is list ) :          datalist = [ ] dtype = datarr . dtype for key , group in it . groupby ( datarr , lambda x : x [ <str> ] ) :              datalist . append ( np . array ( [ gp for gp in group ] , dtype = dtype ) )  returnType = <str>  else :          dtype = datarr [ 0 ] . dtype datalist = datarr returnType = <str>  out = [ ] for timegroup in datalist :          if returnType == <str> :              outgroup = out  else :              outgroup = [ ]  sites = list ( set ( np . hstack ( ( timegroup [ <str> ] , timegroup [ <str> ] , timegroup [ <str> ] ) ) ) ) tris = tri_minimal_set ( sites , obs . tarr , obs . tkey ) tris = [ set ( tri ) for tri in tris ] for dp in timegroup :              if set ( ( dp [ <str> ] , dp [ <str> ] , dp [ <str> ] ) ) in tris :                  outgroup . append ( dp )   if returnType == <str> :              out . append ( np . array ( outgroup , dtype = dtype ) )  else :              out = outgroup   if returnType == <str> :          out = np . array ( out , dtype = dtype )  return out  def reduce_quad_minimal ( obs , datarr , ctype = <str> ) :      if not ctype in [ <str> , <str> ] :          raise Exception ( <str> )  if not ( type ( datarr ) is list ) :          datalist = [ ] dtype = datarr . dtype for key , group in it . groupby ( datarr , lambda x : x [ <str> ] ) :              datalist . append ( np . array ( [ x for x in group ] ) )  returnType = <str>  else :          dtype = datarr [ 0 ] . dtype datalist = datarr returnType = <str>  out = [ ] for timegroup in datalist :          if returnType == <str> :              outgroup = out  else :              outgroup = [ ]  sites = np . array ( list ( set ( np . hstack ( ( timegroup [ <str> ] , timegroup [ <str> ] , timegroup [ <str> ] , timegroup [ <str> ] ) ) ) ) ) if len ( sites ) < 4 :              continue  quads = quad_minimal_set ( sites , obs . tarr , obs . tkey ) for dp in timegroup :              if ( ( dp [ <str> ] , dp [ <str> ] , dp [ <str> ] , dp [ <str> ] ) in quads or ( dp [ <str> ] , dp [ <str> ] , dp [ <str> ] , dp [ <str> ] ) in quads or ( dp [ <str> ] , dp [ <str> ] , dp [ <str> ] , dp [ <str> ] ) in quads or ( dp [ <str> ] , dp [ <str> ] , dp [ <str> ] , dp [ <str> ] ) in quads ) :                  outgroup . append ( np . array ( dp , dtype = DTCAMP ) )  elif ( ( dp [ <str> ] , dp [ <str> ] , dp [ <str> ] , dp [ <str> ] ) in quads or ( dp [ <str> ] , dp [ <str> ] , dp [ <str> ] , dp [ <str> ] ) in quads or ( dp [ <str> ] , dp [ <str> ] , dp [ <str> ] , dp [ <str> ] ) in quads or ( dp [ <str> ] , dp [ <str> ] , dp [ <str> ] , dp [ <str> ] ) in quads ) :                  dp2 = copy . deepcopy ( dp ) campold = dp [ <str> ] sigmaold = dp [ <str> ] t1old = dp [ <str> ] t2old = dp [ <str> ] t3old = dp [ <str> ] t4old = dp [ <str> ] u1old = dp [ <str> ] u2old = dp [ <str> ] u3old = dp [ <str> ] u4old = dp [ <str> ] v1old = dp [ <str> ] v2old = dp [ <str> ] v3old = dp [ <str> ] v4old = dp [ <str> ] dp2 [ <str> ] = t1old dp2 [ <str> ] = t4old dp2 [ <str> ] = t3old dp2 [ <str> ] = t2old dp2 [ <str> ] = u3old dp2 [ <str> ] = v3old dp2 [ <str> ] = - u4old dp2 [ <str> ] = - v4old dp2 [ <str> ] = u1old dp2 [ <str> ] = v1old dp2 [ <str> ] = - u2old dp2 [ <str> ] = - v2old if ctype == <str> :                      dp2 [ <str> ] = 1. / campold dp2 [ <str> ] = sigmaold / ( campold ** 2 )  elif ctype == <str> :                      dp2 [ <str> ] = - campold dp2 [ <str> ] = sigmaold  outgroup . append ( dp2 )   if returnType == <str> :              out . append ( np . array ( outgroup , dtype = dtype ) )  else :              out = outgroup   if returnType == <str> :          out = np . array ( out , dtype = dtype )  return out  def qimage ( iimage , mimage , chiimage ) :      return iimage * mimage * np . cos ( 2 * chiimage )  def uimage ( iimage , mimage , chiimage ) :      return iimage * mimage * np . sin ( 2 * chiimage )  class NFFTInfo ( object ) :      def __init__ ( self , xdim , ydim , psize , pulse , npad , p_rad , uv ) :          self . xdim = int ( xdim ) self . ydim = int ( ydim ) self . psize = psize self . pulse = pulse self . npad = int ( npad ) self . p_rad = int ( p_rad ) self . uv = uv self . uvdim = len ( uv ) uv_scaled = uv * psize nfft_plan = NFFT ( [ xdim , ydim ] , self . uvdim , m = p_rad , n = [ npad , npad ] ) nfft_plan . x = uv_scaled nfft_plan . precompute ( ) self . plan = nfft_plan phases = np . exp ( - 1j * np . pi * ( uv_scaled [ : , 0 ] + uv_scaled [ : , 1 ] ) ) pulses = np . fromiter ( ( pulse ( 2 * np . pi * uv_scaled [ i , 0 ] , 2 * np . pi * uv_scaled [ i , 1 ] , 1. , dom = <str> ) for i in range ( self . uvdim ) ) , <str> ) self . pulsefac = ( pulses * phases )   class SamplerInfo ( object ) :      def __init__ ( self , order , uv , pulsefac ) :          self . order = int ( order ) self . uv = uv self . pulsefac = pulsefac   class GridderInfo ( object ) :      def __init__ ( self , npad , func , p_rad , coords , weights ) :          self . npad = int ( npad ) self . conv_func = func self . p_rad = int ( p_rad ) self . coords = coords self . weights = weights   class ImInfo ( object ) :      def __init__ ( self , xdim , ydim , npad , psize , pulse ) :          self . xdim = int ( xdim ) self . ydim = int ( ydim ) self . npad = int ( npad ) self . psize = psize self . pulse = pulse padvalx1 = padvalx2 = int ( np . floor ( ( npad - xdim ) / 2.0 ) ) if xdim % 2 :              padvalx2 += 1  padvaly1 = padvaly2 = int ( np . floor ( ( npad - ydim ) / 2.0 ) ) if ydim % 2 :              padvaly2 += 1  self . padvalx1 = padvalx1 self . padvalx2 = padvalx2 self . padvaly1 = padvaly1 self . padvaly2 = padvaly2   def conv_func_pill ( x , y ) :      if abs ( x ) < 0.5 and abs ( y ) < 0.5 :          out = 1.  else :          out = 0.  return out  def conv_func_gauss ( x , y ) :      return np . exp ( - ( x ** 2 + y ** 2 ) )  def conv_func_cubicspline ( x , y ) :      if abs ( x ) <= 1 :          fx = 1.5 * abs ( x ) ** 3 - 2.5 * abs ( x ) ** 2 + 1  elif abs ( x ) < 2 :          fx = - 0.5 * abs ( x ) ** 3 + 2.5 * abs ( x ) ** 2 - 4 * abs ( x ) + 2  else :          fx = 0  if abs ( y ) <= 1 :          fy = 1.5 * abs ( y ) ** 3 - 2.5 * abs ( y ) ** 2 + 1  elif abs ( y ) < 2 :          fy = - 0.5 * abs ( y ) ** 3 + 2.5 * abs ( y ) ** 2 - 4 * abs ( y ) + 2  else :          fy = 0  return fx * fy  def fft_imvec ( imvec , im_info ) :      xdim = im_info . xdim ydim = im_info . ydim padvalx1 = im_info . padvalx1 padvalx2 = im_info . padvalx2 padvaly1 = im_info . padvaly1 padvaly2 = im_info . padvaly2 imarr = imvec . reshape ( ydim , xdim ) imarr = np . pad ( imarr , ( ( padvalx1 , padvalx2 ) , ( padvaly1 , padvaly2 ) ) , <str> , constant_values = 0.0 ) npad = imarr . shape [ 0 ] if imarr . shape [ 0 ] != imarr . shape [ 1 ] :          raise Exception ( <str> )  vis_im = np . fft . fftshift ( np . fft . fft2 ( np . fft . ifftshift ( imarr ) ) ) return vis_im  def sampler ( griddata , sampler_info_list , sample_type = <str> ) :      if sample_type not in [ <str> , <str> , <str> ] :          raise Exception ( <str> )  if griddata . shape [ 0 ] != griddata . shape [ 1 ] :          raise Exception ( <str> )  dataset = [ ] for sampler_info in sampler_info_list :          vu2 = sampler_info . uv pulsefac = sampler_info . pulsefac datare = nd . map_coordinates ( np . real ( griddata ) , vu2 , order = sampler_info . order ) dataim = nd . map_coordinates ( np . imag ( griddata ) , vu2 , order = sampler_info . order ) data = datare + 1j * dataim data = data * pulsefac dataset . append ( data )  if sample_type == <str> :          out = dataset [ 0 ]  if sample_type == <str> :          out = dataset [ 0 ] * dataset [ 1 ] * dataset [ 2 ]  if sample_type == <str> :          out = np . abs ( ( dataset [ 0 ] * dataset [ 1 ] ) / ( dataset [ 2 ] * dataset [ 3 ] ) )  return out  def gridder ( data_list , gridder_info_list ) :      if len ( data_list ) != len ( gridder_info_list ) :          raise Exception ( <str> + <str> )  npad = gridder_info_list [ 0 ] . npad datagrid = np . zeros ( ( npad , npad ) ) . astype ( <str> ) for k in range ( len ( gridder_info_list ) ) :          gridder_info = gridder_info_list [ k ] data = data_list [ k ] if gridder_info . npad != npad :              raise Exception ( <str> )  p_rad = gridder_info . p_rad coords = gridder_info . coords weights = gridder_info . weights p_rad = int ( p_rad ) for i in range ( 2 * p_rad + 1 ) :              dy = i - p_rad for j in range ( 2 * p_rad + 1 ) :                  dx = j - p_rad weight = weights [ i ] [ j ] np . add . at ( datagrid , tuple ( map ( tuple , ( coords + [ dy , dx ] ) . transpose ( ) ) ) , data * weight )    return datagrid  def make_gridder_and_sampler_info ( im_info , uv , conv_func = GRIDDER_CONV_FUNC_DEFAULT , p_rad = GRIDDER_P_RAD_DEFAULT , order = FFT_INTERP_DEFAULT ) :      if not ( conv_func in [ <str> , <str> , <str> ] ) :          raise Exception ( <str> )  xdim = im_info . xdim ydim = im_info . ydim npad = im_info . npad psize = im_info . psize pulse = im_info . pulse vu2 = np . hstack ( ( uv [ : , 1 ] . reshape ( - 1 , 1 ) , uv [ : , 0 ] . reshape ( - 1 , 1 ) ) ) du = 1.0 / ( npad * psize ) vu2 = ( vu2 / du + 0.5 * npad ) coords = np . round ( vu2 ) . astype ( int ) dcoords = vu2 - np . round ( vu2 ) . astype ( int ) vu2 = vu2 . T phase = np . exp ( - 1j * np . pi * psize * ( ( 1 + im_info . xdim % 2 ) * uv [ : , 0 ] + ( 1 + im_info . ydim % 2 ) * uv [ : , 1 ] ) ) pulsefac = np . fromiter ( ( pulse ( 2 * np . pi * uvpt [ 0 ] , 2 * np . pi * uvpt [ 1 ] , psize , dom = <str> ) for uvpt in uv ) , <str> ) pulsefac = pulsefac * phase weights = [ ] norm = np . zeros_like ( len ( coords ) ) for i in range ( 2 * p_rad + 1 ) :          weights . append ( [ ] ) dy = i - p_rad for j in range ( 2 * p_rad + 1 ) :              dx = j - p_rad if conv_func == <str> :                  norm = norm + conv_func_gauss ( dy - dcoords [ : , 0 ] , dx - dcoords [ : , 1 ] )  elif conv_func == <str> :                  norm = norm + conv_func_pill ( dy - dcoords [ : , 0 ] , dx - dcoords [ : , 1 ] )  elif conv_func == <str> :                  norm = norm + conv_func_cubicspline ( dy - dcoords [ : , 0 ] , dx - dcoords [ : , 1 ] )  weights [ i ] . append ( None )   for i in range ( 2 * p_rad + 1 ) :          dy = i - p_rad for j in range ( 2 * p_rad + 1 ) :              dx = j - p_rad if conv_func == <str> :                  weight = conv_func_gauss ( dy - dcoords [ : , 0 ] , dx - dcoords [ : , 1 ] ) / norm  elif conv_func == <str> :                  weight = conv_func_pill ( dy - dcoords [ : , 0 ] , dx - dcoords [ : , 1 ] ) / norm  elif conv_func == <str> :                  weight = conv_func_cubicspline ( dy - dcoords [ : , 0 ] , dx - dcoords [ : , 1 ] ) / norm  weights [ i ] [ j ] = weight   sampler_info = SamplerInfo ( order , vu2 , pulsefac ) gridder_info = GridderInfo ( npad , conv_func , p_rad , coords , weights ) return ( sampler_info , gridder_info )   