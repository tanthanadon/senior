from __future__ import division from __future__ import print_function from builtins import range import numpy as np import string import astropy . io . fits as fits import datetime import os import ehtim . io . writeData import ehtim . io . oifits from astropy . time import Time from ehtim . const_def import * from ehtim . observing . obs_helpers import * def save_im_txt ( im , fname , mjd = False , time = False ) :      if im . polrep != <str> or im . pol_prim != <str> :          im = im . switch_polrep ( polrep_out = <str> , pol_prim_out = None )  pdimas = im . psize / RADPERAS xs = np . array ( [ [ j for j in range ( im . xdim ) ] for i in range ( im . ydim ) ] ) . reshape ( im . xdim * im . ydim , 1 ) xs = pdimas * ( xs [ : : - 1 ] - im . xdim / 2.0 ) ys = np . array ( [ [ i for j in range ( im . xdim ) ] for i in range ( im . ydim ) ] ) . reshape ( im . xdim * im . ydim , 1 ) ys = pdimas * ( ys [ : : - 1 ] - im . xdim / 2.0 ) if len ( im . vvec ) and not len ( im . qvec ) :          im . qvec = 0 * im . vvec im . uvec = 0 * im . vvec  if len ( im . qvec ) and len ( im . vvec ) :          outdata = np . hstack ( ( xs , ys , ( im . imvec ) . reshape ( im . xdim * im . ydim , 1 ) , ( im . qvec ) . reshape ( im . xdim * im . ydim , 1 ) , ( im . uvec ) . reshape ( im . xdim * im . ydim , 1 ) , ( im . vvec ) . reshape ( im . xdim * im . ydim , 1 ) ) ) hf = <str> fmts = <str>  elif len ( im . qvec ) :          outdata = np . hstack ( ( xs , ys , ( im . imvec ) . reshape ( im . xdim * im . ydim , 1 ) , ( im . qvec ) . reshape ( im . xdim * im . ydim , 1 ) , ( im . uvec ) . reshape ( im . xdim * im . ydim , 1 ) ) ) hf = <str> fmts = <str>  else :          outdata = np . hstack ( ( xs , ys , ( im . imvec ) . reshape ( im . xdim * im . ydim , 1 ) ) ) hf = <str> fmts = <str>  if not mjd : mjd = float ( im . mjd ) if not time : time = im . time mjd += ( time / 24. ) head = ( <str> % im . source + <str> + rastring ( im . ra ) + <str> + <str> + decstring ( im . dec ) + <str> + <str> % ( float ( mjd ) ) + <str> % ( im . rf / 1e9 ) + <str> % ( im . xdim , pdimas * im . xdim ) + <str> % ( im . ydim , pdimas * im . ydim ) + <str> + hf ) np . savetxt ( fname , outdata , header = head , fmt = fmts ) return  def save_im_fits ( im , fname , mjd = False , time = False ) :      if ( im . polrep != <str> ) or ( im . pol_prim != <str> ) :          im = im . switch_polrep ( polrep_out = <str> , pol_prim_out = None )  header = fits . Header ( ) header [ <str> ] = im . source header [ <str> ] = <str> header [ <str> ] = <str> header [ <str> ] = - im . psize / DEGREE header [ <str> ] = im . psize / DEGREE header [ <str> ] = im . ra * 180 / 12. header [ <str> ] = im . dec header [ <str> ] = im . rf header [ <str> ] = im . xdim / 2. + .5 header [ <str> ] = im . ydim / 2. + .5 if not mjd : mjd = float ( im . mjd ) if not time : time = im . time mjd += ( time / 24. ) header [ <str> ] = float ( mjd ) header [ <str> ] = <str> header [ <str> ] = <str> header [ <str> ] = <str> image = np . reshape ( im . imvec , ( im . ydim , im . xdim ) ) [ : : - 1 , : ] hdu = fits . PrimaryHDU ( image , header = header ) hdulist = [ hdu ] if len ( im . qvec ) :          qimage = np . reshape ( im . qvec , ( im . xdim , im . ydim ) ) [ : : - 1 , : ] uimage = np . reshape ( im . uvec , ( im . xdim , im . ydim ) ) [ : : - 1 , : ] header [ <str> ] = <str> hduq = fits . ImageHDU ( qimage , name = <str> , header = header ) header [ <str> ] = <str> hduu = fits . ImageHDU ( uimage , name = <str> , header = header ) hdulist = [ hdu , hduq , hduu ]  if len ( im . vvec ) :          vimage = np . reshape ( im . vvec , ( im . xdim , im . ydim ) ) [ : : - 1 , : ] header [ <str> ] = <str> hduv = fits . ImageHDU ( vimage , name = <str> , header = header ) hdulist . append ( hduv )  hdulist = fits . HDUList ( hdulist ) hdulist . writeto ( fname , overwrite = True ) return  def save_mov_fits ( mov , fname , mjd = False ) :      if mjd == False : mjd = mov . mjd for i in range ( mov . nframes ) :          time_frame = mov . start_hr + i * mov . framedur / 3600. fname_frame = fname + <str> % i print ( <str> + fname_frame ) frame_im = mov . get_frame ( i ) save_im_fits ( frame_im , fname_frame , mjd = mjd , time = time_frame )  return  def save_mov_txt ( mov , fname , mjd = False ) :      if mjd == False : mjd = mov . mjd for i in range ( mov . nframes ) :          time_frame = mov . start_hr + i * mov . framedur / 3600. fname_frame = fname + <str> % i print ( <str> + fname_frame ) frame_im = mov . get_frame ( i ) save_im_txt ( frame_im , fname_frame , mjd = mjd , time = time_frame )  return  def save_array_txt ( arr , fname ) :      import ehtim . array as array if type ( arr ) == np . ndarray :          tarr = arr  else :          try :              tarr = arr . tarr  except :              print ( <str> )   out = ( <str> + <str> + <str> ) for scope in range ( len ( tarr ) ) :          dat = ( tarr [ scope ] [ <str> ] , tarr [ scope ] [ <str> ] , tarr [ scope ] [ <str> ] , tarr [ scope ] [ <str> ] , tarr [ scope ] [ <str> ] , tarr [ scope ] [ <str> ] , tarr [ scope ] [ <str> ] , tarr [ scope ] [ <str> ] , tarr [ scope ] [ <str> ] , tarr [ scope ] [ <str> ] . real , tarr [ scope ] [ <str> ] . imag , tarr [ scope ] [ <str> ] . real , tarr [ scope ] [ <str> ] . imag ) out += <str> % dat  f = open ( fname , <str> ) f . write ( out ) f . close ( ) return  def save_obs_txt ( obs , fname ) :      if obs . polrep == <str> :          outdata = obs . unpack ( [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] )  elif obs . polrep == <str> :          outdata = obs . unpack ( [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] )  else : raise Exception ( <str> ) head = ( <str> % obs . source + <str> + rastring ( obs . ra ) + <str> + <str> + decstring ( obs . dec ) + <str> + <str> % obs . mjd + <str> % ( obs . rf / 1e9 ) + <str> % ( obs . bw / 1e9 ) + <str> % obs . phasecal + <str> % obs . ampcal + <str> % obs . opacitycal + <str> % obs . dcal + <str> % obs . frcal + <str> + <str> + <str> + <str> + <str> ) for i in range ( len ( obs . tarr ) ) :          head += ( <str> % ( obs . tarr [ i ] [ <str> ] , obs . tarr [ i ] [ <str> ] , obs . tarr [ i ] [ <str> ] , obs . tarr [ i ] [ <str> ] , obs . tarr [ i ] [ <str> ] , obs . tarr [ i ] [ <str> ] , obs . tarr [ i ] [ <str> ] , obs . tarr [ i ] [ <str> ] , obs . tarr [ i ] [ <str> ] , ( obs . tarr [ i ] [ <str> ] ) . real , ( obs . tarr [ i ] [ <str> ] ) . imag , ( obs . tarr [ i ] [ <str> ] ) . real , ( obs . tarr [ i ] [ <str> ] ) . imag ) )  if obs . polrep == <str> :          head += ( <str> + <str> + <str> + <str> + <str> )  elif obs . polrep == <str> :          head += ( <str> + <str> + <str> + <str> + <str> )  fmts = ( <str> + <str> + <str> ) np . savetxt ( fname , outdata , header = head , fmt = fmts ) return  def save_obs_uvfits ( obs , fname , force_singlepol = None , polrep_out = <str> ) :      if polrep_out == <str> :          obs = obs . switch_polrep ( <str> )  elif polrep_out == <str> :          obs = obs . switch_polrep ( <str> )  else :          raise Exception ( <str> )  dir_path = os . path . dirname ( os . path . realpath ( __file__ ) ) hdulist_new = fits . HDUList ( ) hdulist_new . append ( fits . GroupsHDU ( ) ) MJD_0 = 2400000.5 header = hdulist_new [ <str> ] . header header [ <str> ] = obs . ra * 180. / 12. header [ <str> ] = obs . dec header [ <str> ] = obs . source header [ <str> ] = float ( obs . mjd ) header [ <str> ] = Time ( obs . mjd + MJD_0 , format = <str> , scale = <str> , out_subfmt = <str> ) . iso header [ <str> ] = 1.0 header [ <str> ] = 0.0 header [ <str> ] = <str> header [ <str> ] = 3 header [ <str> ] = <str> header [ <str> ] = 1.e0 header [ <str> ] = 0.e0 header [ <str> ] = <str> header [ <str> ] = <str> header [ <str> ] = <str> header [ <str> ] = <str> header [ <str> ] = 1.e0 header [ <str> ] = 1.e0 header [ <str> ] = 1.e0 header [ <str> ] = 0.e0 header [ <str> ] = <str> if polrep_out == <str> :          header [ <str> ] = - 1.e0 header [ <str> ] = - 1.e0  elif polrep_out == <str> :          header [ <str> ] = 1.e0 header [ <str> ] = 1.e0  header [ <str> ] = 1.e0 header [ <str> ] = 0.e0 header [ <str> ] = <str> header [ <str> ] = obs . rf header [ <str> ] = obs . bw header [ <str> ] = 1.e0 header [ <str> ] = 0.e0 header [ <str> ] = <str> header [ <str> ] = header [ <str> ] header [ <str> ] = 1.e0 header [ <str> ] = 1.e0 header [ <str> ] = 0.e0 header [ <str> ] = <str> header [ <str> ] = header [ <str> ] header [ <str> ] = 1.e0 header [ <str> ] = 1.e0 header [ <str> ] = 0.e0 header [ <str> ] = <str> header [ <str> ] = 1.0 / obs . rf header [ <str> ] = 0.e0 header [ <str> ] = <str> header [ <str> ] = 1.0 / obs . rf header [ <str> ] = 0.e0 header [ <str> ] = <str> header [ <str> ] = 1.0 / obs . rf header [ <str> ] = 0.e0 header [ <str> ] = <str> header [ <str> ] = 1.e0 header [ <str> ] = 0.e0 header [ <str> ] = <str> header [ <str> ] = 1.e0 header [ <str> ] = 0.e0 header [ <str> ] = <str> header [ <str> ] = 1.e0 header [ <str> ] = 0.0 header [ <str> ] = <str> header [ <str> ] = 1.e0 header [ <str> ] = 0.e0 header [ <str> ] = <str> header [ <str> ] = 1.e0 header [ <str> ] = 0.e0 header [ <str> ] = <str> header [ <str> ] = 1.e0 header [ <str> ] = 0.e0 header [ <str> ] = <str> if polrep_out == <str> :          obsdata = obs . unpack ( [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] )  elif polrep_out == <str> :          obsdata = obs . unpack ( [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] )  ndat = len ( obsdata [ <str> ] ) jds = ( 2400000.5 + obs . mjd ) * np . ones ( len ( obsdata ) ) fractimes = ( obsdata [ <str> ] / 24.0 ) tints = obsdata [ <str> ] t1 = [ obs . tkey [ scope ] + 1 for scope in obsdata [ <str> ] ] t2 = [ obs . tkey [ scope ] + 1 for scope in obsdata [ <str> ] ] bl = 256 * np . array ( t1 ) + np . array ( t2 ) tau1 = obsdata [ <str> ] tau2 = obsdata [ <str> ] u = obsdata [ <str> ] v = obsdata [ <str> ] if polrep_out == <str> :          rr = obsdata [ <str> ] ll = obsdata [ <str> ] rl = obsdata [ <str> ] lr = obsdata [ <str> ] weightrr = 1.0 / ( obsdata [ <str> ] ** 2 ) weightll = 1.0 / ( obsdata [ <str> ] ** 2 ) weightrl = 1.0 / ( obsdata [ <str> ] ** 2 ) weightlr = 1.0 / ( obsdata [ <str> ] ** 2 ) if force_singlepol == <str> :              if obs . polrep == <str> :                  raise Exception ( <str> )  print ( <str> ) ll = obsdata [ <str> ] rr = rr * 0.0 rl = rl * 0.0 lr = lr * 0.0 weightrr = weightrr * 0.0 weightrl = weightrl * 0.0 weightlr = weightlr * 0.0  elif force_singlepol == <str> :              if obs . polrep == <str> :                  raise Exception ( <str> )  print ( <str> ) rr = obsdata [ <str> ] ll = rr * 0.0 rl = rl * 0.0 lr = lr * 0.0 weightll = weightll * 0.0 weightrl = weightrl * 0.0 weightlr = weightlr * 0.0  dat1 = rr dat2 = ll dat3 = rl dat4 = lr weight1 = weightrr weight2 = weightll weight3 = weightrl weight4 = weightlr  elif polrep_out == <str> :          dat1 = obsdata [ <str> ] dat2 = obsdata [ <str> ] dat3 = obsdata [ <str> ] dat4 = obsdata [ <str> ] weight1 = 1.0 / ( obsdata [ <str> ] ** 2 ) weight2 = 1.0 / ( obsdata [ <str> ] ** 2 ) weight3 = 1.0 / ( obsdata [ <str> ] ** 2 ) weight4 = 1.0 / ( obsdata [ <str> ] ** 2 )  dat1 = np . nan_to_num ( dat1 ) dat2 = np . nan_to_num ( dat2 ) dat3 = np . nan_to_num ( dat3 ) dat4 = np . nan_to_num ( dat4 ) weight1 = np . nan_to_num ( weight1 ) weight2 = np . nan_to_num ( weight2 ) weight3 = np . nan_to_num ( weight3 ) weight4 = np . nan_to_num ( weight4 ) outdat = np . zeros ( ( ndat , 1 , 1 , 1 , 1 , 4 , 3 ) ) outdat [ : , 0 , 0 , 0 , 0 , 0 , 0 ] = np . real ( dat1 ) outdat [ : , 0 , 0 , 0 , 0 , 0 , 1 ] = np . imag ( dat1 ) outdat [ : , 0 , 0 , 0 , 0 , 0 , 2 ] = weight1 outdat [ : , 0 , 0 , 0 , 0 , 1 , 0 ] = np . real ( dat2 ) outdat [ : , 0 , 0 , 0 , 0 , 1 , 1 ] = np . imag ( dat2 ) outdat [ : , 0 , 0 , 0 , 0 , 1 , 2 ] = weight2 outdat [ : , 0 , 0 , 0 , 0 , 2 , 0 ] = np . real ( dat3 ) outdat [ : , 0 , 0 , 0 , 0 , 2 , 1 ] = np . imag ( dat3 ) outdat [ : , 0 , 0 , 0 , 0 , 2 , 2 ] = weight3 outdat [ : , 0 , 0 , 0 , 0 , 3 , 0 ] = np . real ( dat4 ) outdat [ : , 0 , 0 , 0 , 0 , 3 , 1 ] = np . imag ( dat4 ) outdat [ : , 0 , 0 , 0 , 0 , 3 , 2 ] = weight4 pars = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] x = fits . GroupData ( outdat , parnames = pars , pardata = [ u , v , np . zeros ( ndat ) , bl , jds , fractimes , tints , tau1 , tau2 ] , bitpix = - 32 ) hdulist_new [ <str> ] . data = x hdulist_new [ <str> ] . header = header tarr = obs . tarr tnames = tarr [ <str> ] tnums = np . arange ( 1 , len ( tarr ) + 1 ) xyz = np . array ( [ [ tarr [ i ] [ <str> ] , tarr [ i ] [ <str> ] , tarr [ i ] [ <str> ] ] for i in np . arange ( len ( tarr ) ) ] ) sefd = tarr [ <str> ] nsta = len ( tnames ) col1 = fits . Column ( name = <str> , format = <str> , array = tnames ) col2 = fits . Column ( name = <str> , format = <str> , unit = <str> , array = xyz ) col3 = fits . Column ( name = <str> , format = <str> , array = tnums ) colfin = fits . Column ( name = <str> , format = <str> , array = sefd ) col4 = fits . Column ( name = <str> , format = <str> , array = np . zeros ( nsta ) ) col5 = fits . Column ( name = <str> , format = <str> , unit = <str> , array = np . zeros ( nsta ) ) col6 = fits . Column ( name = <str> , format = <str> , array = np . array ( [ <str> for i in range ( nsta ) ] , dtype = <str> ) ) col7 = fits . Column ( name = <str> , format = <str> , unit = <str> , array = np . zeros ( nsta ) ) col8 = fits . Column ( name = <str> , format = <str> , array = np . zeros ( ( nsta , 3 ) ) ) col9 = fits . Column ( name = <str> , format = <str> , array = np . array ( [ <str> for i in range ( nsta ) ] , dtype = <str> ) ) col10 = fits . Column ( name = <str> , format = <str> , unit = <str> , array = ( 90. * np . ones ( nsta ) ) ) col11 = fits . Column ( name = <str> , format = <str> , array = np . zeros ( ( nsta , 3 ) ) ) col25 = fits . Column ( name = <str> , format = <str> , array = np . zeros ( 0 ) ) tbhdu = fits . BinTableHDU . from_columns ( fits . ColDefs ( [ col1 , col2 , col25 , col3 , col4 , col5 , col6 , col7 , col8 , col9 , col10 , col11 , colfin ] ) , name = <str> ) hdulist_new . append ( tbhdu ) head = hdulist_new [ <str> ] . header head [ <str> ] = 1 head [ <str> ] = 0.e0 head [ <str> ] = 0.e0 head [ <str> ] = 0.e0 rdate_tt_new = Time ( obs . mjd + MJD_0 , format = <str> , scale = <str> , out_subfmt = <str> ) rdate_out = rdate_tt_new . iso rdate_jd_out = rdate_tt_new . jd rdate_gstiao_out = rdate_tt_new . sidereal_time ( <str> , <str> ) . degree rdate_offset_out = ( rdate_tt_new . ut1 . datetime . second - rdate_tt_new . utc . datetime . second ) rdate_offset_out += 1.e-6 * ( rdate_tt_new . ut1 . datetime . microsecond - rdate_tt_new . utc . datetime . microsecond ) head [ <str> ] = rdate_out head [ <str> ] = rdate_gstiao_out head [ <str> ] = 360.9856 head [ <str> ] = rdate_offset_out head [ <str> ] = 0.e0 head [ <str> ] = <str> head [ <str> ] = obs . rf head [ <str> ] = 0.e0 head [ <str> ] = 0.e0 head [ <str> ] = <str> head [ <str> ] = <str> head [ <str> ] = <str> head [ <str> ] = 0 head [ <str> ] = 1 head [ <str> ] = 0 head [ <str> ] = <str> head [ <str> ] = 1 hdulist_new [ <str> ] . header = head nif = 1 col1 = np . array ( 1 , dtype = np . int32 ) . reshape ( [ nif ] ) col2 = np . array ( 0.0 , dtype = np . float64 ) . reshape ( [ nif ] ) col3 = np . array ( [ obs . bw ] , dtype = np . float32 ) . reshape ( [ nif ] ) col4 = np . array ( [ obs . bw ] , dtype = np . float32 ) . reshape ( [ nif ] ) col5 = np . array ( [ 1 ] , dtype = np . int32 ) . reshape ( [ nif ] ) col1 = fits . Column ( name = <str> , format = <str> , array = col1 ) col2 = fits . Column ( name = <str> , format = <str> % ( nif ) , array = col2 ) col3 = fits . Column ( name = <str> , format = <str> % ( nif ) , array = col3 ) col4 = fits . Column ( name = <str> , format = <str> % ( nif ) , array = col4 ) col5 = fits . Column ( name = <str> , format = <str> % ( nif ) , array = col5 ) cols = fits . ColDefs ( [ col1 , col2 , col3 , col4 , col5 ] ) tbhdu = fits . BinTableHDU . from_columns ( cols ) tbhdu . header . append ( ( <str> , nif , <str> ) ) tbhdu . header . append ( ( <str> , <str> ) ) tbhdu . header . append ( ( <str> , 1 ) ) hdulist_new . append ( tbhdu ) scan_times = [ ] scan_time_ints = [ ] start_vis = [ ] stop_vis = [ ] jj = 0 ROUND_SCAN_INT = 5 comp_fac = 3600 * 24 * 100 scan_arr = obs . scans print ( <str> ) if ( scan_arr is None or len ( scan_arr ) == 0 ) :          print ( <str> )  else :          try :              scan_arr = scan_arr / 24. for scan in scan_arr :                  scan_start = round ( scan [ 0 ] , ROUND_SCAN_INT ) scan_stop = round ( scan [ 1 ] , ROUND_SCAN_INT ) scan_dur = ( scan_stop - scan_start ) if jj >= len ( fractimes ) :                      break  jd = round ( fractimes [ jj ] , ROUND_SCAN_INT ) * comp_fac if ( np . floor ( jd ) >= np . floor ( scan_start * comp_fac ) ) and ( np . ceil ( jd ) <= np . ceil ( comp_fac * scan_stop ) ) :                      start_vis . append ( jj ) scan_times . append ( scan_start + 0.5 * scan_dur ) scan_time_ints . append ( scan_dur ) while ( jj < len ( fractimes ) and np . floor ( round ( fractimes [ jj ] , ROUND_SCAN_INT ) * comp_fac ) <= np . ceil ( comp_fac * scan_stop ) ) :                          jj += 1  stop_vis . append ( jj - 1 )  else :                      continue   if jj < len ( fractimes ) :                  print ( scan_arr [ - 1 ] ) print ( round ( scan_arr [ - 1 ] [ 0 ] , ROUND_SCAN_INT ) , round ( scan_arr [ - 1 ] [ 1 ] , ROUND_SCAN_INT ) ) print ( jj , len ( jds ) , round ( jds [ jj ] , ROUND_SCAN_INT ) ) print ( <str> ) print ( scan_times )  time_nx = fits . Column ( name = <str> , format = <str> , unit = <str> , array = np . array ( scan_times ) ) timeint_nx = fits . Column ( name = <str> , format = <str> , unit = <str> , array = np . array ( scan_time_ints ) ) sourceid_nx = fits . Column ( name = <str> , format = <str> , unit = <str> , array = np . ones ( len ( scan_times ) ) ) subarr_nx = fits . Column ( name = <str> , format = <str> , unit = <str> , array = np . ones ( len ( scan_times ) ) ) freqid_nx = fits . Column ( name = <str> , format = <str> , unit = <str> , array = np . ones ( len ( scan_times ) ) ) startvis_nx = fits . Column ( name = <str> , format = <str> , unit = <str> , array = np . array ( start_vis ) + 1 ) endvis_nx = fits . Column ( name = <str> , format = <str> , unit = <str> , array = np . array ( stop_vis ) + 1 ) cols = fits . ColDefs ( [ time_nx , timeint_nx , sourceid_nx , subarr_nx , freqid_nx , startvis_nx , endvis_nx ] ) tbhdu = fits . BinTableHDU . from_columns ( cols ) tbhdu . header . append ( ( <str> , <str> ) ) tbhdu . header . append ( ( <str> , 1 ) ) hdulist_new . append ( tbhdu )  except TypeError :              print ( <str> )   hdulist_new . writeto ( fname , overwrite = True ) return  def save_obs_oifits ( obs , fname , flux = 1.0 ) :      print ( <str> ) if ( obs . polrep != <str> ) :          raise Exception ( <str> )  obs . data [ <str> ] /= flux obs . data [ <str> ] /= flux data = obs . unpack ( [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] ) biarr = obs . bispectra ( mode = <str> , count = <str> ) antennaNames = obs . tarr [ <str> ] sefd = obs . tarr [ <str> ] antennaX = obs . tarr [ <str> ] antennaY = obs . tarr [ <str> ] antennaZ = obs . tarr [ <str> ] antennaDiam = sefd union = { } ; union = ehtim . io . writeData . arrayUnion ( antennaNames , union ) intTime = data [ <str> ] [ 0 ] if not all ( data [ <str> ] [ 0 ] == item for item in np . reshape ( data [ <str> ] , ( - 1 ) ) ) :          raise TypeError ( <str> )  amp = data [ <str> ] phase = data [ <str> ] viserror = data [ <str> ] u = data [ <str> ] v = data [ <str> ] ant1 = ehtim . io . writeData . convertStrings ( data [ <str> ] , union ) ant2 = ehtim . io . writeData . convertStrings ( data [ <str> ] , union ) time = data [ <str> ] dttime = np . array ( [ datetime . datetime . utcfromtimestamp ( x * 60.0 * 60.0 ) for x in time ] ) ; bi = biarr [ <str> ] t3amp = np . abs ( bi ) ; t3phi = np . angle ( bi , deg = 1 ) t3amperr = biarr [ <str> ] t3phierr = 180.0 / np . pi * ( 1.0 / t3amp ) * t3amperr ; uClosure = np . transpose ( np . array ( [ np . array ( biarr [ <str> ] ) , np . array ( biarr [ <str> ] ) ] ) ) ; vClosure = np . transpose ( np . array ( [ np . array ( biarr [ <str> ] ) , np . array ( biarr [ <str> ] ) ] ) ) ; timeClosure = biarr [ <str> ] dttimeClosure = np . array ( [ datetime . datetime . utcfromtimestamp ( x * 60.0 * 60.0 ) for x in timeClosure ] ) ; biarr_ant1 = ehtim . io . writeData . convertStrings ( biarr [ <str> ] , union ) biarr_ant2 = ehtim . io . writeData . convertStrings ( biarr [ <str> ] , union ) biarr_ant3 = ehtim . io . writeData . convertStrings ( biarr [ <str> ] , union ) antOrder = np . transpose ( np . array ( [ biarr_ant1 , biarr_ant2 , biarr_ant3 ] ) ) ehtim . io . writeData . writeOIFITS ( fname , obs . ra , obs . dec , obs . rf , obs . bw , intTime , amp , viserror , phase , viserror , u , v , ant1 , ant2 , dttime , t3amp , t3amperr , t3phi , t3phierr , uClosure , vClosure , antOrder , dttimeClosure , antennaNames , antennaDiam , antennaX , antennaY , antennaZ ) obs . data [ <str> ] *= flux obs . data [ <str> ] *= flux return  def save_dtype_txt ( obs , fname , dtype = <str> ) :      head = ( <str> % obs . source + <str> + rastring ( obs . ra ) + <str> + <str> + decstring ( obs . dec ) + <str> + <str> % obs . mjd + <str> % ( obs . rf / 1e9 ) + <str> % ( obs . bw / 1e9 ) + <str> % obs . phasecal + <str> % obs . ampcal + <str> % obs . opacitycal + <str> % obs . dcal + <str> % obs . frcal + <str> + <str> + <str> + <str> + <str> ) for i in range ( len ( obs . tarr ) ) :          head += ( <str> % ( obs . tarr [ i ] [ <str> ] , obs . tarr [ i ] [ <str> ] , obs . tarr [ i ] [ <str> ] , obs . tarr [ i ] [ <str> ] , obs . tarr [ i ] [ <str> ] , obs . tarr [ i ] [ <str> ] , obs . tarr [ i ] [ <str> ] , obs . tarr [ i ] [ <str> ] , obs . tarr [ i ] [ <str> ] , ( obs . tarr [ i ] [ <str> ] ) . real , ( obs . tarr [ i ] [ <str> ] ) . imag , ( obs . tarr [ i ] [ <str> ] ) . real , ( obs . tarr [ i ] [ <str> ] ) . imag ) )  if dtype == <str> :          outdata = obs . cphase head += ( <str> + <str> + <str> ) fmts = ( <str> )  elif dtype == <str> :          outdata = obs . logcamp head += ( <str> + <str> + <str> ) fmts = ( <str> )  elif dtype == <str> :          outdata = obs . camp head += ( <str> + <str> + <str> ) fmts = ( <str> )  elif dtype == <str> :          outdata = obs . bispec head += ( <str> + <str> + <str> ) fmts = ( <str> )  elif dtype == <str> :          outdata = obs . amp head += ( <str> + <str> + <str> ) fmts = ( <str> )  else :          raise Exception ( dtype + <str> )  np . savetxt ( fname , outdata , header = head , fmt = fmts ) return   