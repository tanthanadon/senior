from __future__ import division from __future__ import print_function from builtins import str from builtins import map from builtins import range import numpy as np try :      import pandas as pd  except ImportError :      print ( <str> ) print ( <str> )  import datetime as datetime from astropy . time import Time from ehtim . statistics . stats import * def make_df ( obs , polarization = <str> , band = <str> , round_s = 0.1 ) :      sour = obs . source df = pd . DataFrame ( data = obs . data ) df [ <str> ] = df [ <str> ] / 24. df [ <str> ] = obs . mjd + df [ <str> ] telescopes = list ( zip ( df [ <str> ] , df [ <str> ] ) ) telescopes = [ ( x [ 0 ] , x [ 1 ] ) for x in telescopes ] df [ <str> ] = [ x [ 0 ] + <str> + x [ 1 ] for x in telescopes ] if obs . polrep == <str> :          vis1 = <str> ; sig1 = <str>  elif obs . polrep == <str> :          vis1 = <str> ; sig1 = <str> df [ <str> ] = df [ vis1 ] df [ <str> ] = df [ sig1 ] df [ <str> ] = np . abs ( df [ <str> ] ) df [ <str> ] = np . abs ( df [ <str> ] ) df [ <str> ] = np . abs ( df [ <str> ] ) df [ <str> ] = np . abs ( df [ <str> ] ) df [ <str> ] = df [ <str> ] / df [ <str> ] df [ <str> ] = df [ <str> ] / df [ <str> ] df [ <str> ] = df [ <str> ] / df [ <str> ] df [ <str> ] = df [ <str> ] / df [ <str> ]  df [ <str> ] = list ( map ( np . abs , df [ vis1 ] ) ) df [ <str> ] = list ( map ( lambda x : ( 180. / np . pi ) * np . angle ( x ) , df [ vis1 ] ) ) df [ <str> ] = df [ <str> ] / df [ sig1 ] df [ <str> ] = Time ( df [ <str> ] , format = <str> ) . datetime df [ <str> ] = list ( map ( lambda x : round_time ( x , round_s = round_s ) , df [ <str> ] ) ) df [ <str> ] = Time ( df [ <str> ] , format = <str> ) . jd df [ <str> ] = polarization df [ <str> ] = band df [ <str> ] = sour df [ <str> ] = np . sqrt ( np . asarray ( df . u ) ** 2 + np . asarray ( df . v ) ** 2 ) return df  def make_amp ( obs , debias = True , polarization = <str> , band = <str> , round_s = 0.1 ) :      sour = obs . source df = pd . DataFrame ( data = obs . data ) df [ <str> ] = df [ <str> ] / 24. df [ <str> ] = obs . mjd + df [ <str> ] telescopes = list ( zip ( df [ <str> ] , df [ <str> ] ) ) telescopes = [ ( x [ 0 ] , x [ 1 ] ) for x in telescopes ] df [ <str> ] = [ x [ 0 ] + <str> + x [ 1 ] for x in telescopes ] df [ <str> ] = list ( map ( np . abs , df [ <str> ] ) ) if debias == True :          amp2 = np . maximum ( np . asarray ( df [ <str> ] ) ** 2 - np . asarray ( df [ <str> ] ) ** 2 , np . asarray ( df [ <str> ] ) ** 2 ) df [ <str> ] = np . sqrt ( amp2 )  df [ <str> ] = list ( map ( lambda x : ( 180. / np . pi ) * np . angle ( x ) , df [ <str> ] ) ) df [ <str> ] = Time ( df [ <str> ] , format = <str> ) . datetime df [ <str> ] = list ( map ( lambda x : round_time ( x , round_s = round_s ) , df [ <str> ] ) ) df [ <str> ] = Time ( df [ <str> ] , format = <str> ) . jd df [ <str> ] = polarization df [ <str> ] = band df [ <str> ] = df [ <str> ] / df [ <str> ] df [ <str> ] = sour df [ <str> ] = np . sqrt ( np . asarray ( df . u ) ** 2 + np . asarray ( df . v ) ** 2 ) return df  def coh_avg_vis ( obs , dt = 0 , scan_avg = False , return_type = <str> , err_type = <str> , num_samples = int ( 1e3 ) ) :      if ( dt <= 0 ) & ( scan_avg == False ) :          return obs . data  else :          vis = make_df ( obs ) if scan_avg == False :              t0 = datetime . datetime ( 1960 , 1 , 1 ) vis [ <str> ] = list ( map ( lambda x : np . floor ( ( x - t0 ) . total_seconds ( ) / float ( dt ) ) , vis . datetime ) ) grouping = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ]  else :              bins , labs = get_bins_labels ( obs . scans ) vis [ <str> ] = list ( pd . cut ( vis . time , bins , labels = labs ) ) grouping = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ]  vis [ <str> ] = 1 aggregated = { <str> : np . min , <str> : np . min , <str> : lambda x : len ( x ) , <str> : np . mean , <str> : np . mean , <str> : np . sum } if err_type not in [ <str> , <str> ] :              print ( <str> ) err_type = <str>  if obs . polrep == <str> :              vis1 = <str> ; vis2 = <str> ; vis3 = <str> ; vis4 = <str> sig1 = <str> ; sig2 = <str> ; sig3 = <str> ; sig4 = <str>  elif obs . polrep == <str> :              vis1 = <str> ; vis2 = <str> ; vis3 = <str> ; vis4 = <str> sig1 = <str> ; sig2 = <str> ; sig3 = <str> ; sig4 = <str>  if err_type == <str> :              vis [ <str> ] = vis [ vis1 ] vis [ <str> ] = vis [ vis2 ] vis [ <str> ] = vis [ vis3 ] vis [ <str> ] = vis [ vis4 ] meanF = lambda x : np . nanmean ( np . asarray ( x ) ) meanerrF = lambda x : bootstrap ( np . abs ( x ) , np . mean , num_samples = num_samples , wrapping_variable = False ) aggregated [ vis1 ] = meanF aggregated [ vis2 ] = meanF aggregated [ vis3 ] = meanF aggregated [ vis4 ] = meanF aggregated [ <str> ] = meanerrF aggregated [ <str> ] = meanerrF aggregated [ <str> ] = meanerrF aggregated [ <str> ] = meanerrF  elif err_type == <str> :              meanF = lambda x : np . nanmean ( np . asarray ( x ) ) def meanerrF ( x ) :                  x = np . asarray ( x ) x = x [ x == x ] try : ret = np . sqrt ( np . sum ( x ** 2 ) / len ( x ) ** 2 ) except : ret = np . nan + 1j * np . nan return ret  aggregated [ vis1 ] = meanF aggregated [ vis2 ] = meanF aggregated [ vis3 ] = meanF aggregated [ vis4 ] = meanF aggregated [ sig1 ] = meanerrF aggregated [ sig2 ] = meanerrF aggregated [ sig3 ] = meanerrF aggregated [ sig4 ] = meanerrF  vis_avg = vis . groupby ( grouping ) . agg ( aggregated ) . reset_index ( ) if err_type == <str> :              vis_avg [ sig1 ] = [ 0.5 * ( x [ 1 ] [ 1 ] - x [ 1 ] [ 0 ] ) for x in list ( vis_avg [ <str> ] ) ] vis_avg [ sig2 ] = [ 0.5 * ( x [ 1 ] [ 1 ] - x [ 1 ] [ 0 ] ) for x in list ( vis_avg [ <str> ] ) ] vis_avg [ sig3 ] = [ 0.5 * ( x [ 1 ] [ 1 ] - x [ 1 ] [ 0 ] ) for x in list ( vis_avg [ <str> ] ) ] vis_avg [ sig4 ] = [ 0.5 * ( x [ 1 ] [ 1 ] - x [ 1 ] [ 0 ] ) for x in list ( vis_avg [ <str> ] ) ]  vis_avg [ <str> ] = list ( map ( np . abs , vis_avg [ vis1 ] ) ) vis_avg [ <str> ] = list ( map ( lambda x : ( 180. / np . pi ) * np . angle ( x ) , vis_avg [ vis1 ] ) ) vis_avg [ <str> ] = vis_avg [ <str> ] / vis_avg [ sig1 ] if scan_avg == False :              half_bucket = dt / 2. vis_avg [ <str> ] = list ( map ( lambda x : t0 + datetime . timedelta ( seconds = int ( dt * x ) + half_bucket ) , vis_avg [ <str> ] ) ) vis_avg [ <str> ] = list ( map ( lambda x : ( Time ( x ) . mjd - obs . mjd ) * 24. , vis_avg [ <str> ] ) )  else :              vis_avg . drop ( list ( vis_avg [ vis_avg . scan < 0 ] . index . values ) , inplace = True )  if err_type == <str> :              vis_avg . drop ( labels = [ <str> , <str> , <str> , <str> ] , axis = <str> , inplace = True )  if return_type == <str> :              if obs . polrep == <str> :                  return df_to_rec ( vis_avg , <str> )  elif obs . polrep == <str> :                  return df_to_rec ( vis_avg , <str> )   elif return_type == <str> :              return vis_avg    def incoh_avg_vis ( obs , dt = 0 , debias = True , scan_avg = False , return_type = <str> , rec_type = <str> , err_type = <str> , num_samples = int ( 1e3 ) ) :      if ( dt <= 0 ) & ( scan_avg == False ) :          print ( <str> ) return obs . data  else :          vis = make_df ( obs ) if scan_avg == False :              t0 = datetime . datetime ( 1960 , 1 , 1 ) vis [ <str> ] = list ( map ( lambda x : np . floor ( ( x - t0 ) . total_seconds ( ) / float ( dt ) ) , vis . datetime ) ) grouping = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ]  else :              bins , labs = get_bins_labels ( obs . scans ) vis [ <str> ] = list ( pd . cut ( vis . time , bins , labels = labs ) ) grouping = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ]  vis [ <str> ] = 1 aggregated = { <str> : np . min , <str> : np . min , <str> : lambda x : len ( x ) , <str> : np . mean , <str> : np . mean , <str> : np . sum } if err_type not in [ <str> , <str> ] :              print ( <str> ) err_type = <str>  vis [ <str> ] = list ( zip ( np . abs ( vis [ <str> ] ) , vis [ <str> ] ) ) vis [ <str> ] = list ( zip ( np . abs ( vis [ <str> ] ) , vis [ <str> ] ) ) vis [ <str> ] = list ( zip ( np . abs ( vis [ <str> ] ) , vis [ <str> ] ) ) vis [ <str> ] = list ( zip ( np . abs ( vis [ <str> ] ) , vis [ <str> ] ) ) if err_type == <str> :              aggregated [ <str> ] = lambda x : mean_incoh_avg ( x , debias = debias ) aggregated [ <str> ] = lambda x : mean_incoh_avg ( x , debias = debias ) aggregated [ <str> ] = lambda x : mean_incoh_avg ( x , debias = debias ) aggregated [ <str> ] = lambda x : mean_incoh_avg ( x , debias = debias )  elif err_type == <str> :              aggregated [ <str> ] = lambda x : bootstrap ( np . abs ( np . asarray ( [ y [ 0 ] for y in x ] ) ) , np . mean , num_samples = num_samples , wrapping_variable = False ) aggregated [ <str> ] = lambda x : bootstrap ( np . abs ( np . asarray ( [ y [ 0 ] for y in x ] ) ) , np . mean , num_samples = num_samples , wrapping_variable = False ) aggregated [ <str> ] = lambda x : bootstrap ( np . abs ( np . asarray ( [ y [ 0 ] for y in x ] ) ) , np . mean , num_samples = num_samples , wrapping_variable = False ) aggregated [ <str> ] = lambda x : bootstrap ( np . abs ( np . asarray ( [ y [ 0 ] for y in x ] ) ) , np . mean , num_samples = num_samples , wrapping_variable = False )  vis_avg = vis . groupby ( grouping ) . agg ( aggregated ) . reset_index ( ) if err_type == <str> :              vis_avg [ <str> ] = [ x [ 0 ] for x in list ( vis_avg [ <str> ] ) ] vis_avg [ <str> ] = [ x [ 0 ] for x in list ( vis_avg [ <str> ] ) ] vis_avg [ <str> ] = [ x [ 0 ] for x in list ( vis_avg [ <str> ] ) ] vis_avg [ <str> ] = [ x [ 0 ] for x in list ( vis_avg [ <str> ] ) ] vis_avg [ <str> ] = [ x [ 1 ] for x in list ( vis_avg [ <str> ] ) ] vis_avg [ <str> ] = [ x [ 1 ] for x in list ( vis_avg [ <str> ] ) ] vis_avg [ <str> ] = [ x [ 1 ] for x in list ( vis_avg [ <str> ] ) ] vis_avg [ <str> ] = [ x [ 1 ] for x in list ( vis_avg [ <str> ] ) ]  elif err_type == <str> :              vis_avg [ <str> ] = [ x [ 0 ] for x in list ( vis_avg [ <str> ] ) ] vis_avg [ <str> ] = [ x [ 0 ] for x in list ( vis_avg [ <str> ] ) ] vis_avg [ <str> ] = [ x [ 0 ] for x in list ( vis_avg [ <str> ] ) ] vis_avg [ <str> ] = [ x [ 0 ] for x in list ( vis_avg [ <str> ] ) ] vis_avg [ <str> ] = [ 0.5 * ( x [ 1 ] [ 1 ] - x [ 1 ] [ 0 ] ) for x in list ( vis_avg [ <str> ] ) ] vis_avg [ <str> ] = [ 0.5 * ( x [ 1 ] [ 1 ] - x [ 1 ] [ 0 ] ) for x in list ( vis_avg [ <str> ] ) ] vis_avg [ <str> ] = [ 0.5 * ( x [ 1 ] [ 1 ] - x [ 1 ] [ 0 ] ) for x in list ( vis_avg [ <str> ] ) ] vis_avg [ <str> ] = [ 0.5 * ( x [ 1 ] [ 1 ] - x [ 1 ] [ 0 ] ) for x in list ( vis_avg [ <str> ] ) ]  vis_avg [ <str> ] = list ( map ( np . abs , vis_avg [ <str> ] ) ) vis_avg [ <str> ] = 0 vis_avg [ <str> ] = vis_avg [ <str> ] / vis_avg [ <str> ] if scan_avg == False :              half_bucket = dt / 2. vis_avg [ <str> ] = list ( map ( lambda x : t0 + datetime . timedelta ( seconds = int ( dt * x ) + half_bucket ) , vis_avg [ <str> ] ) ) vis_avg [ <str> ] = list ( map ( lambda x : ( Time ( x ) . mjd - obs . mjd ) * 24. , vis_avg [ <str> ] ) )  else :              vis_avg . drop ( list ( vis_avg [ vis_avg . scan < 0 ] . index . values ) , inplace = True )  vis_avg . drop ( labels = [ <str> , <str> , <str> , <str> ] , axis = <str> , inplace = True ) if return_type == <str> :              return df_to_rec ( vis_avg , rec_type )  elif return_type == <str> :              return vis_avg    def make_cphase_df ( obs , band = <str> , polarization = <str> , mode = <str> , count = <str> , round_s = 0.1 , snrcut = 0. , uv_min = False ) :      data = obs . c_phases ( mode = mode , count = count , snrcut = snrcut , uv_min = uv_min ) sour = obs . source df = pd . DataFrame ( data = data ) . copy ( ) df [ <str> ] = df [ <str> ] / 24. df [ <str> ] = obs . mjd + df [ <str> ] df [ <str> ] = list ( map ( lambda x : x [ 0 ] + <str> + x [ 1 ] + <str> + x [ 2 ] , zip ( df [ <str> ] , df [ <str> ] , df [ <str> ] ) ) ) df [ <str> ] = Time ( df [ <str> ] , format = <str> ) . datetime df [ <str> ] = list ( map ( lambda x : round_time ( x , round_s = round_s ) , df [ <str> ] ) ) df [ <str> ] = Time ( df [ <str> ] , format = <str> ) . jd df [ <str> ] = polarization df [ <str> ] = band df [ <str> ] = sour return df  def make_camp_df ( obs , ctype = <str> , debias = False , band = <str> , polarization = <str> , mode = <str> , count = <str> , round_s = 0.1 , snrcut = 0. ) :      data = obs . c_amplitudes ( mode = mode , count = count , debias = debias , ctype = ctype , snrcut = snrcut ) sour = obs . source df = pd . DataFrame ( data = data ) . copy ( ) df [ <str> ] = df [ <str> ] / 24. df [ <str> ] = obs . mjd + df [ <str> ] df [ <str> ] = list ( map ( lambda x : x [ 0 ] + <str> + x [ 1 ] + <str> + x [ 2 ] + <str> + x [ 3 ] , zip ( df [ <str> ] , df [ <str> ] , df [ <str> ] , df [ <str> ] ) ) ) df [ <str> ] = Time ( df [ <str> ] , format = <str> ) . datetime df [ <str> ] = list ( map ( lambda x : round_time ( x , round_s = round_s ) , df [ <str> ] ) ) df [ <str> ] = Time ( df [ <str> ] , format = <str> ) . jd df [ <str> ] = polarization df [ <str> ] = band df [ <str> ] = sour df [ <str> ] = ctype return df  def make_bsp_df ( obs , band = <str> , polarization = <str> , mode = <str> , count = <str> , round_s = 0.1 , snrcut = 0. , uv_min = False ) :      data = obs . bispectra ( mode = mode , count = count , snrcut = snrcut , uv_min = uv_min ) sour = obs . source df = pd . DataFrame ( data = data ) . copy ( ) df [ <str> ] = df [ <str> ] / 24. df [ <str> ] = obs . mjd + df [ <str> ] df [ <str> ] = list ( map ( lambda x : x [ 0 ] + <str> + x [ 1 ] + <str> + x [ 2 ] , zip ( df [ <str> ] , df [ <str> ] , df [ <str> ] ) ) ) df [ <str> ] = Time ( df [ <str> ] , format = <str> ) . datetime df [ <str> ] = list ( map ( lambda x : round_time ( x , round_s = round_s ) , df [ <str> ] ) ) df [ <str> ] = Time ( df [ <str> ] , format = <str> ) . jd df [ <str> ] = polarization df [ <str> ] = band df [ <str> ] = sour return df  def average_cphases ( cdf , dt , return_type = <str> , err_type = <str> , num_samples = 1000 , snrcut = 0. ) :      cdf2 = cdf . copy ( ) t0 = datetime . datetime ( 1960 , 1 , 1 ) cdf2 [ <str> ] = list ( map ( lambda x : np . round ( ( x - t0 ) . total_seconds ( ) / float ( dt ) ) , cdf2 . datetime ) ) grouping = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> ] cdf2 [ <str> ] = 1 aggregated = { <str> : np . min , <str> : np . mean , <str> : lambda x : len ( x ) , <str> : np . mean , <str> : np . mean , <str> : np . mean , <str> : np . mean , <str> : np . mean , <str> : np . mean } if err_type == <str> :          cdf2 [ <str> ] = cdf2 [ <str> ] aggregated [ <str> ] = lambda x : bootstrap ( x , circular_mean , num_samples = num_samples , wrapping_variable = True )  elif err_type == <str> :          aggregated [ <str> ] = circular_mean aggregated [ <str> ] = lambda x : np . sqrt ( np . sum ( x ** 2 ) / len ( x ) ** 2 )  else :          print ( <str> ) aggregated [ <str> ] = circular_mean aggregated [ <str> ] = lambda x : np . sqrt ( np . sum ( x ** 2 ) / len ( x ) ** 2 )  cdf2 = cdf2 . groupby ( grouping ) . agg ( aggregated ) . reset_index ( ) if err_type == <str> :          cdf2 [ <str> ] = [ x [ 0 ] for x in list ( cdf2 [ <str> ] ) ] cdf2 [ <str> ] = [ 0.5 * ( x [ 1 ] [ 1 ] - x [ 1 ] [ 0 ] ) for x in list ( cdf2 [ <str> ] ) ]  cdf2 = cdf2 [ cdf2 [ <str> ] < 180. / np . pi / snrcut ] . copy ( ) cdf2 [ <str> ] = list ( map ( lambda x : t0 + datetime . timedelta ( seconds = int ( dt * x ) ) , cdf2 [ <str> ] ) ) if return_type == <str> :          return df_to_rec ( cdf2 , <str> )  elif return_type == <str> :          return cdf2   def average_bispectra ( cdf , dt , return_type = <str> , num_samples = int ( 1e3 ) , snrcut = 0. ) :      cdf2 = cdf . copy ( ) t0 = datetime . datetime ( 1960 , 1 , 1 ) cdf2 [ <str> ] = list ( map ( lambda x : np . round ( ( x - t0 ) . total_seconds ( ) / float ( dt ) ) , cdf2 . datetime ) ) grouping = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> ] cdf2 [ <str> ] = 1 aggregated = { <str> : np . min , <str> : np . mean , <str> : lambda x : len ( x ) , <str> : np . mean , <str> : np . mean , <str> : np . mean , <str> : np . mean , <str> : np . mean , <str> : np . mean } aggregated [ <str> ] = np . mean aggregated [ <str> ] = lambda x : np . sqrt ( np . sum ( x ** 2 ) / len ( x ) ** 2 ) cdf2 = cdf2 . groupby ( grouping ) . agg ( aggregated ) . reset_index ( ) cdf2 = cdf2 [ np . abs ( cdf2 [ <str> ] / cdf2 [ <str> ] ) > snrcut ] . copy ( ) cdf2 [ <str> ] = list ( map ( lambda x : t0 + datetime . timedelta ( seconds = int ( dt * x ) ) , cdf2 [ <str> ] ) ) if return_type == <str> :          return df_to_rec ( cdf2 , <str> )  elif return_type == <str> :          return cdf2   def average_camp ( cdf , dt , return_type = <str> , err_type = <str> , num_samples = int ( 1e3 ) ) :      cdf2 = cdf . copy ( ) t0 = datetime . datetime ( 1960 , 1 , 1 ) cdf2 [ <str> ] = list ( map ( lambda x : np . round ( ( x - t0 ) . total_seconds ( ) / float ( dt ) ) , cdf2 . datetime ) ) grouping = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] cdf2 [ <str> ] = 1 aggregated = { <str> : np . min , <str> : np . mean , <str> : lambda x : len ( x ) , <str> : np . mean , <str> : np . mean , <str> : np . mean , <str> : np . mean , <str> : np . mean , <str> : np . mean , <str> : np . mean , <str> : np . mean } if err_type == <str> :          cdf2 [ <str> ] = cdf2 [ <str> ] aggregated [ <str> ] = lambda x : bootstrap ( x , np . mean , num_samples = num_samples , wrapping_variable = False )  elif err_type == <str> :          aggregated [ <str> ] = np . mean aggregated [ <str> ] = lambda x : np . sqrt ( np . sum ( x ** 2 ) / len ( x ) ** 2 )  else :          print ( <str> ) aggregated [ <str> ] = np . mean aggregated [ <str> ] = lambda x : np . sqrt ( np . sum ( x ** 2 ) / len ( x ) ** 2 )  cdf2 = cdf2 . groupby ( grouping ) . agg ( aggregated ) . reset_index ( ) if err_type == <str> :          cdf2 [ <str> ] = [ x [ 0 ] for x in list ( cdf2 [ <str> ] ) ] cdf2 [ <str> ] = [ 0.5 * ( x [ 1 ] [ 1 ] - x [ 1 ] [ 0 ] ) for x in list ( cdf2 [ <str> ] ) ]  cdf2 [ <str> ] = list ( map ( lambda x : t0 + datetime . timedelta ( seconds = int ( dt * x ) ) , cdf2 [ <str> ] ) ) if return_type == <str> :          return df_to_rec ( cdf2 , <str> )  elif return_type == <str> :          return cdf2   def df_to_rec ( df , product_type ) :      if product_type == <str> :           out = df [ [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] ] . to_records ( index = False ) return np . array ( out , dtype = DTCPHASE )  elif product_type == <str> :           out = df [ [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] ] . to_records ( index = False ) return np . array ( out , dtype = DTCAMP )  elif product_type == <str> :           out = df [ [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] ] . to_records ( index = False ) return np . array ( out , dtype = DTPOL_STOKES )  elif product_type == <str> :           out = df [ [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] ] . to_records ( index = False ) return np . array ( out , dtype = DTPOL_CIRC )  elif product_type == <str> :           out = df [ [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] ] . to_records ( index = False ) return np . array ( out , dtype = DTAMP )  elif product_type == <str> :           out = df [ [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] ] . to_records ( index = False ) return np . array ( out , dtype = DTBIS )   def round_time ( t , round_s = 0.1 ) :      t0 = datetime . datetime ( t . year , 1 , 1 ) foo = t - t0 foo_s = foo . days * 24 * 3600 + foo . seconds + foo . microseconds * ( 1e-6 ) foo_s = np . round ( foo_s / round_s ) * round_s days = np . floor ( foo_s / 24 / 3600 ) seconds = np . floor ( foo_s - 24 * 3600 * days ) microseconds = int ( 1e6 * ( foo_s - days * 3600 * 24 - seconds ) ) round_t = t0 + datetime . timedelta ( days , seconds , microseconds ) return round_t  def get_bins_labels ( intervals , dt = 0.00001 ) :      def fix_midnight_overlap ( x ) :          if x [ 1 ] < x [ 0 ] :              x [ 1 ] += 24.  return x  def is_overlapping ( interval0 , interval1 ) :          if ( ( interval1 [ 0 ] <= interval0 [ 0 ] ) & ( interval1 [ 1 ] >= interval0 [ 0 ] ) ) | ( ( interval1 [ 0 ] <= interval0 [ 1 ] ) & ( interval1 [ 1 ] >= interval0 [ 1 ] ) ) :              return True  else : return False  def merge_overlapping_intervals ( intervals ) :          return ( np . min ( [ x [ 0 ] for x in intervals ] ) , np . max ( [ x [ 1 ] for x in intervals ] ) )  def replace_overlapping_intervals ( intervals , element_ind ) :          indic_not_overlap = [ not is_overlapping ( x , intervals [ element_ind ] ) for x in intervals ] indic_overlap = [ is_overlapping ( x , intervals [ element_ind ] ) for x in intervals ] fooarr = np . asarray ( intervals ) return sorted ( [ tuple ( x ) for x in fooarr [ indic_not_overlap ] ] + [ merge_overlapping_intervals ( list ( fooarr [ indic_overlap ] ) ) ] )  intervals = sorted ( list ( set ( zip ( intervals [ : , 0 ] , intervals [ : , 1 ] ) ) ) ) intervals = [ fix_midnight_overlap ( x ) for x in intervals ] cou = 0 while cou < len ( intervals ) :          intervals = replace_overlapping_intervals ( intervals , cou ) cou += 1  binsT = [ None ] * ( 2 * np . shape ( intervals ) [ 0 ] ) binsT [ : : 2 ] = [ x [ 0 ] - dt for x in intervals ] binsT [ 1 : : 2 ] = [ x [ 1 ] + dt for x in intervals ] labels = [ None ] * ( 2 * np . shape ( intervals ) [ 0 ] - 1 ) labels [ : : 2 ] = [ cou for cou in range ( 1 , len ( intervals ) + 1 ) ] labels [ 1 : : 2 ] = [ - cou for cou in range ( 1 , len ( intervals ) ) ] return binsT , labels  def common_set ( obs1 , obs2 , tolerance = 0 , uniquely = False , by_what = <str> ) :      if obs1 . polrep != obs2 . polrep :          raise ValueError ( <str> )  df1 = make_df ( obs1 ) df2 = make_df ( obs2 ) df1 [ <str> ] = list ( map ( lambda x : sorted ( x ) [ 0 ] , zip ( df1 . t1 , df1 . t2 ) ) ) df1 [ <str> ] = list ( map ( lambda x : sorted ( x ) [ 1 ] , zip ( df1 . t1 , df1 . t2 ) ) ) df2 [ <str> ] = list ( map ( lambda x : sorted ( x ) [ 0 ] , zip ( df2 . t1 , df2 . t2 ) ) ) df2 [ <str> ] = list ( map ( lambda x : sorted ( x ) [ 1 ] , zip ( df2 . t1 , df2 . t2 ) ) ) if by_what == <str> :          if tolerance > 0 :              d_mjd = tolerance / 24.0 / 60.0 / 60.0 df1 [ <str> ] = np . round ( df1 . mjd / d_mjd ) df2 [ <str> ] = np . round ( df2 . mjd / d_mjd )  else :              df1 [ <str> ] = df1 [ <str> ] df2 [ <str> ] = df2 [ <str> ]  df1 , df2 = match_multiple_frames ( [ df1 . copy ( ) , df2 . copy ( ) ] , [ <str> , <str> , <str> ] , uniquely = uniquely )  elif by_what == <str> :          df1 = add_gmst ( df1 ) df2 = add_gmst ( df2 ) if tolerance > 0 :              d_gmst = tolerance df1 [ <str> ] = np . round ( df1 . gmst / d_gmst ) df2 [ <str> ] = np . round ( df2 . gmst / d_gmst )  else :              df1 [ <str> ] = df1 [ <str> ] df2 [ <str> ] = df2 [ <str> ]  df1 , df2 = match_multiple_frames ( [ df1 . copy ( ) , df2 . copy ( ) ] , [ <str> , <str> , <str> ] , uniquely = uniquely )  elif by_what == <str> :          if tolerance > 0 :              d_lambda = tolerance df1 [ <str> ] = np . round ( df1 . u / d_lambda ) df1 [ <str> ] = np . round ( df1 . v / d_lambda ) df2 [ <str> ] = np . round ( df2 . u / d_lambda ) df2 [ <str> ] = np . round ( df2 . v / d_lambda )  else :              df1 [ <str> ] = df1 [ <str> ] df1 [ <str> ] = df1 [ <str> ] df2 [ <str> ] = df2 [ <str> ] df2 [ <str> ] = df2 [ <str> ]  df1 , df2 = match_multiple_frames ( [ df1 . copy ( ) , df2 . copy ( ) ] , [ <str> , <str> , <str> , <str> ] , uniquely = uniquely )  obs1cut = obs1 . copy ( ) obs2cut = obs2 . copy ( ) if obs1 . polrep == <str> :          obs1cut . data = df_to_rec ( df1 , <str> ) obs2cut . data = df_to_rec ( df2 , <str> )  elif obs1 . polrep == <str> :          obs1cut . data = df_to_rec ( df1 , <str> ) obs2cut . data = df_to_rec ( df2 , <str> )  return obs1cut , obs2cut  def match_multiple_frames ( frames , what_is_same , dt = 0 , uniquely = True ) :      if dt > 0 :          for frame in frames :              frame [ <str> ] = list ( map ( lambda x : np . round ( ( x - datetime . datetime ( 2017 , 4 , 4 ) ) . total_seconds ( ) / dt ) , frame [ <str> ] ) )  what_is_same += [ <str> ]  frames_common = { } for frame in frames :          frame [ <str> ] = list ( zip ( * [ frame [ x ] for x in what_is_same ] ) ) if frames_common != { } :              frames_common = frames_common & set ( frame [ <str> ] )  else :              frames_common = set ( frame [ <str> ] )   frames_out = [ ] for frame in frames :          frame = frame [ list ( map ( lambda x : x in frames_common , frame . all_ind ) ) ] . copy ( ) if uniquely :              frame . drop_duplicates ( subset = [ <str> ] , keep = <str> , inplace = True )  frame = frame . sort_values ( <str> ) . reset_index ( drop = True ) frame . drop ( <str> , axis = 1 , inplace = True ) frames_out . append ( frame . copy ( ) )  return frames_out  def add_gmst ( df ) :      from astropy import time g = df . groupby ( <str> ) ( timestamps , indices ) = list ( zip ( * iter ( g . groups . items ( ) ) ) ) if type ( timestamps [ 0 ] ) is np . datetime64 :          times_unix = 1e-9 * np . array ( timestamps ) . astype ( <str> )  elif type ( timestamps [ 0 ] ) is pd . Timestamp :          times_unix = np . array ( [ 1e-9 * t . value for t in timestamps ] )  else :          raise Exception ( <str> + repr ( type ( timestamps [ 0 ] ) ) )  times_gmst = time . Time ( times_unix , format = <str> ) . sidereal_time ( <str> , <str> ) . hour df [ <str> ] = 0. for ( gmst , idx ) in zip ( times_gmst , indices ) :          df . ix [ idx , <str> ] = gmst  return df    