from __future__ import division from __future__ import print_function import numpy as np import ehtim . imaging . imager_utils as iu import ehtim . observing . obs_simulate as simobs from ehtim . const_def import * import scipy . optimize as opt import matplotlib as mpl import matplotlib . pyplot as plt import time MAXIT = 1000 def leakage_cal ( obs , im , sites = [ ] , leakage_tol = .1 , pol_fit = [ <str> , <str> ] , dtype = <str> , const_fpol = False , minimizer_method = <str> , ttype = <str> , fft_pad_factor = 2 , show_solution = True , obs_apply = False ) :      tstart = time . time ( ) mask = [ ] im_circ = im . switch_polrep ( <str> ) if dtype not in [ <str> , <str> ] :          raise Exception ( <str> )  obs_test = obs . copy ( ) obs_test = obs_test . switch_polrep ( <str> ) if obs_test . frcal == False :          print ( <str> ) obs_test . data = simobs . apply_jones_inverse ( obs_test , frcal = False , dcal = True , verbose = False ) obs_test . frcal = True  allsites = list ( set ( np . hstack ( ( obs . data [ <str> ] , obs . data [ <str> ] ) ) ) ) if len ( sites ) == 0 :          print ( <str> ) sites = allsites  sites = [ s for s in sites if s in allsites ] site_index = [ list ( obs . tarr [ <str> ] ) . index ( s ) for s in sites ] ( dataRR , sigmaRR , ARR ) = iu . chisqdata ( obs , im_circ , mask = mask , dtype = dtype , pol = <str> , ttype = ttype , fft_pad_factor = fft_pad_factor ) ( dataLL , sigmaLL , ALL ) = iu . chisqdata ( obs , im_circ , mask = mask , dtype = dtype , pol = <str> , ttype = ttype , fft_pad_factor = fft_pad_factor ) ( dataRL , sigmaRL , ARL ) = iu . chisqdata ( obs , im_circ , mask = mask , dtype = dtype , pol = <str> , ttype = ttype , fft_pad_factor = fft_pad_factor ) ( dataLR , sigmaLR , ALR ) = iu . chisqdata ( obs , im_circ , mask = mask , dtype = dtype , pol = <str> , ttype = ttype , fft_pad_factor = fft_pad_factor ) def chisq_total ( data , im , D ) :          if const_fpol :              fpol_model = D [ - 1 ] fpol_data_1 = 2.0 * data [ <str> ] / ( data [ <str> ] + data [ <str> ] ) fpol_data_2 = 2.0 * np . conj ( data [ <str> ] / ( data [ <str> ] + data [ <str> ] ) ) fpol_sigma_1 = 2.0 / np . abs ( data [ <str> ] + data [ <str> ] ) * data [ <str> ] fpol_sigma_2 = 2.0 / np . abs ( data [ <str> ] + data [ <str> ] ) * data [ <str> ] return 0.5 * np . mean ( np . abs ( ( fpol_model - fpol_data_1 ) / fpol_sigma_1 ) ** 2 + np . abs ( ( fpol_model - fpol_data_2 ) / fpol_sigma_2 ) ** 2 )  else :              chisq_RR = chisq_LL = chisq_RL = chisq_LR = 0.0 if <str> in pol_fit : chisq_RR = iu . chisq ( im . rrvec , ARR , obs_test . unpack_dat ( data , [ <str> + dtype ] ) [ <str> + dtype ] , data [ <str> ] , dtype = dtype , ttype = ttype , mask = mask ) if <str> in pol_fit : chisq_LL = iu . chisq ( im . llvec , ALL , obs_test . unpack_dat ( data , [ <str> + dtype ] ) [ <str> + dtype ] , data [ <str> ] , dtype = dtype , ttype = ttype , mask = mask ) if <str> in pol_fit : chisq_RL = iu . chisq ( im . rlvec , ARL , obs_test . unpack_dat ( data , [ <str> + dtype ] ) [ <str> + dtype ] , data [ <str> ] , dtype = dtype , ttype = ttype , mask = mask ) if <str> in pol_fit : chisq_LR = iu . chisq ( im . lrvec , ALR , obs_test . unpack_dat ( data , [ <str> + dtype ] ) [ <str> + dtype ] , data [ <str> ] , dtype = dtype , ttype = ttype , mask = mask ) return ( chisq_RR + chisq_LL + chisq_RL + chisq_LR ) / len ( pol_fit )   print ( <str> , sites ) def errfunc ( Dpar ) :          D = Dpar . astype ( np . float64 ) . view ( dtype = np . complex128 ) for isite in range ( len ( sites ) ) :              obs_test . tarr [ <str> ] [ site_index [ isite ] ] = D [ 2 * isite ] obs_test . tarr [ <str> ] [ site_index [ isite ] ] = D [ 2 * isite + 1 ]  data = simobs . apply_jones_inverse ( obs_test , dcal = False , verbose = False ) chisq = chisq_total ( data , im_circ , D ) chisq_D = np . sum ( np . abs ( D / leakage_tol ) ** 2 ) return chisq + chisq_D  optdict = { <str> : MAXIT } Dpar_guess = np . zeros ( ( len ( sites ) + const_fpol ) * 2 , dtype = np . complex128 ) . view ( dtype = np . float64 ) print ( <str> ) res = opt . minimize ( errfunc , Dpar_guess , method = minimizer_method , options = optdict ) D_fit = res . x . astype ( np . float64 ) . view ( dtype = np . complex128 ) for isite in range ( len ( sites ) ) :          obs_test . tarr [ <str> ] [ site_index [ isite ] ] = D_fit [ 2 * isite ] obs_test . tarr [ <str> ] [ site_index [ isite ] ] = D_fit [ 2 * isite + 1 ]  obs_test . data = simobs . apply_jones_inverse ( obs_test , dcal = False , verbose = False ) obs_test . dcal = True if show_solution :          print ( <str> . format ( chisq_total ( obs . switch_polrep ( <str> ) . data , im_circ , D_fit ) ) ) print ( <str> . format ( chisq_total ( obs_test . data , im_circ , D_fit ) ) ) for isite in range ( len ( sites ) ) :              print ( sites [ isite ] ) print ( <str> . format ( D_fit [ 2 * isite ] ) ) print ( <str> . format ( D_fit [ 2 * isite + 1 ] ) )  if const_fpol :              print ( <str> . format ( np . abs ( D_fit [ - 1 ] ) ) ) print ( <str> . format ( 90. / np . pi * np . angle ( D_fit [ - 1 ] ) ) )   tstop = time . time ( ) print ( <str> % ( tstop - tstart ) ) if not obs_apply == False :          obs_test = obs_apply . copy ( ) for isite in range ( len ( sites ) ) :              obs_test . tarr [ <str> ] [ site_index [ isite ] ] = D_fit [ 2 * isite ] obs_test . tarr [ <str> ] [ site_index [ isite ] ] = D_fit [ 2 * isite + 1 ]  obs_test . data = simobs . apply_jones_inverse ( obs_test , dcal = False , verbose = False ) obs_test . dcal = True  else :          obs_test = obs_test . switch_polrep ( obs . polrep )  if not const_fpol :          return obs_test  else :          return [ obs_test , D_fit [ - 1 ] ]   def plot_leakage ( obs , sites = [ ] , axis = False , rangex = False , rangey = False , markers = [ <str> , <str> ] , markersize = 6 , export_pdf = <str> , axislabels = True , legend = True , sort_tarr = True , show = True ) :      tarr = obs . tarr . copy ( ) if sort_tarr :          tarr . sort ( axis = 0 )  if len ( sites ) :          mask = [ t in sites for t in tarr [ <str> ] ] tarr = tarr [ mask ]  clist = SCOLORS if axis :          fig = axis . figure x = axis  else :          fig = plt . figure ( ) x = fig . add_subplot ( 1 , 1 , 1 )  plt . axhline ( 0 , color = <str> ) plt . axvline ( 0 , color = <str> ) xymax = np . max ( [ np . abs ( tarr [ <str> ] ) , np . abs ( tarr [ <str> ] ) ] ) * 100.0 plot_points = [ ] for i in range ( len ( tarr ) ) :          color = clist [ i % len ( clist ) ] label = tarr [ <str> ] [ i ] plt . hold ( True ) dre , = x . plot ( np . real ( tarr [ <str> ] [ i ] ) * 100.0 , np . imag ( tarr [ <str> ] [ i ] ) * 100.0 , markers [ 0 ] , markersize = markersize , color = color , label = label ) dim , = x . plot ( np . real ( tarr [ <str> ] [ i ] ) * 100.0 , np . imag ( tarr [ <str> ] [ i ] ) * 100.0 , markers [ 1 ] , markersize = markersize , color = color , label = label ) plot_points . append ( [ dre , dim ] )  if not rangex :          rangex = [ - xymax * 1.1 - 0.01 , xymax * 1.1 + 0.01 ]  if not rangey :          rangey = [ - xymax * 1.1 - 0.01 , xymax * 1.1 + 0.01 ]  x . set_xlim ( rangex ) x . set_ylim ( rangey ) if axislabels :          x . set_xlabel ( <str> ) x . set_ylabel ( <str> )  if legend :          legend1 = plt . legend ( [ l [ 0 ] for l in plot_points ] , tarr [ <str> ] , ncol = 1 , loc = 1 ) plt . legend ( plot_points [ 0 ] , [ <str> , <str> ] , loc = 4 ) plt . gca ( ) . add_artist ( legend1 )  if export_pdf != <str> :          fig . savefig ( export_pdf , bbox_inches = <str> )  if show :          plt . show ( block = False )  return x   