from __future__ import division from __future__ import print_function from builtins import str from builtins import range from builtins import object import numpy as np import matplotlib . pyplot as plt import ehtim . image import ehtim . obsdata import ehtim . observing . obs_simulate as simobs import ehtim . io . save import ehtim . io . load from ehtim . const_def import * from ehtim . observing . obs_helpers import * class Movie ( object ) :      def __init__ ( self , movie , framedur , psize , ra , dec , rf = RF_DEFAULT , polrep = <str> , pol_prim = None , pulse = PULSE_DEFAULT , source = SOURCE_DEFAULT , mjd = MJD_DEFAULT , start_hr = 0.0 ) :          if len ( movie [ 0 ] . shape ) != 2 :              raise Exception ( <str> )  frames = [ image . flatten ( ) for image in movie ] self . nframes = len ( self . frames ) if polrep == <str> :              if pol_prim is None : pol_prim = <str> if pol_prim == <str> :                  self . _movdict = { <str> : frames , <str> : [ ] , <str> : [ ] , <str> : [ ] }  elif pol_prim == <str> :                  self . _movdict = { <str> : [ ] , <str> : [ ] , <str> : [ ] , <str> : frames }  elif pol_prim == <str> :                  self . _movdict = { <str> : [ ] , <str> : frames , <str> : [ ] , <str> : [ ] }  elif pol_prim == <str> :                  self . _movdict = { <str> : [ ] , <str> : [ ] , <str> : frames , <str> : [ ] }  else :                  raise Exception ( <str> )   elif polrep == <str> :              if pol_prim is None :                  print ( <str> ) pol_prim = <str>  if pol_prim == <str> :                  self . _movdict = { <str> : frames , <str> : [ ] , <str> : [ ] , <str> : [ ] }  elif pol_prim == <str> :                  self . _movdict = { <str> : [ ] , <str> : frames , <str> : [ ] , <str> : [ ] }  else :                  raise Exception ( <str> )   self . pol_prim = pol_prim self . framedur = float ( framedur ) self . polrep = polrep self . pulse = pulse self . psize = float ( psize ) self . xdim = movie [ 0 ] . shape [ 1 ] self . ydim = movie [ 0 ] . shape [ 0 ] self . ra = float ( ra ) self . dec = float ( dec ) self . rf = float ( rf ) self . source = str ( source ) self . mjd = int ( mjd ) if start_hr > 24 :              self . mjd += int ( ( start_hr - start_hr % 24 ) / 24 ) self . start_hr = float ( start_hr % 24 )  else :              self . start_hr = start_hr   @ property def frames ( self ) :          frames = self . _movdict [ self . pol_prim ] return frames  @ frames . setter def frames ( self , frames ) :          if len ( frames [ 0 ] ) != self . xdim * self . ydim :              raise Exception ( <str> )  self . _movdict [ self . pol_prim ] = frames  @ property def iframes ( self ) :          if self . polrep != <str> :              raise Exception ( <str> )  frames = self . _movdict [ <str> ] return frames  @ iframes . setter def iframes ( self , frames ) :          if len ( frames [ 0 ] ) != self . xdim * self . ydim :              raise Exception ( <str> )  self . _movdict [ <str> ] = frames  @ property def qframes ( self ) :          if self . polrep != <str> :              raise Exception ( <str> )  frames = self . _movdict [ <str> ] return frames  @ qframes . setter def qframes ( self , frames ) :          if len ( frames [ 0 ] ) != self . xdim * self . ydim :              raise Exception ( <str> )  self . _movdict [ <str> ] = frames  @ property def uframes ( self ) :          if self . polrep != <str> :              raise Exception ( <str> )  frames = self . _movdict [ <str> ] return frames  @ uframes . setter def uframes ( self , frames ) :          if len ( frames [ 0 ] ) != self . xdim * self . ydim :              raise Exception ( <str> )  self . _movdict [ <str> ] = frames  @ property def vframes ( self ) :          if self . polrep != <str> :              raise Exception ( <str> )  frames = self . _movdict [ <str> ] return frames  @ vframes . setter def vframes ( self , frames ) :          if len ( frames [ 0 ] ) != self . xdim * self . ydim :              raise Exception ( <str> )  self . _movdict [ <str> ] = frames  @ property def rrframes ( self ) :          if self . polrep != <str> :              raise Exception ( <str> )  frames = self . _movdict [ <str> ] return frames  @ rrframes . setter def rrframes ( self , frames ) :          if len ( frames [ 0 ] ) != self . xdim * self . ydim :              raise Exception ( <str> )  self . _movdict [ <str> ] = frames  @ property def llframes ( self ) :          if self . polrep != <str> :              raise Exception ( <str> )  frames = self . _movdict [ <str> ] return frames  @ llframes . setter def llframes ( self , frames ) :          if len ( frames [ 0 ] ) != self . xdim * self . ydim :              raise Exception ( <str> )  self . _movdict [ <str> ] = frames  @ property def rlvec ( self ) :          if self . polrep != <str> :              raise Exception ( <str> )  frames = self . _movdict [ <str> ] return frames  @ rlvec . setter def rlvec ( self , frames ) :          if len ( frames [ 0 ] ) != self . xdim * self . ydim :              raise Exception ( <str> )  self . _movdict [ <str> ] = frames  @ property def lrvec ( self ) :          if self . polrep != <str> :              raise Exception ( <str> )  frames = self . _movdict [ <str> ] return frames  @ lrvec . setter def lrvec ( self , frames ) :          if len ( frames [ 0 ] ) != self . xdim * self . ydim :              raise Exception ( <str> )  self . _movdict [ <str> ] = frames  def copy ( self ) :          newmov = Movie ( [ imvec . reshape ( self . ydim , self . xdim ) for imvec in self . frames ] , self . framedur , self . psize , self . ra , self . dec , polrep = self . polrep , pol_prim = self . pol_prim , start_hr = self . start_hr , rf = self . rf , source = self . source , mjd = self . mjd , pulse = self . pulse ) for pol in list ( self . _movdict . keys ( ) ) :              if pol == self . pol_prim : continue polframes = self . _movdict [ pol ] if len ( polframes ) :                  newmov . add_pol_movie ( [ polvec . reshape ( self . ydim , self . xdim ) for polvec in polframes ] , pol )   return newmov  def add_pol_movie ( self , movie , pol ) :          if not ( len ( movie ) == self . nframes ) :              raise Exception ( <str> )  if pol == self . pol_prim :              raise Exception ( <str> )  if np . any ( np . array ( [ image . shape != ( self . ydim , self . xdim ) for image in movie ] ) ) :              raise Exception ( <str> )  if not ( pol in list ( self . _movdict . keys ( ) ) ) :              raise Exception ( <str> % self . polrep + <str> . join ( list ( self . _movdict . keys ( ) ) ) )  if self . polrep == <str> :              if pol == <str> : self . iframes = [ image . flatten ( ) for image in movie ] elif pol == <str> : self . qframes = [ image . flatten ( ) for image in movie ] elif pol == <str> : self . uframes = [ image . flatten ( ) for image in movie ] elif pol == <str> : self . vframes = [ image . flatten ( ) for image in movie ] self . _movdict = { <str> : self . iframes , <str> : self . qframes , <str> : self . uframes , <str> : self . vframes }  elif self . polrep == <str> :              if pol == <str> : self . rrframes = [ image . flatten ( ) for image in movie ] elif pol == <str> : self . llframes = [ image . flatten ( ) for image in movie ] elif pol == <str> : self . rlframes = [ image . flatten ( ) for image in movie ] elif pol == <str> : self . lrframes = [ image . flatten ( ) for image in movie ] self . _movdict = { <str> : self . rrframes , <str> : self . llframes , <str> : self . rlframes , <str> : self . lrframes }  return  def add_qu ( self , qmovie , umovie ) :          if self . polrep != <str> :              raise Excpetion ( <str> )  self . add_pol_movie ( qmovie , <str> ) self . add_pol_movie ( umovie , <str> ) return  def add_v ( self , vmovie ) :          if self . polrep != <str> :              raise Excpetion ( <str> )  self . add_pol_movie ( vmovie , <str> ) return  def switch_polrep ( self , polrep_out = <str> , pol_prim_out = None ) :          if polrep_out not in [ <str> , <str> ] :              raise Exception ( <str> )  if pol_prim_out is None :              if polrep_out == <str> : pol_prim_out = <str> elif polrep_out == <str> : pol_prim_out = <str>  if polrep_out == self . polrep and pol_prim_out == self . pol_prim :              return self . copy ( )  if polrep_out == <str> :              if self . polrep == <str> :                  movdict = { <str> : self . iframes , <str> : self . qframes , <str> : self . uframes , <str> : self . vframes }  else :                  if len ( self . rrframes ) == 0 or len ( self . llframes ) == 0 :                      iframes = [ ] vframes = [ ]  else :                      iframes = [ 0.5 * ( self . rrframes [ i ] + self . llframes [ i ] ) . reshape ( self . ydim , self . xdim ) for i in range ( self . nframes ) ] vframes = [ 0.5 * ( self . rrframes [ i ] - self . llframes [ i ] ) . reshape ( self . ydim , self . xdim ) for i in range ( self . nframes ) ]  if len ( self . rlframes ) == 0 or len ( self . lrframes ) == 0 :                      qframes = [ ] uframes = [ ]  else :                      qframes = [ np . real ( 0.5 * ( self . lrframes [ i ] + self . rlframes [ i ] ) ) . reshape ( self . ydim , self . xdim ) for i in range ( self . nframes ) ] uframes = [ np . real ( 0.5j * ( self . lrframes [ i ] - self . rlframes [ i ] ) ) . reshape ( self . ydim , self . xdim ) for i in range ( self . nframes ) ]  movdict = { <str> : iframes , <str> : qframes , <str> : uframes , <str> : vframes }   elif polrep_out == <str> :              if self . polrep == <str> :                  movdict = { <str> : self . rrframes , <str> : self . llframes , <str> : self . rlframes , <str> : self . lrframes }  else :                  if len ( self . iframes ) == 0 or len ( self . vframes ) == 0 :                      rrframes = [ ] llframes = [ ]  else :                      rrframes = [ ( self . iframes [ i ] + self . vframes [ i ] ) . reshape ( self . ydim , self . xdim ) for i in range ( self . nframes ) ] llframes = [ ( self . iframes [ i ] - self . vframes [ i ] ) . reshape ( self . ydim , self . xdim ) for i in range ( self . nframes ) ]  if len ( self . qframes ) == 0 or len ( self . uframes ) == 0 :                      rlframes = [ ] lrframes = [ ]  else :                      rlframes = [ ( self . qframes [ i ] + 1j * self . uframes [ i ] ) . reshape ( self . ydim , self . xdim ) for i in range ( self . nframes ) ] lrframes = [ ( self . qframes [ i ] - 1j * self . uframes [ i ] ) . reshape ( self . ydim , self . xdim ) for i in range ( self . nframes ) ]  movdict = { <str> : rrframes , <str> : llframes , <str> : rlframes , <str> : lrframes }   frames = movdict [ pol_prim_out ] if len ( frames ) == 0 :              raise Exception ( <str> % ( polrep_out , pol_prim_out ) + <str> )  newmov = Movie ( frames , self . framedur , self . psize , self . ra , self . dec , polrep = polrep_out , pol_prim = pol_prim_out , start_hr = self . start_hr , rf = self . rf , source = self . source , mjd = self . mjd , pulse = self . pulse ) for pol in list ( movdict . keys ( ) ) :              if pol == pol_prim_out : continue polframes = movdict [ pol ] if len ( polframes ) :                  newmov . add_pol_movie ( [ polvec . reshape ( self . ydim , self . xdim ) for polvec in polframes ] , pol )   return newmov  def flip_chi ( self ) :          mov = self . copy ( ) if mov . polrep == <str> :              mov . qframes *= [ - qvec for qvec in mov . qframes ]  elif mov . polrep == <str> :              mov . lrframes *= [ - np . conjugate ( lrvec ) for lrvec in mov . lrframes ] mov . rlframes *= [ - np . conjugate ( rlvec ) for rlvec in mov . rlframes ]  return mov  def orth_chi ( self ) :          mov = self . copy ( ) if im . polrep == <str> :              mov . qframes *= [ - uvec for uvec in mov . vframes ]  elif mov . polrep == <str> :              mov . lrframes *= [ np . conjugate ( lrvec ) for lrvec in mov . lrframes ] mov . rlframes *= [ np . conjugate ( rlvec ) for rlvec in mov . rlframes ]  return mov  def frametimes ( self ) :          return self . start_hr + np . arange ( self . nframes ) * self . framedur / 3600.  def fovx ( self ) :          return self . psize * self . xdim  def fovy ( self ) :          return self . psize * self . ydim  def lightcurve ( self ) :          if self . polrep == <str> :              flux = [ np . sum ( ivec ) for ivec in self . iframes ]  elif self . polrep == <str> :              flux = [ 0.5 * ( np . sum ( self . rrframes [ i ] ) + np . sum ( self . llframes [ i ] ) ) for i in range ( self . nframes ) ]  return np . array ( flux )  def lin_polfrac_curve ( self ) :          if self . polrep == <str> :              frac = [ np . abs ( np . sum ( self . qframes [ i ] + 1j * self . uframes [ i ] ) ) / np . abs ( np . sum ( self . iframes [ i ] ) ) for i in range ( self . nframes ) ]  elif self . polrep == <str> :              frac = [ 2 * np . abs ( np . sum ( self . rlframes [ i ] ) ) / np . abs ( np . sum ( self . rrframes [ i ] + self . llframes [ i ] ) ) for i in range ( self . nframes ) ]  return np . array ( frac )  def circ_polfrac_curve ( self ) :          if self . polrep == <str> :              frac = [ np . sum ( self . vframes [ i ] ) / np . abs ( np . sum ( self . iframes [ i ] ) ) for i in range ( self . nframes ) ]  elif self . polrep == <str> :              frac = [ np . sum ( self . rrframes [ i ] - self . llframes [ i ] ) / np . abs ( np . sum ( self . rrframes [ i ] + self . llframes [ i ] ) ) for i in range ( self . nframes ) ]  return np . array ( frac )  def get_frame ( self , n ) :          if n < 0 or n >= len ( self . frames ) :              raise Exception ( <str> % self . nframes )  time = self . start_hr + n * self . framedur / 3600 imarr = self . frames [ n ] . reshape ( self . ydim , self . xdim ) outim = ehtim . image . Image ( imarr , self . psize , self . ra , self . dec , self . pa , polrep = self . polrep , pol_prim = self . pol_prim , time = time , rf = self . rf , source = self . source , mjd = self . mjd , pulse = self . pulse ) for pol in list ( self . _movdict . keys ( ) ) :              if pol == self . pol_prim : continue polframes = self . _movdict [ pol ] if len ( polframes ) :                  polvec = polframes [ n ] polarr = polvec . reshape ( self . ydim , self . xdim ) . copy ( ) outim . add_pol_image ( polarr , pol )   return outim  def im_list ( self ) :          return [ self . get_frame ( j ) for j in range ( self . nframes ) ]  def avg_frame ( self ) :          time = self . start_hr avg_imvec = np . mean ( np . array ( self . frames ) , axis = 0 ) avg_imarr = avg_imvec . reshape ( self . ydim , self . xdim ) outim = ehtim . image . Image ( avg_imarr , self . psize , self . ra , self . dec , self . pa , polrep = self . polrep , pol_prim = self . pol_prim , time = self . start_hr , rf = self . rf , source = self . source , mjd = self . mjd , pulse = self . pulse ) for pol in list ( self . _movdict . keys ( ) ) :              if pol == self . pol_prim : continue polframes = self . _movdict [ pol ] if len ( polframes ) :                  avg_polvec = np . mean ( np . array ( polframes ) , axis = 0 ) avg_polarr = avg_polvec . reshape ( self . ydim , self . xdim ) outim . add_pol_image ( avg_polarr , pol )   return outim  def observe_same_nonoise ( self , obs , sgrscat = False , ttype = <str> , fft_pad_factor = 2 , repeat = False ) :          tolerance = 1e-8 if ( np . abs ( self . ra - obs . ra ) > tolerance ) or ( np . abs ( self . dec - obs . dec ) > tolerance ) :              raise Exception ( <str> )  if ( np . abs ( self . rf - obs . rf ) / obs . rf > tolerance ) :              raise Exception ( <str> )  if ttype == <str> or ttype == <str> or ttype == <str> :              print ( <str> + ttype + <str> )  else :              raise Exception ( <str> % ttype )  mjdstart = float ( self . mjd ) + float ( self . start_hr / 24.0 ) mjdend = mjdstart + ( len ( self . frames ) * self . framedur ) / 86400.0 obslist = obs . tlist ( ) obsmjds = np . array ( [ ( np . floor ( obs . mjd ) + ( obsdata [ 0 ] [ <str> ] ) / 24.0 ) for obsdata in obslist ] ) if ( not repeat ) and ( ( obsmjds < mjdstart ) + ( obsmjds > mjdend ) ) . any ( ) :              raise Exception ( <str> % ( mjdstart , mjdend ) )  obsdata_out = [ ] for i in range ( len ( obslist ) ) :              obsdata = obslist [ i ] mjd = obsmjds [ i ] n = int ( np . floor ( ( mjd - mjdstart ) * 86400. / self . framedur ) ) if ( n >= len ( self . frames ) ) :                  if repeat : n = np . mod ( n , len ( self . frames ) ) else : raise Exception ( <str> % ( mjdstart , mjdend ) )  uv = recarr_to_ndarr ( obsdata [ [ <str> , <str> ] ] , <str> ) im = self . get_frame ( n ) data = simobs . sample_vis ( im , uv , sgrscat = sgrscat , polrep_obs = obs . polrep , ttype = ttype , fft_pad_factor = fft_pad_factor , zero_empty_pol = True ) if obs . polrep == <str> :                  obsdata [ <str> ] = data [ 0 ] if not ( data [ 1 ] is None ) :                      obsdata [ <str> ] = data [ 1 ] obsdata [ <str> ] = data [ 2 ] obsdata [ <str> ] = data [ 3 ]   elif obs . polrep == <str> :                  obsdata [ <str> ] = data [ 0 ] if not ( data [ 1 ] is None ) :                      obsdata [ <str> ] = data [ 1 ]  if not ( data [ 2 ] is None ) :                      obsdata [ <str> ] = data [ 2 ] obsdata [ <str> ] = data [ 3 ]   if len ( obsdata_out ) :                  obsdata_out = np . hstack ( ( obsdata_out , obsdata ) )  else :                  obsdata_out = obsdata   obsdata_out = np . array ( obsdata_out , dtype = obs . poltype ) obs_no_noise = ehtim . obsdata . Obsdata ( self . ra , self . dec , self . rf , obs . bw , obsdata_out , obs . tarr , source = self . source , mjd = np . floor ( obs . mjd ) , polrep = obs . polrep , ampcal = True , phasecal = True , opacitycal = True , dcal = True , frcal = True , timetype = obs . timetype , scantable = obs . scans ) return obs_no_noise  def observe_same ( self , obs_in , ttype = <str> , fft_pad_factor = 2 , repeat = False , sgrscat = False , add_th_noise = True , opacitycal = True , ampcal = True , phasecal = True , frcal = True , dcal = True , stabilize_scan_phase = False , stabilize_scan_amp = False , jones = False , inv_jones = False , tau = TAUDEF , taup = GAINPDEF , gainp = GAINPDEF , gain_offset = GAINPDEF , dtermp = DTERMPDEF , dterm_offset = DTERMPDEF ) :          print ( <str> ) obs = self . observe_same_nonoise ( obs_in , sgrscat = sgrscat , ttype = ttype , fft_pad_factor = fft_pad_factor , repeat = repeat ) if jones :              print ( <str> ) obsdata = simobs . add_jones_and_noise ( obs , add_th_noise = add_th_noise , opacitycal = opacitycal , ampcal = ampcal , phasecal = phasecal , dcal = dcal , frcal = frcal , stabilize_scan_phase = stabilize_scan_phase , stabilize_scan_amp = stabilize_scan_amp , gainp = gainp , taup = taup , gain_offset = gain_offset , dtermp = dtermp , dterm_offset = dterm_offset ) obs = ehtim . obsdata . Obsdata ( obs . ra , obs . dec , obs . rf , obs . bw , obsdata , obs . tarr , source = obs . source , mjd = obs . mjd , polrep = obs_in . polrep , ampcal = ampcal , phasecal = phasecal , opacitycal = opacitycal , dcal = dcal , frcal = frcal , timetype = obs . timetype , scantable = obs . scans ) if inv_jones :                  obsdata = simobs . apply_jones_inverse ( obs , opacitycal = opacitycal , dcal = dcal , frcal = frcal ) obs = ehtim . obsdata . Obsdata ( obs . ra , obs . dec , obs . rf , obs . bw , obsdata , obs . tarr , source = obs . source , mjd = obs . mjd , polrep = obs_in . polrep , ampcal = ampcal , phasecal = phasecal , opacitycal = True , dcal = True , frcal = True , timetype = obs . timetype , scantable = obs . scans )   elif add_th_noise :              obsdata = simobs . add_noise ( obs , add_th_noise = add_th_noise , ampcal = ampcal , phasecal = phasecal , opacitycal = opacitycal , gainp = gainp , taup = taup , gain_offset = gain_offset ) obs = ehtim . obsdata . Obsdata ( obs . ra , obs . dec , obs . rf , obs . bw , obsdata , obs . tarr , source = obs . source , mjd = obs . mjd , polrep = obs_in . polrep , ampcal = ampcal , phasecal = phasecal , opacitycal = True , dcal = True , frcal = True , timetype = obs . timetype , scantable = obs . scans )  return obs  def observe ( self , array , tint , tadv , tstart , tstop , bw , repeat = False , mjd = None , timetype = <str> , polrep_obs = None , elevmin = ELEV_LOW , elevmax = ELEV_HIGH , ttype = <str> , fft_pad_factor = 2 , fix_theta_GMST = False , sgrscat = False , add_th_noise = True , opacitycal = True , ampcal = True , phasecal = True , frcal = True , dcal = True , stabilize_scan_phase = False , stabilize_scan_amp = False , jones = False , inv_jones = False , tau = TAUDEF , taup = GAINPDEF , gainp = GAINPDEF , gain_offset = GAINPDEF , dtermp = DTERMPDEF , dterm_offset = DTERMPDEF ) :          print ( <str> ) if mjd == None :              mjd = self . mjd  if polrep_obs is None :              polrep_obs = self . polrep  obs = array . obsdata ( self . ra , self . dec , self . rf , bw , tint , tadv , tstart , tstop , mjd = mjd , polrep = polrep_obs , tau = tau , timetype = timetype , elevmin = elevmin , elevmax = elevmax , fix_theta_GMST = fix_theta_GMST ) obs = self . observe_same ( obs , ttype = ttype , fft_pad_factor = fft_pad_factor , repeat = repeat , sgrscat = sgrscat , add_th_noise = add_th_noise , opacitycal = opacitycal , ampcal = ampcal , phasecal = phasecal , dcal = dcal , frcal = frcal , stabilize_scan_phase = stabilize_scan_phase , stabilize_scan_amp = stabilize_scan_amp , gainp = gainp , gain_offset = gain_offset , tau = tau , taup = taup , dtermp = dtermp , dterm_offset = dterm_offset , jones = jones , inv_jones = inv_jones ) return obs  def observe_vex ( self , vex , source , synchronize_start = True , t_int = 0.0 , polrep_obs = None , ttype = <str> , fft_pad_factor = 2 , sgrscat = False , add_th_noise = True , opacitycal = True , ampcal = True , phasecal = True , frcal = True , dcal = True , stabilize_scan_phase = False , stabilize_scan_amp = False , jones = False , inv_jones = False , tau = TAUDEF , taup = GAINPDEF , gainp = GAINPDEF , gain_offset = GAINPDEF , dtermp = DTERMPDEF , dterm_offset = DTERMPDEF , fix_theta_GMST = False ) :          if polrep_obs is None :              polrep_obs = self . polrep  obs_List = [ ] movie = self . copy ( ) if synchronize_start :              movie . mjd = vex . sched [ 0 ] [ <str> ] movie . start_hr = vex . sched [ 0 ] [ <str> ]  movie_start = float ( movie . mjd ) + movie . start_hr / 24.0 movie_end = movie_start + len ( movie . frames ) * movie . framedur / 86400. print ( <str> , movie_start , movie_end ) snapshot = 1.0 if t_int > 0.0 :              snapshot = 0.0  for i_scan in range ( len ( vex . sched ) ) :              if vex . sched [ i_scan ] [ <str> ] != source :                  continue  scankeys = list ( vex . sched [ i_scan ] [ <str> ] . keys ( ) ) subarray = vex . array . make_subarray ( [ vex . sched [ i_scan ] [ <str> ] [ key ] [ <str> ] for key in scankeys ] ) if snapshot == 1.0 :                  t_int = np . max ( np . array ( [ vex . sched [ i_scan ] [ <str> ] [ site ] [ <str> ] for site in scankeys ] ) ) print ( t_int )  vex_scan_start_mjd = float ( vex . sched [ i_scan ] [ <str> ] ) + vex . sched [ i_scan ] [ <str> ] / 24.0 vex_scan_stop_mjd = vex_scan_start_mjd + vex . sched [ i_scan ] [ <str> ] [ 0 ] [ <str> ] / 3600.0 / 24.0 print ( <str> , vex_scan_start_mjd , vex_scan_stop_mjd ) if vex_scan_start_mjd < movie_start or vex_scan_stop_mjd > movie_end :                  continue  t_start = vex . sched [ i_scan ] [ <str> ] t_stop = vex . sched [ i_scan ] [ <str> ] + vex . sched [ i_scan ] [ <str> ] [ 0 ] [ <str> ] / 3600.0 - EP mjd = vex . sched [ i_scan ] [ <str> ] obs = subarray . obsdata ( movie . ra , movie . dec , movie . rf , vex . bw_hz , t_int , t_int , t_start , t_stop , mjd = mjd , polrep = polrep_obs , tau = tau , elevmin = .01 , elevmax = 89.99 , timetype = <str> , fix_theta_GMST = fix_theta_GMST ) obs_List . append ( obs )  if len ( obs_List ) == 0 :              raise Exception ( <str> )  obs = ehtim . obsdata . merge_obs ( obs_List ) obsout = movie . observe_same ( obs , ttype = ttype , fft_pad_factor = fft_pad_factor , repeat = False , sgrscat = sgrscat , add_th_noise = add_th_noise , opacitycal = opacitycal , ampcal = ampcal , phasecal = phasecal , frcal = frcal , dcal = dcal , stabilize_scan_phase = stabilize_scan_phase , stabilize_scan_amp = stabilize_scan_amp , jones = jones , inv_jones = inv_jones , tau = tau , taup = taup , gainp = gainp , gain_offset = gain_offset , dtermp = dtermp , dterm_offset = dterm_offset ) return obsout  def save_txt ( self , fname ) :          ehtim . io . save . save_mov_txt ( self , fname ) return  def save_fits ( self , fname ) :          ehtim . io . save . save_mov_fits ( self , fname ) return  def export_mp4 ( self , out = <str> , fps = 10 , dpi = 120 , interp = <str> , scale = <str> , dynamic_range = 1000.0 , cfun = <str> , nvec = 20 , pcut = 0.01 , plotp = False , gamma = 0.5 , frame_pad_factor = 1 , verbose = False ) :          import matplotlib matplotlib . use ( <str> ) import matplotlib . pyplot as plt import matplotlib . animation as animation im = im . switch_polrep ( <str> , <str> ) if ( interp in [ <str> , <str> , <str> , <str> ] ) :              interp = <str>  else :              interp = <str>  if scale == <str> :              unit = <str>  elif scale == <str> :              unit = <str>  elif scale == <str> :              unit = <str>  else :              raise Exception ( <str> )  fig = plt . figure ( ) maxi = np . max ( np . concatenate ( [ im for im in self . frames ] ) ) if len ( self . qframes ) and plotp :              thin = self . xdim // nvec mask = ( self . frames [ 0 ] ) . reshape ( self . ydim , self . xdim ) > pcut * np . max ( self . frames [ 0 ] ) mask2 = mask [ : : thin , : : thin ] x = ( np . array ( [ [ i for i in range ( self . xdim ) ] for j in range ( self . ydim ) ] ) [ : : thin , : : thin ] ) [ mask2 ] y = ( np . array ( [ [ j for i in range ( self . xdim ) ] for j in range ( self . ydim ) ] ) [ : : thin , : : thin ] ) [ mask2 ] a = ( - np . sin ( np . angle ( self . qframes [ 0 ] + 1j * self . uframes [ 0 ] ) / 2 ) . reshape ( self . ydim , self . xdim ) [ : : thin , : : thin ] ) [ mask2 ] b = ( np . cos ( np . angle ( self . qframes [ 0 ] + 1j * self . uframes [ 0 ] ) / 2 ) . reshape ( self . ydim , self . xdim ) [ : : thin , : : thin ] ) [ mask2 ] m = ( np . abs ( self . qframes [ 0 ] + 1j * self . uframes [ 0 ] ) / self . frames [ 0 ] ) . reshape ( self . ydim , self . xdim ) m [ np . logical_not ( mask ) ] = 0 Q1 = plt . quiver ( x , y , a , b , headaxislength = 20 , headwidth = 1 , headlength = .01 , minlength = 0 , minshaft = 1 , width = .01 * self . xdim , units = <str> , pivot = <str> , color = <str> , angles = <str> , scale = 1.0 / thin ) Q2 = plt . quiver ( x , y , a , b , headaxislength = 20 , headwidth = 1 , headlength = .01 , minlength = 0 , minshaft = 1 , width = .005 * self . xdim , units = <str> , pivot = <str> , color = <str> , angles = <str> , scale = 1.1 / thin )  def im_data ( n ) :              n_data = int ( ( n - n % frame_pad_factor ) / frame_pad_factor ) if len ( self . qframes ) and plotp :                  a = ( - np . sin ( np . angle ( self . qframes [ n_data ] + 1j * self . uframes [ n_data ] ) / 2 ) . reshape ( self . ydim , self . xdim ) [ : : thin , : : thin ] ) [ mask2 ] b = ( np . cos ( np . angle ( self . qframes [ n_data ] + 1j * self . uframes [ n_data ] ) / 2 ) . reshape ( self . ydim , self . xdim ) [ : : thin , : : thin ] ) [ mask2 ] Q1 . set_UVC ( a , b ) Q2 . set_UVC ( a , b )  if scale == <str> :                  return self . frames [ n_data ] . reshape ( ( self . ydim , self . xdim ) )  elif scale == <str> :                  return np . log ( self . frames [ n_data ] . reshape ( ( self . ydim , self . xdim ) ) + maxi / dynamic_range )  elif scale == <str> :                  return ( self . frames [ n_data ] ** ( gamma ) ) . reshape ( ( self . ydim , self . xdim ) )   plt_im = plt . imshow ( im_data ( 0 ) , cmap = plt . get_cmap ( cfun ) , interpolation = interp ) plt . colorbar ( plt_im , fraction = 0.046 , pad = 0.04 , label = unit ) if scale == <str> :              plt_im . set_clim ( [ 0 , maxi ] )  else :              plt_im . set_clim ( [ np . log ( maxi / dynamic_range ) , np . log ( maxi ) ] )  xticks = ticks ( self . xdim , self . psize / RADPERAS / 1e-6 ) yticks = ticks ( self . ydim , self . psize / RADPERAS / 1e-6 ) plt . xticks ( xticks [ 0 ] , xticks [ 1 ] ) plt . yticks ( yticks [ 0 ] , yticks [ 1 ] ) plt . xlabel ( <str> ) plt . ylabel ( <str> ) fig . set_size_inches ( [ 5 , 5 ] ) plt . tight_layout ( ) def update_img ( n ) :              if verbose :                  print ( <str> . format ( n , len ( self . frames ) * frame_pad_factor ) )  plt_im . set_data ( im_data ( n ) ) return plt_im  ani = animation . FuncAnimation ( fig , update_img , len ( self . frames ) * frame_pad_factor , interval = 1e3 / fps ) writer = animation . writers [ <str> ] ( fps = fps , bitrate = 1e6 ) ani . save ( out , writer = writer , dpi = dpi )   def merge_im_list ( imlist , framedur = - 1 ) :      framelist = [ ] qlist = [ ] ulist = [ ] vlist = [ ] nframes = len ( imlist ) print ( <str> % ( nframes , imlist [ 0 ] . mjd , imlist [ 0 ] . time , imlist [ - 1 ] . mjd , imlist [ - 1 ] . time ) ) for i in range ( nframes ) :          im = imlist [ i ] if i == 0 :              polrep0 = im . polrep pol_prim0 = im . pol_prim movdict = { key : [ ] for key in list ( im . _imdict . keys ( ) ) } psize0 = im . psize xdim0 = im . xdim ydim0 = im . ydim ra0 = im . ra dec0 = im . dec rf0 = im . rf src0 = im . source mjd0 = im . mjd hour0 = im . time pulse = im . pulse  else :              if ( im . polrep != polrep0 ) :                  raise Exception ( <str> % i )  if ( im . psize != psize0 ) :                  raise Exception ( <str> % i )  if ( im . xdim != xdim0 ) :                  raise Exception ( <str> % i )  if ( im . ydim != ydim0 ) :                  raise Exception ( <str> % i )  if ( im . ra != ra0 ) :                  raise Exception ( <str> % i )  if ( im . dec != dec0 ) :                  raise Exception ( <str> % i )  if ( im . rf != rf0 ) :                  raise Exception ( <str> % i )  if ( im . source != src0 ) :                  raise Exception ( <str> % i )  if ( im . mjd < mjd0 ) :                  raise Exception ( <str> % i )  hour = im . time if im . mjd > mjd0 :                  hour += 24 * ( im . mjd - mjd0 )   imarr = im . imvec . reshape ( ydim0 , xdim0 ) framelist . append ( imarr ) for pol in list ( movdict . keys ( ) ) :              polvec = im . _imdict [ pol ] if len ( polvec ) :                  polarr = polvec . reshape ( ydim0 , xdim0 ) movdict [ pol ] . append ( polarr )  else :                  if movdict [ pol ] :                      raise Exception ( <str> % i )     if framedur == - 1 :          framedur = ( ( hour - hour0 ) / float ( nframes ) ) * 3600.0  newmov = Movie ( framelist , framedur , psize0 , ra0 , dec0 , polrep = polrep0 , pol_prim = pol_prim0 , start_hr = hour0 , rf = rf0 , source = src0 , mjd = mjd0 , pulse = pulse ) for pol in list ( movdict . keys ( ) ) :          if pol == newmov . pol_prim : continue polframes = movdict [ pol ] if len ( polframes ) :              newmov . add_pol_movie ( polframes , pol )   return newmov  def load_hdf5 ( file_name , framedur_sec = - 1 , psize = - 1 , ra = 17.761122472222223 , dec = - 28.992189444444445 , rf = 230e9 , source = <str> , pulse = PULSE_DEFAULT , polrep = <str> , pol_prim = None , zero_pol = True ) :      return ehtim . io . load . load_movie_hdf5 ( file_name , framedur_sec = framedur_sec , psize = psize , ra = ra , dec = dec , rf = rf , source = source , pulse = pulse , polrep = polrep , pol_prim = pol_prim , zero_pol = zero_pol )  def load_txt ( basename , nframes , framedur = - 1 , pulse = PULSE_DEFAULT , polrep = <str> , pol_prim = None , zero_pol = True ) :      return ehtim . io . load . load_movie_txt ( basename , nframes , framedur = framedur , pulse = pulse , polrep = polrep , pol_prim = pol_prim , zero_pol = zero_pol )  def load_fits ( basename , nframes , framedur = - 1 , pulse = PULSE_DEFAULT , polrep = <str> , pol_prim = None , zero_pol = True ) :      return ehtim . io . load . load_movie_fits ( basename , nframes , framedur = framedur , pulse = pulse , polrep = polrep , pol_prim = pol_prim , zero_pol = zero_pol )   