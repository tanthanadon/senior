from __future__ import division from __future__ import print_function from builtins import str from builtins import map from builtins import range import numpy as np import numpy . random as npr import sys from ehtim . const_def import * def circular_mean ( theta , unit = <str> ) :      theta = np . asarray ( theta , dtype = np . float32 ) theta = theta . flatten ( ) theta = theta [ theta == theta ] if unit == <str> :          theta *= np . pi / 180.  if len ( theta ) == 0 :          return None  else :          C = np . mean ( np . cos ( theta ) ) S = np . mean ( np . sin ( theta ) ) circ_mean = np . arctan2 ( S , C ) if unit == <str> :              circ_mean *= 180. / np . pi return np . mod ( circ_mean + 180. , 360. ) - 180.  else :              return np . mod ( circ_mean + np . pi , 2. * np . pi ) - np . pi    def circular_std ( theta , unit = <str> ) :      theta = np . asarray ( theta , dtype = np . float32 ) theta = theta . flatten ( ) theta = theta [ theta == theta ] if unit == <str> :          theta *= np . pi / 180.  if len ( theta ) < 2 :          return None  else :          C = np . mean ( np . cos ( theta ) ) S = np . mean ( np . sin ( theta ) ) circ_std = np . sqrt ( - 2. * np . log ( np . sqrt ( C ** 2 + S ** 2 ) ) ) if unit == <str> :              circ_std *= 180. / np . pi  return circ_std   def circular_std_of_mean ( theta , unit = <str> ) :      theta = np . asarray ( theta , dtype = np . float32 ) theta = theta . flatten ( ) theta = theta [ theta == theta ] return circular_std ( theta , unit ) / np . sqrt ( len ( theta ) )  def mean_incoh_amp ( amp , sigma , debias = True , err_type = <str> , num_samples = int ( 1e3 ) ) :      if ( not hasattr ( amp , <str> ) ) :          amp = [ amp ]  amp = np . asarray ( amp , dtype = np . float32 ) N = len ( amp ) if ( not hasattr ( sigma , <str> ) ) :          sigma = sigma * np . ones ( N )  elif len ( sigma ) == 1 :          sigma = sigma * np . ones ( N )  sigma = np . asarray ( sigma , dtype = np . float32 ) if len ( sigma ) != len ( amp ) :          print ( <str> ) return None  else :          amp_clean = amp [ ( amp == amp ) & ( sigma == sigma ) & ( sigma > 0 ) & ( amp > 0 ) ] sigma_clean = sigma [ ( amp == amp ) & ( sigma == sigma ) & ( sigma > 0 ) & ( amp > 0 ) ] if debias == True :              amp0sq = ( np . mean ( amp_clean ** 2 - ( 2. - 1. / N ) * sigma_clean ** 2 ) )  else : amp0sq = np . mean ( amp_clean ** 2 ) amp0sq = np . maximum ( amp0sq , 0. ) amp0 = np . sqrt ( amp0sq ) if err_type == <str> :              sigma0 = np . sqrt ( np . sum ( sigma_clean ** 2 ) / len ( sigma_clean ) ** 2 )  elif err_type == <str> :              ampfoo , ci = bootstrap ( amp_clean , np . mean , num_samples = num_samples , wrapping_variable = False ) sigma0 = 0.5 * ( ci [ 1 ] - ci [ 0 ] )  return amp0 , sigma0   def mean_incoh_amp_from_vis ( vis , sigma , debias = True , err_type = <str> , num_samples = int ( 1e3 ) ) :      if ( not hasattr ( vis , <str> ) ) :          vis = [ vis ]  vis = np . asarray ( vis ) vis = vis [ vis == vis ] amp = np . abs ( vis ) N = len ( amp ) if ( not hasattr ( sigma , <str> ) ) :          sigma = sigma * np . ones ( N )  elif len ( sigma ) == 1 :          sigma = sigma * np . ones ( N )  sigma = np . asarray ( sigma , dtype = np . float32 ) if len ( sigma ) != len ( amp ) :          print ( <str> ) return None , None  else :          amp_clean = amp [ ( amp == amp ) & ( sigma == sigma ) & ( sigma >= 0 ) & ( amp >= 0 ) ] sigma_clean = sigma [ ( amp == amp ) & ( sigma == sigma ) & ( sigma >= 0 ) & ( amp >= 0 ) ] Nc = len ( amp_clean ) if Nc < 1 :              return None , None  else :              if debias == True :                  amp0sq = ( np . mean ( amp_clean ** 2 - ( 2. - 1. / Nc ) * sigma_clean ** 2 ) )  else : amp0sq = np . mean ( amp_clean ** 2 ) if ( amp0sq != amp0sq ) : amp0sq = 0. amp0sq = np . maximum ( amp0sq , 0. ) amp0 = np . sqrt ( amp0sq ) if err_type == <str> :                  sigma0 = np . sqrt ( np . sum ( sigma_clean ** 2 ) / Nc ** 2 )  elif err_type == <str> :                  ampfoo , ci = bootstrap ( amp_clean , np . mean , num_samples = num_samples , wrapping_variable = False , alpha = <str> ) sigma0 = 0.5 * ( ci [ 1 ] - ci [ 0 ] )  return amp0 , sigma0    def bootstrap ( data , statistic , num_samples = int ( 1e3 ) , alpha = <str> , wrapping_variable = False ) :      if alpha == <str> :          alpha = 0.3173  elif alpha == <str> :          alpha = 0.0455  elif alpha == <str> :          alpha = 0.0027  stat = np . zeros ( num_samples ) data = np . asarray ( data ) if wrapping_variable == True :          m = statistic ( data )  else :          m = 0  data = data - m n = len ( data ) idx = npr . randint ( 0 , n , ( num_samples , n ) ) samples = data [ idx ] for cou in range ( num_samples ) :          stat [ cou ] = statistic ( samples [ cou , : ] )  stat = np . sort ( stat ) bootstrap_value = np . median ( stat ) + m bootstrap_CI = [ stat [ int ( ( alpha / 2.0 ) * num_samples ) ] + m , stat [ int ( ( 1 - alpha / 2.0 ) * num_samples ) ] + m ] return bootstrap_value , bootstrap_CI  def mean_incoh_avg ( x , debias = True ) :      amp = np . abs ( np . asarray ( [ y [ 0 ] for y in x ] ) ) sig = np . asarray ( [ y [ 1 ] for y in x ] ) ampN = amp [ ( amp == amp ) & ( amp >= 0 ) & ( sig == sig ) & ( sig >= 0 ) ] sigN = sig [ ( amp == amp ) & ( amp >= 0 ) & ( sig == sig ) & ( sig >= 0 ) ] amp = ampN sig = sigN Nc = len ( sig ) if Nc == 0 :          amp0 = - 1 sig0 = - 1  elif Nc == 1 :          amp0 = amp [ 0 ] sig0 = sig [ 0 ]  else :          if debias == True :              amp0 = deb_amp ( amp , sig )  else :              amp0 = np . sqrt ( np . maximum ( np . mean ( amp ** 2 ) , 0. ) )  sig0 = inc_sig ( amp , sig )  return amp0 , sig0  def deb_amp ( amp , sig ) :      amp = np . abs ( np . asarray ( amp ) ) sig = np . asarray ( sig ) Nc = len ( amp ) amp0sq = ( np . mean ( amp ** 2 - ( 2. - 1. / Nc ) * sig ** 2 ) ) amp0sq = np . maximum ( amp0sq , 0. ) amp0 = np . sqrt ( amp0sq ) return amp0  def inc_sig ( amp , sig ) :      amp = np . abs ( np . asarray ( amp ) ) sig = np . asarray ( sig ) Nc = len ( amp ) amp0 = deb_amp ( amp , sig ) Esigma = np . median ( sig ) snr0 = amp0 / Esigma snrA = 1. / ( np . sqrt ( 1. + 2. / np . sqrt ( Nc ) * ( 1. / snr0 ) * np . sqrt ( 1. + 1. / snr0 ** 2 ) ) - 1. ) if snrA > 0 :          sigma0 = amp0 / snrA  else : sigma0 = coh_sig ( amp , sig ) return sigma0  def coh_sig ( amp , sig ) :      amp = np . abs ( np . asarray ( amp ) ) sig = np . asarray ( sig ) Nc = len ( amp ) sigma0 = np . sqrt ( np . sum ( sig ** 2 ) / Nc ** 2 ) return sigma0   