from __future__ import division from __future__ import print_function from __future__ import absolute_import from builtins import range import string import time import numpy as np import scipy . optimize as opt import scipy . ndimage as nd import scipy . ndimage . filters as filt import matplotlib . pyplot as plt try :      from pynfft . nfft import NFFT  except ImportError :      print ( <str> )  from scipy . special import jv import ehtim . image as image from . import linearize_energy as le from ehtim . const_def import * from ehtim . observing . obs_helpers import * from IPython import display NORM_REGULARIZER = False MAXLS = 100 NHIST = 100 MAXIT = 100 STOP = 1.e-8 DATATERMS = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> ] REGULARIZERS = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] nit = 0 def imager_func ( Obsdata , InitIm , Prior , flux , d1 = <str> , d2 = False , d3 = False , alpha_d1 = 100 , alpha_d2 = 100 , alpha_d3 = 100 , s1 = <str> , s2 = False , s3 = False , alpha_s1 = 1 , alpha_s2 = 1 , alpha_s3 = 1 , alpha_flux = 500 , alpha_cm = 500 , ** kwargs ) :      maxit = kwargs . get ( <str> , MAXIT ) stop = kwargs . get ( <str> , STOP ) clipfloor = kwargs . get ( <str> , 0 ) ttype = kwargs . get ( <str> , <str> ) grads = kwargs . get ( <str> , True ) logim = kwargs . get ( <str> , True ) norm_init = kwargs . get ( <str> , False ) show_updates = kwargs . get ( <str> , True ) beam_size = kwargs . get ( <str> , Obsdata . res ( ) ) kwargs [ <str> ] = beam_size if not d1 and not d2 :          raise Exception ( <str> )  if not s1 and not s2 :          raise Exception ( <str> )  if ( not ( ( d1 in DATATERMS ) or d1 == False ) ) or ( not ( ( d2 in DATATERMS ) or d2 == False ) ) :          raise Exception ( <str> + <str> . join ( DATATERMS ) )  if ( not ( ( s1 in REGULARIZERS ) or s1 == False ) ) or ( not ( ( s2 in REGULARIZERS ) or s2 == False ) ) :          raise Exception ( <str> + <str> . join ( REGULARIZERS ) )  if ( Prior . psize != InitIm . psize ) or ( Prior . xdim != InitIm . xdim ) or ( Prior . ydim != InitIm . ydim ) :          raise Exception ( <str> )  if ( InitIm . polrep != Prior . polrep ) :          raise Exception ( <str> )  if ( logim and Prior . pol_prim in [ <str> , <str> , <str> ] ) :          raise Exception ( <str> )  pol = Prior . pol_prim print ( <str> % pol ) imsize = np . max ( [ Prior . xdim , Prior . ydim ] ) * Prior . psize uvmax = 1.0 / Prior . psize uvmin = 1.0 / imsize uvdists = Obsdata . unpack ( <str> ) [ <str> ] maxbl = np . max ( uvdists ) minbl = np . max ( uvdists [ uvdists > 0 ] ) maxamp = np . max ( np . abs ( Obsdata . unpack ( <str> ) [ <str> ] ) ) if uvmax < maxbl :          print ( <str> )  if uvmin > minbl :          print ( <str> )  if flux > 1.2 * maxamp :          print ( <str> )  if flux < .8 * maxamp :          print ( <str> )  embed_mask = Prior . imvec > clipfloor if ( not norm_init ) :          nprior = Prior . imvec [ embed_mask ] ninit = InitIm . imvec [ embed_mask ]  else :          nprior = ( flux * Prior . imvec / np . sum ( ( Prior . imvec ) [ embed_mask ] ) ) [ embed_mask ] ninit = ( flux * InitIm . imvec / np . sum ( ( InitIm . imvec ) [ embed_mask ] ) ) [ embed_mask ]  if len ( nprior ) == 0 :          raise Exception ( <str> )  ( data1 , sigma1 , A1 ) = chisqdata ( Obsdata , Prior , embed_mask , d1 , pol = pol , ** kwargs ) ( data2 , sigma2 , A2 ) = chisqdata ( Obsdata , Prior , embed_mask , d2 , pol = pol , ** kwargs ) ( data3 , sigma3 , A3 ) = chisqdata ( Obsdata , Prior , embed_mask , d3 , pol = pol , ** kwargs ) def chisq1 ( imvec ) :          return chisq ( imvec , A1 , data1 , sigma1 , d1 , ttype = ttype , mask = embed_mask )  def chisq1grad ( imvec ) :          c = chisqgrad ( imvec , A1 , data1 , sigma1 , d1 , ttype = ttype , mask = embed_mask ) return c  def chisq2 ( imvec ) :          return chisq ( imvec , A2 , data2 , sigma2 , d2 , ttype = ttype , mask = embed_mask )  def chisq2grad ( imvec ) :          c = chisqgrad ( imvec , A2 , data2 , sigma2 , d2 , ttype = ttype , mask = embed_mask ) return c  def chisq3 ( imvec ) :          return chisq ( imvec , A3 , data3 , sigma3 , d3 , ttype = ttype , mask = embed_mask )  def chisq3grad ( imvec ) :          c = chisqgrad ( imvec , A3 , data3 , sigma3 , d3 , ttype = ttype , mask = embed_mask ) return c  def reg1 ( imvec ) :          return regularizer ( imvec , nprior , embed_mask , flux , Prior . xdim , Prior . ydim , Prior . psize , s1 , ** kwargs )  def reg1grad ( imvec ) :          return regularizergrad ( imvec , nprior , embed_mask , flux , Prior . xdim , Prior . ydim , Prior . psize , s1 , ** kwargs )  def reg2 ( imvec ) :          return regularizer ( imvec , nprior , embed_mask , flux , Prior . xdim , Prior . ydim , Prior . psize , s2 , ** kwargs )  def reg2grad ( imvec ) :          return regularizergrad ( imvec , nprior , embed_mask , flux , Prior . xdim , Prior . ydim , Prior . psize , s2 , ** kwargs )  def reg3 ( imvec ) :          return regularizer ( imvec , nprior , embed_mask , flux , Prior . xdim , Prior . ydim , Prior . psize , s3 , ** kwargs )  def reg3grad ( imvec ) :          return regularizergrad ( imvec , nprior , embed_mask , flux , Prior . xdim , Prior . ydim , Prior . psize , s3 , ** kwargs )  def flux_constraint ( imvec ) :          return regularizer ( imvec , nprior , embed_mask , flux , Prior . xdim , Prior . ydim , Prior . psize , <str> , ** kwargs )  def flux_constraint_grad ( imvec ) :          return regularizergrad ( imvec , nprior , embed_mask , flux , Prior . xdim , Prior . ydim , Prior . psize , <str> , ** kwargs )  def cm_constraint ( imvec ) :          return regularizer ( imvec , nprior , embed_mask , flux , Prior . xdim , Prior . ydim , Prior . psize , <str> , ** kwargs )  def cm_constraint_grad ( imvec ) :          return regularizergrad ( imvec , nprior , embed_mask , flux , Prior . xdim , Prior . ydim , Prior . psize , <str> , ** kwargs )  def objfunc ( imvec ) :          if logim : imvec = np . exp ( imvec ) datterm = alpha_d1 * ( chisq1 ( imvec ) - 1 ) + alpha_d2 * ( chisq2 ( imvec ) - 1 ) + alpha_d3 * ( chisq3 ( imvec ) - 1 ) regterm = alpha_s1 * reg1 ( imvec ) + alpha_s2 * reg2 ( imvec ) + alpha_s3 * reg3 ( imvec ) conterm = alpha_flux * flux_constraint ( imvec ) + alpha_cm * cm_constraint ( imvec ) return datterm + regterm + conterm  def objgrad ( imvec ) :          if logim : imvec = np . exp ( imvec ) datterm = alpha_d1 * chisq1grad ( imvec ) + alpha_d2 * chisq2grad ( imvec ) + alpha_d3 * chisq3grad ( imvec ) regterm = alpha_s1 * reg1grad ( imvec ) + alpha_s2 * reg2grad ( imvec ) + alpha_s3 * reg3grad ( imvec ) conterm = alpha_flux * flux_constraint_grad ( imvec ) + alpha_cm * cm_constraint_grad ( imvec ) grad = datterm + regterm + conterm if logim : grad *= imvec return grad  global nit nit = 0 def plotcur ( im_step ) :          global nit if logim : im_step = np . exp ( im_step ) if show_updates :              chi2_1 = chisq1 ( im_step ) chi2_2 = chisq2 ( im_step ) chi2_3 = chisq3 ( im_step ) s_1 = reg1 ( im_step ) s_2 = reg2 ( im_step ) s_3 = reg3 ( im_step ) if np . any ( np . invert ( embed_mask ) ) : im_step = embed ( im_step , embed_mask ) plot_i ( im_step , Prior , nit , { d1 : chi2_1 , d2 : chi2_2 , d3 : chi2_3 } , pol = pol ) print ( <str> % ( nit , chi2_1 , chi2_2 , chi2_3 , s_1 , s_2 , s_3 ) )  nit += 1  if logim :          xinit = np . log ( ninit )  else :          xinit = ninit  print ( <str> % ( reg1 ( ninit ) , reg2 ( ninit ) , reg3 ( ninit ) ) ) print ( <str> % ( chisq1 ( ninit ) , chisq2 ( ninit ) , chisq3 ( ninit ) ) ) print ( <str> % ( objfunc ( xinit ) ) ) if d1 in DATATERMS :          print ( <str> , ( len ( data1 ) ) )  if d2 in DATATERMS :          print ( <str> , ( len ( data2 ) ) )  if d3 in DATATERMS :          print ( <str> , ( len ( data3 ) ) )  print ( <str> , ( len ( Prior . imvec ) ) ) print ( <str> , ( len ( ninit ) ) ) print ( ) plotcur ( xinit ) optdict = { <str> : maxit , <str> : stop , <str> : NHIST , <str> : stop , <str> : MAXLS } tstart = time . time ( ) if grads :          res = opt . minimize ( objfunc , xinit , method = <str> , jac = objgrad , options = optdict , callback = plotcur )  else :          res = opt . minimize ( objfunc , xinit , method = <str> , options = optdict , callback = plotcur )  tstop = time . time ( ) out = res . x if logim : out = np . exp ( res . x ) if np . any ( np . invert ( embed_mask ) ) : out = embed ( out , embed_mask ) outim = image . Image ( out . reshape ( Prior . ydim , Prior . xdim ) , Prior . psize , Prior . ra , Prior . dec , rf = Prior . rf , source = Prior . source , polrep = Prior . polrep , pol_prim = pol , mjd = Prior . mjd , time = Prior . time , pulse = Prior . pulse ) outim . copy_pol_images ( InitIm ) print ( <str> % ( tstop - tstart ) ) print ( <str> % res . fun ) print ( <str> % ( chisq1 ( out [ embed_mask ] ) , chisq2 ( out [ embed_mask ] ) , chisq3 ( out [ embed_mask ] ) ) ) print ( res . message ) return outim  def chisq ( imvec , A , data , sigma , dtype , ttype = <str> , mask = None ) :      if mask is None : mask = [ ] chisq = 1 if not dtype in DATATERMS :          return chisq  if ttype not in [ <str> , <str> , <str> ] :          raise Exception ( <str> )  if ttype == <str> :          if dtype == <str> :              chisq = chisq_vis ( imvec , A , data , sigma )  elif dtype == <str> :              chisq = chisq_amp ( imvec , A , data , sigma )  elif dtype == <str> :              chisq = chisq_logamp ( imvec , A , data , sigma )  elif dtype == <str> :              chisq = chisq_bs ( imvec , A , data , sigma )  elif dtype == <str> :              chisq = chisq_cphase ( imvec , A , data , sigma )  elif dtype == <str> :              chisq = chisq_camp ( imvec , A , data , sigma )  elif dtype == <str> :              chisq = chisq_logcamp ( imvec , A , data , sigma )   elif ttype == <str> :          if len ( mask ) > 0 and np . any ( np . invert ( mask ) ) :              imvec = embed ( imvec , mask , randomfloor = True )  vis_arr = fft_imvec ( imvec , A [ 0 ] ) if dtype == <str> :              chisq = chisq_vis_fft ( vis_arr , A , data , sigma )  elif dtype == <str> :              chisq = chisq_amp_fft ( vis_arr , A , data , sigma )  elif dtype == <str> :              chisq = chisq_logamp_fft ( vis_arr , A , data , sigma )  elif dtype == <str> :              chisq = chisq_bs_fft ( vis_arr , A , data , sigma )  elif dtype == <str> :              chisq = chisq_cphase_fft ( vis_arr , A , data , sigma )  elif dtype == <str> :              chisq = chisq_camp_fft ( vis_arr , A , data , sigma )  elif dtype == <str> :              chisq = chisq_logcamp_fft ( vis_arr , A , data , sigma )   elif ttype == <str> :          if len ( mask ) > 0 and np . any ( np . invert ( mask ) ) :              imvec = embed ( imvec , mask , randomfloor = True )  if dtype == <str> :              chisq = chisq_vis_nfft ( imvec , A , data , sigma )  elif dtype == <str> :              chisq = chisq_amp_nfft ( imvec , A , data , sigma )  elif dtype == <str> :              chisq = chisq_logamp_nfft ( imvec , A , data , sigma )  elif dtype == <str> :              chisq = chisq_bs_nfft ( imvec , A , data , sigma )  elif dtype == <str> :              chisq = chisq_cphase_nfft ( imvec , A , data , sigma )  elif dtype == <str> :              chisq = chisq_camp_nfft ( imvec , A , data , sigma )  elif dtype == <str> :              chisq = chisq_logcamp_nfft ( imvec , A , data , sigma )   return chisq  def chisqgrad ( imvec , A , data , sigma , dtype , ttype = <str> , mask = None ) :      if mask is None : mask = [ ] chisqgrad = np . zeros ( len ( imvec ) ) if not dtype in DATATERMS :          return chisqgrad  if ttype not in [ <str> , <str> , <str> ] :          raise Exception ( <str> )  if ttype == <str> :          if dtype == <str> :              chisqgrad = chisqgrad_vis ( imvec , A , data , sigma )  elif dtype == <str> :              chisqgrad = chisqgrad_amp ( imvec , A , data , sigma )  elif dtype == <str> :              chisqgrad = chisqgrad_logamp ( imvec , A , data , sigma )  elif dtype == <str> :              chisqgrad = chisqgrad_bs ( imvec , A , data , sigma )  elif dtype == <str> :              chisqgrad = chisqgrad_cphase ( imvec , A , data , sigma )  elif dtype == <str> :              chisqgrad = chisqgrad_camp ( imvec , A , data , sigma )  elif dtype == <str> :              chisqgrad = chisqgrad_logcamp ( imvec , A , data , sigma )   elif ttype == <str> :          if len ( mask ) > 0 and np . any ( np . invert ( mask ) ) :              imvec = embed ( imvec , mask , randomfloor = True )  vis_arr = fft_imvec ( imvec , A [ 0 ] ) if dtype == <str> :              chisqgrad = chisqgrad_vis_fft ( vis_arr , A , data , sigma )  elif dtype == <str> :              chisqgrad = chisqgrad_amp_fft ( vis_arr , A , data , sigma )  elif dtype == <str> :              chisqgrad = chisqgrad_logamp_fft ( vis_arr , A , data , sigma )  elif dtype == <str> :              chisqgrad = chisqgrad_bs_fft ( vis_arr , A , data , sigma )  elif dtype == <str> :              chisqgrad = chisqgrad_cphase_fft ( vis_arr , A , data , sigma )  elif dtype == <str> :              chisqgrad = chisqgrad_camp_fft ( vis_arr , A , data , sigma )  elif dtype == <str> :              chisqgrad = chisqgrad_logcamp_fft ( vis_arr , A , data , sigma )  if len ( mask ) > 0 and np . any ( np . invert ( mask ) ) :              chisqgrad = chisqgrad [ mask ]   elif ttype == <str> :          if len ( mask ) > 0 and np . any ( np . invert ( mask ) ) :              imvec = embed ( imvec , mask , randomfloor = True )  if dtype == <str> :              chisqgrad = chisqgrad_vis_nfft ( imvec , A , data , sigma )  elif dtype == <str> :              chisqgrad = chisqgrad_amp_nfft ( imvec , A , data , sigma )  elif dtype == <str> :              chisqgrad = chisqgrad_logamp_nfft ( imvec , A , data , sigma )  elif dtype == <str> :              chisqgrad = chisqgrad_bs_nfft ( imvec , A , data , sigma )  elif dtype == <str> :              chisqgrad = chisqgrad_cphase_nfft ( imvec , A , data , sigma )  elif dtype == <str> :              chisqgrad = chisqgrad_camp_nfft ( imvec , A , data , sigma )  elif dtype == <str> :              chisqgrad = chisqgrad_logcamp_nfft ( imvec , A , data , sigma )  if len ( mask ) > 0 and np . any ( np . invert ( mask ) ) :              chisqgrad = chisqgrad [ mask ]   return chisqgrad  def regularizer ( imvec , nprior , mask , flux , xdim , ydim , psize , stype , ** kwargs ) :      norm_reg = kwargs . get ( <str> , NORM_REGULARIZER ) beam_size = kwargs . get ( <str> , psize ) alpha_A = kwargs . get ( <str> , 1.0 ) if stype == <str> :          s = - sflux ( imvec , nprior , flux , norm_reg = norm_reg )  elif stype == <str> :          s = - scm ( imvec , xdim , ydim , psize , flux , mask , norm_reg = norm_reg , beam_size = beam_size )  elif stype == <str> :          s = - ssimple ( imvec , nprior , flux , norm_reg = norm_reg )  elif stype == <str> :          s = - sl1 ( imvec , nprior , flux , norm_reg = norm_reg )  elif stype == <str> :          s = - slA ( imvec , nprior , psize , flux , beam_size , alpha_A , norm_reg )  elif stype == <str> :          s = - sgs ( imvec , nprior , flux , norm_reg = norm_reg )  elif stype == <str> :          s = - spatch ( imvec , nprior , flux , norm_reg = norm_reg )  elif stype == <str> :          if np . any ( np . invert ( mask ) ) :              imvec = embed ( imvec , mask , randomfloor = True )  s = - stv ( imvec , xdim , ydim , psize , flux , norm_reg = norm_reg , beam_size = beam_size )  elif stype == <str> :          if np . any ( np . invert ( mask ) ) :              imvec = embed ( imvec , mask , randomfloor = True )  s = - stv2 ( imvec , xdim , ydim , psize , flux , norm_reg = norm_reg , beam_size = beam_size )  elif stype == <str> :          if np . any ( np . invert ( mask ) ) :              imvec = embed ( imvec , mask , randomfloor = True )  s = - scompact ( imvec , xdim , ydim , psize , flux , norm_reg = norm_reg )  elif stype == <str> :          if np . any ( np . invert ( mask ) ) :              imvec = embed ( imvec , mask , randomfloor = True )  s = - scompact2 ( imvec , xdim , ydim , psize , flux , norm_reg = norm_reg )  elif stype == <str> :          major = kwargs . get ( <str> , 1.0 ) minor = kwargs . get ( <str> , 1.0 ) PA = kwargs . get ( <str> , 1.0 ) if np . any ( np . invert ( mask ) ) :              imvec = embed ( imvec , mask , randomfloor = True )  s = - sgauss ( imvec , xdim , ydim , psize , major = major , minor = minor , PA = PA )  else :          s = 0  return s  def regularizergrad ( imvec , nprior , mask , flux , xdim , ydim , psize , stype , ** kwargs ) :      norm_reg = kwargs . get ( <str> , NORM_REGULARIZER ) beam_size = kwargs . get ( <str> , psize ) alpha_A = kwargs . get ( <str> , 1.0 ) if stype == <str> :          s = - sfluxgrad ( imvec , nprior , flux , norm_reg = norm_reg )  elif stype == <str> :          s = - scmgrad ( imvec , xdim , ydim , psize , flux , mask , norm_reg = norm_reg , beam_size = beam_size )  elif stype == <str> :          s = - ssimplegrad ( imvec , nprior , flux , norm_reg = norm_reg )  elif stype == <str> :          s = - sl1grad ( imvec , nprior , flux , norm_reg = norm_reg )  elif stype == <str> :          s = - slAgrad ( imvec , nprior , psize , flux , beam_size , alpha_A , norm_reg )  elif stype == <str> :          s = - sgsgrad ( imvec , nprior , flux , norm_reg = norm_reg )  elif stype == <str> :          s = - spatchgrad ( imvec , nprior , flux , norm_reg = norm_reg )  elif stype == <str> :          if np . any ( np . invert ( mask ) ) :              imvec = embed ( imvec , mask , randomfloor = True )  s = - stvgrad ( imvec , xdim , ydim , psize , flux , norm_reg = norm_reg , beam_size = beam_size ) s = s [ mask ]  elif stype == <str> :          if np . any ( np . invert ( mask ) ) :              imvec = embed ( imvec , mask , randomfloor = True )  s = - stv2grad ( imvec , xdim , ydim , psize , flux , norm_reg = norm_reg , beam_size = beam_size ) s = s [ mask ]  elif stype == <str> :          if np . any ( np . invert ( mask ) ) :              imvec = embed ( imvec , mask , randomfloor = True )  s = - scompactgrad ( imvec , xdim , ydim , psize , flux , norm_reg = norm_reg ) s = s [ mask ]  elif stype == <str> :          if np . any ( np . invert ( mask ) ) :              imvec = embed ( imvec , mask , randomfloor = True )  s = - scompact2grad ( imvec , xdim , ydim , psize , flux , norm_reg = norm_reg ) s = s [ mask ]  elif stype == <str> :          major = kwargs . get ( <str> , 1.0 ) minor = kwargs . get ( <str> , 1.0 ) PA = kwargs . get ( <str> , 1.0 ) if np . any ( np . invert ( mask ) ) :              imvec = embed ( imvec , mask , randomfloor = True )  s = - sgauss_grad ( imvec , xdim , ydim , psize , major , minor , PA ) s = s [ mask ]  else :          s = np . zeros ( len ( imvec ) )  return s  def chisqdata ( Obsdata , Prior , mask , dtype , pol = <str> , ** kwargs ) :      ttype = kwargs . get ( <str> , <str> ) ( data , sigma , A ) = ( False , False , False ) if ttype not in [ <str> , <str> , <str> ] :          raise Exception ( <str> )  if ttype == <str> :          if dtype == <str> :              ( data , sigma , A ) = chisqdata_vis ( Obsdata , Prior , mask , pol = pol , ** kwargs )  elif dtype == <str> or dtype == <str> :              ( data , sigma , A ) = chisqdata_amp ( Obsdata , Prior , mask , pol = pol , ** kwargs )  elif dtype == <str> :              ( data , sigma , A ) = chisqdata_bs ( Obsdata , Prior , mask , pol = pol , ** kwargs )  elif dtype == <str> :              ( data , sigma , A ) = chisqdata_cphase ( Obsdata , Prior , mask , pol = pol , ** kwargs )  elif dtype == <str> :              ( data , sigma , A ) = chisqdata_camp ( Obsdata , Prior , mask , pol = pol , ** kwargs )  elif dtype == <str> :              ( data , sigma , A ) = chisqdata_logcamp ( Obsdata , Prior , mask , pol = pol , ** kwargs )   elif ttype == <str> :          if dtype == <str> :              ( data , sigma , A ) = chisqdata_vis_fft ( Obsdata , Prior , pol = pol , ** kwargs )  elif dtype == <str> or dtype == <str> :              ( data , sigma , A ) = chisqdata_amp_fft ( Obsdata , Prior , pol = pol , ** kwargs )  elif dtype == <str> :              ( data , sigma , A ) = chisqdata_bs_fft ( Obsdata , Prior , pol = pol , ** kwargs )  elif dtype == <str> :              ( data , sigma , A ) = chisqdata_cphase_fft ( Obsdata , Prior , pol = pol , ** kwargs )  elif dtype == <str> :              ( data , sigma , A ) = chisqdata_camp_fft ( Obsdata , Prior , pol = pol , ** kwargs )  elif dtype == <str> :              ( data , sigma , A ) = chisqdata_logcamp_fft ( Obsdata , Prior , pol = pol , ** kwargs )   elif ttype == <str> :          if dtype == <str> :              ( data , sigma , A ) = chisqdata_vis_nfft ( Obsdata , Prior , pol = pol , ** kwargs )  elif dtype == <str> or dtype == <str> :              ( data , sigma , A ) = chisqdata_amp_nfft ( Obsdata , Prior , pol = pol , ** kwargs )  elif dtype == <str> :              ( data , sigma , A ) = chisqdata_bs_nfft ( Obsdata , Prior , pol = pol , ** kwargs )  elif dtype == <str> :              ( data , sigma , A ) = chisqdata_cphase_nfft ( Obsdata , Prior , pol = pol , ** kwargs )  elif dtype == <str> :              ( data , sigma , A ) = chisqdata_camp_nfft ( Obsdata , Prior , pol = pol , ** kwargs )  elif dtype == <str> :              ( data , sigma , A ) = chisqdata_logcamp_nfft ( Obsdata , Prior , pol = pol , ** kwargs )   return ( data , sigma , A )  def chisq_vis ( imvec , Amatrix , vis , sigma ) :      samples = np . dot ( Amatrix , imvec ) return np . sum ( np . abs ( ( samples - vis ) / sigma ) ** 2 ) / ( 2 * len ( vis ) )  def chisqgrad_vis ( imvec , Amatrix , vis , sigma ) :      samples = np . dot ( Amatrix , imvec ) wdiff = ( vis - samples ) / ( sigma ** 2 ) out = - np . real ( np . dot ( Amatrix . conj ( ) . T , wdiff ) ) / len ( vis ) return out  def chisq_amp ( imvec , A , amp , sigma ) :      amp_samples = np . abs ( np . dot ( A , imvec ) ) return np . sum ( np . abs ( ( amp - amp_samples ) / sigma ) ** 2 ) / len ( amp )  def chisqgrad_amp ( imvec , A , amp , sigma ) :      i1 = np . dot ( A , imvec ) amp_samples = np . abs ( i1 ) pp = ( ( amp - amp_samples ) * amp_samples ) / ( sigma ** 2 ) / i1 out = ( - 2.0 / len ( amp ) ) * np . real ( np . dot ( pp , A ) ) return out  def chisq_bs ( imvec , Amatrices , bis , sigma ) :      bisamples = np . dot ( Amatrices [ 0 ] , imvec ) * np . dot ( Amatrices [ 1 ] , imvec ) * np . dot ( Amatrices [ 2 ] , imvec ) chisq = np . sum ( np . abs ( ( ( bis - bisamples ) / sigma ) ) ** 2 ) / ( 2. * len ( bis ) ) return chisq  def chisqgrad_bs ( imvec , Amatrices , bis , sigma ) :      bisamples = np . dot ( Amatrices [ 0 ] , imvec ) * np . dot ( Amatrices [ 1 ] , imvec ) * np . dot ( Amatrices [ 2 ] , imvec ) wdiff = ( ( bis - bisamples ) . conj ( ) ) / ( sigma ** 2 ) pt1 = wdiff * np . dot ( Amatrices [ 1 ] , imvec ) * np . dot ( Amatrices [ 2 ] , imvec ) pt2 = wdiff * np . dot ( Amatrices [ 0 ] , imvec ) * np . dot ( Amatrices [ 2 ] , imvec ) pt3 = wdiff * np . dot ( Amatrices [ 0 ] , imvec ) * np . dot ( Amatrices [ 1 ] , imvec ) out = - np . real ( np . dot ( pt1 , Amatrices [ 0 ] ) + np . dot ( pt2 , Amatrices [ 1 ] ) + np . dot ( pt3 , Amatrices [ 2 ] ) ) / len ( bis ) return out  def chisq_cphase ( imvec , Amatrices , clphase , sigma ) :      clphase = clphase * DEGREE sigma = sigma * DEGREE clphase_samples = np . angle ( np . dot ( Amatrices [ 0 ] , imvec ) * np . dot ( Amatrices [ 1 ] , imvec ) * np . dot ( Amatrices [ 2 ] , imvec ) ) chisq = ( 2.0 / len ( clphase ) ) * np . sum ( ( 1.0 - np . cos ( clphase - clphase_samples ) ) / ( sigma ** 2 ) ) return chisq  def chisqgrad_cphase ( imvec , Amatrices , clphase , sigma ) :      clphase = clphase * DEGREE sigma = sigma * DEGREE i1 = np . dot ( Amatrices [ 0 ] , imvec ) i2 = np . dot ( Amatrices [ 1 ] , imvec ) i3 = np . dot ( Amatrices [ 2 ] , imvec ) clphase_samples = np . angle ( i1 * i2 * i3 ) pref = np . sin ( clphase - clphase_samples ) / ( sigma ** 2 ) pt1 = pref / i1 pt2 = pref / i2 pt3 = pref / i3 out = - ( 2.0 / len ( clphase ) ) * np . imag ( np . dot ( pt1 , Amatrices [ 0 ] ) + np . dot ( pt2 , Amatrices [ 1 ] ) + np . dot ( pt3 , Amatrices [ 2 ] ) ) return out  def chisq_camp ( imvec , Amatrices , clamp , sigma ) :      clamp_samples = np . abs ( np . dot ( Amatrices [ 0 ] , imvec ) * np . dot ( Amatrices [ 1 ] , imvec ) / ( np . dot ( Amatrices [ 2 ] , imvec ) * np . dot ( Amatrices [ 3 ] , imvec ) ) ) chisq = np . sum ( np . abs ( ( clamp - clamp_samples ) / sigma ) ** 2 ) / len ( clamp ) return chisq  def chisqgrad_camp ( imvec , Amatrices , clamp , sigma ) :      i1 = np . dot ( Amatrices [ 0 ] , imvec ) i2 = np . dot ( Amatrices [ 1 ] , imvec ) i3 = np . dot ( Amatrices [ 2 ] , imvec ) i4 = np . dot ( Amatrices [ 3 ] , imvec ) clamp_samples = np . abs ( ( i1 * i2 ) / ( i3 * i4 ) ) pp = ( ( clamp - clamp_samples ) * clamp_samples ) / ( sigma ** 2 ) pt1 = pp / i1 pt2 = pp / i2 pt3 = - pp / i3 pt4 = - pp / i4 out = ( - 2.0 / len ( clamp ) ) * np . real ( np . dot ( pt1 , Amatrices [ 0 ] ) + np . dot ( pt2 , Amatrices [ 1 ] ) + np . dot ( pt3 , Amatrices [ 2 ] ) + np . dot ( pt4 , Amatrices [ 3 ] ) ) return out  def chisq_logcamp ( imvec , Amatrices , log_clamp , sigma ) :      a1 = np . abs ( np . dot ( Amatrices [ 0 ] , imvec ) ) a2 = np . abs ( np . dot ( Amatrices [ 1 ] , imvec ) ) a3 = np . abs ( np . dot ( Amatrices [ 2 ] , imvec ) ) a4 = np . abs ( np . dot ( Amatrices [ 3 ] , imvec ) ) samples = np . log ( a1 ) + np . log ( a2 ) - np . log ( a3 ) - np . log ( a4 ) chisq = np . sum ( np . abs ( ( log_clamp - samples ) / sigma ) ** 2 ) / ( len ( log_clamp ) ) return chisq  def chisqgrad_logcamp ( imvec , Amatrices , log_clamp , sigma ) :      i1 = np . dot ( Amatrices [ 0 ] , imvec ) i2 = np . dot ( Amatrices [ 1 ] , imvec ) i3 = np . dot ( Amatrices [ 2 ] , imvec ) i4 = np . dot ( Amatrices [ 3 ] , imvec ) log_clamp_samples = np . log ( np . abs ( i1 ) ) + np . log ( np . abs ( i2 ) ) - np . log ( np . abs ( i3 ) ) - np . log ( np . abs ( i4 ) ) pp = ( log_clamp - log_clamp_samples ) / ( sigma ** 2 ) pt1 = pp / i1 pt2 = pp / i2 pt3 = - pp / i3 pt4 = - pp / i4 out = ( - 2.0 / len ( log_clamp ) ) * np . real ( np . dot ( pt1 , Amatrices [ 0 ] ) + np . dot ( pt2 , Amatrices [ 1 ] ) + np . dot ( pt3 , Amatrices [ 2 ] ) + np . dot ( pt4 , Amatrices [ 3 ] ) ) return out  def chisq_logamp ( imvec , A , amp , sigma ) :      logsigma = sigma / amp amp_samples = np . abs ( np . dot ( A , imvec ) ) return np . sum ( np . abs ( ( np . log ( amp ) - np . log ( amp_samples ) ) / logsigma ) ** 2 ) / len ( amp )  def chisqgrad_logamp ( imvec , A , amp , sigma ) :      logsigma = sigma / amp i1 = np . dot ( A , imvec ) amp_samples = np . abs ( i1 ) pp = ( ( np . log ( amp ) - np . log ( amp_samples ) ) ) / ( logsigma ** 2 ) / i1 out = ( - 2.0 / len ( amp ) ) * np . real ( np . dot ( pp , A ) ) return out  def chisq_vis_fft ( vis_arr , A , vis , sigma ) :      im_info , sampler_info_list , gridder_info_list = A samples = sampler ( vis_arr , sampler_info_list , sample_type = <str> ) chisq = np . sum ( np . abs ( ( samples - vis ) / sigma ) ** 2 ) / ( 2 * len ( vis ) ) return chisq  def chisqgrad_vis_fft ( vis_arr , A , vis , sigma ) :      im_info , sampler_info_list , gridder_info_list = A pulsefac = sampler_info_list [ 0 ] . pulsefac samples = sampler ( vis_arr , sampler_info_list , sample_type = <str> ) wdiff_vec = ( - 1.0 / len ( vis ) * ( vis - samples ) / ( sigma ** 2 ) ) * pulsefac . conj ( ) wdiff_arr = gridder ( [ wdiff_vec ] , gridder_info_list ) grad_arr = np . fft . ifftshift ( np . fft . ifft2 ( np . fft . fftshift ( wdiff_arr ) ) ) grad_arr = grad_arr * ( im_info . npad * im_info . npad ) out = np . real ( grad_arr [ im_info . padvalx1 : - im_info . padvalx2 , im_info . padvaly1 : - im_info . padvaly2 ] . flatten ( ) ) return out  def chisq_amp_fft ( vis_arr , A , amp , sigma ) :      im_info , sampler_info_list , gridder_info_list = A amp_samples = np . abs ( sampler ( vis_arr , sampler_info_list , sample_type = <str> ) ) chisq = np . sum ( np . abs ( ( amp_samples - amp ) / sigma ) ** 2 ) / ( len ( amp ) ) return chisq  def chisqgrad_amp_fft ( vis_arr , A , amp , sigma ) :      im_info , sampler_info_list , gridder_info_list = A samples = sampler ( vis_arr , sampler_info_list , sample_type = <str> ) amp_samples = np . abs ( samples ) pulsefac = sampler_info_list [ 0 ] . pulsefac wdiff_vec = ( - 2.0 / len ( amp ) * ( ( amp - amp_samples ) * amp_samples ) / ( sigma ** 2 ) / samples . conj ( ) ) * pulsefac . conj ( ) wdiff_arr = gridder ( [ wdiff_vec ] , gridder_info_list ) grad_arr = np . fft . ifftshift ( np . fft . ifft2 ( np . fft . fftshift ( wdiff_arr ) ) ) grad_arr = grad_arr * ( im_info . npad * im_info . npad ) out = np . real ( grad_arr [ im_info . padvalx1 : - im_info . padvalx2 , im_info . padvaly1 : - im_info . padvaly2 ] . flatten ( ) ) return out  def chisq_bs_fft ( vis_arr , A , bis , sigma ) :      im_info , sampler_info_list , gridder_info_list = A bisamples = sampler ( vis_arr , sampler_info_list , sample_type = <str> ) return np . sum ( np . abs ( ( ( bis - bisamples ) / sigma ) ) ** 2 ) / ( 2. * len ( bis ) )  def chisqgrad_bs_fft ( vis_arr , A , bis , sigma ) :      im_info , sampler_info_list , gridder_info_list = A v1 = sampler ( vis_arr , [ sampler_info_list [ 0 ] ] , sample_type = <str> ) v2 = sampler ( vis_arr , [ sampler_info_list [ 1 ] ] , sample_type = <str> ) v3 = sampler ( vis_arr , [ sampler_info_list [ 2 ] ] , sample_type = <str> ) bisamples = v1 * v2 * v3 wdiff = - 1.0 / len ( bis ) * ( bis - bisamples ) / ( sigma ** 2 ) pt1 = wdiff * ( v2 * v3 ) . conj ( ) * sampler_info_list [ 0 ] . pulsefac . conj ( ) pt2 = wdiff * ( v1 * v3 ) . conj ( ) * sampler_info_list [ 1 ] . pulsefac . conj ( ) pt3 = wdiff * ( v1 * v2 ) . conj ( ) * sampler_info_list [ 2 ] . pulsefac . conj ( ) wdiff = gridder ( [ pt1 , pt2 , pt3 ] , gridder_info_list ) grad_arr = np . fft . ifftshift ( np . fft . ifft2 ( np . fft . fftshift ( wdiff ) ) ) grad_arr = grad_arr * ( im_info . npad * im_info . npad ) out = np . real ( grad_arr [ im_info . padvalx1 : - im_info . padvalx2 , im_info . padvaly1 : - im_info . padvaly2 ] . flatten ( ) ) return out  def chisq_cphase_fft ( vis_arr , A , clphase , sigma ) :      clphase = clphase * DEGREE sigma = sigma * DEGREE im_info , sampler_info_list , gridder_info_list = A clphase_samples = np . angle ( sampler ( vis_arr , sampler_info_list , sample_type = <str> ) ) chisq = ( 2.0 / len ( clphase ) ) * np . sum ( ( 1.0 - np . cos ( clphase - clphase_samples ) ) / ( sigma ** 2 ) ) return chisq  def chisqgrad_cphase_fft ( vis_arr , A , clphase , sigma ) :      clphase = clphase * DEGREE sigma = sigma * DEGREE im_info , sampler_info_list , gridder_info_list = A v1 = sampler ( vis_arr , [ sampler_info_list [ 0 ] ] , sample_type = <str> ) v2 = sampler ( vis_arr , [ sampler_info_list [ 1 ] ] , sample_type = <str> ) v3 = sampler ( vis_arr , [ sampler_info_list [ 2 ] ] , sample_type = <str> ) clphase_samples = np . angle ( v1 * v2 * v3 ) pref = ( 2.0 / len ( clphase ) ) * np . sin ( clphase - clphase_samples ) / ( sigma ** 2 ) pt1 = pref / v1 . conj ( ) * sampler_info_list [ 0 ] . pulsefac . conj ( ) pt2 = pref / v2 . conj ( ) * sampler_info_list [ 1 ] . pulsefac . conj ( ) pt3 = pref / v3 . conj ( ) * sampler_info_list [ 2 ] . pulsefac . conj ( ) wdiff = gridder ( [ pt1 , pt2 , pt3 ] , gridder_info_list ) grad_arr = np . fft . ifftshift ( np . fft . ifft2 ( np . fft . fftshift ( wdiff ) ) ) grad_arr = grad_arr * ( im_info . npad * im_info . npad ) out = np . imag ( grad_arr [ im_info . padvalx1 : - im_info . padvalx2 , im_info . padvaly1 : - im_info . padvaly2 ] . flatten ( ) ) return out  def chisq_camp_fft ( vis_arr , A , clamp , sigma ) :      im_info , sampler_info_list , gridder_info_list = A clamp_samples = sampler ( vis_arr , sampler_info_list , sample_type = <str> ) chisq = np . sum ( np . abs ( ( clamp - clamp_samples ) / sigma ) ** 2 ) / len ( clamp ) return chisq  def chisqgrad_camp_fft ( vis_arr , A , clamp , sigma ) :      im_info , sampler_info_list , gridder_info_list = A v1 = sampler ( vis_arr , [ sampler_info_list [ 0 ] ] , sample_type = <str> ) v2 = sampler ( vis_arr , [ sampler_info_list [ 1 ] ] , sample_type = <str> ) v3 = sampler ( vis_arr , [ sampler_info_list [ 2 ] ] , sample_type = <str> ) v4 = sampler ( vis_arr , [ sampler_info_list [ 3 ] ] , sample_type = <str> ) clamp_samples = np . abs ( ( v1 * v2 ) / ( v3 * v4 ) ) pp = ( - 2.0 / len ( clamp ) ) * ( ( clamp - clamp_samples ) * clamp_samples ) / ( sigma ** 2 ) pt1 = pp / v1 . conj ( ) * sampler_info_list [ 0 ] . pulsefac . conj ( ) pt2 = pp / v2 . conj ( ) * sampler_info_list [ 1 ] . pulsefac . conj ( ) pt3 = - pp / v3 . conj ( ) * sampler_info_list [ 2 ] . pulsefac . conj ( ) pt4 = - pp / v4 . conj ( ) * sampler_info_list [ 3 ] . pulsefac . conj ( ) wdiff = gridder ( [ pt1 , pt2 , pt3 , pt4 ] , gridder_info_list ) grad_arr = np . fft . ifftshift ( np . fft . ifft2 ( np . fft . fftshift ( wdiff ) ) ) grad_arr = grad_arr * ( im_info . npad * im_info . npad ) out = np . real ( grad_arr [ im_info . padvalx1 : - im_info . padvalx2 , im_info . padvaly1 : - im_info . padvaly2 ] . flatten ( ) ) return out  def chisq_logcamp_fft ( vis_arr , A , log_clamp , sigma ) :      im_info , sampler_info_list , gridder_info_list = A log_clamp_samples = np . log ( sampler ( vis_arr , sampler_info_list , sample_type = <str> ) ) chisq = np . sum ( np . abs ( ( log_clamp - log_clamp_samples ) / sigma ) ** 2 ) / ( len ( log_clamp ) ) return chisq  def chisqgrad_logcamp_fft ( vis_arr , A , log_clamp , sigma ) :      im_info , sampler_info_list , gridder_info_list = A v1 = sampler ( vis_arr , [ sampler_info_list [ 0 ] ] , sample_type = <str> ) v2 = sampler ( vis_arr , [ sampler_info_list [ 1 ] ] , sample_type = <str> ) v3 = sampler ( vis_arr , [ sampler_info_list [ 2 ] ] , sample_type = <str> ) v4 = sampler ( vis_arr , [ sampler_info_list [ 3 ] ] , sample_type = <str> ) log_clamp_samples = np . log ( np . abs ( ( v1 * v2 ) / ( v3 * v4 ) ) ) pp = ( - 2.0 / len ( log_clamp ) ) * ( log_clamp - log_clamp_samples ) / ( sigma ** 2 ) pt1 = pp / v1 . conj ( ) * sampler_info_list [ 0 ] . pulsefac . conj ( ) pt2 = pp / v2 . conj ( ) * sampler_info_list [ 1 ] . pulsefac . conj ( ) pt3 = - pp / v3 . conj ( ) * sampler_info_list [ 2 ] . pulsefac . conj ( ) pt4 = - pp / v4 . conj ( ) * sampler_info_list [ 3 ] . pulsefac . conj ( ) wdiff = gridder ( [ pt1 , pt2 , pt3 , pt4 ] , gridder_info_list ) grad_arr = np . fft . ifftshift ( np . fft . ifft2 ( np . fft . fftshift ( wdiff ) ) ) grad_arr = grad_arr * ( im_info . npad * im_info . npad ) out = np . real ( grad_arr [ im_info . padvalx1 : - im_info . padvalx2 , im_info . padvaly1 : - im_info . padvaly2 ] . flatten ( ) ) return out  def chisq_logamp_fft ( vis_arr , A , amp , sigma ) :      logsigma = sigma / amp im_info , sampler_info_list , gridder_info_list = A amp_samples = np . abs ( sampler ( vis_arr , sampler_info_list , sample_type = <str> ) ) chisq = np . sum ( np . abs ( ( np . log ( amp_samples ) - np . log ( amp ) ) / logsigma ) ** 2 ) / ( len ( amp ) ) return chisq  def chisqgrad_logamp_fft ( vis_arr , A , amp , sigma ) :      im_info , sampler_info_list , gridder_info_list = A samples = sampler ( vis_arr , sampler_info_list , sample_type = <str> ) amp_samples = np . abs ( samples ) logsigma = sigma / amp pulsefac = sampler_info_list [ 0 ] . pulsefac wdiff_vec = ( - 2.0 / len ( amp ) * ( ( np . log ( amp ) - np . log ( amp_samples ) ) ) / ( logsigma ** 2 ) / samples . conj ( ) ) * pulsefac . conj ( ) wdiff_arr = gridder ( [ wdiff_vec ] , gridder_info_list ) grad_arr = np . fft . ifftshift ( np . fft . ifft2 ( np . fft . fftshift ( wdiff_arr ) ) ) grad_arr = grad_arr * ( im_info . npad * im_info . npad ) out = np . real ( grad_arr [ im_info . padvalx1 : - im_info . padvalx2 , im_info . padvaly1 : - im_info . padvaly2 ] . flatten ( ) ) return out  def chisq_vis_nfft ( imvec , A , vis , sigma ) :      nfft_info = A [ 0 ] plan = nfft_info . plan pulsefac = nfft_info . pulsefac plan . f_hat = imvec . copy ( ) . reshape ( ( nfft_info . ydim , nfft_info . xdim ) ) . T plan . trafo ( ) samples = plan . f . copy ( ) * pulsefac chisq = np . sum ( np . abs ( ( samples - vis ) / sigma ) ** 2 ) / ( 2 * len ( vis ) ) return chisq  def chisqgrad_vis_nfft ( imvec , A , vis , sigma ) :      nfft_info = A [ 0 ] plan = nfft_info . plan pulsefac = nfft_info . pulsefac plan . f_hat = imvec . copy ( ) . reshape ( ( nfft_info . ydim , nfft_info . xdim ) ) . T plan . trafo ( ) samples = plan . f . copy ( ) * pulsefac wdiff_vec = ( - 1.0 / len ( vis ) * ( vis - samples ) / ( sigma ** 2 ) ) * pulsefac . conj ( ) plan . f = wdiff_vec plan . adjoint ( ) grad = np . real ( ( plan . f_hat . copy ( ) . T ) . reshape ( nfft_info . xdim * nfft_info . ydim ) ) return grad  def chisq_amp_nfft ( imvec , A , amp , sigma ) :      nfft_info = A [ 0 ] plan = nfft_info . plan pulsefac = nfft_info . pulsefac plan . f_hat = imvec . copy ( ) . reshape ( ( nfft_info . ydim , nfft_info . xdim ) ) . T plan . trafo ( ) samples = plan . f . copy ( ) * pulsefac amp_samples = np . abs ( samples ) chisq = np . sum ( np . abs ( ( amp_samples - amp ) / sigma ) ** 2 ) / ( len ( amp ) ) return chisq  def chisqgrad_amp_nfft ( imvec , A , amp , sigma ) :      nfft_info = A [ 0 ] plan = nfft_info . plan pulsefac = nfft_info . pulsefac plan . f_hat = imvec . copy ( ) . reshape ( ( nfft_info . ydim , nfft_info . xdim ) ) . T plan . trafo ( ) samples = plan . f . copy ( ) * pulsefac amp_samples = np . abs ( samples ) wdiff_vec = ( - 2.0 / len ( amp ) * ( ( amp - amp_samples ) * samples ) / ( sigma ** 2 ) / amp_samples ) * pulsefac . conj ( ) plan . f = wdiff_vec plan . adjoint ( ) out = np . real ( ( plan . f_hat . copy ( ) . T ) . reshape ( nfft_info . xdim * nfft_info . ydim ) ) return out  def chisq_bs_nfft ( imvec , A , bis , sigma ) :      nfft_info1 = A [ 0 ] plan1 = nfft_info1 . plan pulsefac1 = nfft_info1 . pulsefac nfft_info2 = A [ 1 ] plan2 = nfft_info2 . plan pulsefac2 = nfft_info2 . pulsefac nfft_info3 = A [ 2 ] plan3 = nfft_info3 . plan pulsefac3 = nfft_info3 . pulsefac plan1 . f_hat = imvec . copy ( ) . reshape ( ( nfft_info1 . ydim , nfft_info1 . xdim ) ) . T plan1 . trafo ( ) samples1 = plan1 . f . copy ( ) * pulsefac1 plan2 . f_hat = imvec . copy ( ) . reshape ( ( nfft_info2 . ydim , nfft_info2 . xdim ) ) . T plan2 . trafo ( ) samples2 = plan2 . f . copy ( ) * pulsefac2 plan3 . f_hat = imvec . copy ( ) . reshape ( ( nfft_info3 . ydim , nfft_info3 . xdim ) ) . T plan3 . trafo ( ) samples3 = plan3 . f . copy ( ) * pulsefac3 bisamples = samples1 * samples2 * samples3 chisq = np . sum ( np . abs ( ( ( bis - bisamples ) / sigma ) ) ** 2 ) / ( 2. * len ( bis ) ) return chisq  def chisqgrad_bs_nfft ( imvec , A , bis , sigma ) :      nfft_info1 = A [ 0 ] plan1 = nfft_info1 . plan pulsefac1 = nfft_info1 . pulsefac nfft_info2 = A [ 1 ] plan2 = nfft_info2 . plan pulsefac2 = nfft_info2 . pulsefac nfft_info3 = A [ 2 ] plan3 = nfft_info3 . plan pulsefac3 = nfft_info3 . pulsefac plan1 . f_hat = imvec . copy ( ) . reshape ( ( nfft_info1 . ydim , nfft_info1 . xdim ) ) . T plan1 . trafo ( ) v1 = plan1 . f . copy ( ) * pulsefac1 plan2 . f_hat = imvec . copy ( ) . reshape ( ( nfft_info2 . ydim , nfft_info2 . xdim ) ) . T plan2 . trafo ( ) v2 = plan2 . f . copy ( ) * pulsefac2 plan3 . f_hat = imvec . copy ( ) . reshape ( ( nfft_info3 . ydim , nfft_info3 . xdim ) ) . T plan3 . trafo ( ) v3 = plan3 . f . copy ( ) * pulsefac3 bisamples = v1 * v2 * v3 wdiff = - 1.0 / len ( bis ) * ( bis - bisamples ) / ( sigma ** 2 ) pt1 = wdiff * ( v2 * v3 ) . conj ( ) * pulsefac1 . conj ( ) pt2 = wdiff * ( v1 * v3 ) . conj ( ) * pulsefac2 . conj ( ) pt3 = wdiff * ( v1 * v2 ) . conj ( ) * pulsefac3 . conj ( ) plan1 . f = pt1 plan1 . adjoint ( ) out1 = np . real ( ( plan1 . f_hat . copy ( ) . T ) . reshape ( nfft_info1 . xdim * nfft_info1 . ydim ) ) plan2 . f = pt2 plan2 . adjoint ( ) out2 = np . real ( ( plan2 . f_hat . copy ( ) . T ) . reshape ( nfft_info2 . xdim * nfft_info2 . ydim ) ) plan3 . f = pt3 plan3 . adjoint ( ) out3 = np . real ( ( plan3 . f_hat . copy ( ) . T ) . reshape ( nfft_info3 . xdim * nfft_info3 . ydim ) ) out = out1 + out2 + out3 return out  def chisq_cphase_nfft ( imvec , A , clphase , sigma ) :      clphase = clphase * DEGREE sigma = sigma * DEGREE nfft_info1 = A [ 0 ] plan1 = nfft_info1 . plan pulsefac1 = nfft_info1 . pulsefac nfft_info2 = A [ 1 ] plan2 = nfft_info2 . plan pulsefac2 = nfft_info2 . pulsefac nfft_info3 = A [ 2 ] plan3 = nfft_info3 . plan pulsefac3 = nfft_info3 . pulsefac plan1 . f_hat = imvec . copy ( ) . reshape ( ( nfft_info1 . ydim , nfft_info1 . xdim ) ) . T plan1 . trafo ( ) samples1 = plan1 . f . copy ( ) * pulsefac1 plan2 . f_hat = imvec . copy ( ) . reshape ( ( nfft_info2 . ydim , nfft_info2 . xdim ) ) . T plan2 . trafo ( ) samples2 = plan2 . f . copy ( ) * pulsefac2 plan3 . f_hat = imvec . copy ( ) . reshape ( ( nfft_info3 . ydim , nfft_info3 . xdim ) ) . T plan3 . trafo ( ) samples3 = plan3 . f . copy ( ) * pulsefac3 clphase_samples = np . angle ( samples1 * samples2 * samples3 ) chisq = ( 2.0 / len ( clphase ) ) * np . sum ( ( 1.0 - np . cos ( clphase - clphase_samples ) ) / ( sigma ** 2 ) ) return chisq  def chisqgrad_cphase_nfft ( imvec , A , clphase , sigma ) :      clphase = clphase * DEGREE sigma = sigma * DEGREE nfft_info1 = A [ 0 ] plan1 = nfft_info1 . plan pulsefac1 = nfft_info1 . pulsefac nfft_info2 = A [ 1 ] plan2 = nfft_info2 . plan pulsefac2 = nfft_info2 . pulsefac nfft_info3 = A [ 2 ] plan3 = nfft_info3 . plan pulsefac3 = nfft_info3 . pulsefac plan1 . f_hat = imvec . copy ( ) . reshape ( ( nfft_info1 . ydim , nfft_info1 . xdim ) ) . T plan1 . trafo ( ) v1 = plan1 . f . copy ( ) * pulsefac1 plan2 . f_hat = imvec . copy ( ) . reshape ( ( nfft_info2 . ydim , nfft_info2 . xdim ) ) . T plan2 . trafo ( ) v2 = plan2 . f . copy ( ) * pulsefac2 plan3 . f_hat = imvec . copy ( ) . reshape ( ( nfft_info3 . ydim , nfft_info3 . xdim ) ) . T plan3 . trafo ( ) v3 = plan3 . f . copy ( ) * pulsefac3 clphase_samples = np . angle ( v1 * v2 * v3 ) pref = ( 2.0 / len ( clphase ) ) * np . sin ( clphase - clphase_samples ) / ( sigma ** 2 ) pt1 = pref / v1 . conj ( ) * pulsefac1 . conj ( ) pt2 = pref / v2 . conj ( ) * pulsefac2 . conj ( ) pt3 = pref / v3 . conj ( ) * pulsefac3 . conj ( ) plan1 . f = pt1 plan1 . adjoint ( ) out1 = np . imag ( ( plan1 . f_hat . copy ( ) . T ) . reshape ( nfft_info1 . xdim * nfft_info1 . ydim ) ) plan2 . f = pt2 plan2 . adjoint ( ) out2 = np . imag ( ( plan2 . f_hat . copy ( ) . T ) . reshape ( nfft_info2 . xdim * nfft_info2 . ydim ) ) plan3 . f = pt3 plan3 . adjoint ( ) out3 = np . imag ( ( plan3 . f_hat . copy ( ) . T ) . reshape ( nfft_info3 . xdim * nfft_info3 . ydim ) ) out = out1 + out2 + out3 return out  def chisq_camp_nfft ( imvec , A , clamp , sigma ) :      nfft_info1 = A [ 0 ] plan1 = nfft_info1 . plan pulsefac1 = nfft_info1 . pulsefac nfft_info2 = A [ 1 ] plan2 = nfft_info2 . plan pulsefac2 = nfft_info2 . pulsefac nfft_info3 = A [ 2 ] plan3 = nfft_info3 . plan pulsefac3 = nfft_info3 . pulsefac nfft_info4 = A [ 3 ] plan4 = nfft_info4 . plan pulsefac4 = nfft_info4 . pulsefac plan1 . f_hat = imvec . copy ( ) . reshape ( ( nfft_info1 . ydim , nfft_info1 . xdim ) ) . T plan1 . trafo ( ) samples1 = plan1 . f . copy ( ) * pulsefac1 plan2 . f_hat = imvec . copy ( ) . reshape ( ( nfft_info2 . ydim , nfft_info2 . xdim ) ) . T plan2 . trafo ( ) samples2 = plan2 . f . copy ( ) * pulsefac2 plan3 . f_hat = imvec . copy ( ) . reshape ( ( nfft_info3 . ydim , nfft_info3 . xdim ) ) . T plan3 . trafo ( ) samples3 = plan3 . f . copy ( ) * pulsefac3 plan4 . f_hat = imvec . copy ( ) . reshape ( ( nfft_info4 . ydim , nfft_info4 . xdim ) ) . T plan4 . trafo ( ) samples4 = plan4 . f . copy ( ) * pulsefac4 clamp_samples = np . abs ( ( samples1 * samples2 ) / ( samples3 * samples4 ) ) chisq = np . sum ( np . abs ( ( clamp - clamp_samples ) / sigma ) ** 2 ) / len ( clamp ) return chisq  def chisqgrad_camp_nfft ( imvec , A , clamp , sigma ) :      nfft_info1 = A [ 0 ] plan1 = nfft_info1 . plan pulsefac1 = nfft_info1 . pulsefac nfft_info2 = A [ 1 ] plan2 = nfft_info2 . plan pulsefac2 = nfft_info2 . pulsefac nfft_info3 = A [ 2 ] plan3 = nfft_info3 . plan pulsefac3 = nfft_info3 . pulsefac nfft_info4 = A [ 3 ] plan4 = nfft_info4 . plan pulsefac4 = nfft_info4 . pulsefac plan1 . f_hat = imvec . copy ( ) . reshape ( ( nfft_info1 . ydim , nfft_info1 . xdim ) ) . T plan1 . trafo ( ) v1 = plan1 . f . copy ( ) * pulsefac1 plan2 . f_hat = imvec . copy ( ) . reshape ( ( nfft_info2 . ydim , nfft_info2 . xdim ) ) . T plan2 . trafo ( ) v2 = plan2 . f . copy ( ) * pulsefac2 plan3 . f_hat = imvec . copy ( ) . reshape ( ( nfft_info3 . ydim , nfft_info3 . xdim ) ) . T plan3 . trafo ( ) v3 = plan3 . f . copy ( ) * pulsefac3 plan4 . f_hat = imvec . copy ( ) . reshape ( ( nfft_info4 . ydim , nfft_info4 . xdim ) ) . T plan4 . trafo ( ) v4 = plan4 . f . copy ( ) * pulsefac4 clamp_samples = np . abs ( ( v1 * v2 ) / ( v3 * v4 ) ) pp = ( - 2.0 / len ( clamp ) ) * ( ( clamp - clamp_samples ) * clamp_samples ) / ( sigma ** 2 ) pt1 = pp / v1 . conj ( ) * pulsefac1 . conj ( ) pt2 = pp / v2 . conj ( ) * pulsefac2 . conj ( ) pt3 = - pp / v3 . conj ( ) * pulsefac3 . conj ( ) pt4 = - pp / v4 . conj ( ) * pulsefac4 . conj ( ) plan1 . f = pt1 plan1 . adjoint ( ) out1 = np . real ( ( plan1 . f_hat . copy ( ) . T ) . reshape ( nfft_info1 . xdim * nfft_info1 . ydim ) ) plan2 . f = pt2 plan2 . adjoint ( ) out2 = np . real ( ( plan2 . f_hat . copy ( ) . T ) . reshape ( nfft_info2 . xdim * nfft_info2 . ydim ) ) plan3 . f = pt3 plan3 . adjoint ( ) out3 = np . real ( ( plan3 . f_hat . copy ( ) . T ) . reshape ( nfft_info3 . xdim * nfft_info3 . ydim ) ) plan4 . f = pt4 plan4 . adjoint ( ) out4 = np . real ( ( plan4 . f_hat . copy ( ) . T ) . reshape ( nfft_info4 . xdim * nfft_info4 . ydim ) ) out = out1 + out2 + out3 + out4 return out  def chisq_logcamp_nfft ( imvec , A , log_clamp , sigma ) :      nfft_info1 = A [ 0 ] plan1 = nfft_info1 . plan pulsefac1 = nfft_info1 . pulsefac nfft_info2 = A [ 1 ] plan2 = nfft_info2 . plan pulsefac2 = nfft_info2 . pulsefac nfft_info3 = A [ 2 ] plan3 = nfft_info3 . plan pulsefac3 = nfft_info3 . pulsefac nfft_info4 = A [ 3 ] plan4 = nfft_info4 . plan pulsefac4 = nfft_info4 . pulsefac plan1 . f_hat = imvec . copy ( ) . reshape ( ( nfft_info1 . ydim , nfft_info1 . xdim ) ) . T plan1 . trafo ( ) samples1 = plan1 . f . copy ( ) * pulsefac1 plan2 . f_hat = imvec . copy ( ) . reshape ( ( nfft_info2 . ydim , nfft_info2 . xdim ) ) . T plan2 . trafo ( ) samples2 = plan2 . f . copy ( ) * pulsefac2 plan3 . f_hat = imvec . copy ( ) . reshape ( ( nfft_info3 . ydim , nfft_info3 . xdim ) ) . T plan3 . trafo ( ) samples3 = plan3 . f . copy ( ) * pulsefac3 plan4 . f_hat = imvec . copy ( ) . reshape ( ( nfft_info4 . ydim , nfft_info4 . xdim ) ) . T plan4 . trafo ( ) samples4 = plan4 . f . copy ( ) * pulsefac4 log_clamp_samples = ( np . log ( np . abs ( samples1 ) ) + np . log ( np . abs ( samples2 ) ) - np . log ( np . abs ( samples3 ) ) - np . log ( np . abs ( samples4 ) ) ) chisq = np . sum ( np . abs ( ( log_clamp - log_clamp_samples ) / sigma ) ** 2 ) / ( len ( log_clamp ) ) return chisq  def chisqgrad_logcamp_nfft ( imvec , A , log_clamp , sigma ) :      nfft_info1 = A [ 0 ] plan1 = nfft_info1 . plan pulsefac1 = nfft_info1 . pulsefac nfft_info2 = A [ 1 ] plan2 = nfft_info2 . plan pulsefac2 = nfft_info2 . pulsefac nfft_info3 = A [ 2 ] plan3 = nfft_info3 . plan pulsefac3 = nfft_info3 . pulsefac nfft_info4 = A [ 3 ] plan4 = nfft_info4 . plan pulsefac4 = nfft_info4 . pulsefac plan1 . f_hat = imvec . copy ( ) . reshape ( ( nfft_info1 . ydim , nfft_info1 . xdim ) ) . T plan1 . trafo ( ) v1 = plan1 . f . copy ( ) * pulsefac1 plan2 . f_hat = imvec . copy ( ) . reshape ( ( nfft_info2 . ydim , nfft_info2 . xdim ) ) . T plan2 . trafo ( ) v2 = plan2 . f . copy ( ) * pulsefac2 plan3 . f_hat = imvec . copy ( ) . reshape ( ( nfft_info3 . ydim , nfft_info3 . xdim ) ) . T plan3 . trafo ( ) v3 = plan3 . f . copy ( ) * pulsefac3 plan4 . f_hat = imvec . copy ( ) . reshape ( ( nfft_info4 . ydim , nfft_info4 . xdim ) ) . T plan4 . trafo ( ) v4 = plan4 . f . copy ( ) * pulsefac4 log_clamp_samples = np . log ( np . abs ( ( v1 * v2 ) / ( v3 * v4 ) ) ) pp = ( - 2.0 / len ( log_clamp ) ) * ( log_clamp - log_clamp_samples ) / ( sigma ** 2 ) pt1 = pp / v1 . conj ( ) * pulsefac1 . conj ( ) pt2 = pp / v2 . conj ( ) * pulsefac2 . conj ( ) pt3 = - pp / v3 . conj ( ) * pulsefac3 . conj ( ) pt4 = - pp / v4 . conj ( ) * pulsefac4 . conj ( ) plan1 . f = pt1 plan1 . adjoint ( ) out1 = np . real ( ( plan1 . f_hat . copy ( ) . T ) . reshape ( nfft_info1 . xdim * nfft_info1 . ydim ) ) plan2 . f = pt2 plan2 . adjoint ( ) out2 = np . real ( ( plan2 . f_hat . copy ( ) . T ) . reshape ( nfft_info2 . xdim * nfft_info2 . ydim ) ) plan3 . f = pt3 plan3 . adjoint ( ) out3 = np . real ( ( plan3 . f_hat . copy ( ) . T ) . reshape ( nfft_info3 . xdim * nfft_info3 . ydim ) ) plan4 . f = pt4 plan4 . adjoint ( ) out4 = np . real ( ( plan4 . f_hat . copy ( ) . T ) . reshape ( nfft_info4 . xdim * nfft_info4 . ydim ) ) out = out1 + out2 + out3 + out4 return out  def chisq_logamp_nfft ( imvec , A , amp , sigma ) :      nfft_info = A [ 0 ] plan = nfft_info . plan pulsefac = nfft_info . pulsefac plan . f_hat = imvec . copy ( ) . reshape ( ( nfft_info . ydim , nfft_info . xdim ) ) . T plan . trafo ( ) samples = plan . f . copy ( ) * pulsefac logsigma = sigma / amp amp_samples = np . abs ( samples ) chisq = np . sum ( np . abs ( ( np . log ( amp_samples ) - np . log ( amp ) ) / logsigma ) ** 2 ) / ( len ( amp ) ) return chisq  def chisqgrad_logamp_nfft ( imvec , A , amp , sigma ) :      nfft_info = A [ 0 ] plan = nfft_info . plan pulsefac = nfft_info . pulsefac plan . f_hat = imvec . copy ( ) . reshape ( ( nfft_info . ydim , nfft_info . xdim ) ) . T plan . trafo ( ) samples = plan . f . copy ( ) * pulsefac amp_samples = np . abs ( samples ) logsigma = sigma / amp wdiff_vec = ( - 2.0 / len ( amp ) * ( ( np . log ( amp ) - np . log ( amp_samples ) ) ) / ( logsigma ** 2 ) / samples . conj ( ) ) * pulsefac . conj ( ) plan . f = wdiff_vec plan . adjoint ( ) out = np . real ( ( plan . f_hat . copy ( ) . T ) . reshape ( nfft_info . xdim * nfft_info . ydim ) ) return out  def sflux ( imvec , priorvec , flux , norm_reg = NORM_REGULARIZER ) :      if norm_reg : norm = flux ** 2 else : norm = 1 out = - ( np . sum ( imvec ) - flux ) ** 2 return out / norm  def sfluxgrad ( imvec , priorvec , flux , norm_reg = NORM_REGULARIZER ) :      if norm_reg : norm = flux ** 2 else : norm = 1 out = - 2 * ( np . sum ( imvec ) - flux ) return out / norm  def scm ( imvec , nx , ny , psize , flux , embed_mask , norm_reg = NORM_REGULARIZER , beam_size = None ) :      if beam_size is None : beam_size = psize if norm_reg : norm = beam_size ** 2 * flux ** 2 else : norm = 1 xx , yy = np . meshgrid ( range ( nx // 2 , - nx // 2 , - 1 ) , range ( ny // 2 , - ny // 2 , - 1 ) ) xx = psize * xx . flatten ( ) [ embed_mask ] yy = psize * yy . flatten ( ) [ embed_mask ] out = - ( np . sum ( imvec * xx ) ** 2 + np . sum ( imvec * yy ) ** 2 ) return out / norm  def scmgrad ( imvec , nx , ny , psize , flux , embed_mask , norm_reg = NORM_REGULARIZER , beam_size = None ) :      if beam_size is None : beam_size = psize if norm_reg : norm = beam_size ** 2 * flux ** 2 else : norm = 1 xx , yy = np . meshgrid ( range ( nx // 2 , - nx // 2 , - 1 ) , range ( ny // 2 , - ny // 2 , - 1 ) ) xx = psize * xx . flatten ( ) [ embed_mask ] yy = psize * yy . flatten ( ) [ embed_mask ] out = - 2 * ( np . sum ( imvec * xx ) * xx + np . sum ( imvec * yy ) * yy ) return out / norm  def ssimple ( imvec , priorvec , flux , norm_reg = NORM_REGULARIZER ) :      if norm_reg : norm = flux else : norm = 1 entropy = - np . sum ( imvec * np . log ( imvec / priorvec ) ) return entropy / norm  def ssimplegrad ( imvec , priorvec , flux , norm_reg = NORM_REGULARIZER ) :      if norm_reg : norm = flux else : norm = 1 entropygrad = - np . log ( imvec / priorvec ) - 1 return entropygrad / norm  def sl1 ( imvec , priorvec , flux , norm_reg = NORM_REGULARIZER ) :      if norm_reg : norm = flux else : norm = 1 l1 = - np . sum ( np . abs ( imvec ) ) return l1 / norm  def sl1grad ( imvec , priorvec , flux , norm_reg = NORM_REGULARIZER ) :      if norm_reg : norm = flux else : norm = 1 l1grad = - np . sign ( imvec ) return l1grad / norm  def fA ( imvec , I_ref = 1.0 , alpha_A = 1.0 ) :      return 2.0 / np . pi * ( 1.0 + alpha_A ) / alpha_A * np . arctan ( np . pi * alpha_A / 2.0 * np . abs ( imvec ) / I_ref )  def fAgrad ( imvec , I_ref = 1.0 , alpha_A = 1.0 ) :      return ( 1.0 + alpha_A ) / ( I_ref * ( 1.0 + ( np . pi * alpha_A / 2.0 * imvec / I_ref ) ** 2 ) )  def slA ( imvec , priorvec , psize , flux , beam_size = None , alpha_A = 1.0 , norm_reg = NORM_REGULARIZER ) :      if beam_size is None : beam_size = psize I_ref = flux if norm_reg :          norm_l1 = 1.0 norm_l0 = ( beam_size / psize ) ** 2 weight_l1 = 1.0 / ( 1.0 + alpha_A ) weight_l0 = alpha_A norm = ( norm_l1 * weight_l1 + norm_l0 * weight_l0 ) / ( weight_l0 + weight_l1 )  else :          norm = 1  return - np . sum ( fA ( imvec , I_ref , alpha_A ) ) / norm  def slAgrad ( imvec , priorvec , psize , flux , beam_size = None , alpha_A = 1.0 , norm_reg = NORM_REGULARIZER ) :      if beam_size is None : beam_size = psize I_ref = flux if norm_reg :          norm_l1 = 1.0 norm_l0 = ( beam_size / psize ) ** 2 weight_l1 = 1.0 / ( 1.0 + alpha_A ) weight_l0 = alpha_A norm = ( norm_l1 * weight_l1 + norm_l0 * weight_l0 ) / ( weight_l0 + weight_l1 )  else :          norm = 1  return - fAgrad ( imvec , I_ref , alpha_A ) / norm  def sgs ( imvec , priorvec , flux , norm_reg = NORM_REGULARIZER ) :      if norm_reg : norm = flux else : norm = 1 entropy = np . sum ( imvec - priorvec - imvec * np . log ( imvec / priorvec ) ) return entropy / norm  def sgsgrad ( imvec , priorvec , flux , norm_reg = NORM_REGULARIZER ) :      if norm_reg : norm = flux else : norm = 1 entropygrad = - np . log ( imvec / priorvec ) return entropygrad / norm  def stv ( imvec , nx , ny , psize , flux , norm_reg = NORM_REGULARIZER , beam_size = None ) :      if beam_size is None : beam_size = psize if norm_reg : norm = flux * psize / beam_size else : norm = 1 im = imvec . reshape ( ny , nx ) impad = np . pad ( im , 1 , mode = <str> , constant_values = 0 ) im_l1 = np . roll ( impad , - 1 , axis = 0 ) [ 1 : ny + 1 , 1 : nx + 1 ] im_l2 = np . roll ( impad , - 1 , axis = 1 ) [ 1 : ny + 1 , 1 : nx + 1 ] out = - np . sum ( np . sqrt ( np . abs ( im_l1 - im ) ** 2 + np . abs ( im_l2 - im ) ** 2 ) ) return out / norm  def stvgrad ( imvec , nx , ny , psize , flux , norm_reg = NORM_REGULARIZER , beam_size = None ) :      if beam_size is None : beam_size = psize if norm_reg : norm = flux * psize / beam_size else : norm = 1 im = imvec . reshape ( ny , nx ) impad = np . pad ( im , 1 , mode = <str> , constant_values = 0 ) im_l1 = np . roll ( impad , - 1 , axis = 0 ) [ 1 : ny + 1 , 1 : nx + 1 ] im_l2 = np . roll ( impad , - 1 , axis = 1 ) [ 1 : ny + 1 , 1 : nx + 1 ] im_r1 = np . roll ( impad , 1 , axis = 0 ) [ 1 : ny + 1 , 1 : nx + 1 ] im_r2 = np . roll ( impad , 1 , axis = 1 ) [ 1 : ny + 1 , 1 : nx + 1 ] im_r1l2 = np . roll ( np . roll ( impad , 1 , axis = 0 ) , - 1 , axis = 1 ) [ 1 : ny + 1 , 1 : nx + 1 ] im_l1r2 = np . roll ( np . roll ( impad , - 1 , axis = 0 ) , 1 , axis = 1 ) [ 1 : ny + 1 , 1 : nx + 1 ] g1 = ( 2 * im - im_l1 - im_l2 ) / np . sqrt ( ( im - im_l1 ) ** 2 + ( im - im_l2 ) ** 2 ) g2 = ( im - im_r1 ) / np . sqrt ( ( im - im_r1 ) ** 2 + ( im_r1l2 - im_r1 ) ** 2 ) g3 = ( im - im_r2 ) / np . sqrt ( ( im - im_r2 ) ** 2 + ( im_l1r2 - im_r2 ) ** 2 ) mask1 = np . zeros ( im . shape ) mask2 = np . zeros ( im . shape ) mask1 [ 0 , : ] = 1 mask2 [ : , 0 ] = 1 g2 [ mask1 . astype ( bool ) ] = 0 g3 [ mask2 . astype ( bool ) ] = 0 out = - ( g1 + g2 + g3 ) . flatten ( ) return out / norm  def stv2 ( imvec , nx , ny , psize , flux , norm_reg = NORM_REGULARIZER , beam_size = None ) :      if beam_size is None : beam_size = psize if norm_reg : norm = psize ** 4 * flux ** 2 / beam_size ** 4 else : norm = 1 im = imvec . reshape ( ny , nx ) impad = np . pad ( im , 1 , mode = <str> , constant_values = 0 ) im_l1 = np . roll ( impad , - 1 , axis = 0 ) [ 1 : ny + 1 , 1 : nx + 1 ] im_l2 = np . roll ( impad , - 1 , axis = 1 ) [ 1 : ny + 1 , 1 : nx + 1 ] out = - np . sum ( ( im_l1 - im ) ** 2 + ( im_l2 - im ) ** 2 ) return out / norm  def stv2grad ( imvec , nx , ny , psize , flux , norm_reg = NORM_REGULARIZER , beam_size = None ) :      if beam_size is None : beam_size = psize if norm_reg : norm = psize ** 4 * flux ** 2 / beam_size ** 4 else : norm = 1 im = imvec . reshape ( ny , nx ) impad = np . pad ( im , 1 , mode = <str> , constant_values = 0 ) im_l1 = np . roll ( impad , - 1 , axis = 0 ) [ 1 : ny + 1 , 1 : nx + 1 ] im_l2 = np . roll ( impad , - 1 , axis = 1 ) [ 1 : ny + 1 , 1 : nx + 1 ] im_r1 = np . roll ( impad , 1 , axis = 0 ) [ 1 : ny + 1 , 1 : nx + 1 ] im_r2 = np . roll ( impad , 1 , axis = 1 ) [ 1 : ny + 1 , 1 : nx + 1 ] g1 = ( 2 * im - im_l1 - im_l2 ) g2 = ( im - im_r1 ) g3 = ( im - im_r2 ) mask1 = np . zeros ( im . shape ) mask2 = np . zeros ( im . shape ) mask1 [ 0 , : ] = 1 mask2 [ : , 0 ] = 1 g2 [ mask1 . astype ( bool ) ] = 0 g3 [ mask2 . astype ( bool ) ] = 0 out = - 2 * ( g1 + g2 + g3 ) . flatten ( ) return out / norm  def spatch ( imvec , priorvec , flux , norm_reg = NORM_REGULARIZER ) :      if norm_reg : norm = flux ** 2 else : norm = 1 out = - 0.5 * np . sum ( ( imvec - priorvec ) ** 2 ) return out / norm  def spatchgrad ( imvec , priorvec , flux , norm_reg = NORM_REGULARIZER ) :      if norm_reg : norm = flux ** 2 else : norm = 1 out = - ( imvec - priorvec ) return out / norm  def scompact ( imvec , nx , ny , psize , flux , norm_reg = NORM_REGULARIZER , beam_size = None ) :      if beam_size is None : beam_size = psize if norm_reg : norm = flux * ( beam_size ** 2 ) else : norm = 1 im = imvec . reshape ( ny , nx ) xx , yy = np . meshgrid ( range ( nx ) , range ( ny ) ) xx = xx - ( nx - 1 ) / 2.0 yy = yy - ( ny - 1 ) / 2.0 xxpsize = xx * psize yypsize = yy * psize x0 = np . sum ( np . sum ( im * xxpsize ) ) / flux y0 = np . sum ( np . sum ( im * yypsize ) ) / flux out = - np . sum ( np . sum ( im * ( ( xxpsize - x0 ) ** 2 + ( yypsize - y0 ) ** 2 ) ) ) return out / norm  def scompactgrad ( imvec , nx , ny , psize , flux , norm_reg = NORM_REGULARIZER , beam_size = None ) :      if beam_size is None : beam_size = psize if norm_reg : norm = flux * beam_size ** 2 else : norm = 1 im = imvec . reshape ( ny , nx ) xx , yy = np . meshgrid ( range ( nx ) , range ( ny ) ) xx = xx - ( nx - 1 ) / 2.0 yy = yy - ( ny - 1 ) / 2.0 xxpsize = xx * psize yypsize = yy * psize x0 = np . sum ( np . sum ( im * xxpsize ) ) / flux y0 = np . sum ( np . sum ( im * yypsize ) ) / flux term1 = np . sum ( np . sum ( im * ( ( xxpsize - x0 ) ) ) ) term2 = np . sum ( np . sum ( im * ( ( yypsize - y0 ) ) ) ) grad = - 2 * xxpsize * term1 - 2 * yypsize * term2 + ( xxpsize - x0 ) ** 2 + ( yypsize - y0 ) ** 2 return - grad . reshape ( - 1 ) / norm  def scompact2 ( imvec , nx , ny , psize , flux , norm_reg = NORM_REGULARIZER , beam_size = None ) :      if beam_size is None : beam_size = psize if norm_reg : norm = flux ** 2 * beam_size ** 2 else : norm = 1 im = imvec . reshape ( ny , nx ) xx , yy = np . meshgrid ( range ( nx ) , range ( ny ) ) xx = xx - ( nx - 1 ) / 2.0 yy = yy - ( ny - 1 ) / 2.0 xxpsize = xx * psize yypsize = yy * psize out = - np . sum ( np . sum ( im ** 2 * ( xxpsize ** 2 + yypsize ** 2 ) ) ) return out / norm  def scompact2grad ( imvec , nx , ny , psize , flux , norm_reg = NORM_REGULARIZER , beam_size = None ) :      if beam_size is None : beam_size = psize if norm_reg : norm = flux ** 2 * beam_size ** 2 else : norm = 1 im = imvec . reshape ( ny , nx ) xx , yy = np . meshgrid ( range ( nx ) , range ( ny ) ) xx = xx - ( nx - 1 ) / 2.0 yy = yy - ( ny - 1 ) / 2.0 xxpsize = xx * psize yypsize = yy * psize grad = - 2 * im * ( xxpsize ** 2 + yypsize ** 2 ) return grad . reshape ( - 1 ) / norm  def sgauss ( imvec , xdim , ydim , psize , major , minor , PA ) :      phi = PA lambda1 = minor ** 2. / ( 8. * np . log ( 2. ) ) lambda2 = major ** 2. / ( 8. * np . log ( 2. ) ) sigxx_prime = lambda1 * ( np . cos ( phi ) ** 2. ) + lambda2 * ( np . sin ( phi ) ** 2. ) sigyy_prime = lambda1 * ( np . sin ( phi ) ** 2. ) + lambda2 * ( np . cos ( phi ) ** 2. ) sigxy_prime = ( lambda2 - lambda1 ) * np . cos ( phi ) * np . sin ( phi ) pdim = psize im = imvec . reshape ( xdim , ydim ) xlist , ylist = np . meshgrid ( range ( xdim ) , range ( ydim ) ) xlist = xlist - ( xdim - 1 ) / 2.0 ylist = ylist - ( ydim - 1 ) / 2.0 xx = xlist * psize yy = ylist * psize x0 = np . sum ( xx * im ) / np . sum ( im ) y0 = np . sum ( yy * im ) / np . sum ( im ) sigxx = ( np . sum ( ( xx - x0 ) ** 2. * im ) / np . sum ( im ) ) sigyy = ( np . sum ( ( yy - y0 ) ** 2. * im ) / np . sum ( im ) ) sigxy = ( np . sum ( ( xx - x0 ) * ( yy - y0 ) * im ) / np . sum ( im ) ) rgauss = - ( ( sigxx - sigxx_prime ) ** 2. + ( sigyy - sigyy_prime ) ** 2. + 2 * ( sigxy - sigxy_prime ) ** 2. ) rgauss = rgauss / ( major ** 2. * minor ** 2. ) return rgauss  def sgauss_grad ( imvec , xdim , ydim , psize , major , minor , PA ) :      phi = PA lambda1 = ( minor ** 2. ) / ( 8. * np . log ( 2. ) ) lambda2 = ( major ** 2. ) / ( 8. * np . log ( 2. ) ) sigxx_prime = lambda1 * ( np . cos ( phi ) ** 2. ) + lambda2 * ( np . sin ( phi ) ** 2. ) sigyy_prime = lambda1 * ( np . sin ( phi ) ** 2. ) + lambda2 * ( np . cos ( phi ) ** 2. ) sigxy_prime = ( lambda2 - lambda1 ) * np . cos ( phi ) * np . sin ( phi ) pdim = psize im = imvec . reshape ( xdim , ydim ) xlist , ylist = np . meshgrid ( range ( xdim ) , range ( ydim ) ) xlist = xlist - ( xdim - 1 ) / 2.0 ylist = ylist - ( ydim - 1 ) / 2.0 xx = xlist * psize yy = ylist * psize x0 = np . sum ( xx * im ) / np . sum ( im ) y0 = np . sum ( yy * im ) / np . sum ( im ) sigxx = ( np . sum ( ( xx - x0 ) ** 2. * im ) / np . sum ( im ) ) sigyy = ( np . sum ( ( yy - y0 ) ** 2. * im ) / np . sum ( im ) ) sigxy = ( np . sum ( ( xx - x0 ) * ( yy - y0 ) * im ) / np . sum ( im ) ) dx0 = ( xx - x0 ) / np . sum ( im ) dy0 = ( yy - y0 ) / np . sum ( im ) dxx = ( ( ( xx - x0 ) ** 2. - 2. * ( xx - x0 ) * dx0 * im ) - sigxx ) / np . sum ( im ) dyy = ( ( ( yy - y0 ) ** 2. - 2. * ( yy - y0 ) * dx0 * im ) - sigyy ) / np . sum ( im ) dxy = ( ( ( xx - x0 ) * ( yy - y0 ) - ( yy - y0 ) * dx0 * im - ( xx - x0 ) * dy0 * im ) - sigxy ) / np . sum ( im ) drgauss = ( 2. * ( sigxx - sigxx_prime ) * dxx + 2. * ( sigyy - sigyy_prime ) * dyy + 4. * ( sigxy - sigxy_prime ) * dxy ) drgauss = drgauss / ( major ** 2. * minor ** 2. ) return - drgauss . reshape ( - 1 )  def apply_systematic_noise_snrcut ( data_arr , systematic_noise , snrcut , pol ) :      vtype = vis_poldict [ pol ] atype = amp_poldict [ pol ] etype = sig_poldict [ pol ] t1 = data_arr [ <str> ] t2 = data_arr [ <str> ] sigma = data_arr [ etype ] amp = data_arr [ atype ] try :          vis = data_arr [ vtype ]  except ValueError :          vis = amp . astype ( <str> )  snrmask = np . abs ( amp / sigma ) >= snrcut if type ( systematic_noise ) is dict :          sys_level = np . zeros ( len ( t1 ) ) for i in range ( len ( t1 ) ) :              if t1 [ i ] in systematic_noise . keys ( ) :                  t1sys = systematic_noise [ t1 [ i ] ]  else :                  t1sys = 0.  if t2 [ i ] in systematic_noise . keys ( ) :                  t2sys = systematic_noise [ t2 [ i ] ]  else :                  t2sys = 0.  if t1sys < 0 or t2sys < 0 :                  sys_level [ i ] = - 1  else :                  sys_level [ i ] = np . sqrt ( t1sys ** 2 + t2sys ** 2 )    else :          sys_level = np . sqrt ( 2 ) * systematic_noise * np . ones ( len ( t1 ) )  mask = sys_level >= 0. mask = snrmask * mask sigma = np . linalg . norm ( [ sigma , sys_level * np . abs ( amp ) ] , axis = 0 ) [ mask ] vis = vis [ mask ] amp = amp [ mask ] uv = np . hstack ( ( data_arr [ <str> ] . reshape ( - 1 , 1 ) , data_arr [ <str> ] . reshape ( - 1 , 1 ) ) ) [ mask ] return ( uv , vis , amp , sigma )  def chisqdata_vis ( Obsdata , Prior , mask , pol = <str> , ** kwargs ) :      systematic_noise = kwargs . get ( <str> , 0. ) snrcut = kwargs . get ( <str> , 0. ) debias = kwargs . get ( <str> , True ) weighting = kwargs . get ( <str> , <str> ) vtype = vis_poldict [ pol ] atype = amp_poldict [ pol ] etype = sig_poldict [ pol ] data_arr = Obsdata . unpack ( [ <str> , <str> , <str> , <str> , vtype , atype , etype ] , debias = debias ) ( uv , vis , amp , sigma ) = apply_systematic_noise_snrcut ( data_arr , systematic_noise , snrcut , pol ) A = ftmatrix ( Prior . psize , Prior . xdim , Prior . ydim , uv , pulse = Prior . pulse , mask = mask ) return ( vis , sigma , A )  def chisqdata_amp ( Obsdata , Prior , mask , pol = <str> , ** kwargs ) :      systematic_noise = kwargs . get ( <str> , 0. ) snrcut = kwargs . get ( <str> , 0. ) debias = kwargs . get ( <str> , True ) weighting = kwargs . get ( <str> , <str> ) vtype = vis_poldict [ pol ] atype = amp_poldict [ pol ] etype = sig_poldict [ pol ] if ( Obsdata . amp is None ) or ( len ( Obsdata . amp ) == 0 ) or pol != <str> :          data_arr = Obsdata . unpack ( [ <str> , <str> , <str> , <str> , vtype , atype , etype ] , debias = debias )  else :          print ( <str> ) if not type ( Obsdata . amp ) in [ np . ndarray , np . recarray ] :              raise Exception ( <str> )  data_arr = Obsdata . amp  ( uv , vis , amp , sigma ) = apply_systematic_noise_snrcut ( data_arr , systematic_noise , snrcut , pol ) if weighting == <str> :          sigma = np . median ( sigma ) * np . ones ( len ( sigma ) )  A = ftmatrix ( Prior . psize , Prior . xdim , Prior . ydim , uv , pulse = Prior . pulse , mask = mask ) return ( amp , sigma , A )  def chisqdata_bs ( Obsdata , Prior , mask , pol = <str> , ** kwargs ) :      maxset = kwargs . get ( <str> , False ) if maxset : count = <str> else : count = <str> snrcut = kwargs . get ( <str> , 0. ) debias = kwargs . get ( <str> , True ) weighting = kwargs . get ( <str> , <str> ) vtype = vis_poldict [ pol ] if ( Obsdata . bispec is None ) or ( len ( Obsdata . bispec ) == 0 ) or pol != <str> :          biarr = Obsdata . bispectra ( mode = <str> , vtype = vtype , count = count , snrcut = snrcut )  else :          print ( <str> ) if not type ( Obsdata . bispec ) in [ np . ndarray , np . recarray ] :              raise Exception ( <str> )  biarr = Obsdata . bispec if count != <str> :              biarr = reduce_tri_minimal ( Obsdata , biarr )   uv1 = np . hstack ( ( biarr [ <str> ] . reshape ( - 1 , 1 ) , biarr [ <str> ] . reshape ( - 1 , 1 ) ) ) uv2 = np . hstack ( ( biarr [ <str> ] . reshape ( - 1 , 1 ) , biarr [ <str> ] . reshape ( - 1 , 1 ) ) ) uv3 = np . hstack ( ( biarr [ <str> ] . reshape ( - 1 , 1 ) , biarr [ <str> ] . reshape ( - 1 , 1 ) ) ) bi = biarr [ <str> ] sigma = biarr [ <str> ] if weighting == <str> :          sigma = np . median ( sigma ) * np . ones ( len ( sigma ) )  A3 = ( ftmatrix ( Prior . psize , Prior . xdim , Prior . ydim , uv1 , pulse = Prior . pulse , mask = mask ) , ftmatrix ( Prior . psize , Prior . xdim , Prior . ydim , uv2 , pulse = Prior . pulse , mask = mask ) , ftmatrix ( Prior . psize , Prior . xdim , Prior . ydim , uv3 , pulse = Prior . pulse , mask = mask ) ) return ( bi , sigma , A3 )  def chisqdata_cphase ( Obsdata , Prior , mask , pol = <str> , ** kwargs ) :      maxset = kwargs . get ( <str> , False ) uv_min = kwargs . get ( <str> , False ) if maxset : count = <str> else : count = <str> snrcut = kwargs . get ( <str> , 0. ) systematic_cphase_noise = kwargs . get ( <str> , 0. ) weighting = kwargs . get ( <str> , <str> ) vtype = vis_poldict [ pol ] if ( Obsdata . cphase is None ) or ( len ( Obsdata . cphase ) == 0 ) or pol != <str> :          clphasearr = Obsdata . c_phases ( mode = <str> , vtype = vtype , count = count , uv_min = uv_min , snrcut = snrcut )  else :          print ( <str> ) if not type ( Obsdata . cphase ) in [ np . ndarray , np . recarray ] :              raise Exception ( <str> )  clphasearr = Obsdata . cphase if count != <str> :              clphasearr = reduce_tri_minimal ( Obsdata , clphasearr )   uv1 = np . hstack ( ( clphasearr [ <str> ] . reshape ( - 1 , 1 ) , clphasearr [ <str> ] . reshape ( - 1 , 1 ) ) ) uv2 = np . hstack ( ( clphasearr [ <str> ] . reshape ( - 1 , 1 ) , clphasearr [ <str> ] . reshape ( - 1 , 1 ) ) ) uv3 = np . hstack ( ( clphasearr [ <str> ] . reshape ( - 1 , 1 ) , clphasearr [ <str> ] . reshape ( - 1 , 1 ) ) ) clphase = clphasearr [ <str> ] sigma = clphasearr [ <str> ] sigma = np . linalg . norm ( [ sigma , systematic_cphase_noise * np . ones ( len ( sigma ) ) ] , axis = 0 ) if weighting == <str> :          sigma = np . median ( sigma ) * np . ones ( len ( sigma ) )  A3 = ( ftmatrix ( Prior . psize , Prior . xdim , Prior . ydim , uv1 , pulse = Prior . pulse , mask = mask ) , ftmatrix ( Prior . psize , Prior . xdim , Prior . ydim , uv2 , pulse = Prior . pulse , mask = mask ) , ftmatrix ( Prior . psize , Prior . xdim , Prior . ydim , uv3 , pulse = Prior . pulse , mask = mask ) ) return ( clphase , sigma , A3 )  def chisqdata_camp ( Obsdata , Prior , mask , pol = <str> , ** kwargs ) :      maxset = kwargs . get ( <str> , False ) if maxset : count = <str> else : count = <str> snrcut = kwargs . get ( <str> , 0. ) debias = kwargs . get ( <str> , True ) weighting = kwargs . get ( <str> , <str> ) vtype = vis_poldict [ pol ] if ( Obsdata . camp is None ) or ( len ( Obsdata . camp ) == 0 ) or pol != <str> :          clamparr = Obsdata . c_amplitudes ( mode = <str> , count = count , ctype = <str> , debias = debias , snrcut = snrcut )  else :          print ( <str> ) if not type ( Obsdata . camp ) in [ np . ndarray , np . recarray ] :              raise Exception ( <str> )  clamparr = Obsdata . camp if count != <str> :              clamparr = reduce_quad_minimal ( Obsdata , clamparr , ctype = <str> )   uv1 = np . hstack ( ( clamparr [ <str> ] . reshape ( - 1 , 1 ) , clamparr [ <str> ] . reshape ( - 1 , 1 ) ) ) uv2 = np . hstack ( ( clamparr [ <str> ] . reshape ( - 1 , 1 ) , clamparr [ <str> ] . reshape ( - 1 , 1 ) ) ) uv3 = np . hstack ( ( clamparr [ <str> ] . reshape ( - 1 , 1 ) , clamparr [ <str> ] . reshape ( - 1 , 1 ) ) ) uv4 = np . hstack ( ( clamparr [ <str> ] . reshape ( - 1 , 1 ) , clamparr [ <str> ] . reshape ( - 1 , 1 ) ) ) clamp = clamparr [ <str> ] sigma = clamparr [ <str> ] if weighting == <str> :          sigma = np . median ( sigma ) * np . ones ( len ( sigma ) )  A4 = ( ftmatrix ( Prior . psize , Prior . xdim , Prior . ydim , uv1 , pulse = Prior . pulse , mask = mask ) , ftmatrix ( Prior . psize , Prior . xdim , Prior . ydim , uv2 , pulse = Prior . pulse , mask = mask ) , ftmatrix ( Prior . psize , Prior . xdim , Prior . ydim , uv3 , pulse = Prior . pulse , mask = mask ) , ftmatrix ( Prior . psize , Prior . xdim , Prior . ydim , uv4 , pulse = Prior . pulse , mask = mask ) ) return ( clamp , sigma , A4 )  def chisqdata_logcamp ( Obsdata , Prior , mask , pol = <str> , ** kwargs ) :      maxset = kwargs . get ( <str> , False ) if maxset : count = <str> else : count = <str> snrcut = kwargs . get ( <str> , 0. ) debias = kwargs . get ( <str> , True ) weighting = kwargs . get ( <str> , <str> ) vtype = vis_poldict [ pol ] if ( Obsdata . logcamp is None ) or ( len ( Obsdata . logcamp ) == 0 ) or pol != <str> :          clamparr = Obsdata . c_amplitudes ( mode = <str> , count = count , vtype = vtype , ctype = <str> , debias = debias , snrcut = snrcut )  else :          print ( <str> ) if not type ( Obsdata . logcamp ) in [ np . ndarray , np . recarray ] :              raise Exception ( <str> )  clamparr = Obsdata . logcamp if count != <str> :              clamparr = reduce_quad_minimal ( Obsdata , clamparr , ctype = <str> )   uv1 = np . hstack ( ( clamparr [ <str> ] . reshape ( - 1 , 1 ) , clamparr [ <str> ] . reshape ( - 1 , 1 ) ) ) uv2 = np . hstack ( ( clamparr [ <str> ] . reshape ( - 1 , 1 ) , clamparr [ <str> ] . reshape ( - 1 , 1 ) ) ) uv3 = np . hstack ( ( clamparr [ <str> ] . reshape ( - 1 , 1 ) , clamparr [ <str> ] . reshape ( - 1 , 1 ) ) ) uv4 = np . hstack ( ( clamparr [ <str> ] . reshape ( - 1 , 1 ) , clamparr [ <str> ] . reshape ( - 1 , 1 ) ) ) clamp = clamparr [ <str> ] sigma = clamparr [ <str> ] if weighting == <str> :          sigma = np . median ( sigma ) * np . ones ( len ( sigma ) )  A4 = ( ftmatrix ( Prior . psize , Prior . xdim , Prior . ydim , uv1 , pulse = Prior . pulse , mask = mask ) , ftmatrix ( Prior . psize , Prior . xdim , Prior . ydim , uv2 , pulse = Prior . pulse , mask = mask ) , ftmatrix ( Prior . psize , Prior . xdim , Prior . ydim , uv3 , pulse = Prior . pulse , mask = mask ) , ftmatrix ( Prior . psize , Prior . xdim , Prior . ydim , uv4 , pulse = Prior . pulse , mask = mask ) ) return ( clamp , sigma , A4 )  def chisqdata_vis_fft ( Obsdata , Prior , pol = <str> , ** kwargs ) :      systematic_noise = kwargs . get ( <str> , 0. ) snrcut = kwargs . get ( <str> , 0. ) debias = kwargs . get ( <str> , True ) weighting = kwargs . get ( <str> , <str> ) fft_pad_factor = kwargs . get ( <str> , FFT_PAD_DEFAULT ) conv_func = kwargs . get ( <str> , GRIDDER_CONV_FUNC_DEFAULT ) p_rad = kwargs . get ( <str> , GRIDDER_P_RAD_DEFAULT ) order = kwargs . get ( <str> , FFT_INTERP_DEFAULT ) vtype = vis_poldict [ pol ] atype = amp_poldict [ pol ] etype = sig_poldict [ pol ] data_arr = Obsdata . unpack ( [ <str> , <str> , <str> , <str> , vtype , atype , etype ] , debias = debias ) ( uv , vis , amp , sigma ) = apply_systematic_noise_snrcut ( data_arr , systematic_noise , snrcut , pol ) if weighting == <str> :          sigma = np . median ( sigma ) * np . ones ( len ( sigma ) )  npad = int ( fft_pad_factor * np . max ( ( Prior . xdim , Prior . ydim ) ) ) im_info = ImInfo ( Prior . xdim , Prior . ydim , npad , Prior . psize , Prior . pulse ) gs_info = make_gridder_and_sampler_info ( im_info , uv , conv_func = conv_func , p_rad = p_rad , order = order ) sampler_info_list = [ gs_info [ 0 ] ] gridder_info_list = [ gs_info [ 1 ] ] A = ( im_info , sampler_info_list , gridder_info_list ) return ( vis , sigma , A )  def chisqdata_amp_fft ( Obsdata , Prior , pol = <str> , ** kwargs ) :      systematic_noise = kwargs . get ( <str> , 0. ) snrcut = kwargs . get ( <str> , 0. ) debias = kwargs . get ( <str> , True ) weighting = kwargs . get ( <str> , <str> ) fft_pad_factor = kwargs . get ( <str> , FFT_PAD_DEFAULT ) conv_func = kwargs . get ( <str> , GRIDDER_CONV_FUNC_DEFAULT ) p_rad = kwargs . get ( <str> , GRIDDER_P_RAD_DEFAULT ) order = kwargs . get ( <str> , FFT_INTERP_DEFAULT ) vtype = vis_poldict [ pol ] atype = amp_poldict [ pol ] etype = sig_poldict [ pol ] if ( Obsdata . amp is None ) or ( len ( Obsdata . amp ) == 0 ) or pol != <str> :          data_arr = Obsdata . unpack ( [ <str> , <str> , <str> , <str> , vtype , atype , etype ] , debias = debias )  else :          print ( <str> ) if not type ( Obsdata . amp ) in [ np . ndarray , np . recarray ] :              raise Exception ( <str> )  data_arr = Obsdata . amp  ( uv , vis , amp , sigma ) = apply_systematic_noise_snrcut ( data_arr , systematic_noise , snrcut , pol ) if weighting == <str> :          sigma = np . median ( sigma ) * np . ones ( len ( sigma ) )  npad = int ( fft_pad_factor * np . max ( ( Prior . xdim , Prior . ydim ) ) ) im_info = ImInfo ( Prior . xdim , Prior . ydim , npad , Prior . psize , Prior . pulse ) gs_info = make_gridder_and_sampler_info ( im_info , uv , conv_func = conv_func , p_rad = p_rad , order = order ) sampler_info_list = [ gs_info [ 0 ] ] gridder_info_list = [ gs_info [ 1 ] ] A = ( im_info , sampler_info_list , gridder_info_list ) return ( amp , sigma , A )  def chisqdata_bs_fft ( Obsdata , Prior , pol = <str> , ** kwargs ) :      maxset = kwargs . get ( <str> , False ) if maxset : count = <str> else : count = <str> snrcut = kwargs . get ( <str> , 0. ) weighting = kwargs . get ( <str> , <str> ) fft_pad_factor = kwargs . get ( <str> , FFT_PAD_DEFAULT ) conv_func = kwargs . get ( <str> , GRIDDER_CONV_FUNC_DEFAULT ) p_rad = kwargs . get ( <str> , GRIDDER_P_RAD_DEFAULT ) order = kwargs . get ( <str> , FFT_INTERP_DEFAULT ) vtype = vis_poldict [ pol ] if ( Obsdata . bispec is None ) or ( len ( Obsdata . bispec ) == 0 ) or pol != <str> :          biarr = Obsdata . bispectra ( mode = <str> , vtype = vtype , count = count , snrcut = snrcut )  else :          print ( <str> ) if not type ( Obsdata . bispec ) in [ np . ndarray , np . recarray ] :              raise Exception ( <str> )  biarr = Obsdata . bispec if count != <str> :              biarr = reduce_tri_minimal ( Obsdata , biarr )   uv1 = np . hstack ( ( biarr [ <str> ] . reshape ( - 1 , 1 ) , biarr [ <str> ] . reshape ( - 1 , 1 ) ) ) uv2 = np . hstack ( ( biarr [ <str> ] . reshape ( - 1 , 1 ) , biarr [ <str> ] . reshape ( - 1 , 1 ) ) ) uv3 = np . hstack ( ( biarr [ <str> ] . reshape ( - 1 , 1 ) , biarr [ <str> ] . reshape ( - 1 , 1 ) ) ) bi = biarr [ <str> ] sigma = biarr [ <str> ] if weighting == <str> :          sigma = np . median ( sigma ) * np . ones ( len ( sigma ) )  npad = int ( fft_pad_factor * np . max ( ( Prior . xdim , Prior . ydim ) ) ) im_info = ImInfo ( Prior . xdim , Prior . ydim , npad , Prior . psize , Prior . pulse ) gs_info1 = make_gridder_and_sampler_info ( im_info , uv1 , conv_func = conv_func , p_rad = p_rad , order = order ) gs_info2 = make_gridder_and_sampler_info ( im_info , uv2 , conv_func = conv_func , p_rad = p_rad , order = order ) gs_info3 = make_gridder_and_sampler_info ( im_info , uv3 , conv_func = conv_func , p_rad = p_rad , order = order ) sampler_info_list = [ gs_info1 [ 0 ] , gs_info2 [ 0 ] , gs_info3 [ 0 ] ] gridder_info_list = [ gs_info1 [ 1 ] , gs_info2 [ 1 ] , gs_info3 [ 1 ] ] A = ( im_info , sampler_info_list , gridder_info_list ) return ( bi , sigma , A )  def chisqdata_cphase_fft ( Obsdata , Prior , pol = <str> , ** kwargs ) :      maxset = kwargs . get ( <str> , False ) uv_min = kwargs . get ( <str> , False ) if maxset : count = <str> else : count = <str> snrcut = kwargs . get ( <str> , 0. ) weighting = kwargs . get ( <str> , <str> ) systematic_cphase_noise = kwargs . get ( <str> , 0. ) fft_pad_factor = kwargs . get ( <str> , FFT_PAD_DEFAULT ) conv_func = kwargs . get ( <str> , GRIDDER_CONV_FUNC_DEFAULT ) p_rad = kwargs . get ( <str> , GRIDDER_P_RAD_DEFAULT ) order = kwargs . get ( <str> , FFT_INTERP_DEFAULT ) vtype = vis_poldict [ pol ] if ( Obsdata . cphase is None ) or ( len ( Obsdata . cphase ) == 0 ) or pol != <str> :          clphasearr = Obsdata . c_phases ( mode = <str> , vtype = vtype , count = count , uv_min = uv_min , snrcut = snrcut )  else :          print ( <str> ) if not type ( Obsdata . cphase ) in [ np . ndarray , np . recarray ] :              raise Exception ( <str> )  clphasearr = Obsdata . cphase if count != <str> :              clphasearr = reduce_tri_minimal ( Obsdata , clphasearr )   uv1 = np . hstack ( ( clphasearr [ <str> ] . reshape ( - 1 , 1 ) , clphasearr [ <str> ] . reshape ( - 1 , 1 ) ) ) uv2 = np . hstack ( ( clphasearr [ <str> ] . reshape ( - 1 , 1 ) , clphasearr [ <str> ] . reshape ( - 1 , 1 ) ) ) uv3 = np . hstack ( ( clphasearr [ <str> ] . reshape ( - 1 , 1 ) , clphasearr [ <str> ] . reshape ( - 1 , 1 ) ) ) clphase = clphasearr [ <str> ] sigma = clphasearr [ <str> ] sigma = np . linalg . norm ( [ sigma , systematic_cphase_noise * np . ones ( len ( sigma ) ) ] , axis = 0 ) if weighting == <str> :          sigma = np . median ( sigma ) * np . ones ( len ( sigma ) )  npad = int ( fft_pad_factor * np . max ( ( Prior . xdim , Prior . ydim ) ) ) im_info = ImInfo ( Prior . xdim , Prior . ydim , npad , Prior . psize , Prior . pulse ) gs_info1 = make_gridder_and_sampler_info ( im_info , uv1 , conv_func = conv_func , p_rad = p_rad , order = order ) gs_info2 = make_gridder_and_sampler_info ( im_info , uv2 , conv_func = conv_func , p_rad = p_rad , order = order ) gs_info3 = make_gridder_and_sampler_info ( im_info , uv3 , conv_func = conv_func , p_rad = p_rad , order = order ) sampler_info_list = [ gs_info1 [ 0 ] , gs_info2 [ 0 ] , gs_info3 [ 0 ] ] gridder_info_list = [ gs_info1 [ 1 ] , gs_info2 [ 1 ] , gs_info3 [ 1 ] ] A = ( im_info , sampler_info_list , gridder_info_list ) return ( clphase , sigma , A )  def chisqdata_camp_fft ( Obsdata , Prior , pol = <str> , ** kwargs ) :      maxset = kwargs . get ( <str> , False ) if maxset : count = <str> else : count = <str> snrcut = kwargs . get ( <str> , 0. ) debias = kwargs . get ( <str> , True ) weighting = kwargs . get ( <str> , <str> ) fft_pad_factor = kwargs . get ( <str> , FFT_PAD_DEFAULT ) conv_func = kwargs . get ( <str> , GRIDDER_CONV_FUNC_DEFAULT ) p_rad = kwargs . get ( <str> , GRIDDER_P_RAD_DEFAULT ) order = kwargs . get ( <str> , FFT_INTERP_DEFAULT ) vtype = vis_poldict [ pol ] if ( Obsdata . camp is None ) or ( len ( Obsdata . camp ) == 0 ) or pol != <str> :          clamparr = Obsdata . c_amplitudes ( mode = <str> , count = count , ctype = <str> , debias = debias , snrcut = snrcut )  else :          print ( <str> ) if not type ( Obsdata . camp ) in [ np . ndarray , np . recarray ] :              raise Exception ( <str> )  clamparr = Obsdata . camp if count != <str> :              clamparr = reduce_quad_minimal ( Obsdata , clamparr , ctype = <str> )   uv1 = np . hstack ( ( clamparr [ <str> ] . reshape ( - 1 , 1 ) , clamparr [ <str> ] . reshape ( - 1 , 1 ) ) ) uv2 = np . hstack ( ( clamparr [ <str> ] . reshape ( - 1 , 1 ) , clamparr [ <str> ] . reshape ( - 1 , 1 ) ) ) uv3 = np . hstack ( ( clamparr [ <str> ] . reshape ( - 1 , 1 ) , clamparr [ <str> ] . reshape ( - 1 , 1 ) ) ) uv4 = np . hstack ( ( clamparr [ <str> ] . reshape ( - 1 , 1 ) , clamparr [ <str> ] . reshape ( - 1 , 1 ) ) ) clamp = clamparr [ <str> ] sigma = clamparr [ <str> ] if weighting == <str> :          sigma = np . median ( sigma ) * np . ones ( len ( sigma ) )  npad = int ( fft_pad_factor * np . max ( ( Prior . xdim , Prior . ydim ) ) ) im_info = ImInfo ( Prior . xdim , Prior . ydim , npad , Prior . psize , Prior . pulse ) gs_info1 = make_gridder_and_sampler_info ( im_info , uv1 , conv_func = conv_func , p_rad = p_rad , order = order ) gs_info2 = make_gridder_and_sampler_info ( im_info , uv2 , conv_func = conv_func , p_rad = p_rad , order = order ) gs_info3 = make_gridder_and_sampler_info ( im_info , uv3 , conv_func = conv_func , p_rad = p_rad , order = order ) gs_info4 = make_gridder_and_sampler_info ( im_info , uv4 , conv_func = conv_func , p_rad = p_rad , order = order ) sampler_info_list = [ gs_info1 [ 0 ] , gs_info2 [ 0 ] , gs_info3 [ 0 ] , gs_info4 [ 0 ] ] gridder_info_list = [ gs_info1 [ 1 ] , gs_info2 [ 1 ] , gs_info3 [ 1 ] , gs_info4 [ 1 ] ] A = ( im_info , sampler_info_list , gridder_info_list ) return ( clamp , sigma , A )  def chisqdata_logcamp_fft ( Obsdata , Prior , pol = <str> , ** kwargs ) :      maxset = kwargs . get ( <str> , False ) if maxset : count = <str> else : count = <str> snrcut = kwargs . get ( <str> , 0. ) debias = kwargs . get ( <str> , True ) weighting = kwargs . get ( <str> , <str> ) fft_pad_factor = kwargs . get ( <str> , FFT_PAD_DEFAULT ) conv_func = kwargs . get ( <str> , GRIDDER_CONV_FUNC_DEFAULT ) p_rad = kwargs . get ( <str> , GRIDDER_P_RAD_DEFAULT ) order = kwargs . get ( <str> , FFT_INTERP_DEFAULT ) vtype = vis_poldict [ pol ] if ( Obsdata . logcamp is None ) or ( len ( Obsdata . logcamp ) == 0 ) or pol != <str> :          clamparr = Obsdata . c_amplitudes ( mode = <str> , count = count , vtype = vtype , ctype = <str> , debias = debias , snrcut = snrcut )  else :          print ( <str> ) if not type ( Obsdata . logcamp ) in [ np . ndarray , np . recarray ] :              raise Exception ( <str> )  clamparr = Obsdata . logcamp if count != <str> :              clamparr = reduce_quad_minimal ( Obsdata , clamparr , ctype = <str> )   uv1 = np . hstack ( ( clamparr [ <str> ] . reshape ( - 1 , 1 ) , clamparr [ <str> ] . reshape ( - 1 , 1 ) ) ) uv2 = np . hstack ( ( clamparr [ <str> ] . reshape ( - 1 , 1 ) , clamparr [ <str> ] . reshape ( - 1 , 1 ) ) ) uv3 = np . hstack ( ( clamparr [ <str> ] . reshape ( - 1 , 1 ) , clamparr [ <str> ] . reshape ( - 1 , 1 ) ) ) uv4 = np . hstack ( ( clamparr [ <str> ] . reshape ( - 1 , 1 ) , clamparr [ <str> ] . reshape ( - 1 , 1 ) ) ) clamp = clamparr [ <str> ] sigma = clamparr [ <str> ] if weighting == <str> :          sigma = np . median ( sigma ) * np . ones ( len ( sigma ) )  npad = int ( fft_pad_factor * np . max ( ( Prior . xdim , Prior . ydim ) ) ) im_info = ImInfo ( Prior . xdim , Prior . ydim , npad , Prior . psize , Prior . pulse ) gs_info1 = make_gridder_and_sampler_info ( im_info , uv1 , conv_func = conv_func , p_rad = p_rad , order = order ) gs_info2 = make_gridder_and_sampler_info ( im_info , uv2 , conv_func = conv_func , p_rad = p_rad , order = order ) gs_info3 = make_gridder_and_sampler_info ( im_info , uv3 , conv_func = conv_func , p_rad = p_rad , order = order ) gs_info4 = make_gridder_and_sampler_info ( im_info , uv4 , conv_func = conv_func , p_rad = p_rad , order = order ) sampler_info_list = [ gs_info1 [ 0 ] , gs_info2 [ 0 ] , gs_info3 [ 0 ] , gs_info4 [ 0 ] ] gridder_info_list = [ gs_info1 [ 1 ] , gs_info2 [ 1 ] , gs_info3 [ 1 ] , gs_info4 [ 1 ] ] A = ( im_info , sampler_info_list , gridder_info_list ) return ( clamp , sigma , A )  def chisqdata_vis_nfft ( Obsdata , Prior , pol = <str> , ** kwargs ) :      if ( Prior . xdim % 2 or Prior . ydim % 2 ) :          raise Exception ( <str> )  systematic_noise = kwargs . get ( <str> , 0. ) snrcut = kwargs . get ( <str> , 0. ) debias = kwargs . get ( <str> , True ) weighting = kwargs . get ( <str> , <str> ) fft_pad_factor = kwargs . get ( <str> , FFT_PAD_DEFAULT ) p_rad = kwargs . get ( <str> , GRIDDER_P_RAD_DEFAULT ) vtype = vis_poldict [ pol ] atype = amp_poldict [ pol ] etype = sig_poldict [ pol ] data_arr = Obsdata . unpack ( [ <str> , <str> , <str> , <str> , vtype , atype , etype ] , debias = debias ) ( uv , vis , amp , sigma ) = apply_systematic_noise_snrcut ( data_arr , systematic_noise , snrcut , pol ) if weighting == <str> :          sigma = np . median ( sigma ) * np . ones ( len ( sigma ) )  npad = int ( fft_pad_factor * np . max ( ( Prior . xdim , Prior . ydim ) ) ) A1 = NFFTInfo ( Prior . xdim , Prior . ydim , Prior . psize , Prior . pulse , npad , p_rad , uv ) A = [ A1 ] return ( vis , sigma , A )  def chisqdata_amp_nfft ( Obsdata , Prior , pol = <str> , ** kwargs ) :      if ( Prior . xdim % 2 or Prior . ydim % 2 ) :          raise Exception ( <str> )  systematic_noise = kwargs . get ( <str> , 0. ) snrcut = kwargs . get ( <str> , 0. ) debias = kwargs . get ( <str> , True ) weighting = kwargs . get ( <str> , <str> ) fft_pad_factor = kwargs . get ( <str> , FFT_PAD_DEFAULT ) p_rad = kwargs . get ( <str> , GRIDDER_P_RAD_DEFAULT ) vtype = vis_poldict [ pol ] atype = amp_poldict [ pol ] etype = sig_poldict [ pol ] if ( Obsdata . amp is None ) or ( len ( Obsdata . amp ) == 0 ) or pol != <str> :          data_arr = Obsdata . unpack ( [ <str> , <str> , <str> , <str> , vtype , atype , etype ] , debias = debias )  else :          print ( <str> ) if not type ( Obsdata . amp ) in [ np . ndarray , np . recarray ] :              raise Exception ( <str> )  data_arr = Obsdata . amp  ( uv , vis , amp , sigma ) = apply_systematic_noise_snrcut ( data_arr , systematic_noise , snrcut , pol ) if weighting == <str> :          sigma = np . median ( sigma ) * np . ones ( len ( sigma ) )  npad = int ( fft_pad_factor * np . max ( ( Prior . xdim , Prior . ydim ) ) ) A1 = NFFTInfo ( Prior . xdim , Prior . ydim , Prior . psize , Prior . pulse , npad , p_rad , uv ) A = [ A1 ] return ( amp , sigma , A )  def chisqdata_bs_nfft ( Obsdata , Prior , pol = <str> , ** kwargs ) :      if ( Prior . xdim % 2 or Prior . ydim % 2 ) :          raise Exception ( <str> )  maxset = kwargs . get ( <str> , False ) if maxset : count = <str> else : count = <str> snrcut = kwargs . get ( <str> , 0. ) weighting = kwargs . get ( <str> , <str> ) fft_pad_factor = kwargs . get ( <str> , FFT_PAD_DEFAULT ) p_rad = kwargs . get ( <str> , GRIDDER_P_RAD_DEFAULT ) vtype = vis_poldict [ pol ] if ( Obsdata . bispec is None ) or ( len ( Obsdata . bispec ) == 0 ) or pol != <str> :          biarr = Obsdata . bispectra ( mode = <str> , vtype = vtype , count = count , snrcut = snrcut )  else :          print ( <str> ) if not type ( Obsdata . bispec ) in [ np . ndarray , np . recarray ] :              raise Exception ( <str> )  biarr = Obsdata . bispec if count != <str> :              biarr = reduce_tri_minimal ( Obsdata , biarr )   uv1 = np . hstack ( ( biarr [ <str> ] . reshape ( - 1 , 1 ) , biarr [ <str> ] . reshape ( - 1 , 1 ) ) ) uv2 = np . hstack ( ( biarr [ <str> ] . reshape ( - 1 , 1 ) , biarr [ <str> ] . reshape ( - 1 , 1 ) ) ) uv3 = np . hstack ( ( biarr [ <str> ] . reshape ( - 1 , 1 ) , biarr [ <str> ] . reshape ( - 1 , 1 ) ) ) bi = biarr [ <str> ] sigma = biarr [ <str> ] if weighting == <str> :          sigma = np . median ( sigma ) * np . ones ( len ( sigma ) )  npad = int ( fft_pad_factor * np . max ( ( Prior . xdim , Prior . ydim ) ) ) A1 = NFFTInfo ( Prior . xdim , Prior . ydim , Prior . psize , Prior . pulse , npad , p_rad , uv1 ) A2 = NFFTInfo ( Prior . xdim , Prior . ydim , Prior . psize , Prior . pulse , npad , p_rad , uv2 ) A3 = NFFTInfo ( Prior . xdim , Prior . ydim , Prior . psize , Prior . pulse , npad , p_rad , uv3 ) A = [ A1 , A2 , A3 ] return ( bi , sigma , A )  def chisqdata_cphase_nfft ( Obsdata , Prior , pol = <str> , ** kwargs ) :      if ( Prior . xdim % 2 or Prior . ydim % 2 ) :          raise Exception ( <str> )  maxset = kwargs . get ( <str> , False ) uv_min = kwargs . get ( <str> , False ) if maxset : count = <str> else : count = <str> snrcut = kwargs . get ( <str> , 0. ) weighting = kwargs . get ( <str> , <str> ) systematic_cphase_noise = kwargs . get ( <str> , 0. ) fft_pad_factor = kwargs . get ( <str> , FFT_PAD_DEFAULT ) p_rad = kwargs . get ( <str> , GRIDDER_P_RAD_DEFAULT ) vtype = vis_poldict [ pol ] if ( Obsdata . cphase is None ) or ( len ( Obsdata . cphase ) == 0 ) or pol != <str> :          clphasearr = Obsdata . c_phases ( mode = <str> , vtype = vtype , count = count , uv_min = uv_min , snrcut = snrcut )  else :          print ( <str> ) if not type ( Obsdata . cphase ) in [ np . ndarray , np . recarray ] :              raise Exception ( <str> )  clphasearr = Obsdata . cphase if count != <str> :              clphasearr = reduce_tri_minimal ( Obsdata , clphasearr )   uv1 = np . hstack ( ( clphasearr [ <str> ] . reshape ( - 1 , 1 ) , clphasearr [ <str> ] . reshape ( - 1 , 1 ) ) ) uv2 = np . hstack ( ( clphasearr [ <str> ] . reshape ( - 1 , 1 ) , clphasearr [ <str> ] . reshape ( - 1 , 1 ) ) ) uv3 = np . hstack ( ( clphasearr [ <str> ] . reshape ( - 1 , 1 ) , clphasearr [ <str> ] . reshape ( - 1 , 1 ) ) ) clphase = clphasearr [ <str> ] sigma = clphasearr [ <str> ] sigma = np . linalg . norm ( [ sigma , systematic_cphase_noise * np . ones ( len ( sigma ) ) ] , axis = 0 ) if weighting == <str> :          sigma = np . median ( sigma ) * np . ones ( len ( sigma ) )  npad = int ( fft_pad_factor * np . max ( ( Prior . xdim , Prior . ydim ) ) ) A1 = NFFTInfo ( Prior . xdim , Prior . ydim , Prior . psize , Prior . pulse , npad , p_rad , uv1 ) A2 = NFFTInfo ( Prior . xdim , Prior . ydim , Prior . psize , Prior . pulse , npad , p_rad , uv2 ) A3 = NFFTInfo ( Prior . xdim , Prior . ydim , Prior . psize , Prior . pulse , npad , p_rad , uv3 ) A = [ A1 , A2 , A3 ] return ( clphase , sigma , A )  def chisqdata_camp_nfft ( Obsdata , Prior , pol = <str> , ** kwargs ) :      if ( Prior . xdim % 2 or Prior . ydim % 2 ) :          raise Exception ( <str> )  maxset = kwargs . get ( <str> , False ) if maxset : count = <str> else : count = <str> snrcut = kwargs . get ( <str> , 0. ) debias = kwargs . get ( <str> , True ) weighting = kwargs . get ( <str> , <str> ) fft_pad_factor = kwargs . get ( <str> , FFT_PAD_DEFAULT ) p_rad = kwargs . get ( <str> , GRIDDER_P_RAD_DEFAULT ) vtype = vis_poldict [ pol ] if ( Obsdata . camp is None ) or ( len ( Obsdata . camp ) == 0 ) or pol != <str> :          clamparr = Obsdata . c_amplitudes ( mode = <str> , count = count , ctype = <str> , debias = debias , snrcut = snrcut )  else :          print ( <str> ) if not type ( Obsdata . camp ) in [ np . ndarray , np . recarray ] :              raise Exception ( <str> )  clamparr = Obsdata . camp if count != <str> :              clamparr = reduce_quad_minimal ( Obsdata , clamparr , ctype = <str> )   uv1 = np . hstack ( ( clamparr [ <str> ] . reshape ( - 1 , 1 ) , clamparr [ <str> ] . reshape ( - 1 , 1 ) ) ) uv2 = np . hstack ( ( clamparr [ <str> ] . reshape ( - 1 , 1 ) , clamparr [ <str> ] . reshape ( - 1 , 1 ) ) ) uv3 = np . hstack ( ( clamparr [ <str> ] . reshape ( - 1 , 1 ) , clamparr [ <str> ] . reshape ( - 1 , 1 ) ) ) uv4 = np . hstack ( ( clamparr [ <str> ] . reshape ( - 1 , 1 ) , clamparr [ <str> ] . reshape ( - 1 , 1 ) ) ) clamp = clamparr [ <str> ] sigma = clamparr [ <str> ] if weighting == <str> :          sigma = np . median ( sigma ) * np . ones ( len ( sigma ) )  npad = int ( fft_pad_factor * np . max ( ( Prior . xdim , Prior . ydim ) ) ) A1 = NFFTInfo ( Prior . xdim , Prior . ydim , Prior . psize , Prior . pulse , npad , p_rad , uv1 ) A2 = NFFTInfo ( Prior . xdim , Prior . ydim , Prior . psize , Prior . pulse , npad , p_rad , uv2 ) A3 = NFFTInfo ( Prior . xdim , Prior . ydim , Prior . psize , Prior . pulse , npad , p_rad , uv3 ) A4 = NFFTInfo ( Prior . xdim , Prior . ydim , Prior . psize , Prior . pulse , npad , p_rad , uv4 ) A = [ A1 , A2 , A3 , A4 ] return ( clamp , sigma , A )  def chisqdata_logcamp_nfft ( Obsdata , Prior , pol = <str> , ** kwargs ) :      if ( Prior . xdim % 2 or Prior . ydim % 2 ) :          raise Exception ( <str> )  maxset = kwargs . get ( <str> , False ) if maxset : count = <str> else : count = <str> snrcut = kwargs . get ( <str> , 0. ) debias = kwargs . get ( <str> , True ) weighting = kwargs . get ( <str> , <str> ) fft_pad_factor = kwargs . get ( <str> , FFT_PAD_DEFAULT ) p_rad = kwargs . get ( <str> , GRIDDER_P_RAD_DEFAULT ) vtype = vis_poldict [ pol ] if ( Obsdata . logcamp is None ) or ( len ( Obsdata . logcamp ) == 0 ) or pol != <str> :          clamparr = Obsdata . c_amplitudes ( mode = <str> , count = count , vtype = vtype , ctype = <str> , debias = debias , snrcut = snrcut )  else :          print ( <str> ) if not type ( Obsdata . logcamp ) in [ np . ndarray , np . recarray ] :              raise Exception ( <str> )  clamparr = Obsdata . logcamp if count != <str> :              clamparr = reduce_quad_minimal ( Obsdata , clamparr , ctype = <str> )   uv1 = np . hstack ( ( clamparr [ <str> ] . reshape ( - 1 , 1 ) , clamparr [ <str> ] . reshape ( - 1 , 1 ) ) ) uv2 = np . hstack ( ( clamparr [ <str> ] . reshape ( - 1 , 1 ) , clamparr [ <str> ] . reshape ( - 1 , 1 ) ) ) uv3 = np . hstack ( ( clamparr [ <str> ] . reshape ( - 1 , 1 ) , clamparr [ <str> ] . reshape ( - 1 , 1 ) ) ) uv4 = np . hstack ( ( clamparr [ <str> ] . reshape ( - 1 , 1 ) , clamparr [ <str> ] . reshape ( - 1 , 1 ) ) ) clamp = clamparr [ <str> ] sigma = clamparr [ <str> ] if weighting == <str> :          sigma = np . median ( sigma ) * np . ones ( len ( sigma ) )  npad = int ( fft_pad_factor * np . max ( ( Prior . xdim , Prior . ydim ) ) ) A1 = NFFTInfo ( Prior . xdim , Prior . ydim , Prior . psize , Prior . pulse , npad , p_rad , uv1 ) A2 = NFFTInfo ( Prior . xdim , Prior . ydim , Prior . psize , Prior . pulse , npad , p_rad , uv2 ) A3 = NFFTInfo ( Prior . xdim , Prior . ydim , Prior . psize , Prior . pulse , npad , p_rad , uv3 ) A4 = NFFTInfo ( Prior . xdim , Prior . ydim , Prior . psize , Prior . pulse , npad , p_rad , uv4 ) A = [ A1 , A2 , A3 , A4 ] return ( clamp , sigma , A )  def plot_i ( im , Prior , nit , chi2_dict , ** kwargs ) :      cmap = kwargs . get ( <str> , <str> ) interpolation = kwargs . get ( <str> , <str> ) pol = kwargs . get ( <str> , <str> ) scale = kwargs . get ( <str> , None ) dynamic_range = kwargs . get ( <str> , 1.e5 ) gamma = kwargs . get ( <str> , .5 ) plt . ion ( ) plt . pause ( 1.e-6 ) plt . clf ( ) imarr = im . reshape ( Prior . ydim , Prior . xdim ) if scale == <str> :          if ( imarr < 0.0 ) . any ( ) :              print ( <str> ) imarr [ imarr < 0.0 ] = 0.0  imarr = np . log ( imarr + np . max ( imarr ) / dynamic_range )  if scale == <str> :          if ( imarr < 0.0 ) . any ( ) :              print ( <str> ) imarr [ imarr < 0.0 ] = 0.0  imarr = ( imarr + np . max ( imarr ) / dynamic_range ) ** ( gamma )  plt . imshow ( imarr , cmap = plt . get_cmap ( cmap ) , interpolation = interpolation ) xticks = ticks ( Prior . xdim , Prior . psize / RADPERAS / 1e-6 ) yticks = ticks ( Prior . ydim , Prior . psize / RADPERAS / 1e-6 ) plt . xticks ( xticks [ 0 ] , xticks [ 1 ] ) plt . yticks ( yticks [ 0 ] , yticks [ 1 ] ) plt . xlabel ( <str> ) plt . ylabel ( <str> ) plotstr = str ( pol ) + <str> % nit for key in chi2_dict . keys ( ) :          plotstr += <str> % ( key , chi2_dict [ key ] )  plt . title ( plotstr , fontsize = 18 )  def embed ( im , mask , clipfloor = 0. , randomfloor = False ) :      out = np . zeros ( len ( mask ) ) out [ mask . nonzero ( ) ] = im if clipfloor != 0.0 :          if randomfloor :              out [ ( mask - 1 ) . nonzero ( ) ] = clipfloor * np . abs ( np . random . normal ( size = len ( ( mask - 1 ) . nonzero ( ) ) ) )  else :              out [ ( mask - 1 ) . nonzero ( ) ] = clipfloor   return out   