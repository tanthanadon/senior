from __future__ import division from __future__ import print_function from builtins import str from builtins import range from builtins import object import string , copy import numpy as np import numpy . lib . recfunctions as rec import matplotlib . pyplot as plt import scipy . optimize as opt import itertools as it import sys , os import ehtim . image import ehtim . observing . obs_simulate import ehtim . io . save import ehtim . io . load from ehtim . const_def import * from ehtim . observing . obs_helpers import * import scipy class Caltable ( object ) :      def __init__ ( self , ra , dec , rf , bw , datadict , tarr , source = SOURCE_DEFAULT , mjd = MJD_DEFAULT , timetype = <str> ) :          self . source = str ( source ) self . ra = float ( ra ) self . dec = float ( dec ) self . rf = float ( rf ) self . bw = float ( bw ) self . mjd = int ( mjd ) if timetype not in [ <str> , <str> ] :              raise Exception ( <str> )  self . timetype = timetype self . tarr = tarr self . tkey = { self . tarr [ i ] [ <str> ] : i for i in range ( len ( self . tarr ) ) } self . data = datadict  def copy ( self ) :          new_caltable = Caltable ( self . ra , self . dec , self . rf , self . bw , self . data , self . tarr , source = self . source , mjd = self . mjd , timetype = self . timetype ) return new_caltable  def plot_dterms ( self , sites = <str> , label = None , legend = True , clist = SCOLORS , rangex = False , rangey = False , markersize = 2 * MARKERSIZE , show = True , grid = True , export_pdf = <str> ) :          if sites in [ <str> or <str> ] or sites == [ ] :              sites = list ( self . data . keys ( ) )  if not type ( sites ) is list :              sites = [ sites ]  keys = [ self . tkey [ site ] for site in sites ] axes = plot_tarr_dterms ( self . tarr , keys = keys , label = label , legend = legend , clist = clist , rangex = rangex , rangey = rangey , markersize = markersize , show = show , grid = grid , export_pdf = export_pdf ) return axes  def plot_gains ( self , sites , gain_type = <str> , pol = <str> , label = None , ang_unit = <str> , timetype = False , yscale = <str> , legend = True , clist = SCOLORS , rangex = False , rangey = False , markersize = [ MARKERSIZE ] , show = True , grid = False , axislabels = True , axis = False , export_pdf = <str> ) :          colors = iter ( clist ) if timetype == False :              timetype = self . timetype  if timetype not in [ <str> , <str> , <str> , <str> ] :              raise Exception ( <str> )  if gain_type not in [ <str> , <str> ] :              raise Exception ( <str> )  if pol not in [ <str> , <str> , <str> ] :              raise Exception ( <str> )  if ang_unit == <str> : angle = DEGREE else : angle = 1.0 if axis :              x = axis  else :              fig = plt . figure ( ) x = fig . add_subplot ( 1 , 1 , 1 )  if sites in [ <str> or <str> ] or sites == [ ] :              sites = sorted ( list ( self . data . keys ( ) ) )  if not type ( sites ) is list :              sites = [ sites ]  if len ( markersize ) == 1 :              markersize = markersize * np . ones ( len ( sites ) )  tmins = tmaxes = gmins = gmaxes = [ ] for s in range ( len ( sites ) ) :              site = sites [ s ] times = self . data [ site ] [ <str> ] if timetype in [ <str> , <str> ] and self . timetype == <str> :                  times = gmst_to_utc ( times , self . mjd )  elif timetype in [ <str> , <str> ] and self . timetype == <str> :                  times = utc_to_gmst ( times , self . mjd )  if pol == <str> :                  gains = self . data [ site ] [ <str> ]  elif pol == <str> :                  gains = self . data [ site ] [ <str> ]  if gain_type == <str> :                  gains = np . abs ( gains ) ylabel = <str>  if gain_type == <str> :                  gains = np . angle ( gains ) / angle if ang_unit == <str> : ylabel = <str> else : ylabel = <str>  tmins . append ( np . min ( times ) ) tmaxes . append ( np . max ( times ) ) gmins . append ( np . min ( gains ) ) gmaxes . append ( np . max ( gains ) ) if label is None :                  bllabel = str ( site )  else :                  bllabel = label + <str> + str ( site )  plt . plot ( times , gains , color = next ( colors ) , marker = <str> , markersize = markersize [ s ] , label = bllabel , linestyle = <str> )  if not rangex :              rangex = [ np . min ( tmins ) - 0.2 * np . abs ( np . min ( tmins ) ) , np . max ( tmaxes ) + 0.2 * np . abs ( np . max ( tmaxes ) ) ] if np . any ( np . isnan ( np . array ( rangex ) ) ) :                  print ( <str> ) rangex = [ 0 , 24 ]   if not rangey :              rangey = [ np . min ( gmins ) - 0.2 * np . abs ( np . min ( gmins ) ) , np . max ( gmaxes ) + 0.2 * np . abs ( np . max ( gmaxes ) ) ] if np . any ( np . isnan ( np . array ( rangey ) ) ) :                  print ( <str> ) rangey = [ 1.e-2 , 1.e2 ]   plt . plot ( np . linspace ( rangex [ 0 ] , rangex [ 1 ] , 5 ) , np . ones ( 5 ) , <str> ) x . set_xlim ( rangex ) x . set_ylim ( rangey ) if axislabels :              x . set_xlabel ( self . timetype + <str> ) x . set_ylabel ( ylabel ) plt . title ( <str> % ( self . source , self . mjd ) )  if legend :              plt . legend ( )  if yscale == <str> :              x . set_yscale ( <str> )  if grid :              x . grid ( )  if export_pdf != <str> and not axis :              fig . savefig ( export_pdf , bbox_inches = <str> )  if show :              plt . show ( block = False )  return x  def enforce_positive ( self , method = <str> , min_gain = 0.9 , sites = [ ] , verbose = True ) :          if len ( sites ) == 0 :              sites = self . data . keys ( )  caltab_pos = self . copy ( ) for site in self . data . keys ( ) :              if not site in sites : continue if len ( self . data [ site ] [ <str> ] ) == 0 : continue if method == <str> :                  sitemin = np . min ( [ np . abs ( self . data [ site ] [ <str> ] ) , np . abs ( self . data [ site ] [ <str> ] ) ] )  elif method == <str> :                  sitemin = np . mean ( [ np . abs ( self . data [ site ] [ <str> ] ) , np . abs ( self . data [ site ] [ <str> ] ) ] )  elif method == <str> :                  sitemin = np . median ( [ np . abs ( self . data [ site ] [ <str> ] ) , np . abs ( self . data [ site ] [ <str> ] ) ] )  else :                  print ( <str> + method + <str> ) return caltab_pos  if sitemin < min_gain :                  if verbose : print ( method + <str> + site + <str> + str ( sitemin ) + <str> ) caltab_pos . data [ site ] [ <str> ] /= sitemin caltab_pos . data [ site ] [ <str> ] /= sitemin  else :                  if verbose : print ( method + <str> + site + <str> + str ( sitemin ) + <str> )   return caltab_pos  def pad_scans ( self , maxdiff = 60 , padtype = <str> ) :          import copy outdict = { } scopes = list ( self . data . keys ( ) ) for scope in scopes :              if np . any ( self . data [ scope ] is None ) or len ( self . data [ scope ] ) == 0 :                  continue  caldata = copy . deepcopy ( self . data [ scope ] ) gathered_data = [ ] scandata = [ caldata [ 0 ] ] for i in range ( 1 , len ( caldata ) ) :                  if ( caldata [ i ] [ <str> ] - caldata [ i - 1 ] [ <str> ] ) * 3600 > maxdiff :                      scandata = np . array ( scandata , dtype = DTCAL ) gathered_data . append ( scandata ) scandata = [ caldata [ i ] ]  else :                      scandata . append ( caldata [ i ] )   scandata = np . array ( scandata ) gathered_data . append ( scandata ) for i in range ( len ( gathered_data ) ) :                  gg = gathered_data [ i ] medR = np . median ( gg [ <str> ] ) medL = np . median ( gg [ <str> ] ) timepre = gg [ <str> ] [ 0 ] - maxdiff / 2. / 3600. timepost = gg [ <str> ] [ - 1 ] + maxdiff / 2. / 3600. if padtype == <str> :                      medR = np . median ( gg [ <str> ] ) medL = np . median ( gg [ <str> ] ) preR = medR postR = medR preL = medL postL = medL  elif padtype == <str> :                      preR = gg [ <str> ] [ 0 ] postR = gg [ <str> ] [ - 1 ] preL = gg [ <str> ] [ 0 ] postL = gg [ <str> ] [ - 1 ]  else :                      preR = 1. postR = 1. preL = 1. postL = 1.  valspre = np . array ( [ ( timepre , preR , preL ) ] , dtype = DTCAL ) valspost = np . array ( [ ( timepost , postR , postL ) ] , dtype = DTCAL ) gg = np . insert ( gg , 0 , valspre ) gg = np . append ( gg , valspost ) if i == 0 :                      caldata_out = gg  else :                      caldata_out = np . append ( caldata_out , gg )   try :                  caldata_out  except NameError :                  print ( <str> )  else :                  outdict [ scope ] = caldata_out   return Caltable ( self . ra , self . dec , self . rf , self . bw , outdict , self . tarr , source = self . source , mjd = self . mjd , timetype = self . timetype )  def applycal ( self , obs , interp = <str> , extrapolate = None , force_singlepol = False , copy_closure_tables = True ) :          if not ( self . tarr == obs . tarr ) . all ( ) :              raise Exception ( <str> )  if extrapolate is True :              fill_value = <str>  else :              fill_value = extrapolate  obs_orig = obs . copy ( ) orig_polrep = obs . polrep obs = obs . switch_polrep ( <str> ) rinterp = { } linterp = { } skipsites = [ ] for s in range ( 0 , len ( self . tarr ) ) :              site = self . tarr [ s ] [ <str> ] try :                  self . data [ site ]  except KeyError :                  skipsites . append ( site ) print ( <str> % site ) continue  time_mjd = self . data [ site ] [ <str> ] / 24.0 + self . mjd rinterp [ site ] = relaxed_interp1d ( time_mjd , self . data [ site ] [ <str> ] , kind = interp , fill_value = fill_value , bounds_error = False ) linterp [ site ] = relaxed_interp1d ( time_mjd , self . data [ site ] [ <str> ] , kind = interp , fill_value = fill_value , bounds_error = False )  bllist = obs . bllist ( ) datatable = [ ] for bl_obs in bllist :              t1 = bl_obs [ <str> ] [ 0 ] t2 = bl_obs [ <str> ] [ 0 ] time_mjd = bl_obs [ <str> ] / 24.0 + obs . mjd if t1 in skipsites :                  rscale1 = lscale1 = np . array ( 1. )  else :                  rscale1 = rinterp [ t1 ] ( time_mjd ) lscale1 = linterp [ t1 ] ( time_mjd )  if t2 in skipsites :                  rscale2 = lscale2 = np . array ( 1. )  else :                  rscale2 = rinterp [ t2 ] ( time_mjd ) lscale2 = linterp [ t2 ] ( time_mjd )  if force_singlepol == <str> :                  lscale1 = rscale1 lscale2 = rscale2  if force_singlepol == <str> :                  rscale1 = lscale1 rscale2 = lscale2  rrscale = rscale1 * rscale2 . conj ( ) llscale = lscale1 * lscale2 . conj ( ) rlscale = rscale1 * lscale2 . conj ( ) lrscale = lscale1 * rscale2 . conj ( ) bl_obs [ <str> ] = ( bl_obs [ <str> ] ) * rrscale bl_obs [ <str> ] = ( bl_obs [ <str> ] ) * llscale bl_obs [ <str> ] = ( bl_obs [ <str> ] ) * rlscale bl_obs [ <str> ] = ( bl_obs [ <str> ] ) * lrscale bl_obs [ <str> ] = bl_obs [ <str> ] * np . abs ( rrscale ) bl_obs [ <str> ] = bl_obs [ <str> ] * np . abs ( llscale ) bl_obs [ <str> ] = bl_obs [ <str> ] * np . abs ( rlscale ) bl_obs [ <str> ] = bl_obs [ <str> ] * np . abs ( lrscale ) if len ( datatable ) :                  datatable = np . hstack ( ( datatable , bl_obs ) )  else :                  datatable = bl_obs   calobs = ehtim . obsdata . Obsdata ( obs . ra , obs . dec , obs . rf , obs . bw , np . array ( datatable ) , obs . tarr , polrep = obs . polrep , scantable = obs . scans , source = obs . source , mjd = obs . mjd , ampcal = obs . ampcal , phasecal = obs . phasecal , opacitycal = obs . opacitycal , dcal = obs . dcal , frcal = obs . frcal , timetype = obs . timetype ) calobs = calobs . switch_polrep ( orig_polrep ) if copy_closure_tables :              calobs . camp = obs_orig . camp calobs . logcamp = obs_orig . logcamp calobs . cphase = obs_orig . cphase  return calobs  def merge ( self , caltablelist , interp = <str> , extrapolate = 1 ) :          if extrapolate is True :              fill_value = <str>  else :              fill_value = extrapolate  try :              x = caltablelist . __iter__  except AttributeError : caltablelist = [ caltablelist ] tarr1 = self . tarr . copy ( ) tkey1 = self . tkey . copy ( ) data1 = self . data . copy ( ) for caltable in caltablelist :              tarr2 = caltable . tarr . copy ( ) tkey2 = caltable . tkey . copy ( ) data2 = caltable . data . copy ( ) sites2 = list ( data2 . keys ( ) ) sites1 = list ( data1 . keys ( ) ) for site in sites2 :                  if site in sites1 :                      time1 = data1 [ site ] [ <str> ] time2 = data2 [ site ] [ <str> ] rinterp1 = relaxed_interp1d ( time1 , data1 [ site ] [ <str> ] , kind = interp , fill_value = fill_value , bounds_error = False ) linterp1 = relaxed_interp1d ( time1 , data1 [ site ] [ <str> ] , kind = interp , fill_value = fill_value , bounds_error = False ) rinterp2 = relaxed_interp1d ( time2 , data2 [ site ] [ <str> ] , kind = interp , fill_value = fill_value , bounds_error = False ) linterp2 = relaxed_interp1d ( time2 , data2 [ site ] [ <str> ] , kind = interp , fill_value = fill_value , bounds_error = False ) times_merge = np . unique ( np . hstack ( ( time1 , time2 ) ) ) rscale_merge = rinterp1 ( times_merge ) * rinterp2 ( times_merge ) lscale_merge = linterp1 ( times_merge ) * linterp2 ( times_merge ) datatable = [ ] for i in range ( len ( times_merge ) ) :                          datatable . append ( np . array ( ( times_merge [ i ] , rscale_merge [ i ] , lscale_merge [ i ] ) , dtype = DTCAL ) )  data1 [ site ] = np . array ( datatable )  else :                      if site not in tkey1 . keys ( ) :                          tarr1 = np . append ( tarr1 , tarr2 [ tkey2 [ site ] ] )  data1 [ site ] = data2 [ site ]   tkey1 = { tarr1 [ i ] [ <str> ] : i for i in range ( len ( tarr1 ) ) }  new_caltable = Caltable ( self . ra , self . dec , self . rf , self . bw , data1 , tarr1 , source = self . source , mjd = self . mjd , timetype = self . timetype ) return new_caltable  def save_txt ( self , obs , datadir = <str> , sqrt_gains = False ) :          return save_caltable ( self , obs , datadir = datadir , sqrt_gains = sqrt_gains )  def scan_avg ( self , obs , incoherent = True ) :          sites = self . data . keys ( ) ntele = len ( sites ) datatables = { } for s in range ( 0 , ntele ) :              site = sites [ s ] times = self . data [ site ] [ <str> ] times_stable = times . copy ( ) obs . add_scans ( ) scans = obs . scans for j in range ( len ( times_stable ) ) :                  for scan in scans :                      if scan [ 0 ] <= times_stable [ j ] and scan [ 1 ] >= times_stable [ j ] :                          times_stable [ j ] = scan [ 0 ] break    datatable = [ ] for scan in scans :                  gains_l = self . data [ site ] [ <str> ] gains_r = self . data [ site ] [ <str> ] if incoherent :                      gains_l = np . abs ( gains_l ) gains_r = np . abs ( gains_r )  gains_l_avg = np . mean ( gains_l [ np . array ( times_stable == scan [ 0 ] ) ] ) gains_r_avg = np . mean ( gains_r [ np . array ( times_stable == scan [ 0 ] ) ] ) datatable . append ( np . array ( ( scan [ 0 ] , gains_r_avg , gains_l_avg ) , dtype = DTCAL ) )  datatables [ site ] = np . array ( datatable )  if len ( datatables ) > 0 :              caltable = Caltable ( obs . ra , obs . dec , obs . rf , obs . bw , datatables , obs . tarr , source = obs . source , mjd = obs . mjd , timetype = obs . timetype )  else :              caltable = False  return caltable  def invert_gains ( self ) :          sites = self . data . keys ( ) ntele = len ( sites ) for s in range ( 0 , ntele ) :              site = sites [ s ] self . data [ site ] [ <str> ] = 1 / self . data [ site ] [ <str> ] self . data [ site ] [ <str> ] = 1 / self . data [ site ] [ <str> ]  return self   def load_caltable ( obs , datadir , sqrt_gains = False ) :      tarr = obs . tarr array_filename = datadir + <str> if os . path . exists ( array_filename ) :          tarr = ehtim . io . load . load_array_txt ( array_filename ) . tarr  datatables = { } for s in range ( 0 , len ( tarr ) ) :          site = tarr [ s ] [ <str> ] filename = datadir + obs . source + <str> + site + <str> try :              data = np . loadtxt ( filename , dtype = bytes ) . astype ( str )  except IOError :              continue  datatable = [ ] for row in data :              time = ( float ( row [ 0 ] ) - obs . mjd ) * 24.0 if len ( row ) == 3 :                  rscale = float ( row [ 1 ] ) lscale = float ( row [ 2 ] )  elif len ( row ) == 5 :                  rscale = float ( row [ 1 ] ) + 1j * float ( row [ 2 ] ) lscale = float ( row [ 3 ] ) + 1j * float ( row [ 4 ] )  else :                  raise Exception ( <str> )  if sqrt_gains :                  rscale = rscale ** .5 lscale = lscale ** .5  datatable . append ( np . array ( ( time , rscale , lscale ) , dtype = DTCAL ) )  datatables [ site ] = np . array ( datatable )  if len ( datatables ) > 0 :          caltable = Caltable ( obs . ra , obs . dec , obs . rf , obs . bw , datatables , tarr , source = obs . source , mjd = obs . mjd , timetype = obs . timetype )  else :          print ( <str> % datadir ) caltable = False  return caltable  def save_caltable ( caltable , obs , datadir = <str> , sqrt_gains = False ) :      if not os . path . exists ( datadir ) :          os . makedirs ( datadir )  ehtim . io . save . save_array_txt ( obs . tarr , datadir + <str> ) datatables = caltable . data src = caltable . source for site_info in caltable . tarr :          site = site_info [ <str> ] if len ( datatables . get ( site , [ ] ) ) == 0 :              continue  filename = datadir + <str> + src + <str> + site + <str> outfile = open ( filename , <str> ) site_data = datatables [ site ] for entry in site_data :              time = entry [ <str> ] / 24.0 + obs . mjd if sqrt_gains :                  rscale = np . square ( entry [ <str> ] ) lscale = np . square ( entry [ <str> ] )  else :                  rscale = entry [ <str> ] lscale = entry [ <str> ]  rreal = float ( np . real ( rscale ) ) rimag = float ( np . imag ( rscale ) ) lreal = float ( np . real ( lscale ) ) limag = float ( np . imag ( lscale ) ) outline = str ( float ( time ) ) + <str> + str ( float ( rreal ) ) + <str> + str ( float ( rimag ) ) + <str> + str ( float ( lreal ) ) + <str> + str ( float ( limag ) ) + <str> outfile . write ( outline )  outfile . close ( )  return  def make_caltable ( obs , gains , sites , times ) :      ntele = len ( sites ) ntimes = len ( times ) datatables = { } for s in range ( 0 , ntele ) :          datatable = [ ] for t in range ( 0 , ntimes ) :              gain = gains [ s * ntele + t ] datatable . append ( np . array ( ( times [ t ] , gain , gain ) , dtype = DTCAL ) )  datatables [ sites [ s ] ] = np . array ( datatable )  if len ( datatables ) > 0 :          caltable = Caltable ( obs . ra , obs . dec , obs . rf , obs . bw , datatables , obs . tarr , source = obs . source , mjd = obs . mjd , timetype = obs . timetype )  else :          caltable = False  return caltable  def relaxed_interp1d ( x , y , ** kwargs ) :      if len ( x ) == 1 :          x = np . array ( [ - 0.5 , 0.5 ] ) + x [ 0 ] y = np . array ( [ 1.0 , 1.0 ] ) * y [ 0 ]  return scipy . interpolate . interp1d ( x , y , ** kwargs )  def plot_tarr_dterms ( tarr , keys = None , label = None , legend = True , clist = SCOLORS , rangex = False , rangey = False , markersize = 2 * MARKERSIZE , show = True , grid = True , export_pdf = <str> , auto_order = True ) :      if auto_order :          keys = np . argsort ( tarr [ <str> ] )  else :          keys = range ( len ( tarr ) )  colors = iter ( clist ) if export_pdf != <str> :          fig , axes = plt . subplots ( nrows = 1 , ncols = 2 , sharey = True , sharex = True , figsize = ( 16 , 8 ) )  else :          fig , axes = plt . subplots ( nrows = 1 , ncols = 2 , sharey = True , sharex = True )  for key in keys :          site = str ( tarr [ key ] [ <str> ] ) if label is None :              bllabel = str ( site )  else :              bllabel = label + <str> + str ( site )  color = next ( colors ) axes [ 0 ] . plot ( np . real ( tarr [ key ] [ <str> ] ) , np . imag ( tarr [ key ] [ <str> ] ) , color = color , marker = <str> , markersize = markersize , label = bllabel , linestyle = <str> ) axes [ 0 ] . set_title ( <str> ) axes [ 0 ] . set_xlabel ( <str> ) axes [ 0 ] . set_ylabel ( <str> ) ; axes [ 1 ] . plot ( np . real ( tarr [ key ] [ <str> ] ) , np . imag ( tarr [ key ] [ <str> ] ) , color = color , marker = <str> , markersize = markersize , label = bllabel , linestyle = <str> ) axes [ 1 ] . set_title ( <str> ) axes [ 1 ] . set_xlabel ( <str> ) axes [ 1 ] . set_ylabel ( <str> ) ;  axes [ 0 ] . axhline ( y = 0 , color = <str> ) axes [ 0 ] . axvline ( x = 0 , color = <str> ) axes [ 1 ] . axhline ( y = 0 , color = <str> ) axes [ 1 ] . axvline ( x = 0 , color = <str> ) if grid :          axes [ 0 ] . grid ( ) axes [ 1 ] . grid ( )  if rangex :          axes [ 0 ] . set_xlim ( rangex ) axes [ 1 ] . set_xlim ( rangex )  if rangey :          axes [ 0 ] . set_ylim ( rangey ) axes [ 1 ] . set_ylim ( rangey )  if legend :          axes [ 1 ] . legend ( loc = <str> , bbox_to_anchor = ( 1 , 0.5 ) )  if export_pdf != <str> :          fig . savefig ( export_pdf , bbox_inches = <str> )  return axes  def plot_compare_gains ( caltab1 , caltab2 , obs , sites = <str> , pol = <str> , gain_type = <str> , ang_unit = <str> , scan_avg = True , site_name_dict = None , fontsize = 13 , legend_fontsize = 13 , yscale = <str> , legend = True , clist = SCOLORS , rangex = False , rangey = False , scalefac = [ 0.9 , 1.1 ] , markersize = [ 2 * MARKERSIZE ] , show = True , grid = False , axislabels = True , remove_ticks = False , axis = False , export_pdf = <str> ) :      colors = iter ( clist ) if ang_unit == <str> : angle = DEGREE else : angle = 1.0 if axis :          x = axis  else :          fig = plt . figure ( ) x = fig . add_subplot ( 1 , 1 , 1 )  if scan_avg :          caltab1 = caltab1 . scan_avg ( obs , incoherent = True ) caltab2 = caltab2 . scan_avg ( obs , incoherent = True )  if sites in [ <str> or <str> ] or sites == [ ] :          sites = list ( set ( caltab1 . data . keys ( ) ) . intersection ( caltab2 . data . keys ( ) ) )  if not type ( sites ) is list :          sites = [ sites ]  if site_name_dict == None :          print ( <str> ) site_name_dict = { } for site in sites :              site_name_dict [ site ] = site   if len ( markersize ) == 1 :          markersize = markersize * np . ones ( len ( sites ) )  maxgain = 0.0 mingain = 10000 for s in range ( len ( sites ) ) :          site = sites [ s ] if pol == <str> :              gains1 = caltab1 . data [ site ] [ <str> ] gains2 = caltab2 . data [ site ] [ <str> ]  elif pol == <str> :              gains1 = caltab1 . data [ site ] [ <str> ] gains2 = caltab2 . data [ site ] [ <str> ]  if gain_type == <str> :              gains1 = np . abs ( gains1 ) gains2 = np . abs ( gains2 ) ylabel = <str>  if gain_type == <str> :              gains1 = np . angle ( gains1 ) / angle gains2 = np . angle ( gains2 ) / angle if ang_unit == <str> : ylabel = <str> else : ylabel = <str>  maxgain = np . nanmax ( [ maxgain , np . nanmax ( gains1 ) , np . nanmax ( gains2 ) ] ) mingain = np . nanmin ( [ mingain , np . nanmin ( gains1 ) , np . nanmin ( gains2 ) ] ) plt . plot ( gains1 , gains2 , marker = <str> , linestyle = <str> , color = next ( colors ) , markersize = markersize [ s ] , label = site_name_dict [ site ] )  plt . xticks ( fontsize = fontsize ) plt . yticks ( fontsize = fontsize ) plt . axes ( ) . set_aspect ( <str> ) if rangex :          x . set_xlim ( rangex )  else :          x . set_xlim ( [ mingain * scalefac [ 0 ] , maxgain * scalefac [ 1 ] ] )  if rangey :          x . set_ylim ( rangey )  else :          x . set_ylim ( [ mingain * scalefac [ 0 ] , maxgain * scalefac [ 1 ] ] )  plt . plot ( [ mingain * scalefac [ 0 ] , maxgain * scalefac [ 1 ] ] , [ mingain * scalefac [ 0 ] , maxgain * scalefac [ 1 ] ] , <str> , linewidth = 1 ) if axislabels :          x . set_xlabel ( <str> + ylabel , fontsize = fontsize ) x . set_ylabel ( <str> + ylabel , fontsize = fontsize )  else :          x . tick_params ( axis = <str> , direction = <str> , pad = - 30 ) x . tick_params ( axis = <str> , direction = <str> , pad = - 18 )  if remove_ticks :          plt . setp ( x . get_xticklabels ( ) , visible = False ) plt . setp ( x . get_yticklabels ( ) , visible = False )  if legend :          plt . legend ( frameon = False , fontsize = legend_fontsize )  if yscale == <str> :          x . set_yscale ( <str> ) x . set_xscale ( <str> )  if grid :          x . grid ( )  if export_pdf != <str> and not axis :          fig . savefig ( export_pdf , bbox_inches = <str> )  if show :          plt . show ( block = False )  return x   