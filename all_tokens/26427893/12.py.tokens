from __future__ import division from __future__ import print_function from builtins import str from builtins import object import numpy as np import matplotlib . pyplot as plt import time import ehtim . observing . pulses import ehtim . scattering as so from ehtim . imaging . imager_utils import * from ehtim . imaging . pol_imager_utils import * from ehtim . const_def import * from ehtim . observing . obs_helpers import * MAXIT = 200 NHIST = 50 MAXLS = 40 STOP = 1e-6 EPS = 1e-8 DATATERMS = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> ] REGULARIZERS = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] DATATERMS_POL = [ <str> , <str> , <str> ] REGULARIZERS_POL = [ <str> , <str> , <str> ] GRIDDER_P_RAD_DEFAULT = 2 GRIDDER_CONV_FUNC_DEFAULT = <str> FFT_PAD_DEFAULT = 2 FFT_INTERP_DEFAULT = 3 REG_DEFAULT = { <str> : 1 } DAT_DEFAULT = { <str> : 100 } POL_PRIM = <str> POL_SOLVE = ( 0 , 1 , 1 ) class Imager ( object ) :      def __init__ ( self , obsdata , init_im , prior_im = None , flux = None , data_term = DAT_DEFAULT , reg_term = REG_DEFAULT , ** kwargs ) :          self . logstr = <str> self . _obs_list = [ ] self . _init_list = [ ] self . _prior_list = [ ] self . _out_list = [ ] self . _out_list_epsilon = [ ] self . _out_list_scattered = [ ] self . _flux_list = { } self . _reg_term_list = [ ] self . _dat_term_list = [ ] self . _clipfloor_list = [ ] self . _pol_list = [ ] self . _maxit_list = [ ] self . _stop_list = [ ] self . _flux_list = [ ] self . _snrcut_list = [ ] self . _debias_list = [ ] self . _systematic_noise_list = [ ] self . _systematic_cphase_noise_list = [ ] self . _transform_list = [ ] self . _weighting_list = [ ] self . reg_term_next = reg_term self . dat_term_next = data_term self . obs_next = obsdata self . init_next = init_im if prior_im is None :              self . prior_next = self . init_next  else :              self . prior_next = prior_im  if flux is None :              self . flux_next = self . prior_next . total_flux ( )  else :              self . flux_next = flux  self . pol_next = kwargs . get ( <str> , self . init_next . pol_prim ) self . debias_next = kwargs . get ( <str> , True ) snrcut = kwargs . get ( <str> , 0. ) self . snrcut_next = { key : 0. for key in DATATERMS } if type ( snrcut ) is dict :              for key in snrcut . keys ( ) :                  self . snrcut_next [ key ] = snrcut [ key ]   else :              for key in self . snrcut_next . keys ( ) :                  self . snrcut_next [ key ] = snrcut   self . systematic_noise_next = kwargs . get ( <str> , 0. ) self . systematic_cphase_noise_next = kwargs . get ( <str> , 0. ) self . weighting_next = kwargs . get ( <str> , <str> ) self . clipfloor_next = kwargs . get ( <str> , 0. ) self . maxit_next = kwargs . get ( <str> , MAXIT ) self . stop_next = kwargs . get ( <str> , STOP ) self . transform_next = kwargs . get ( <str> , <str> ) self . norm_init = kwargs . get ( <str> , True ) self . norm_reg = kwargs . get ( <str> , False ) self . beam_size = self . obs_next . res ( ) self . regparams = { k : kwargs . get ( k , 1.0 ) for k in ( <str> , <str> , <str> , <str> ) } self . chisq_transform = False self . chisq_offset_gradient = 0.0 self . _ttype = kwargs . get ( <str> , <str> ) self . _fft_gridder_prad = kwargs . get ( <str> , GRIDDER_P_RAD_DEFAULT ) self . _fft_conv_func = kwargs . get ( <str> , GRIDDER_CONV_FUNC_DEFAULT ) self . _fft_pad_factor = kwargs . get ( <str> , FFT_PAD_DEFAULT ) self . _fft_interp_order = kwargs . get ( <str> , FFT_INTERP_DEFAULT ) self . cp_uv_min = kwargs . get ( <str> , False ) self . epsilon_list_next = [ ] self . scattering_model = kwargs . get ( <str> , None ) self . _sqrtQ = None self . _ea_ker = None self . _ea_ker_gradient_x = None self . _ea_ker_gradient_y = None self . _alpha_phi_list = [ ] self . alpha_phi_next = kwargs . get ( <str> , 1e4 ) self . _change_imgr_params = True self . nruns = 0 self . check_params ( ) self . check_limits ( ) self . init_imager ( )  def make_image ( self , pol = None , grads = True , ** kwargs ) :          if pol is None :              pol_prim = self . pol_next  else :              self . pol_next = pol pol_prim = pol  print ( <str> ) print ( <str> % ( int ( self . nruns ) + 1 ) ) if self . pol_next == <str> :              print ( <str> ) self . prior_next = self . prior_next . switch_polrep ( polrep_out = <str> , pol_prim_out = <str> ) self . init_next = self . prior_next . switch_polrep ( polrep_out = <str> , pol_prim_out = <str> ) pol_prim = <str>  self . check_params ( ) self . check_limits ( ) self . init_imager ( ) self . _nit = 0 self . _show_updates = kwargs . get ( <str> , True ) self . _update_interval = kwargs . get ( <str> , 1 ) self . plotcur ( self . _xinit , ** kwargs ) optdict = { <str> : self . maxit_next , <str> : self . stop_next , <str> : self . stop_next , <str> : NHIST , <str> : MAXLS } tstart = time . time ( ) if grads :              res = opt . minimize ( self . objfunc , self . _xinit , method = <str> , jac = self . objgrad , options = optdict , callback = self . plotcur )  else :              res = opt . minimize ( self . objfunc , self . _xinit , method = <str> , options = optdict , callback = self . plotcur )  tstop = time . time ( ) out = res . x [ : ] self . tmpout = res . x if self . pol_next == <str> :              out = unpack_poltuple ( out , self . _xtuple , self . _nimage , POL_SOLVE ) if self . transform_next == <str> :                  out = mcv ( out )   elif self . transform_next == <str> :              out = np . exp ( out )  outstr = <str> chi2_term_dict = self . make_chisq_dict ( out ) for dname in sorted ( self . dat_term_next . keys ( ) ) :              outstr += <str> % ( dname , chi2_term_dict [ dname ] )  print ( <str> % ( tstop - tstart ) ) print ( <str> % res . fun ) print ( outstr ) print ( res . message . decode ( ) ) print ( <str> ) if self . pol_next == <str> :              if np . any ( np . invert ( self . _embed_mask ) ) :                  out = embed_pol ( out , self . _embed_mask )  iimage_out = out [ 0 ] qimage_out = make_q_image ( out , POL_PRIM ) uimage_out = make_u_image ( out , POL_PRIM )  else :              if np . any ( np . invert ( self . _embed_mask ) ) :                  out = embed ( out , self . _embed_mask )  iimage_out = out  outim = image . Image ( iimage_out . reshape ( self . prior_next . ydim , self . prior_next . xdim ) , self . prior_next . psize , self . prior_next . ra , self . prior_next . dec , self . prior_next . pa , rf = self . prior_next . rf , source = self . prior_next . source , polrep = self . prior_next . polrep , pol_prim = pol_prim , mjd = self . prior_next . mjd , time = self . prior_next . time , pulse = self . prior_next . pulse ) for pol2 in list ( outim . _imdict . keys ( ) ) :              if pol2 == outim . pol_prim : continue if self . pol_next == <str> and pol2 == <str> :                  polvec = qimage_out  elif self . pol_next == <str> and pol2 == <str> :                  polvec = uimage_out  else :                  polvec = self . init_next . _imdict [ pol2 ]  if len ( polvec ) :                  polarr = polvec . reshape ( outim . ydim , outim . xdim ) outim . add_pol_image ( polarr , pol2 )   logstr = str ( self . nruns ) + <str> % pol self . _append_image_history ( outim , logstr ) self . nruns += 1 return outim  def make_image_I ( self , grads = True , ** kwargs ) :          return self . make_image ( pol = <str> , grads = grads , ** kwargs )  def make_image_P ( self , grads = True , ** kwargs ) :          return self . make_image ( pol = <str> , grads = grads , ** kwargs )  def set_embed ( self ) :          self . _embed_mask = self . prior_next . imvec > self . clipfloor_next if not np . any ( self . _embed_mask ) :              raise Exception ( <str> )  coord = np . array ( [ [ [ x , y ] for x in np . arange ( self . prior_next . xdim // 2 , - self . prior_next . xdim // 2 , - 1 ) ] for y in np . arange ( self . prior_next . ydim // 2 , - self . prior_next . ydim // 2 , - 1 ) ] ) coord = self . prior_next . psize * coord . reshape ( self . prior_next . ydim * self . prior_next . xdim , 2 ) self . _coord_matrix = coord [ self . _embed_mask ] return  def check_params ( self ) :          if ( ( self . prior_next . psize != self . init_next . psize ) or ( self . prior_next . xdim != self . init_next . xdim ) or ( self . prior_next . ydim != self . prior_next . ydim ) ) :              raise Exception ( <str> )  if ( self . prior_next . polrep != self . init_next . polrep ) :              raise Exception ( <str> )  if ( self . prior_next . polrep == <str> and not ( self . pol_next in [ <str> , <str> , <str> ] ) ) :              raise Exception ( <str> )  if ( self . prior_next . polrep == <str> and not ( self . pol_next in [ <str> , <str> , <str> , <str> , <str> ] ) ) :              raise Exception ( <str> )  if ( self . transform_next == <str> and self . pol_next in [ <str> , <str> , <str> , <str> ] ) :              raise Exception ( <str> )  if self . _ttype not in [ <str> , <str> , <str> ] :              raise Exception ( <str> )  if ( self . pol_next in [ <str> , <str> , <str> ] and ( <str> in self . reg_term_next . keys ( ) or <str> in self . reg_term_next . keys ( ) ) ) :              raise Exception ( <str> )  if ( self . pol_next == <str> ) :              if self . transform_next != <str> :                  raise Exception ( <str> )  if ( self . _ttype not in [ <str> , <str> ] ) :                  raise Exception ( <str> )  dt_here = False dt_type = True for term in sorted ( self . dat_term_next . keys ( ) ) :                  if ( term != None ) and ( term != False ) : dt_here = True if not ( ( term in DATATERMS_POL ) or term == False ) : dt_type = False  st_here = False st_type = True for term in sorted ( self . reg_term_next . keys ( ) ) :                  if ( term != None ) and ( term != False ) : st_here = True if not ( ( term in REGULARIZERS_POL ) or term == False ) : st_type = False  if not dt_here :                  raise Exception ( <str> )  if not st_here :                  raise Exception ( <str> )  if not dt_type :                  raise Exception ( <str> + <str> . join ( DATATERMS_POL ) )  if not st_type :                  raise Exception ( <str> + <str> . join ( REGULARIZERS_POL ) )   else :              dt_here = False dt_type = True for term in sorted ( self . dat_term_next . keys ( ) ) :                  if ( term != None ) and ( term != False ) : dt_here = True if not ( ( term in DATATERMS ) or term == False ) : dt_type = False  st_here = False st_type = True for term in sorted ( self . reg_term_next . keys ( ) ) :                  if ( term != None ) and ( term != False ) : st_here = True if not ( ( term in REGULARIZERS ) or term == False ) : st_type = False  if not dt_here :                  raise Exception ( <str> )  if not st_here :                  raise Exception ( <str> )  if not dt_type :                  raise Exception ( <str> + <str> . join ( DATATERMS ) )  if not st_type :                  raise Exception ( <str> + <str> . join ( REGULARIZERS ) )   if self . nruns == 0 :              return  if self . pol_next != self . pol_last ( ) :              print ( <str> ) self . _change_imgr_params = True return  if self . obs_next != self . obs_last ( ) :              print ( <str> ) self . _change_imgr_params = True return  if len ( self . reg_term_next ) != len ( self . reg_terms_last ( ) ) :              print ( <str> ) self . _change_imgr_params = True return  if len ( self . dat_term_next ) != len ( self . dat_terms_last ( ) ) :              print ( <str> ) self . _change_imgr_params = True return  for term in sorted ( self . dat_term_next . keys ( ) ) :              if term not in self . dat_terms_last ( ) . keys ( ) :                  print ( <str> % term ) self . _change_imgr_params = True return   for term in sorted ( self . reg_term_next . keys ( ) ) :              if term not in self . reg_terms_last ( ) . keys ( ) :                  print ( <str> % term ) self . _change_imgr_params = True return   if ( ( self . prior_next . psize != self . prior_last ( ) . psize ) or ( self . prior_next . xdim != self . prior_last ( ) . xdim ) or ( self . prior_next . ydim != self . prior_last ( ) . ydim ) ) :              print ( <str> ) self . _change_imgr_params = True  if self . debias_next != self . debias_last ( ) :              print ( <str> ) self . _change_imgr_params = True return  if self . snrcut_next != self . snrcut_last ( ) :              print ( <str> ) self . _change_imgr_params = True return  if self . weighting_next != self . weighting_last ( ) :              print ( <str> ) self . _change_imgr_params = True return  if self . systematic_noise_next != self . systematic_noise_last ( ) :              print ( <str> ) self . _change_imgr_params = True return  if self . systematic_cphase_noise_next != self . systematic_cphase_noise_last ( ) :              print ( <str> ) self . _change_imgr_params = True return   def check_limits ( self ) :          uvmax = 1.0 / self . prior_next . psize uvmin = 1.0 / ( self . prior_next . psize * np . max ( ( self . prior_next . xdim , self . prior_next . ydim ) ) ) uvdists = self . obs_next . unpack ( <str> ) [ <str> ] maxbl = np . max ( uvdists ) minbl = np . max ( uvdists [ uvdists > 0 ] ) if uvmax < maxbl :              print ( <str> )  if uvmin > minbl :              print ( <str> )  if self . pol_next in [ <str> , <str> , <str> ] :              maxamp = np . max ( np . abs ( self . obs_next . unpack ( <str> ) [ <str> ] ) ) if self . flux_next > 1.2 * maxamp :                  print ( <str> )  if self . flux_next < .8 * maxamp :                  print ( <str> )    def reg_terms_last ( self ) :          if self . nruns == 0 :              print ( <str> ) return  return self . _reg_term_list [ - 1 ]  def dat_terms_last ( self ) :          if self . nruns == 0 :              print ( <str> ) return  return self . _dat_term_list [ - 1 ]  def obs_last ( self ) :          if self . nruns == 0 :              print ( <str> ) return  return self . _obs_list [ - 1 ]  def prior_last ( self ) :          if self . nruns == 0 :              print ( <str> ) return  return self . _prior_list [ - 1 ]  def out_last ( self ) :          if self . nruns == 0 :              print ( <str> ) return  return self . _out_list [ - 1 ]  def out_scattered_last ( self ) :          if self . nruns == 0 or len ( self . _out_list_scattered ) == 0 :              print ( <str> ) return  return self . _out_list_scattered [ - 1 ]  def out_epsilon_last ( self ) :          if self . nruns == 0 or len ( self . _out_list_epsilon ) == 0 :              print ( <str> ) return  return self . _out_list_epsilon [ - 1 ]  def init_last ( self ) :          if self . nruns == 0 :              print ( <str> ) return  return self . _init_list [ - 1 ]  def flux_last ( self ) :          if self . nruns == 0 :              print ( <str> ) return  return self . _flux_list [ - 1 ]  def clipfloor_last ( self ) :          if self . nruns == 0 :              print ( <str> ) return  return self . _clipfloor_list [ - 1 ]  def pol_last ( self ) :          if self . nruns == 0 :              print ( <str> ) return  return self . _pol_list [ - 1 ]  def maxit_last ( self ) :          if self . nruns == 0 :              print ( <str> ) return  return self . _maxit_list [ - 1 ]  def debias_last ( self ) :          if self . nruns == 0 :              print ( <str> ) return  return self . _debias_list [ - 1 ]  def snrcut_last ( self ) :          if self . nruns == 0 :              print ( <str> ) return  return self . _snrcut_list [ - 1 ]  def weighting_last ( self ) :          if self . nruns == 0 :              print ( <str> ) return  return self . _weighting_list [ - 1 ]  def systematic_noise_last ( self ) :          if self . nruns == 0 :              print ( <str> ) return  return self . _systematic_noise_list [ - 1 ]  def systematic_cphase_noise_last ( self ) :          if self . nruns == 0 :              print ( <str> ) return  return self . _systematic_cphase_noise_list [ - 1 ]  def stop_last ( self ) :          if self . nruns == 0 :              print ( <str> ) return  return self . _stop_list [ - 1 ]  def transform_last ( self ) :          if self . nruns == 0 :              print ( <str> ) return  return self . _transform_list [ - 1 ]  def init_imager ( self ) :          self . set_embed ( ) if self . pol_next == <str> :              self . _iinit = self . init_next . imvec [ self . _embed_mask ] self . _nimage = len ( self . _iinit ) if len ( self . init_next . qvec ) and ( np . any ( self . init_next . qvec != 0 ) or np . any ( self . init_next . uvec != 0 ) ) :                  init1 = ( np . abs ( self . init_next . qvec + 1j * self . init_next . uvec ) / self . init_next . imvec ) [ self . _embed_mask ] init2 = ( np . arctan2 ( self . init_next . uvec , self . init_next . qvec ) / 2.0 ) [ self . _embed_mask ]  else :                  print ( <str> ) init1 = 0.2 * ( np . ones ( self . _nimage ) + 1e-2 * np . random . rand ( self . _nimage ) ) init2 = np . zeros ( self . _nimage ) + 1e-2 * np . random . rand ( self . _nimage )  self . _inittuple = np . array ( ( self . _iinit , init1 , init2 ) ) if self . transform_next == <str> :                  self . _xtuple = mcv_r ( self . _inittuple )  else :                  raise Exception ( <str> )  self . _xinit = pack_poltuple ( self . _xtuple , POL_SOLVE )  else :              if self . norm_init :                  self . _nprior = ( self . flux_next * self . prior_next . imvec / np . sum ( ( self . prior_next . imvec ) [ self . _embed_mask ] ) ) [ self . _embed_mask ] self . _ninit = ( self . flux_next * self . init_next . imvec / np . sum ( ( self . init_next . imvec ) [ self . _embed_mask ] ) ) [ self . _embed_mask ]  else :                  self . _nprior = self . prior_next . imvec [ self . _embed_mask ] self . _ninit = self . init_next . imvec [ self . _embed_mask ]  if self . transform_next == <str> :                  self . _xinit = np . log ( self . _ninit )  else : self . _xinit = self . _ninit  if self . _change_imgr_params :              if self . nruns == 0 :                  print ( <str> )  if self . nruns > 0 :                  print ( <str> )  self . _data_tuples = { } for dname in sorted ( self . dat_term_next . keys ( ) ) :                  if self . pol_next == <str> :                      tup = polchisqdata ( self . obs_next , self . prior_next , self . _embed_mask , dname , pol = self . pol_next , debias = self . debias_next , snrcut = self . snrcut_next [ dname ] , weighting = self . weighting_next , systematic_noise = self . systematic_noise_next , systematic_cphase_noise = self . systematic_cphase_noise_next , ttype = self . _ttype , order = self . _fft_interp_order , fft_pad_factor = self . _fft_pad_factor , conv_func = self . _fft_conv_func , p_rad = self . _fft_gridder_prad , cp_uv_min = self . cp_uv_min )  else :                      tup = chisqdata ( self . obs_next , self . prior_next , self . _embed_mask , dname , pol = self . pol_next , debias = self . debias_next , snrcut = self . snrcut_next [ dname ] , weighting = self . weighting_next , systematic_noise = self . systematic_noise_next , systematic_cphase_noise = self . systematic_cphase_noise_next , ttype = self . _ttype , order = self . _fft_interp_order , fft_pad_factor = self . _fft_pad_factor , conv_func = self . _fft_conv_func , p_rad = self . _fft_gridder_prad , cp_uv_min = self . cp_uv_min )  self . _data_tuples [ dname ] = tup  self . _change_imgr_params = False  return  def init_imager_scattering ( self ) :          N = self . prior_next . xdim if self . scattering_model == None :              self . scattering_model = so . ScatteringModel ( )  wavelength = C / self . obs_next . rf * 100.0 wavelengthbar = wavelength / ( 2.0 * np . pi ) N = self . prior_next . xdim FOV = self . prior_next . psize * N * self . scattering_model . observer_screen_distance self . _ea_ker = self . scattering_model . Ensemble_Average_Kernel ( self . prior_next , wavelength_cm = wavelength ) ea_ker_gradient = so . Wrapped_Gradient ( self . _ea_ker / ( FOV / N ) ) self . _ea_ker_gradient_x = - ea_ker_gradient [ 1 ] self . _ea_ker_gradient_y = - ea_ker_gradient [ 0 ] self . _sqrtQ = np . real ( self . scattering_model . sqrtQ_Matrix ( self . prior_next , t_hr = 0.0 ) ) if len ( self . epsilon_list_next ) == 0 :              self . _xinit = np . concatenate ( ( self . _xinit , np . zeros ( N ** 2 - 1 ) ) )  else :              self . _xinit = np . concatenate ( ( self . _xinit , self . epsilon_list_next ) )   def make_chisq_dict ( self , imcur ) :          chi2_dict = { } for dname in sorted ( self . dat_term_next . keys ( ) ) :              data = self . _data_tuples [ dname ] [ 0 ] sigma = self . _data_tuples [ dname ] [ 1 ] A = self . _data_tuples [ dname ] [ 2 ] if self . pol_next == <str> :                  chi2 = polchisq ( imcur , A , data , sigma , dname , ttype = self . _ttype , mask = self . _embed_mask , pol_prim = POL_PRIM )  else :                  chi2 = chisq ( imcur , A , data , sigma , dname , ttype = self . _ttype , mask = self . _embed_mask )  chi2_dict [ dname ] = chi2  return chi2_dict  def make_chisqgrad_dict ( self , imcur ) :          chi2grad_dict = { } for dname in sorted ( self . dat_term_next . keys ( ) ) :              data = self . _data_tuples [ dname ] [ 0 ] sigma = self . _data_tuples [ dname ] [ 1 ] A = self . _data_tuples [ dname ] [ 2 ] if self . pol_next == <str> :                  chi2grad = polchisqgrad ( imcur , A , data , sigma , dname , ttype = self . _ttype , mask = self . _embed_mask , pol_prim = POL_PRIM , pol_solve = POL_SOLVE )  else :                  chi2grad = chisqgrad ( imcur , A , data , sigma , dname , ttype = self . _ttype , mask = self . _embed_mask )  chi2grad_dict [ dname ] = chi2grad  return chi2grad_dict  def make_reg_dict ( self , imcur ) :          reg_dict = { } for regname in sorted ( self . reg_term_next . keys ( ) ) :              if self . pol_next == <str> :                  reg = polregularizer ( imcur , self . _embed_mask , self . prior_next . xdim , self . prior_next . ydim , self . prior_next . psize , regname , pol_prim = POL_PRIM )  else :                  reg = regularizer ( imcur , self . _nprior , self . _embed_mask , self . flux_next , self . prior_next . xdim , self . prior_next . ydim , self . prior_next . psize , regname , norm_reg = self . norm_reg , beam_size = self . beam_size , ** self . regparams )  reg_dict [ regname ] = reg  return reg_dict  def make_reggrad_dict ( self , imcur ) :          reggrad_dict = { } for regname in sorted ( self . reg_term_next . keys ( ) ) :              if self . pol_next == <str> :                  reg = polregularizergrad ( imcur , self . _embed_mask , self . prior_next . xdim , self . prior_next . ydim , self . prior_next . psize , regname , pol_prim = POL_PRIM , pol_solve = POL_SOLVE )  else :                  reg = regularizergrad ( imcur , self . _nprior , self . _embed_mask , self . flux_next , self . prior_next . xdim , self . prior_next . ydim , self . prior_next . psize , regname , norm_reg = self . norm_reg , beam_size = self . beam_size , ** self . regparams )  reggrad_dict [ regname ] = reg  return reggrad_dict  def objfunc ( self , imvec ) :          if self . pol_next == <str> :              imcur = unpack_poltuple ( imvec , self . _xtuple , self . _nimage , POL_SOLVE )  else :              imcur = imvec  if self . transform_next == <str> :              imcur = np . exp ( imcur )  elif self . transform_next == <str> :              imcur = mcv ( imcur )  datterm = 0. chi2_term_dict = self . make_chisq_dict ( imcur ) for dname in sorted ( self . dat_term_next . keys ( ) ) :              if self . chisq_transform :                  datterm += self . dat_term_next [ dname ] * ( chi2_term_dict [ dname ] + 1. / chi2_term_dict [ dname ] - 1. )  else :                  datterm += self . dat_term_next [ dname ] * ( chi2_term_dict [ dname ] - 1. )   regterm = 0 reg_term_dict = self . make_reg_dict ( imcur ) for regname in sorted ( self . reg_term_next . keys ( ) ) :              regterm += self . reg_term_next [ regname ] * reg_term_dict [ regname ]  return datterm + regterm  def objgrad ( self , imvec ) :          if self . pol_next == <str> :              imcur = unpack_poltuple ( imvec , self . _xtuple , self . _nimage , POL_SOLVE )  else :              imcur = imvec  if self . transform_next == <str> :              imcur = np . exp ( imcur )  elif self . transform_next == <str> :              cvcur = imcur . copy ( ) imcur = mcv ( imcur )  datterm = 0. chi2_term_dict = self . make_chisqgrad_dict ( imcur ) if self . chisq_transform :              chi2_value_dict = self . make_chisq_dict ( imcur )  for dname in sorted ( self . dat_term_next . keys ( ) ) :              if self . chisq_transform :                  datterm += self . dat_term_next [ dname ] * chi2_term_dict [ dname ] * ( 1 - 1. / ( chi2_value_dict [ dname ] ** 2 ) )  else :                  datterm += self . dat_term_next [ dname ] * ( chi2_term_dict [ dname ] + self . chisq_offset_gradient )   regterm = 0 reg_term_dict = self . make_reggrad_dict ( imcur ) for regname in sorted ( self . reg_term_next . keys ( ) ) :              regterm += self . reg_term_next [ regname ] * reg_term_dict [ regname ]  grad = datterm + regterm if self . transform_next == <str> :              grad *= imcur  elif self . transform_next == <str> :              grad *= mchain ( cvcur )  if self . pol_next == <str> :              grad = pack_poltuple ( grad , POL_SOLVE )  return grad  def plotcur ( self , imvec , ** kwargs ) :          if self . _show_updates :              if self . _nit % self . _update_interval == 0 :                  if self . pol_next == <str> :                      imcur = unpack_poltuple ( imvec , self . _xtuple , self . _nimage , POL_SOLVE )  else :                      imcur = imvec  if self . transform_next == <str> :                      imcur = np . exp ( imcur )  elif self . transform_next == <str> :                      imcur = mcv ( imcur )  chi2_term_dict = self . make_chisq_dict ( imcur ) reg_term_dict = self . make_reg_dict ( imcur ) chi2_keys = sorted ( chi2_term_dict . keys ( ) ) chi2_1 = chi2_term_dict [ chi2_keys [ 0 ] ] chi2_2 = 0. if len ( chi2_term_dict ) > 1 :                      chi2_2 = chi2_term_dict [ chi2_keys [ 1 ] ]  outstr = <str> outstr += <str> % self . _nit for dname in sorted ( self . dat_term_next . keys ( ) ) :                      outstr += <str> % ( dname , chi2_term_dict [ dname ] )  outstr += <str> for dname in sorted ( self . dat_term_next . keys ( ) ) :                      outstr += <str> % ( dname , chi2_term_dict [ dname ] * self . dat_term_next [ dname ] )  outstr += <str> for regname in sorted ( self . reg_term_next . keys ( ) ) :                      outstr += <str> % ( regname , reg_term_dict [ regname ] * self . reg_term_next [ regname ] )  if self . pol_next == <str> :                      if np . any ( np . invert ( self . _embed_mask ) ) :                          imcur = embed_pol ( imcur , self . _embed_mask )  plot_m ( imcur , self . prior_next , self . _nit , chi2_term_dict , ** kwargs )  else :                      if np . any ( np . invert ( self . _embed_mask ) ) :                          imcur = embed ( imcur , self . _embed_mask )  plot_i ( imcur , self . prior_next , self . _nit , chi2_term_dict , pol = self . pol_next , ** kwargs )  if self . _nit == 0 : print ( ) print ( outstr )   self . _nit += 1  def objfunc_scattering ( self , minvec ) :          N = self . prior_next . xdim imvec = minvec [ : N ** 2 ] EpsilonList = minvec [ N ** 2 : ] if self . transform_next == <str> :              imvec = np . exp ( imvec )  IM = ehtim . image . Image ( imvec . reshape ( N , N ) , self . prior_next . psize , self . prior_next . ra , self . prior_next . dec , self . prior_next . pa , rf = self . obs_next . rf , source = self . prior_next . source , mjd = self . prior_next . mjd ) scatt_im = self . scattering_model . Scatter ( IM , Epsilon_Screen = so . MakeEpsilonScreenFromList ( EpsilonList , N ) , ea_ker = self . _ea_ker , sqrtQ = self . _sqrtQ , Linearized_Approximation = True ) . imvec datterm = 0. chi2_term_dict = self . make_chisq_dict ( scatt_im ) for dname in sorted ( self . dat_term_next . keys ( ) ) :              datterm += self . dat_term_next [ dname ] * ( chi2_term_dict [ dname ] - 1. )  regterm = 0 reg_term_dict = self . make_reg_dict ( imvec ) reg_term_dict_scatt = self . make_reg_dict ( scatt_im ) for regname in sorted ( self . reg_term_next . keys ( ) ) :              if regname == <str> :                  regterm += self . reg_term_next [ regname ] * reg_term_dict_scatt [ regname ]  else :                  regterm += self . reg_term_next [ regname ] * reg_term_dict [ regname ]   chisq_epsilon = sum ( EpsilonList * EpsilonList ) / ( ( N * N - 1.0 ) / 2.0 ) regterm_scattering = self . alpha_phi_next * ( chisq_epsilon - 1.0 ) return datterm + regterm + regterm_scattering  def objgrad_scattering ( self , minvec ) :          wavelength = C / self . obs_next . rf * 100.0 wavelengthbar = wavelength / ( 2.0 * np . pi ) N = self . prior_next . xdim FOV = self . prior_next . psize * N * self . scattering_model . observer_screen_distance rF = self . scattering_model . rF ( wavelength ) imvec = minvec [ : N ** 2 ] EpsilonList = minvec [ N ** 2 : ] if self . transform_next == <str> :              imvec = np . exp ( imvec )  IM = ehtim . image . Image ( imvec . reshape ( N , N ) , self . prior_next . psize , self . prior_next . ra , self . prior_next . dec , self . prior_next . pa , rf = self . obs_next . rf , source = self . prior_next . source , mjd = self . prior_next . mjd ) scatt_im = self . scattering_model . Scatter ( IM , Epsilon_Screen = so . MakeEpsilonScreenFromList ( EpsilonList , N ) , ea_ker = self . _ea_ker , sqrtQ = self . _sqrtQ , Linearized_Approximation = True ) . imvec EA_Image = self . scattering_model . Ensemble_Average_Blur ( IM , ker = self . _ea_ker ) EA_Gradient = so . Wrapped_Gradient ( ( EA_Image . imvec / ( FOV / N ) ) . reshape ( N , N ) ) EA_Gradient_x = - EA_Gradient [ 1 ] EA_Gradient_y = - EA_Gradient [ 0 ] Epsilon_Screen = so . MakeEpsilonScreenFromList ( EpsilonList , N ) phi = self . scattering_model . MakePhaseScreen ( Epsilon_Screen , IM , obs_frequency_Hz = self . obs_next . rf , sqrtQ_init = self . _sqrtQ ) . imvec . reshape ( ( N , N ) ) phi_Gradient = so . Wrapped_Gradient ( phi / ( FOV / N ) ) phi_Gradient_x = - phi_Gradient [ 1 ] phi_Gradient_y = - phi_Gradient [ 0 ] regterm = 0 reg_term_dict = self . make_reggrad_dict ( imvec ) reg_term_dict_scatt = self . make_reggrad_dict ( scatt_im ) for regname in sorted ( self . reg_term_next . keys ( ) ) :              if regname == <str> :                  gaussterm = self . reg_term_next [ regname ] * reg_term_dict_scatt [ regname ] dgauss_dIa = gaussterm . reshape ( ( N , N ) ) gx = ( rF ** 2.0 * so . Wrapped_Convolve ( self . _ea_ker_gradient_x [ : : - 1 , : : - 1 ] , phi_Gradient_x * ( dgauss_dIa ) ) ) . flatten ( ) gy = ( rF ** 2.0 * so . Wrapped_Convolve ( self . _ea_ker_gradient_y [ : : - 1 , : : - 1 ] , phi_Gradient_y * ( dgauss_dIa ) ) ) . flatten ( ) regterm += so . Wrapped_Convolve ( self . _ea_ker [ : : - 1 , : : - 1 ] , ( dgauss_dIa ) ) . flatten ( ) + gx + gy  else :                  regterm += self . reg_term_next [ regname ] * reg_term_dict [ regname ]   datterm = 0. chi2_term_dict = self . make_chisqgrad_dict ( scatt_im ) for dname in sorted ( self . dat_term_next . keys ( ) ) :              datterm += self . dat_term_next [ dname ] * ( chi2_term_dict [ dname ] )  dchisq_dIa = datterm . reshape ( ( N , N ) ) gx = ( rF ** 2.0 * so . Wrapped_Convolve ( self . _ea_ker_gradient_x [ : : - 1 , : : - 1 ] , phi_Gradient_x * ( dchisq_dIa ) ) ) . flatten ( ) gy = ( rF ** 2.0 * so . Wrapped_Convolve ( self . _ea_ker_gradient_y [ : : - 1 , : : - 1 ] , phi_Gradient_y * ( dchisq_dIa ) ) ) . flatten ( ) chisq_grad_im = so . Wrapped_Convolve ( self . _ea_ker [ : : - 1 , : : - 1 ] , ( dchisq_dIa ) ) . flatten ( ) + gx + gy chisq_grad_epsilon = np . zeros ( N ** 2 - 1 ) i_grad = 0 ell_mat = np . zeros ( ( N , N ) ) m_mat = np . zeros ( ( N , N ) ) for ell in range ( 0 , N ) :              for m in range ( 0 , N ) :                  ell_mat [ ell , m ] = ell m_mat [ ell , m ] = m   for t in range ( 1 , ( N + 1 ) // 2 ) :              s = 0 grad_term = so . Wrapped_Gradient ( wavelengthbar / FOV * self . _sqrtQ [ s ] [ t ] * 2.0 * np . cos ( 2.0 * np . pi / N * ( ell_mat * s + m_mat * t ) ) / ( FOV / N ) ) grad_term_x = - grad_term [ 1 ] grad_term_y = - grad_term [ 0 ] chisq_grad_epsilon [ i_grad ] = np . sum ( dchisq_dIa * rF ** 2 * ( EA_Gradient_x * grad_term_x + EA_Gradient_y * grad_term_y ) ) i_grad = i_grad + 1  for s in range ( 1 , ( N + 1 ) // 2 ) :              for t in range ( N ) :                  grad_term = so . Wrapped_Gradient ( wavelengthbar / FOV * self . _sqrtQ [ s ] [ t ] * 2.0 * np . cos ( 2.0 * np . pi / N * ( ell_mat * s + m_mat * t ) ) / ( FOV / N ) ) grad_term_x = - grad_term [ 1 ] grad_term_y = - grad_term [ 0 ] chisq_grad_epsilon [ i_grad ] = np . sum ( dchisq_dIa * rF ** 2 * ( EA_Gradient_x * grad_term_x + EA_Gradient_y * grad_term_y ) ) i_grad = i_grad + 1   for t in range ( 1 , ( N + 1 ) // 2 ) :              s = 0 grad_term = so . Wrapped_Gradient ( - wavelengthbar / FOV * self . _sqrtQ [ s ] [ t ] * 2.0 * np . sin ( 2.0 * np . pi / N * ( ell_mat * s + m_mat * t ) ) / ( FOV / N ) ) grad_term_x = - grad_term [ 1 ] grad_term_y = - grad_term [ 0 ] chisq_grad_epsilon [ i_grad ] = np . sum ( dchisq_dIa * rF ** 2 * ( EA_Gradient_x * grad_term_x + EA_Gradient_y * grad_term_y ) ) i_grad = i_grad + 1  for s in range ( 1 , ( N + 1 ) // 2 ) :              for t in range ( N ) :                  grad_term = so . Wrapped_Gradient ( - wavelengthbar / FOV * self . _sqrtQ [ s ] [ t ] * 2.0 * np . sin ( 2.0 * np . pi / N * ( ell_mat * s + m_mat * t ) ) / ( FOV / N ) ) grad_term_x = - grad_term [ 1 ] grad_term_y = - grad_term [ 0 ] chisq_grad_epsilon [ i_grad ] = np . sum ( dchisq_dIa * rF ** 2 * ( EA_Gradient_x * grad_term_x + EA_Gradient_y * grad_term_y ) ) i_grad = i_grad + 1   chisq_epsilon_grad = self . alpha_phi_next * 2.0 * EpsilonList / ( ( N * N - 1 ) / 2.0 ) if self . transform_next == <str> :              regterm *= imvec chisq_grad_im *= imvec  return np . concatenate ( ( ( regterm + chisq_grad_im ) , ( chisq_grad_epsilon + chisq_epsilon_grad ) ) )  def plotcur_scattering ( self , minvec ) :          if self . _show_updates :              if self . _nit % self . _update_interval == 0 :                  N = self . prior_next . xdim imvec = minvec [ : N ** 2 ] EpsilonList = minvec [ N ** 2 : ] if self . transform_next == <str> :                      imvec = np . exp ( imvec )  IM = ehtim . image . Image ( imvec . reshape ( N , N ) , self . prior_next . psize , self . prior_next . ra , self . prior_next . dec , self . prior_next . pa , rf = self . obs_next . rf , source = self . prior_next . source , mjd = self . prior_next . mjd ) scatt_im = self . scattering_model . Scatter ( IM , Epsilon_Screen = so . MakeEpsilonScreenFromList ( EpsilonList , N ) , ea_ker = self . _ea_ker , sqrtQ = self . _sqrtQ , Linearized_Approximation = True ) . imvec datterm = 0. chi2_term_dict = self . make_chisq_dict ( scatt_im ) for dname in sorted ( self . dat_term_next . keys ( ) ) :                      datterm += self . dat_term_next [ dname ] * ( chi2_term_dict [ dname ] - 1. )  regterm = 0 reg_term_dict = self . make_reg_dict ( imvec ) for regname in sorted ( self . reg_term_next . keys ( ) ) :                      regterm += self . reg_term_next [ regname ] * reg_term_dict [ regname ]  chisq_epsilon = sum ( EpsilonList * EpsilonList ) / ( ( N * N - 1.0 ) / 2.0 ) regterm_scattering = self . alpha_phi_next * ( chisq_epsilon - 1.0 ) outstr = <str> % self . _nit for dname in sorted ( self . dat_term_next . keys ( ) ) :                      outstr += <str> % ( dname , chi2_term_dict [ dname ] )  for regname in sorted ( self . reg_term_next . keys ( ) ) :                      outstr += <str> % ( regname , reg_term_dict [ regname ] )  outstr += <str> % ( chisq_epsilon ) outstr += <str> % ( max ( abs ( EpsilonList ) ) ) print ( outstr )   self . _nit += 1  def make_image_I_stochastic_optics ( self , grads = True , ** kwargs ) :          N = self . prior_next . xdim self . check_params ( ) self . check_limits ( ) self . init_imager ( ) self . init_imager_scattering ( ) self . _nit = 0 self . _show_updates = kwargs . get ( <str> , True ) self . _update_interval = kwargs . get ( <str> , 1 ) self . plotcur_scattering ( self . _xinit ) optdict = { <str> : self . maxit_next , <str> : self . stop_next , <str> : NHIST } tstart = time . time ( ) if grads :              res = opt . minimize ( self . objfunc_scattering , self . _xinit , method = <str> , jac = self . objgrad_scattering , options = optdict , callback = self . plotcur_scattering )  else :              res = opt . minimize ( self . objfunc_scattering , self . _xinit , method = <str> , options = optdict , callback = self . plotcur_scattering )  tstop = time . time ( ) out = res . x [ : N ** 2 ] if self . transform_next == <str> : out = np . exp ( out ) if np . any ( np . invert ( self . _embed_mask ) ) :              raise Exception ( <str> ) out = embed ( out , self . _embed_mask )  outim = image . Image ( out . reshape ( N , N ) , self . prior_next . psize , self . prior_next . ra , self . prior_next . dec , self . prior_next . pa , rf = self . prior_next . rf , source = self . prior_next . source , mjd = self . prior_next . mjd , pulse = self . prior_next . pulse ) outep = res . x [ N ** 2 : ] outscatt = self . scattering_model . Scatter ( outim , Epsilon_Screen = so . MakeEpsilonScreenFromList ( outep , N ) , ea_ker = self . _ea_ker , sqrtQ = self . _sqrtQ , Linearized_Approximation = True ) if len ( self . prior_next . qvec ) :              qvec = self . prior_next . qvec * out / self . prior_next . imvec uvec = self . prior_next . uvec * out / self . prior_next . imvec outim . add_qu ( qvec . reshape ( N , N ) , uvec . reshape ( N , N ) )  print ( <str> % ( tstop - tstart ) ) print ( <str> % res . fun ) print ( res . message ) logstr = str ( self . nruns ) + <str> self . _append_image_history ( outim , logstr ) self . _out_list_epsilon . append ( res . x [ N ** 2 : ] ) self . _out_list_scattered . append ( outscatt ) self . nruns += 1 return outim  def _append_image_history ( self , outim , logstr ) :          self . logstr += ( logstr + <str> ) self . _obs_list . append ( self . obs_next ) self . _init_list . append ( self . init_next ) self . _prior_list . append ( self . prior_next ) self . _debias_list . append ( self . debias_next ) self . _weighting_list . append ( self . weighting_next ) self . _systematic_noise_list . append ( self . systematic_noise_next ) self . _systematic_cphase_noise_list . append ( self . systematic_cphase_noise_next ) self . _snrcut_list . append ( self . snrcut_next ) self . _flux_list . append ( self . flux_next ) self . _pol_list . append ( self . pol_next ) self . _clipfloor_list . append ( self . clipfloor_next ) self . _maxit_list . append ( self . maxit_next ) self . _stop_list . append ( self . stop_next ) self . _transform_list . append ( self . transform_next ) self . _reg_term_list . append ( self . reg_term_next ) self . _dat_term_list . append ( self . dat_term_next ) self . _alpha_phi_list . append ( self . alpha_phi_next ) self . _out_list . append ( outim ) return  def make_image_scat ( self ) :          return    