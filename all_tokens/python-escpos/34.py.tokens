from __future__ import absolute_import from __future__ import division from __future__ import print_function from __future__ import unicode_literals from builtins import bytes from . constants import CODEPAGE_CHANGE from . exceptions import Error from . codepages import CodePages import six class Encoder ( object ) :      def __init__ ( self , codepage_map ) :          self . codepages = codepage_map self . available_encodings = set ( codepage_map . keys ( ) ) self . available_characters = { } self . used_encodings = set ( )  def get_sequence ( self , encoding ) :          return int ( self . codepages [ encoding ] )  def get_encoding_name ( self , encoding ) :          encoding = CodePages . get_encoding_name ( encoding ) if encoding not in self . codepages :              raise ValueError ( ( <str> <str> ) . format ( encoding , <str> . join ( self . codepages . keys ( ) ) ) )  return encoding  @ staticmethod def _get_codepage_char_list ( encoding ) :          codepage = CodePages . get_encoding ( encoding ) if <str> in codepage :              encodable_chars = list ( <str> . join ( codepage [ <str> ] ) ) assert ( len ( encodable_chars ) == 128 ) return encodable_chars  elif <str> in codepage :              encodable_chars = [ <str> ] * 128 for i in range ( 0 , 128 ) :                  codepoint = i + 128 try :                      encodable_chars [ i ] = bytes ( [ codepoint ] ) . decode ( codepage [ <str> ] )  except UnicodeDecodeError :                      pass   return encodable_chars  raise LookupError ( <str> . format ( encoding ) )  def _get_codepage_char_map ( self , encoding ) :          if encoding in self . available_characters :              return self . available_characters [ encoding ]  codepage_char_list = self . _get_codepage_char_list ( encoding ) codepage_char_map = dict ( ( utf8 , i + 128 ) for ( i , utf8 ) in enumerate ( codepage_char_list ) ) self . available_characters [ encoding ] = codepage_char_map return codepage_char_map  def can_encode ( self , encoding , char ) :          available_map = { } try :              available_map = self . _get_codepage_char_map ( encoding )  except LookupError :              return False  is_ascii = ord ( char ) < 128 is_encodable = char in available_map return is_ascii or is_encodable  @ staticmethod def _encode_char ( char , charmap , defaultchar ) :          if ord ( char ) < 128 :              return ord ( char )  if char in charmap :              return charmap [ char ]  return ord ( defaultchar )  def encode ( self , text , encoding , defaultchar = <str> ) :          codepage_char_map = self . _get_codepage_char_map ( encoding ) output_bytes = bytes ( [ self . _encode_char ( char , codepage_char_map , defaultchar ) for char in text ] ) return output_bytes  def __encoding_sort_func ( self , item ) :          key , index = item return ( key in self . used_encodings , index )  def find_suitable_encoding ( self , char ) :          sorted_encodings = sorted ( self . codepages . items ( ) , key = self . __encoding_sort_func ) for encoding , _ in sorted_encodings :              if self . can_encode ( encoding , char ) :                  self . used_encodings . add ( encoding ) return encoding     def split_writable_text ( encoder , text , encoding ) :      if not encoding :          return None , text  for idx , char in enumerate ( text ) :          if encoder . can_encode ( encoding , char ) :              continue  return text [ : idx ] , text [ idx : ]  return text , None  class MagicEncode ( object ) :      def __init__ ( self , driver , encoding = None , disabled = False , defaultsymbol = <str> , encoder = None ) :          if disabled and not encoding :              raise Error ( <str> )  self . driver = driver self . encoder = encoder or Encoder ( driver . profile . get_code_pages ( ) ) self . encoding = self . encoder . get_encoding_name ( encoding ) if encoding else None self . defaultsymbol = defaultsymbol self . disabled = disabled  def force_encoding ( self , encoding ) :          if not encoding :              self . disabled = False  else :              self . write_with_encoding ( encoding , None ) self . disabled = True   def write ( self , text ) :          if self . disabled :              self . write_with_encoding ( self . encoding , text ) return  to_write , text = split_writable_text ( self . encoder , text , self . encoding ) if to_write :              self . write_with_encoding ( self . encoding , to_write )  while text :              encoding = self . encoder . find_suitable_encoding ( text [ 0 ] ) if not encoding :                  self . _handle_character_failed ( text [ 0 ] ) text = text [ 1 : ] continue  to_write , text = split_writable_text ( self . encoder , text , encoding ) if to_write :                  self . write_with_encoding ( encoding , to_write )    def _handle_character_failed ( self , char ) :          self . write ( self . defaultsymbol )  def write_with_encoding ( self , encoding , text ) :          if text is not None and type ( text ) is not six . text_type :              raise Error ( <str> . format ( type = type ( text ) ) )  if encoding != self . encoding :              self . encoding = encoding self . driver . _raw ( CODEPAGE_CHANGE + six . int2byte ( self . encoder . get_sequence ( encoding ) ) )  if text :              self . driver . _raw ( self . encoder . encode ( text , encoding ) )     