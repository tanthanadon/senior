import json from . _2to3 import url_parse from . _client_session import ( BasicSession , ClientSession , CookieSession , IAMSession ) from . database import CloudantDatabase , CouchDatabase from . feed import Feed , InfiniteFeed from . error import ( CloudantArgumentError , CloudantClientException , CloudantDatabaseException , CloudantException ) from . _common_util import ( USER_AGENT , append_response_error_content , CloudFoundryService , response_to_json_dict , ) class CouchDB ( dict ) :      _DATABASE_CLASS = CouchDatabase def __init__ ( self , user , auth_token , admin_party = False , ** kwargs ) :          super ( CouchDB , self ) . __init__ ( ) self . _user = user self . _auth_token = auth_token self . server_url = kwargs . get ( <str> ) self . _client_user_header = None self . admin_party = admin_party self . encoder = kwargs . get ( <str> ) or json . JSONEncoder self . adapter = kwargs . get ( <str> ) self . _timeout = kwargs . get ( <str> , None ) self . r_session = None self . _auto_renew = kwargs . get ( <str> , False ) self . _use_basic_auth = kwargs . get ( <str> , False ) self . _use_iam = kwargs . get ( <str> , False ) self . _iam_client_id = kwargs . get ( <str> , None ) self . _iam_client_secret = kwargs . get ( <str> , None ) if not self . _use_basic_auth and self . server_url :              parsed_url = url_parse ( kwargs . get ( <str> ) ) if parsed_url . port is None :                  self . server_url = parsed_url . _replace ( netloc = <str> . format ( parsed_url . hostname ) ) . geturl ( )  else :                  self . server_url = parsed_url . _replace ( netloc = <str> . format ( parsed_url . hostname , parsed_url . port ) ) . geturl ( )  if ( not user and not auth_token ) and ( parsed_url . username and parsed_url . password ) :                  self . _user = parsed_url . username self . _auth_token = parsed_url . password   self . _features = None connect_to_couch = kwargs . get ( <str> , False ) if connect_to_couch and self . _DATABASE_CLASS == CouchDatabase :              self . connect ( )   @ property def is_iam_authenticated ( self ) :          return self . _use_iam  def features ( self ) :          if self . _features is None :              metadata = self . metadata ( ) if <str> in metadata :                  self . _features = metadata [ <str> ]  else :                  self . _features = [ ]   return self . _features  def connect ( self ) :          if self . r_session :              self . session_logout ( )  if self . admin_party :              self . _use_iam = False self . r_session = ClientSession ( timeout = self . _timeout )  elif self . _use_basic_auth :              self . _use_iam = False self . r_session = BasicSession ( self . _user , self . _auth_token , self . server_url , timeout = self . _timeout )  elif self . _use_iam :              self . r_session = IAMSession ( self . _auth_token , self . server_url , auto_renew = self . _auto_renew , client_id = self . _iam_client_id , client_secret = self . _iam_client_secret , timeout = self . _timeout )  else :              self . r_session = CookieSession ( self . _user , self . _auth_token , self . server_url , auto_renew = self . _auto_renew , timeout = self . _timeout )  if self . adapter is not None :              self . r_session . mount ( self . server_url , self . adapter )  if self . _client_user_header is not None :              self . r_session . headers . update ( self . _client_user_header )  self . session_login ( ) self . r_session . hooks [ <str> ] . append ( append_response_error_content )  def disconnect ( self ) :          if self . r_session :              self . session_logout ( )  self . r_session = None self . clear ( )  def session ( self ) :          return self . r_session . info ( )  def session_cookie ( self ) :          return self . r_session . cookies . get ( <str> )  def session_login ( self , user = None , passwd = None ) :          self . change_credentials ( user = user , auth_token = passwd )  def change_credentials ( self , user = None , auth_token = None ) :          self . r_session . set_credentials ( user , auth_token ) self . r_session . login ( )  def session_logout ( self ) :          self . r_session . logout ( )  def basic_auth_str ( self ) :          return self . r_session . base64_user_pass ( )  def all_dbs ( self ) :          url = <str> . join ( ( self . server_url , <str> ) ) resp = self . r_session . get ( url ) resp . raise_for_status ( ) return response_to_json_dict ( resp )  def create_database ( self , dbname , partitioned = False , ** kwargs ) :          new_db = self . _DATABASE_CLASS ( self , dbname , partitioned = partitioned ) try :              new_db . create ( kwargs . get ( <str> , False ) )  except CloudantDatabaseException as ex :              if ex . status_code == 412 :                  raise CloudantClientException ( 412 , dbname )  raise ex  super ( CouchDB , self ) . __setitem__ ( dbname , new_db ) return new_db  def delete_database ( self , dbname ) :          db = self . _DATABASE_CLASS ( self , dbname ) if not db . exists ( ) :              raise CloudantClientException ( 404 , dbname )  db . delete ( ) if dbname in list ( self . keys ( ) ) :              super ( CouchDB , self ) . __delitem__ ( dbname )   def db_updates ( self , raw_data = False , ** kwargs ) :          return Feed ( self , raw_data , ** kwargs )  def metadata ( self ) :          resp = self . r_session . get ( self . server_url ) resp . raise_for_status ( ) return response_to_json_dict ( resp )  def keys ( self , remote = False ) :          if not remote :              return list ( super ( CouchDB , self ) . keys ( ) )  return self . all_dbs ( )  def __getitem__ ( self , key ) :          if key in list ( self . keys ( ) ) :              return super ( CouchDB , self ) . __getitem__ ( key )  db = self . _DATABASE_CLASS ( self , key ) if db . exists ( ) :              super ( CouchDB , self ) . __setitem__ ( key , db )  else :              raise KeyError ( key )  return db  def __delitem__ ( self , key , remote = False ) :          super ( CouchDB , self ) . __delitem__ ( key ) if remote :              self . delete_database ( key )   def get ( self , key , default = None , remote = False ) :          if not remote :              return super ( CouchDB , self ) . get ( key , default )  db = self . _DATABASE_CLASS ( self , key ) if db . exists ( ) :              super ( CouchDB , self ) . __setitem__ ( key , db ) return db  return default  def __setitem__ ( self , key , value , remote = False ) :          if not isinstance ( value , self . _DATABASE_CLASS ) :              raise CloudantClientException ( 101 , type ( value ) . __name__ )  if remote and not value . exists ( ) :              value . create ( )  super ( CouchDB , self ) . __setitem__ ( key , value )   class Cloudant ( CouchDB ) :      _DATABASE_CLASS = CloudantDatabase def __init__ ( self , cloudant_user , auth_token , ** kwargs ) :          super ( Cloudant , self ) . __init__ ( cloudant_user , auth_token , ** kwargs ) self . _client_user_header = { <str> : USER_AGENT } account = kwargs . get ( <str> ) if account is not None :              self . server_url = <str> . format ( account )  if kwargs . get ( <str> ) is not None :              self . _client_user_header [ <str> ] = kwargs . get ( <str> )  if self . server_url is None :              raise CloudantClientException ( 102 )  if kwargs . get ( <str> , False ) :              self . connect ( )   def db_updates ( self , raw_data = False , ** kwargs ) :          return Feed ( self , raw_data , ** kwargs )  def infinite_db_updates ( self , ** kwargs ) :          return InfiniteFeed ( self , ** kwargs )  def _usage_endpoint ( self , endpoint , year = None , month = None ) :          err = False if year is None and month is None :              resp = self . r_session . get ( endpoint )  else :              try :                  if int ( year ) > 0 and int ( month ) in range ( 1 , 13 ) :                      resp = self . r_session . get ( <str> . join ( ( endpoint , str ( int ( year ) ) , str ( int ( month ) ) ) ) )  else :                      err = True   except ( ValueError , TypeError ) :                  err = True   if err :              raise CloudantArgumentError ( 101 , year , month )  resp . raise_for_status ( ) return response_to_json_dict ( resp )  def bill ( self , year = None , month = None ) :          endpoint = <str> . join ( ( self . server_url , <str> , <str> , <str> ) ) return self . _usage_endpoint ( endpoint , year , month )  def volume_usage ( self , year = None , month = None ) :          endpoint = <str> . join ( ( self . server_url , <str> , <str> , <str> , <str> ) ) return self . _usage_endpoint ( endpoint , year , month )  def requests_usage ( self , year = None , month = None ) :          endpoint = <str> . join ( ( self . server_url , <str> , <str> , <str> , <str> ) ) return self . _usage_endpoint ( endpoint , year , month )  def shared_databases ( self ) :          endpoint = <str> . join ( ( self . server_url , <str> , <str> , <str> , <str> ) ) resp = self . r_session . get ( endpoint ) resp . raise_for_status ( ) data = response_to_json_dict ( resp ) return data . get ( <str> , [ ] )  def generate_api_key ( self ) :          endpoint = <str> . join ( ( self . server_url , <str> , <str> , <str> ) ) resp = self . r_session . post ( endpoint ) resp . raise_for_status ( ) return response_to_json_dict ( resp )  def cors_configuration ( self ) :          endpoint = <str> . join ( ( self . server_url , <str> , <str> , <str> , <str> , <str> ) ) resp = self . r_session . get ( endpoint ) resp . raise_for_status ( ) return response_to_json_dict ( resp )  def disable_cors ( self ) :          return self . update_cors_configuration ( enable_cors = False , allow_credentials = False , origins = [ ] , overwrite_origins = True )  def cors_origins ( self ) :          cors = self . cors_configuration ( ) return cors [ <str> ]  def update_cors_configuration ( self , enable_cors = True , allow_credentials = True , origins = None , overwrite_origins = False ) :          if origins is None :              origins = [ ]  cors_config = { <str> : enable_cors , <str> : allow_credentials , <str> : origins } if overwrite_origins :              return self . _write_cors_configuration ( cors_config )  old_config = self . cors_configuration ( ) updated_config = old_config . copy ( ) updated_config [ <str> ] = cors_config . get ( <str> ) updated_config [ <str> ] = cors_config . get ( <str> ) if cors_config . get ( <str> ) == [ <str> ] :              updated_config [ <str> ] = [ <str> ]  elif old_config . get ( <str> ) != cors_config . get ( <str> ) :              new_origins = list ( set ( old_config . get ( <str> ) ) . union ( set ( cors_config . get ( <str> ) ) ) ) updated_config [ <str> ] = new_origins  return self . _write_cors_configuration ( updated_config )  def _write_cors_configuration ( self , config ) :          endpoint = <str> . join ( ( self . server_url , <str> , <str> , <str> , <str> , <str> ) ) resp = self . r_session . put ( endpoint , data = json . dumps ( config , cls = self . encoder ) , headers = { <str> : <str> } ) resp . raise_for_status ( ) return response_to_json_dict ( resp )  @ classmethod def bluemix ( cls , vcap_services , instance_name = None , service_name = None , ** kwargs ) :          service_name = service_name or <str> try :              service = CloudFoundryService ( vcap_services , instance_name = instance_name , service_name = service_name )  except CloudantException :              raise CloudantClientException ( 103 )  if hasattr ( service , <str> ) :              return Cloudant . iam ( service . username , service . iam_api_key , url = service . url , ** kwargs )  return Cloudant ( service . username , service . password , url = service . url , ** kwargs )  @ classmethod def iam ( cls , account_name , api_key , ** kwargs ) :          return cls ( None , api_key , account = account_name , auto_renew = kwargs . get ( <str> , True ) , use_iam = True , ** kwargs )    