from collections import deque from functools import partial from . _2to3 import STRTYPE from . error import ResultException from . _common_util import py_to_couch_validate , type_or_none class ResultByKey ( object ) :      def __init__ ( self , value ) :          self . _value = value  def __call__ ( self ) :          return self . _value   class Result ( object ) :      def __init__ ( self , method_ref , ** options ) :          self . options = options self . _ref = method_ref self . _page_size = options . pop ( <str> , 100 )  def __getitem__ ( self , arg ) :          data = None if isinstance ( arg , int ) :              data = self . _handle_result_by_index ( arg )  elif isinstance ( arg , ( STRTYPE , list ) ) :              data = self . _handle_result_by_key ( arg )  elif isinstance ( arg , ResultByKey ) :              data = self . _handle_result_by_key ( arg ( ) )  elif isinstance ( arg , slice ) :              if arg . start is None and arg . stop is None :                  data = self . _ref ( ** self . options )  elif ( type_or_none ( ( STRTYPE , list , ResultByKey ) , arg . start ) and type_or_none ( ( STRTYPE , list , ResultByKey ) , arg . stop ) ) :                  data = self . _handle_result_by_key_slice ( arg )  elif ( type_or_none ( int , arg . start ) and type_or_none ( int , arg . stop ) ) :                  data = self . _handle_result_by_idx_slice ( arg )   if data is None :              raise ResultException ( 101 , arg )  return self . _parse_data ( data )  def _handle_result_by_index ( self , idx ) :          if idx < 0 :              return None  opts = dict ( self . options ) skip = opts . pop ( <str> , 0 ) limit = opts . pop ( <str> , None ) py_to_couch_validate ( <str> , skip ) py_to_couch_validate ( <str> , limit ) if limit is not None and idx >= limit :              return dict ( )  return self . _ref ( skip = skip + idx , limit = 1 , ** opts )  def _handle_result_by_key ( self , key ) :          invalid_options = ( <str> , <str> , <str> , <str> ) if any ( x in invalid_options for x in self . options ) :              raise ResultException ( 102 , invalid_options , self . options )  return self . _ref ( key = key , ** self . options )  def _handle_result_by_idx_slice ( self , idx_slice ) :          opts = dict ( self . options ) skip = opts . pop ( <str> , 0 ) limit = opts . pop ( <str> , None ) py_to_couch_validate ( <str> , skip ) py_to_couch_validate ( <str> , limit ) start = idx_slice . start stop = idx_slice . stop data = None if all ( i is not None and i >= 0 for i in [ start , stop ] ) and start < stop :              if limit is not None :                  if start >= limit :                      return dict ( )  if stop > limit :                      return self . _ref ( skip = skip + start , limit = limit - start , ** opts )   data = self . _ref ( skip = skip + start , limit = stop - start , ** opts )  elif start is not None and stop is None and start >= 0 :              if limit is not None :                  if start >= limit :                      return dict ( )  data = self . _ref ( skip = skip + start , limit = limit - start , ** opts )  else :                  data = self . _ref ( skip = skip + start , ** opts )   elif start is None and stop is not None and stop >= 0 :              if limit is not None and stop > limit :                  data = self . _ref ( skip = skip , limit = limit , ** opts )  else :                  data = self . _ref ( skip = skip , limit = stop , ** opts )   return data  def _handle_result_by_key_slice ( self , key_slice ) :          invalid_options = ( <str> , <str> , <str> , <str> ) if any ( x in invalid_options for x in self . options ) :              raise ResultException ( 102 , invalid_options , self . options )  if isinstance ( key_slice . start , ResultByKey ) :              start = key_slice . start ( )  else :              start = key_slice . start  if isinstance ( key_slice . stop , ResultByKey ) :              stop = key_slice . stop ( )  else :              stop = key_slice . stop  if ( start is not None and stop is not None and isinstance ( start , type ( stop ) ) ) :              data = self . _ref ( startkey = start , endkey = stop , ** self . options )  elif start is not None and stop is None :              data = self . _ref ( startkey = start , ** self . options )  elif start is None and stop is not None :              data = self . _ref ( endkey = stop , ** self . options )  else :              data = None  return data  def __iter__ ( self ) :          invalid_options = ( <str> , ) if any ( x in invalid_options for x in self . options ) :              raise ResultException ( 103 , invalid_options , self . options )  try :              self . _page_size = int ( self . _page_size ) if self . _page_size <= 0 :                  raise ResultException ( 104 , self . _page_size )   except ValueError :              raise ResultException ( 104 , self . _page_size )  init_opts = { <str> : self . options . pop ( <str> , None ) , <str> : self . options . pop ( <str> , None ) } self . _call = partial ( self . _ref , limit = self . _real_page_size , ** self . options ) response = self . _call ( ** { k : v for k , v in init_opts . items ( ) if v is not None } ) return self . _iterator ( response )  @ property def _real_page_size ( self ) :          return self . _page_size + 1  def _iterator ( self , response ) :          while True :              result = deque ( self . _parse_data ( response ) ) del response if result :                  doc_count = len ( result ) last = result . pop ( ) while result :                      yield result . popleft ( )  if doc_count < self . _real_page_size :                      yield last break  del result if last [ <str> ] :                      response = self . _call ( startkey = last [ <str> ] , startkey_docid = last [ <str> ] )  else :                      response = self . _call ( startkey = last [ <str> ] )   else :                  break    def _parse_data ( self , data ) :          return data . get ( <str> , [ ] )  def all ( self ) :          return self [ : ]   class QueryResult ( Result ) :      def __init__ ( self , query , ** options ) :          if <str> in query and <str> not in options :              options [ <str> ] = query [ <str> ]  if <str> in query and <str> not in options :              options [ <str> ] = query [ <str> ]  super ( QueryResult , self ) . __init__ ( query , ** options )  def __getitem__ ( self , arg ) :          if ( ( isinstance ( arg , int ) ) or ( isinstance ( arg , slice ) and type_or_none ( int , arg . start ) and type_or_none ( int , arg . stop ) ) ) :              return super ( QueryResult , self ) . __getitem__ ( arg )  raise ResultException ( 101 , arg )  def _parse_data ( self , data ) :          return data . get ( <str> , [ ] )  @ property def _real_page_size ( self ) :          return self . _page_size  def _iterator ( self , response ) :          while True :              result = self . _parse_data ( response ) bookmark = response . get ( <str> ) if result :                  for row in result :                      yield row  del result if not bookmark :                      break  response = self . _call ( bookmark = bookmark )  else :                  break      