import json import contextlib from . _2to3 import iteritems_ from . result import QueryResult from . error import CloudantArgumentError from . _common_util import QUERY_ARG_TYPES from . _common_util import response_to_json_dict class Query ( dict ) :      def __init__ ( self , database , ** kwargs ) :          super ( Query , self ) . __init__ ( ) self . _database = database self . _partition_key = kwargs . pop ( <str> , None ) self . _r_session = self . _database . r_session self . _encoder = self . _database . client . encoder if kwargs . get ( <str> , True ) is None :              del kwargs [ <str> ]  if kwargs :              super ( Query , self ) . update ( kwargs )  self . result = QueryResult ( self )  @ property def url ( self ) :          if self . _partition_key :              base_url = self . _database . database_partition_url ( self . _partition_key )  else :              base_url = self . _database . database_url  return base_url + <str>  def __call__ ( self , ** kwargs ) :          data = dict ( self ) data . update ( kwargs ) for key , val in iteritems_ ( data ) :              if key not in list ( QUERY_ARG_TYPES . keys ( ) ) :                  raise CloudantArgumentError ( 129 , key )  if not isinstance ( val , QUERY_ARG_TYPES [ key ] ) :                  raise CloudantArgumentError ( 130 , key , QUERY_ARG_TYPES [ key ] )   if data . get ( <str> , None ) is None or data . get ( <str> ) == { } :              raise CloudantArgumentError ( 131 )  headers = { <str> : <str> } resp = self . _r_session . post ( self . url , headers = headers , data = json . dumps ( data , cls = self . _encoder ) ) resp . raise_for_status ( ) return response_to_json_dict ( resp )  @ contextlib . contextmanager def custom_result ( self , ** options ) :          rslt = QueryResult ( self , ** options ) yield rslt del rslt    