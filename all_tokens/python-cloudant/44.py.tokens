import sys import platform import json from . _2to3 import LONGTYPE , STRTYPE , NONETYPE , UNITYPE , iteritems_ from . error import CloudantArgumentError , CloudantException , CloudantClientException try :      from collections . abc import Sequence  except ImportError :      from collections import Sequence  USER_AGENT = <str> . join ( [ <str> , sys . modules [ <str> ] . __version__ , <str> , <str> . format ( sys . version_info [ 0 ] , sys . version_info [ 1 ] , sys . version_info [ 2 ] ) , platform . system ( ) , platform . machine ( ) ] ) QUERY_LANGUAGE = <str> JSON_INDEX_TYPE = <str> TEXT_INDEX_TYPE = <str> SPECIAL_INDEX_TYPE = <str> ANY_ARG = object ( ) ANY_TYPE = object ( ) RESULT_ARG_TYPES = { <str> : ( bool , ) , <str> : ( int , LONGTYPE , STRTYPE , Sequence , ) , <str> : ( STRTYPE , ) , <str> : ( bool , ) , <str> : ( int , LONGTYPE , NONETYPE , ) , <str> : ( bool , ) , <str> : ( bool , ) , <str> : ( int , LONGTYPE , STRTYPE , Sequence , ) , <str> : ( list , ) , <str> : ( int , LONGTYPE , NONETYPE , ) , <str> : ( bool , ) , <str> : ( int , LONGTYPE , NONETYPE , ) , <str> : ( bool , ) , <str> : ( STRTYPE , ) , <str> : ( int , LONGTYPE , STRTYPE , Sequence , ) , <str> : ( STRTYPE , ) , <str> : ( STRTYPE , ) , } TYPE_CONVERTERS = { STRTYPE : lambda x : json . dumps ( x ) , str : lambda x : json . dumps ( x ) , UNITYPE : lambda x : json . dumps ( x ) , Sequence : lambda x : json . dumps ( list ( x ) ) , list : lambda x : json . dumps ( x ) , tuple : lambda x : json . dumps ( list ( x ) ) , int : lambda x : x , LONGTYPE : lambda x : x , bool : lambda x : <str> if x else <str> , NONETYPE : lambda x : x } _COUCH_DB_UPDATES_ARG_TYPES = { <str> : ( STRTYPE , ) , <str> : ( bool , ) , <str> : ( int , LONGTYPE , NONETYPE , ) , } _DB_UPDATES_ARG_TYPES = { <str> : ( bool , ) , <str> : ( int , LONGTYPE , NONETYPE , ) , <str> : ( int , LONGTYPE , STRTYPE , ) , } _DB_UPDATES_ARG_TYPES . update ( _COUCH_DB_UPDATES_ARG_TYPES ) _DB_UPDATES_ARG_TYPES [ <str> ] = ( int , LONGTYPE , NONETYPE , ) _CHANGES_ARG_TYPES = { <str> : ( bool , ) , <str> : ( list , ) , <str> : ( STRTYPE , ) , <str> : ( bool , ) , <str> : ( STRTYPE , ) , ANY_ARG : ANY_TYPE } _CHANGES_ARG_TYPES . update ( _DB_UPDATES_ARG_TYPES ) QUERY_ARG_TYPES = { <str> : dict , <str> : ( int , LONGTYPE , NONETYPE ) , <str> : ( int , LONGTYPE , NONETYPE ) , <str> : list , <str> : list , <str> : ( int , LONGTYPE , NONETYPE ) , <str> : STRTYPE , <str> : STRTYPE } TEXT_INDEX_ARGS = { <str> : list , <str> : dict , <str> : dict } SEARCH_INDEX_ARGS = { <str> : STRTYPE , <str> : list , <str> : list , <str> : STRTYPE , <str> : ( int , NONETYPE ) , <str> : ( STRTYPE , list ) , <str> : bool , <str> : ( int , NONETYPE ) , <str> : ( STRTYPE , int , LONGTYPE ) , <str> : ( STRTYPE , int , LONGTYPE ) , <str> : dict , <str> : ( STRTYPE , list ) , <str> : STRTYPE , <str> : list , <str> : STRTYPE , <str> : STRTYPE , <str> : ( int , LONGTYPE , NONETYPE ) , <str> : ( int , LONGTYPE , NONETYPE ) , <str> : list , <str> : STRTYPE } def feed_arg_types ( feed_type ) :      if feed_type == <str> :          return _DB_UPDATES_ARG_TYPES  if feed_type == <str> :          return _COUCH_DB_UPDATES_ARG_TYPES  return _CHANGES_ARG_TYPES  def python_to_couch ( options ) :      translation = dict ( ) for key , val in iteritems_ ( options ) :          py_to_couch_validate ( key , val ) translation . update ( _py_to_couch_translate ( key , val ) )  return translation  def py_to_couch_validate ( key , val ) :      if key not in RESULT_ARG_TYPES :          raise CloudantArgumentError ( 116 , key )  if ( not isinstance ( val , RESULT_ARG_TYPES [ key ] ) or ( type ( val ) is bool and int in RESULT_ARG_TYPES [ key ] ) ) :          raise CloudantArgumentError ( 117 , key , RESULT_ARG_TYPES [ key ] )  if key == <str> :          for key_list_val in val :              if ( not isinstance ( key_list_val , RESULT_ARG_TYPES [ <str> ] ) or type ( key_list_val ) is bool ) :                  raise CloudantArgumentError ( 134 , RESULT_ARG_TYPES [ <str> ] )    if key == <str> :          if val not in ( <str> , <str> ) :              raise CloudantArgumentError ( 135 , val )    def _py_to_couch_translate ( key , val ) :      try :          if key in [ <str> , <str> , <str> , <str> , <str> ] :              return { key : val }  if val is None :              return { key : None }  arg_converter = TYPE_CONVERTERS . get ( type ( val ) ) return { key : arg_converter ( val ) }  except Exception as ex :          raise CloudantArgumentError ( 136 , key , ex )   def type_or_none ( typerefs , value ) :      return isinstance ( value , typerefs ) or value is None  def codify ( code_or_str ) :      if code_or_str is None :          return None  if not isinstance ( code_or_str , _Code ) :          return _Code ( code_or_str )  return code_or_str  def get_docs ( r_session , url , encoder = None , headers = None , ** params ) :      keys_list = params . pop ( <str> , None ) keys = None if keys_list is not None :          keys = json . dumps ( { <str> : keys_list } , cls = encoder )  f_params = python_to_couch ( params ) resp = None if keys is not None :          if headers is None :              headers = { }  headers [ <str> ] = <str> resp = r_session . post ( url , headers = headers , params = f_params , data = keys )  else :          resp = r_session . get ( url , headers = headers , params = f_params )  resp . raise_for_status ( ) return resp  def append_response_error_content ( response , ** kwargs ) :      if response . status_code >= 400 :          try :              resp_dict = response_to_json_dict ( response ) error = resp_dict . get ( <str> , <str> ) reason = resp_dict . get ( <str> , <str> ) response . reason += <str> . format ( error , reason )  except ValueError :              pass   return response  def response_to_json_dict ( response , ** kwargs ) :      if response . encoding is None :          response . encoding = <str>  return json . loads ( response . text , ** kwargs )  class _Code ( str ) :      def __new__ ( cls , code ) :          if type ( code ) . __name__ == <str> :              return str . __new__ ( cls , code . encode ( <str> ) )  return str . __new__ ( cls , code )   class CloudFoundryService ( object ) :      def __init__ ( self , vcap_services , instance_name = None , service_name = None ) :          try :              services = vcap_services if not isinstance ( vcap_services , dict ) :                  services = json . loads ( vcap_services )  cloudant_services = services . get ( service_name , [ ] ) use_first = instance_name is None and len ( cloudant_services ) == 1 for service in cloudant_services :                  if use_first or service . get ( <str> ) == instance_name :                      credentials = service [ <str> ] self . _host = credentials [ <str> ] self . _name = service . get ( <str> ) self . _port = credentials . get ( <str> , 443 ) self . _username = credentials [ <str> ] if <str> in credentials :                          self . _iam_api_key = credentials [ <str> ]  elif <str> in credentials and <str> in credentials :                          self . _password = credentials [ <str> ]  else :                          raise CloudantClientException ( 103 )  break   else :                  raise CloudantException ( <str> )   except KeyError as ex :              raise CloudantException ( <str> . format ( ex . args [ 0 ] ) )  except TypeError :              raise CloudantException ( <str> )  except ValueError :              raise CloudantException ( <str> )   @ property def host ( self ) :          return self . _host  @ property def name ( self ) :          return self . _name  @ property def password ( self ) :          return self . _password  @ property def port ( self ) :          return str ( self . _port )  @ property def url ( self ) :          return <str> . format ( self . _host , self . _port )  @ property def username ( self ) :          return self . _username  @ property def iam_api_key ( self ) :          return self . _iam_api_key    