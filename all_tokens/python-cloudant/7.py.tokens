import json import os import unittest from cloudant . _2to3 import unicode_ from cloudant . error import CloudantArgumentError from cloudant . feed import Feed from nose . plugins . attrib import attr from requests import Session from . unit_t_db_base import UnitTestDbBase from . . import BYTETYPE class DbUpdatesTestsBase ( UnitTestDbBase ) :      def setUp ( self ) :          super ( DbUpdatesTestsBase , self ) . setUp ( ) self . client . connect ( ) self . db_names = list ( ) self . new_dbs = list ( ) if not self . is_couchdb_1x_version ( ) :              self . create_db_updates ( ) self . create_dbs ( )   def tearDown ( self ) :          test_dbs_deleted = False changes = list ( ) [ db . delete ( ) for db in self . new_dbs ] if not self . is_couchdb_1x_version ( ) :              while not test_dbs_deleted and not self . is_couchdb_1x_version ( ) :                  feed = Feed ( self . client , timeout = 1000 ) for change in feed :                      if change [ <str> ] in self . db_names and change [ <str> ] == <str> :                          changes . append ( change )  if len ( changes ) == 2 :                          test_dbs_deleted = True feed . stop ( )    self . delete_db_updates ( )  self . client . disconnect ( ) super ( DbUpdatesTestsBase , self ) . tearDown ( )  def create_dbs ( self ) :          if not self . is_couchdb_1x_version ( ) :              self . db_names = [ self . dbname ( ) for x in range ( 2 ) ] self . new_dbs += [ self . client . create_database ( dbname ) for dbname in self . db_names ] all_dbs_exist = False while not all_dbs_exist :                  changes = list ( ) feed = Feed ( self . client , timeout = 1000 ) for change in feed :                      changes . append ( change ) if len ( changes ) == 3 :                              all_dbs_exist = True feed . stop ( )     else :              self . new_dbs += [ ( self . client . create_database ( self . dbname ( ) ) ) for x in range ( 3 ) ]   def assert_changes_in_db_updates_feed ( self , changes ) :          if not self . is_couchdb_1x_version ( ) :              self . dbs = [ <str> , self . new_dbs [ 0 ] . database_name , self . new_dbs [ 1 ] . database_name ] types = [ <str> , <str> ] for doc in changes :                  self . assertIsNotNone ( doc [ <str> ] ) self . assertTrue ( doc [ <str> ] in self . dbs ) self . assertTrue ( doc [ <str> ] in types )   else :              self . assertDictEqual ( changes [ 0 ] , { <str> : self . new_dbs [ 0 ] . database_name , <str> : <str> } ) self . assertDictEqual ( changes [ 1 ] , { <str> : self . new_dbs [ 1 ] . database_name , <str> : <str> } ) self . assertDictEqual ( changes [ 2 ] , { <str> : self . new_dbs [ 2 ] . database_name , <str> : <str> } )    @ attr ( db = <str> ) class CouchDbUpdatesTests ( DbUpdatesTestsBase ) :      def test_constructor_db_updates ( self ) :          feed = Feed ( self . client , feed = <str> , heartbeat = False , timeout = 2 ) self . assertEqual ( feed . _url , <str> . join ( [ self . client . server_url , <str> ] ) ) self . assertIsInstance ( feed . _r_session , Session ) self . assertFalse ( feed . _raw_data ) self . assertDictEqual ( feed . _options , { <str> : <str> , <str> : False , <str> : 2 } )  def test_stop_iteration_of_continuous_feed_with_heartbeat ( self ) :          feed = Feed ( self . client , feed = <str> , timeout = 100 ) changes = list ( ) for change in feed :              if not change and self . is_couchdb_1x_version ( ) :                  self . create_dbs ( )  else :                  changes . append ( change ) if len ( changes ) == 3 :                      feed . stop ( )    self . assert_changes_in_db_updates_feed ( changes ) self . assertEqual ( len ( changes ) , 3 )  def test_get_raw_content ( self ) :          feed = Feed ( self . client , raw_data = True , feed = <str> , timeout = 100 ) raw_content = list ( ) for raw_line in feed :              self . assertIsInstance ( raw_line , BYTETYPE ) if not raw_line and self . is_couchdb_1x_version ( ) :                  self . create_dbs ( )  else :                  raw_content . append ( raw_line ) if len ( raw_content ) == 3 :                      feed . stop ( )    changes = [ json . loads ( unicode_ ( x ) ) for x in raw_content ] self . assert_changes_in_db_updates_feed ( changes )  def test_get_longpoll_feed_as_default ( self ) :          feed = Feed ( self . client , timeout = 1000 ) changes = list ( ) if self . is_couchdb_1x_version ( ) :              for change in feed :                  self . assertIsNone ( change ) changes . append ( change )  self . assertEqual ( len ( changes ) , 1 ) self . assertIsNone ( changes [ 0 ] )  else :              for change in feed :                  self . assertIsNotNone ( change ) changes . append ( change ) if len ( changes ) == 3 :                      feed . stop ( )   self . assert_changes_in_db_updates_feed ( changes ) self . assertEqual ( len ( changes ) , 3 )   def test_get_longpoll_feed_explicit ( self ) :          feed = Feed ( self . client , timeout = 1000 , feed = <str> ) changes = list ( ) if self . is_couchdb_1x_version ( ) :              for change in feed :                  self . assertIsNone ( change ) changes . append ( change )  self . assertEqual ( len ( changes ) , 1 ) self . assertIsNone ( changes [ 0 ] )  else :              for change in feed :                  self . assertIsNotNone ( change ) changes . append ( change ) if len ( changes ) == 3 :                      feed . stop ( )   self . assert_changes_in_db_updates_feed ( changes ) self . assertEqual ( len ( changes ) , 3 )   def test_get_continuous_with_timeout ( self ) :          feed = Feed ( self . client , feed = <str> , heartbeat = False , timeout = 1000 ) changes = list ( ) if self . is_couchdb_1x_version ( ) :              self . assertListEqual ( [ x for x in feed ] , [ ] )  else :              for change in feed :                  self . assertIsNotNone ( change ) changes . append ( change ) if len ( changes ) == 3 :                      feed . stop ( )   self . assert_changes_in_db_updates_feed ( changes ) self . assertEqual ( len ( changes ) , 3 )   def test_invalid_argument ( self ) :          feed = Feed ( self . client , foo = <str> ) with self . assertRaises ( CloudantArgumentError ) as cm :              invalid_feed = [ x for x in feed ]  self . assertEqual ( str ( cm . exception ) , <str> ) feed = Feed ( self . client , style = <str> ) with self . assertRaises ( CloudantArgumentError ) as cm :              invalid_feed = [ x for x in feed ]  self . assertEqual ( str ( cm . exception ) , <str> ) feed = Feed ( self . client , descending = True ) with self . assertRaises ( CloudantArgumentError ) as cm :              invalid_feed = [ x for x in feed ]  self . assertEqual ( str ( cm . exception ) , <str> )  def test_invalid_argument_type ( self ) :          feed = Feed ( self . client , heartbeat = 6 ) with self . assertRaises ( CloudantArgumentError ) as cm :              invalid_feed = [ x for x in feed ]  self . assertTrue ( str ( cm . exception ) . startswith ( <str> ) )  def test_invalid_non_positive_integer_argument ( self ) :          feed = Feed ( self . client , timeout = - 1 ) with self . assertRaises ( CloudantArgumentError ) as cm :              invalid_feed = [ x for x in feed ]  self . assertEqual ( str ( cm . exception ) , <str> )  def test_invalid_feed_value ( self ) :          feed = Feed ( self . client , feed = <str> ) with self . assertRaises ( CloudantArgumentError ) as cm :              invalid_feed = [ x for x in feed ]  self . assertTrue ( str ( cm . exception ) . startswith ( <str> ) ) feed = Feed ( self . client , feed = <str> ) with self . assertRaises ( CloudantArgumentError ) as cm :              invalid_feed = [ x for x in feed ]  self . assertTrue ( str ( cm . exception ) . startswith ( <str> ) )   @ attr ( db = <str> ) @ unittest . skipIf ( os . environ . get ( <str> ) , <str> ) class CloudantDbUpdatesTests ( DbUpdatesTestsBase ) :      def test_constructor_db_updates ( self ) :          feed = Feed ( self . client , feed = <str> , heartbeat = 5000 ) self . assertEqual ( feed . _url , <str> . join ( [ self . client . server_url , <str> ] ) ) self . assertIsInstance ( feed . _r_session , Session ) self . assertFalse ( feed . _raw_data ) self . assertDictEqual ( feed . _options , { <str> : <str> , <str> : 5000 } )  def test_get_last_seq ( self ) :          self . create_dbs ( 1 ) feed = Feed ( self . client , since = <str> ) self . assertIsNone ( feed . last_seq ) [ x for x in feed ] self . assertIsNotNone ( feed . last_seq )  def test_stop_iteration_of_continuous_feed_using_since_now ( self ) :          feed = Feed ( self . client , feed = <str> , since = <str> ) count = 0 changes = list ( ) for change in feed :              self . assertTrue ( all ( x in change for x in ( <str> , <str> ) ) ) changes . append ( change ) count += 1 if count == 2 :                  feed . stop ( )   self . assertEqual ( len ( changes ) , 2 ) self . assertTrue ( changes [ 0 ] [ <str> ] < changes [ 1 ] [ <str> ] ) self . assertIsNone ( feed . last_seq )  def test_get_raw_content ( self ) :          self . create_dbs ( 3 ) feed = Feed ( self . client , limit = 3 , raw_data = True ) raw_content = list ( ) for raw_line in feed :              self . assertIsInstance ( raw_line , BYTETYPE ) raw_content . append ( raw_line )  changes = json . loads ( <str> . join ( [ unicode_ ( x ) for x in raw_content ] ) ) self . assertSetEqual ( set ( changes . keys ( ) ) , set ( [ <str> , <str> ] ) ) self . assertEqual ( len ( changes [ <str> ] ) , 3 ) self . assertIsNotNone ( changes [ <str> ] ) self . assertIsNone ( feed . last_seq )  def test_get_normal_feed_default ( self ) :          feed = Feed ( self . client , limit = 3 ) changes = list ( ) for change in feed :              self . assertTrue ( all ( x in change for x in ( <str> , <str> ) ) ) changes . append ( change )  self . assertEqual ( len ( changes ) , 3 ) self . assertTrue ( changes [ 0 ] [ <str> ] < changes [ 1 ] [ <str> ] < changes [ 2 ] [ <str> ] ) self . assertIsNotNone ( feed . last_seq )  def test_get_normal_feed_explicit ( self ) :          feed = Feed ( self . client , feed = <str> , limit = 3 ) changes = list ( ) for change in feed :              self . assertTrue ( all ( x in change for x in ( <str> , <str> ) ) ) changes . append ( change )  self . assertEqual ( len ( changes ) , 3 ) self . assertTrue ( changes [ 0 ] [ <str> ] < changes [ 1 ] [ <str> ] < changes [ 2 ] [ <str> ] ) self . assertIsNotNone ( feed . last_seq )  def test_get_longpoll_feed ( self ) :          feed = Feed ( self . client , feed = <str> , limit = 3 ) changes = list ( ) for change in feed :              self . assertTrue ( all ( x in change for x in ( <str> , <str> ) ) ) changes . append ( change )  self . assertEqual ( len ( changes ) , 3 ) self . assertIsNotNone ( feed . last_seq )  def test_get_feed_with_heartbeat ( self ) :          feed = Feed ( self . client , feed = <str> , since = <str> , heartbeat = 1000 ) changes = list ( ) heartbeats = 0 for change in feed :              if not change :                  self . assertIsNone ( change ) heartbeats += 1 if heartbeats < 4 :                      self . create_dbs ( 1 )   else :                  self . assertTrue ( all ( x in change for x in ( <str> , <str> ) ) ) if len ( changes ) < 3 :                      changes . append ( change )   if heartbeats >= 3 and len ( changes ) == 3 :                  feed . stop ( )   self . assertTrue ( changes [ 0 ] [ <str> ] < changes [ 1 ] [ <str> ] < changes [ 2 ] [ <str> ] ) self . assertIsNone ( feed . last_seq )  def test_get_raw_feed_with_heartbeat ( self ) :          feed = Feed ( self . client , raw_data = True , feed = <str> , since = <str> , heartbeat = 1000 ) raw_content = list ( ) heartbeats = 0 for raw_line in feed :              if not raw_line :                  self . assertEqual ( len ( raw_line ) , 0 ) heartbeats += 1 if heartbeats < 4 :                      self . create_dbs ( 1 )   else :                  self . assertIsInstance ( raw_line , BYTETYPE ) raw_content . append ( raw_line )  if heartbeats >= 3 and len ( raw_content ) >= 3 :                  feed . stop ( )   changes = [ json . loads ( unicode_ ( x ) ) for x in raw_content ] self . assertTrue ( changes [ 0 ] [ <str> ] < changes [ 1 ] [ <str> ] < changes [ 2 ] [ <str> ] ) self . assertIsNone ( feed . last_seq )  def test_get_feed_descending ( self ) :          self . create_dbs ( 3 ) feed = Feed ( self . client , limit = 3 , descending = True ) changes = list ( ) for change in feed :              self . assertTrue ( all ( x in change for x in ( <str> , <str> ) ) ) changes . append ( change )  self . assertEqual ( len ( changes ) , 3 ) self . assertTrue ( changes [ 0 ] [ <str> ] > changes [ 1 ] [ <str> ] > changes [ 2 ] [ <str> ] ) self . assertIsNotNone ( feed . last_seq )  def test_get_feed_using_since ( self ) :          self . create_dbs ( 1 ) feed = Feed ( self . client , since = <str> ) [ x for x in feed ] last_seq = feed . last_seq self . create_dbs ( 3 ) feed = Feed ( self . client , since = last_seq ) for change in feed :              self . assertTrue ( all ( x in change for x in ( <str> , <str> ) ) )  self . assertTrue ( feed . last_seq > last_seq )  def test_get_feed_using_timeout ( self ) :          feed = Feed ( self . client , feed = <str> , since = <str> , timeout = 1000 ) count = 0 self . create_dbs ( 1 ) for change in feed :              self . assertTrue ( all ( x in change for x in ( <str> , <str> ) ) ) count += 1 if count == 15 :                  feed . stop ( )   self . assertIsNotNone ( feed . last_seq )  def test_invalid_argument ( self ) :          feed = Feed ( self . client , foo = <str> ) with self . assertRaises ( CloudantArgumentError ) as cm :              invalid_feed = [ x for x in feed ]  self . assertEqual ( str ( cm . exception ) , <str> ) feed = Feed ( self . client , style = <str> ) with self . assertRaises ( CloudantArgumentError ) as cm :              invalid_feed = [ x for x in feed ]  self . assertEqual ( str ( cm . exception ) , <str> )  def test_invalid_argument_type ( self ) :          feed = Feed ( self . client , descending = 6 ) with self . assertRaises ( CloudantArgumentError ) as cm :              invalid_feed = [ x for x in feed ]  self . assertTrue ( str ( cm . exception ) . startswith ( <str> ) )  def test_invalid_non_positive_integer_argument ( self ) :          feed = Feed ( self . client , limit = - 1 ) with self . assertRaises ( CloudantArgumentError ) as cm :              invalid_feed = [ x for x in feed ]  self . assertEqual ( str ( cm . exception ) , <str> )  def test_invalid_feed_value ( self ) :          feed = Feed ( self . client , feed = <str> ) with self . assertRaises ( CloudantArgumentError ) as cm :              invalid_feed = [ x for x in feed ]  self . assertTrue ( str ( cm . exception ) . startswith ( <str> ) )   if __name__ == <str> :      unittest . main ( )   