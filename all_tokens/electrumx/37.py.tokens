from ipaddress import ip_address , IPv4Address , IPv6Address , IPv4Network , IPv6Network from socket import AF_INET , AF_INET6 from aiorpcx import is_valid_hostname from electrumx . lib . util import cachedproperty , protocol_tuple , version_string class Peer ( object ) :      ATTRS = ( <str> , <str> , <str> , <str> , <str> , <str> , <str> ) FEATURES = ( <str> , <str> , <str> , <str> , <str> , <str> ) DEFAULT_PORTS = { } def __init__ ( self , host , features , source = <str> , ip_addr = None , last_good = 0 , last_try = 0 , try_count = 0 ) :          assert isinstance ( host , str ) assert isinstance ( features , dict ) assert host in features . get ( <str> , { } ) self . host = host self . features = features . copy ( ) for feature in self . FEATURES :              self . features [ feature ] = getattr ( self , feature )  self . source = source self . ip_addr = ip_addr self . last_good = last_good self . last_try = last_try self . try_count = try_count self . bad = False self . other_port_pairs = set ( )  @ classmethod def peers_from_features ( cls , features , source ) :          peers = [ ] if isinstance ( features , dict ) :              hosts = features . get ( <str> ) if isinstance ( hosts , dict ) :                  peers = [ Peer ( host , features , source = source ) for host in hosts if isinstance ( host , str ) ]   return peers  @ classmethod def deserialize ( cls , item ) :          return cls ( ** item )  def matches ( self , peers ) :          candidates = ( self . host . lower ( ) , self . ip_addr ) return [ peer for peer in peers if peer . host . lower ( ) in candidates or peer . ip_addr == self . host ]  def __str__ ( self ) :          return self . host  def update_features ( self , features ) :          try :              tmp = Peer ( self . host , features )  except AssertionError :              pass  else :              self . update_features_from_peer ( tmp )   def update_features_from_peer ( self , peer ) :          if peer != self :              self . features = peer . features for feature in self . FEATURES :                  setattr ( self , feature , getattr ( peer , feature ) )    def connection_tuples ( self ) :          pairs = [ ( <str> , self . ssl_port ) , ( <str> , self . tcp_port ) ] while self . other_port_pairs :              pairs . append ( self . other_port_pairs . pop ( ) )  if isinstance ( self . ip_address , IPv4Address ) :              families = [ AF_INET ]  elif isinstance ( self . ip_address , IPv6Address ) :              families = [ AF_INET6 ]  else :              families = [ AF_INET , AF_INET6 ]  return [ ( kind , port , family ) for kind , port in pairs if port for family in families ]  def mark_bad ( self ) :          self . bad = True  def check_ports ( self , other ) :          if other . ssl_port != self . ssl_port :              self . other_port_pairs . add ( ( <str> , other . ssl_port ) )  if other . tcp_port != self . tcp_port :              self . other_port_pairs . add ( ( <str> , other . tcp_port ) )  return bool ( self . other_port_pairs )  @ cachedproperty def is_tor ( self ) :          return self . host . endswith ( <str> )  @ cachedproperty def is_valid ( self ) :          ip = self . ip_address if ip :              return ( ( ip . is_global or ip . is_private ) and not ( ip . is_multicast or ip . is_unspecified ) )  return is_valid_hostname ( self . host )  @ cachedproperty def is_public ( self ) :          ip = self . ip_address if ip :              return self . is_valid and not ip . is_private  else :              return self . is_valid and self . host != <str>   @ cachedproperty def ip_address ( self ) :          try :              return ip_address ( self . host )  except ValueError :              return None   def bucket_for_internal_purposes ( self ) :          if self . is_tor :              return <str>  if not self . ip_addr :              return <str>  ip_addr = ip_address ( self . ip_addr ) if ip_addr . version == 4 :              return str ( ip_addr )  elif ip_addr . version == 6 :              slash64 = IPv6Network ( self . ip_addr ) . supernet ( prefixlen_diff = 128 - 64 ) return str ( slash64 )  return <str>  def bucket_for_external_interface ( self ) :          if self . is_tor :              return <str>  if not self . ip_addr :              return <str>  ip_addr = ip_address ( self . ip_addr ) if ip_addr . version == 4 :              slash16 = IPv4Network ( self . ip_addr ) . supernet ( prefixlen_diff = 32 - 16 ) return str ( slash16 )  elif ip_addr . version == 6 :              slash56 = IPv6Network ( self . ip_addr ) . supernet ( prefixlen_diff = 128 - 56 ) return str ( slash56 )  return <str>  def serialize ( self ) :          return { attr : getattr ( self , attr ) for attr in self . ATTRS }  def _port ( self , key ) :          hosts = self . features . get ( <str> ) if isinstance ( hosts , dict ) :              host = hosts . get ( self . host ) port = self . _integer ( key , host ) if port and 0 < port < 65536 :                  return port   return None  def _integer ( self , key , d = None ) :          d = d or self . features result = d . get ( key ) if isinstance ( d , dict ) else None if isinstance ( result , str ) :              try :                  result = int ( result )  except ValueError :                  pass   return result if isinstance ( result , int ) else None  def _string ( self , key ) :          result = self . features . get ( key ) return result if isinstance ( result , str ) else None  @ cachedproperty def genesis_hash ( self ) :          return self . _string ( <str> )  @ cachedproperty def ssl_port ( self ) :          return self . _port ( <str> )  @ cachedproperty def tcp_port ( self ) :          return self . _port ( <str> )  @ cachedproperty def server_version ( self ) :          return self . _string ( <str> )  @ cachedproperty def pruning ( self ) :          pruning = self . _integer ( <str> ) if pruning and pruning > 0 :              return pruning  return None  def _protocol_version_string ( self , key ) :          version_str = self . features . get ( key ) ptuple = protocol_tuple ( version_str ) return version_string ( ptuple )  @ cachedproperty def protocol_min ( self ) :          return self . _protocol_version_string ( <str> )  @ cachedproperty def protocol_max ( self ) :          return self . _protocol_version_string ( <str> )  def to_tuple ( self ) :          details = self . real_name ( ) . split ( ) [ 1 : ] return ( self . ip_addr or self . host , self . host , details )  def real_name ( self ) :          def port_text ( letter , port ) :              if port == self . DEFAULT_PORTS . get ( letter ) :                  return letter  else :                  return letter + str ( port )   parts = [ self . host , <str> + self . protocol_max ] if self . pruning :              parts . append ( <str> . format ( self . pruning ) )  for letter , port in ( ( <str> , self . ssl_port ) , ( <str> , self . tcp_port ) ) :              if port :                  parts . append ( port_text ( letter , port ) )   return <str> . join ( parts )  @ classmethod def from_real_name ( cls , real_name , source ) :          host = <str> features = { } ports = { } for n , part in enumerate ( real_name . split ( ) ) :              if n == 0 :                  host = part continue  if part [ 0 ] in ( <str> , <str> ) :                  if len ( part ) == 1 :                      port = cls . DEFAULT_PORTS [ part [ 0 ] ]  else :                      port = part [ 1 : ]  if part [ 0 ] == <str> :                      ports [ <str> ] = port  else :                      ports [ <str> ] = port   elif part [ 0 ] == <str> :                  features [ <str> ] = features [ <str> ] = part [ 1 : ]  elif part [ 0 ] == <str> :                  features [ <str> ] = part [ 1 : ]   features . update ( ports ) features [ <str> ] = { host : ports } return cls ( host , features , source )    