import log from torrent2http import State , Engine , MediaType , Encryption from base import TorrentPlayer import urlparse , urllib , time , filesystem , xbmc , xbmcaddon def path2url ( path ) : 	 return urlparse . urljoin ( <str> , urllib . pathname2url ( path ) )  _ADDON_NAME = <str> _addon = xbmcaddon . Addon ( id = _ADDON_NAME ) dht_routers = [ <str> , <str> ] user_agent = <str> def getSetting ( settings_name ) : 	 return _addon . getSetting ( settings_name )  class Torrent2HTTPPlayer ( TorrentPlayer ) : 	 def debug ( self , msg ) : 		 try : 			 import log log . debug ( <str> % msg )  except : 			 pass   def debug_assignment ( self , value , varname ) : 		 try : 			 self . debug ( <str> % ( varname , str ( value ) ) )  except : 			 pass  return value  def __init__ ( self , settings ) : 		 self . engine = None self . file_id = None self . settings = settings self . download_path = None self . pre_buffer_bytes = self . debug_assignment ( int ( getSetting ( <str> ) ) * 1024 * 1024 , <str> ) self . debug ( <str> ) TorrentPlayer . __init__ ( self )  def close ( self ) : 		 if self . engine != None : 			 self . engine . close ( ) self . engine = None  self . debug ( <str> )  def __exit__ ( self ) : 		 self . debug ( <str> ) self . close ( )  def _AddTorrent ( self , path ) : 		 if filesystem . exists ( path ) : 			 if path . startswith ( <str> ) or <str> in path : 				 tempPath = xbmc . translatePath ( <str> ) . decode ( <str> ) destPath = filesystem . join ( tempPath , <str> ) filesystem . copyfile ( path , destPath ) path = destPath  uri = path2url ( path )  else : 			 uri = path  self . debug ( <str> + uri ) add_trackers = [ ] if getSetting ( <str> ) : 			 add_trackers . append ( getSetting ( <str> ) )  download_path = self . settings . storage_path if download_path == <str> : 			 download_path = xbmc . translatePath ( <str> )  self . debug ( <str> % download_path ) self . download_path = download_path encryption = self . debug_assignment ( Encryption . ENABLED if getSetting ( <str> ) == <str> else Encryption . DISABLED , <str> ) upload_limit = self . debug_assignment ( int ( getSetting ( <str> ) ) * 1024 if getSetting ( <str> ) != <str> else 0 , <str> ) download_limit = self . debug_assignment ( int ( getSetting ( <str> ) ) * 1024 if getSetting ( <str> ) != <str> else 0 , <str> ) if getSetting ( <str> ) not in [ <str> , 0 , <str> ] : 			 connections_limit = self . debug_assignment ( int ( getSetting ( <str> ) ) , <str> )  else : 			 connections_limit = None  use_random_port = self . debug_assignment ( True if getSetting ( <str> ) == <str> else False , <str> ) listen_port = self . debug_assignment ( int ( getSetting ( <str> ) ) if getSetting ( <str> ) != <str> else 62881 , <str> ) if listen_port == 6881 : 			 use_random_port = True  keep_files = getSetting ( <str> ) . decode ( <str> ) != <str> args = { <str> : uri , <str> : download_path , <str> : user_agent , <str> : encryption , <str> : upload_limit , <str> : download_limit , <str> : connections_limit , <str> : False , <str> : keep_files , <str> : keep_files , <str> : dht_routers , <str> : use_random_port , <str> : listen_port , <str> : True , <str> : add_trackers , <str> : 1000 } try : 			 if keep_files : 				 args [ <str> ] = filesystem . join ( self . settings . torrents_path ( ) , self . info_hash + <str> )   except BaseException as e : 			 log . print_tb ( e ) if keep_files : 				 args [ <str> ] = filesystem . join ( download_path , self . info_hash + <str> )   if args . get ( <str> ) : 			 self . debug ( <str> + args [ <str> ] )  self . engine = Engine ( ** args )  def CheckTorrentAdded ( self ) : 		 if self . engine : 			 status = self . engine . status ( ) self . engine . check_torrent_error ( status ) self . debug ( <str> ) if status . state == State . CHECKING_FILES : 				 self . debug ( <str> ) return False   else : 			 return TorrentPlayer . CheckTorrentAdded ( self )  return True  def _GetLastTorrentData ( self ) : 		 while True : 			 time . sleep ( 0.2 ) files = self . engine . list ( ) if files is None : 				 self . debug ( <str> ) continue  self . debug ( <str> + str ( len ( files ) ) ) if not files or len ( files ) > 0 : 				 break   info_hash = <str> playable_items = [ ] for item in files : 			 if TorrentPlayer . is_playable ( item . name ) : 				 playable_items . append ( { <str> : item . index , <str> : item . name , <str> : long ( item . size ) } )   return { <str> : info_hash , <str> : playable_items }  def StartBufferFile ( self , fileIndex ) : 		 self . _AddTorrent ( self . path ) self . download_path = None self . engine . start ( fileIndex ) self . file_id = fileIndex self . debug ( <str> % fileIndex )  def CheckBufferComplete ( self ) : 		 if not self . download_path is None : 			 return True  status = self . engine . status ( ) self . debug ( <str> + str ( status . state_str ) ) if status . state == State . DOWNLOADING : 			 f_status = self . engine . file_status ( self . file_id ) self . debug ( <str> % f_status . download ) if f_status . download >= self . pre_buffer_bytes : 				 return True   return status . state in [ State . FINISHED , State . SEEDING ]  def GetBufferingProgress ( self ) : 		 f_status = self . engine . file_status ( self . file_id ) try : 			 progress = int ( round ( float ( f_status . download ) / self . pre_buffer_bytes , 2 ) * 100 ) self . debug ( <str> % progress ) if progress > 99 : 				 progress = 99   except : 			 progress = 0  return progress  def updateCheckingProgress ( self , progressBar ) : 		 status = self . engine . status ( ) percents = int ( status . progress * 100 ) if percents > 99 : 			 percents = 99  progressBar . update ( percents , <str> , <str> , <str> )  def updateDialogInfo ( self , progress , progressBar ) : 		 f_status = self . engine . file_status ( self . file_id ) status = self . engine . status ( ) if f_status is None or status is None : 			 return  dialogText = <str> + <str> % ( int ( f_status . download / 1024 / 1024 ) , int ( f_status . size / 1024 / 1024 ) ) peersText = <str> % ( <str> , status . num_seeds , <str> , status . num_peers ) speedsText = <str> % ( <str> , int ( status . download_rate / 1024 * 8 ) , <str> , int ( status . upload_rate / 1024 * 8 ) ) progressBar . update ( progress , dialogText + <str> + peersText , speedsText )  def GetTorrentInfo ( self ) : 		 f_status = self . engine . file_status ( self . file_id ) status = self . engine . status ( ) if f_status is None or status is None : 			 return None  try : 			 return { <str> : int ( f_status . download / 1024 / 1024 ) , <str> : int ( f_status . size / 1024 / 1024 ) , <str> : int ( status . download_rate ) , <str> : int ( status . upload_rate ) , <str> : status . num_seeds , <str> : status . num_peers }  except : 			 pass  return None  def GetStreamURL ( self , playable_item ) : 		 if self . download_path is None : 			 f_status = self . engine . file_status ( self . file_id ) self . debug ( <str> % f_status . url ) return f_status . url  else : 			 self . debug ( <str> % self . download_path ) return self . download_path      