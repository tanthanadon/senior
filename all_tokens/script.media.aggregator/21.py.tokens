 import log import filesystem , os , time import xml . etree . ElementTree as ET test_reader = None class AdvancedSettingsReader ( object ) : 	 dict = { } def LOG ( self , s ) : 		 log . debug ( <str> + s )  def __init__ ( self ) : 		 self . use_mysql = False self . dict . clear ( ) root = [ ] try : 			 import xbmc path = xbmc . translatePath ( <str> ) . decode ( <str> ) self . LOG ( path ) if filesystem . exists ( path ) : 				 self . load ( path )   except : 			 pass   def load ( self , path ) : 		 try : 			 with filesystem . fopen ( path , <str> ) as f : 				 content = f . read ( ) root = ET . fromstring ( content )   except IOError as e : 			 self . LOG ( <str> . format ( e . errno , e . strerror ) ) return  except BaseException as e : 			 self . LOG ( <str> + str ( e ) ) return  for section in root : 			 if section . tag == <str> : 				 for child in section : 					 if child . tag in [ <str> , <str> , <str> , <str> , <str> , <str> ] : 						 self . dict [ child . tag ] = child . text log . debug ( child . text )   self . LOG ( <str> ) return   self . LOG ( <str> )  def __getitem__ ( self , key ) : 		 return self . dict . get ( key , None )   DB_VERSIONS = { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } BASE_PATH = <str> class VideoDatabase ( object ) : 	 @ staticmethod def find_last_version ( name , path = BASE_PATH ) : 		 import re , filesystem try : 			 if path . startswith ( <str> ) : 				 import xbmc path = xbmc . translatePath ( path )  files = filesystem . listdir ( path ) matched_files = [ f for f in files if bool ( re . match ( name , f , re . I ) ) ] versions = [ int ( os . path . splitext ( f [ len ( name ) : ] ) [ 0 ] ) for f in matched_files ] if not versions : 				 return 0  return max ( versions )  except BaseException as e : 			 log . debug ( e , log . lineno ( ) ) raise ValueError ( <str> )   @ staticmethod def get_db_version ( name = None ) : 		 try : 			 import xbmc major = xbmc . getInfoLabel ( <str> ) . split ( <str> ) [ 0 ] ver = DB_VERSIONS . get ( major ) if ver : 				 return ver  return VideoDatabase . find_last_version ( name , <str> )  except ( ImportError , ValueError ) : 			 return DB_VERSIONS [ <str> ]   def __init__ ( self ) : 		 try : 			 reader = test_reader if test_reader else AdvancedSettingsReader ( ) self . DB_NAME = reader [ <str> ] if reader [ <str> ] is not None else <str> self . DB_NAME += self . get_db_version ( self . DB_NAME ) log . debug ( <str> + self . DB_NAME ) self . DB_USER = reader [ <str> ] self . DB_PASS = reader [ <str> ] self . DB_ADDRESS = reader [ <str> ] self . DB_PORT = reader [ <str> ] if reader [ <str> ] == <str> and self . DB_ADDRESS is not None and self . DB_USER is not None and self . DB_PASS is not None and self . DB_NAME is not None : 				 log . debug ( <str> ) self . DB = <str>  else : 				 log . debug ( <str> ) raise ValueError ( <str> )   except : 			 self . DB = <str> import xbmc db_path = xbmc . translatePath ( BASE_PATH ) self . db_dir = filesystem . join ( db_path , <str> % VideoDatabase . find_last_version ( <str> , db_path ) )   def create_connection ( self ) : 		 if self . DB == <str> : 			 import mysql . connector return mysql . connector . connect ( database = self . DB_NAME , user = self . DB_USER , password = self . DB_PASS , host = self . DB_ADDRESS , port = self . DB_PORT , buffered = True )  else : 			 from sqlite3 import dbapi2 as db_sqlite return db_sqlite . connect ( self . db_dir )   def sql_request ( self , req ) : 		 if self . DB == <str> : 			 return req . replace ( <str> , <str> )  else : 			 return req . replace ( <str> , <str> )    def request ( fn ) : 	 def wrapper ( self , * args , ** kwargs ) : 		 self . db = self . videoDB . create_connection ( ) try : 			 sql = fn ( self , * args , ** kwargs ) cur = self . db . cursor ( ) cur . execute ( sql ) result = cur . fetchall ( ) self . db . commit ( ) return result  except BaseException as e : 			 pass  finally : 			 self . db . close ( )   return wrapper  def request_dict ( fn ) : 	 def wrapper ( self , * args , ** kwargs ) : 		 self . db = self . videoDB . create_connection ( ) try : 			 sql = fn ( self , * args , ** kwargs ) cur = self . db . cursor ( ) cur . execute ( sql ) result = cur . fetchall ( ) self . db . commit ( ) keys = sql . replace ( <str> , <str> ) keys = keys . split ( <str> ) [ 0 ] keys = keys . split ( <str> ) keys = [ k . strip ( ) for k in keys ] out = [ ] for res in result : 				 dct = { } for i , k in enumerate ( keys ) : 					 dct [ k . strip ( ) ] = res [ i ]  out . append ( dct . copy ( ) )  return out  finally : 			 self . db . close ( )   return wrapper  class KodiDB ( object ) : 	 def debug ( self , msg , line = 0 ) : 		 if isinstance ( msg , unicode ) : 			 msg = msg . encode ( <str> )  log . debug ( <str> % ( line , msg ) )  def __init__ ( self , strmName , strmPath , pluginUrl ) : 		 self . debug ( <str> + strmName , log . lineno ( ) ) self . debug ( <str> + strmPath , log . lineno ( ) ) self . debug ( <str> + pluginUrl , log . lineno ( ) ) self . timeOffset = 0 self . strmName = strmName self . strmPath = strmPath self . pluginUrl = pluginUrl self . videoDB = VideoDatabase ( )  def PlayerPreProccessing ( self ) : 		 import xbmc xbmc . sleep ( 1000 ) self . db = self . videoDB . create_connection ( ) try : 			 self . debug ( <str> , log . lineno ( ) ) strmItem = self . getFileItem ( self . strmName , self . strmPath ) if not strmItem is None : 				 self . debug ( <str> + str ( strmItem ) , log . lineno ( ) ) bookmarkItem = self . getBookmarkItem ( strmItem [ <str> ] ) self . debug ( <str> + str ( bookmarkItem ) , log . lineno ( ) ) self . timeOffset = bookmarkItem [ <str> ] if bookmarkItem != None else 0 self . debug ( <str> + str ( self . timeOffset / 60 ) , log . lineno ( ) )  else : 				 self . debug ( <str> , log . lineno ( ) )   finally : 			 self . db . close ( )   def PlayerPostProccessing ( self ) : 		 self . db = self . videoDB . create_connection ( ) try : 			 self . debug ( <str> , log . lineno ( ) ) for cnt in range ( 3 ) : 				 pluginItem = self . getFileItem ( self . pluginUrl ) self . debug ( <str> + str ( pluginItem ) , log . lineno ( ) ) if pluginItem : 					 break  self . debug ( <str> + str ( cnt + 2 ) ) time . sleep ( 2 )  strmItem = self . getFileItem ( self . strmName , self . strmPath ) self . debug ( <str> + str ( strmItem ) , log . lineno ( ) ) self . CopyWatchedStatus ( pluginItem , strmItem ) self . ChangeBookmarkId ( pluginItem , strmItem )  finally : 			 self . db . close ( )   def CopyWatchedStatus ( self , pluginItem , strmItem ) : 		 if pluginItem is None or strmItem is None : 			 return  if pluginItem [ <str> ] is None or strmItem [ <str> ] is None : 			 return  cur = self . db . cursor ( ) sql = <str> sql += <str> + str ( pluginItem [ <str> ] ) sql += <str> + str ( strmItem [ <str> ] ) self . debug ( <str> + sql , log . lineno ( ) ) cur . execute ( sql ) self . db . commit ( )  def ChangeBookmarkId ( self , pluginItem , strmItem ) : 		 if pluginItem is None or strmItem is None : 			 return  if strmItem [ <str> ] is None or pluginItem [ <str> ] is None : 			 return  cur = self . db . cursor ( ) sql = <str> + str ( strmItem [ <str> ] ) self . debug ( <str> + sql , log . lineno ( ) ) cur . execute ( sql ) self . db . commit ( ) sql = <str> + str ( strmItem [ <str> ] ) sql += <str> + str ( pluginItem [ <str> ] ) self . debug ( <str> + sql , log . lineno ( ) ) cur . execute ( sql ) self . db . commit ( )  def getBookmarkItem ( self , idFile ) : 		 cur = self . db . cursor ( ) sql = <str> + <str> + str ( idFile ) cur . execute ( sql ) bookmarks = cur . fetchall ( ) for item in bookmarks : 			 self . debug ( <str> + item . __repr__ ( ) , log . lineno ( ) ) return { <str> : item [ 0 ] , <str> : item [ 1 ] , <str> : item [ 2 ] , <str> : item [ 3 ] }  return None  def getFileItem ( self , strFilename , strPath = None ) : 		 cur = self . db . cursor ( ) sql = <str> + <str> + <str> + strFilename . replace ( <str> , <str> ) + <str> self . debug ( sql , log . lineno ( ) ) cur . execute ( sql ) files = cur . fetchall ( ) if len ( files ) == 0 : 			 self . debug ( <str> , log . lineno ( ) ) return None  if strPath is None : 			 for item in files : 				 self . debug ( <str> + item . __repr__ ( ) , log . lineno ( ) ) return { <str> : item [ 0 ] , <str> : item [ 1 ] , <str> : item [ 2 ] , <str> : item [ 3 ] , <str> : item [ 4 ] }   else : 			 sql = <str> ids = [ ] for item in files : 				 ids . append ( str ( item [ 1 ] ) )  sql += <str> . join ( ids ) + <str> self . debug ( sql , log . lineno ( ) ) cur . execute ( sql ) paths = cur . fetchall ( ) for path in paths : 				 if path [ 1 ] . replace ( <str> , <str> ) . endswith ( strPath + <str> ) or path [ 1 ] . replace ( <str> , <str> ) . endswith ( strPath + <str> ) : 					 for item in files : 						 if path [ 0 ] == item [ 1 ] : 							 self . debug ( <str> + item . __repr__ ( ) , log . lineno ( ) ) return { <str> : item [ 0 ] , <str> : item [ 1 ] , <str> : item [ 2 ] , <str> : item [ 3 ] , <str> : item [ 4 ] }      self . debug ( <str> , log . lineno ( ) ) return None  def getPathId ( self , strPath ) : 		 cur = self . db . cursor ( ) sql = <str> + <str> + strPath . encode ( <str> ) . replace ( <str> , <str> ) + <str> self . debug ( sql , log . lineno ( ) ) cur . execute ( sql ) return cur . fetchall ( )  def getFileDataById ( self , fileId ) : 		 return   class MoreRequests ( object ) : 	 _videoDB = None @ property def videoDB ( self ) : 		 if not self . _videoDB : 			 self . _videoDB = VideoDatabase ( )  return self . _videoDB  @ request_dict def get_movies_by_imdb ( self , imdb ) : 		 sql = . format ( imdb ) self . _log ( sql ) return sql  def _log ( self , s ) : 		 from log import debug debug ( <str> . format ( s ) )  @ request def update_movie_by_id ( self , id , fields = { } ) : 		 try : 			 expression = <str> for k , v in fields . iteritems ( ) : 				 if isinstance ( v , unicode ) : 					 v = v . encode ( <str> )  expression += <str> . format ( k , v . replace ( <str> , <str> ) )  sql = . format ( expression [ : - 2 ] , id ) self . _log ( sql ) return sql  except BaseException as e : 			 pass   @ request def remove_movie_by_id ( self , id ) : 		 sql = . format ( id ) self . _log ( sql ) return sql  @ request def get_movie_duplicates ( self ) : 		 sql = self . _log ( sql ) return sql    