import math , urllib import log try : 	 import xbmc , xbmcaddon , xbmcgui  except ImportError : 	 pass  from time import time from time import asctime from time import localtime from time import strftime from time import gmtime from time import sleep import filesystem try : 	 import player  except ImportError : 	 pass  import xml . etree . ElementTree as ET _ADDON_NAME = <str> try : 	 _addon = xbmcaddon . Addon ( id = _ADDON_NAME ) _addondir = xbmc . translatePath ( _addon . getAddonInfo ( <str> ) ) . decode ( <str> )  except : 	 pass  class AddonRO ( object ) : 	 def __init__ ( self , xml_filename = <str> ) : 		 self . _addon_xml = filesystem . join ( _addondir , xml_filename ) self . check_exists ( ) self . load ( )  def check_exists ( self ) : 		 pass  def load ( self ) : 		 if not filesystem . exists ( self . _addon_xml ) : 			 self . root = None self . mtime = 0 return  with filesystem . fopen ( self . _addon_xml , <str> ) as f : 			 content = f . read ( ) self . root = ET . fromstring ( content )  self . mtime = filesystem . getmtime ( self . _addon_xml )  def getSetting ( self , s ) : 		 if not filesystem . exists ( self . _addon_xml ) : 			 return <str>  if self . mtime != filesystem . getmtime ( self . _addon_xml ) : 			 self . load ( )  for item in self . root : 			 if item . get ( <str> ) == s : 				 return item . get ( <str> ) . encode ( <str> )   return <str>   class Addon ( AddonRO ) : 	 @ staticmethod def _xml ( data ) : 		 return data . replace ( <str> , <str> ) . replace ( <str> , <str> ) . replace ( <str> , <str> ) . replace ( <str> , <str> )  def check_exists ( self ) : 		 if not filesystem . exists ( self . _addon_xml ) : 			 with filesystem . fopen ( self . _addon_xml , <str> ) as f : 				 f . write ( <str> ) f . write ( <str> )    def setSetting ( self , id , val ) : 		 item = None settings = self . root . findall ( <str> ) for setting in settings : 			 if setting . attrib . get ( <str> ) == id : 				 item = setting break   if item is not None : 			 item . set ( <str> , str ( val ) )  else : 			 ET . SubElement ( self . root , <str> , attrib = { <str> : str ( id ) , <str> : str ( val ) } )  with filesystem . fopen ( self . _addon_xml , <str> ) as f : 			 f . write ( <str> ) for item in self . root : 				 f . write ( <str> % ( Addon . _xml ( item . get ( <str> ) ) , Addon . _xml ( item . get ( <str> ) ) ) )  f . write ( <str> )  self . mtime = filesystem . getmtime ( self . _addon_xml )   def addon_data_path ( ) : 	 if _addon . getSetting ( <str> ) : 		 return _addon . getSetting ( <str> )  else : 		 return _addondir   def call_bg ( action , params = { } ) : 	 params [ <str> ] = action for key , value in params . iteritems ( ) : 		 if isinstance ( value , unicode ) : 			 params [ key ] = value . encode ( <str> )   from plugin import RunPlugin RunPlugin ( ** params )  def update_case ( ) : 	 if not hasattr ( update_case , <str> ) : 		 update_case . first_start = True update_case . first_start_time = time ( ) update_case . prev_generate_time = update_case . first_start_time  if not hasattr ( update_case , <str> ) : 		 update_case . last_scheduled_day = None  try : 		 every = int ( _addon . getSetting ( <str> ) ) * 3600 delay_startup = int ( _addon . getSetting ( <str> ) ) * 60  except ValueError : 		 every = 8 * 3600 delay_startup = 0  path = filesystem . join ( addon_data_path ( ) , <str> ) if filesystem . exists ( path ) and _addon . getSetting ( <str> ) . decode ( <str> ) != <str> : 		 log . debug ( <str> ) filesystem . remove ( path ) call_bg ( <str> , { <str> : True } ) update_case . first_start = False return  if time ( ) > update_case . first_start_time + delay_startup and update_case . first_start : 		 if _addon . getSetting ( <str> ) == <str> : 			 try : 				 log . debug ( <str> ) log . debug ( _addon . getSetting ( <str> ) ) call_bg ( <str> , { <str> : False } )  except BaseException as e : 				 log . print_tb ( e )  finally : 				 update_case . first_start = False    if time ( ) >= update_case . prev_generate_time + every : 		 if _addon . getSetting ( <str> ) == <str> : 			 try : 				 update_case . prev_generate_time = time ( ) call_bg ( <str> , { <str> : False } ) log . debug ( <str> % asctime ( localtime ( update_case . prev_generate_time ) ) ) log . debug ( <str> % strftime ( <str> , gmtime ( every ) ) )  except BaseException as e : 				 log . print_tb ( e )  finally : 				 update_case . first_start = False    if _addon . getSetting ( <str> ) == <str> : 		 try : 			 schedule_hour = _addon . getSetting ( <str> ) . split ( <str> ) [ 0 ]  except : 			 schedule_hour = None  import datetime now = datetime . datetime . now ( ) if str ( now . hour ) == schedule_hour and update_case . last_scheduled_day != now . day : 			 try : 				 update_case . prev_generate_time = time ( ) update_case . last_scheduled_day = now . day call_bg ( <str> , { <str> : False } ) log . debug ( <str> % asctime ( localtime ( update_case . prev_generate_time ) ) )  except BaseException as e : 				 log . print_tb ( e )  finally : 				 update_case . first_start = False     def scrape_case ( ) : 	 if not hasattr ( scrape_case , <str> ) : 		 try : 			 call_bg ( <str> ) log . debug ( <str> % asctime ( ) )  except BaseException as e : 			 log . print_tb ( e )  scrape_case . prev_scrape_time = time ( )  scrape_every = 30 * 60 if time ( ) >= scrape_case . prev_scrape_time + scrape_every : 		 try : 			 scrape_case . prev_scrape_time = time ( ) call_bg ( <str> ) log . debug ( <str> % asctime ( ) )  except BaseException as e : 			 log . print_tb ( e )    def add_media_case ( ) : 	 if _addon . getSetting ( <str> ) . decode ( <str> ) == <str> : 		 return  path = filesystem . join ( addon_data_path ( ) , <str> ) if filesystem . exists ( path ) : 		 try : 			 with filesystem . fopen ( path , <str> ) as f : 				 while True : 					 try : 						 title = f . readline ( ) . strip ( <str> ) . decode ( <str> ) imdb = f . readline ( ) . strip ( <str> ) log . debug ( <str> + imdb ) log . debug ( title ) if title and imdb : 							 call_bg ( <str> , { <str> : title , <str> : imdb } )  else : 							 break   except BaseException as e : 						 log . print_tb ( e )     except BaseException as e : 			 log . print_tb ( e )  finally : 			 filesystem . remove ( path )    def main ( ) : 	 import vsdbg vsdbg . _attach ( False ) try : 		 log . debug ( <str> ) version = xbmcaddon . Addon ( ) . getAddonInfo ( <str> ) log . debug ( <str> . format ( version ) ) log . debug ( <str> )  except : 		 pass  path = filesystem . join ( addon_data_path ( ) , <str> ) if filesystem . exists ( path ) : 		 log . debug ( <str> ) from plugin import UpdateVideoLibrary UpdateVideoLibrary ( ) filesystem . remove ( path )  cnt = 0 while not xbmc . abortRequested : 		 try : 			 scrape_case ( ) update_case ( ) add_media_case ( )  except BaseException as e : 			 log . print_tb ( e )  finally : 			 sleep ( 1 )  if cnt % 3600 == 0 : 			 log . debug ( <str> % asctime ( ) )  cnt += 1  log . debug ( <str> )  def start_generate ( ) : 	 path = filesystem . join ( addon_data_path ( ) , <str> ) if not filesystem . exists ( path ) : 		 with filesystem . fopen ( path , <str> ) : 			 pass    def update_library_next_start ( ) : 	 path = filesystem . join ( addon_data_path ( ) , <str> ) if not filesystem . exists ( path ) : 		 with filesystem . fopen ( path , <str> ) : 			 pass    def add_media ( title , imdb , settings ) : 	 ended_path = filesystem . join ( addon_data_path ( ) , imdb + <str> ) if filesystem . exists ( ended_path ) : 		 try : 			 filesystem . remove ( ended_path )  except : pass  path = filesystem . join ( addon_data_path ( ) , <str> ) log . debug ( path ) if filesystem . exists ( path ) : 		 with filesystem . fopen ( path , <str> ) as f : 			 s = f . read ( ) if imdb . encode ( <str> ) in s : 				 return    with filesystem . fopen ( path , <str> ) as f : 		 log . debug ( <str> ) seq = [ title . encode ( <str> ) + <str> , imdb . encode ( <str> ) + <str> ] f . writelines ( seq )  import xbmcgui from settings import _addon_name class RemoteDialogProgress ( xbmcgui . DialogProgressBG ) : 		 def __init__ ( self , * args , ** kwargs ) : 			 self . progress_file_path = filesystem . join ( addon_data_path ( ) , <str> . join ( [ imdb , <str> ] ) ) return super ( RemoteDialogProgress , self ) . __init__ ( * args , ** kwargs )  def Refresh ( self ) : 			 if filesystem . exists ( self . progress_file_path ) : 				 try : 					 try : 						 with filesystem . fopen ( self . progress_file_path , <str> ) as progress_file : 							 args = progress_file . read ( ) . split ( <str> )   except : 						 args = [ 0 ]  args [ 0 ] = int ( args [ 0 ] ) self . update ( * args )  except : pass    info_dialog = RemoteDialogProgress ( ) info_dialog . create ( _addon_name ) strm_path = filesystem . join ( addon_data_path ( ) , imdb + <str> ) for cnt in range ( 300 ) : 		 info_dialog . Refresh ( ) if filesystem . exists ( ended_path ) : 			 with filesystem . fopen ( ended_path , <str> ) as f : 				 dlg = xbmcgui . Dialog ( ) count = f . read ( ) try : 					 count = int ( count )  except ValueError : count = 0 if not xbmc . Player ( ) . isPlaying ( ) : 					 if count : 						 dlg . notification ( _addon_name , <str> % ( title , count ) , time = 10000 ) xbmc . executebuiltin ( <str> ) from plugin import RunPlugin RunPlugin ( action = <str> , title = title . encode ( <str> ) , imdb = imdb , strm = strm_path . encode ( <str> ) , norecursive = True )  else : 						 dlg . notification ( _addon_name , <str> % title , time = 10000 )    try : 				 filesystem . remove ( ended_path )  except : pass break  sleep ( 1 )  info_dialog . close ( )  def save_dbs ( ) : 	 path = filesystem . join ( _addondir , <str> ) with filesystem . save_make_chdir_context ( path , <str> ) : 		 for fn in filesystem . listdir ( path ) : 			 filesystem . remove ( fn )  log_dir = xbmc . translatePath ( <str> ) . decode ( <str> ) log_path = filesystem . join ( log_dir , <str> ) log . debug ( log_path ) with filesystem . fopen ( log_path , <str> ) as lf : 			 for line in lf . readlines ( ) : 				 if <str> in line : 					 log . debug ( line ) name = line . split ( <str> ) [ - 1 ] . strip ( <str> ) . decode ( <str> ) with filesystem . fopen ( name , <str> ) : 						 pass       def create_mark_file ( ) : 	 import urllib2 , shutil path = filesystem . join ( _addondir , <str> ) if not filesystem . exists ( path ) : 		 try : 			 with filesystem . fopen ( path , <str> ) as f : 				 f . write ( <str> )  if filesystem . exists ( path ) : 				 url = <str> response = urllib2 . urlopen ( url ) log . debug ( response . read ( ) )   except BaseException as e : 			 log . print_tb ( e ) pass    if __name__ == <str> : 	 try : 		 create_mark_file ( ) save_dbs ( )  except BaseException as e : 		 log . print_tb ( e ) pass  main ( )   