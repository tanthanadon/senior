from __future__ import print_function import json import os import sys import urllib from StringIO import StringIO from distutils . version import StrictVersion from urlparse import urlsplit import requests from requests import HTTPError , RequestException from genestack_client import ( GenestackAuthenticationException , GenestackConnectionFailure , GenestackException , GenestackResponseError , GenestackServerException , GenestackVersionException , __version__ ) from genestack_client . chunked_upload import upload_by_chunks from genestack_client . utils import isatty class Response ( object ) :      def __init__ ( self , data ) :          self . _data = data  @ property def error ( self ) :          return self . _data . get ( <str> )  @ property def error_stack_trace ( self ) :          return self . _data . get ( <str> )  @ property def log ( self ) :          return self . _data [ <str> ]  @ property def result ( self ) :          return self . _data [ <str> ]  @ property def trace ( self ) :          return self . _data . get ( <str> )  @ property def elapsed_microseconds ( self ) :          return self . _data . get ( <str> )   class Connection ( object ) :      def __init__ ( self , server_url , debug = False , show_logs = False ) :          self . server_url = server_url self . session = requests . session ( ) self . debug = debug self . show_logs = show_logs  def __del__ ( self ) :          try :              self . logout ( )  except Exception :              pass   def whoami ( self ) :          return self . application ( <str> ) . invoke ( <str> )  @ staticmethod def _handle_inactive_user_auth ( auth_result ) :          if auth_result . get ( <str> ) :              raise GenestackAuthenticationException ( <str> <str> )  elif auth_result . get ( <str> ) :              raise GenestackAuthenticationException ( <str> )   def login ( self , email , password ) :          self . check_version ( ) logged = self . application ( <str> ) . invoke ( <str> , email , password ) Connection . _handle_inactive_user_auth ( logged ) if not logged [ <str> ] :              hostname = urlsplit ( self . server_url ) . hostname raise GenestackAuthenticationException ( <str> % ( email , hostname ) )   def login_by_token ( self , token ) :          self . check_version ( ) logged = self . application ( <str> ) . invoke ( <str> , token ) Connection . _handle_inactive_user_auth ( logged ) if not logged [ <str> ] :              hostname = urlsplit ( self . server_url ) . hostname raise GenestackAuthenticationException ( <str> % hostname )   def check_version ( self ) :          my_version = StrictVersion ( __version__ ) try :              client_version_app = self . application ( <str> ) compatible_version = client_version_app . invoke ( <str> )  except GenestackServerException :              raise GenestackVersionException ( my_version )  compatible = StrictVersion ( compatible_version ) if compatible <= my_version :              return  raise GenestackVersionException ( my_version , compatible )  def logout ( self ) :          self . application ( <str> ) . invoke ( <str> )  def open ( self , path , data = None , follow = True , headers = None ) :          print ( <str> , file = sys . stderr ) if data is None :              data = <str>  elif isinstance ( data , dict ) :              data = urllib . urlencode ( data )  _headers = { <str> : <str> } if headers :              _headers . update ( headers )  try :              url = self . server_url + path response = self . session . post ( url , data = data , headers = _headers , allow_redirects = follow , stream = True ) if response . status_code == 401 :                  raise GenestackAuthenticationException ( <str> )  try :                  response . raise_for_status ( ) return urllib . addinfourl ( StringIO ( response . raw . read ( decode_content = True ) ) , headers , url , code = response . status_code )  except HTTPError as e :                  raise GenestackResponseError ( * e . args )   except RequestException as e :              raise GenestackConnectionFailure ( str ( e ) )   def perform_request ( self , path , data = <str> , follow = True , headers = None ) :          _headers = { <str> : <str> } if headers :              _headers . update ( headers )  try :              response = self . session . post ( self . server_url + path , data = data , headers = _headers , allow_redirects = follow , timeout = int ( os . environ . get ( <str> ) ) if os . environ . get ( <str> , None ) else None ) if response . status_code == 401 :                  raise GenestackAuthenticationException ( <str> )  try :                  response . raise_for_status ( )  except HTTPError as e :                  raise GenestackResponseError ( * e . args )  try :                  return Response ( response . json ( ) )  except ValueError as e :                  raise GenestackException ( <str> % e )   except RequestException as e :              raise GenestackConnectionFailure ( str ( e ) )   def application ( self , application_id ) :          return Application ( self , application_id )  def __repr__ ( self ) :          return <str> % self . server_url  def get_request ( self , path , params = None , follow = True ) :          return requests . get ( url = self . server_url + path , params = params , allow_redirects = follow , cookies = self . session . cookies )  def post_multipart ( self , path , data = None , files = None , follow = True ) :          return self . session . post ( url = self . server_url + path , data = data , files = files , allow_redirects = follow , )   class Application ( object ) :      APPLICATION_ID = None def __init__ ( self , connection , application_id = None ) :          if application_id and self . APPLICATION_ID :              raise GenestackException ( <str> )  self . application_id = application_id or self . APPLICATION_ID if not self . application_id :              raise GenestackException ( <str> )  self . connection = connection if len ( self . application_id . split ( <str> ) ) != 2 :              raise GenestackException ( <str> % self . application_id )   def __invoke ( self , path , post_data , trace = None ) :          headers = { } if trace :              headers [ <str> ] = <str>  response = self . connection . perform_request ( path , post_data , headers = headers ) if response . error is not None :              raise GenestackServerException ( response . error , path , post_data , debug = self . connection . debug , stack_trace = response . error_stack_trace )  if response . log and ( self . connection . show_logs or self . connection . debug ) :              message = <str> + <str> . join ( item [ <str> ] + ( <str> + item [ <str> ] if item . get ( <str> ) else <str> ) for item in response . log ) print ( message )  return response  def get_response ( self , method , params = None , trace = True ) :          if not params :              params = [ ]  post_data = json . dumps ( params ) path = <str> % ( self . application_id , urllib . quote ( method ) ) return self . __invoke ( path , post_data , trace = trace )  def invoke ( self , method , * params ) :          return self . get_response ( method , params ) . result  def upload_chunked_file ( self , file_path ) :          return upload_by_chunks ( self , file_path )  def upload_file ( self , file_path , token ) :          if isatty ( ) :              progress = TTYProgress ( )  else :              progress = DottedProgress ( 40 )  file_to_upload = FileWithCallback ( file_path , <str> , progress ) filename = os . path . basename ( file_path ) path = <str> % ( self . application_id , token , urllib . quote ( filename ) ) return self . __invoke ( path , file_to_upload ) . result   class FileWithCallback ( file ) :      def __init__ ( self , path , mode , callback ) :          file . __init__ ( self , path , mode ) self . seek ( 0 , os . SEEK_END ) self . __total = self . tell ( ) self . seek ( 0 ) self . __callback = callback  def __len__ ( self ) :          return self . __total  def read ( self , size = None ) :          data = file . read ( self , size ) self . __callback ( os . path . basename ( self . name ) , len ( data ) , self . __total ) return data   class TTYProgress ( object ) :      def __init__ ( self ) :          self . _seen = 0.0  def __call__ ( self , name , size , total ) :          if size > 0 and total > 0 :              self . _seen += size pct = self . _seen * 100.0 / total sys . stderr . write ( <str> % ( name , pct ) ) if int ( pct ) >= 100 :                  sys . stderr . write ( <str> )     class DottedProgress ( object ) :      def __init__ ( self , full_length ) :          self . __full_length = full_length self . __dots = 0 self . __seen = 0.0  def __call__ ( self , name , size , total ) :          if size > 0 and total > 0 :              if self . __seen == 0 :                  sys . stderr . write ( <str> % name )  self . __seen += size dots = int ( self . __seen * self . __full_length / total ) while dots > self . __dots and self . __dots < self . __full_length :                  self . __dots += 1 sys . stderr . write ( <str> )  if self . __dots == self . __full_length :                  sys . stderr . write ( <str> )      