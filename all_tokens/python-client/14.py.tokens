import sys from time import sleep import genestack_client from genestack_client import ( Application , FileFilter , GenestackException , Metainfo , validate_constant , ShareUtil ) CALCULATE_CHECKSUMS_KEY = <str> EXPECTED_CHECKSUM_PREFIX = <str> FILE_BATCH_SIZE = 500 class SpecialFolders ( object ) :      IMPORTED = <str> CREATED = <str> TEMPORARY = <str> UPLOADED = <str> MY_DATASETS = <str>  class SortOrder ( object ) :      BY_NAME = <str> BY_ACCESSION = <str> BY_LAST_UPDATE = <str> DEFAULT = <str>  class MatchType ( object ) :      PREFIX = <str> SUBSTRING = <str>  class FilesUtil ( Application ) :      APPLICATION_ID = <str> CONTAINER = <str> FOLDER = <str> EXPERIMENT = <str> DATASET = <str> FILE = <str> UNALIGNED_READS = <str> UNALIGNED_READS_DATA = <str> ALIGNED_READS = <str> VARIATION_FILE = <str> APPLICATION_PAGE_FILE = <str> REFERENCE_GENOME = <str> AUXILIARY_FILE = <str> INDEX_FILE = <str> CODON_TABLE = <str> GENOME_BED_DATA = <str> GENOME_WIGGLE_DATA = <str> GENOME_ANNOTATIONS = <str> HTSEQ_COUNTS = <str> EXTERNAL_DATABASE = <str> PREFERENCES_FILE = <str> REPORT_FILE = <str> RAW_FILE = <str> MICROARRAY_ASSAY = <str> MICROARRAY_DATA = <str> SEQUENCING_ASSAY = <str> FEATURE_LIST = <str> EXPRESSION_SIGNATURE = <str> EXPRESSION_LEVELS = <str> MAX_FILE_SEARCH_LIMIT = 2000 MAX_RELATED_TERMS_LIMIT = 10000 def find_reference_genome ( self , organism , assembly , release ) :          return self . invoke ( <str> , organism , assembly , release )  def find_file_by_name ( self , name , parent = None , file_class = FILE ) :          return self . invoke ( <str> , name , parent , file_class )  def find_folder_by_name ( self , name , parent = None ) :          return self . find_file_by_name ( name , parent , self . FOLDER )  def find_aligned_reads_file_by_name ( self , name , parent = None ) :          return self . find_file_by_name ( name , parent , self . ALIGNED_READS )  def find_unaligned_reads_file_by_name ( self , name , parent = None ) :          return self . find_file_by_name ( name , parent , self . UNALIGNED_READS )  def find_variation_file_by_name ( self , name , parent = None ) :          return self . find_file_by_name ( name , parent , self . VARIATION_FILE )  def find_experiment_by_name ( self , name , parent = None ) :          return self . find_file_by_name ( name , parent , self . EXPERIMENT )  def find_application_page_file_by_name ( self , name , parent = None ) :          return self . find_file_by_name ( name , parent , self . APPLICATION_PAGE_FILE )  def collect_initializable_files_in_container ( self , accession ) :          return self . invoke ( <str> , accession )  def count_file_children ( self , container_accession ) :          return self . invoke ( <str> , container_accession )  def get_file_children ( self , container_accession ) :          all_files = [ ] count = 0 while True :              batch = self . invoke ( <str> , container_accession , count , FILE_BATCH_SIZE ) all_files += batch count += len ( batch ) if len ( batch ) < FILE_BATCH_SIZE :                  break   return all_files  def create_folder ( self , name , parent = None , description = None , metainfo = None ) :          metainfo = metainfo or Metainfo ( ) metainfo . add_string ( Metainfo . NAME , name ) if description is not None :              metainfo . add_string ( Metainfo . DESCRIPTION , description )  return self . invoke ( <str> , parent , metainfo )  def find_or_create_folder ( self , name , parent = None ) :          return self . invoke ( <str> , name , parent )  def link_file ( self , accession , parent ) :          self . invoke ( <str> , { accession : [ parent ] } )  def unlink_file ( self , accession , parent ) :          self . invoke ( <str> , { accession : [ parent ] } )  def link_files ( self , children_to_parents_dict ) :          self . invoke ( <str> , children_to_parents_dict )  def unlink_files ( self , children_to_parents_dict ) :          self . invoke ( <str> , children_to_parents_dict )  def clear_container ( self , container_accession ) :          self . invoke ( <str> , container_accession )  def add_metainfo_string_value ( self , accession_list , key , value ) :          self . invoke ( <str> , accession_list , key , value )  def replace_metainfo_string_value ( self , accession_list , key , value ) :          self . invoke ( <str> , accession_list , key , value )  def replace_metainfo_value ( self , accession_list , key , value ) :          self . invoke ( <str> , accession_list , key , value )  def remove_metainfo_value ( self , accession_list , key ) :          self . invoke ( <str> , accession_list , key )  def add_metainfo_values ( self , accession , metainfo , skip_existing_keys = True , replace_existing_keys = False ) :          self . invoke ( <str> , accession , metainfo , skip_existing_keys , replace_existing_keys )  def get_metainfo_values_as_strings ( self , accessions_list , keys_list = None ) :          return self . invoke ( <str> , accessions_list , keys_list )  def get_metainfo_values_as_string_list ( self , accessions_list , keys_list = None ) :          return self . invoke ( <str> , accessions_list , keys_list )  def get_special_folder ( self , name ) :          special_folders = ( SpecialFolders . IMPORTED , SpecialFolders . CREATED , SpecialFolders . TEMPORARY , SpecialFolders . UPLOADED , SpecialFolders . MY_DATASETS ) if name not in special_folders :              raise GenestackException ( <str> % ( name , <str> . join ( special_folders ) ) )  return self . invoke ( <str> , name )  def share_files ( self , accessions , group , destination_folder = None , password = None ) :          if password is not None :              sys . stderr . write ( <str> )  share_util = ShareUtil ( self . connection ) share_util . share_files_for_view ( accessions , group , destination_folder )  def share_folder ( self , folder_accession , group , destination_folder = None , password = None ) :          if password is not None :              sys . stderr . write ( <str> )  share_utils = ShareUtil ( self . connection ) share_utils . share_files_for_view ( folder_accession , group , destination_folder ) limit = 100 delay_seconds = 1 offset = 0 while True :              count = share_utils . invoke ( <str> , folder_accession , group , offset , limit ) if count == 0 and offset == 0 :                  return  if count < limit :                  sleep ( delay_seconds ) offset = 0  else :                  offset += limit    def get_groups_to_share ( self ) :          share_utils = ShareUtil ( self . connection ) return share_utils . get_available_sharing_groups ( )  def get_group_folder_info ( self , group_accession ) :          share_utils = ShareUtil ( self . connection ) return share_utils . invoke ( <str> , group_accession )  def get_folder ( self , parent , * names , ** kwargs ) :          if not names :              raise GenestackException ( <str> )  create = bool ( kwargs . get ( <str> ) ) for path in names :              if create :                  parent = self . find_or_create_folder ( path , parent = parent )  else :                  _parent_accession = self . find_file_by_name ( path , parent = parent , file_class = self . FOLDER ) if _parent_accession is None :                      raise Exception ( <str> % ( path , parent ) )  parent = _parent_accession   return parent  def get_home_folder ( self ) :          return <str>  def get_public_folder ( self ) :          return <str>  def get_complete_infos ( self , accession_list ) :          return self . invoke ( <str> , accession_list )  def get_infos ( self , accession_list ) :          return self . invoke ( <str> , accession_list )  def rename_file ( self , accession , name ) :          self . invoke ( <str> , accession , name )  def mark_for_tests ( self , app_file ) :          metainfo = Metainfo ( ) metainfo . add_boolean ( CALCULATE_CHECKSUMS_KEY , True ) self . add_metainfo_values ( app_file , metainfo )  def mark_obsolete ( self , accession ) :          metainfo = Metainfo ( ) metainfo . add_boolean ( <str> , True ) self . add_metainfo_values ( accession , metainfo )  def add_checksums ( self , app_file , expected_checksums ) :          metainfo = Metainfo ( ) for key , value in expected_checksums . items ( ) :              metainfo . add_string ( <str> % ( EXPECTED_CHECKSUM_PREFIX , key ) , value )  self . add_metainfo_values ( app_file , metainfo )  def find_files ( self , file_filter , sort_order = SortOrder . DEFAULT , ascending = False , offset = 0 , limit = MAX_FILE_SEARCH_LIMIT ) :          limit = min ( self . MAX_FILE_SEARCH_LIMIT , limit ) if offset < 0 or limit < 0 :              raise GenestackException ( <str> )  if not validate_constant ( SortOrder , sort_order ) :              raise GenestackException ( <str> )  return self . invoke ( <str> , file_filter . get_dict ( ) , sort_order , ascending , offset , limit )  def collect_metainfos ( self , accessions ) :          return map ( Metainfo . parse_metainfo_from_dict , self . invoke ( <str> , accessions ) )  def create_dataset ( self , name , dataset_type , children , parent = None ) :          sys . stderr . write ( <str> ) try :              return genestack_client . DatasetsUtil ( self . connection ) . create_dataset ( name , dataset_type , children , parent )  except GenestackException :              if parent is None :                  parent = self . get_special_folder ( SpecialFolders . MY_DATASETS )  return self . invoke ( <str> , parent , name , dataset_type , children )   def find_metainfo_related_terms ( self , file_filter , dictionary_accession , relationship_name , transitive , key , match_type = MatchType . SUBSTRING , search_string = <str> , offset = 0 , limit = MAX_RELATED_TERMS_LIMIT ) :          limit = min ( self . MAX_RELATED_TERMS_LIMIT , limit ) return self . invoke ( <str> , { <str> : dictionary_accession , <str> : relationship_name , <str> : transitive } , file_filter . get_dict ( ) , key , match_type , search_string , offset , limit )    