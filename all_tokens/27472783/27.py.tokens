import json import os import re import sys import time from datetime import datetime from io import BytesIO from threading import Condition , Lock , Thread from OpenSSL . SSL import SysCallError from requests . exceptions import RequestException from genestack_client import GenestackException from genestack_client . utils import isatty RETRY_ATTEMPTS = 5 RETRY_INTERVAL = 2 NUM_THREADS = 5 CHUNK_SIZE = 1024 * 1024 * 5 class Chunk ( object ) :      def __init__ ( self , number , start , size , chunk_size , total_size , token , filename , path , chunk_count , launch_time ) :          self . data = { <str> : chunk_size , <str> : <str> , <str> : total_size , <str> : token , <str> : filename , <str> : path , <str> : chunk_count , <str> : launch_time , <str> : number , <str> : size } self . start = start self . size = size  def __str__ ( self ) :          return <str> % ( self . data [ <str> ] , self . size , self . data [ <str> ] )  def get_file ( self ) :          container = BytesIO ( ) with open ( self . data [ <str> ] , <str> ) as f :              f . seek ( self . start ) container . write ( f . read ( self . size ) )  container . seek ( 0 ) return container   class PermanentError ( GenestackException ) :      pass  def with_lock ( method ) :      def wrapper ( self , * args ) :          with self . lock :              return method ( self , * args )   return wrapper  class ChunkedUpload ( object ) :      def __init__ ( self , application , path , chunk_size = None ) :          if chunk_size is None :              chunk_size = CHUNK_SIZE  if chunk_size <= 0 :              raise GenestackException ( <str> )  self . chunk_upload_url = <str> % application . application_id self . connection = application . connection self . lock = Lock ( ) self . __iterator_lock = Lock ( ) self . __output_lock = Lock ( ) self . __application_result = None self . __has_application_result = False self . __finished = False self . __error = None self . thread_counter = 0 self . condition = Condition ( ) modified = datetime . fromtimestamp ( os . path . getmtime ( path ) ) total_size = os . path . getsize ( path ) token = <str> . format ( total_size = total_size , name = re . sub ( <str> , <str> , os . path . basename ( path ) ) , date = modified . strftime ( <str> ) ) self . token = token self . path = path if total_size < chunk_size * 2 :              chunk_count = 1  else :              chunk_count = total_size / chunk_size  self . total_size = total_size self . filename = os . path . basename ( path ) self . path = path self . chunk_count = chunk_count launch_time = int ( time . time ( ) * 1000 ) if isatty ( ) :              from genestack_connection import TTYProgress self . progress = TTYProgress ( )  else :              from genestack_connection import DottedProgress self . progress = DottedProgress ( 40 )  def _iterator ( ) :              start = 0 info = [ chunk_size , total_size , token , self . filename , path , chunk_count , launch_time ] for x in xrange ( 1 , chunk_count + 1 ) :                  if x == chunk_count :                      current_chunk_size = self . total_size - start  else :                      current_chunk_size = chunk_size  yield Chunk ( x , start , current_chunk_size , * info ) start += current_chunk_size   self . iterator = _iterator ( )  @ property @ with_lock def application_result ( self ) :          return self . __application_result  @ application_result . setter @ with_lock def application_result ( self , value ) :          self . __application_result = value  @ property @ with_lock def has_application_result ( self ) :          return self . __has_application_result  @ has_application_result . setter @ with_lock def has_application_result ( self , value ) :          self . __has_application_result = value  @ property @ with_lock def finished ( self ) :          return self . __finished  @ finished . setter @ with_lock def finished ( self , value ) :          self . __finished = value  @ property @ with_lock def error ( self ) :          return self . __error  @ error . setter def error ( self , value ) :          self . __error = value  def __update_progress ( self , update_size ) :          with self . __output_lock :              self . progress ( self . filename , update_size , self . total_size )   def __process_chunk ( self , chunk ) :          file_cache = None upload_checked = False error = None for attempt in xrange ( RETRY_ATTEMPTS ) :              if not upload_checked :                  try :                      response = self . connection . get_request ( self . chunk_upload_url , params = chunk . data , follow = False )  except RequestException as e :                      error = str ( e ) time . sleep ( RETRY_INTERVAL ) continue  if response . status_code == 200 :                      self . __update_progress ( chunk . size ) return  else :                      upload_checked = True   if file_cache is None :                  file_cache = chunk . get_file ( )  file_cache . seek ( 0 ) try :                  response = self . connection . post_multipart ( self . chunk_upload_url , data = chunk . data , files = { <str> : file_cache } , follow = False )  except ( RequestException , SysCallError ) as e :                  time . sleep ( RETRY_INTERVAL ) error = str ( e ) if self . connection . debug :                      sys . stderr . write ( <str> % ( attempt + 1 , RETRY_ATTEMPTS , chunk , error ) )  continue  if response . status_code == 200 :                  self . __update_progress ( chunk . size ) data = json . loads ( response . text ) if data . get ( <str> , False ) :                      self . application_result = data [ <str> ] self . has_application_result = True self . finished = True  return  error = <str> % response . status_code if 400 <= response . status_code < 600 :                  self . finished = True try :                      data = json . loads ( response . text ) if isinstance ( data , dict ) and <str> in data :                          error = data [ <str> ]   except ValueError :                      pass  self . error = error return  time . sleep ( RETRY_INTERVAL ) continue  self . error = error self . finished = True  def upload ( self ) :          def do_stuff ( ) :              with self . condition :                  self . thread_counter += 1  try :                  while not self . finished :                      try :                          with self . __iterator_lock :                              chunk = next ( self . iterator )   except StopIteration :                          return  self . __process_chunk ( chunk )   except Exception as e :                  self . error = str ( e )  finally :                  with self . condition :                      self . thread_counter -= 1 self . condition . notify ( )    threads = [ Thread ( target = do_stuff ) for _ in range ( min ( NUM_THREADS , self . chunk_count ) ) ] [ thread . setDaemon ( True ) for thread in threads ] [ thread . start ( ) for thread in threads ] with self . condition :              while True :                  try :                      self . condition . wait ( )  except ( KeyboardInterrupt , SystemExit ) :                      self . error = <str> self . finished = True break  if not self . thread_counter :                      break    if self . has_application_result :              return self . application_result  else :              error_message = self . error or <str> raise GenestackException ( <str> % ( self . path , error_message ) )    def upload_by_chunks ( application , path , chunk_size = None ) :      return ChunkedUpload ( application , path , chunk_size = chunk_size ) . upload ( )   