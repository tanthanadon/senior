from __future__ import print_function import os import sys from argparse import RawTextHelpFormatter from datetime import datetime from itertools import groupby from operator import itemgetter from genestack_client import ( DataImporter , FilesUtil , GenestackServerException , GenestackVersionException , SpecialFolders , get_connection , make_connection_parser ) EXIT_CODE_DUPLICATED_NAMES = 23 DESCRIPTION = parser = make_connection_parser ( ) parser . description = DESCRIPTION parser . formatter_class = RawTextHelpFormatter group = parser . add_argument_group ( <str> ) group . add_argument ( <str> , help = <str> , metavar = <str> , nargs = <str> ) group . add_argument ( <str> , <str> , help = <str> , action = <str> ) exclusive_group = group . add_mutually_exclusive_group ( ) exclusive_group . add_argument ( <str> , <str> , metavar = <str> , help = <str> ) exclusive_group . add_argument ( <str> , metavar = <str> , help = <str> ) def friendly_number ( number ) :      template = <str> powers = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] base = 1000 number = float ( number ) for power in powers [ : - 1 ] :          if number < base :              return template % ( number , power )  number /= base  return template % ( number , powers [ - 1 ] )  def check_duplicated_file_names ( files_list ) :      names = ( ( os . path . basename ( x ) , x ) for x in files_list ) duplication = { } for file_name , collected_paths in names :          duplication . setdefault ( file_name , [ ] ) . append ( collected_paths )  duplication = { k : sorted ( v ) for k , v in duplication . items ( ) if len ( v ) > 1 } if duplication :          print ( <str> <str> , file = sys . stderr ) for name , duplicated_paths in sorted ( duplication . items ( ) ) :              print ( <str> % ( name , <str> . join ( duplicated_paths ) ) , file = sys . stderr )  exit ( EXIT_CODE_DUPLICATED_NAMES )   def get_files ( paths ) :      errors = [ ] for path in paths :          if not os . path . exists ( path ) :              errors . append ( path )   if errors :          sys . stderr . write ( <str> % ( <str> if len ( paths ) > 1 else <str> , <str> . join ( paths ) ) ) exit ( 1 )  files_list = [ ] total_size = 0 for path in paths :          if os . path . isfile ( path ) :              files_list . append ( path ) total_size += os . path . getsize ( path ) continue  for base , folders , files in os . walk ( path , followlinks = False ) :              for f in files :                  file_path = os . path . join ( base , f ) files_list . append ( file_path ) total_size += os . path . getsize ( file_path )  for f in folders :                  folder_path = os . path . join ( base , f ) if os . path . islink ( folder_path ) :                      sys . stderr . write ( <str> % folder_path )     check_duplicated_file_names ( files_list ) return files_list , total_size  def upload_files ( connection , files , folder_name , folder_accession ) :      importer = DataImporter ( connection ) fu = FilesUtil ( connection ) upload = fu . get_special_folder ( SpecialFolders . UPLOADED ) if not folder_accession :          folder_name = folder_name or datetime . now ( ) . strftime ( <str> ) folder_accession = fu . create_folder ( folder_name , parent = upload , description = <str> )  else :          folder_name = fu . get_infos ( [ folder_accession ] ) [ 0 ] [ <str> ]  accession_file_map = { } for f in files :          accession = importer . load_raw ( f ) fu . link_file ( accession , folder_accession ) fu . unlink_file ( accession , upload ) accession_file_map [ accession ] = f  return folder_accession , folder_name , accession_file_map  def recognize_files ( connection , accession_file_map , new_folder ) :      fu = FilesUtil ( connection ) application = connection . application ( <str> ) recognised_files = application . invoke ( <str> , accession_file_map . keys ( ) ) recognized_accessions = set ( ) for x in recognised_files :          for sources in x [ <str> ] . values ( ) :              for info in sources :                  recognized_accessions . add ( info [ <str> ] )    created_files = application . invoke ( <str> , recognised_files , [ ] , None ) groups = sorted ( created_files [ <str> ] , key = itemgetter ( <str> ) ) for name , group in groupby ( groups , key = itemgetter ( <str> ) ) :          print ( name ) for f in group :              print ( <str> % ( f [ <str> ] , f [ <str> ] ) )   unrecognized_file_infos = set ( accession_file_map ) - recognized_accessions if unrecognized_file_infos :          print ( <str> ) for accession in unrecognized_file_infos :              print ( <str> % ( accession , accession_file_map [ accession ] . decode ( <str> ) ) )  unrecognized_folder = fu . create_folder ( <str> , parent = new_folder ) for accession in unrecognized_file_infos :              fu . link_file ( accession , unrecognized_folder ) fu . unlink_file ( accession , new_folder )  print ( <str> % ( unrecognized_folder , <str> ) )   def main ( ) :      args = parser . parse_args ( ) files , size = get_files ( args . paths ) print ( <str> % ( len ( files ) , friendly_number ( size ) ) ) try :          connection = get_connection ( args )  except GenestackVersionException as e :          sys . stderr . write ( str ( e ) ) sys . stderr . write ( <str> ) exit ( 13 )  new_folder , folder_name , accessions = upload_files ( connection , files , args . folder_name , args . upload_to ) print ( <str> % ( len ( accessions ) , new_folder , folder_name ) ) if args . no_recognition :          exit ( 0 )  try :          recognize_files ( connection , accessions , new_folder )  except GenestackServerException as e :          sys . stderr . write ( <str> % e ) exit ( 1 )   if __name__ == <str> :      main ( )   