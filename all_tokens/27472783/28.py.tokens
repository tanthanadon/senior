from __future__ import print_function import cmd import os import shlex import sys from argparse import ArgumentParser , HelpFormatter from traceback import print_exc from genestack_client import ( GenestackAuthenticationException , GenestackException , GenestackVersionException ) from utils import get_connection , isatty , make_connection_parser , get_terminal_width from version import __version__ if isatty ( ) :      try :          import readline  except :          pass   HELP_SEPARATOR = <str> % ( <str> * 20 , <str> * 20 ) def get_help ( parser ) :      width = min ( get_terminal_width ( ) , 100 ) formatter = HelpFormatter ( prog = parser . prog , max_help_position = 30 , width = width ) formatter . add_usage ( parser . usage , parser . _actions , parser . _mutually_exclusive_groups ) formatter . add_text ( parser . description ) groups = list ( parser . _action_groups ) groups . sort ( key = lambda x : x . title != <str> ) for action_group in groups :          formatter . start_section ( action_group . title ) formatter . add_text ( action_group . description ) formatter . add_arguments ( action_group . _group_actions ) formatter . end_section ( )  formatter . add_text ( parser . epilog ) return formatter . format_help ( )  class Command ( object ) :      COMMAND = None DESCRIPTION = <str> OFFLINE = False def __init__ ( self ) :          self . connection = None self . args = None  def get_command_parser ( self , parser = None ) :          parser = parser or ArgumentParser ( description = self . DESCRIPTION ) parser . prog = <str> % ( parser . prog , self . COMMAND ) parser . description = self . DESCRIPTION group = parser . add_argument_group ( <str> ) self . update_parser ( group ) return parser  def update_parser ( self , parent ) :          pass  def set_connection ( self , conn ) :          self . connection = conn  def set_arguments ( self , args ) :          self . args = args  def get_short_description ( self ) :          return self . DESCRIPTION  def run ( self ) :          raise NotImplementedError ( )   class GenestackShell ( cmd . Cmd ) :      INTRO = <str> COMMAND_LIST = [ ] DESCRIPTION = <str> COMMANDS = { } def get_history_file_path ( self ) :          return os . path . join ( os . path . expanduser ( <str> ) , <str> % self . __class__ . __name__ )  def get_names ( self ) :          return [ x for x in cmd . Cmd . get_names ( self ) if x != <str> ]  def __init__ ( self , * args , ** kwargs ) :          self . COMMANDS = { command . COMMAND : command for command in self . COMMAND_LIST } cmd . Cmd . __init__ ( self , * args , ** kwargs ) self . connection = None  def get_shell_parser ( self , offline = False ) :          parents = [ ] if offline else [ make_connection_parser ( ) ] parser = ArgumentParser ( conflict_handler = <str> , description = self . DESCRIPTION , parents = parents ) parser . add_argument ( <str> , <str> , action = <str> , help = <str> ) parser . add_argument ( <str> , <str> , action = <str> , help = <str> ) parser . add_argument ( <str> , metavar = <str> , help = <str> % <str> . join ( self . COMMANDS ) , nargs = <str> ) return parser  def setup_connection ( self , args = None ) :          try :              self . connection = get_connection ( args )  except GenestackVersionException as e :              sys . stderr . write ( str ( e ) ) sys . stderr . write ( <str> ) exit ( 13 )   def preloop ( self ) :          parser = self . get_shell_parser ( ) args , others = parser . parse_known_args ( ) if args . version :              print ( __version__ ) exit ( 0 )  command = self . COMMANDS . get ( args . command ) if command :              command = command ( )  elif args . command :              print ( <str> % args . command ) print ( get_help ( parser ) ) exit ( 0 )  elif others :              print ( <str> % <str> . join ( others ) ) print ( get_help ( parser ) ) exit ( 0 )  if args . help :              if not command :                  print ( get_help ( parser ) )  elif command . OFFLINE :                  print ( get_help ( command . get_command_parser ( ) ) )  else :                  print ( get_help ( command . get_command_parser ( make_connection_parser ( ) ) ) )  exit ( 0 )  if command :              if not command . OFFLINE :                  self . setup_connection ( args )  else :                  parser = self . get_shell_parser ( offline = True ) _ , others = parser . parse_known_args ( )  exit_code = self . process_command ( command , others ) exit ( exit_code )  try :              readline . read_history_file ( self . get_history_file_path ( ) ) readline . set_history_length ( 1000 )  except ( IOError , NameError ) :              pass  self . set_shell_user ( args )  def set_shell_user ( self , args ) :          self . setup_connection ( args ) try :              email = self . connection . whoami ( ) self . prompt = <str> % email  except GenestackAuthenticationException :              self . prompt = <str>  if self . connection . debug :              debug_string = <str>  else :              debug_string = <str>  self . intro = ( <str> <str> . format ( version = __version__ , debug_string = debug_string , intro = self . INTRO ) )  def postloop ( self ) :          try :              readline . write_history_file ( self . get_history_file_path ( ) )  except ( IOError , NameError ) :              pass   def do_EOF ( self , line ) :          return True  do_quit = do_EOF def process_command ( self , command , argument_list , shell = False ) :          if shell or command . OFFLINE :              p = command . get_command_parser ( )  else :              p = command . get_command_parser ( make_connection_parser ( ) )  try :              args = p . parse_args ( argument_list )  except SystemExit :              return 1  command . set_connection ( self . connection ) command . set_arguments ( args ) try :              command . run ( ) return 0  except ( KeyboardInterrupt , EOFError ) :              print ( ) print ( <str> )  except GenestackException as e :              sys . stdout . flush ( ) sys . stderr . write ( <str> % e )  except Exception :              sys . stdout . flush ( ) print_exc ( )  return 1  def do_debug ( self , line ) :          self . connection . debug = not self . connection . debug if self . connection . debug :              print ( <str> )  else :              print ( <str> )   def get_commands_for_help ( self ) :          commands = [ ( <str> , <str> ) , ( <str> , <str> ) ] for name , value in self . COMMANDS . items ( ) :              commands . append ( ( name , value ( ) . get_short_description ( ) ) )  return sorted ( commands )  def do_help ( self , line ) :          print ( ) command = self . COMMANDS . get ( line ) if command :              print ( get_help ( command ( ) . get_command_parser ( ) ) ) return  if not line :              print ( self . doc_header ) print ( <str> * len ( self . doc_header ) ) commands = self . get_commands_for_help ( ) max_size = max ( len ( command_name ) for command_name , _ in commands ) help_size = max ( ( 20 , max_size + 3 ) ) for command_name , short_description in self . get_commands_for_help ( ) :                  print ( <str> % ( help_size , command_name , short_description ) )  print ( <str> * len ( self . doc_header ) )  try :              getattr ( self , <str> + line ) ( ) return  except AttributeError :              pass  try :              doc = getattr ( self , <str> + line ) . __doc__ if doc :                  self . stdout . write ( <str> % str ( doc ) ) return   except AttributeError :              pass  self . stdout . write ( <str> % str ( self . nohelp % ( line , ) ) )  def emptyline ( self ) :          pass  def default ( self , line ) :          try :              args = shlex . split ( line )  except Exception as e :              sys . stderr . write ( str ( e ) ) sys . stderr . write ( <str> ) return  if args and args [ 0 ] in self . COMMANDS :              self . process_command ( self . COMMANDS [ args [ 0 ] ] ( ) , args [ 1 : ] , shell = True )  else :              self . stdout . write ( <str> % line )   def completenames ( self , text , * ignored ) :          dotext = <str> + text commands = [ a [ 3 : ] for a in self . get_names ( ) if a . startswith ( dotext ) ] commands += [ x for x in self . COMMANDS . keys ( ) if x . startswith ( text ) ] return commands  def cmdloop ( self , intro = None ) :          try :              cmd . Cmd . cmdloop ( self , intro = intro )  except ( KeyboardInterrupt , EOFError ) :              print ( ) self . postloop ( )     