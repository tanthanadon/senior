from __future__ import print_function import glob import json import os import sys import time import urllib2 import xml . dom . minidom as minidom import zipfile from collections import OrderedDict , namedtuple from textwrap import TextWrapper from genestack_client import GenestackException , GenestackServerException from genestack_client . genestack_shell import Command , GenestackShell from genestack_client . utils import ask_confirmation , isatty if sys . stdout . encoding is None :      import codecs import locale sys . stdout = codecs . getwriter ( locale . getpreferredencoding ( ) ) ( sys . stdout )  def validate_application_id ( app_id ) :      if len ( app_id . split ( <str> ) ) != 2 :          sys . stderr . write ( <str> <str> % app_id ) return False  return True  APPLICATION_ID = <str> SCOPE_DICT = { <str> : <str> , <str> : <str> , <str> : <str> } DEFAULT_SCOPE = <str> VISIBILITIES = [ <str> , <str> , <str> ] class Info ( Command ) :      COMMAND = <str> DESCRIPTION = <str> OFFLINE = True def update_parser ( self , p ) :          p . add_argument ( <str> , <str> , action = <str> , help = <str> ) p . add_argument ( <str> , <str> , action = <str> , help = <str> ) p . add_argument ( <str> , action = <str> , help = <str> ) p . add_argument ( <str> , metavar = <str> , nargs = <str> , help = <str> )  def run ( self ) :          jar_files = [ resolve_jar_file ( f ) for f in match_jar_globs ( self . args . files ) ] return show_info ( jar_files , self . args . vendor , self . args . with_filename , self . args . no_filename )   class Install ( Command ) :      COMMAND = <str> DESCRIPTION = <str> def update_parser ( self , p ) :          p . add_argument ( <str> , <str> , action = <str> , default = False , help = <str> ) p . add_argument ( <str> , <str> , action = <str> , help = <str> ) p . add_argument ( <str> , <str> , action = <str> , help = <str> ) p . add_argument ( <str> , <str> , metavar = <str> , choices = SCOPE_DICT . keys ( ) , default = DEFAULT_SCOPE , help = <str> <str> % ( DEFAULT_SCOPE , <str> . join ( SCOPE_DICT . keys ( ) ) ) ) p . add_argument ( <str> , <str> , metavar = <str> , help = <str> <str> ) p . add_argument ( <str> , <str> , action = <str> , dest = <str> , help = <str> ) p . add_argument ( <str> , metavar = <str> , help = <str> ) p . add_argument ( <str> , metavar = <str> , nargs = <str> , help = <str> )  def run ( self ) :          jar_files = [ resolve_jar_file ( f ) for f in match_jar_globs ( self . args . files ) ] if not jar_files :              raise GenestackException ( <str> )  return upload_file ( self . connection . application ( APPLICATION_ID ) , jar_files , self . args . version , self . args . override , self . args . stable , self . args . scope , self . args . force , self . args . visibility , self . args . no_wait )   class ListVersions ( Command ) :      COMMAND = <str> DESCRIPTION = <str> def update_parser ( self , p ) :          p . add_argument ( <str> , action = <str> , dest = <str> , help = <str> ) p . add_argument ( <str> , action = <str> , dest = <str> , help = <str> ) p . add_argument ( <str> , action = <str> , dest = <str> , help = <str> ) p . add_argument ( <str> , action = <str> , dest = <str> , help = <str> ) p . add_argument ( <str> , action = <str> , dest = <str> , help = <str> ) p . add_argument ( <str> , metavar = <str> , help = <str> )  def run ( self ) :          app_id = self . args . app_id show_loading_state = self . args . show_loading_state show_release_state = self . args . show_release_state show_visibilities = self . args . show_visibilities if not validate_application_id ( app_id ) :              return 1  app_info = self . connection . application ( APPLICATION_ID ) . invoke ( <str> , app_id , self . args . show_owned ) if not app_info :              sys . stderr . write ( <str> % app_id ) return 1  app_info = OrderedDict ( sorted ( app_info . items ( ) ) ) max_len = max ( len ( x ) for x in app_info . keys ( ) ) multi_column_mode = show_loading_state or show_release_state or show_visibilities for item in app_info . items ( ) :              version_name = item [ 0 ] version_details = item [ 1 ] output_string = <str> if self . args . show_stable :                  output_string += <str> % ( <str> if <str> in version_details [ <str> ] else <str> , <str> if <str> in version_details [ <str> ] else <str> , <str> if <str> in version_details [ <str> ] else <str> )  if multi_column_mode :                  output_string += <str> % ( max_len + 2 , version_name )  else :                  output_string += version_name  if show_loading_state :                  output_string += <str> % ( version_details [ <str> ] . lower ( ) )  if show_release_state :                  output_string += <str> % ( <str> if version_details [ <str> ] else <str> )  if show_visibilities :                  levels = version_details [ <str> ] visibility = <str> + ( <str> if <str> in levels else <str> ) visibility += <str> visibility += ( <str> if <str> in levels else <str> ) visibility += <str> visibility += ( <str> if <str> not in levels else <str> + ( <str> . join ( levels [ <str> ] ) ) + <str> ) output_string += <str> % visibility  print ( output_string )    class Status ( Command ) :      COMMAND = <str> DESCRIPTION = <str> def update_parser ( self , p ) :          p . add_argument ( <str> , metavar = <str> , help = <str> ) p . add_argument ( <str> , metavar = <str> , nargs = <str> , help = <str> ) p . add_argument ( <str> , <str> , action = <str> , dest = <str> , help = <str> )  def run ( self ) :          app_ids = self . args . app_id_list if not all ( map ( validate_application_id , app_ids ) ) :              return 1  version = self . args . version lines = [ ] for app_id in app_ids :              app_info = self . connection . application ( APPLICATION_ID ) . invoke ( <str> , app_id , version ) lines . append ( <str> % ( app_id , app_info [ <str> ] . lower ( ) ) ) if not self . args . state_only :                  lines . extend ( format_loading_messages_by_lines ( app_info . get ( <str> , [ ] ) , app_info . get ( <str> , [ ] ) ) )   print ( <str> . join ( lines ) )   class Visibility ( Command ) :      COMMAND = <str> DESCRIPTION = <str> def update_parser ( self , p ) :          p . add_argument ( <str> , <str> , action = <str> , dest = <str> , help = <str> <str> ) p . add_argument ( <str> , metavar = <str> , help = <str> ) p . add_argument ( <str> , metavar = <str> , help = <str> ) p . add_argument ( <str> , metavar = <str> , choices = VISIBILITIES , help = <str> % ( <str> . join ( VISIBILITIES ) ) ) p . add_argument ( <str> , metavar = <str> , nargs = <str> , help = <str> )  def run ( self ) :          return change_applications_visibility ( self . args . remove , self . connection . application ( APPLICATION_ID ) , [ self . args . app_id ] , self . args . version , self . args . level , self . args . accessions )   class Release ( Command ) :      COMMAND = <str> DESCRIPTION = <str> def update_parser ( self , p ) :          p . add_argument ( <str> , metavar = <str> , help = <str> ) p . add_argument ( <str> , metavar = <str> , help = <str> ) p . add_argument ( <str> , metavar = <str> , help = <str> <str> )  def run ( self ) :          return release_applications ( self . connection . application ( APPLICATION_ID ) , [ self . args . app_id ] , self . args . version , self . args . new_version )   class ListApplications ( Command ) :      COMMAND = <str> DESCRIPTION = <str> def run ( self ) :          result = self . connection . application ( APPLICATION_ID ) . invoke ( <str> ) result . sort ( ) for item in result :              print ( item )    class MarkAsStable ( Command ) :      COMMAND = <str> DESCRIPTION = <str> def update_parser ( self , p ) :          p . add_argument ( <str> , metavar = <str> , help = <str> <str> ) p . add_argument ( <str> , metavar = <str> , nargs = <str> , help = <str> ) p . add_argument ( <str> , <str> , metavar = <str> , choices = SCOPE_DICT . keys ( ) , default = DEFAULT_SCOPE , help = <str> <str> % ( DEFAULT_SCOPE , <str> . join ( SCOPE_DICT . keys ( ) ) ) )  def run ( self ) :          apps_ids = self . args . app_id_list if not all ( map ( validate_application_id , apps_ids ) ) :              return 1  version = self . args . version if version == <str> :              version = None  return mark_as_stable ( self . connection . application ( APPLICATION_ID ) , version , apps_ids , self . args . scope )   class Remove ( Command ) :      COMMAND = <str> DESCRIPTION = <str> def update_parser ( self , p ) :          p . add_argument ( <str> , <str> , action = <str> , default = False , help = <str> ) p . add_argument ( <str> , metavar = <str> , help = <str> ) p . add_argument ( <str> , metavar = <str> , nargs = <str> , help = <str> <str> )  def run ( self ) :          app_ids = self . args . app_id_list if app_ids == [ <str> ] :              app_ids = None  elif not all ( map ( validate_application_id , app_ids ) ) :              return 1  application = self . connection . application ( APPLICATION_ID ) version = self . args . version if not self . args . force and not prompt_removing_stable_version ( application , app_ids , version ) :              raise GenestackException ( <str> )  return remove_applications ( self . connection . application ( APPLICATION_ID ) , self . args . version , app_ids )   class Reload ( Command ) :      COMMAND = <str> DESCRIPTION = <str> def update_parser ( self , p ) :          p . add_argument ( <str> , metavar = <str> , help = <str> ) p . add_argument ( <str> , metavar = <str> , nargs = <str> , help = <str> )  def run ( self ) :          apps_ids = self . args . app_id_list if not all ( map ( validate_application_id , apps_ids ) ) :              return 1  return reload_applications ( self . connection . application ( APPLICATION_ID ) , self . args . version , apps_ids )   class Invoke ( Command ) :      COMMAND = <str> DESCRIPTION = <str> def update_parser ( self , p ) :          p . add_argument ( <str> , metavar = <str> , help = <str> ) p . add_argument ( <str> , metavar = <str> , help = <str> ) p . add_argument ( <str> , metavar = <str> , nargs = <str> , help = <str> )  def run ( self ) :          application = self . connection . application ( self . args . app_id ) args = [ ] for arg in self . args . arguments :              try :                  args . append ( json . loads ( arg ) )  except ValueError :                  args . append ( arg )   response = application . invoke ( self . args . method_name , * args ) if isinstance ( response , list ) :              for item in response :                  print ( item )   else :              print ( response )    def match_jar_globs ( paths ) :      return sum ( [ glob . glob ( p ) for p in paths ] , [ ] )  def resolve_jar_file ( file_path ) :      if not os . path . exists ( file_path ) :          raise GenestackException ( <str> % file_path )  if not os . path . isdir ( file_path ) :          return file_path  jar_files = [ ] for dirpath , dirnames , filenames in os . walk ( file_path , followlinks = True ) :          for f in filenames :              if f . lower ( ) . endswith ( <str> ) :                  jar_files . append ( os . path . join ( dirpath , f ) )    if len ( jar_files ) > 1 :          raise GenestackException ( <str> <str> % ( file_path , <str> . join ( jar_files ) ) )  elif not jar_files :          raise GenestackException ( <str> % file_path )  return jar_files [ 0 ]  def mark_as_stable ( application , version , app_id_list , scope ) :      print ( <str> % ( version , scope ) ) scope = SCOPE_DICT [ scope ] result = 0 for app_id in app_id_list :          sys . stdout . write ( <str> % app_id ) sys . stdout . flush ( ) try :              if scope == <str> :                  if wait_application_loading ( application , app_id , version ) . success :                      application . invoke ( <str> , app_id , scope , version ) sys . stdout . write ( <str> ) sys . stdout . flush ( )   else :                  application . invoke ( <str> , app_id , scope , version ) sys . stdout . write ( <str> ) sys . stdout . flush ( )   except GenestackServerException as e :              handle_server_error_gracefully ( e ) result = 1   return result  def remove_applications ( application , version , app_id_list ) :      print ( <str> % version ) result = 0 if app_id_list :          for app_id in app_id_list :              sys . stdout . write ( <str> % app_id ) sys . stdout . flush ( ) try :                  application . invoke ( <str> , app_id , version ) sys . stdout . write ( <str> ) sys . stdout . flush ( )  except GenestackServerException as e :                  handle_server_error_gracefully ( e ) result = 1    else :          sys . stdout . write ( <str> ) sys . stdout . flush ( ) removed_apps = application . invoke ( <str> , version ) sys . stdout . write ( <str> ) sys . stdout . flush ( ) sys . stdout . write ( <str> % ( <str> . join ( sorted ( removed_apps ) ) ) ) sys . stdout . flush ( )  return result  def reload_applications ( application , version , app_id_list ) :      print ( <str> ) result = 0 for app_id in app_id_list :          sys . stdout . write ( <str> % app_id ) sys . stdout . flush ( ) try :              application . invoke ( <str> , app_id , version ) sys . stdout . write ( <str> ) sys . stdout . flush ( )  except GenestackServerException as e :              handle_server_error_gracefully ( e ) result = 1   return result  def upload_file ( application , files_list , version , override , stable , scope , force , initial_visibility , no_wait ) :      result = 0 for file_path in files_list :          result |= upload_single_file ( application , file_path , version , override , stable , scope , force , initial_visibility , no_wait )  return result  def upload_single_file ( application , file_path , version , override , stable , scope , force = False , initial_visibility = None , no_wait = False ) :      app_info = read_jar_file ( file_path ) if not force and override and not ( stable and SCOPE_DICT [ scope ] == <str> ) :          if get_system_stable_apps_version ( application , app_info . identifiers , version ) :              raise GenestackException ( <str> <str> <str> % version )   parameters = { <str> : version , <str> : override } upload_token = application . invoke ( <str> , parameters ) if upload_token is None :          raise GenestackException ( <str> )  upload_token = upload_token . encode ( <str> , <str> ) try :          result = application . upload_file ( file_path , upload_token ) if result :              print ( result )   except urllib2 . HTTPError as e :          raise GenestackException ( <str> % ( e . code , e . read ( ) ) )  if not no_wait :          identifiers_number = len ( app_info . identifiers ) for i , app_id in enumerate ( app_info . identifiers ) :              success , descriptor = wait_application_loading ( application , app_id , version ) if i == identifiers_number - 1 :                  errors = descriptor . get ( <str> , [ ] ) warns = descriptor . get ( <str> , [ ] ) if errors or warns :                      lines = [ <str> ] lines . extend ( format_loading_messages_by_lines ( errors , warns ) ) print ( <str> . join ( lines ) )     else :          sys . stdout . write ( <str> <str> ) sys . stdout . flush ( )  if initial_visibility :          change_applications_visibility ( False , application , app_info . identifiers , version , <str> if initial_visibility == <str> else <str> , None if initial_visibility == <str> else [ initial_visibility ] )  if not stable :          return 0  return mark_as_stable ( application , version , app_info . identifiers , scope )  def release_applications ( application , app_ids , version , new_version ) :      print ( <str> % new_version ) result = 0 for app_id in app_ids :          if not validate_application_id ( app_id ) :              sys . stderr . write ( <str> % app_id ) result = 1 continue  sys . stdout . write ( <str> % app_id ) sys . stdout . flush ( ) if wait_application_loading ( application , app_id , version ) . success :              application . invoke ( <str> , app_id , version , new_version ) sys . stdout . write ( <str> ) sys . stdout . flush ( )   return result  def change_applications_visibility ( remove , application , app_ids , version , level , accessions = None ) :      def invoke_change ( group_accession = None ) :          application . invoke ( <str> if remove else <str> , app_id , version , level , group_accession if group_accession else None )  print ( <str> % ( <str> if remove else <str> , level , version ) ) result = 0 for app_id in app_ids :          if not validate_application_id ( app_id ) :              sys . stderr . write ( <str> % app_id ) result = 1 continue  sys . stdout . write ( <str> % app_id ) sys . stdout . flush ( ) if accessions :              for accession in accessions :                  invoke_change ( accession )   else :              invoke_change ( )  sys . stdout . write ( <str> ) sys . stdout . flush ( )  return result  def get_application_descriptor ( application , application_id , version ) :      return application . invoke ( <str> , application_id , version )  def wait_application_loading ( application , app_id , version , seconds = 1 ) :      first = True while True :          descriptor = get_application_descriptor ( application , app_id , version ) if descriptor [ <str> ] == <str> :              sys . stdout . write ( <str> % app_id ) return LoadingResult ( False , descriptor )  elif descriptor [ <str> ] == <str> and first :              sys . stdout . write ( <str> <str> % app_id ) sys . stdout . flush ( ) first = False  elif descriptor [ <str> ] == <str> :              break  time . sleep ( seconds )  return LoadingResult ( True , descriptor )  def format_loading_messages_by_lines ( errors , warnings ) :      wrapper = TextWrapper ( initial_indent = <str> , subsequent_indent = <str> , width = 80 ) lines = [ ] if warnings :          lines . append ( <str> % <str> ) lines . append ( <str> . join ( [ wrapper . fill ( warning ) for warning in warnings ] ) )  if errors :          lines . append ( <str> % <str> ) lines . append ( <str> . join ( [ wrapper . fill ( error ) for error in errors ] ) )  return lines  AppInfo = namedtuple ( <str> , [ <str> , <str> ] ) LoadingResult = namedtuple ( <str> , [ <str> , <str> ] ) def log_on_error ( function ) :      def wrapper ( * args ) :          try :              return function ( * args )  except Exception :              sys . stderr . write ( <str> % ( function . __name__ , <str> . join ( map ( repr , args ) ) ) ) raise   return wrapper  @ log_on_error def read_jar_file ( file_path ) :      with zipfile . ZipFile ( file_path ) as zip_file :          try :              info = zip_file . getinfo ( <str> ) with zip_file . open ( info ) as manifest :                  doc = minidom . parse ( manifest ) namespace = doc . documentElement . namespaceURI applications = doc . getElementsByTagNameNS ( namespace , <str> ) vendor = doc . getElementsByTagNameNS ( namespace , <str> ) [ 0 ] . firstChild . nodeValue identifiers = [ vendor + <str> + a . getElementsByTagNameNS ( namespace , <str> ) [ 0 ] . firstChild . nodeValue for a in applications ]   except KeyError as e :              raise GenestackException ( <str> % ( os . path . abspath ( file_path ) , e ) )  return AppInfo ( vendor , identifiers )   def show_info ( files , vendor_only , with_filename , no_filename ) :      first_file = True for file_path in files :          app_info = read_jar_file ( file_path ) if vendor_only :              if no_filename :                  print ( app_info . vendor )  else :                  print ( <str> % ( file_path , app_info . vendor ) )  continue  if with_filename or not no_filename and len ( files ) > 1 :              if not first_file :                  print ( )  print ( <str> , file_path )  print ( <str> , app_info . vendor ) print ( <str> ) for app_id in sorted ( app_info . identifiers ) :              print ( <str> % app_id )  first_file = False   REMOVE_PROMPT = def prompt_removing_stable_version ( application , apps_ids , version ) :      check_tty ( ) if apps_ids :          apps = get_system_stable_apps_version ( application , apps_ids , version )  else :          apps = application . invoke ( <str> , version )  if not apps :          return True  message = REMOVE_PROMPT % ( version , <str> . join ( sorted ( apps ) ) ) try :          sys . stdout . write ( message ) sys . stdout . flush ( ) return ask_confirmation ( <str> )  except KeyboardInterrupt :          return False   def get_system_stable_apps_version ( application , apps_ids , version ) :      apps = [ ] for app_id in apps_ids :          stable_versions = application . invoke ( <str> , app_id ) if stable_versions . get ( <str> ) == version :              apps . append ( app_id )   return apps  def check_tty ( ) :      if not isatty ( ) :          raise GenestackException ( <str> )   def handle_server_error_gracefully ( e ) :      if e . debug :          sys . stderr . write ( str ( e ) )  else :          sys . stdout . write ( <str> % e . message ) sys . stdout . flush ( )   class ApplicationManager ( GenestackShell ) :      DESCRIPTION = ( <str> <str> <str> ) INTRO = <str> COMMAND_LIST = [ Info , Install , ListVersions , ListApplications , MarkAsStable , Remove , Reload , Invoke , Visibility , Release , Status ]  def main ( ) :      shell = ApplicationManager ( ) shell . cmdloop ( )  if __name__ == <str> :      main ( )   