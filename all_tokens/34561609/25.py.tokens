import neuraltda . simpComp as sc import neuraltda . topology2 as tp2 import neuraltda . spectralAnalysis as sa from ephys import rasters from importlib import reload import pickle import glob import os import numpy as np from scipy . optimize import brentq import tqdm def poisson_model_loss_generic ( a , beta , E_data , ncells , nwin , n_samples , metric_func ) :      KLsave = [ ] JSsave = [ ] probs = a * np . ones ( ( ncells , 1 ) ) samples = np . random . rand ( ncells , nwin , n_samples ) probmat = np . tile ( probs , ( 1 , nwin ) ) [ : , : , np . newaxis ] probmat = np . tile ( probmat , ( 1 , 1 , n_samples ) ) binMatsamples = np . greater ( probmat , samples ) . astype ( int ) SCGs = [ ] for ind in range ( n_samples ) :          msimps = sc . binarytomaxsimplex ( binMat = binMatsamples [ : , : , ind ] , rDup = True ) E_model = sc . simplicialChainGroups ( msimps ) Lsamp = sc . compute_laplacian ( E_model , d ) Ldata = sc . compute_laplacian ( E_data , d ) if np . size ( Lsamp ) > np . size ( Ldata ) :              ( Ldata , Lsamp ) = sc . reconcile_laplacians ( Ldata , Lsamp )  else :              ( Lsamp , Ldata ) = sc . reconcile_laplacians ( Lsamp , Ldata )  KLsave . append ( metric_func ( Ldata , Lsamp , beta ) )  m = np . mean ( KLsave ) std = np . std ( KLsave ) stderr = std / np . sqrt ( n_samples ) return ( m , stderr )   