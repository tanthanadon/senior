import numpy as np import scipy . linalg as spla import networkx as nx from sklearn . manifold import MDS from sklearn . decomposition import PCA def mu_k ( k , Ncells ) :      return 1 - np . pi * np . sqrt ( float ( k - 1 ) / float ( Ncells ) )  def add_cellgroups ( graph , cg , Ncells , depth ) :      cg_orig = tuple ( cg ) cg_list = list ( cg ) if len ( cg_list ) <= 1 :          return  k = len ( cg ) - 1 muk = mu_k ( k , Ncells ) if len ( cg_list ) > 1 :          for ind in range ( len ( cg ) ) :              a = cg_list . pop ( ind ) graph . add_edge ( tuple ( cg_list ) , cg_orig , weight = muk ) add_cellgroups ( graph , cg_list , Ncells , depth + 1 ) cg_list . insert ( ind , a )   return  def stimspacegraph_nx ( maxsimps , Ncells , stimuli = None ) :      g = nx . Graph ( ) depth = 0 for maxsimp in maxsimps :          add_cellgroups ( g , maxsimp , Ncells , depth )  if stimuli is not None :          vals = dict ( ) for ind , cg in enumerate ( maxsimps ) :              vals [ cg ] = stimuli [ ind , : ]  nx . set_node_attributes ( g , <str> , vals )  return g  def binnedtobinary ( popvec , thresh ) :      popvec = np . array ( popvec ) Ncells , Nwin = np . shape ( popvec ) means = popvec . sum ( 1 ) / Nwin means = np . tile ( means , ( Nwin , 1 ) ) . T meanthr = thresh * means activeUnits = np . greater ( popvec , meanthr ) . astype ( int ) return activeUnits  def binarytomaxsimplex ( binMat , rDup = False , clus = None ) :      if rDup :          lexInd = np . lexsort ( binMat ) binMat = binMat [ : , lexInd ] diff = np . diff ( binMat , axis = 1 ) ui = np . ones ( len ( binMat . T ) , <str> ) ui [ 1 : ] = ( diff != 0 ) . any ( axis = 0 ) binMat = binMat [ : , ui ]  Ncells , Nwin = np . shape ( binMat ) if not clus :          clus = np . arange ( Ncells )  MaxSimps = [ ] MaxSimps = [ tuple ( clus [ list ( np . nonzero ( t ) [ 0 ] ) ] ) for t in binMat . T if list ( np . nonzero ( t ) [ 0 ] ) ] return MaxSimps  def adjacency2maxsimp ( adjmat , basis ) :      maxsimps = [ ] uptr = np . triu ( adjmat ) for b in basis :          maxsimps . append ( ( b , ) )  for ind , row in enumerate ( uptr ) :          for targ , val in enumerate ( row ) :              if val > 0 :                  maxsimps . append ( tuple ( sorted ( ( basis [ ind ] , basis [ targ ] ) ) ) )    return maxsimps  def prepare_affine_data ( binmat , stim , embed_pts , sorted_node_list ) :      stimdim , nwin = np . shape ( stim ) _ , embeddim = np . shape ( embed_pts ) assert np . shape ( binmat ) [ 1 ] == nwin maxsimps = binarytomaxsimplex ( binmat ) inds = np . nonzero ( ( np . sum ( binmat , axis = 0 ) > 0 ) ) [ 0 ] y = np . zeros ( ( stimdim , len ( inds ) ) ) x = np . zeros ( ( embeddim , len ( inds ) ) ) for ptind , ( cg , ind ) in enumerate ( zip ( maxsimps , inds ) ) :          if cg not in sorted_node_list :              continue  y [ : , ptind ] = stim [ : , ind ] x [ : , ptind ] = get_mds_position_of_cg ( cg , embed_pts , sorted_node_list )  return ( x , y )  def mds_embed ( graph ) :      sorted_node_list = sorted ( list ( graph . nodes ( ) ) , key = len ) dmat = nx . floyd_warshall_numpy ( graph , nodelist = sorted_node_list ) gmds = MDS ( n_jobs = - 2 , dissimilarity = <str> ) embed_pts = gmds . fit_transform ( dmat ) return ( embed_pts , dmat , sorted_node_list )  def get_mds_position_of_cg ( cg , embed_pts , sorted_node_list ) :      return embed_pts [ sorted_node_list . index ( cg ) , : ]  def prepare_stimulus ( stimfile ) :      pass  def affine_loss ( affine , x , y , stimdim , embeddim ) :      A = np . array ( affine [ 0 : stimdim * embeddim ] ) b = np . array ( affine [ stimdim * embeddim : ] ) A = np . reshape ( A , ( stimdim , embeddim ) ) yhat = np . dot ( A , x ) yhat += np . tile ( b [ : , np . newaxis ] , ( 1 , np . shape ( x ) [ 1 ] ) ) s = np . power ( yhat - y , 2 ) s = np . sum ( s , axis = 0 ) return ( 1 / 2 ) * np . sum ( s )  def affine_loss_jac ( affine , x , y , stimdim , embeddim ) :      A = np . array ( affine [ 0 : stimdim * embeddim ] ) b = np . array ( affine [ stimdim * embeddim : ] ) A = np . reshape ( A , ( stimdim , embeddim ) ) yhat = np . dot ( A , x ) yhat += np . tile ( b [ : , np . newaxis ] , ( 1 , np . shape ( x ) [ 1 ] ) ) da = np . einsum ( <str> , ( yhat - y ) , x ) db = np . sum ( yhaty , axis = 1 ) da = np . reshape ( da , stimdim * embeddim ) jac_affine = np . zeros ( ( stimdim * embeddim + stimdim ) ) jac_affine [ 0 : stimdim * embeddim ] = da jac_affine [ stimdim * embeddim : ] = db return jac_affine  def decompose_matrix ( m ) :      n , n1 = np . shape ( m ) assert n1 == n tr = np . trace ( m ) tr = tr * np . eye ( n ) / n symm = ( 1 / 2 ) * ( ( m - tr ) + ( m - tr ) . T ) asymm = ( 1 / 2 ) * ( m - m . T ) return ( tr , symm , asymm )  def affine_transform ( affine , x , sd , ed ) :      A = np . reshape ( affine [ 0 : sd * ed ] , ( sd , ed ) ) b = np . array ( affine [ sd * ed : ] ) yhat = np . dot ( A , x ) + np . tile ( b [ : , np . newaxis ] , ( 1 , np . shape ( x ) [ 1 ] ) ) return yhat  def h_mds ( dmat ) :      Y = np . cosh ( dmat )   