import neuraltda . stimulus_space as ss import neuraltda . topology2 as tp2 import h5py import os import pickle import numpy as np from joblib import Parallel , delayed import pycuslsa as pyslsa def pyslsa_compute_chain_group ( poptens , thresh , trial ) :      popmat = poptens [ : , : , trial ] popmat_binary = ss . binnedtobinary ( popmat , thresh ) maxsimps = ss . binarytomaxsimplex ( popmat_binary , rDup = True ) maxsimps = sorted ( maxsimps , key = len ) scgGens = pyslsa . build_SCG ( maxsimps ) return scgGens  def computeChainGroup ( poptens , thresh , trial ) :      popmat = poptens [ : , : , trial ] popmatbinary = ss . binnedtobinary ( popmat , thresh ) maxsimps = ss . binarytomaxsimplex ( popmatbinary , rDup = True ) maxsimps = sorted ( maxsimps , key = len ) newms = maxsimps r = 1 scgGens = ss . simplicialChainGroups ( newms ) return scgGens  def parallel_compute_chain_group ( bdf , stim , thresh ) :      poptens = np . array ( bdf [ stim ] [ <str> ] ) try :          ( ncell , nwin , ntrial ) = np . shape ( poptens )  except ValueError :          print ( <str> ) return  if nwin == 0 :          return  scgGenSave = dict ( ) scgGenSave = Parallel ( n_jobs = 14 ) ( delayed ( computeChainGroup ) ( poptens , thresh , trial ) for trial in range ( ntrial ) )  def pyslsa_compute_chain_groups_binned ( blockPath , binned_datafile , thresh , comment = <str> , shuffle = False , clusters = None , nperms = None , ncellsperm = 30 , ) :      print ( <str> ) with h5py . File ( binned_datafile , <str> ) as bdf :          stims = bdf . keys ( ) print ( stims ) stimGenSave = dict ( ) for ind , stim in enumerate ( stims ) :              binned_clusters = np . array ( bdf [ stim ] [ <str> ] ) poptens = np . array ( bdf [ stim ] [ <str> ] ) print ( <str> . format ( stim , str ( clusters ) ) ) try :                  if clusters is not None :                      poptens = poptens [ np . in1d ( binned_clusters , clusters ) , : , : ] print ( <str> + str ( np . shape ( poptens ) ) )  ( ncell , nwin , ntrial ) = np . shape ( poptens )  except ( ValueError , IndexError ) :                  print ( <str> ) continue  if shuffle :                  poptens = tp2 . build_shuffled_data_tensor ( poptens , 1 ) poptens = poptens [ : , : , : , 0 ]  if nperms :                  print ( <str> ) poptens = tp2 . build_permuted_data_tensor ( poptens , ncellsperm , nperms ) poptens = np . reshape ( poptens , ( ncellsperm , nwin , ntrial * nperms ) ) ntrial = ntrial * nperms  if nwin == 0 :                  continue  print ( <str> ) scgGenSave = [ ] for trial in range ( ntrial ) :                  scgGenSave . append ( pyslsa_compute_chain_group ( poptens , thresh , trial ) )  stimGenSave [ stim ] = scgGenSave   return stimGenSave  def computeChainGroups ( blockPath , binned_datafile , thresh , comment = <str> , shuffle = False , clusters = None , nperms = None , ncellsperm = 30 , ) :      print ( <str> ) with h5py . File ( binned_datafile , <str> ) as bdf :          stims = bdf . keys ( ) print ( stims ) stimGenSave = dict ( ) for ind , stim in enumerate ( stims ) :              binned_clusters = np . array ( bdf [ stim ] [ <str> ] ) poptens = np . array ( bdf [ stim ] [ <str> ] ) print ( <str> . format ( stim , str ( clusters ) ) ) try :                  if clusters is not None :                      poptens = poptens [ np . in1d ( binned_clusters , clusters ) , : , : ] print ( <str> + str ( np . shape ( poptens ) ) )  ( ncell , nwin , ntrial ) = np . shape ( poptens )  except ( ValueError , IndexError ) :                  print ( <str> ) continue  if shuffle :                  poptens = tp2 . build_shuffled_data_tensor ( poptens , 1 ) poptens = poptens [ : , : , : , 0 ]  if nperms :                  print ( <str> ) poptens = tp2 . build_permuted_data_tensor ( poptens , ncellsperm , nperms ) poptens = np . reshape ( poptens , ( ncellsperm , nwin , ntrial * nperms ) ) ntrial = ntrial * nperms  if nwin == 0 :                  continue  print ( <str> ) scgGenSave = Parallel ( n_jobs = 14 ) ( delayed ( computeChainGroup ) ( poptens , thresh , trial ) for trial in range ( ntrial ) ) stimGenSave [ stim ] = scgGenSave   ( binFold , binFile ) = os . path . split ( binned_datafile ) ( binFileName , binExt ) = os . path . splitext ( binFile ) scg_prefix = <str> . format ( thresh ) if not ( comment == <str> ) :          scg_prefix = scg_prefix + <str> . format ( comment )  scgGenFile = binFileName + scg_prefix + <str> scgFold = os . path . join ( blockPath , <str> ) if not os . path . exists ( scgFold ) :          os . makedirs ( scgFold )  scgGenFile = os . path . join ( scgFold , scgGenFile ) with open ( scgGenFile , <str> ) as scggf :          pickle . dump ( stimGenSave , scggf )  return scgGenFile  def computeSimplicialLaplacians ( scgf ) :      ( scgFold , scgFile ) = os . path . split ( scgf ) ( scgFileName , scgExt ) = os . path . splitext ( scgFile ) LapFile = scgFileName + <str> with open ( scgf , <str> ) as scgff :          E = pickle . load ( scgff )  LapDict = dict ( ) for stim in E . keys ( ) :          stimSCGs = E [ stim ] trialDict = dict ( ) for trial in stimSCGs . keys ( ) :              print ( <str> . format ( stim , trial ) ) scg = stimSCGs [ trial ] D = ss . boundaryOperatorMatrix ( scg ) trialDict [ trial ] = ss . laplacians ( D )  LapDict [ stim ] = trialDict  LapFile = os . path . join ( scgFold , LapFile ) with open ( LapFile , <str> ) as lpf :          pickle . dump ( LapDict , lpf )   def compute_JS_expanded ( scgA , scgB , d , beta ) :      LA = ss . compute_laplacian ( scgA , d ) LB = ss . compute_laplacian ( scgB , d ) ( LA , LB ) = sc . reconcile_laplacians ( LA , LB ) rho1 = sc . densityMatrix ( LA , beta ) rho2 = sc . densityMatrix ( LB , beta ) div = sc . JSdivergence ( rho1 , rho2 ) return div  def compute_JS_expanded_SSG ( scgA , scgB , beta ) :      DA = sc . boundaryOperatorMatrices ( scgA ) DB = sc . boundaryOperatorMatrices ( scgB ) GA , ex = sc . stimSpaceGraph ( scgA , DA ) GB , ex = sc . stimSpaceGraph ( scgB , DB ) LA = np . diag ( np . sum ( GA , axis = 0 ) ) - GA LB = np . diag ( np . sum ( GB , axis = 0 ) ) - GB ( LA , LB ) = sc . reconcile_laplacians ( LA , LB ) rho1 = sc . densityMatrix ( LA , beta ) rho2 = sc . densityMatrix ( LB , beta ) div = sc . JSdivergence ( rho1 , rho2 ) return div  def compute_JS_expanded_negativeL ( scgA , scgB , d , beta ) :      DA = sc . boundaryOperatorMatrix ( scgA ) DB = sc . boundaryOperatorMatrix ( scgB ) LA = sc . laplacian ( DA , d ) LB = sc . laplacian ( DB , d ) ( LA , LB ) = sc . reconcile_laplacians ( LA , LB ) rho1 = sc . densityMatrix ( - 1.0 * LA , beta ) rho2 = sc . densityMatrix ( - 1.0 * LB , beta ) div = sc . JSdivergence ( rho1 , rho2 ) return div  def compute_entropy ( scgA , d , beta ) :      DA = sc . boundaryOperatorMatrix ( scgA ) LA = sc . laplacian ( DA , d ) rho1 = sc . densityMatrix ( LA , beta ) div = sc . Entropy ( rho1 ) return div   