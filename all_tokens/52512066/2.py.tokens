import matplotlib matplotlib . use ( <str> ) import pickle import matplotlib . pyplot as plt from scipy . misc import imread from matplotlib . patches import Rectangle import numpy as np import pylab as pl from utils import rgb2gray , transparent_cmap from scipy . io import savemat class Output :      def __init__ ( self , mode , category , prune_tree_levels , experiment ) :          self . category = category self . prune_tree_levels = prune_tree_levels self . mode = mode self . experiment = experiment self . mse_path = <str> self . ae_path = <str> self . nn_path = <str> self . npe_path = <str> self . model_path = <str> self . plot_path = <str> self . preds_plot_path = <str> self . image_path = <str> self . scaler_path = <str> if mode . startswith ( <str> ) :                  self . scaler_category_path = <str> % ( category )  elif mode . startswith ( <str> ) :              self . scaler_category_path = <str> % ( category ) self . classifier_path = <str> % ( category )  self . feat_var_path = <str> self . loss_path = <str> self . compare_path = <str> self . best_path = <str> self . avg_path = <str> self . avg_path_ = <str> self . upd_path = <str> self . upd_path_new = <str> if self . mode == <str> :              self . train_mat_path = <str> self . test_mat_path = <str>  elif self . mode . startswith ( <str> ) :              self . train_mat_path = <str> self . test_mat_path = <str>  elif self . mode == <str> :              self . train_mat_path = <str> self . test_mat_path = <str>  else :              self . train_mat_path = <str> self . test_mat_path = <str>  self . preds_path = <str> self . label_path = <str>  def dump_scaler ( self , scaler ) :          pickle . dump ( scaler , open ( self . scaler_path , <str> ) )  def dump_scaler_category ( self , scaler ) :          pickle . dump ( scaler , open ( self . scaler_category_path , <str> ) )  def dump_classifier ( self , classifier ) :          pickle . dump ( classifier , open ( self . classifier_path , <str> ) )  def save ( self , mse_level , ae_level , nn , sgd , eta0 , alpha , learn_mode ) :          pickle . dump ( sgd . w , open ( self . model_path % ( self . experiment , self . mode , self . category , self . prune_tree_levels , eta0 , alpha , learn_mode ) , <str> ) )  def save_w ( self , sgd , preds , y , eta0 , alpha , learn_mode ) :          pickle . dump ( sgd . w , open ( self . model_path % ( self . experiment , self . mode , self . category , self . prune_tree_levels , eta0 , alpha , learn_mode ) , <str> ) ) pickle . dump ( preds , open ( self . preds_path % ( self . experiment , self . mode , self . category , self . prune_tree_levels , eta0 , alpha , learn_mode ) , <str> ) ) pickle . dump ( y , open ( self . label_path % ( self . experiment , self . mode , self . category , self . prune_tree_levels , eta0 , alpha , learn_mode ) , <str> ) )  def plot_preds ( self , preds , y , alpha , dataset ) :          if self . mode . endswith ( <str> ) :              f , ax = plt . subplots ( self . prune_tree_levels ) for lvl in range ( self . prune_tree_levels ) :                  ax [ lvl ] . plot ( preds [ lvl ] , <str> , label = <str> ) ax [ lvl ] . plot ( y , <str> , label = <str> ) ax [ lvl ] . tick_params ( axis = <str> , which = <str> , bottom = <str> , top = <str> , labelbottom = <str> ) ax [ lvl ] . title . set_text ( <str> % ( lvl ) )   else :              sorted_preds = [ ] sorted_y = [ ] decorated = [ ( y_i , i ) for i , y_i in enumerate ( y ) ] decorated . sort ( ) for y_i , i in reversed ( decorated ) :                  sorted_preds . append ( preds [ i ] ) sorted_y . append ( y_i )  plt . figure ( ) plt . plot ( range ( len ( preds ) ) , preds , <str> , label = <str> ) plt . plot ( range ( len ( preds ) ) , y , <str> , label = <str> ) plt . ylabel ( <str> ) plt . ylim ( [ - 1 , max ( max ( preds , y ) ) + 1 ] ) plt . xlim ( [ - 1 , len ( preds ) + 1 ] ) plt . legend ( loc = <str> ) plt . title ( <str> % ( alpha ) )  plt . savefig ( self . preds_plot_path % ( self . mode , alpha , self . category , dataset , self . prune_tree_levels ) )  def plot_level_boxes ( self , rects , img_nr ) :          colors = [ <str> , <str> , <str> ] im = imread ( self . image_path % ( format ( img_nr , <str> ) ) ) plt . imshow ( im ) plt . axis ( <str> ) ax = plt . gca ( ) for rect , c in zip ( rects , colors ) :              ax . add_patch ( Rectangle ( ( int ( rect [ 0 ] ) , int ( rect [ 1 ] ) ) , int ( rect [ 2 ] - rect [ 0 ] ) , int ( rect [ 3 ] - rect [ 1 ] ) , edgecolor = c , facecolor = c , alpha = 0.5 ) )  plt . savefig ( self . plot_path % ( img_nr , <str> ) ) plt . clf ( ) f , ax = plt . subplots ( 3 ) ax [ 0 ] . imshow ( im [ rects [ 0 ] [ 1 ] : rects [ 0 ] [ 3 ] , rects [ 0 ] [ 0 ] : rects [ 0 ] [ 2 ] ] ) ax [ 1 ] . imshow ( im [ rects [ 1 ] [ 1 ] : rects [ 1 ] [ 3 ] , rects [ 1 ] [ 0 ] : rects [ 1 ] [ 2 ] ] ) ax [ 2 ] . imshow ( im [ rects [ 2 ] [ 1 ] : rects [ 2 ] [ 3 ] , rects [ 2 ] [ 0 ] : rects [ 2 ] [ 2 ] ] ) plt . savefig ( self . plot_path % ( img_nr , <str> ) )  def plot_features_variance ( self , var1 , var2 ) :          f , ax = plt . subplots ( 2 ) ax [ 0 ] . plot ( var1 , <str> ) ax [ 1 ] . plot ( var2 , <str> ) plt . savefig ( self . feat_var_path )  def plot_train_val_loss_old ( self , train , val , eta , alpha ) :          plt . clf ( ) plt . plot ( train , <str> , label = <str> ) plt . plot ( val , <str> , label = <str> ) plt . legend ( ) plt . savefig ( self . loss_path % ( self . experiment , self . prune_tree_levels , eta , self . category , alpha ) )  def plot_train_val_loss ( self , train , val , mses , eta , alpha ) :          plt . clf ( ) f , ax = plt . subplots ( self . prune_tree_levels + 1 ) for lvl in range ( self . prune_tree_levels + 1 ) :              ax [ lvl ] . plot ( train [ lvl ] , <str> , label = <str> ) ax [ lvl ] . plot ( val [ lvl ] , <str> , label = <str> ) ax [ lvl ] . tick_params ( axis = <str> , which = <str> , bottom = <str> , top = <str> , labelbottom = <str> ) if lvl == self . prune_tree_levels :                  ax [ lvl ] . title . set_text ( <str> ) ax [ lvl ] . plot ( mses , <str> , label = <str> )  else :                  ax [ lvl ] . title . set_text ( <str> % ( lvl ) )   plt . legend ( <str> ) plt . savefig ( self . loss_path % ( self . experiment , self . prune_tree_levels , eta , self . category , alpha , self . mode ) )  def compare_train_val_loss ( self , train , val , train_old , val_old , mses , mses_old , eta , alpha ) :          plt . clf ( ) f , ax = plt . subplots ( self . prune_tree_levels + 1 ) for lvl in range ( self . prune_tree_levels + 1 ) :              ax [ lvl ] . plot ( train [ lvl ] , <str> , label = <str> ) ax [ lvl ] . plot ( val [ lvl ] , <str> , label = <str> ) ax [ lvl ] . plot ( train_old [ lvl ] , <str> , label = <str> ) ax [ lvl ] . plot ( val_old [ lvl ] , <str> , label = <str> ) ax [ lvl ] . tick_params ( axis = <str> , which = <str> , bottom = <str> , top = <str> , labelbottom = <str> ) if lvl == self . prune_tree_levels :                  ax [ lvl ] . title . set_text ( <str> ) ax [ lvl ] . plot ( mses , <str> , label = <str> ) ax [ lvl ] . plot ( mses_old , <str> , label = <str> )  else :                  ax [ lvl ] . title . set_text ( <str> % ( lvl ) )   plt . savefig ( self . compare_path % ( self . experiment , self . prune_tree_levels , eta , self . category , alpha , self . mode ) )  def plot_best ( self , level_preds , max_level_window , min_level_window , avg_pixls , al_i ) :          for img_nr in level_preds . keys ( ) :              im = imread ( <str> + ( format ( img_nr , <str> ) ) + <str> ) for lvl , ( lvl_pred , b_patch , m_patch ) in enumerate ( zip ( level_preds [ img_nr ] , max_level_window [ img_nr ] , min_level_window [ img_nr ] ) ) :                  coord_iep = b_patch [ 0 ] coord_iep_ = m_patch [ 0 ] plt . imshow ( im ) plt . axis ( <str> ) ax = plt . gca ( ) ax . add_patch ( Rectangle ( ( int ( coord_iep [ 0 ] ) , int ( coord_iep [ 1 ] ) ) , int ( coord_iep [ 2 ] - coord_iep [ 0 ] ) , int ( coord_iep [ 3 ] - coord_iep [ 1 ] ) , edgecolor = <str> , facecolor = <str> ) ) ax . add_patch ( Rectangle ( ( int ( coord_iep_ [ 0 ] ) , int ( coord_iep_ [ 1 ] ) ) , int ( coord_iep_ [ 2 ] - coord_iep_ [ 0 ] ) , int ( coord_iep_ [ 3 ] - coord_iep_ [ 1 ] ) , edgecolor = <str> , facecolor = <str> ) ) ax . set_title ( <str> % ( b_patch [ 1 ] , m_patch [ 1 ] , lvl_pred ) ) plt . savefig ( self . best_path % ( self . category , img_nr , lvl , al_i ) ) plt . clf ( ) ax = plt . gca ( ) ax . imshow ( im ) mycmap = transparent_cmap ( plt . cm . Reds ) im_cut = avg_pixls [ img_nr ] [ lvl ] im_heat = np . zeros ( ( im . shape [ 0 ] , im . shape [ 1 ] , 4 ) ) im_heat [ : , : , : 3 ] = im im_heat [ : , : , 3 ] = np . rint ( 255.0 / ( im_cut + np . max ( im_cut ) ) ) cb = ax . contourf ( im_cut , 15 , cmap = mycmap ) ax . axis ( <str> ) plt . colorbar ( cb ) plt . savefig ( self . avg_path % ( self . category , img_nr , lvl , al_i ) ) plt . clf ( )    def plot_updates ( self , updates1 , updates2 , updates3 ) :          plt . plot ( [ upd [ 0 ] for upd in updates1 ] , <str> , label = <str> ) plt . plot ( [ upd [ 1 ] for upd in updates1 ] , <str> , label = <str> ) plt . plot ( [ upd [ 0 ] for upd in updates2 ] , <str> , label = <str> ) plt . plot ( [ upd [ 1 ] for upd in updates2 ] , <str> , label = <str> ) plt . plot ( [ upd [ 0 ] for upd in updates3 ] , <str> , label = <str> ) plt . plot ( [ upd [ 1 ] for upd in updates3 ] , <str> , label = <str> ) plt . savefig ( self . upd_path % ( self . category ) )  def plot_updates_new ( self , updates1 , updates2 ) :          plt . plot ( updates1 , <str> , label = <str> ) plt . plot ( updates2 , <str> , label = <str> ) plt . savefig ( self . upd_path_new % ( self . category ) )  def save_mat ( self , train_mat , test_mat , dataset , from_ , to_ , level_size = <str> ) :          print self . train_mat_path % ( dataset , level_size ) , self . test_mat_path % ( dataset , level_size ) raw_input ( ) if dataset == <str> :             savemat ( self . train_mat_path % ( from_ , to_ ) , train_mat ) print self . test_mat_path % ( from_ , to_ ) savemat ( self . test_mat_path % ( from_ , to_ ) , test_mat )  if train_mat != [ ] :              savemat ( self . train_mat_path % ( dataset , level_size ) , train_mat ) print <str>  if test_mat != [ ] :              savemat ( self . test_mat_path % ( dataset , level_size ) , test_mat ) print <str>  raw_input ( ) print <str> , self . test_mat_path % ( from_ , to_ )    