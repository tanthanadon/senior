from __future__ import absolute_import from __future__ import division from __future__ import print_function from __future__ import unicode_literals import qrcode import textwrap import six import time from re import match as re_match import barcode from barcode . writer import ImageWriter import os from . constants import ESC , GS , NUL , QR_ECLEVEL_L , QR_ECLEVEL_M , QR_ECLEVEL_H , QR_ECLEVEL_Q from . constants import QR_MODEL_1 , QR_MODEL_2 , QR_MICRO , BARCODE_TYPES , BARCODE_HEIGHT , BARCODE_WIDTH from . constants import BARCODE_FONT_A , BARCODE_FONT_B , BARCODE_FORMATS from . constants import BARCODE_TXT_OFF , BARCODE_TXT_BTH , BARCODE_TXT_ABV , BARCODE_TXT_BLW from . constants import TXT_SIZE , TXT_NORMAL from . constants import SET_FONT from . constants import LINESPACING_FUNCS , LINESPACING_RESET from . constants import LINE_DISPLAY_OPEN , LINE_DISPLAY_CLEAR , LINE_DISPLAY_CLOSE from . constants import CD_KICK_DEC_SEQUENCE , CD_KICK_5 , CD_KICK_2 , PAPER_FULL_CUT , PAPER_PART_CUT from . constants import HW_RESET , HW_SELECT , HW_INIT from . constants import CTL_VT , CTL_CR , CTL_FF , CTL_LF , CTL_SET_HT , PANEL_BUTTON_OFF , PANEL_BUTTON_ON from . constants import TXT_STYLE from . constants import RT_STATUS_ONLINE , RT_MASK_ONLINE from . constants import RT_STATUS_PAPER , RT_MASK_PAPER , RT_MASK_LOWPAPER , RT_MASK_NOPAPER from . exceptions import BarcodeTypeError , BarcodeSizeError , TabPosError from . exceptions import CashDrawerError , SetVariableError , BarcodeCodeError from . exceptions import ImageWidthError from . magicencode import MagicEncode from abc import ABCMeta , abstractmethod from escpos . image import EscposImage from escpos . capabilities import get_profile , BARCODE_B @ six . add_metaclass ( ABCMeta ) class Escpos ( object ) :      device = None def __init__ ( self , profile = None , magic_encode_args = None , ** kwargs ) :          self . profile = get_profile ( profile ) self . magic = MagicEncode ( self , ** ( magic_encode_args or { } ) )  def __del__ ( self ) :          self . close ( )  @ abstractmethod def _raw ( self , msg ) :          pass  def _read ( self ) :          raise NotImplementedError ( )  def image ( self , img_source , high_density_vertical = True , high_density_horizontal = True , impl = <str> , fragment_height = 960 , center = False ) :          im = EscposImage ( img_source ) try :              max_width = int ( self . profile . profile_data [ <str> ] [ <str> ] [ <str> ] ) if im . width > max_width :                  raise ImageWidthError ( <str> . format ( im . width , max_width ) )  if center :                  im . center ( max_width )   except KeyError :              pass  except ValueError :              pass  if im . height > fragment_height :              fragments = im . split ( fragment_height ) for fragment in fragments :                  self . image ( fragment , high_density_vertical = high_density_vertical , high_density_horizontal = high_density_horizontal , impl = impl , fragment_height = fragment_height )  return  if impl == <str> :              density_byte = ( 0 if high_density_horizontal else 1 ) + ( 0 if high_density_vertical else 2 ) header = GS + <str> + six . int2byte ( density_byte ) + self . _int_low_high ( im . width_bytes , 2 ) + self . _int_low_high ( im . height , 2 ) self . _raw ( header + im . to_raster_format ( ) )  if impl == <str> :              img_header = self . _int_low_high ( im . width , 2 ) + self . _int_low_high ( im . height , 2 ) tone = <str> colors = <str> ym = six . int2byte ( 1 if high_density_vertical else 2 ) xm = six . int2byte ( 1 if high_density_horizontal else 2 ) header = tone + xm + ym + colors + img_header raster_data = im . to_raster_format ( ) self . _image_send_graphics_data ( <str> , <str> , header + raster_data ) self . _image_send_graphics_data ( <str> , <str> , <str> )  if impl == <str> :              density_byte = ( 1 if high_density_horizontal else 0 ) + ( 32 if high_density_vertical else 0 ) header = ESC + <str> + six . int2byte ( density_byte ) + self . _int_low_high ( im . width , 2 ) outp = [ ESC + <str> + six . int2byte ( 16 ) ] for blob in im . to_column_format ( high_density_vertical ) :                  outp . append ( header + blob + <str> )  outp . append ( ESC + <str> ) self . _raw ( <str> . join ( outp ) )   def _image_send_graphics_data ( self , m , fn , data ) :          header = self . _int_low_high ( len ( data ) + 2 , 2 ) self . _raw ( GS + <str> + header + m + fn + data )  def qr ( self , content , ec = QR_ECLEVEL_L , size = 3 , model = QR_MODEL_2 , native = False , center = False , impl = <str> ) :          if ec not in [ QR_ECLEVEL_L , QR_ECLEVEL_M , QR_ECLEVEL_H , QR_ECLEVEL_Q ] :              raise ValueError ( <str> )  if not 1 <= size <= 16 :              raise ValueError ( <str> )  if model not in [ QR_MODEL_1 , QR_MODEL_2 , QR_MICRO ] :              raise ValueError ( <str> )  if content == <str> :              return  if not native :              if model != QR_MODEL_2 :                  raise ValueError ( <str> )  python_qr_ec = { QR_ECLEVEL_H : qrcode . constants . ERROR_CORRECT_H , QR_ECLEVEL_L : qrcode . constants . ERROR_CORRECT_L , QR_ECLEVEL_M : qrcode . constants . ERROR_CORRECT_M , QR_ECLEVEL_Q : qrcode . constants . ERROR_CORRECT_Q } qr_code = qrcode . QRCode ( version = None , box_size = size , border = 1 , error_correction = python_qr_ec [ ec ] ) qr_code . add_data ( content ) qr_code . make ( fit = True ) qr_img = qr_code . make_image ( ) im = qr_img . _img . convert ( <str> ) self . text ( <str> ) self . image ( im , center = center , impl = impl ) self . text ( <str> ) self . text ( <str> ) return  if center :              raise NotImplementedError ( <str> )  cn = <str> self . _send_2d_code_data ( six . int2byte ( 65 ) , cn , six . int2byte ( 48 + model ) + six . int2byte ( 0 ) ) self . _send_2d_code_data ( six . int2byte ( 67 ) , cn , six . int2byte ( size ) ) self . _send_2d_code_data ( six . int2byte ( 69 ) , cn , six . int2byte ( 48 + ec ) ) self . _send_2d_code_data ( six . int2byte ( 80 ) , cn , content . encode ( <str> ) , <str> ) self . _send_2d_code_data ( six . int2byte ( 81 ) , cn , <str> , <str> )  def _send_2d_code_data ( self , fn , cn , data , m = <str> ) :          if len ( m ) > 1 or len ( cn ) != 1 or len ( fn ) != 1 :              raise ValueError ( <str> )  header = self . _int_low_high ( len ( data ) + len ( m ) + 2 , 2 ) self . _raw ( GS + <str> + header + cn + fn + m + data )  @ staticmethod def _int_low_high ( inp_number , out_bytes ) :          max_input = ( 256 << ( out_bytes * 8 ) - 1 ) if not 1 <= out_bytes <= 4 :              raise ValueError ( <str> )  if not 0 <= inp_number <= max_input :              raise ValueError ( <str> . format ( max_input , out_bytes ) )  outp = <str> for _ in range ( 0 , out_bytes ) :              outp += six . int2byte ( inp_number % 256 ) inp_number //= 256  return outp  def charcode ( self , code = <str> ) :          if code . upper ( ) == <str> :              self . magic . force_encoding ( False )  else :              self . magic . force_encoding ( code )   @ staticmethod def check_barcode ( bc , code ) :          if bc not in BARCODE_FORMATS :              return False  bounds , regex = BARCODE_FORMATS [ bc ] return any ( bound [ 0 ] <= len ( code ) <= bound [ 1 ] for bound in bounds ) and re_match ( regex , code )  def barcode ( self , code , bc , height = 64 , width = 3 , pos = <str> , font = <str> , align_ct = True , function_type = None , check = True ) :          if function_type is None :              if bc in BARCODE_TYPES [ <str> ] :                  function_type = <str>  else :                  if bc in BARCODE_TYPES [ <str> ] :                      if not self . profile . supports ( BARCODE_B ) :                          raise BarcodeTypeError ( ( <str> <str> ) . format ( bc = bc ) )  function_type = <str>  else :                      raise BarcodeTypeError ( ( <str> ) . format ( bc = bc ) )    bc_types = BARCODE_TYPES [ function_type . upper ( ) ] if bc . upper ( ) not in bc_types . keys ( ) :              raise BarcodeTypeError ( ( <str> <str> ) . format ( bc = bc , function_type = function_type , ) )  if check and not self . check_barcode ( bc , code ) :              raise BarcodeCodeError ( ( <str> ) . format ( code = code , bc = bc , ) )  if align_ct :              self . _raw ( TXT_STYLE [ <str> ] [ <str> ] )  if 1 <= height <= 255 :              self . _raw ( BARCODE_HEIGHT + six . int2byte ( height ) )  else :              raise BarcodeSizeError ( <str> . format ( height = height ) )  if 2 <= width <= 6 :              self . _raw ( BARCODE_WIDTH + six . int2byte ( width ) )  else :              raise BarcodeSizeError ( <str> . format ( width = width ) )  if font . upper ( ) == <str> :              self . _raw ( BARCODE_FONT_B )  else :              self . _raw ( BARCODE_FONT_A )  if pos . upper ( ) == <str> :              self . _raw ( BARCODE_TXT_OFF )  elif pos . upper ( ) == <str> :              self . _raw ( BARCODE_TXT_BTH )  elif pos . upper ( ) == <str> :              self . _raw ( BARCODE_TXT_ABV )  else :              self . _raw ( BARCODE_TXT_BLW )  self . _raw ( bc_types [ bc . upper ( ) ] ) if function_type . upper ( ) == <str> :              self . _raw ( six . int2byte ( len ( code ) ) )  if code :              self . _raw ( code . encode ( ) )  else :              raise BarcodeCodeError ( )  if function_type . upper ( ) == <str> :              self . _raw ( NUL )   def soft_barcode ( self , barcode_type , data , impl = <str> , module_height = 5 , module_width = 0.2 , text_distance = 1 ) :          image_writer = ImageWriter ( ) if barcode_type not in barcode . PROVIDED_BARCODES :              raise BarcodeTypeError ( <str> . format ( barcode_type ) )  barcode_class = barcode . get_barcode_class ( barcode_type ) my_code = barcode_class ( data , writer = image_writer ) with open ( os . devnull , <str> ) as nullfile :              my_code . write ( nullfile , { <str> : module_height , <str> : module_width , <str> : text_distance } )  image = my_code . writer . _image self . image ( image , impl = impl )  def text ( self , txt ) :          txt = six . text_type ( txt ) self . magic . write ( txt )  def textln ( self , txt = <str> ) :          self . text ( <str> . format ( txt ) )  def ln ( self , count = 1 ) :          if count < 0 :              raise ValueError ( <str> )  if count > 0 :              self . text ( <str> * count )   def block_text ( self , txt , font = None , columns = None ) :          col_count = self . profile . get_columns ( font ) if columns is None else columns self . text ( textwrap . fill ( txt , col_count ) )  def set ( self , align = <str> , font = <str> , bold = False , underline = 0 , width = 1 , height = 1 , density = 9 , invert = False , smooth = False , flip = False , double_width = False , double_height = False , custom_size = False ) :          if custom_size :              if 1 <= width <= 8 and 1 <= height <= 8 and isinstance ( width , int ) and isinstance ( height , int ) :                  size_byte = TXT_STYLE [ <str> ] [ width ] + TXT_STYLE [ <str> ] [ height ] self . _raw ( TXT_SIZE + six . int2byte ( size_byte ) )  else :                  raise SetVariableError ( )   else :              self . _raw ( TXT_NORMAL ) if double_width and double_height :                  self . _raw ( TXT_STYLE [ <str> ] [ <str> ] )  elif double_width :                  self . _raw ( TXT_STYLE [ <str> ] [ <str> ] )  elif double_height :                  self . _raw ( TXT_STYLE [ <str> ] [ <str> ] )  else :                  self . _raw ( TXT_STYLE [ <str> ] [ <str> ] )   self . _raw ( TXT_STYLE [ <str> ] [ flip ] ) self . _raw ( TXT_STYLE [ <str> ] [ smooth ] ) self . _raw ( TXT_STYLE [ <str> ] [ bold ] ) self . _raw ( TXT_STYLE [ <str> ] [ underline ] ) self . _raw ( SET_FONT ( six . int2byte ( self . profile . get_font ( font ) ) ) ) self . _raw ( TXT_STYLE [ <str> ] [ align ] ) if density != 9 :              self . _raw ( TXT_STYLE [ <str> ] [ density ] )  self . _raw ( TXT_STYLE [ <str> ] [ invert ] )  def line_spacing ( self , spacing = None , divisor = 180 ) :          if spacing is None :              self . _raw ( LINESPACING_RESET ) return  if divisor not in LINESPACING_FUNCS :              raise ValueError ( <str> )  if ( divisor in [ 360 , 180 ] and ( not ( 0 <= spacing <= 255 ) ) ) :              raise ValueError ( <str> )  if divisor == 60 and ( not ( 0 <= spacing <= 85 ) ) :              raise ValueError ( <str> )  self . _raw ( LINESPACING_FUNCS [ divisor ] + six . int2byte ( spacing ) )  def cut ( self , mode = <str> , feed = True ) :          if not feed :              self . _raw ( GS + <str> + six . int2byte ( 66 ) + <str> ) return  self . print_and_feed ( 6 ) mode = mode . upper ( ) if mode not in ( <str> , <str> ) :              raise ValueError ( <str> )  if mode == <str> :              if self . profile . supports ( <str> ) :                  self . _raw ( PAPER_PART_CUT )  elif self . profile . supports ( <str> ) :                  self . _raw ( PAPER_FULL_CUT )   elif mode == <str> :              if self . profile . supports ( <str> ) :                  self . _raw ( PAPER_FULL_CUT )  elif self . profile . supports ( <str> ) :                  self . _raw ( PAPER_PART_CUT )    def cashdraw ( self , pin ) :          if pin == 2 :              self . _raw ( CD_KICK_2 )  elif pin == 5 :              self . _raw ( CD_KICK_5 )  else :              try :                  self . _raw ( CD_KICK_DEC_SEQUENCE ( * pin ) )  except TypeError as err :                  raise CashDrawerError ( err )    def linedisplay_select ( self , select_display = False ) :          if select_display :              self . _raw ( LINE_DISPLAY_OPEN )  else :              self . _raw ( LINE_DISPLAY_CLOSE )   def linedisplay_clear ( self ) :          self . _raw ( LINE_DISPLAY_CLEAR )  def linedisplay ( self , text ) :          self . linedisplay_select ( select_display = True ) self . linedisplay_clear ( ) self . text ( text ) self . linedisplay_select ( select_display = False )  def hw ( self , hw ) :          if hw . upper ( ) == <str> :              self . _raw ( HW_INIT )  elif hw . upper ( ) == <str> :              self . _raw ( HW_SELECT )  elif hw . upper ( ) == <str> :              self . _raw ( HW_RESET )  else :              pass   def print_and_feed ( self , n = 1 ) :          if 0 <= n <= 255 :              self . _raw ( ESC + <str> + six . int2byte ( n ) )  else :              raise ValueError ( <str> )   def control ( self , ctl , count = 5 , tab_size = 8 ) :          if ctl . upper ( ) == <str> :              self . _raw ( CTL_LF )  elif ctl . upper ( ) == <str> :              self . _raw ( CTL_FF )  elif ctl . upper ( ) == <str> :              self . _raw ( CTL_CR )  elif ctl . upper ( ) == <str> :              if not ( 0 <= count <= 32 and 1 <= tab_size <= 255 and count * tab_size < 256 ) :                  raise TabPosError ( )  else :                  self . _raw ( CTL_SET_HT ) for iterator in range ( 1 , count ) :                      self . _raw ( six . int2byte ( iterator * tab_size ) )  self . _raw ( NUL )   elif ctl . upper ( ) == <str> :              self . _raw ( CTL_VT )   def panel_buttons ( self , enable = True ) :          if enable :              self . _raw ( PANEL_BUTTON_ON )  else :              self . _raw ( PANEL_BUTTON_OFF )   def query_status ( self , mode ) :          self . _raw ( mode ) time . sleep ( 1 ) status = self . _read ( ) return status  def is_online ( self ) :          status = self . query_status ( RT_STATUS_ONLINE ) if len ( status ) == 0 :              return False  return not ( status [ 0 ] & RT_MASK_ONLINE )  def paper_status ( self ) :          status = self . query_status ( RT_STATUS_PAPER ) if len ( status ) == 0 :              return 2  if ( status [ 0 ] & RT_MASK_NOPAPER == RT_MASK_NOPAPER ) :              return 0  if ( status [ 0 ] & RT_MASK_LOWPAPER == RT_MASK_LOWPAPER ) :              return 1  if ( status [ 0 ] & RT_MASK_PAPER == RT_MASK_PAPER ) :              return 2    class EscposIO ( object ) :      def __init__ ( self , printer , autocut = True , autoclose = True , ** kwargs ) :          self . printer = printer self . params = kwargs self . autocut = autocut self . autoclose = autoclose  def set ( self , ** kwargs ) :          self . params . update ( kwargs )  def writelines ( self , text , ** kwargs ) :          params = dict ( self . params ) params . update ( kwargs ) if isinstance ( text , six . text_type ) :              lines = text . split ( <str> )  elif isinstance ( text , list ) or isinstance ( text , tuple ) :              lines = text  else :              lines = [ <str> . format ( text ) , ]  for line in lines :              self . printer . set ( ** params ) if isinstance ( text , six . text_type ) :                  self . printer . text ( <str> . format ( line ) )  else :                  self . printer . text ( <str> . format ( line ) )    def close ( self ) :          self . printer . close ( )  def __enter__ ( self , ** kwargs ) :          return self  def __exit__ ( self , type , value , traceback ) :          if not ( type is not None and issubclass ( type , Exception ) ) :              if self . autocut :                  self . printer . cut ( )   if self . autoclose :              self . close ( )     