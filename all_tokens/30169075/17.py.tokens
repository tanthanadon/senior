from __future__ import absolute_import from __future__ import division from __future__ import print_function from __future__ import unicode_literals import six import pytest from hypothesis import given , settings from hypothesis . strategies import text import escpos . printer as printer if six . PY3 :      mock_open_call = <str>  else :      mock_open_call = <str>  @ pytest . mark . skip ( <str> ) @ settings ( use_coverage = False ) @ given ( path = text ( ) ) def test_load_file_printer ( mocker , path ) :      mock_escpos = mocker . patch ( <str> ) mock_open = mocker . patch ( mock_open_call ) printer . File ( devfile = path ) assert mock_escpos . called mock_open . assert_called_with ( path , <str> )  @ pytest . mark . skip ( <str> ) @ settings ( deadline = None , use_coverage = False ) @ given ( txt = text ( ) ) def test_auto_flush ( mocker , txt ) :      mock_escpos = mocker . patch ( <str> ) mock_open = mocker . patch ( mock_open_call ) mock_device = mocker . patch . object ( printer . File , <str> ) p = printer . File ( auto_flush = False ) p . device = mock_device p . _raw ( txt ) assert not mock_device . flush . called mock_device . reset_mock ( ) p = printer . File ( auto_flush = True ) p . device = mock_device p . _raw ( txt ) assert mock_device . flush . called  @ pytest . mark . skip ( <str> ) @ settings ( deadline = None , use_coverage = False ) @ given ( txt = text ( ) ) def test_flush_on_close ( mocker , txt ) :      mock_open = mocker . patch ( mock_open_call ) mock_device = mocker . patch . object ( printer . File , <str> ) p = printer . File ( auto_flush = False ) p . device = mock_device p . _raw ( txt ) assert not mock_device . flush . called p . close ( ) assert mock_device . flush . called assert mock_device . close . called   