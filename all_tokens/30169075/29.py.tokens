import re from os import environ , path import pickle import logging import time import six import yaml from tempfile import gettempdir import platform logging . basicConfig ( ) logger = logging . getLogger ( __name__ ) pickle_dir = environ . get ( <str> , gettempdir ( ) ) pickle_path = path . join ( pickle_dir , <str> . format ( v = platform . python_version ( ) ) ) capabilities_path = environ . get ( <str> , path . join ( path . dirname ( __file__ ) , <str> ) ) t0 = time . time ( ) logger . debug ( <str> , capabilities_path ) if path . exists ( pickle_path ) :      if path . getmtime ( capabilities_path ) > path . getmtime ( pickle_path ) :          logger . debug ( <str> ) full_load = True  else :          full_load = False logger . debug ( <str> , pickle_path ) with open ( pickle_path , <str> ) as cf :              CAPABILITIES = pickle . load ( cf )    else :      logger . debug ( <str> , pickle_path ) full_load = True  if full_load :      logger . debug ( <str> ) with open ( capabilities_path ) as cp , open ( pickle_path , <str> ) as pp :          CAPABILITIES = yaml . safe_load ( cp ) pickle . dump ( CAPABILITIES , pp , protocol = 2 )   logger . debug ( <str> , time . time ( ) - t0 ) PROFILES = CAPABILITIES [ <str> ] class NotSupported ( Exception ) :      pass  BARCODE_B = <str> class BaseProfile ( object ) :      profile_data = { } def __getattr__ ( self , name ) :          return self . profile_data [ name ]  def get_font ( self , font ) :          font = { <str> : 0 , <str> : 1 } . get ( font , font ) if not six . text_type ( font ) in self . fonts :              raise NotSupported ( <str> . format ( font ) )  return font  def get_columns ( self , font ) :          font = self . get_font ( font ) return self . fonts [ six . text_type ( font ) ] [ <str> ]  def supports ( self , feature ) :          return self . features . get ( feature )  def get_code_pages ( self ) :          return { v : k for k , v in self . codePages . items ( ) }   def get_profile ( name = None , ** kwargs ) :      if isinstance ( name , Profile ) :          return name  clazz = get_profile_class ( name or <str> ) return clazz ( ** kwargs )  CLASS_CACHE = { } def get_profile_class ( name ) :      if name not in CLASS_CACHE :          profile_data = PROFILES [ name ] profile_name = clean ( name ) class_name = <str> . format ( profile_name [ 0 ] . upper ( ) , profile_name [ 1 : ] ) new_class = type ( class_name , ( BaseProfile , ) , { <str> : profile_data } ) CLASS_CACHE [ name ] = new_class  return CLASS_CACHE [ name ]  def clean ( s ) :      s = re . sub ( <str> , <str> , s ) s = re . sub ( <str> , <str> , s ) return str ( s )  class Profile ( get_profile_class ( <str> ) ) :      def __init__ ( self , columns = None , features = None ) :          super ( Profile , self ) . __init__ ( ) self . columns = columns self . features = features or { }  def get_columns ( self , font ) :          if self . columns is not None :              return self . columns  return super ( Profile , self ) . get_columns ( font )    