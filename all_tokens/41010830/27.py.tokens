def dyndoc_insert ( src ) :      import json import re def mkblock ( d , flag = 0 ) :          v = json . dumps ( d , indent = 2 ) if flag == 1 :              nw = re . findall ( <str> , v , flags = re . S ) v = nw [ 0 ]  return <str> . format ( <str> . join ( [ <str> . format ( <str> , L ) for L in v . split ( <str> ) ] ) )  def dec ( obj ) :          allSlots = re . findall ( <str> , obj . __doc__ ) docsub = { } sub = { } for k in allSlots :              p = re . findall ( <str> , k ) p = list ( * p ) sub . update ( { p [ 1 ] : p [ 0 ] } )  for v in sub . values ( ) :              for k in sub . keys ( ) :                  docsub [ <str> . format ( v ) ] = <str> . format ( src [ v ] [ <str> ] ) if <str> == k :                      docsub . update ( { <str> . format ( v ) : mkblock ( src [ v ] [ <str> ] ) } )  if <str> == k :                      docsub . update ( { <str> . format ( v ) : mkblock ( src [ v ] [ <str> ] ) } )  if <str> == k :                      docsub . update ( { <str> . format ( v ) : mkblock ( src [ v ] [ <str> ] ) } )  if <str> == k :                      docsub . update ( { <str> . format ( v ) : mkblock ( src [ v ] [ <str> ] , 1 ) } )    obj . __doc__ = obj . __doc__ . format ( ** docsub ) return obj  return dec  def endpoint ( url , method = <str> , expected_status = 200 ) :      def dec ( obj ) :          obj . ENDPOINT = url obj . METHOD = method obj . EXPECTED_STATUS = expected_status return obj  return dec  def abstractclass ( cls ) :      setattr ( cls , <str> , cls . __bases__ [ 0 ] . __name__ ) origInit = cls . __dict__ [ <str> ] def wrapInit ( self , * args , ** kwargs ) :          try :              assert self . __class__ . __bases__ [ - 1 ] . __name__ != self . _ISNEVER origInit ( self , * args , ** kwargs )  except AssertionError :              raise TypeError ( <str> )   setattr ( wrapInit , <str> , getattr ( origInit , <str> ) ) setattr ( origInit , <str> , <str> ) setattr ( cls , <str> , wrapInit ) return cls  class extendargs ( object ) :      def __init__ ( self , * loa ) :          self . loa = loa  def __call__ ( self , cls ) :          origInit = cls . __bases__ [ 0 ] . __dict__ [ <str> ] def wrapInit ( wself , * args , ** kwargs ) :              for extraArg in self . loa :                  if extraArg in kwargs :                      setattr ( wself , extraArg , kwargs [ extraArg ] ) del kwargs [ extraArg ]   origInit ( wself , * args , ** kwargs )  setattr ( cls , <str> , wrapInit ) return cls    