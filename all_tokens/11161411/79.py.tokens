import os from PyQt5 . QtWidgets import QApplication from scipy . optimize import fsolve from lib . corriente import Corriente from lib import unidades from equipment . parents import equipment class Divider ( equipment ) :      title = QApplication . translate ( <str> , <str> ) kwargs = { <str> : None , <str> : 0 , <str> : 0 , <str> : [ ] , <str> : 0.0 } kwargsInput = ( <str> , ) kwargsList = ( <str> , ) kwargsValue = ( <str> , ) TEXT_CRITERIO = [ QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) ] @ property def isCalculable ( self ) :          if self . kwargs [ <str> ] == 1 :              self . kwargs [ <str> ] = [ 1. ]  if not self . kwargs [ <str> ] :              self . msg = QApplication . translate ( <str> , <str> ) self . status = 0  elif not self . kwargs [ <str> ] :              self . msg = QApplication . translate ( <str> , <str> ) self . status = 0  elif self . kwargs [ <str> ] != len ( self . kwargs [ <str> ] ) :              self . msg = QApplication . translate ( <str> , <str> ) self . status = 0  else :              self . status = 1 self . msg = <str> return True   def calculo ( self ) :          self . entrada = self . kwargs [ <str> ] self . criterio = self . kwargs [ <str> ] self . split = [ unidades . Dimensionless ( i ) for i in self . kwargs [ <str> ] ] self . deltaP = unidades . DeltaP ( self . kwargs [ <str> ] ) if self . criterio == 0 :              if sum ( self . split ) != 1 :                  fracciones_normalizadas = [ ] total = sum ( self . split ) for i in self . split :                      fracciones_normalizadas . append ( i / total )  self . split = fracciones_normalizadas   self . salida = [ ] if self . criterio == 0 :              for i in self . split :                  self . salida . append ( self . entrada . clone ( P = self . entrada . P - self . deltaP , split = i ) )   else :              self . entrada = self . entrada . clone ( caudalmasico = sum ( self . split ) ) for i in self . split :                  self . salida . append ( self . entrada . clone ( P = self . entrada . P - self . deltaP , split = i ) )   self . inputMolarFlow = self . entrada . caudalmolar self . inputMassFlow = self . entrada . caudalmasico self . inputVolFlow = self . entrada . Q self . inputT = self . entrada . T self . inputP = self . entrada . P self . output = unidades . Dimensionless ( self . kwargs [ <str> ] )  def propTxt ( self ) :          txt = <str> txt += QApplication . translate ( <str> , <str> ) txt += <str> + os . linesep txt += self . propertiesToText ( 0 ) for i , salida in enumerate ( self . salida ) :              txt += <str> % ( QApplication . translate ( <str> , <str> ) + str ( i ) , salida . caudalmolar . str ) + os . linesep  txt += os . linesep txt += self . propertiesToText ( 1 ) for i , salida in enumerate ( self . salida ) :              txt += <str> % ( QApplication . translate ( <str> , <str> ) + str ( i ) , salida . caudalmasico . str ) + os . linesep  txt += os . linesep txt += self . propertiesToText ( 2 ) for i , salida in enumerate ( self . salida ) :              txt += <str> % ( QApplication . translate ( <str> , <str> ) + str ( i ) , salida . Q . str ) + os . linesep  txt += os . linesep txt += self . propertiesToText ( 7 ) return txt  @ classmethod def propertiesEquipment ( cls ) :          l = [ ( QApplication . translate ( <str> , <str> ) , <str> , unidades . MolarFlow ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . MassFlow ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . VolFlow ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Temperature ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Pressure ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Dimensionless ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Dimensionless ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . DeltaP ) ] return l  def propertiesListTitle ( self , index ) :          lista = [ ] for i in range ( self . kwargs [ <str> ] ) :              lista . append ( <str> % ( i + 1 ) )  return lista  def writeStatetoJSON ( self , state ) :          state [ <str> ] = self . criterio state [ <str> ] = self . split state [ <str> ] = self . deltaP state [ <str> ] = self . inputMolarFlow state [ <str> ] = self . inputMassFlow state [ <str> ] = self . inputVolFlow state [ <str> ] = self . inputT state [ <str> ] = self . inputP state [ <str> ] = self . output  def readStatefromJSON ( self , state ) :          self . criterio = state [ <str> ] self . split = ( unidades . Dimensionless ( x ) for x in state [ <str> ] ) self . deltaP = unidades . DeltaP ( state [ <str> ] ) self . inputMolarFlow = unidades . MolarFlow ( state [ <str> ] ) self . inputMassFlow = unidades . MassFlow ( state [ <str> ] ) self . inputVolFlow = unidades . VolFlow ( state [ <str> ] ) self . inputT = unidades . Temperature ( state [ <str> ] ) self . inputP = unidades . Pressure ( state [ <str> ] ) self . output = unidades . Dimensionless ( state [ <str> ] ) self . salida = [ None ] * self . kwargs [ <str> ]  def ajustState ( self , stream ) :          print ( self . kwargs )   class Mixer ( equipment ) :      title = QApplication . translate ( <str> , <str> ) help = <str> kwargs = { <str> : [ ] , <str> : 0 , <str> : 0 , <str> : 0.0 } kwargs_forbidden = [ <str> , <str> ] kwargsValue = ( <str> , ) kwargsList = ( <str> , ) TEXT_METODO = [ QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) ] @ property def isCalculable ( self ) :          if self . kwargs [ <str> ] == 2 and not self . kwargs [ <str> ] :              self . msg = QApplication . translate ( <str> , <str> ) self . status = 0  elif not self . kwargs [ <str> ] :              self . msg = QApplication . translate ( <str> , <str> ) self . status = 0  elif sum ( [ s . status for s in self . kwargs [ <str> ] ] ) == 0 :              self . msg = QApplication . translate ( <str> , <str> ) self . status = 0  elif len ( self . kwargs [ <str> ] ) != sum ( [ s . status for s in self . kwargs [ <str> ] ] ) :              self . msg = QApplication . translate ( <str> , <str> ) self . status = 3 return True  else :              self . msg = <str> self . status = 1 return True   def cleanOldValues ( self , ** kwargs ) :          if <str> in kwargs :              if isinstance ( kwargs [ <str> ] , list ) :                  kwargs [ <str> ] = None  else :                  corriente = kwargs [ <str> ] kwargs [ <str> ] = self . kwargs [ <str> ] [ : ] while len ( kwargs [ <str> ] ) < kwargs [ <str> ] + 1 :                      kwargs [ <str> ] . append ( Corriente ( ) )  kwargs [ <str> ] [ kwargs [ <str> ] ] = corriente kwargs [ <str> ] = None   self . kwargs . update ( kwargs )  def calculo ( self ) :          self . entrada = self . kwargs [ <str> ] self . criterio = self . kwargs [ <str> ] if self . criterio == 2 :              Pout = self . kwargs [ <str> ]  else :              lst = [ ] for entrada in self . entrada :                  if entrada . status :                      lst . append ( entrada . P )   if self . criterio == 0 :                  Pout = min ( lst )  else :                  Pout = sum ( lst , 0.0 ) / len ( lst )   self . Pout = unidades . Pressure ( Pout ) h_in = 0 To = 0 massUnitFlow = [ 0 ] * len ( self . entrada [ 0 ] . fraccion ) for entrada in self . entrada :              if entrada . status :                  h_in += entrada . h To += entrada . T * entrada . caudalmasico for i , caudal in enumerate ( entrada . caudalunitariomasico ) :                      massUnitFlow [ i ] += caudal    To /= sum ( massUnitFlow ) def f ( T ) :              output = Corriente ( T = T , P = self . Pout , caudalUnitarioMasico = massUnitFlow ) return output . h - h_in  T = fsolve ( f , To ) [ 0 ] if self . entrada [ 0 ] . solido :              pass  salida = Corriente ( T = T , P = self . Pout , caudalUnitarioMasico = massUnitFlow ) self . salida = [ salida ] self . outT = salida . T self . outX = salida . x self . outMolarFlow = salida . caudalmolar self . outMassFlow = salida . caudalmasico self . outVolFlow = salida . Q  def propTxt ( self ) :          txt = <str> txt += QApplication . translate ( <str> , <str> ) txt += <str> + os . linesep txt += self . propertiesToText ( range ( 3 ) ) txt += os . linesep txt += self . propertiesToText ( 3 ) for i , entrada in enumerate ( self . kwargs [ <str> ] ) :              txt += <str> % ( QApplication . translate ( <str> , <str> ) + str ( i ) , entrada . caudalmolar . str ) + os . linesep  txt += os . linesep txt += self . propertiesToText ( 4 ) for i , entrada in enumerate ( self . kwargs [ <str> ] ) :              txt += <str> % ( QApplication . translate ( <str> , <str> ) + str ( i ) , entrada . caudalmasico . str ) + os . linesep  txt += os . linesep txt += self . propertiesToText ( 5 ) for i , entrada in enumerate ( self . kwargs [ <str> ] ) :              txt += <str> % ( QApplication . translate ( <str> , <str> ) + str ( i ) , entrada . Q . str ) + os . linesep  txt += os . linesep + <str> txt += QApplication . translate ( <str> , <str> ) txt += os . linesep for comp , x in zip ( self . salida [ 0 ] . componente , self . salida [ 0 ] . fraccion ) :              txt += <str> % ( comp . nombre , x ) + os . linesep  return txt  @ classmethod def propertiesEquipment ( cls ) :          l = [ ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Temperature ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Pressure ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Dimensionless ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . MolarFlow ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . MassFlow ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . VolFlow ) ] return l  def writeStatetoJSON ( self , state ) :          state [ <str> ] = self . criterio state [ <str> ] = self . Pout state [ <str> ] = self . outT state [ <str> ] = self . outX state [ <str> ] = self . outMolarFlow state [ <str> ] = self . outMassFlow state [ <str> ] = self . outVolFlow  def readStatefromJSON ( self , state ) :          self . criterio = state [ <str> ] self . Pout = unidades . Pressure ( state [ <str> ] ) self . outT = unidades . Temperature ( state [ <str> ] ) self . outX = unidades . Dimensionless ( state [ <str> ] ) self . outMolarFlow = unidades . MolarFlow ( state [ <str> ] ) self . outMassFlow = unidades . MassFlow ( state [ <str> ] ) self . outVolFlow = unidades . VolFlow ( state [ <str> ] ) self . salida = [ None ]   class Valve ( equipment ) :      title = QApplication . translate ( <str> , <str> ) help = <str> kwargs = { <str> : None , <str> : 0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 } kwargsInput = ( <str> , ) kwargsValue = ( <str> , <str> , <str> , <str> ) kwargsList = ( <str> , ) TEXT_WORKING = [ QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) ] @ property def isCalculable ( self ) :          if self . kwargs [ <str> ] == 1 :              if not self . kwargs [ <str> ] :                  self . msg = QApplication . translate ( <str> , <str> ) self . status = 0  elif self . kwargs [ <str> ] or self . kwargs [ <str> ] or self . kwargs [ <str> ] or self . kwargs [ <str> ] :                  self . status = 1 self . msg = <str> return True  else :                  self . msg = QApplication . translate ( <str> , <str> ) self . status = 0   elif self . kwargs [ <str> ] == 2 :              self . msg = <str> self . status = 1 return True  else :              if not self . kwargs [ <str> ] :                  self . msg = QApplication . translate ( <str> , <str> ) self . status = 0  else :                  self . msg = <str> self . status = 1 return True    def cleanOldValues ( self , ** kwargs ) :          if <str> in kwargs :              self . kwargs [ <str> ] = 0 self . kwargs [ <str> ] = 0 self . kwargs [ <str> ] = 0  elif <str> in kwargs :              self . kwargs [ <str> ] = 0 self . kwargs [ <str> ] = 0 self . kwargs [ <str> ] = 0  elif <str> in kwargs :              self . kwargs [ <str> ] = 0 self . kwargs [ <str> ] = 0 self . kwargs [ <str> ] = 0  elif <str> in kwargs :              self . kwargs [ <str> ] = 0 self . kwargs [ <str> ] = 0 self . kwargs [ <str> ] = 0  self . kwargs . update ( kwargs )  def calculo ( self ) :          self . entrada = self . kwargs [ <str> ] Pout = self . kwargs [ <str> ] DeltaP = self . kwargs [ <str> ] Dew = self . kwargs [ <str> ] Bubble = self . kwargs [ <str> ] if self . kwargs [ <str> ] == 1 :              if Pout :                  self . Pout = unidades . Pressure ( Pout )  elif DeltaP :                  self . Pout = unidades . Pressure ( self . entrada . P - DeltaP )  elif Dew :                  corriente = self . entrada . clone ( T = Dew ) self . Pout = corriente . eos . _Dew_P ( )  elif Bubble :                  corriente = self . entrada . clone ( T = Bubble ) self . Pout = corriente . eos . _Bubble_P ( )  self . salida = [ self . entrada . clone ( P = self . Pout ) ]  elif self . kwargs [ <str> ] == 2 :              self . entrada = Corriente ( ) self . salida = [ self . entrada ]  else :              self . salida = [ self . entrada ] self . Pout = unidades . Pressure ( self . salida [ 0 ] . P )  self . outT = self . salida [ 0 ] . T self . outX = self . salida [ 0 ] . x  def propTxt ( self ) :          txt = <str> txt += QApplication . translate ( <str> , <str> ) txt += <str> + os . linesep txt += self . propertiesToText ( range ( 4 ) ) return txt  @ classmethod def propertiesEquipment ( cls ) :          l = [ ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Temperature ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Pressure ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Dimensionless ) , ( QApplication . translate ( <str> , <str> ) , ( <str> , <str> ) , str ) ] return l  def writeStatetoJSON ( self , state ) :          state [ <str> ] = self . Pout state [ <str> ] = self . outT state [ <str> ] = self . outX  def readStatefromJSON ( self , state ) :          self . Pout = unidades . Pressure ( state [ <str> ] ) self . outT = unidades . Temperature ( state [ <str> ] ) self . outX = unidades . Dimensionless ( state [ <str> ] ) self . salida = [ None ]   if __name__ == <str> :      import doctest doctest . testmod ( )   