from scipy import log , exp , r_ from scipy . optimize import leastsq from scipy . special import erf from PyQt5 . QtWidgets import QApplication from lib . compuestos import Componente from lib . config import Entity , getMainWindowConfig from lib . unidades import Density , MassFlow , Length , Temperature class Solid ( Entity ) :      kwargs = { <str> : [ ] , <str> : 0.0 , <str> : [ ] , <str> : [ ] , <str> : None } status = 0 msg = QApplication . translate ( <str> , <str> ) def __call__ ( self , ** kwargs ) :          Entity . __call__ ( self , ** kwargs ) if self . _oldkwargs != self . kwargs and self . isCalculable :              self . calculo ( )   @ property def isCalculable ( self ) :          self . status = 0 if sum ( self . kwargs [ <str> ] ) > 0 :              if self . kwargs [ <str> ] and self . kwargs [ <str> ] :                  self . status = 2  elif self . kwargs [ <str> ] :                  self . status = 1   return self . status  def calculo ( self ) :          if self . kwargs [ <str> ] is not None :              self . ids = self . kwargs [ <str> ]  else :              Config = getMainWindowConfig ( ) txt = Config . get ( <str> , <str> ) if isinstance ( txt , str ) :                  self . ids = eval ( txt )  else :                  self . ids = txt   self . componente = [ Componente ( int ( i ) ) for i in self . ids ] caudal = self . kwargs . get ( <str> , [ ] ) diametro_medio = self . kwargs . get ( <str> , 0.0 ) fraccion = self . kwargs . get ( <str> , [ ] ) diametros = self . kwargs . get ( <str> , [ ] ) if self . status == 0 :              self . _bool = False return  else :              self . _bool = True  self . caudalUnitario = [ MassFlow ( i ) for i in caudal ] self . caudal = MassFlow ( sum ( self . caudalUnitario ) ) self . diametros = diametros self . fracciones = fraccion if self . status == 2 :              self . diametros = [ Length ( i , <str> , magnitud = <str> ) for i in diametros ] self . fracciones = fraccion diametro_medio = 0 self . fracciones_acumuladas = [ 0 ] for di , xi in zip ( diametros , fraccion ) :                  diametro_medio += di * xi self . fracciones_acumuladas . append ( xi + self . fracciones_acumuladas [ - 1 ] )  del self . fracciones_acumuladas [ 0 ]  self . diametro_medio = Length ( diametro_medio , magnitud = <str> ) self . RhoS ( self . kwargs . get ( <str> , 300 ) )  def RhoS ( self , T ) :          densidad = 0 for i in range ( len ( self . ids ) ) :              densidad += self . caudalUnitario [ i ] / self . caudal * self . componente [ i ] . RhoS ( T )  self . rho = Density ( densidad ) self . T = Temperature ( T )  def __repr__ ( self ) :          if self . status :              return <str> % ( self . caudal . str , self . diametro_medio . str )  else :              return <str> % ( self . __class__ )   def ajustar_distribucion ( self , eq = 0 ) :          d = r_ [ self . diametros ] y = r_ [ self . fracciones_acumuladas ] if eq == 0 :              model = <str> inicio = r_ [ 1 , 1 ] def function ( p , d ) :                  return 1. - exp ( - ( d / p [ 0 ] ) ** p [ 1 ] )   elif eq == 1 :              model = <str> inicio = r_ [ 1 , 1 ] def function ( p , d ) :                  return ( d / p [ 0 ] ) ** p [ 1 ]   elif eq == 2 :              model = <str> inicio = r_ [ d [ - 1 ] * 2 , 0 ] def function ( p , d ) :                  return 1 - ( 1 - d / p [ 0 ] ) ** p [ 1 ]   elif eq == 3 :              model = <str> inicio = r_ [ 1 , 1 ] def function ( p , d ) :                  return 1. - exp ( - ( d / p [ 0 ] ) ** p [ 1 ] ) / ( 1 - exp ( - 1. ) )   elif eq == 4 :              model = <str> inicio = r_ [ 1 , 1 ] def function ( p , d ) :                  return erf ( log ( d / p [ 0 ] ) / p [ 1 ] )   elif eq == 5 :              model = <str> inicio = r_ [ d [ - 1 ] * 2 , 1 , 1 ] def function ( p , d ) :                  return 1 - ( 1 - d / p [ 0 ] ** p [ 1 ] ) ** p [ 2 ]   def residuo ( p , d , y ) :              return function ( p , d ) - y  ajuste , exito = leastsq ( residuo , inicio , args = ( d , y ) ) return d , function ( ajuste , d ) , model  def Separar ( self , etas ) :          rendimiento_global = 0 for i , fraccion in enumerate ( self . fracciones ) :              rendimiento_global += etas [ i ] * fraccion  G_skip = MassFlow ( self . caudal * ( 1 - rendimiento_global ) ) G_sep = MassFlow ( self . caudal * rendimiento_global ) if rendimiento_global == 1 :              return None , self  elif rendimiento_global == 0 :              return self , None  else :              f_gas = [ ] f_solid = [ ] for i in range ( len ( self . diametros ) ) :                  f_gas . append ( self . caudal * self . fracciones [ i ] * ( 1 - etas [ i ] ) / G_skip ) f_solid . append ( self . caudal * self . fracciones [ i ] * etas [ i ] / G_sep )  S_skip = Solid ( caudalSolido = [ G_skip ] , distribucion_diametro = self . diametros , distribucion_fraccion = f_gas ) S_sep = Solid ( caudalSolido = [ G_sep ] , distribucion_diametro = self . diametros , distribucion_fraccion = f_solid ) return S_skip , S_sep   def writeStatetoJSON ( self , solid ) :          if self . status :              solid [ <str> ] = self . status solid [ <str> ] = self . ids solid [ <str> ] = self . caudalUnitario solid [ <str> ] = self . caudal solid [ <str> ] = self . diametros solid [ <str> ] = self . fracciones solid [ <str> ] = self . fracciones_acumuladas solid [ <str> ] = self . diametro_medio solid [ <str> ] = self . rho solid [ <str> ] = self . T   def readStatefromJSON ( self , solid ) :          if solid :              self . _bool = True self . status = solid [ <str> ] self . ids = solid [ <str> ] self . componente = [ Componente ( int ( i ) ) for i in self . ids ] self . caudalUnitario = [ MassFlow ( q ) for q in solid [ <str> ] ] self . caudal = MassFlow ( solid [ <str> ] ) self . diametros = [ Length ( d , <str> , <str> ) for d in solid [ <str> ] ] self . fracciones = solid [ <str> ] self . fracciones_acumuladas = solid [ <str> ] self . diametro_medio = Length ( solid [ <str> ] ) self . rho = Density ( solid [ <str> ] ) self . T = Temperature ( solid [ <str> ] )  else :              self . _bool = False self . status = False    if __name__ == <str> :      distribucion = [ [ 17.5 , 0.02 ] , [ 22.4 , 0.03 ] , [ 26.2 , 0.05 ] , [ 31.8 , 0.1 ] , [ 37 , 0.1 ] , [ 42.4 , 0.1 ] , [ 48 , 0.1 ] , [ 54 , 0.1 ] , [ 60 , 0.1 ] , [ 69 , 0.1 ] , [ 81.3 , 0.1 ] , [ 96.5 , 0.05 ] , [ 109 , 0.03 ] , [ 127 , 0.02 ] ] diametros = [ ] fracciones = [ ] for diametro , fraccion in distribucion :          diametros . append ( diametro ) fracciones . append ( fraccion )  solido = Solid ( caudalSolido = [ 5 ] , distribucion_diametro = diametros , distribucion_fraccion = fracciones ) print ( solido . _def )   