import os from scipy import log , exp , pi , log10 , linspace from scipy . optimize import fsolve from PyQt5 . QtWidgets import QApplication from lib import unidades from lib . corriente import Corriente from lib . plot import Plot from equipment . parents import equipment from equipment . heatExchanger import Heat_Exchanger class Flash ( equipment ) :      title = QApplication . translate ( <str> , <str> ) help = <str> kwargs = { <str> : None , <str> : 0 , <str> : 1.7 , <str> : 0.0 , <str> : 0.0 , <str> : 0 , <str> : 0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 0 , <str> : 0.0 , <str> : 0.0 } kwargsInput = ( <str> , ) kwargsList = ( <str> , <str> , <str> , <str> ) kwargsValue = ( <str> , <str> , <str> , <str> , <str> ) calculateCostos = ( <str> , <str> , <str> , <str> ) indiceCostos = 3 TEXT_FLASH = [ QApplication . translate ( <str> , <str> ) ] TEXT_ORIENTATION = [ QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) ] TEXT_MATERIAL = [ QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) ] TEXT_HEAD = [ QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) ] @ property def isCalculable ( self ) :          if self . kwargs [ <str> ] and self . kwargs [ <str> ] and self . kwargs [ <str> ] and self . kwargs [ <str> ] and self . kwargs [ <str> ] and self . kwargs [ <str> ] :              self . statusCoste = True  else :              self . statusCoste = False  if not self . kwargs [ <str> ] :              self . msg = QApplication . translate ( <str> , <str> ) self . status = 0 return  self . msg = <str> self . status = 1 return True  def calculo ( self ) :          self . entrada = self . kwargs [ <str> ] if self . kwargs [ <str> ] == 0 :              Vapor = self . entrada . clone ( fraccionMolar = self . entrada . Gas . fraccion , caudalMasico = self . entrada . Gas . caudalmasico ) Liquido = self . entrada . clone ( fraccionMolar = self . entrada . Liquido . fraccion , caudalMasico = self . entrada . Liquido . caudalmasico ) self . salida = [ Vapor , Liquido ]  self . Tout = Vapor . T self . Pout = Vapor . P self . VaporMolarFlow = Vapor . caudalmolar self . VaporMassFlow = Vapor . caudalmasico self . VaporVolFlow = Vapor . Q self . VaporMolarComposition = Vapor . fraccion self . VaporMassComposition = Vapor . fraccion_masica self . LiquidMolarFlow = Liquido . caudalmolar self . LiquidMassFlow = Liquido . caudalmasico self . LiquidVolFlow = Liquido . Q self . LiquidMolarComposition = Liquido . fraccion self . LiquidMassComposition = Liquido . fraccion_masica  def volumen ( self ) :          self . Di = unidades . Length ( 0 ) self . L = unidades . Length ( 0 ) self . reborde = 0 self . espesor = 0 self . espesor_cabeza = 0 V_carcasa = pi / 4 * self . Di ** 2 * self . L if self . kwargs [ <str> ] == 0 :              V_cabeza = 4. / 3 * pi / 8 * self . Di ** 3  elif self . kwargs [ <str> ] == 1 :              V_cabeza = 4. / 3 * pi / 8 / 2 * self . Di ** 3  elif self . kwargs [ <str> ] == 2 :              V_cabeza = 0.215483 / 2 * self . Di ** 3  else :              V_cabeza = 0.  self . V = unidades . Volume ( V_carcasa + V_cabeza )  def peso ( self ) :          W_carcasa = pi / 4 * ( self . De ** 2 - self . Di ** 2 ) * self . L * self . densidad if self . kwargs [ <str> ] == 3 :              W_cabeza = pi / 4 * self . Di ** 2 * self . espesor_cabeza * self . densidad  else :              ratio = self . De / self . espesor_cabeza if self . kwargs [ <str> ] == 0 :                  if ratio > 20 :                      hb = 1.24  else :                      hb = 1.3   elif self . kwargs [ <str> ] == 2 :                  if ratio > 50 :                      hb = 1.09  elif ratio > 30 :                      hb = 1.11  else :                      hb = 1.15   else :                  if ratio > 30 :                      hb = 1.6  elif ratio > 18 :                      hb = 1.65  else :                      hb = 1.70   Do = hb * self . De + 2 * self . reborde W_cabeza = pi / 4 * Do ** 2 * self . espesor_cabeza * self . densidad  self . W = unidades . Mass ( W_carcasa + 2 * W_cabeza )  def coste ( self ) :          CI = self . kwargs [ <str> ] BI = self . kwargs [ <str> ] if self . kwargs [ <str> ] :              self . densidad = unidades . Density ( self . kwargs [ <str> ] )  else :              self . densidad = unidades . Density ( 501 , <str> )  self . Di = unidades . Length ( self . kwargs [ <str> ] ) self . L = unidades . Length ( self . kwargs [ <str> ] ) self . espesor = unidades . Length ( self . kwargs [ <str> ] ) if self . kwargs [ <str> ] :              self . espesor_cabeza = unidades . Length ( self . kwargs [ <str> ] )  else :              self . espesor_cabeza = self . espesor  self . reborde = unidades . Length ( self . kwargs [ <str> ] ) self . De = unidades . Length ( self . Di + 2 * self . espesor ) self . volumen ( ) self . peso ( ) ind_material = self . kwargs [ <str> ] Fm = [ 1. , 1.7 , 2.1 , 3.2 , 5.4 , 3.6 , 3.9 , 3.7 , 7.7 ] [ ind_material ] if self . kwargs [ <str> ] == 0 :              Cb = exp ( 8.571 - 0.233 * log ( self . W . lb ) + 0.04333 * log ( self . W . lb ) ** 2 ) Ca = 1370 * self . Di . ft ** 0.2029  else :              Cb = exp ( 9.1 - 0.2889 * log ( self . W . lb ) + 0.04576 * log ( self . W . lb ) ** 2 ) Ca = 246 * self . Di . ft ** 0.7396 * self . L . ft ** 0.7068  C = Fm * Cb + Ca self . C_adq = unidades . Currency ( C * CI / BI ) self . C_inst = unidades . Currency ( self . C_adq * self . kwargs [ <str> ] )  def propTxt ( self ) :          txt = <str> txt += QApplication . translate ( <str> , <str> ) txt += <str> + os . linesep txt += self . propertiesToText ( range ( 3 ) ) + os . linesep txt += self . propertiesToText ( range ( 3 , 6 ) ) txt += QApplication . translate ( <str> , <str> ) + os . linesep for cmp , xi in zip ( self . salida [ 0 ] . componente , self . salida [ 0 ] . fraccion ) :              txt += <str> % ( cmp . nombre , xi ) + os . linesep  txt += os . linesep txt += self . propertiesToText ( range ( 8 , 11 ) ) txt += QApplication . translate ( <str> , <str> ) + os . linesep for cmp , xi in zip ( self . salida [ 1 ] . componente , self . salida [ 1 ] . fraccion ) :              txt += <str> % ( cmp . nombre , xi ) + os . linesep  return txt  @ classmethod def propertiesEquipment ( cls ) :          l = [ ( QApplication . translate ( <str> , <str> ) , ( <str> , <str> ) , str ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Temperature ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Pressure ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . MolarFlow ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . MassFlow ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . VolFlow ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Dimensionless ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Dimensionless ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . MolarFlow ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . MassFlow ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . VolFlow ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Dimensionless ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Dimensionless ) ] return l  def propertiesListTitle ( self , index ) :          l = [ comp . nombre for comp in self . kwargs [ <str> ] . componente ] return l  def writeStatetoJSON ( self , state ) :          state [ <str> ] = self . Tout state [ <str> ] = self . Pout state [ <str> ] = self . VaporMolarFlow state [ <str> ] = self . VaporVolFlow state [ <str> ] = self . VaporMolarComposition state [ <str> ] = self . VaporMassComposition state [ <str> ] = self . LiquidMolarFlow state [ <str> ] = self . LiquidVolFlow state [ <str> ] = self . LiquidMolarComposition state [ <str> ] = self . LiquidMassComposition state [ <str> ] = self . statusCoste if self . statusCoste :              state [ <str> ] = self . C_adq state [ <str> ] = self . C_inst   def readStatefromJSON ( self , state ) :          self . Tout = unidades . Temperature ( state [ <str> ] ) self . Pout = unidades . Pressure ( state [ <str> ] ) self . VaporMolarFlow = unidades . MassFlow ( state [ <str> ] ) self . VaporVolFlow = unidades . VolFlow ( state [ <str> ] ) self . VaporMolarComposition = [ unidades . MolarFlow ( p ) for p in state [ <str> ] ] self . VaporMassComposition = [ unidades . MassFlow ( p ) for p in state [ <str> ] ] self . LiquidMolarFlow = unidades . MolarFlow ( state [ <str> ] ) self . LiquidVolFlow = unidades . VolFlow ( state [ <str> ] ) self . LiquidMolarComposition = [ unidades . MolarFlow ( p ) for p in state [ <str> ] ] self . LiquidMassComposition = [ unidades . MassFlow ( p ) for p in state [ <str> ] ] self . statusCoste = state [ <str> ] if self . statusCoste :              self . C_adq = unidades . Currency ( state [ <str> ] ) self . C_inst = unidades . Currency ( state [ <str> ] )  self . salida = [ None ]   class Tower ( equipment ) :      title = <str> help = <str> Condenser = Heat_Exchanger ( ) Reboiler = Heat_Exchanger ( ) calculateCostos = ( <str> , <str> , <str> , <str> , <str> , <str> ) TEXT_PROCESS = [ QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) ] TEXT_COLUMN = [ QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) ] TEXT_MATERIAL = [ QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) ] TEXT_TRAY = [ QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) ] def isCalculable ( self ) :          if self . kwargs [ <str> ] :              if not self . kwargs [ <str> ] :                  self . statusCoste = False return   if self . kwargs [ <str> ] and self . kwargs [ <str> ] and self . kwargs [ <str> ] and self . kwargs [ <str> ] :              self . statusCoste = True  else :              self . statusCoste = False   def peso ( self ) :          return unidades . Mass ( pi * self . kwargs [ <str> ] * ( self . kwargs [ <str> ] + 0.8116 * self . kwargs [ <str> ] ) * 0.5 * ( self . kwargs [ <str> ] + self . kwargs [ <str> ] ) * self . densidad )  def volumen ( self ) :          return unidades . Volume ( pi / 4 * self . kwargs [ <str> ] ** 2 * self . kwargs [ <str> ] )  def McCabe ( self , LK = 0 , HK = 1 ) :          A = self . kwargs [ <str> ] . componente [ LK ] . nombre B = self . kwargs [ <str> ] . componente [ HK ] . nombre P = self . kwargs [ <str> ] . P Psat = dict ( ) Psat [ A ] = self . kwargs [ <str> ] . componente [ LK ] . Pv Psat [ B ] = self . kwargs [ <str> ] . componente [ HK ] . Pv Tsat = dict ( ) for i , s in enumerate ( Psat . keys ( ) ) :              Tsat [ s ] = lambda P , s = s : fsolve ( lambda T : Psat [ s ] ( T ) - P , self . kwargs [ <str> ] . componente [ i ] . Tb ) [ 0 ]  T = linspace ( Tsat [ A ] ( P ) , Tsat [ B ] ( P ) ) x = lambda T : ( P - Psat [ B ] ( T ) ) / ( Psat [ A ] ( T ) - Psat [ B ] ( T ) ) y = lambda T : x ( T ) * Psat [ A ] ( T ) / P xB = 1 - self . kwargs [ <str> ] xF = self . kwargs [ <str> ] . fraccion [ LK ] xD = self . kwargs [ <str> ] Tbub = fsolve ( lambda T : x ( T ) - xF , T [ 25 ] ) yF = y ( Tbub ) if self . kwargs [ <str> ] :              R = self . kwargs [ <str> ]  else :              Eslope = ( xD - yF ) / ( xD - xF ) Rmin = Eslope / ( 1 - Eslope ) R = self . kwargs [ <str> ] * Rmin  zF = xD - R * ( xD - xF ) / ( R + 1 ) Sslope = ( zF - xB ) / ( xF - xB ) S = 1 / ( Sslope - 1 ) xP = xD yP = xD dialog = Plot ( ) dialog . plot . ax . grid ( True ) dialog . plot . ax . set_title ( QApplication . translate ( <str> , <str> ) + <str> . format ( A , B , P . str ) , size = <str> ) dialog . plot . ax . set_xlabel ( QApplication . translate ( <str> , <str> ) + <str> . format ( A ) , size = <str> ) dialog . plot . ax . set_ylabel ( QApplication . translate ( <str> , <str> ) + <str> . format ( B ) , size = <str> ) dialog . plot . ax . set_xticks ( linspace ( 0 , 1.0 , 21 ) ) dialog . plot . ax . set_yticks ( linspace ( 0.05 , 1.0 , 20 ) ) dialog . addData ( [ 0 , 1 ] , [ 0 , 1 ] , <str> ) dialog . addData ( list ( map ( x , T ) ) , list ( map ( y , T ) ) ) dialog . addData ( [ xB , xB ] , [ 0 , xB ] , <str> ) dialog . addData ( xB , xB , <str> , ms = 5 ) dialog . addText ( xB + 0.005 , 0.02 , <str> . format ( float ( xB ) ) ) dialog . addData ( [ xF , xF , xF ] , [ 0 , xF , yF ] , <str> ) dialog . addData ( [ xF , xF ] , [ xF , yF ] , <str> , ms = 5 ) dialog . addText ( xF + 0.005 , 0.02 , <str> . format ( float ( xF ) ) ) dialog . addData ( [ xD , xD ] , [ 0 , xD ] , <str> ) dialog . addData ( xD , xD , <str> , ms = 5 ) dialog . addText ( xD - 0.005 , 0.02 , <str> . format ( float ( xD ) ) , ha = <str> ) dialog . addData ( [ xD , xF ] , [ xD , yF ] , <str> ) dialog . addData ( [ xD , xF ] , [ xD , zF ] , <str> ) dialog . addData ( [ xB , xF ] , [ xB , xB + ( S + 1 ) * ( xF - xB ) / S ] , <str> ) nTray = 0 while xP > xB :              nTray += 1 Tdew = fsolve ( lambda T : y ( T ) - yP , T [ 25 ] ) xQ = xP xP = x ( Tdew ) dialog . addData ( [ xQ , xP ] , [ yP , yP ] , <str> ) dialog . addData ( xP , yP , <str> , ms = 5 ) dialog . addText ( xP - 0.03 , yP , nTray ) yQ = yP yP = min ( [ xD - ( R / ( R + 1 ) ) * ( xD - xP ) , xB + ( ( S + 1 ) / S ) * ( xP - xB ) ] ) dialog . addData ( [ xP , xP ] , [ yQ , yP ] , <str> )  nTray -= 1 dialog . addText ( 0.1 , 0.90 , <str> . format ( float ( Rmin ) ) , size = <str> ) dialog . addText ( 0.1 , 0.85 , <str> . format ( float ( R ) ) , size = <str> ) dialog . addText ( 0.1 , 0.80 , <str> . format ( float ( S ) ) , size = <str> ) dialog . addText ( 0.1 , 0.75 , <str> . format ( int ( nTray ) ) , size = <str> ) dialog . exec_ ( )  def coste ( self ) :          self . tipo_pisos = kwargs . get ( <str> , 0 ) self . material_columna = kwargs . get ( <str> , 0 ) self . material_pisos = kwargs . get ( <str> , 0 ) Di = unidades . Length ( self . kwargs [ <str> ] ) . ft L = unidades . Length ( self . kwargs [ <str> ] ) . ft W = self . peso ( ) . lb f1 = [ 1. , 1.7 , 2.1 , 3.2 , 5.4 , 3.6 , 3.9 , 3.7 , 7.7 ] [ self . kwargs [ <str> ] ] if self . kwargs [ <str> ] :              Cb = exp ( 7.123 + 0.1478 * log ( W ) + 0.02488 * log ( W ) ** 2 + 0.0158 * L / Di * log ( self . kwargs [ <str> ] / self . kwargs [ <str> ] ) ) Cp = 204.9 * Di ** 0.6332 * L ** 0.8016  else :              Cb = exp ( 6.629 + 0.1826 * log ( W ) + 0.02297 * log ( W ) ** 2 ) Cp = 246.4 * Di ** 0.7396 * L ** 0.7068  if self . kwargs [ <str> ] == 0 :              f2 = [ 1. , 1.189 + 0.0577 * Di , 1.401 + 0.0724 * Di , 1.525 + 0.0788 * Di , 1. , 2.306 + 0.112 * Di , 1. , 1. , 1. ] [ self . kwargs [ <str> ] ] f3 = [ 1. , 0.8 , 1.59 , 0.85 ] [ self . kwargs [ <str> ] ] if self . NTray <= 20 :                  f4 = 2.25 / 1.0414 ** self . NTray  else :                  f4 = 1.  Ci = f2 * f3 * f4 * self . NTray * 375.8 * exp ( 0.1739 * Di )  else :              Ci = self . volumen ( ) * self . kwargs [ <str> ]  C = f1 * Cb + Cp + Ci C_adq = C * self . Current_index / self . Base_index C_inst = C_adq * self . f_install self . C_pisos = Ci self . C_carcasa = f1 * Cb self . C_accesorios = Cp self . C_col_adq = C_adq self . C_col_inst = C_inst self . C_adq = C_adq + self . caldera . C_adq + self . condensador . C_adq self . C_inst = C_inst + self . caldera . C_inst + self . condensador . C_inst   class ColumnFUG ( Tower ) :      title = QApplication . translate ( <str> , <str> ) help = <str> kwargs = { <str> : None , <str> : 0 , <str> : 0 , <str> : 0.0 , <str> : 0 , <str> : 0.0 , <str> : 0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 3 , <str> : 0.0 , <str> : 0.0 , <str> : 0 , <str> : 0 , <str> : 0 , <str> : 0 , <str> : 0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 } kwargsInput = ( <str> , ) kwargsValue = ( <str> , <str> , <str> , <str> , <str> , <str> ) kwargsList = ( <str> , <str> , <str> , <str> ) calculateValue = ( <str> , <str> , <str> , <str> , <str> , <str> , <str> ) indiceCostos = 3 TEXT_FEED = [ <str> , <str> ] TEXT_CONDENSER = [ QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) ] def cleanOldValues ( self , ** kwargs ) :          if <str> in kwargs :              self . kwargs [ <str> ] = 0.0  elif <str> in kwargs :              self . kwargs [ <str> ] = 0.0  self . kwargs . update ( kwargs )  @ property def isCalculable ( self ) :          Tower . isCalculable ( self ) self . statusMcCabe = True if not self . kwargs [ <str> ] and not self . kwargs [ <str> ] :              self . statusMcCabe = False  elif not self . kwargs [ <str> ] or not self . kwargs [ <str> ] :              self . statusMcCabe = False  if not self . kwargs [ <str> ] :              self . msg = QApplication . translate ( <str> , <str> ) self . status = 0 return  if not self . kwargs [ <str> ] and not self . kwargs [ <str> ] :              self . msg = QApplication . translate ( <str> , <str> ) self . status = 0 return  if not self . kwargs [ <str> ] :              self . msg = QApplication . translate ( <str> , <str> ) self . status = 0 return  if not self . kwargs [ <str> ] :              self . msg = QApplication . translate ( <str> , <str> ) self . status = 0 return  if self . kwargs [ <str> ] == - 1 :              self . msg = QApplication . translate ( <str> , <str> ) self . status = 0 return  if self . kwargs [ <str> ] == - 1 :              self . msg = QApplication . translate ( <str> , <str> ) self . status = 0 return  if self . kwargs [ <str> ] <= self . kwargs [ <str> ] :              self . msg = QApplication . translate ( <str> , <str> ) self . status = 0 return  self . msg = <str> self . status = 1 return True  def calculo ( self ) :          self . entrada = self . kwargs [ <str> ] self . LKsplit = unidades . Dimensionless ( self . kwargs [ <str> ] ) self . HKsplit = unidades . Dimensionless ( self . kwargs [ <str> ] ) self . RCalculada = unidades . Dimensionless ( self . kwargs [ <str> ] ) self . R_Rmin = unidades . Dimensionless ( self . kwargs [ <str> ] ) if self . kwargs [ <str> ] :              self . Pd = unidades . Pressure ( self . kwargs [ <str> ] )  else :              self . Pd = self . entrada . P  self . DeltaP = unidades . Pressure ( self . kwargs [ <str> ] ) b = [ ] d = [ ] for i , caudal_i in enumerate ( self . entrada . caudalunitariomolar ) :              if i == self . kwargs [ <str> ] :                  b . append ( caudal_i * ( 1 - self . LKsplit ) ) d . append ( caudal_i * self . LKsplit )  elif i == self . kwargs [ <str> ] :                  d . append ( caudal_i * ( 1 - self . HKsplit ) ) b . append ( caudal_i * self . HKsplit )  elif self . entrada . eos . Ki [ i ] > self . entrada . eos . Ki [ self . kwargs [ <str> ] ] :                  b . append ( 0 ) d . append ( caudal_i )  elif self . entrada . eos . Ki [ i ] < self . entrada . eos . Ki [ self . kwargs [ <str> ] ] :                  d . append ( 0 ) b . append ( caudal_i )  else :                  d . append ( caudal_i * 0.5 ) b . append ( caudal_i * 0.5 )   while True :              bo = b do = d xt = [ Q / sum ( d ) for Q in d ] xb = [ Q / sum ( b ) for Q in b ] Qt = sum ( [ di * comp . M for di , comp in zip ( d , self . entrada . componente ) ] ) Qb = sum ( [ bi * comp . M for bi , comp in zip ( b , self . entrada . componente ) ] ) destilado = Corriente ( T = self . entrada . T , P = self . Pd , caudalMasico = Qt , fraccionMolar = xt ) residuo = Corriente ( T = self . entrada . T , P = self . Pd , caudalMasico = Qb , fraccionMolar = xb ) alfam = ( destilado . eos . Ki [ self . kwargs [ <str> ] ] / destilado . eos . Ki [ self . kwargs [ <str> ] ] * residuo . eos . Ki [ self . kwargs [ <str> ] ] / residuo . eos . Ki [ self . kwargs [ <str> ] ] ) ** 0.5 Nmin = log10 ( destilado . caudalunitariomolar [ self . kwargs [ <str> ] ] / destilado . caudalunitariomolar [ self . kwargs [ <str> ] ] * residuo . caudalunitariomolar [ self . kwargs [ <str> ] ] / residuo . caudalunitariomolar [ self . kwargs [ <str> ] ] ) / log10 ( alfam ) b = [ ] d = [ ] for i in range ( len ( self . entrada . ids ) ) :                  if i in [ self . kwargs [ <str> ] , self . kwargs [ <str> ] ] :                      b . append ( bo [ i ] ) d . append ( do [ i ] )  else :                      alfa = ( destilado . eos . Ki [ i ] / destilado . eos . Ki [ self . kwargs [ <str> ] ] * residuo . eos . Ki [ i ] / residuo . eos . Ki [ self . kwargs [ <str> ] ] ) ** 0.5 b . append ( self . entrada . caudalunitariomolar [ i ] / ( 1 + do [ self . kwargs [ <str> ] ] / bo [ self . kwargs [ <str> ] ] * alfa ** Nmin ) ) d . append ( self . entrada . caudalunitariomolar [ i ] * do [ self . kwargs [ <str> ] ] / bo [ self . kwargs [ <str> ] ] * alfa ** Nmin / ( 1 + do [ self . kwargs [ <str> ] ] / bo [ self . kwargs [ <str> ] ] * alfa ** Nmin ) )   res = sum ( [ abs ( inicial - final ) for inicial , final in zip ( bo , b ) ] ) + sum ( [ abs ( inicial - final ) for inicial , final in zip ( do , d ) ] ) if res < 1e-10 :                  self . Nmin = Nmin - self . kwargs [ <str> ] + 1 break   alfa = self . entrada . eos . Ki [ self . kwargs [ <str> ] ] / self . entrada . eos . Ki [ self . kwargs [ <str> ] ] self . Rmin = unidades . Dimensionless ( abs ( float ( destilado . caudalmolar / self . entrada . caudalmolar * ( destilado . fraccion [ self . kwargs [ <str> ] ] / self . entrada . Liquido . fraccion [ self . kwargs [ <str> ] ] - alfa * destilado . fraccion [ self . kwargs [ <str> ] ] / self . entrada . Liquido . fraccion [ self . kwargs [ <str> ] ] ) / ( alfa - 1 ) ) ) ) if self . R_Rmin and not self . RCalculada :              self . RCalculada = unidades . Dimensionless ( self . R_Rmin * self . Rmin )  X = ( self . RCalculada - self . Rmin ) / ( self . RCalculada + 1 ) Y = 1 - exp ( ( 1 + 54.4 * X ) / ( 11 + 117.2 * X ) * ( X - 1 ) / X ** 0.5 ) self . NTray = unidades . Dimensionless ( ( Y + self . Nmin ) / ( 1 - Y ) - 1 - self . kwargs [ <str> ] ) if self . kwargs [ <str> ] :              alfa_b = residuo . eos . Ki [ self . kwargs [ <str> ] ] / residuo . eos . Ki [ self . kwargs [ <str> ] ] alfa_d = destilado . eos . Ki [ self . kwargs [ <str> ] ] / destilado . eos . Ki [ self . kwargs [ <str> ] ] alfa_f = self . entrada . eos . Ki [ self . kwargs [ <str> ] ] / self . entrada . eos . Ki [ self . kwargs [ <str> ] ] ratio = log ( destilado . fraccion [ self . kwargs [ <str> ] ] / self . entrada . fraccion [ self . kwargs [ <str> ] ] * self . entrada . fraccion [ self . kwargs [ <str> ] ] / destilado . fraccion [ self . kwargs [ <str> ] ] ) / log ( self . entrada . fraccion [ self . kwargs [ <str> ] ] / residuo . fraccion [ self . kwargs [ <str> ] ] * residuo . fraccion [ self . kwargs [ <str> ] ] / self . entrada . fraccion [ self . kwargs [ <str> ] ] ) * log ( ( alfa_b * alfa_f ) ** 0.5 ) / log ( ( alfa_d * alfa_f ) ** 0.5 )  else :              ratio = ( self . entrada . fraccion [ self . kwargs [ <str> ] ] / self . entrada . fraccion [ self . kwargs [ <str> ] ] * residuo . fraccion [ self . kwargs [ <str> ] ] ** 2 / destilado . fraccion [ self . kwargs [ <str> ] ] ** 2 * residuo . caudalmolar / destilado . caudalmolar ) ** 0.206  self . Ns = self . NTray / ( ratio + 1 ) self . Nr = self . NTray - self . Ns self . N_feed = unidades . Dimensionless ( self . Ns + 1 ) if self . kwargs [ <str> ] :              Tout = destilado . eos . _Dew_T ( )  else :              Tout = destilado . eos . _Bubble_T ( )  Tin = destilado . eos . _Dew_T ( ) SalidaDestilado = destilado . clone ( T = Tout ) ToutReboiler = residuo . eos . _Bubble_T ( ) ToutReboiler2 = residuo . eos . _Dew_T ( ) print ( ( ToutReboiler , ToutReboiler2 , Tin , Tout ) ) SalidaResiduo = residuo . clone ( T = ToutReboiler ) self . salida = [ SalidaDestilado , SalidaResiduo ] inCondenser = destilado . clone ( T = Tin , P = self . entrada . P , split = self . RCalculada + 1 ) outCondenser = destilado . clone ( T = Tout , P = self . entrada . P , split = self . RCalculada + 1 ) self . DutyCondenser = unidades . Power ( outCondenser . h - inCondenser . h ) self . DutyReboiler = unidades . Power ( SalidaDestilado . h + SalidaResiduo . h - self . DutyCondenser - self . entrada . h ) self . DestiladoT = SalidaDestilado . T self . DestiladoP = SalidaDestilado . P self . DestiladoMassFlow = SalidaDestilado . caudalmasico self . DestiladoMolarComposition = SalidaDestilado . fraccion self . ResiduoT = SalidaResiduo . T self . ResiduoP = SalidaResiduo . P self . ResiduoMassFlow = SalidaResiduo . caudalmasico self . ResiduoMolarComposition = SalidaResiduo . fraccion self . LKName = self . salida [ 0 ] . componente [ self . kwargs [ <str> ] ] . nombre self . HKName = self . salida [ 0 ] . componente [ self . kwargs [ <str> ] ] . nombre  def McCabe ( self ) :          return Tower . McCabe ( self , self . kwargs [ <str> ] , self . kwargs [ <str> ] )  def propTxt ( self ) :          txt = <str> + QApplication . translate ( <str> , <str> ) + <str> + os . linesep txt += os . linesep + <str> % ( QApplication . translate ( <str> , <str> ) , self . salida [ 0 ] . T . str ) + os . linesep txt += <str> % ( QApplication . translate ( <str> , <str> ) , self . salida [ 0 ] . P . str ) + os . linesep txt += <str> % ( QApplication . translate ( <str> , <str> ) , self . salida [ 0 ] . caudalmolar . str ) + os . linesep txt += <str> + QApplication . translate ( <str> , <str> ) + os . linesep for componente , fraccion in zip ( self . salida [ 0 ] . componente , self . salida [ 0 ] . fraccion ) :              txt += <str> % ( componente . nombre , fraccion ) + os . linesep  txt += os . linesep + <str> % ( QApplication . translate ( <str> , <str> ) , self . salida [ 1 ] . T . str ) + os . linesep txt += <str> % ( QApplication . translate ( <str> , <str> ) , self . salida [ 1 ] . P . str ) + os . linesep txt += <str> % ( QApplication . translate ( <str> , <str> ) , self . salida [ 1 ] . caudalmolar . str ) + os . linesep txt += <str> + QApplication . translate ( <str> , <str> ) + os . linesep for componente , fraccion in zip ( self . salida [ 1 ] . componente , self . salida [ 1 ] . fraccion ) :              txt += <str> % ( componente . nombre , fraccion ) + os . linesep  txt += os . linesep + <str> % ( QApplication . translate ( <str> , <str> ) , self . TEXT_FEED [ self . kwargs [ <str> ] ] ) + os . linesep txt += <str> % ( QApplication . translate ( <str> , <str> ) , self . TEXT_CONDENSER [ self . kwargs [ <str> ] ] ) + os . linesep txt += <str> % ( QApplication . translate ( <str> , <str> ) , self . salida [ 0 ] . componente [ self . kwargs [ <str> ] ] . nombre ) + os . linesep txt += <str> % ( QApplication . translate ( <str> , <str> ) , self . salida [ 0 ] . componente [ self . kwargs [ <str> ] ] . nombre ) + os . linesep txt += <str> % ( QApplication . translate ( <str> , <str> ) , self . Rmin . str ) + os . linesep txt += <str> % ( QApplication . translate ( <str> , <str> ) , self . RCalculada . str ) + os . linesep txt += <str> % ( QApplication . translate ( <str> , <str> ) , self . NTray . str ) + os . linesep txt += <str> % ( QApplication . translate ( <str> , <str> ) , self . N_feed . str ) + os . linesep txt += <str> % ( QApplication . translate ( <str> , <str> ) , self . DutyCondenser . str ) + os . linesep txt += <str> % ( QApplication . translate ( <str> , <str> ) , self . DutyReboiler . str ) + os . linesep return txt  @ classmethod def propertiesEquipment ( cls ) :          list = [ ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Temperature ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Pressure ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . MassFlow ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Dimensionless ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Temperature ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Pressure ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . MassFlow ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Dimensionless ) , ( QApplication . translate ( <str> , <str> ) , ( <str> , <str> ) , str ) , ( QApplication . translate ( <str> , <str> ) , ( <str> , <str> ) , str ) , ( QApplication . translate ( <str> , <str> ) , <str> , str ) , ( QApplication . translate ( <str> , <str> ) , <str> , str ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Dimensionless ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Dimensionless ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Dimensionless ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Dimensionless ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Power ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Power ) ] return list  def propertiesListTitle ( self , index ) :          lista = [ comp . nombre for comp in self . kwargs [ <str> ] . componente ] return lista   def batch ( ) :      D = 10 a = 2.41 W_int = 100 x_w_int = 0.5 t = list ( range ( 0 , 6 , 1 ) ) def batch ( x_w , t ) :          W_t = - D * t + W_int y = a * x_w / ( 1.0 + x_w * ( a - 1.0 ) ) dx_wdt = - ( D / W_t ) * ( y - x_w ) return dx_wdt  x_w_sol = odeint ( batch , x_w_int , t ) figure ( ) plot ( t , x_w_sol , <str> ) xlabel ( <str> ) ylabel ( <str> ) grid ( ) plt . show ( )  if __name__ == <str> :      kw = { <str> : True , <str> : True , <str> : [ 5 , 6 , 7 , 8 , 10 ] } entrada = Corriente ( ** kw ) entrada ( T = 300 ) entrada ( x = 0.5 ) entrada ( caudalMasico = 0.01 ) entrada ( fraccionMolar = [ .3 , 0.25 , 0.05 , 0.15 , 0.25 ] ) flash = Flash ( entrada = entrada ) print ( flash . propTxt ( ) )   