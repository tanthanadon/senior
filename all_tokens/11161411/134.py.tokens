import os from math import exp , log from PyQt5 . QtWidgets import QApplication try :      import CoolProp as CP  except ImportError as e :      pass  from lib import unidades , mEoS from lib . thermo import ThermoAdvanced from lib . compuestos import Componente __all__ = { } noIds = [ ] for cmp in mEoS . __all__ :      if cmp . id and cmp . _coolPropName :          __all__ [ cmp . id ] = cmp . _coolPropName  elif cmp . _coolPropName :          noIds . append ( cmp . _coolPropName )   class CoolProp ( ThermoAdvanced ) :      kwargs = { <str> : [ ] , <str> : [ ] , <str> : 0.0 , <str> : 0.0 , <str> : None , <str> : None , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : None , <str> : None , <str> : None , <str> : None , <str> : None , <str> : None } __doi__ = [ { <str> : <str> <str> , <str> : <str> <str> <str> , <str> : <str> , <str> : <str> } ] def __call__ ( self , ** kwargs ) :          self . kwargs . update ( kwargs ) if self . calculable :                  self . calculo ( ) self . status = 1 self . msg = <str>  elif self . _definition and not self . _multicomponent and <str> in kwargs :              if os . environ [ <str> ] == <str> :                  fluido = self . _name ( ) estado = CP . AbstractState ( <str> , fluido ) self . Tc = unidades . Temperature ( estado . T_critical ( ) ) self . Pc = unidades . Pressure ( estado . p_critical ( ) ) self . rhoc = unidades . Density ( estado . rhomass_critical ( ) ) self . M = unidades . Dimensionless ( estado . molar_mass ( ) * 1000 ) self . R = unidades . SpecificHeat ( estado . gas_constant ( ) / self . M ) self . Tt = unidades . Temperature ( estado . Ttriple ( ) ) self . f_accent = unidades . Dimensionless ( estado . acentric_factor ( ) ) self . name = fluido self . CAS = estado . fluid_param_string ( <str> ) self . synonim = estado . fluid_param_string ( <str> ) self . formula = estado . fluid_param_string ( <str> )  self . eq = self . _limit ( fluido , estado )   def _limit ( self , name , estado ) :          eq = { } eq [ <str> ] = estado . Tmin ( ) eq [ <str> ] = estado . Tmax ( ) eq [ <str> ] = CP . CoolProp . PropsSI ( <str> , name ) eq [ <str> ] = estado . pmax ( ) return eq  @ property def calculable ( self ) :          self . _multicomponent = False if len ( self . kwargs [ <str> ] ) > 1 :              self . _multicomponent = True  COOLPROP_available = True for id in self . kwargs [ <str> ] :              if id not in __all__ and id not in noIds :                  COOLPROP_available = False if not COOLPROP_available :                      raise ( ValueError )    if self . _multicomponent :              if self . kwargs [ <str> ] and len ( self . kwargs [ <str> ] ) == len ( self . kwargs [ <str> ] ) :                  self . _definition = True  else :                  self . _definition = False   elif self . kwargs [ <str> ] :              self . _definition = True  else :              self . _definition = False  if self . kwargs [ <str> ] != CoolProp . kwargs [ <str> ] :              self . kwargs [ <str> ] = self . kwargs [ <str> ]  if self . kwargs [ <str> ] != CoolProp . kwargs [ <str> ] :              self . kwargs [ <str> ] = 1 / self . kwargs [ <str> ]  if self . kwargs [ <str> ] != CoolProp . kwargs [ <str> ] :              self . kwargs [ <str> ] = self . kwargs [ <str> ]  if self . kwargs [ <str> ] != CoolProp . kwargs [ <str> ] :              self . kwargs [ <str> ] = self . kwargs [ <str> ]  if self . kwargs [ <str> ] != CoolProp . kwargs [ <str> ] :              self . kwargs [ <str> ] = self . kwargs [ <str> ]  if self . kwargs [ <str> ] != CoolProp . kwargs [ <str> ] :              self . kwargs [ <str> ] = self . kwargs [ <str> ]  self . _thermo = <str> for def_ in [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] :              inputs = def_ . split ( <str> ) if self . kwargs [ inputs [ 0 ] ] != CoolProp . kwargs [ inputs [ 0 ] ] and self . kwargs [ inputs [ 1 ] ] != CoolProp . kwargs [ inputs [ 1 ] ] :                  self . _thermo = def_ . replace ( <str> , <str> ) self . _inputs = inputs self . _par = CP . __getattribute__ ( <str> % self . _thermo ) break   return self . _definition and self . _thermo  def args ( self ) :          var1 = self . kwargs [ self . _inputs [ 0 ] ] var2 = self . kwargs [ self . _inputs [ 1 ] ] args = [ var1 , var2 ] return args  def _new ( self , ** kw ) :          return self . __class__ ( ids = self . kwargs [ <str> ] , ** kw )  def _name ( self ) :          lst = [ ] for fld in self . kwargs [ <str> ] :              if fld in __all__ :                  lst . append ( __all__ [ fld ] )  elif fld in noIds :                  lst . append ( fld )   name = <str> . join ( lst ) return name  def calculo ( self ) :          fluido = self . _name ( ) args = self . args ( ) estado = CP . AbstractState ( <str> , fluido ) self . eq = self . _limit ( fluido , estado ) if self . _multicomponent :              estado . set_mole_fractions ( self . kwargs [ <str> ] )  estado . update ( self . _par , * args ) self . M = unidades . Dimensionless ( estado . molar_mass ( ) * 1000 ) if self . _multicomponent :              Cmps = [ Componente ( int ( i ) ) for i in self . kwargs [ <str> ] ] V = sum ( [ xi * cmp . Vc for xi , cmp in zip ( self . kwargs [ <str> ] , Cmps ) ] ) k = [ xi * cmp . Vc / V for xi , cmp in zip ( self . kwargs [ <str> ] , Cmps ) ] Tcm = sum ( [ ki * cmp . Tc for ki , cmp in zip ( k , Cmps ) ] ) self . Tc = unidades . Temperature ( Tcm ) tpc = sum ( [ x * cmp . Tc for x , cmp in zip ( self . kwargs [ <str> ] , Cmps ) ] ) ppc = sum ( [ x * cmp . Pc for x , cmp in zip ( self . kwargs [ <str> ] , Cmps ) ] ) sumaw = 0 for xi , cmp in zip ( self . kwargs [ <str> ] , Cmps ) :                  sumaw += xi * cmp . f_acent  pc = ppc + ppc * ( 5.808 + 4.93 * sumaw ) * ( self . Tc - tpc ) / tpc self . Pc = unidades . Pressure ( pc ) sumaxvc23 = sum ( [ xi * cmp . Vc ** ( 2. / 3 ) for xi , cmp in zip ( self . kwargs [ <str> ] , Cmps ) ] ) k = [ xi * cmp . Vc ** ( 2. / 3 ) / sumaxvc23 for xi , cmp in zip ( self . kwargs [ <str> ] , Cmps ) ] C = 0 V = [ [ - 1.4684 * abs ( ( cmpi . Vc - cmpj . Vc ) / ( cmpi . Vc + cmpj . Vc ) ) + C for cmpj in Cmps ] for cmpi in Cmps ] v = [ [ V [ i ] [ j ] * ( cmpi . Vc + cmpj . Vc ) / 2. for j , cmpj in enumerate ( Cmps ) ] for i , cmpi in enumerate ( Cmps ) ] suma1 = sum ( [ ki * cmp . Vc for ki , cmp in zip ( k , Cmps ) ] ) suma2 = sum ( [ ki * kj * v [ i ] [ j ] for j , kj in enumerate ( k ) for i , ki in enumerate ( k ) ] ) self . rhoc = unidades . Density ( ( suma1 + suma2 ) * self . M )  else :              self . Tc = unidades . Temperature ( estado . T_critical ( ) ) self . Pc = unidades . Pressure ( estado . p_critical ( ) ) self . rhoc = unidades . Density ( estado . rhomass_critical ( ) )  self . R = unidades . SpecificHeat ( estado . gas_constant ( ) / self . M ) self . Tt = unidades . Temperature ( estado . Ttriple ( ) ) if self . _multicomponent :              estado2 = CP . AbstractState ( <str> , fluido ) estado2 . set_mole_fractions ( self . kwargs [ <str> ] ) estado2 . update ( CP . PQ_INPUTS , 101325 , 1 ) self . Tb = unidades . Temperature ( estado2 . T ( ) )  else :              Pt = estado . trivial_keyed_output ( CP . iP_triple ) if Pt < 101325 :                  estado2 = CP . AbstractState ( <str> , fluido ) estado2 . update ( CP . PQ_INPUTS , 101325 , 1 ) self . Tb = unidades . Temperature ( estado2 . T ( ) )   self . f_accent = unidades . Dimensionless ( estado . acentric_factor ( ) ) self . phase , x = self . getphase ( estado ) self . x = unidades . Dimensionless ( x ) if self . _multicomponent :              string = fluido . replace ( <str> , <str> ) string += <str> self . name = string % tuple ( self . kwargs [ <str> ] ) self . CAS = <str> self . synonim = <str> self . formula = <str>  else :              self . name = fluido self . CAS = estado . fluid_param_string ( <str> ) self . synonim = estado . fluid_param_string ( <str> ) self . formula = estado . fluid_param_string ( <str> )  self . P = unidades . Pressure ( estado . p ( ) ) self . T = unidades . Temperature ( estado . T ( ) ) self . Tr = unidades . Dimensionless ( self . T / self . Tc ) self . Pr = unidades . Dimensionless ( self . P / self . Pc ) self . rho = unidades . Density ( estado . rhomass ( ) ) self . v = unidades . SpecificVolume ( 1. / self . rho ) cp0 = self . _prop0 ( estado ) self . _cp0 ( cp0 ) self . Liquido = ThermoAdvanced ( ) self . Gas = ThermoAdvanced ( ) if self . x == 0 :              self . fill ( self . Liquido , estado ) self . fill ( self , estado ) self . fillNone ( self . Gas )  elif self . x == 1 :              self . fill ( self . Gas , estado ) self . fill ( self , estado ) self . fillNone ( self . Liquido )  else :              liquido = CP . AbstractState ( <str> , fluido ) if self . _multicomponent :                  xi = estado . mole_fractions_liquid ( ) liquido . set_mole_fractions ( xi )  liquido . specify_phase ( CP . iphase_liquid ) liquido . update ( CP . QT_INPUTS , 0 , self . T ) self . fill ( self . Liquido , liquido ) vapor = CP . AbstractState ( <str> , fluido ) if self . _multicomponent :                  yi = estado . mole_fractions_vapor ( ) vapor . set_mole_fractions ( yi )  vapor . specify_phase ( CP . iphase_gas ) vapor . update ( CP . QT_INPUTS , 1 , self . T ) self . fill ( self . Gas , vapor ) self . fill ( self , estado )  if self . _multicomponent :              self . sigma = unidades . Tension ( None )  elif x < 1 and self . Tt <= self . T <= self . Tc :              try :                  self . sigma = unidades . Tension ( estado . surface_tension ( ) )  except ValueError :                  self . sigma = unidades . Tension ( None )   else :              self . sigma = unidades . Tension ( None )  self . virialB = unidades . SpecificVolume ( estado . Bvirial ( ) ) self . virialC = unidades . SpecificVolume_square ( estado . Cvirial ( ) ) self . invT = unidades . InvTemperature ( - 1 / self . T ) if 0 < self . x < 1 :              self . Hvap = unidades . Enthalpy ( self . Gas . h - self . Liquido . h ) self . Svap = unidades . SpecificHeat ( self . Gas . s - self . Liquido . s )  else :              self . Hvap = unidades . Enthalpy ( None ) self . Svap = unidades . SpecificHeat ( None )   def _prop0 ( self , estado ) :          tau = self . Tc / self . T fio = estado . alpha0 ( ) fiot = estado . dalpha0_dTau ( ) fiott = estado . d2alpha0_dTau2 ( ) propiedades = { } propiedades [ <str> ] = self . R * self . T / self . P . kPa propiedades [ <str> ] = self . R * self . T * ( 1 + tau * fiot ) * 1000 propiedades [ <str> ] = self . R * ( tau * fiot - fio ) * 1000 propiedades [ <str> ] = - self . R * tau ** 2 * fiott * 1000 propiedades [ <str> ] = self . R * ( - tau ** 2 * fiott + 1 ) * 1000 propiedades [ <str> ] = ( self . R * self . T * 1000 / ( 1 + tau ** 2 / abs ( fiott ) ) ) ** 0.5 return propiedades  def fill ( self , fase , estado ) :          fase . _bool = True fase . M = unidades . Dimensionless ( estado . molar_mass ( ) * 1000 ) fase . rho = unidades . Density ( estado . rhomass ( ) ) fase . v = unidades . SpecificVolume ( 1. / fase . rho ) fase . Z = unidades . Dimensionless ( estado . keyed_output ( CP . iZ ) ) fase . h = unidades . Enthalpy ( estado . hmass ( ) ) fase . s = unidades . SpecificHeat ( estado . smass ( ) ) fase . u = unidades . Enthalpy ( estado . umass ( ) ) fase . a = unidades . Enthalpy ( fase . u - self . T * fase . s ) fase . g = unidades . Enthalpy ( fase . h - self . T * fase . s ) if self . _multicomponent :              fase . fi = [ ] fase . f = [ ] for i in range ( len ( self . kwargs [ <str> ] ) ) :                  fase . fi . append ( unidades . Dimensionless ( estado . fugacity_coefficient ( i ) ) ) fase . f . append ( unidades . Pressure ( estado . fugacity ( i ) ) )   else :              fase . fi = [ unidades . Dimensionless ( exp ( estado . alphar ( ) + estado . delta ( ) * estado . dalphar_dDelta ( ) - log ( 1 + estado . delta ( ) * estado . dalphar_dDelta ( ) ) ) ) ] fase . f = [ unidades . Pressure ( self . P * f ) for f in fase . fi ]  fase . cv = unidades . SpecificHeat ( estado . cvmass ( ) ) fase . cp = unidades . SpecificHeat ( estado . cpmass ( ) ) fase . cp_cv = unidades . Dimensionless ( fase . cp / fase . cv ) fase . gamma = fase . cp_cv fase . w = unidades . Speed ( estado . speed_sound ( ) ) fase . rhoM = unidades . MolarDensity ( estado . rhomolar ( ) , <str> ) fase . hM = unidades . MolarEnthalpy ( estado . hmolar ( ) , <str> ) fase . sM = unidades . MolarSpecificHeat ( estado . smolar ( ) , <str> ) fase . uM = unidades . MolarEnthalpy ( estado . umolar ( ) , <str> ) fase . aM = unidades . MolarEnthalpy ( fase . a * self . M ) fase . gM = unidades . MolarEnthalpy ( fase . g * self . M ) fase . cvM = unidades . MolarSpecificHeat ( estado . cvmolar ( ) , <str> ) fase . cpM = unidades . MolarSpecificHeat ( estado . cpmolar ( ) , <str> ) fase . joule = unidades . TemperaturePressure ( estado . first_partial_deriv ( CP . iT , CP . iP , CP . iHmass ) ) fase . Gruneisen = unidades . Dimensionless ( fase . v / fase . cv * estado . first_partial_deriv ( CP . iP , CP . iT , CP . iDmass ) ) fase . alfav = unidades . InvTemperature ( estado . isobaric_expansion_coefficient ( ) ) fase . kappa = unidades . InvPressure ( estado . isothermal_compressibility ( ) ) fase . kappas = unidades . InvPressure ( - 1 / fase . v * self . derivative ( <str> , <str> , <str> , fase ) ) fase . alfap = unidades . Density ( fase . alfav / self . P / fase . kappa ) fase . betap = unidades . Density ( - 1 / self . P * self . derivative ( <str> , <str> , <str> , fase ) ) fase . betas = unidades . TemperaturePressure ( estado . first_partial_deriv ( CP . iT , CP . iP , CP . iSmass ) ) fase . kt = unidades . Dimensionless ( fase . rho / self . P * estado . first_partial_deriv ( CP . iP , CP . iDmass , CP . iT ) ) fase . Ks = unidades . Pressure ( fase . rho * estado . first_partial_deriv ( CP . iP , CP . iDmass , CP . iSmass ) ) fase . Kt = unidades . Pressure ( fase . rho * estado . first_partial_deriv ( CP . iP , CP . iDmass , CP . iT ) ) fase . ks = unidades . Dimensionless ( fase . rho / self . P * estado . first_partial_deriv ( CP . iP , CP . iDmass , CP . iSmass ) ) fase . dhdT_rho = unidades . SpecificHeat ( estado . first_partial_deriv ( CP . iHmass , CP . iT , CP . iDmass ) ) fase . dhdT_P = unidades . SpecificHeat ( estado . first_partial_deriv ( CP . iHmass , CP . iT , CP . iP ) ) fase . dhdP_T = unidades . EnthalpyPressure ( estado . first_partial_deriv ( CP . iHmass , CP . iP , CP . iT ) ) fase . deltat = fase . dhdP_T fase . dhdP_rho = unidades . EnthalpyPressure ( estado . first_partial_deriv ( CP . iHmass , CP . iP , CP . iDmass ) ) fase . dhdrho_T = unidades . EnthalpyDensity ( estado . first_partial_deriv ( CP . iHmass , CP . iDmass , CP . iT ) ) fase . dhdrho_P = unidades . EnthalpyDensity ( estado . first_partial_deriv ( CP . iHmass , CP . iDmass , CP . iP ) ) fase . dpdT_rho = unidades . PressureTemperature ( estado . first_partial_deriv ( CP . iP , CP . iT , CP . iDmass ) ) fase . dpdrho_T = unidades . PressureDensity ( estado . first_partial_deriv ( CP . iP , CP . iDmass , CP . iT ) ) fase . drhodP_T = unidades . DensityPressure ( estado . first_partial_deriv ( CP . iDmass , CP . iP , CP . iT ) ) fase . drhodT_P = unidades . DensityTemperature ( estado . first_partial_deriv ( CP . iDmass , CP . iT , CP . iP ) ) fase . Z_rho = unidades . SpecificVolume ( ( fase . Z - 1 ) / fase . rho ) fase . IntP = unidades . Pressure ( self . T * estado . first_partial_deriv ( CP . iP , CP . iT , CP . iDmass ) - self . P ) fase . hInput = unidades . Enthalpy ( - fase . rho * estado . first_partial_deriv ( CP . iHmass , CP . iDmass , CP . iP ) ) fase . virialB = unidades . SpecificVolume ( estado . Bvirial ( ) ) fase . virialC = unidades . SpecificVolume_square ( estado . Cvirial ( ) ) fase . invT = unidades . InvTemperature ( - 1 / self . T ) try :              fase . mu = unidades . Viscosity ( estado . viscosity ( ) )  except ValueError :              fase . mu = unidades . Viscosity ( None ) fase . Prandt = unidades . Dimensionless ( None )  try :              fase . k = unidades . ThermalConductivity ( estado . conductivity ( ) )  except ValueError :              fase . k = unidades . ThermalConductivity ( None )  fase . nu = unidades . Diffusivity ( fase . mu / fase . rho ) fase . alfa = unidades . Diffusivity ( fase . k / fase . rho / fase . cp ) fase . fraccion = estado . get_mole_fractions ( ) fase . fraccion_masica = estado . get_mass_fractions ( ) fase . epsilon = unidades . Dimensionless ( None )  def getphase ( self , estado ) :          phase = estado . phase ( ) if phase == CP . iphase_supercritical :              msg = QApplication . translate ( <str> , <str> ) x = 1  elif phase == CP . iphase_supercritical_liquid :              msg = QApplication . translate ( <str> , <str> ) x = 1  elif phase == CP . iphase_supercritical_gas :              msg = QApplication . translate ( <str> , <str> ) x = 1  elif phase == CP . iphase_gas :              msg = QApplication . translate ( <str> , <str> ) x = 1  elif phase == CP . iphase_liquid :              msg = QApplication . translate ( <str> , <str> ) x = 0  elif phase == CP . iphase_twophase :              msg = QApplication . translate ( <str> , <str> ) x = estado . Q ( )  elif phase == CP . iphase_critical_point :              msg = QApplication . translate ( <str> , <str> ) x = 1  return msg , x    