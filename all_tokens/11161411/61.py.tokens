import os from PyQt5 . QtWidgets import QApplication from scipy import log , exp , optimize , polyval , roots , r_ from scipy . constants import g from lib . unidades import ( Pressure , Length , Power , VolFlow , Currency , Dimensionless , DeltaP ) from lib . datasheet import pdf from equipment . parents import equipment class Pump ( equipment ) :      title = QApplication . translate ( <str> , <str> ) help = <str> kwargs = { <str> : None , <str> : 0 , <str> : 0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : [ ] , <str> : 0.0 , <str> : 0.0 , <str> : 2.8 , <str> : 0.0 , <str> : 0.0 , <str> : 0 , <str> : 0 , <str> : 0 , <str> : 0 , <str> : 0 } kwargsInput = ( <str> , ) kwargsCheck = ( <str> , ) kwargsValue = ( <str> , <str> , <str> , <str> , <str> , <str> ) kwargsList = ( <str> , <str> , <str> , <str> , <str> , <str> ) calculateValue = ( <str> , <str> , <str> , <str> , <str> ) calculateCostos = ( <str> , <str> , <str> , <str> ) indiceCostos = 7 salida = [ None ] TEXT_BOMBA = ( QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) ) TEXT_CENTRIFUGA = ( QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) ) TEXT_MATERIAL = ( QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) ) TEXT_MOTOR = ( QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) ) TEXT_RPM = ( <str> , <str> , <str> ) @ property def isCalculable ( self ) :          if self . kwargs [ <str> ] and self . kwargs [ <str> ] and self . kwargs [ <str> ] :              self . statusCoste = True  else :              self . statusCoste = False  if not self . kwargs [ <str> ] :              self . msg = QApplication . translate ( <str> , <str> ) self . status = 0  else :              P = self . kwargs [ <str> ] or self . kwargs [ <str> ] or self . kwargs [ <str> ] if self . kwargs [ <str> ] :                  if self . kwargs [ <str> ] :                      if P and self . kwargs [ <str> ] :                          self . msg = <str> self . status = 1 return True  elif P :                          self . msg = QApplication . translate ( <str> , <str> ) self . status = 0  else :                          self . msg = QApplication . translate ( <str> , <str> ) self . status = 0   elif self . kwargs [ <str> ] :                      self . msg = <str> self . status = 1 return True  else :                      self . msg = QApplication . translate ( <str> , <str> ) self . status = 0   else :                  if P and self . kwargs [ <str> ] :                      self . msg = <str> self . status = 1 return True  elif P :                      self . msg = QApplication . translate ( <str> , <str> ) self . status = 0  else :                      self . msg = QApplication . translate ( <str> , <str> ) self . status = 0     def calculo ( self ) :          entrada = self . kwargs [ <str> ] self . rendimientoCalculado = Dimensionless ( self . kwargs [ <str> ] ) if self . kwargs [ <str> ] :              DeltaP = Pressure ( self . kwargs [ <str> ] - entrada . P )  elif self . kwargs [ <str> ] :              DeltaP = Pressure ( self . kwargs [ <str> ] )  elif self . kwargs [ <str> ] :              DeltaP = Pressure ( self . kwargs [ <str> ] * entrada . Liquido . rho * g )  else :              DeltaP = Pressure ( 0 )  if self . kwargs [ <str> ] :              b1 = self . kwargs [ <str> ] != self . kwargs [ <str> ] [ 0 ] b2 = self . kwargs [ <str> ] != self . kwargs [ <str> ] [ 1 ] if b1 or b2 :                  self . curvaActual = self . calcularCurvaActual ( )  else :                  self . curvaActual = self . kwargs [ <str> ]  self . Ajustar_Curvas_Caracteristicas ( )  if not self . kwargs [ <str> ] :              head = Length ( DeltaP / g / entrada . Liquido . rho ) power = Power ( head * g * entrada . Liquido . rho * entrada . Q / self . rendimientoCalculado ) P_freno = Power ( power * self . rendimientoCalculado )  elif not self . kwargs [ <str> ] :              head = Length ( polyval ( self . CurvaHQ , entrada . Q ) ) DeltaP = Pressure ( head * g * entrada . Liquido . rho ) power = Power ( entrada . Q * DeltaP ) P_freno = Power ( polyval ( self . CurvaPotQ , entrada . Q ) ) self . rendimientoCalculado = Dimensionless ( power / P_freno )  else :              head = Length ( self . DeltaP / g / entrada . Liquido . rho ) poli = [ self . CurvaHQ [ 0 ] , self . CurvaHQ [ 1 ] , self . CurvaHQ [ 2 ] - head ] Q = roots ( poli ) [ 0 ] power = Power ( Q * self . DeltaP ) entrada = entrada . clone ( split = Q / entrada . Q ) P_freno = Power ( polyval ( self . CurvaPotQ , Q ) ) self . rendimientoCalculado = Dimensionless ( power / P_freno )  self . deltaP = DeltaP self . headCalculada = head self . power = power self . P_freno = P_freno self . salida = [ entrada . clone ( P = entrada . P + DeltaP ) ] self . Pin = entrada . P self . PoutCalculada = self . salida [ 0 ] . P self . volflow = entrada . Q self . cp_cv = entrada . Liquido . cp_cv  def Ajustar_Curvas_Caracteristicas ( self ) :          Q = r_ [ self . curvaActual [ 2 ] ] h = r_ [ self . curvaActual [ 3 ] ] Pot = r_ [ self . curvaActual [ 4 ] ] NPSH = r_ [ self . curvaActual [ 5 ] ] def funcion ( p , x ) :              return p [ 0 ] * x ** 2 + p [ 1 ] * x + p [ 2 ]  def residuo ( p , x , y ) :              return funcion ( p , x ) - y  inicio = r_ [ 1 , 1 , 1 ] ajuste_h , exito_h = optimize . leastsq ( residuo , inicio , args = ( Q , h ) ) self . CurvaHQ = ajuste_h ajuste_P , exito_P = optimize . leastsq ( residuo , inicio , args = ( Q , Pot ) ) self . CurvaPotQ = ajuste_P def funcion_NPSH ( p , x ) :              return p [ 0 ] + p [ 1 ] * exp ( p [ 2 ] * x )  def residuo_NPSH ( p , x , y ) :              return funcion_NPSH ( p , x ) - y  ajuste_N , ex = optimize . leastsq ( residuo_NPSH , inicio , args = ( Q , NPSH ) ) self . CurvaNPSHQ = ajuste_N  def calcularCurvaActual ( self ) :          D1 = self . kwargs [ <str> ] [ 0 ] N1 = self . kwargs [ <str> ] [ 1 ] D2 = self . kwargs [ <str> ] N2 = self . kwargs [ <str> ] Q1 = r_ [ self . kwargs [ <str> ] [ 2 ] ] h1 = r_ [ self . kwargs [ <str> ] [ 3 ] ] Pot1 = r_ [ self . kwargs [ <str> ] [ 4 ] ] npsh1 = r_ [ self . kwargs [ <str> ] [ 5 ] ] Q2 = Q1 * D2 / D1 * N2 / N1 h2 = h1 * N2 ** 2 / N1 ** 2 * D2 ** 2 / D1 ** 2 Pot2 = Pot1 * N2 ** 3 / N1 ** 3 * D2 ** 3 / D1 ** 3 npsh2 = npsh1 * N2 ** 2 / N1 ** 2 * D2 ** 2 / D1 ** 2 return [ D2 , N2 , Q2 , h2 , Pot2 , npsh2 ]  def coste ( self ) :          HP = self . power . hp LnHP = log ( self . power . hp ) Q = self . kwargs [ <str> ] . Q . galUSmin CI = self . kwargs [ <str> ] BI = self . kwargs [ <str> ] if self . kwargs [ <str> ] == 0 :              QH = log ( Q * self . power . hp ** 0.5 ) Fm = [ 1. , 1.35 , 1.15 , 2. , 2. , 3.5 , 3.3 , 4.95 , 4.6 , 9.7 , 2.95 , 1.15 , 1.90 ] B1 = [ 0. , 5.1029 , 0.0632 , 2.0290 , 13.7321 , 9.8849 ] B2 = [ 0. , - 1.2217 , 0.2744 , - 0.2371 , - 2.8304 , - 1.6164 ] B3 = [ 0. , 0.0771 , - 0.0253 , 0.0102 , 0.1542 , 0.0834 ] fm = Fm [ self . kwargs [ <str> ] ] b1 = B1 [ self . kwargs [ <str> ] ] b2 = B2 [ self . kwargs [ <str> ] ] b3 = B3 [ self . kwargs [ <str> ] ] Ft = exp ( b1 + b2 * QH + b3 * QH ** 2 ) Cb = fm * Ft * 1.55 * exp ( 8.833 - 0.6019 * QH + 0.0519 * QH ** 2 )  elif self . kwargs [ <str> ] == 1 :              if self . kwargs [ <str> ] == 0 :                  Cb = 40. * Q ** 0.81  elif self . kwargs [ <str> ] == 3 :                  Cb = 410. * Q ** 0.52  elif self . kwargs [ <str> ] == 12 :                  Cb = 410. * 1.4 * Q ** 0.52  elif self . kwargs [ <str> ] == 5 :                  Cb = 410. * 1.86 * Q ** 0.52  elif self . kwargs [ <str> ] == 6 :                  Cb = 410. * 2.20 * Q ** 0.52  else :                  Cb = 40. * Q ** 0.81   elif self . kwargs [ <str> ] == 2 :              Cb = 1000 * exp ( - 0.0881 + 0.1986 * log ( Q ) + 0.0291 * log ( Q ) ** 2 )  elif self . kwargs [ <str> ] == 3 :              Cb = 0.036 * Q ** 0.82 * 1000  elif self . kwargs [ <str> ] == 4 :              Cb = 0.02 * Q ** 0.78 * 1000  C_bomba = Cb * CI / BI if self . kwargs [ <str> ] == 0 :              if self . kwargs [ <str> ] == 0 and HP <= 7.5 :                  a1 , a2 , a3 = 4.8314 , 0.0966 , 0.10960  elif self . kwargs [ <str> ] == 0 and 7.5 < HP <= 250. :                  a1 , a2 , a3 = 4.1514 , 0.5347 , 0.05252  elif self . kwargs [ <str> ] == 0 and HP > 250. :                  a1 , a2 , a3 = 4.2432 , 1.03251 , - 0.03595  elif self . kwargs [ <str> ] == 1 and HP <= 7.5 :                  a1 , a2 , a3 = 4.7075 , - 0.01511 , 0.22888  elif self . kwargs [ <str> ] == 1 and 7.5 < HP <= 250 :                  a1 , a2 , a3 = 4.5212 , 0.47242 , 0.04820  elif self . kwargs [ <str> ] == 1 and HP > 250. :                  a1 , a2 , a3 = 7.4044 , - 0.06464 , 0.05448  elif self . kwargs [ <str> ] == 2 and HP <= 7.5 :                  a1 , a2 , a3 = 4.9298 , 0.30118 , 0.12630  elif self . kwargs [ <str> ] == 2 and 7.5 < HP <= 250 :                  a1 , a2 , a3 = 5.0999 , 0.35861 , 0.06052  elif self . kwargs [ <str> ] == 2 and HP > 250. :                  a1 , a2 , a3 = 4.6163 , 0.88531 , - 0.02188   elif self . kwargs [ <str> ] == 1 :              if self . kwargs [ <str> ] == 0 and HP <= 7.5 :                  a1 , a2 , a3 = 5.1058 , 0.03316 , 0.15374  elif self . kwargs [ <str> ] == 0 and 7.5 < HP <= 250. :                  a1 , a2 , a3 = 3.8544 , 0.83311 , 0.02399  elif self . kwargs [ <str> ] == 0 and HP > 250. :                  a1 , a2 , a3 = 5.3182 , 1.08470 , - 0.05695  elif self . kwargs [ <str> ] == 1 and HP <= 7.5 :                  a1 , a2 , a3 = 4.9687 , - 0.00930 , 0.22616  elif self . kwargs [ <str> ] == 1 and HP > 7.5 :                  a1 , a2 , a3 = 4.5347 , 0.57065 , 0.04609  elif self . kwargs [ <str> ] == 2 and HP <= 7.5 :                  a1 , a2 , a3 = 5.1532 , 0.28931 , 0.14357  elif self . kwargs [ <str> ] == 2 and HP > 7.5 :                  a1 , a2 , a3 = 5.3858 , 0.31004 , 0.07406   elif self . kwargs [ <str> ] == 2 :              if self . kwargs [ <str> ] == 0 and HP <= 7.5 :                  a1 , a2 , a3 = 5.3934 , - 0.00333 , 0.15475  elif self . kwargs [ <str> ] == 0 and HP > 7.5 :                  a1 , a2 , a3 = 4.4442 , 0.60820 , 0.05202  elif self . kwargs [ <str> ] == 1 and HP <= 7.5 :                  a1 , a2 , a3 = 5.2851 , 0.00048 , 0.19949  elif self . kwargs [ <str> ] == 1 and HP > 7.5 :                  a1 , a2 , a3 = 4.8178 , 0.51086 , 0.05293  elif self . kwargs [ <str> ] == 2 and HP <= 7.5 :                  a1 , a2 , a3 = 5.4166 , 0.31216 , 0.10573  elif self . kwargs [ <str> ] == 2 and HP > 7.5 :                  a1 , a2 , a3 = 5.5655 , 0.31284 , 0.07212   CI = self . kwargs [ <str> ] BI = self . kwargs [ <str> ] C_motor = 1.2 * exp ( a1 + a2 * LnHP + a3 * LnHP ** 2 ) * CI / BI self . C_bomba = Currency ( C_bomba ) self . C_motor = Currency ( C_motor ) self . C_adq = Currency ( C_bomba + C_motor ) self . C_inst = Currency ( self . C_adq * self . kwargs [ <str> ] )  def propTxt ( self ) :          txt = <str> txt += QApplication . translate ( <str> , <str> ) txt += <str> + os . linesep txt += self . propertiesToText ( range ( 8 ) ) if self . statusCoste :              txt += os . linesep + <str> txt += QApplication . translate ( <str> , <str> ) txt += <str> + os . linesep txt += self . propertiesToText ( range ( 8 , 11 ) ) txt += self . propertiesToText ( 11 , linesep = False ) if self . kwargs [ <str> ] == 0 :                  txt += <str> txt += self . TEXT_CENTRIFUGA [ self . kwargs [ <str> ] ]  txt += os . linesep txt += self . propertiesToText ( range ( 13 , 19 ) )  return txt  @ classmethod def propertiesEquipment ( cls ) :          l = [ ( QApplication . translate ( <str> , <str> ) , <str> , Pressure ) , ( QApplication . translate ( <str> , <str> ) , <str> , Pressure ) , ( QApplication . translate ( <str> , <str> ) , <str> , Length ) , ( QApplication . translate ( <str> , <str> ) , <str> , Power ) , ( QApplication . translate ( <str> , <str> ) , <str> , VolFlow ) , ( QApplication . translate ( <str> , <str> ) , <str> , Power ) , ( QApplication . translate ( <str> , <str> ) , <str> , Dimensionless ) , ( <str> , <str> , Dimensionless ) , ( QApplication . translate ( <str> , <str> ) , <str> , float ) , ( QApplication . translate ( <str> , <str> ) , <str> , float ) , ( QApplication . translate ( <str> , <str> ) , <str> , float ) , ( QApplication . translate ( <str> , <str> ) , ( <str> , <str> ) , str ) , ( QApplication . translate ( <str> , <str> ) , ( <str> , <str> ) , str ) , ( QApplication . translate ( <str> , <str> ) , ( <str> , <str> ) , str ) , ( QApplication . translate ( <str> , <str> ) , ( <str> , <str> ) , str ) , ( QApplication . translate ( <str> , <str> ) , ( <str> , <str> ) , str ) , ( QApplication . translate ( <str> , <str> ) , <str> , Currency ) , ( QApplication . translate ( <str> , <str> ) , <str> , Currency ) , ( QApplication . translate ( <str> , <str> ) , <str> , Currency ) , ( QApplication . translate ( <str> , <str> ) , <str> , Currency ) ] return l  def writeStatetoJSON ( self , state ) :          state [ <str> ] = self . deltaP state [ <str> ] = self . rendimientoCalculado state [ <str> ] = self . headCalculada state [ <str> ] = self . power state [ <str> ] = self . P_freno state [ <str> ] = self . Pin state [ <str> ] = self . PoutCalculada state [ <str> ] = self . volflow state [ <str> ] = self . statusCoste state [ <str> ] = self . cp_cv if self . statusCoste :              state [ <str> ] = self . C_bomba state [ <str> ] = self . C_motor state [ <str> ] = self . C_adq state [ <str> ] = self . C_inst  if self . kwargs [ <str> ] :              pass   def readStatefromJSON ( self , state ) :          self . deltaP = DeltaP ( state [ <str> ] ) self . rendimientoCalculado = Dimensionless ( state [ <str> ] ) self . headCalculada = Length ( state [ <str> ] ) self . power = Power ( state [ <str> ] ) self . P_freno = Power ( state [ <str> ] ) self . Pin = Pressure ( state [ <str> ] ) self . PoutCalculada = Pressure ( state [ <str> ] ) self . volflow = VolFlow ( state [ <str> ] ) self . cp_cv = Dimensionless ( state [ <str> ] ) self . statusCoste = state [ <str> ] if self . statusCoste :              self . C_bomba = Currency ( state [ <str> ] ) self . C_motor = Currency ( state [ <str> ] ) self . C_adq = Currency ( state [ <str> ] ) self . C_inst = Currency ( state [ <str> ] )  if self . kwargs [ <str> ] :              pass  self . salida = [ None ]  def datamap2xls ( self ) :          datamap = ( ( <str> , <str> , <str> ) , ( <str> , <str> , <str> ) , ( <str> , <str> , <str> ) , ( <str> , <str> , <str> ) , ) return datamap  def export2pdf ( self ) :          bomba = pdf ( <str> ) bomba . bomba ( self ) bomba . dibujar ( ) os . system ( <str> )  def export2xls ( self ) :          import xlwt font0 = xlwt . Font ( ) font0 . bold = True font0 . height = 300 print ( ( font0 . height ) ) style0 = xlwt . XFStyle ( ) style0 . font = font0 style1 = xlwt . XFStyle ( ) style1 . num_format_str = <str> wb = xlwt . Workbook ( ) ws = wb . add_sheet ( <str> ) ws . write ( 0 , 0 , <str> , style0 ) ws . write ( 2 , 0 , 1 ) ws . write ( 2 , 1 , 1 ) ws . write ( 2 , 2 , xlwt . Formula ( <str> ) ) wb . save ( <str> ) os . system ( <str> )   if __name__ == <str> :      import doctest doctest . testmod ( )   