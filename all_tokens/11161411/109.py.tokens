from math import pi from numpy . linalg import solve from scipy import log , log10 , exp from lib . compuestos import ( Componente , RhoL_Costald , RhoL_AaltoKeskinen , RhoL_TaitCostald , RhoL_Nasrifar , MuG_DeanStiel , MuG_API , ThG_StielThodos ) from lib . physics import R_atml , R , Collision_Neufeld from lib import unidades , config from lib . utilities import refDoc __doi__ = { 1 : { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } , 2 : { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } , 3 : { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } , 4 : { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } , 5 : { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } , 6 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 7 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 8 : { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } , 9 : { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } , 10 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 11 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 12 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 13 : { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } , 14 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 15 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 16 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 17 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 18 : { <str> : <str> , <str> : <str> <str> <str> , <str> : <str> , <str> : <str> } , 19 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 20 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 21 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , } def mix_unitmassflow ( unitMassFlow , cmps ) :      massFlow = sum ( unitMassFlow ) unitMolarFlow = [ mass / cmp . M for mass , cmp in zip ( unitMassFlow , cmps ) ] molarFlow = sum ( unitMolarFlow ) molarFraction = [ mi / molarFlow for mi in unitMolarFlow ] massFraction = [ mi / massFlow for mi in unitMassFlow ] kw = { } kw [ <str> ] = unitMassFlow kw [ <str> ] = unitMolarFlow kw [ <str> ] = molarFlow kw [ <str> ] = massFlow kw [ <str> ] = molarFraction kw [ <str> ] = massFraction return kw  def mix_unitmolarflow ( unitMolarFlow , cmps ) :      molarFlow = sum ( unitMolarFlow ) unitMassFlow = [ mol * cmp . M for mol , cmp in zip ( unitMolarFlow , cmps ) ] massFlow = sum ( unitMassFlow ) molarFraction = [ mi / molarFlow for mi in unitMolarFlow ] massFraction = [ mi / massFlow for mi in unitMassFlow ] kw = { } kw [ <str> ] = unitMassFlow kw [ <str> ] = unitMolarFlow kw [ <str> ] = molarFlow kw [ <str> ] = massFlow kw [ <str> ] = molarFraction kw [ <str> ] = massFraction return kw  def mix_massflow_molarfraction ( massFlow , molarFraction , cmps ) :      pesos = [ x * cmp . M for x , cmp in zip ( molarFraction , cmps ) ] M = sum ( pesos ) molarFlow = massFlow / M massFraction = [ peso / M for peso in pesos ] unitMassFlow = [ x * massFlow for x in massFraction ] unitMolarFlow = [ x * molarFlow for x in molarFraction ] kw = { } kw [ <str> ] = unitMassFlow kw [ <str> ] = unitMolarFlow kw [ <str> ] = molarFlow kw [ <str> ] = massFlow kw [ <str> ] = molarFraction kw [ <str> ] = massFraction return kw  def mix_massflow_massfraction ( massFlow , massFraction , cmps ) :      unitMassFlow = [ x * massFlow for x in massFraction ] unitMolarFlow = [ mass / cmp . M for mass , cmp in zip ( unitMassFlow , cmps ) ] molarFlow = sum ( unitMolarFlow ) molarFraction = [ mi / molarFlow for mi in unitMolarFlow ] kw = { } kw [ <str> ] = unitMassFlow kw [ <str> ] = unitMolarFlow kw [ <str> ] = molarFlow kw [ <str> ] = massFlow kw [ <str> ] = molarFraction kw [ <str> ] = massFraction return kw  def mix_molarflow_molarfraction ( molarFlow , molarFraction , cmps ) :      unitMolarFlow = [ x * molarFlow for x in molarFraction ] unitMassFlow = [ mol * cmp . M for mol , cmp in zip ( unitMolarFlow , cmps ) ] massFlow = sum ( unitMassFlow ) massFraction = [ mi / massFlow for mi in unitMassFlow ] kw = { } kw [ <str> ] = unitMassFlow kw [ <str> ] = unitMolarFlow kw [ <str> ] = molarFlow kw [ <str> ] = massFlow kw [ <str> ] = molarFraction kw [ <str> ] = massFraction return kw  def mix_molarflow_massfraction ( molarFlow , massFraction , cmps ) :      moles = [ x / cmp . M for x , cmp in zip ( massFraction , cmps ) ] M = sum ( moles ) massFlow = molarFlow * M molarFraction = [ mol / molarFlow for mol in moles ] unitMassFlow = [ x * massFlow for x in massFraction ] unitMolarFlow = [ x * molarFlow for x in molarFraction ] kw = { } kw [ <str> ] = unitMassFlow kw [ <str> ] = unitMolarFlow kw [ <str> ] = molarFlow kw [ <str> ] = massFlow kw [ <str> ] = molarFraction kw [ <str> ] = massFraction return kw  @ refDoc ( __doi__ , [ 18 , 2 ] ) def Vc_ChuehPrausnitz ( xi , Vci , Mi , hydrocarbon = None ) :      <str> if hydrocarbon is None :          hydrocarbon = [ True ] * len ( xi )  Vci = [ Vc * M for Vc , M in zip ( Vci , Mi ) ] Mm = sum ( [ M * x for M , x in zip ( Mi , xi ) ] ) Vij = [ ] for Vc_i , C_i in zip ( Vci , hydrocarbon ) :          Viji = [ ] for Vc_j , C_j in zip ( Vci , hydrocarbon ) :              if C_i and C_j :                  C = 0  else :                  C = 0.1559  mu = abs ( ( Vc_i - Vc_j ) / ( Vc_i + Vc_j ) ) Viji . append ( - 1.4684 * mu + C )  Vij . append ( Viji )  nuij = [ ] for Viji , Vc_i in zip ( Vij , Vci ) :          nuiji = [ ] for V , Vc_j in zip ( Viji , Vci ) :              nuiji . append ( V * ( Vc_i + Vc_j ) / 2 )  nuij . append ( nuiji )  phii = [ ] for x_j , Vc_j in zip ( xi , Vci ) :          suma = sum ( [ x_i * Vc_i ** ( 2 / 3 ) for x_i , Vc_i in zip ( xi , Vci ) ] ) phii . append ( x_j * Vc_j ** ( 2 / 3 ) / suma )  sum1 = sum ( [ phi * Vc for phi , Vc in zip ( phii , Vci ) ] ) sum2 = 0 for phi_i , nuiji in zip ( phii , nuij ) :          for phi_j , nu in zip ( phii , nuiji ) :              sum2 += phi_i * phi_j * nu   Vcm = sum1 + sum2 return unidades . SpecificVolume ( Vcm / Mm )  @ refDoc ( __doi__ , [ 9 , 2 , 3 ] ) def RhoL_RackettMix ( T , xi , Tci , Pci , Vci , Zrai , Mi ) :      <str> Vci = [ Vc * M for Vc , M in zip ( Vci , Mi ) ] Zram = 0 for x , Zra in zip ( xi , Zrai ) :          Zram += x * Zra  suma = 0 for x , Vc in zip ( xi , Vci ) :          suma += x * Vc  phi = [ ] for x , Vc in zip ( xi , Vci ) :          phi . append ( x * Vc / suma )  kij = [ ] for Vc_i in Vci :          kiji = [ ] for Vc_j in Vci :              kiji . append ( 1 - 8 * ( ( Vc_i ** ( 1 / 3 ) * Vc_j ** ( 1 / 3 ) ) ** 0.5 / ( Vc_i ** ( 1 / 3 ) + Vc_j ** ( 1 / 3 ) ) ) ** 3 )  kij . append ( kiji )  Tcij = [ ] for Tc_i , kiji in zip ( Tci , kij ) :          Tciji = [ ] for Tc_j , k in zip ( Tci , kiji ) :              Tciji . append ( ( Tc_i * Tc_j ) ** 0.5 * ( 1 - k ) )  Tcij . append ( Tciji )  Tcm = 0 for phi_i , Tciji in zip ( phi , Tcij ) :          for phi_j , Tc in zip ( phi , Tciji ) :              Tcm += phi_i * phi_j * Tc   suma = 0 for x , Tc , Pc in zip ( xi , Tci , Pci ) :          suma += x * Tc / Pc * 101325  Tr = T / Tcm V = R_atml * suma * Zram ** ( 1 + ( 1 - Tr ) ** ( 2 / 7 ) ) Mm = sum ( [ M * x for M , x in zip ( Mi , xi ) ] ) return unidades . Density ( Mm / V )  @ refDoc ( __doi__ , [ 10 , 2 , 3 ] ) def RhoL_CostaldMix ( T , xi , Tci , wi , Vci , Mi ) :      <str> Vci = [ Vc * M for Vc , M in zip ( Vci , Mi ) ] wm = 0 for x , w in zip ( xi , wi ) :          wm += x * w  sum1 = 0 sum2 = 0 sum3 = 0 for x , Vc , Tc in zip ( xi , Vci , Tci ) :          sum1 += x * Vc sum2 += x * Vc ** ( 2 / 3 ) sum3 += x * Vc ** ( 1 / 3 )  Vcm = ( sum1 + 3 * sum2 * sum3 ) / 4 Tcm = 0 for x_i , Vc_i , Tc_i in zip ( xi , Vci , Tci ) :          for x_j , Vc_j , Tc_j in zip ( xi , Vci , Tci ) :              Tcm += x_i * x_j * ( Vc_i * Tc_i * Vc_j * Tc_j ) ** 0.5   Tcm /= Vcm Mm = sum ( [ M * x for M , x in zip ( Mi , xi ) ] ) rho = RhoL_Costald ( T , Tcm , wm , Vcm ) return unidades . Density ( rho * Mm )  @ refDoc ( __doi__ , [ 11 , 3 ] ) def RhoL_AaltoKeskinenMix ( T , P , xi , Tci , Pci , Vci , wi , Mi , rhos ) :      <str> Vci = [ Vc * M for Vc , M in zip ( Vci , Mi ) ] wm = 0 for x , w in zip ( xi , wi ) :          wm += x * w ** 0.5  wm *= wm sum1 = 0 sum2 = 0 sum3 = 0 for x , Vc , Tc in zip ( xi , Vci , Tci ) :          sum1 += x * Vc sum2 += x * Vc ** ( 2 / 3 ) sum3 += x * Vc ** ( 1 / 3 )  Vcm = ( sum1 + 3 * sum2 * sum3 ) / 4 Tcm = 0 for x_i , Vc_i , Tc_i in zip ( xi , Vci , Tci ) :          for x_j , Vc_j , Tc_j in zip ( xi , Vci , Tci ) :              Tcm += x_i * x_j * ( Vc_i * Tc_i * Vc_j * Tc_j ) ** 0.5   Tcm /= Vcm Pcm = ( 0.291 - 0.08 * wm ) * R * Tcm / Vcm * 1000 Ps = _Pv ( T , Tcm , Pcm , wm ) rho = RhoL_AaltoKeskinen ( T , P , Tcm , Pcm , wm , Ps , rhos ) return unidades . Density ( rho )  @ refDoc ( __doi__ , [ 12 , 2 ] ) def RhoL_TaitCostaldMix ( T , P , xi , Tci , Vci , wi , Mi , rhos ) :      <str> Vci = [ Vc * M for Vc , M in zip ( Vci , Mi ) ] wm = 0 for x , w in zip ( xi , wi ) :          wm += x * w  sum1 = 0 sum2 = 0 sum3 = 0 for x , Vc , Tc in zip ( xi , Vci , Tci ) :          sum1 += x * Vc sum2 += x * Vc ** ( 2 / 3 ) sum3 += x * Vc ** ( 1 / 3 )  Vcm = ( sum1 + 3 * sum2 * sum3 ) / 4 Tcm = 0 for x_i , Vc_i , Tc_i in zip ( xi , Vci , Tci ) :          for x_j , Vc_j , Tc_j in zip ( xi , Vci , Tci ) :              Tcm += x_i * x_j * ( Vc_i * Tc_i * Vc_j * Tc_j ) ** 0.5   Tcm /= Vcm Pcm = ( 0.291 - 0.08 * wm ) * R * Tcm / Vcm * 1000 Ps = _Pv ( T , Tcm , Pcm , wm ) rho = RhoL_TaitCostald ( T , P , Tcm , Pcm , wm , Ps , rhos ) return unidades . Density ( rho )  @ refDoc ( __doi__ , [ 13 ] ) def RhoL_NasrifarMix ( T , P , xi , Tci , Vci , wi , Mi , rhos ) :      <str> Vci = [ Vc * M for Vc , M in zip ( Vci , Mi ) ] wm = 0 for x , w in zip ( xi , wi ) :          wm += x * w  sum1 = 0 sum2 = 0 sum3 = 0 for x , Vc , Tc in zip ( xi , Vci , Tci ) :          sum1 += x * Vc sum2 += x * Vc ** ( 2 / 3 ) sum3 += x * Vc ** ( 1 / 3 )  Vcm = ( sum1 + 3 * sum2 * sum3 ) / 4 Tcm = 0 for x_i , Vc_i , Tc_i in zip ( xi , Vci , Tci ) :          for x_j , Vc_j , Tc_j in zip ( xi , Vci , Tci ) :              Tcm += x_i * x_j * ( Vc_i * Tc_i * Vc_j * Tc_j ) ** 0.5   Tcm /= Vcm Mm = 0 for x , M in zip ( xi , Mi ) :          Mm += x * M  Pcm = ( 0.291 - 0.08 * wm ) * R * Tcm / Vcm * 1000 Ps = _Pv ( T , Tcm , Pcm , wm ) rho = RhoL_Nasrifar ( T , P , Tcm , Pcm , wm , Mm , Ps , rhos ) return unidades . Density ( rho )  @ refDoc ( __doi__ , [ 14 , 2 ] ) def RhoL_APIMix ( T , P , xi , Tci , Pci , rhos , To = None , Po = None ) :      <str> if To is None :          To = T  if Po is None :          Po = 101325  Tc = 0 Pc = 0 for x , Tc_i , Pc_i in zip ( xi , Tci , Pci ) :          Tc += x * Tc_i Pc += x * Pc_i  def C ( Tr , Pr ) :          A0 = 1.6368 - 0.04615 * Pr + 2.1138e-3 * Pr ** 2 - 0.7845e-5 * Pr ** 3 - 0.6923e-6 * Pr ** 4 A1 = - 1.9693 + 0.21874 * Pr - 8.0028e-3 * Pr ** 2 - 8.2328e-5 * Pr ** 3 + 5.2604e-6 * Pr ** 4 A2 = 2.4638 - .36461 * Pr + 12.8763e-3 * Pr ** 2 + 14.8059e-5 * Pr ** 3 - 8.6895e-6 * Pr ** 4 A3 = - 1.5841 + .25136 * Pr - 11.3805e-3 * Pr ** 2 + 9.5672e-5 * Pr ** 3 + 2.1812e-6 * Pr ** 4 C = A0 + A1 * Tr + A2 * Tr ** 2 + A3 * Tr ** 3 return C  C1 = C ( To / Tc , Po / Pc ) C2 = C ( T / Tc , P / Pc ) d2 = rhos * C2 / C1 return unidades . Density ( d2 )  @ refDoc ( __doi__ , [ 11 , 12 ] ) def _Pv ( T , Tcm , Pcm , wm ) :      Trm = T / Tcm alpha = 35 - 36 / Trm - 96.736 * log10 ( Trm ) + Trm ** 6 beta = log10 ( Trm ) + 0.03721754 * alpha Pro = 5.8031817 * log10 ( Trm ) + 0.07608141 * alpha Pr1 = 4.86601 * beta + 0.03721754 * alpha Pbp = Pcm * 10 ** ( Pro + wm * Pr1 ) return unidades . Pressure ( Pbp )  @ refDoc ( __doi__ , [ 20 , 2 , 3 ] ) def MuL_KendallMonroe ( xi , mui ) :      <str> mum = 0 for x , mu in zip ( xi , mui ) :          mum += x * mu ** ( 1 / 3 )  return unidades . Viscosity ( mum ** 3 )  def MuL_Chemcad ( xi , Mi , mui ) :      <str> Mm = sum ( [ M * x for M , x in zip ( Mi , xi ) ] ) if max ( Mi ) > 2000 :          A = 0 for x , M , mu in zip ( xi , Mi , mui ) :              A += x * M / Mm * log ( mu )   else :          A = 0 for x , mu in zip ( xi , mui ) :              A += x * log ( mu )   return unidades . Viscosity ( exp ( A ) )  @ refDoc ( __doi__ , [ 3 ] ) def MuG_Reichenberg ( T , xi , Tci , Pci , Mi , mui , Di ) :      <str> Tri = [ T / Tc for Tc in Tci ] Trij = [ ] for Tc_i in Tci :          Triji = [ ] for Tc_j in Tci :              Triji . append ( T / ( Tc_i * Tc_j ) ** 0.5 )  Trij . append ( Triji )  muri = [ 52.46 * D ** 2 * Pc * 1e-5 / Tc ** 2 for D , Pc , Tc in zip ( Di , Pci , Tci ) ] murij = [ ] for mur_i in muri :          muriji = [ ] for mur_j in muri :              muriji . append ( ( mur_i * mur_j ) ** 0.5 )  murij . append ( muriji )  Fri = [ ] for Tr , mur in zip ( Tri , muri ) :          Fri . append ( ( Tr ** 3.5 + ( 10 * mur ) ** 7 ) / Tr ** 3.5 / ( 1 + ( 10 * mur ) ** 7 ) )  Frij = [ ] for Triji , muriji in zip ( Trij , murij ) :          Friji = [ ] for Tr , mur in zip ( Triji , muriji ) :              Friji . append ( ( Tr ** 3.5 + ( 10 * mur ) ** 7 ) / Tr ** 3.5 / ( 1 + ( 10 * mur ) ** 7 ) )  Frij . append ( Friji )  Ui = [ ] for Tr , Fr in zip ( Tri , Fri ) :          Ui . append ( ( 1 + 0.36 * Tr * ( Tr - 1 ) ) ** ( 1 / 6 ) * Fr / Tr ** 0.5 )  Ci = [ M ** 0.25 / ( mu * U ) ** 0.5 for M , mu , U in zip ( Mi , mui , Ui ) ] Hij = [ ] for M_i , C_i , Triji , Friji in zip ( Mi , Ci , Trij , Frij ) :          Hiji = [ ] for M_j , C_j , Tr , Fr in zip ( Mi , Ci , Triji , Friji ) :              Hiji . append ( ( M_i * M_j / 32 / ( M_i + M_j ) ** 3 ) ** 0.5 * ( C_i + C_j ) ** 2 * ( 1 + 0.36 * Tr * ( Tr - 1 ) ) ** ( 1 / 6 ) * Fr / Tr ** 0.5 )  Hij . append ( Hiji )  sumai = [ ] for i , M_i in enumerate ( Mi ) :          sumaij = 0 for j , M_j in enumerate ( Mi ) :              if i != j :                  sumaij += xi [ j ] * Hij [ i ] [ j ] * ( 3 + 2 * M_j / M_i )   sumai . append ( sumaij )  Ki = [ x * mu / ( x + mu * suma ) for x , mu , suma in zip ( xi , mui , sumai ) ] mu = 0 for i , K_i in enumerate ( Ki ) :          sum1 = 0 for H , K_j in zip ( Hij [ i ] , Ki [ : i ] ) :              sum1 += H * K_j  sum2 = 0 for j , K_j in enumerate ( Ki ) :              for k , K_k in enumerate ( Ki ) :                  if j != i and k != i :                      sum2 += Hij [ i ] [ j ] * Hij [ i ] [ k ] * K_j * K_k    mu += K_i * ( 1 + 2 * sum1 + sum2 )  return unidades . Viscosity ( mu )  @ refDoc ( __doi__ , [ 1 , 2 , 3 ] ) def MuG_Wilke ( xi , Mi , mui ) :      <str> kij = [ ] for i , mi in enumerate ( Mi ) :          kiji = [ ] for j , mj in enumerate ( Mi ) :              if i == j :                  kiji . append ( 0 )  else :                  kiji . append ( ( 1 + ( mui [ i ] / mui [ j ] ) ** 0.5 * ( mj / mi ) ** 0.25 ) ** 2 / 8 ** 0.5 / ( 1 + mi / mj ) ** 0.5 )   kij . append ( kiji )  suma = [ ] for i , Xi in enumerate ( xi ) :          sumai = 0 if Xi != 0 :              for j , Xj in enumerate ( xi ) :                  sumai += kij [ i ] [ j ] * Xj / Xi   suma . append ( sumai )  mu = 0 for mu_i , sumai in zip ( mui , suma ) :          mu += mu_i / ( 1 + sumai )  return unidades . Viscosity ( mu )  @ refDoc ( __doi__ , [ 3 ] ) def MuG_Herning ( xi , Mi , mui ) :      <str> kij = [ ] for i , mi in enumerate ( Mi ) :          kiji = [ ] for j , mj in enumerate ( Mi ) :              if i == j :                  kiji . append ( 0 )  else :                  kiji . append ( ( mj / mi ) ** 0.5 )   kij . append ( kiji )  suma = [ ] for i , Xi in enumerate ( xi ) :          sumai = 0 if Xi != 0 :              for j , Xj in enumerate ( xi ) :                  sumai += kij [ i ] [ j ] * Xj / Xi   suma . append ( sumai )  mu = 0 for mu_i , sumai in zip ( mui , suma ) :          mu += mu_i / ( 1 + sumai )  return unidades . Viscosity ( mu )  @ refDoc ( __doi__ , [ 3 ] ) def MuG_Lucas ( T , P , xi , Tci , Pci , Vci , Zci , Mi , Di ) :      <str> Vci = [ Vc * M * 1000 for Vc , M in zip ( Vci , Mi ) ] Tcm = sum ( [ x * Tc for x , Tc in zip ( xi , Tci ) ] ) Zcm = sum ( [ x * Zc for x , Zc in zip ( xi , Zci ) ] ) Vcm = sum ( [ x * Vc for x , Vc in zip ( xi , Vci ) ] ) Mm = sum ( [ x * M for x , M in zip ( xi , Mi ) ] ) Pcm = R * Tcm * Zcm / Vcm * 1e6 Trm = T / Tcm Prm = P / Pcm Pcm_bar = Pcm * 1e-5 X = 0.176 * Tcm ** ( 1 / 6 ) / Mm ** 0.5 / Pcm_bar ** ( 2 / 3 ) Fpoi = [ ] Fqoi = [ ] for Tc , Pc , Zc , M , D in zip ( Tci , Pci , Zci , Mi , Di ) :          Tr = T / Tc Pc_bar = Pc * 1e-5 mur = 52.46 * D ** 2 * Pc_bar / Tc ** 2 if mur < 0.022 :              Fpoi . append ( 1 )  elif mur < 0.075 :              Fpoi . append ( 1 + 30.55 * ( 0.292 - Zc ) ** 1.72 )  else :              Fpoi . append ( 1 + 30.55 * ( 0.292 - Zc ) ** 1.72 * abs ( 0.96 + 0.1 * ( Tr - 0.7 ) ) )  if Tr < 12 :              sign = - 1  else :              sign = 1  if M == 2.0158 :              Q = 0.76 Fqoi . append ( 1.22 * Q ** 0.15 * ( 1 + 0.00385 * ( ( Tr - 12 ) ** 2 ) ** ( 1 / M ) * sign ) )  elif M == 4.0026 :              Q = 1.38 Fqoi . append ( 1.22 * Q ** 0.15 * ( 1 + 0.00385 * ( ( Tr - 12 ) ** 2 ) ** ( 1 / M ) * sign ) )  else :              Fqoi . append ( 1 )   Fpom = sum ( [ x * Fpo for x , Fpo in zip ( xi , Fpoi ) ] ) Fqom = sum ( [ x * Fqo for x , Fqo in zip ( xi , Fqoi ) ] ) Mh = max ( Mi ) Ml = min ( Mi ) xh = xi [ Mi . index ( Mh ) ] if Mh / Ml > 9 and 0.05 < xh < 0.7 :          A = 1 - 0.01 * ( Mh / Ml ) ** 0.87  else :          A = 1  Fqom *= A Z1 = Fpom * Fqom * ( 0.807 * Trm ** 0.618 - 0.357 * exp ( - 0.449 * Trm ) + 0.34 * exp ( - 4.058 * Trm ) + 0.018 ) if Prm < 0.6 :          mu = Z1 / X  else :          if Trm <= 1 :              alfa = 3.262 + 14.98 * Prm ** 5.508 beta = 1.39 + 14.98 * Prm Z2 = 0.6 + 0.76 * Prm ** alfa + ( 6.99 * Prm ** beta - 0.6 ) * ( 1 - Trm )  else :              a = 1.245e-3 / Trm * exp ( 5.1726 * Trm ** - 0.3286 ) b = a * ( 1.6553 * Trm - 1.2723 ) c = 0.4489 / Trm * exp ( 3.0578 * Trm ** - 37.7332 ) d = 1.7368 / Trm * exp ( 2.231 * Trm ** - 7.6351 ) e = 1.3088 f = 0.9425 * exp ( - 0.1853 * Trm ** 0.4489 ) Z2 = Z1 * ( 1 + a * Prm ** e / ( b * Prm ** f + 1 / ( 1 + c * Prm ** d ) ) )  Y = Z2 / Z1 Fp = ( 1 + ( Fpom - 1 ) / Y ** 3 ) / Fpom Fq = ( 1 + ( Fqom - 1 ) * ( 1 / Y - 0.007 * log ( Y ) ** 4 ) ) / Fqom mu = Z2 * Fp * Fq / X  return unidades . Viscosity ( mu , <str> )  @ refDoc ( __doi__ , [ 15 , 3 ] ) def MuG_Chung ( T , xi , Tci , Vci , Mi , wi , Di , ki ) :      <str> Vci = [ Vc * M * 1000 for Vc , M in zip ( Vci , Mi ) ] sigmai = [ 0.809 * Vc ** ( 1 / 3 ) for Vc in Vci ] eki = [ Tc / 1.2593 for Tc in Tci ] sigmaij = [ ] for s_i in sigmai :          sigmaiji = [ ] for s_j in sigmai :              sigmaiji . append ( ( s_i * s_j ) ** 0.5 )  sigmaij . append ( sigmaiji )  ekij = [ ] for ek_i in eki :          ekiji = [ ] for ek_j in eki :              ekiji . append ( ( ek_i * ek_j ) ** 0.5 )  ekij . append ( ekiji )  wij = [ ] for w_i in wi :          wiji = [ ] for w_j in wi :              wiji . append ( ( w_i + w_j ) / 2 )  wij . append ( wiji )  Mij = [ ] for M_i in Mi :          Miji = [ ] for M_j in Mi :              Miji . append ( 2 * M_i * M_j / ( M_i + M_j ) )  Mij . append ( Miji )  kij = [ ] for k_i in ki :          kiji = [ ] for k_j in ki :              kiji . append ( ( k_i * k_j ) ** 0.5 )  kij . append ( kiji )  sm = 0 for x_i , sigmaiji in zip ( xi , sigmaij ) :          for x_j , sij in zip ( xi , sigmaiji ) :              sm += x_i * x_j * sij ** 3   sm = sm ** ( 1 / 3 ) ekm = 0 for x_i , sigmaiji , ekiji in zip ( xi , sigmaij , ekij ) :          for x_j , sij , ek in zip ( xi , sigmaiji , ekiji ) :              ekm += x_i * x_j * ek * sij ** 3   ekm /= sm ** 3 wm = 0 for x_i , sigmaiji , wiji in zip ( xi , sigmaij , wij ) :          for x_j , sij , w in zip ( xi , sigmaiji , wiji ) :              wm += x_i * x_j * w * sij ** 3   wm /= sm ** 3 Mm = 0 for x_i , sigmaiji , ekiji , Miji in zip ( xi , sigmaij , ekij , Mij ) :          for x_j , s , ek , M in zip ( xi , sigmaiji , ekiji , Miji ) :              Mm += x_i * x_j * ek * s ** 2 * M ** 0.5   Mm = ( Mm / ( ekm * sm ** 2 ) ) ** 2 Dm = 0 for x_i , sigmaiji , ekiji , D_i in zip ( xi , sigmaij , ekij , Di ) :          for x_j , s , ek , D_j in zip ( xi , sigmaiji , ekiji , Di ) :              Dm += x_i * x_j * ( D_i * D_j ) ** 2 / ek / s ** 3   Dm = ( Dm * ekm * sm ** 3 ) ** 0.25 km = 0 for x_i , kiji in zip ( xi , kij ) :          for x_j , k in zip ( xi , kiji ) :              km += x_i * x_j * k   Vcm = ( sm / 0.809 ) ** 3 Tcm = 1.2593 * ekm murm = 131.3 * Dm / ( Vcm * Tcm ) ** 0.5 T_ = T / ekm omega = Collision_Neufeld ( T_ ) Fcm = 1 - 0.2756 * wm + 0.059035 * murm ** 4 + km mu = 40.785 * Fcm * Mm ** 0.5 * T ** 0.5 / Vcm ** ( 2 / 3 ) / omega return unidades . Viscosity ( mu , <str> )  @ refDoc ( __doi__ , [ 15 , 1 ] ) def MuG_P_Chung ( T , xi , Tci , Vci , Mi , wi , Di , ki , rho , muo ) :      <str> Vci = [ Vc * M * 1000 for Vc , M in zip ( Vci , Mi ) ] sigmai = [ 0.809 * Vc ** ( 1 / 3 ) for Vc in Vci ] eki = [ Tc / 1.2593 for Tc in Tci ] sigmaij = [ ] for s_i in sigmai :          sigmaiji = [ ] for s_j in sigmai :              sigmaiji . append ( ( s_i * s_j ) ** 0.5 )  sigmaij . append ( sigmaiji )  ekij = [ ] for ek_i in eki :          ekiji = [ ] for ek_j in eki :              ekiji . append ( ( ek_i * ek_j ) ** 0.5 )  ekij . append ( ekiji )  wij = [ ] for w_i in wi :          wiji = [ ] for w_j in wi :              wiji . append ( ( w_i + w_j ) / 2 )  wij . append ( wiji )  Mij = [ ] for M_i in Mi :          Miji = [ ] for M_j in Mi :              Miji . append ( 2 * M_i * M_j / ( M_i + M_j ) )  Mij . append ( Miji )  kij = [ ] for k_i in ki :          kiji = [ ] for k_j in ki :              kiji . append ( ( k_i * k_j ) ** 0.5 )  kij . append ( kiji )  sm = 0 for x_i , sigmaiji in zip ( xi , sigmaij ) :          for x_j , sij in zip ( xi , sigmaiji ) :              sm += x_i * x_j * sij ** 3   sm = sm ** ( 1 / 3 ) ekm = 0 for x_i , sigmaiji , ekiji in zip ( xi , sigmaij , ekij ) :          for x_j , sij , ek in zip ( xi , sigmaiji , ekiji ) :              ekm += x_i * x_j * ek * sij ** 3   ekm /= sm ** 3 wm = 0 for x_i , sigmaiji , wiji in zip ( xi , sigmaij , wij ) :          for x_j , sij , w in zip ( xi , sigmaiji , wiji ) :              wm += x_i * x_j * w * sij ** 3   wm /= sm ** 3 Mm = 0 for x_i , sigmaiji , ekiji , Miji in zip ( xi , sigmaij , ekij , Mij ) :          for x_j , s , ek , M in zip ( xi , sigmaiji , ekiji , Miji ) :              Mm += x_i * x_j * ek * s ** 2 * M ** 0.5   Mm = ( Mm / ( ekm * sm ** 2 ) ) ** 2 Dm = 0 for x_i , sigmaiji , ekiji , D_i in zip ( xi , sigmaij , ekij , Di ) :          for x_j , s , ek , D_j in zip ( xi , sigmaiji , ekiji , Di ) :              Dm += x_i * x_j * ( D_i * D_j ) ** 2 / ek / s ** 3   Dm = ( Dm * ekm * sm ** 3 ) ** 0.25 km = 0 for x_i , kiji in zip ( xi , kij ) :          for x_j , k in zip ( xi , kiji ) :              km += x_i * x_j * k   rho = rho / Mm / 1000 Vcm = ( sm / 0.809 ) ** 3 Tcm = 1.2593 * ekm murm = 131.3 * Dm / ( Vcm * Tcm ) ** 0.5 T_ = T / ekm dat = [ ( 6.32402 , 50.4119 , - 51.6801 , 1189.02 ) , ( 0.12102e-2 , - 0.11536e-2 , - 0.62571e-2 , 0.37283e-1 ) , ( 5.28346 , 254.209 , - 168.481 , 3898.27 ) , ( 6.62263 , 38.09570 , - 8.46414 , 31.4178 ) , ( 19.74540 , 7.63034 , - 14.35440 , 31.5267 ) , ( - 1.89992 , - 12.53670 , 4.98529 , - 18.1507 ) , ( 24.27450 , 3.44945 , - 11.29130 , 69.3466 ) , ( 0.79716 , 1.11764 , 0.12348e-1 , - 4.11661 ) , ( - 0.23816 , 0.67695e-1 , - 0.81630 , 4.02528 ) , ( 0.68629e-1 , 0.34793 , 0.59256 , - 0.72663 ) ] A = [ ] for ao , a1 , a2 , a3 in dat :          A . append ( ao + a1 * wm + a2 * murm ** 4 + a3 * km )  A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 = A Y = rho * Vcm / 6 G1 = ( 1 - 0.5 * Y ) / ( 1 - Y ) ** 3 G2 = ( A1 * ( ( 1 - exp ( - A4 * Y ) ) / Y ) + A2 * G1 * exp ( A5 * Y ) + A3 * G1 ) / ( A1 * A4 + A2 + A3 ) muk = muo * ( 1 / G2 + A6 * Y ) mup = ( 36.344e-6 * ( Mm * Tcm ) ** 0.5 / Vcm ** ( 2 / 3 ) ) * A7 * Y ** 2 * G2 * exp ( A8 + A9 / T_ + A10 / T_ ** 2 ) return unidades . Viscosity ( muk + mup , <str> )  @ refDoc ( __doi__ , [ 1 , 21 , 16 , 17 ] ) def MuG_TRAPP ( T , P , xi , Tci , Vci , Zci , Mi , wi , rho , muo ) :      <str> TcR = 369.83 rhocR = 1 / 200 ZcR = 0.276 wR = 0.152 Vci = [ Vc * M * 1000 for Vc , M in zip ( Vci , Mi ) ] Mm = sum ( [ x * M for x , M in zip ( xi , Mi ) ] ) rho = rho / Mm fi = [ ] hi = [ ] for Tc , Vc , Zc , w in zip ( Tci , Vci , Zci , wi ) :          fi . append ( Tc / TcR * ( 1 + ( w - wR ) * ( 0.05203 - 0.7498 * log ( T / Tc ) ) ) ) hi . append ( rhocR * Vc * ZcR / Zc * ( 1 - ( w - wR ) * ( 0.1436 - 0.2822 * log ( T / Tc ) ) ) )  fij = [ ] for f_i in fi :          fiji = [ ] for f_j in fi :              fiji . append ( ( f_i * f_j ) ** 0.5 )  fij . append ( fiji )  hij = [ ] for h_i in hi :          hiji = [ ] for h_j in hi :              hiji . append ( ( h_i ** ( 1 / 3 ) + h_j ** ( 1 / 3 ) ) ** 3 / 8 )  hij . append ( hiji )  hm = 0 for x_i , hiji in zip ( xi , hij ) :          for x_j , h in zip ( xi , hiji ) :              hm += x_i * x_j * h   fm = 0 for x_i , hiji , fiji in zip ( xi , hij , fij ) :          for x_j , h , f in zip ( xi , hiji , fiji ) :              fm += x_i * x_j * f * h / hm   Mij = [ ] for M_i in Mi :          Miji = [ ] for M_j in Mi :              Miji . append ( 2 * M_i * M_j / ( M_i + M_j ) )  Mij . append ( Miji )  To = T / fm rho0 = rho / 1000 * hm suma = 0 for x_i , fiji , Miji , hiji in zip ( xi , fij , Mij , hij ) :          for x_j , f , M , h in zip ( xi , fiji , Miji , hiji ) :              suma += x_i * x_j * ( f * M ) ** 0.5 * h ** ( 4 / 3 )   Fnm = 44.094 ** - 0.5 / hm ** 2 * suma rho0 *= 1000 rhocR *= 1000 G = - 14.113294896 + 968.22940153 / To H = rho0 ** 0.5 * ( rho0 - rhocR ) / rhocR G2 = 13.686545032 - 12511.628378 / To ** 1.5 G3 = 0.0168910864 + 43.527109444 / To + 7659.4543472 / To ** 2 F = G + G2 * rho0 ** 0.1 + G3 * H muR = exp ( F ) - exp ( G ) sigmai = [ 4.771 * h ** ( 1 / 3 ) for h in hi ] sigmaij = [ ] for s_i in sigmai :          sigmaiji = [ ] for s_j in sigmai :              sigmaiji . append ( ( s_i + s_j ) / 2 )  sigmaij . append ( sigmaiji )  X = 6.023e-4 * pi / 6 * rho * sum ( [ x * s ** 3 for x , s in zip ( xi , sigmai ) ] ) sum2 = sum ( [ x * s ** 2 for x , s in zip ( xi , sigmai ) ] ) sum3 = sum ( [ x * s ** 3 for x , s in zip ( xi , sigmai ) ] ) titaij = [ ] for s_i , siji in zip ( sigmai , sigmaij ) :          titaiji = [ ] for s_j , sij in zip ( sigmai , siji ) :              titaiji . append ( s_i * s_j / 2 / sij * sum2 / sum3 )  titaij . append ( titaiji )  gij = [ ] for titaiji in titaij :          giji = [ ] for tij in titaiji :              giji . append ( 1 / ( 1 - X ) + 3 * X / ( 1 - X ) ** 2 * tij + 2 * X ** 2 / ( 1 - X ) ** 3 * tij ** 2 )  gij . append ( giji )  muij = [ ] for miji , siji in zip ( Mij , sigmaij ) :          muiji = [ ] for m , s in zip ( miji , siji ) :              muiji . append ( 2.669 * ( m * T ) ** 0.5 / s ** 2 )  muij . append ( muiji )  Bij = [ ] for i , M_i in enumerate ( Mi ) :          Biji = [ ] for j , M_j in enumerate ( Mi ) :              B = 0 for k , M_k in enumerate ( Mi ) :                  if i == j :                      dij = 1  else :                      dij = 0  if j == k :                      djk = 1  else :                      djk = 0  B += xi [ i ] * xi [ k ] * gij [ i ] [ k ] / muij [ i ] [ k ] * ( M_k / ( M_i + M_k ) ) ** 2 * ( ( 1 + 5 / 3 * M_i / M_k ) * dij - 2 / 3 * M_i / M_k * djk )  B *= 2e-1 Biji . append ( B )  Bij . append ( Biji )  Yi = [ ] for x_i , M_i , siji , giji in zip ( xi , Mi , sigmaij , gij ) :          suma = 0 for x_j , M_j , s , g in zip ( xi , Mi , siji , giji ) :              suma += x_j * M_j / ( M_i + M_j ) * s ** 3 * g  Yi . append ( x_i * ( 1 + 8 * pi / 15 * 6.023e-4 * rho * suma ) )  betai = solve ( Bij , Yi ) sum1 = sum ( [ b * Y for b , Y in zip ( betai , Yi ) ] ) sum2 = 0 for x_i , siji , muiji , giji in zip ( xi , sigmaij , muij , gij ) :          for x_j , s , mu , g in zip ( xi , siji , muiji , giji ) :              sum2 += x_i * x_j * s ** 6 * mu * g   alfa = 48 / 25 / pi * ( 2 * pi / 3 * 6.023e-4 ) ** 2 eta_m = sum1 + alfa * 10 * rho ** 2 * sum2 sigmax = 0 for x_i , siji in zip ( xi , sigmaij ) :          for x_j , s in zip ( xi , siji ) :              sigmax += x_i * x_j * s ** 3   sigmax = sigmax ** ( 1 / 3 ) Mx = 0 for x_i , siji , Miji in zip ( xi , sigmaij , Mij ) :          for x_j , s , M in zip ( xi , siji , Miji ) :              Mx += x_i * x_j * M ** 0.5 * s ** 4   Mx = Mx ** 2 / sigmax ** 8 X = 6.023e-4 * pi / 6 * rho * sigmax ** 3 gxx = 1 / ( 1 - X ) + 3 * X / ( 1 - X ) ** 2 * 0.5 + 2 * X ** 2 / ( 1 - X ) ** 3 * 0.25 Yx = 1 + 8 * pi / 15 * 6.023e-4 * rho * sigmax ** 3 * gxx / 2 mux = 26.69 * ( Mx * T ) ** 0.5 / sigmax ** 2 Bxx = gxx / mux betax = Yx / Bxx eta_x = betax * Yx + alfa * rho ** 2 * sigmax ** 6 * mux * gxx Dmu = ( eta_m - eta_x ) * 0.1 return unidades . Viscosity ( Fnm * muR + Dmu + muo * 1e6 , <str> )  @ refDoc ( __doi__ , [ 19 , 2 ] ) def MuG_DeanStielMix ( xi , Tci , Pci , Mi , rhoc , rho , muo ) :      <str> Tpc = sum ( [ x * Tc for x , Tc in zip ( xi , Tci ) ] ) Ppc = sum ( [ x * Pc for x , Pc in zip ( xi , Pci ) ] ) M = sum ( [ x * M_i for x , M_i in zip ( xi , Mi ) ] ) return MuG_DeanStiel ( Tpc , Ppc , rhoc , M , rho , muo )  @ refDoc ( __doi__ , [ 2 ] ) def MuG_APIMix ( T , P , xi , Tci , Pci , muo ) :      <str> Tpc = sum ( [ x * Tc for x , Tc in zip ( xi , Tci ) ] ) Ppc = sum ( [ x * Pc for x , Pc in zip ( xi , Pci ) ] ) return MuG_API ( T , P , Tpc , Ppc , muo )  @ refDoc ( __doi__ , [ 4 , 2 ] ) def ThL_Li ( xi , Vi , Mi , ki ) :      <str> Vi = [ V * M * 1000 for V , M in zip ( Vi , Mi ) ] kij = [ ] for k_i in ki :          kiji = [ ] for k_j in ki :              kiji . append ( 2 / ( 1 / k_i + 1 / k_j ) )  kij . append ( kiji )  suma = 0 for x , V in zip ( xi , Vi ) :          suma += x * V  phi = [ ] for x , V in zip ( xi , Vi ) :          phi . append ( x * V / suma )  k = 0 for phi_i , ki in zip ( phi , kij ) :          for phi_j , k_ij in zip ( phi , ki ) :              k += phi_i * phi_j * k_ij   return unidades . ThermalConductivity ( k )  @ refDoc ( __doi__ , [ 3 ] ) def ThL_Power ( wi , ki ) :      <str> km = 0 for w , k in zip ( wi , ki ) :          km += w / k ** 2  km = km ** - 0.5 return unidades . ThermalConductivity ( km )  @ refDoc ( __doi__ , [ 5 , 2 ] ) def ThG_LindsayBromley ( T , xi , Mi , Tbi , mui , ki ) :      <str> S = [ ] for Tb , M in zip ( Tbi , Mi ) :          if M == 2.0158 or M == 4.0026 :              S . append ( 79 )  else :              S . append ( 1.5 * Tb )   Sij = [ ] for Si in S :          Siji = [ ] for Sj in S :              Siji . append ( ( Si * Sj ) ** 0.5 )  Sij . append ( Siji )  Aij = [ ] for mu_i , M_i , Si , Siji in zip ( mui , Mi , S , Sij ) :          Aiji = [ ] for mu_j , M_j , Sj , S_ij in zip ( mui , Mi , S , Siji ) :              Aiji . append ( 0.25 * ( 1 + ( mu_i / mu_j * ( M_j / M_i ) ** 0.75 * ( 1 + Si / T ) / ( 1 + Sj / T ) ) ** 0.5 ) ** 2 * ( 1 + S_ij / T ) / ( 1 + Si / T ) )  Aij . append ( Aiji )  sumaj = [ ] for Aiji in Aij :          suma = 0 for xj , A_ij in zip ( xi , Aiji ) :              suma += A_ij * xj  sumaj . append ( suma )  k = 0 for x_i , k_i , si in zip ( xi , ki , sumaj ) :          k += k_i * x_i / si  return unidades . ThermalConductivity ( k )  @ refDoc ( __doi__ , [ 6 , 3 ] ) def ThG_MasonSaxena ( xi , Mi , mui , ki ) :      <str> Aij = [ ] for mu_i , M_i in zip ( mui , Mi ) :          Aiji = [ ] for mu_j , M_j in zip ( mui , Mi ) :              lt_ij = mu_i * M_j / mu_j / M_i Aiji . append ( ( 1 + lt_ij ** 0.5 * ( M_i / M_j ) ** 0.25 ) ** 2 / ( 8 * ( 1 + M_i / M_j ) ) ** 0.5 )  Aij . append ( Aiji )  sumaj = [ ] for Aiji in Aij :          suma = 0 for xj , A_ij in zip ( xi , Aiji ) :              suma += A_ij * xj  sumaj . append ( suma )  k = 0 for x_i , k_i , si in zip ( xi , ki , sumaj ) :          k += k_i * x_i / si  return unidades . ThermalConductivity ( k )  @ refDoc ( __doi__ , [ 15 , 1 ] ) def ThG_Chung ( T , xi , Tci , Vci , Mi , wi , Cvi , mu ) :      <str> Vci = [ Vc * M * 1000 for Vc , M in zip ( Vci , Mi ) ] Cvi = [ Cv * M / 1000 for Cv , M in zip ( Cvi , Mi ) ] Cvm = sum ( [ x * Cv for x , Cv in zip ( xi , Cvi ) ] ) sigmai = [ 0.809 * Vc ** ( 1 / 3 ) for Vc in Vci ] eki = [ Tc / 1.2593 for Tc in Tci ] sigmaij = [ ] for s_i in sigmai :          sigmaiji = [ ] for s_j in sigmai :              sigmaiji . append ( ( s_i * s_j ) ** 0.5 )  sigmaij . append ( sigmaiji )  ekij = [ ] for ek_i in eki :          ekiji = [ ] for ek_j in eki :              ekiji . append ( ( ek_i * ek_j ) ** 0.5 )  ekij . append ( ekiji )  wij = [ ] for w_i in wi :          wiji = [ ] for w_j in wi :              wiji . append ( ( w_i + w_j ) / 2 )  wij . append ( wiji )  Mij = [ ] for M_i in Mi :          Miji = [ ] for M_j in Mi :              Miji . append ( 2 * M_i * M_j / ( M_i + M_j ) )  Mij . append ( Miji )  sm = 0 for x_i , sigmaiji in zip ( xi , sigmaij ) :          for x_j , sij in zip ( xi , sigmaiji ) :              sm += x_i * x_j * sij ** 3   sm = sm ** ( 1 / 3 ) ekm = 0 for x_i , sigmaiji , ekiji in zip ( xi , sigmaij , ekij ) :          for x_j , sij , ek in zip ( xi , sigmaiji , ekiji ) :              ekm += x_i * x_j * ek * sij ** 3   ekm /= sm ** 3 wm = 0 for x_i , sigmaiji , wiji in zip ( xi , sigmaij , wij ) :          for x_j , sij , w in zip ( xi , sigmaiji , wiji ) :              wm += x_i * x_j * w * sij ** 3   wm /= sm ** 3 Mm = 0 for x_i , sigmaiji , ekiji , Miji in zip ( xi , sigmaij , ekij , Mij ) :          for x_j , s , ek , M in zip ( xi , sigmaiji , ekiji , Miji ) :              Mm += x_i * x_j * ek * s ** 2 * M ** 0.5   Mm = ( Mm / ( ekm * sm ** 2 ) ) ** 2 Tcm = 1.2593 * ekm Trm = T / Tcm alpha = Cvm / R - 1.5 beta = 0.7862 - 0.7109 * wm + 1.3168 * wm ** 2 Z = 2 + 10.5 * Trm ** 2 phi = 1 + alpha * ( ( 0.215 + 0.28288 * alpha - 1.061 * beta + 0.26665 * Z ) / ( 0.6366 + beta * Z + 1.061 * alpha * beta ) ) k = 7.452 * mu * 10 / Mm * phi return unidades . ThermalConductivity ( k , <str> )  @ refDoc ( __doi__ , [ 15 , 1 ] ) def ThG_P_Chung ( T , xi , Tci , Vci , Mi , wi , Di , ki , rho , ko ) :      <str> ko = unidades . ThermalConductivity ( ko ) . calscmK Vci = [ Vc * M * 1000 for Vc , M in zip ( Vci , Mi ) ] sigmai = [ 0.809 * Vc ** ( 1 / 3 ) for Vc in Vci ] eki = [ Tc / 1.2593 for Tc in Tci ] sigmaij = [ ] for s_i in sigmai :          sigmaiji = [ ] for s_j in sigmai :              sigmaiji . append ( ( s_i * s_j ) ** 0.5 )  sigmaij . append ( sigmaiji )  ekij = [ ] for ek_i in eki :          ekiji = [ ] for ek_j in eki :              ekiji . append ( ( ek_i * ek_j ) ** 0.5 )  ekij . append ( ekiji )  wij = [ ] for w_i in wi :          wiji = [ ] for w_j in wi :              wiji . append ( ( w_i + w_j ) / 2 )  wij . append ( wiji )  Mij = [ ] for M_i in Mi :          Miji = [ ] for M_j in Mi :              Miji . append ( 2 * M_i * M_j / ( M_i + M_j ) )  Mij . append ( Miji )  kij = [ ] for k_i in ki :          kiji = [ ] for k_j in ki :              kiji . append ( ( k_i * k_j ) ** 0.5 )  kij . append ( kiji )  sm = 0 for x_i , sigmaiji in zip ( xi , sigmaij ) :          for x_j , sij in zip ( xi , sigmaiji ) :              sm += x_i * x_j * sij ** 3   sm = sm ** ( 1 / 3 ) ekm = 0 for x_i , sigmaiji , ekiji in zip ( xi , sigmaij , ekij ) :          for x_j , sij , ek in zip ( xi , sigmaiji , ekiji ) :              ekm += x_i * x_j * ek * sij ** 3   ekm /= sm ** 3 wm = 0 for x_i , sigmaiji , wiji in zip ( xi , sigmaij , wij ) :          for x_j , sij , w in zip ( xi , sigmaiji , wiji ) :              wm += x_i * x_j * w * sij ** 3   wm /= sm ** 3 Mm = 0 for x_i , sigmaiji , ekiji , Miji in zip ( xi , sigmaij , ekij , Mij ) :          for x_j , s , ek , M in zip ( xi , sigmaiji , ekiji , Miji ) :              Mm += x_i * x_j * ek * s ** 2 * M ** 0.5   Mm = ( Mm / ( ekm * sm ** 2 ) ) ** 2 Dm = 0 for x_i , sigmaiji , ekiji , D_i in zip ( xi , sigmaij , ekij , Di ) :          for x_j , s , ek , D_j in zip ( xi , sigmaiji , ekiji , Di ) :              Dm += x_i * x_j * ( D_i * D_j ) ** 2 / ek / s ** 3   Dm = ( Dm * ekm * sm ** 3 ) ** 0.25 km = 0 for x_i , kiji in zip ( xi , kij ) :          for x_j , k in zip ( xi , kiji ) :              km += x_i * x_j * k   rho = rho / Mm / 1000 Vcm = ( sm / 0.809 ) ** 3 Tcm = 1.2593 * ekm murm = 131.3 * Dm / ( Vcm * Tcm ) ** 0.5 T_ = T / ekm dat = [ ( 2.41657 , 0.74824 , - 0.91858 , 121.72100 ) , ( - 0.50924 , - 1.50936 , - 49.99120 , 69.98340 ) , ( 6.61069 , 5.62073 , 64.75990 , 27.03890 ) , ( 14.54250 , - 8.91387 , - 5.63794 , 74.34350 ) , ( 0.79274 , 0.82019 , - 0.69369 , 6.31734 ) , ( - 5.86340 , 12.80050 , 9.58926 , - 65.52920 ) , ( 81.17100 , 114.15800 , - 60.84100 , 466.77500 ) ] B = [ ] for bo , b1 , b2 , b3 in dat :          B . append ( bo + b1 * wm + b2 * murm ** 4 + b3 * km )  B1 , B2 , B3 , B4 , B5 , B6 , B7 = B Y = rho * Vcm / 6 G1 = ( 1 - 0.5 * Y ) / ( 1 - Y ) ** 3 H2 = ( B1 * ( ( 1 - exp ( - B4 * Y ) ) / Y ) + B2 * G1 * exp ( B5 * Y ) + B3 * G1 ) / ( B1 * B4 + B2 + B3 ) kk = ko * ( 1 / H2 + B6 * Y ) kp = ( 3.039e-4 * ( Tcm / Mm ) ** 0.5 / Vcm ** ( 2 / 3 ) ) * B7 * Y ** 2 * H2 * T_ ** 0.5 return unidades . ThermalConductivity ( kk + kp , <str> )  @ refDoc ( __doi__ , [ 7 , 3 ] ) def ThG_StielThodosYorizane ( T , xi , Tci , Pci , Vci , wi , Mi , V , ko ) :      <str> Vci = [ Vc * M * 1000 for Vc , M in zip ( Vci , Mi ) ] wm = sum ( [ x * w for x , w in zip ( xi , wi ) ] ) Mm = sum ( [ x * M for x , M in zip ( xi , Mi ) ] ) Zcm = 0.291 - 0.08 * wm Vcij = [ ] for Vc_i in Vci :          Vciji = [ ] for Vc_j in Vci :              Vciji . append ( ( Vc_i ** ( 1 / 3 ) + Vc_j ** ( 1 / 3 ) ) ** 3 / 8 )  Vcij . append ( Vciji )  Vcm = 0 for x_i , Vciji in zip ( xi , Vcij ) :          for x_j , Vc in zip ( xi , Vciji ) :              Vcm += x_i * x_j * Vc   Tcij = [ ] for Tc_i in Tci :          Tciji = [ ] for Tc_j in Tci :              Tciji . append ( ( Tc_i * Tc_j ) ** 0.5 )  Tcij . append ( Tciji )  Tcm = 0 for x_i , Vciji , Tciji in zip ( xi , Vcij , Tcij ) :          for x_j , Vc , Tc in zip ( xi , Vciji , Tciji ) :              Tcm += x_i * x_j * Vc * Tc / Vcm   Pcm = Zcm * R * Tcm / Vcm * 1e6 Vcm = Vcm / Mm / 1000 km = ThG_StielThodos ( T , Tcm , Pcm , Vcm , Mm , V , ko ) return unidades . ThermalConductivity ( km )  @ refDoc ( __doi__ , [ 1 , 21 ] ) def ThG_TRAPP ( T , xi , Tci , Vci , Zci , wi , Mi , rho , ko ) :      <str> TcR = 369.83 rhocR = 1 / 200 ZcR = 0.276 wR = 0.152 Vci = [ Vc * M * 1000 for Vc , M in zip ( Vci , Mi ) ] Mm = sum ( [ x * M for x , M in zip ( xi , Mi ) ] ) rho = rho / Mm / 1000 fi = [ ] hi = [ ] for Tc , Vc , Zc , w in zip ( Tci , Vci , Zci , wi ) :          fi . append ( Tc / TcR * ( 1 + ( w - wR ) * ( 0.05203 - 0.7498 * log ( T / Tc ) ) ) ) hi . append ( rhocR * Vc * ZcR / Zc * ( 1 - ( w - wR ) * ( 0.1436 - 0.2822 * log ( T / Tc ) ) ) )  fij = [ ] for f_i in fi :          fiji = [ ] for f_j in fi :              fiji . append ( ( f_i * f_j ) ** 0.5 )  fij . append ( fiji )  hij = [ ] for h_i in hi :          hiji = [ ] for h_j in hi :              hiji . append ( ( h_i ** ( 1 / 3 ) + h_j ** ( 1 / 3 ) ) ** 3 / 8 )  hij . append ( hiji )  hm = 0 for x_i , hiji in zip ( xi , hij ) :          for x_j , h in zip ( xi , hiji ) :              hm += x_i * x_j * h   fm = 0 for x_i , hiji , fiji in zip ( xi , hij , fij ) :          for x_j , h , f in zip ( xi , hiji , fiji ) :              fm += x_i * x_j * f * h / hm   To = T / fm rho0 = rho * hm Mij = [ ] for M_i in Mi :          Miji = [ ] for M_j in Mi :              Miji . append ( 1 / ( 1 / 2 / M_i + 1 / 2 / M_j ) )  Mij . append ( Miji )  suma = 0 for x_i , fiji , Miji , hiji in zip ( xi , fij , Mij , hij ) :          for x_j , f , M , h in zip ( xi , fiji , Miji , hiji ) :              suma += x_i * x_j * ( f / M ) ** 0.5 * h ** ( 4 / 3 )   Flm = 44.094 ** 0.5 / hm ** 2 * suma wm = sum ( [ x * w for x , w in zip ( xi , wi ) ] ) Xlm = ( 1 + 2.1866 * ( wm - wR ) / ( 1 - 0.505 * ( wm - wR ) ) ) ** 0.5 rho0 *= 1000 rhocR *= 1000 rhorR = rho0 / rhocR TrR = To / TcR lR = 15.2583985944 * rhorR + 5.29917319127 * rhorR ** 3 + ( - 3.05330414748 + 0.450477583739 / TrR ) * rhorR ** 4 + ( 1.03144050679 - 0.185480417707 / TrR ) * rhorR ** 5 return unidades . ThermalConductivity ( Flm * Xlm * lR * 1e-3 + ko )  @ refDoc ( __doi__ , [ 8 , 2 ] ) def Tension ( xi , sigmai ) :      <str> sigma = 0 for x , s in zip ( xi , sigmai ) :          sigma += x * s  return unidades . Tension ( sigma )  class Mezcla ( config . Entity ) :      kwargs = { <str> : 0.0 , <str> : 0.0 , <str> : [ ] , <str> : [ ] , <str> : [ ] , <str> : [ ] , <str> : None , <str> : None , <str> : None , <str> : None , <str> : None , <str> : None , <str> : None , <str> : None } METHODS_RhoL = [ <str> , <str> ] METHODS_RhoLP = [ <str> , <str> , <str> , <str> ] METHODS_MuG = [ <str> , <str> , <str> , <str> , <str> ] METHODS_MuGP = [ <str> , <str> , <str> , <str> , <str> ] METHODS_MuL = [ <str> , <str> ] METHODS_ThG = [ <str> , <str> , <str> ] METHODS_ThGP = [ <str> , <str> , <str> ] METHODS_ThL = [ <str> , <str> ] def __init__ ( self , tipo = 0 , ** kwargs ) :          if tipo == 0 :              self . _bool = False return  self . _bool = True self . kwargs = Mezcla . kwargs . copy ( ) self . kwargs . update ( kwargs ) self . Config = config . getMainWindowConfig ( ) if self . kwargs [ <str> ] :              self . ids = self . kwargs . get ( <str> )  else :              txt = self . Config . get ( <str> , <str> ) if isinstance ( txt , str ) :                  self . ids = eval ( txt )  else :                  self . ids = txt   self . componente = [ Componente ( int ( i ) , ** kwargs ) for i in self . ids ] fraccionMolar = self . kwargs . get ( <str> , None ) fraccionMasica = self . kwargs . get ( <str> , None ) caudalMasico = self . kwargs . get ( <str> , None ) caudalMolar = self . kwargs . get ( <str> , None ) caudalUnitarioMasico = self . kwargs . get ( <str> , None ) caudalUnitarioMolar = self . kwargs . get ( <str> , None ) if fraccionMolar :              suma = float ( sum ( fraccionMolar ) ) fraccionMolar = [ x / suma for x in fraccionMolar ]  if fraccionMasica :              suma = float ( sum ( fraccionMasica ) ) fraccionMasica = [ x / suma for x in fraccionMasica ]  if tipo == 1 :              kw = mix_unitmassflow ( caudalUnitarioMasico , self . componente )  elif tipo == 2 :              kw = mix_unitmolarflow ( caudalUnitarioMolar , self . componente )  elif tipo == 3 :              kw = mix_massflow_molarfraction ( caudalMasico , fraccionMolar , self . componente )  elif tipo == 4 :              kw = mix_massflow_massfraction ( caudalMasico , fraccionMasica , self . componente )  elif tipo == 5 :              kw = mix_molarflow_molarfraction ( caudalMolar , fraccionMolar , self . componente )  elif tipo == 6 :              kw = mix_molarflow_massfraction ( caudalMolar , fraccionMasica , self . componente )  caudalMolar = kw [ <str> ] caudalMasico = kw [ <str> ] caudalUnitarioMasico = kw [ <str> ] caudalUnitarioMolar = kw [ <str> ] fraccionMolar = kw [ <str> ] fraccionMasica = kw [ <str> ] self . fraccion = [ unidades . Dimensionless ( f ) for f in fraccionMolar ] self . caudalmasico = unidades . MassFlow ( caudalMasico ) self . caudalmolar = unidades . MolarFlow ( caudalMolar ) self . fraccion_masica = [ unidades . Dimensionless ( f ) for f in fraccionMasica ] self . caudalunitariomasico = [ unidades . MassFlow ( q ) for q in caudalUnitarioMasico ] self . caudalunitariomolar = [ unidades . MolarFlow ( q ) for q in caudalUnitarioMolar ] self . M = unidades . Dimensionless ( caudalMasico / caudalMolar ) if tipo == 0 :              self . _bool = False self . status = 0 return  else :              self . _bool = True self . status = 1  V = sum ( [ xi * cmp . Vc for xi , cmp in zip ( self . fraccion , self . componente ) ] ) k = [ xi * cmp . Vc / V for xi , cmp in zip ( self . fraccion , self . componente ) ] Tcm = sum ( [ ki * cmp . Tc for ki , cmp in zip ( k , self . componente ) ] ) self . Tc = unidades . Temperature ( Tcm ) t = sum ( [ xi * cmp . Tc for xi , cmp in zip ( self . fraccion , self . componente ) ] ) self . tpc = unidades . Temperature ( t ) p = sum ( [ xi * cmp . Pc for xi , cmp in zip ( self . fraccion , self . componente ) ] ) self . ppc = unidades . Pressure ( p ) sumaw = 0 for xi , cmp in zip ( self . fraccion , self . componente ) :              sumaw += xi * cmp . f_acent  pc = self . ppc + self . ppc * ( 5.808 + 4.93 * sumaw ) * ( self . Tc - self . tpc ) / self . tpc self . Pc = unidades . Pressure ( pc ) self . f_acent = sum ( [ xi * cmp . f_acent for xi , cmp in zip ( self . fraccion , self . componente ) ] ) self . f_acent_mod = sum ( [ xi * cmp . f_acent_mod for xi , cmp in zip ( self . fraccion , self . componente ) ] ) Vci = self . _arraylize ( <str> ) Mi = self . _arraylize ( <str> ) hc = self . _arraylize ( <str> ) self . Vc = Vc_ChuehPrausnitz ( self . fraccion , Vci , Mi , hydrocarbon = hc ) tb = [ xi * cmp . Tb for xi , cmp in zip ( self . fraccion , self . componente ) ] self . Tb = unidades . Temperature ( sum ( tb ) ) self . SG = sum ( [ xi * cmp . SG for xi , cmp in zip ( self . fraccion , self . componente ) ] )  def __call__ ( self ) :          pass  def _arraylize ( self , prop , unit = None ) :          array = [ ] for cmp in self . componente :              value = cmp . __getattribute__ ( prop ) if unit :                  value = value . __getattribute__ ( unit )  array . append ( value )  return array  def _Ho ( self , T ) :          h = 0 for xw , cmp in zip ( self . fraccion_masica , self . componente ) :              h += xw * cmp . _Ho ( T )  return unidades . Enthalpy ( h )  @ refDoc ( __doi__ , [ 2 ] , tab = 8 ) def _so ( self , T ) :          <str> s = 0 for x , xw , cmp in zip ( self . fraccion , self . fraccion_masica , self . componente ) :              s += xw * cmp . _So ( T ) + R / cmp . M * x * log ( x )  return unidades . SpecificHeat ( s )  def Cp_Gas ( self , T , P ) :          Cp = 0 for xi , cmp in zip ( self . fraccion_masica , self . componente ) :              Cp += xi * cmp . Cp_Gas_DIPPR ( T )  return unidades . SpecificHeat ( Cp )  def RhoL ( self , T , P ) :          method = self . kwargs [ <str> ] if method is None or method >= len ( Mezcla . METHODS_RhoL ) :              method = self . Config . getint ( <str> , <str> )  Pcorr = self . kwargs [ <str> ] if Pcorr is None or method >= len ( Mezcla . METHODS_RhoLP ) :              Pcorr = self . Config . getint ( <str> , <str> )  if method == 0 :              Tci = self . _arraylize ( <str> ) Pci = self . _arraylize ( <str> ) Vci = self . _arraylize ( <str> ) Zrai = self . _arraylize ( <str> ) Mi = self . _arraylize ( <str> ) rhos = RhoL_RackettMix ( T , self . fraccion , Tci , Pci , Vci , Zrai , Mi )  elif method == 1 :              Tci = self . _arraylize ( <str> ) Vci = self . _arraylize ( <str> ) wi = self . _arraylize ( <str> ) Mi = self . _arraylize ( <str> ) rhos = RhoL_CostaldMix ( T , self . fraccion , Tci , wi , Vci , Mi )  if P < 1e6 :              rho = rhos  elif Pcorr == 0 :              Tci = self . _arraylize ( <str> ) Pci = self . _arraylize ( <str> ) Vci = self . _arraylize ( <str> ) Mi = self . _arraylize ( <str> ) wi = self . _arraylize ( <str> ) Mi = self . _arraylize ( <str> ) rho = RhoL_AaltoKeskinenMix ( T , P , self . fraccion , Tci , Pci , Vci , wi , Mi , rhos )  elif Pcorr == 1 :              Tci = self . _arraylize ( <str> ) Vci = self . _arraylize ( <str> ) Mi = self . _arraylize ( <str> ) wi = self . _arraylize ( <str> ) Mi = self . _arraylize ( <str> ) rho = RhoL_TaitCostaldMix ( T , P , self . fraccion , Tci , Vci , wi , Mi , rhos )  elif Pcorr == 2 :              Tci = self . _arraylize ( <str> ) Vci = self . _arraylize ( <str> ) Mi = self . _arraylize ( <str> ) wi = self . _arraylize ( <str> ) Mi = self . _arraylize ( <str> ) rho = RhoL_NasrifarMix ( T , P , self . fraccion , Tci , Vci , wi , Mi , rhos )  elif Pcorr == 3 :              Tci = self . _arraylize ( <str> ) Mi = self . _arraylize ( <str> ) wi = self . _arraylize ( <str> ) Mi = self . _arraylize ( <str> ) rho = RhoL_APIMix ( T , P , self . fraccion , Tci , Pci , rhos )  return rho  def Mu_Gas ( self , T , P , rho ) :          method = self . kwargs [ <str> ] if method is None or method >= len ( Mezcla . METHODS_MuG ) :              method = self . Config . getint ( <str> , <str> )  Pcorr = self . kwargs [ <str> ] if Pcorr is None or method >= len ( Mezcla . METHODS_MuGP ) :              Pcorr = self . Config . getint ( <str> , <str> )  if method == 0 :              Tci = self . _arraylize ( <str> ) Pci = self . _arraylize ( <str> ) Mi = self . _arraylize ( <str> ) Mi = self . _arraylize ( <str> ) Di = self . _arraylize ( <str> , <str> ) mui = [ cmp . Mu_Gas ( T , 101325 , rho ) for cmp in self . componente ] muo = MuG_Reichenberg ( T , self . fraccion , Tci , Pci , Mi , mui , Di )  elif method == 1 :              Tci = self . _arraylize ( <str> ) Pci = self . _arraylize ( <str> ) Vci = self . _arraylize ( <str> ) Zci = self . _arraylize ( <str> ) Mi = self . _arraylize ( <str> ) Di = self . _arraylize ( <str> , <str> ) muo = MuG_Lucas ( T , 101325 , self . fraccion , Tci , Pci , Vci , Zci , Mi , Di )  elif method == 2 :              Tci = self . _arraylize ( <str> ) Vci = self . _arraylize ( <str> ) Mi = self . _arraylize ( <str> ) wi = self . _arraylize ( <str> ) Di = self . _arraylize ( <str> , <str> ) ki = [ cmp . _K_Chung ( ) for cmp in self . componente ] muo = MuG_Chung ( T , self . fraccion , Tci , Vci , Mi , wi , Di , ki )  elif method == 3 :              Mi = self . _arraylize ( <str> ) mui = [ cmp . Mu_Gas ( T , 101325 , None ) for cmp in self . componente ] muo = MuG_Wilke ( self . fraccion , Mi , mui )  elif method == 4 :              Mi = self . _arraylize ( <str> ) mui = [ cmp . Mu_Gas ( T , 101325 , None ) for cmp in self . componente ] muo = MuG_Herning ( self . fraccion , Mi , mui )  if P < 1e6 :              mu = muo  elif Pcorr == 0 :              Tci = self . _arraylize ( <str> ) Pci = self . _arraylize ( <str> ) Vci = self . _arraylize ( <str> ) Zci = self . _arraylize ( <str> ) Mi = self . _arraylize ( <str> ) Di = self . _arraylize ( <str> , <str> ) mu = MuG_Lucas ( T , P , self . fraccion , Tci , Pci , Vci , Zci , Mi , Di )  elif Pcorr == 1 :              Tci = self . _arraylize ( <str> ) Vci = self . _arraylize ( <str> ) Mi = self . _arraylize ( <str> ) wi = self . _arraylize ( <str> ) Di = self . _arraylize ( <str> , <str> ) ki = [ cmp . _K_Chung ( ) for cmp in self . componente ] mu = MuG_P_Chung ( T , self . fraccion , Tci , Vci , Mi , wi , Di , ki , rho , muo )  elif Pcorr == 2 :              Tci = self . _arraylize ( <str> ) Vci = self . _arraylize ( <str> ) Zci = self . _arraylize ( <str> ) Mi = self . _arraylize ( <str> ) wi = self . _arraylize ( <str> ) mu = MuG_TRAPP ( T , P , self . fraccion , Tci , Vci , Zci , Mi , wi , rho , muo )  elif Pcorr == 3 :              Tci = self . _arraylize ( <str> ) Pci = self . _arraylize ( <str> ) Vci = self . _arraylize ( <str> ) Mi = self . _arraylize ( <str> ) rhoc = 1 / Vc_ChuehPrausnitz ( self . fraccion , Vci , Mi ) mu = MuG_DeanStielMix ( self . fraccion , Tci , Pci , Mi , rhoc , rho , muo )  elif Pcorr == 4 :              Tci = self . _arraylize ( <str> ) Pci = self . _arraylize ( <str> ) mu = MuG_APIMix ( T , P , self . fraccion , Tci , Pci , muo )  return mu  def Mu_Liquido ( self , T , P ) :          method = self . kwargs [ <str> ] if method is None or method >= len ( Mezcla . METHODS_MuL ) :              method = self . Config . getint ( <str> , <str> )  if method == 0 :              mui = [ cmp . Mu_Liquido ( T , P ) for cmp in self . componente ] mu = MuL_KendallMonroe ( self . fraccion , mui )  elif method == 1 :              Mi = self . _arraylize ( <str> ) mui = [ cmp . Mu_Liquido ( T , P ) for cmp in self . componente ] mu = MuL_Chemcad ( self . fraccion , Mi , mui )  return mu  def Tension ( self , T ) :          sigmai = [ cmp . Tension ( T ) for cmp in self . componente ] tension = Tension ( self . fraccion , sigmai ) return unidades . Tension ( tension )  def ThCond_Liquido ( self , T , P , rho ) :          method = self . kwargs [ <str> ] if method is None or method >= len ( Mezcla . METHODS_ThL ) :              method = self . Config . getint ( <str> , <str> )  if method == 0 :              Vi = [ 1 / cmp . RhoL ( T , P ) for cmp in self . componente ] Mi = self . _arraylize ( <str> ) ki = [ cmp . ThCond_Liquido ( T , P , rho ) for cmp in self . componente ] k = ThL_Li ( self . fraccion , Vi , Mi , ki )  elif method == 1 :              ki = [ cmp . ThCond_Liquido ( T , P , rho ) for cmp in self . componente ] k = ThL_Power ( self . fraccion_masica , ki )  return k  def ThCond_Gas ( self , T , P , rho ) :          method = self . kwargs [ <str> ] if method is None or method >= len ( Mezcla . METHODS_ThG ) :              method = self . Config . getint ( <str> , <str> )  Pcorr = self . kwargs [ <str> ] if Pcorr is None or method >= len ( Mezcla . METHODS_ThGP ) :              Pcorr = self . Config . getint ( <str> , <str> )  if method == 0 :              Mi = self . _arraylize ( <str> ) mui = [ cmp . Mu_Gas ( T , 101325 , rho ) for cmp in self . componente ] ki = [ cmp . ThCond_Gas ( T , P , rho ) for cmp in self . componente ] ko = ThG_MasonSaxena ( self . fraccion , Mi , mui , ki )  elif method == 1 :              Mi = self . _arraylize ( <str> ) Tbi = self . _arraylize ( <str> ) mui = [ cmp . Mu_Gas ( T , 101325 , rho ) for cmp in self . componente ] ki = [ cmp . ThCond_Gas ( T , P , rho ) for cmp in self . componente ] ko = ThG_LindsayBromley ( T , self . fraccion , Mi , Tbi , mui , ki )  elif method == 2 :              Tci = self . _arraylize ( <str> ) Vci = self . _arraylize ( <str> ) Mi = self . _arraylize ( <str> ) wi = self . _arraylize ( <str> ) Cvi = [ cmp . Cv ( T ) for cmp in self . componente ] Di = self . _arraylize ( <str> , <str> ) ki = [ cmp . _K_Chung ( ) for cmp in self . componente ] mu = MuG_Chung ( T , self . fraccion , Tci , Vci , Mi , wi , Di , ki ) ko = ThG_Chung ( T , self . fraccion , Tci , Vci , Mi , wi , Cvi , mu )  if P < 1e6 :              k = ko  elif Pcorr == 0 :              Tci = self . _arraylize ( <str> ) Pci = self . _arraylize ( <str> ) Vci = self . _arraylize ( <str> ) wi = self . _arraylize ( <str> ) Mi = self . _arraylize ( <str> ) k = ThG_StielThodosYorizane ( T , self . fraccion , Tci , Pci , Vci , wi , Mi , 1 / rho , ko )  elif Pcorr == 1 :              Tci = self . _arraylize ( <str> ) Vci = self . _arraylize ( <str> ) Zci = self . _arraylize ( <str> ) wi = self . _arraylize ( <str> ) Mi = self . _arraylize ( <str> ) k = ThG_TRAPP ( T , self . fraccion , Tci , Vci , Zci , wi , Mi , rho , ko )  elif Pcorr == 2 :              Tci = self . _arraylize ( <str> ) Vci = self . _arraylize ( <str> ) Mi = self . _arraylize ( <str> ) wi = self . _arraylize ( <str> ) Di = self . _arraylize ( <str> , <str> ) ki = [ cmp . _K_Chung ( ) for cmp in self . componente ] k = ThG_P_Chung ( T , self . fraccion , Tci , Vci , Mi , wi , Di , ki , rho , ko )  return k  def writeStatetoJSON ( self , state ) :          mezcla = { } if self . _bool :              mezcla [ <str> ] = self . ids mezcla [ <str> ] = self . fraccion mezcla [ <str> ] = self . fraccion_masica mezcla [ <str> ] = self . caudalunitariomasico mezcla [ <str> ] = self . caudalunitariomolar mezcla [ <str> ] = self . caudalmasico mezcla [ <str> ] = self . caudalmolar mezcla [ <str> ] = self . M mezcla [ <str> ] = self . Tc mezcla [ <str> ] = self . tpc mezcla [ <str> ] = self . ppc mezcla [ <str> ] = self . Pc mezcla [ <str> ] = self . f_acent mezcla [ <str> ] = self . f_acent_mod mezcla [ <str> ] = self . Vc mezcla [ <str> ] = self . Tb mezcla [ <str> ] = self . SG  state [ <str> ] = mezcla  def readStatefromJSON ( self , mezcla ) :          if mezcla :              self . _bool = True self . ids = mezcla [ <str> ] self . componente = [ Componente ( int ( i ) ) for i in self . ids ] self . fraccion = [ unidades . Dimensionless ( x ) for x in mezcla [ <str> ] ] self . fraccion_masica = [ unidades . Dimensionless ( x ) for x in mezcla [ <str> ] ] self . caudalunitariomasico = [ unidades . MassFlow ( x ) for x in mezcla [ <str> ] ] self . caudalunitariomolar = [ unidades . MolarFlow ( x ) for x in mezcla [ <str> ] ] self . caudalmasico = unidades . MassFlow ( mezcla [ <str> ] ) self . caudalmolar = unidades . MolarFlow ( mezcla [ <str> ] ) self . M = unidades . Dimensionless ( mezcla [ <str> ] ) self . Tc = unidades . Temperature ( mezcla [ <str> ] ) self . tpc = unidades . Temperature ( mezcla [ <str> ] ) self . ppc = unidades . Pressure ( mezcla [ <str> ] ) self . Pc = unidades . Pressure ( mezcla [ <str> ] ) self . f_acent = unidades . Dimensionless ( mezcla [ <str> ] ) self . f_acent_mod = unidades . Dimensionless ( mezcla [ <str> ] ) self . Vc = unidades . SpecificVolume ( mezcla [ <str> ] ) self . Tb = unidades . Temperature ( mezcla [ <str> ] ) self . SG = unidades . Dimensionless ( mezcla [ <str> ] )   def recallZeros ( self , lista , val = 0 ) :          l = lista [ : ] for i in self . zeros :              l . insert ( i , val )  return l    