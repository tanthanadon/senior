from configparser import ConfigParser from PyQt5 . QtWidgets import QApplication from scipy import exp , sqrt , log10 , log from scipy . interpolate import interp1d from scipy . optimize import fsolve , leastsq , newton from numpy . linalg import solve from numpy import array from lib import unidades from lib . physics import R_atml , R_Btu from lib . newComponent import newComponente from lib . config import conf_dir from lib . compuestos import prop_Edmister from lib . utilities import refDoc __doi__ = { 1 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 2 : { <str> : <str> , <str> : <str> <str> , <str> : <str> <str> <str> , <str> : <str> } , 3 : { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } , 4 : { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } , 5 : { <str> : <str> , <str> : <str> <str> <str> , <str> : <str> , <str> : <str> } , 6 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 7 : { <str> : <str> , <str> : <str> <str> , <str> : <str> <str> , <str> : <str> } , 8 : { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } , 9 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 10 : { <str> : <str> , <str> : <str> <str> <str> , <str> : <str> , <str> : <str> } , 11 : { <str> : <str> , <str> : <str> <str> , <str> : <str> <str> <str> , <str> : <str> } , 12 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 13 : { <str> : <str> , <str> : <str> <str> <str> , <str> : <str> , <str> : <str> } , 14 : { <str> : <str> , <str> : <str> , <str> : <str> <str> , <str> : <str> } , 15 : { <str> : <str> , <str> : <str> , <str> : <str> <str> , <str> : <str> } , 16 : { <str> : <str> , <str> : <str> <str> , <str> : <str> <str> , <str> : <str> } , 17 : { <str> : <str> , <str> : <str> <str> , <str> : <str> <str> , <str> : <str> } , 18 : { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } , 20 : { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } , 21 : { <str> : <str> , <str> : <str> <str> <str> , <str> : <str> , <str> : <str> } , 22 : { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } , 23 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 24 : { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } , 25 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 26 : { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } , 27 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 28 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 29 : { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } , 30 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 31 : { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } , 32 : { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } , 51 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 52 : { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } , 53 : { <str> : <str> , <str> : <str> <str> <str> , <str> : <str> , <str> : <str> } , 54 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 55 : { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } , 56 : { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } , 57 : { <str> : <str> , <str> : <str> , <str> : <str> <str> , <str> : <str> } , 58 : { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } , 59 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 60 : { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } , 61 : { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } , 62 : { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } , 63 : { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } , 64 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 65 : { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } , } def _unit ( key , val , unit = None ) :      if key in ( <str> , <str> ) :          if unit is None :              unit = <str>  x = unidades . Temperature ( val , unit )  elif key == <str> :          if unit is None :              unit = <str>  x = unidades . Pressure ( val , unit )  elif key == <str> :          if unit is None :              unit = <str>  x = unidades . SpecificVolume ( val , unit )  else :          x = unidades . Dimensionless ( val )  return x  @ refDoc ( __doi__ , [ 1 , 2 ] ) def prop_Ahmed ( Nc ) :      a1 = [ - 131.11375 , 915.53747 , 275.56275 , 434.38878 , - 0.50862704 , 0.86714949 , 5.223458e-2 ] a2 = [ 24.96156 , 41.421337 , - 12.522269 , 50.125279 , 8.700211e-2 , 3.41434080e-3 , 7.87091369e-4 ] a3 = [ - 0.34079022 , - 0.7586849 , 0.29926384 , - 0.9097293 , - 1.8484814e-3 , - 2.839627e-5 , - 1.9324432e-5 ] a4 = [ 2.4941184e-3 , 5.8675351e-3 , - 2.8452129e-3 , 7.0280657e-3 , 1.466389e-5 , 2.4943308e-8 , 1.7547264e-7 ] a5 = [ 468.32575 , - 1.3028779e3 , 1.7117226e3 , - 601.856510 , 1.8518106 , - 1.1627984 , 4.4017952e-2 ] prop = { } for i , key in enumerate ( [ <str> , <str> , <str> , <str> , <str> , <str> , <str> ] ) :          x = a1 [ i ] + a2 [ i ] * Nc + a3 [ i ] * Nc ** 2 + a4 [ i ] * Nc ** 3 + a5 [ i ] / Nc val = _unit ( key , x ) prop [ key ] = val  return prop  @ refDoc ( __doi__ , [ 4 , 9 ] ) def prop_Riazi_Daubert_1980 ( Tb , SG ) :      Tb_R = unidades . K2R ( Tb ) a = [ 4.5673e-5 , 24.2787 , 3.12281e9 , 7.5214e-3 ] b = [ 2.1962 , 0.58848 , - 2.3125 , 0.2896 ] c = [ - 1.0164 , 0.3596 , 2.3201 , - 0.7666 ] prop = { } prop [ <str> ] = unidades . Temperature ( Tb ) prop [ <str> ] = unidades . Dimensionless ( SG ) for i , key in enumerate ( [ <str> , <str> , <str> , <str> ] ) :          x = a [ i ] * Tb_R ** b [ i ] * SG ** c [ i ] val = _unit ( key , x ) prop [ key ] = val  return prop  @ refDoc ( __doi__ , [ 3 , 9 ] ) def prop_Riazi_Daubert ( tita1 , val1 , tita2 , val2 ) :      p1 = ( <str> , <str> , <str> ) p2 = ( <str> , <str> , <str> ) if tita1 in p2 and tita2 in p1 :          tita1 , tita2 = tita2 , tita1 val1 , val2 = val2 , val1  if tita1 not in p1 or tita2 not in p2 :          raise NotImplementedError ( QApplication . translate ( <str> , <str> ) )  elif tita1 == <str> and ( val1 < 70 or val1 > 300 ) :          raise NotImplementedError ( QApplication . translate ( <str> , <str> ) )  elif tita1 == <str> and ( val1 < 300 or val1 > 620 ) :          raise NotImplementedError ( QApplication . translate ( <str> , <str> ) )  if tita1 == <str> :          val1 = unidades . K2R ( val1 )  par = { <str> : { <str> : [ 10.6443 , - 5.1747e-4 , - .54444 , 3.5995e-4 , .81067 , .53691 ] , <str> : [ 5.62596e5 , - 7.317e-4 , - 16.9097 , 2.5131e-3 , .6154 , 4.3469 ] , <str> : [ 2.2452 , 1.9152e-4 , - 0.06487 , - 6.0192e-4 , 0.7699 , 0.900 ] , <str> : [ 554.4 , - 1.3478e-4 , - 0.61641 , 0.0 , 0.2998 , 1.0555 ] , <str> : [ 2.4254e6 , 2.001e-4 , - 13.049 , 0.0 , 0.2383 , 4.0642 ] , <str> : [ 37.332 , 1.3848e-3 , - 0.1379 , - 2.7e-4 , 0.3526 , 1.4191 ] , <str> : [ 251.026 , - 3.177e-2 , 1.6587 , 0.0 , 0.1958 , - 0.9431 ] , <str> : [ 4.414e3 , - 0.0291 , - 1.2664 , 0.0 , 0.1884 , 0.7492 ] , <str> : [ 4.939e2 , - 2.8e-2 , - 8.91e-2 , 0.0 , 0.1928 , 0.7744 ] } , <str> : { <str> : [ 6.162e6 , - 4.725e-3 , - 4.8014 , 3.1939e-3 , - 0.4844 , 4.0846 ] , <str> : [ 2.2337e25 , - 6.7041e-3 , - 74.5612 , .019 , - 1.0303 , 18.43302 ] , <str> : [ 158.96 , - 2.1357e-3 , - 0.3454 , 0.0 , - 0.1801 , 3.2223 ] , <str> : [ 4.5203e4 , - 1.8078e-3 , - 0.3084 , 0.0 , - 0.8063 , 1.6015 ] , <str> : [ 2.9384e17 , - 0.01415 , - 48.5809 , 0.0451 , - 0.8097 , 12.9148 ] , <str> : [ 815.99 , - 2.139e-3 , - 0.265 , 0.0 , - 0.6616 , 2.4004 ] , <str> : [ 1.271e5 , - 0.2523 , - 5.6028 , 0.355 , - 0.5913 , 6.0793 ] , <str> : [ 6.1475e22 , - 0.4586 , - 71.905 , 1.8854 , - 0.6395 , 20.7032 ] , <str> : [ 40.9115 , 0.01906 , 0.1323 , 0.0 , 0.471 , 1.6306 ] } , <str> : { <str> : [ 6.233e-4 , - 1.4679e-3 , - .26404 , 1.095e-3 , .7506 , - 1.2028 ] , <str> : [ 1.3077e-3 , - 1.799e-3 , - 3.5349 , 4.425e-3 , .7687 , - .72011 ] , <str> : [ 0.2048 , - 9.2189e-4 , 0.05345 , 1.4805e-4 , 0.1657 , - 1.4439 ] , <str> : [ 1.206e-2 , - 2.657e-3 , 0.5287 , 2.6012e-3 , 0.20378 , - 1.3036 ] , <str> : [ 1.016e-6 , - 2.0208e-3 , 14.1853 , 4.5318e-3 , .2556 , - 4.60413 ] , <str> : [ 0.2558 , - 2.3533e-3 , 0.1082 , 3.826e-4 , 0.0706 , - 1.3362 ] , <str> : [ 1.64424e-3 , - 2.04563e-1 , 3.513392 , 2.12365e-1 , 1.19093e-1 , - 3.801261 ] , <str> : [ 3.219523e-12 , - 1.63181e-1 , 36.09011 , .4608 , .1417 , - 10.65067 ] , <str> : [ .245582 , - .11261 , .086387 , .016031 , .046004 , - 1.028488 ] } , <str> : { <str> : [ 581.96 , 5.43076e-4 , - 9.53384 , 1.11056e-3 , 0.97476 , 6.51274 ] , <str> : [ 2.606e-6 , 8.6574e-6 , 4.2376 , 0.0 , 2.0935 , - 1.9985 ] , <str> : [ 3.06584e-3 , 5.3305e-4 , 7.9113e-2 , - 2.87657e1 , 1.6736 , - 0.68681 ] , <str> : [ 1.51723e6 , - 0.195411 , - 9.63897 , .16247 , .56370 , 6.89383 ] , <str> : [ 4.0e-9 , - 8.9854e-2 , 38.106 , 0.0 , 0.6675 , - 10.6 ] , <str> : [ 84.1505 , - 5.976e-2 , - 0.10741 , 0.0 , 0.5596 , 0.65815 ] , <str> : [ 288.916 , 0.1380 , - 0.7311 , - 5.704e-3 , 0.051 , 0.8411 ] } , <str> : { <str> : [ 6.77857 , 3.77409e-3 , 2.984036 , - 4.25288e-3 , 4.01673e-1 , - 1.58262 ] , <str> : [ 136.395 , 0.0 , 0.0 , 0.0 , 0.4748 , 0.4283 ] , <str> : [ 36.45625 , - 1.57415e-4 , - 4.5707e-2 , 9.22926e-6 , 5.12976e-1 , 4.72372e-1 ] , <str> : [ 4.28375e3 , - 1.3051e-2 , - 1.68759 , - 2.1247e-2 , 2.62914e-1 , 1.34890 ] , <str> : [ 9.1133e-2 , - 6.5236e-2 , 14.9371 , 6.029e-2 , .3228 , - 3.8798 ] , <str> : [ 444.377 , - 3.8093e-2 , - 7.7305e-2 , 0.0 , 0.2899 , 0.6056 ] } , <str> : { <str> : [ 6.9195 , - 2.33e-4 , - 23.5535 , 2.2152e-3 , 2.9806e7 , - 0.3418 ] , <str> : [ 7.3238e-1 , - 1.01845e-3 , - 8.1635e-2 , 3.60649e-5 , 1.69916e-3 , 8.90041e-1 ] , <str> : [ 6.3028 , - 1.588e-3 , - 20.594 , 7.344e-3 , 1.1284e6 , - 7.71e-2 ] , <str> : [ 9.19255e-1 , - 1.48844e-3 , - 7.925e-2 , 4.921118e-5 , 6.84403e-2 , 2.89844e-1 ] , <str> : [ 8.04224 , - 6.1406e-2 , - 26.3934 , .2533 , 3.8083e7 , - .02353 ] , <str> : [ 1.17777 , 0.02614 , - 0.10966 , - 5.654e-3 , .18242 , .05245 ] } , <str> : { <str> : [ 0.022657 , 3.9052e-4 , 2.468316 , - 5.70425e-4 , 5.7209e-2 , - 0.719895 ] , <str> : [ 4.307e-3 , - 9.8747e-5 , - 6.0737e-2 , - 4.414e-5 , 0.4470 , 0.9896 ] , <str> : [ 0.422375 , 3.18857e-4 , - 0.200996 , - 4.24514e-4 , - 8.43271e-3 , 1.117818 ] , <str> : [ 4.239e-2 , - 5.6946e-4 , - 6.836e-2 , 0.0 , 0.1656 , 0.8291 ] , <str> : [ .26376 , 1.7458e-2 , .231043 , - 1.8441e-2 , - 1.1275e-2 , .770779 ] , <str> : [ 0.08716 , 6.1396e-3 , - 7.019e-2 , - 2.5935e-3 , .05166 , .84599 ] } , <str> : { <str> : [ 17.22022 , 8.24983e-3 , 16.9402 , - 6.93931e-3 , - 2.72522 , - 6.79769 ] , <str> : [ 1.8866e-12 , 4.2873e-3 , 71.6531 , - 0.0116 , - 1.3773 , - 13.6139 ] , <str> : [ 2.35475 , 9.3485e-3 , 4.74695 , - 8.01719e-3 , - 0.68418 , - 0.7682 ] , <str> : [ 2.9004e-13 , 7.8276e-3 , 60.3484 , - 0.02445 , - 0.37884 , - 12.34051 ] , <str> : [ 2.523e-12 , .482811 , 29.98797 , - 0.55768 , - .146565 , - 20.31303 ] , <str> : [ 2.143e-12 , 0.2832 , 53.7316 , - 0.91085 , - 0.17158 , - 10.88065 ] } } prop = { } prop [ tita1 ] = _unit ( tita1 , val1 ) prop [ tita2 ] = _unit ( tita2 , val2 ) for key in par . keys ( ) :          if key not in ( tita1 , tita2 ) :              a , b , c , d , e , f = par [ key ] [ <str> % ( tita1 , tita2 ) ] x = a * val1 ** e * val2 ** f * exp ( b * val1 + c * val2 + d * val1 * val2 ) val = _unit ( key , x ) prop [ key ] = val   return prop  @ refDoc ( __doi__ , [ 7 , 9 ] ) def prop_Cavett ( Tb , API ) :      Tb_F = unidades . K2F ( Tb ) a = [ 768.07121 , 1.7133693 , - 0.0010834003 , - 0.0089212579 , 0.38890584e-6 , 0.5309492000e-5 , 0.3271160000e-7 ] Tc = a [ 0 ] + a [ 1 ] * Tb_F + a [ 2 ] * Tb_F ** 2 + a [ 3 ] * API * Tb_F + a [ 4 ] * Tb_F ** 3 + a [ 5 ] * API * Tb_F ** 2 + a [ 6 ] * API ** 2 * Tb_F ** 2 b = [ 2.82904060 , 0.94120109e-3 , - 0.30474749e-5 , - 0.20876110e-4 , 0.15184103e-8 , 0.11047899e-7 , - 0.48271599e-7 , 0.13949619e-9 ] Pc = 10 ** ( b [ 0 ] + b [ 1 ] * Tb_F + b [ 2 ] * Tb_F ** 2 + b [ 3 ] * API * Tb_F + b [ 4 ] * Tb_F ** 3 + b [ 5 ] * API * Tb_F ** 2 + b [ 6 ] * API ** 2 * Tb_F + b [ 7 ] * API ** 2 * Tb_F ** 2 ) prop = { } prop [ <str> ] = unidades . Temperature ( Tb ) prop [ <str> ] = unidades . Dimensionless ( API ) prop [ <str> ] = unidades . Temperature ( Tc , <str> ) prop [ <str> ] = unidades . Pressure ( Pc , <str> ) return prop  @ refDoc ( __doi__ , [ 8 , 9 ] ) def prop_Lee_Kesler ( Tb , SG ) :      Tb_R = unidades . K2R ( Tb ) Tc = 341.7 + 811.1 * SG + ( 0.4244 + 0.1174 * SG ) * Tb_R + ( 0.4669 - 3.26238 * SG ) * 1e5 / Tb_R Pc = exp ( 8.3634 - 0.0566 / SG - ( 0.24244 + 2.2898 / SG + 0.11857 / SG ** 2 ) * 1e-3 * Tb_R + ( 1.4685 + 3.648 / SG + 0.47227 / SG ** 2 ) * 1e-7 * Tb_R ** 2 - ( 0.42019 + 1.6977 / SG ** 2 ) * 1e-10 * Tb_R ** 3 ) M = - 12272.6 + 9486.4 * SG + ( 4.6523 - 3.3287 * SG ) * Tb_R + ( 1 - 0.77084 * SG - 0.02058 * SG ** 2 ) * ( 1.3437 - 720.79 / Tb_R ) * 1e7 / Tb_R + ( 1 - 0.80882 * SG + 0.02226 * SG ** 2 ) * ( 1.8828 - 181.98 / Tb_R ) * 1e12 / Tb_R ** 3 tr = Tb_R / Tc Kw = Tb_R ** ( 1. / 3 ) / SG if tr > 0.8 :          w = - 7.904 + 0.1352 * Kw - 0.007465 * Kw ** 2 + 8359 * tr + ( 1.408 - 0.01063 * Kw ) / tr  else :          w = ( - log ( Pc / 14.7 ) - 5.92714 + 6.09648 / tr + 1.28862 * log ( tr ) - 0.169347 * tr ** 6 ) / ( 15.2518 - 15.6875 / tr - 13.4721 * log ( tr ) + 0.43577 * tr ** 6 )  prop = { } prop [ <str> ] = unidades . Temperature ( Tb ) prop [ <str> ] = unidades . Dimensionless ( SG ) prop [ <str> ] = unidades . Temperature ( Tc , <str> ) prop [ <str> ] = unidades . Pressure ( Pc , <str> ) prop [ <str> ] = unidades . Dimensionless ( M ) prop [ <str> ] = unidades . Dimensionless ( w ) return prop  @ refDoc ( __doi__ , [ 6 , 9 ] ) def prop_Sim_Daubert ( Tb , SG ) :      M = 5.805e-5 * Tb ** 2.3776 / SG ** 0.9371 Pc = 6.1483e12 * Tb ** - 2.3177 * SG ** 2.4853 Tc = exp ( 4.2009 * Tb ** 0.08615 * SG ** 0.04614 ) prop = { } prop [ <str> ] = unidades . Temperature ( Tb ) prop [ <str> ] = unidades . Dimensionless ( SG ) prop [ <str> ] = unidades . Dimensionless ( M ) prop [ <str> ] = unidades . Temperature ( Tc , <str> ) prop [ <str> ] = unidades . Pressure ( Pc ) return prop  @ refDoc ( __doi__ , [ 10 , 9 ] ) def prop_Watansiri_Owens_Starling ( Tb , SG , M ) :      Tc = exp ( - 0.00093906 * Tb + 0.03095 * log ( M ) + 1.11067 * log ( Tb ) + M * ( 0.078154 * SG ** 0.5 - 0.061061 * SG ** ( 1. / 3. ) - 0.016943 * SG ) ) Vc = exp ( 80.4479 - 129.8038 * SG + 63.175 * SG ** 2 - 13.175 * SG ** 3 + 1.10108 * log ( M ) + 42.1958 * log ( SG ) ) Pc = exp ( 3.95431 + 0.70682 * ( Tc / Vc ) ** 0.8 - 4.84 * M / Tc - 0.15919 * Tb / M ) w = ( 0.92217e-3 * Tb + 0.507288 * Tb / M + 382.904 / M + 0.242e-5 * ( Tb / SG ) ** 2 - 0.2165e-4 * Tb * M + 0.1261e-2 * SG * M + 0.1265e-4 * M ** 2 + 0.2016e-4 * SG * M ** 2 - 80.6495 * Tb ** ( 1 / 3. ) / M - 0.378e-2 * Tb ** ( 2 / 3. ) / SG ** 2 ) * Tb / M HVNP = - 10397.5 + 46.2681 * Tb - 1373.91 * Tb ** 0.5 + 4595.81 * log ( Tb ) u1 = ( 197.933 / M + 0.039177 * M ) * Vc / Tc u2 = 0.3185e-2 * Vc + 0.956247e-2 * Tb - 0.5479e-3 * HVNP u3 = - 1.34634 * w + 0.906609 * log ( w ) u4 = - 4.85638 - 0.013548 * M + 0.271949e-3 * M ** 2 + 1.04024 * log ( M ) Dm = u1 / u4 + u2 * u3 prop = { } prop [ <str> ] = unidades . Temperature ( Tb ) prop [ <str> ] = unidades . Dimensionless ( M ) prop [ <str> ] = unidades . Temperature ( Tc ) prop [ <str> ] = unidades . Pressure ( Pc , <str> ) prop [ <str> ] = unidades . SpecificVolume ( Vc / M , <str> ) prop [ <str> ] = unidades . Dimensionless ( w ) prop [ <str> ] = unidades . DipoleMoment ( Dm , <str> ) return prop  @ refDoc ( __doi__ , [ 11 , 9 ] ) def prop_Rowe ( M ) :      n = ( M - 2 ) / 14 Tc = ( 961 - 10 ** ( 2.95597 - ( 0.090597 * n ** ( 2 / 3. ) ) ) ) * 1.8 Tb = 4.347e-4 * Tc ** 2 + 265 Y = - 0.0134426826 * n + 0.6801481651 C = 10 ** Y * 1e5 Pc = C / Tc prop = { } prop [ <str> ] = unidades . Dimensionless ( M ) prop [ <str> ] = unidades . Temperature ( Tc , <str> ) prop [ <str> ] = unidades . Temperature ( Tb , <str> ) prop [ <str> ] = unidades . Pressure ( Pc , <str> ) return prop  @ refDoc ( __doi__ , [ 12 , 9 ] ) def prop_Standing ( M , SG ) :      Tc = 608 + 364 * log10 ( M - 71.2 ) + ( 2450 * log10 ( M ) - 3800 ) * log10 ( SG ) Pc = 1188 - 431 * log10 ( M - 61.1 ) + ( 2319 - 852 * log10 ( M - 53.7 ) ) * ( SG - 0.8 ) prop = { } prop [ <str> ] = unidades . Dimensionless ( M ) prop [ <str> ] = unidades . Dimensionless ( SG ) prop [ <str> ] = unidades . Temperature ( Tc , <str> ) prop [ <str> ] = unidades . Pressure ( Pc , <str> ) return prop  @ refDoc ( __doi__ , [ 13 , 9 ] ) def prop_Willman_Teja ( Tb ) :      A = [ 95.50441892007 , 3.742203001499 , 2295.53031513 , - 1042.57256080 , - 22.66229823925 , - 1660.893846582 , 439.13226915 ] def f ( n ) :          return A [ 0 ] + A [ 1 ] * n + A [ 2 ] * n ** 0.667 + A [ 3 ] * n ** 0.5 + A [ 4 ] * log10 ( n ) + A [ 5 ] * n ** 0.8 + A [ 6 ] * n ** 0.9 - Tb  n = fsolve ( f , 10 ) Tc = Tb * ( 1 + 1 / ( 1.25127 + 0.137242 * n ) ) Pc = ( 2.33761 + 8.16448 * n ) / ( 0.873159 + 0.54285 * n ) ** 2 prop = { } prop [ <str> ] = unidades . Dimensionless ( Tb ) prop [ <str> ] = unidades . Dimensionless ( n ) prop [ <str> ] = unidades . Temperature ( Tc ) prop [ <str> ] = unidades . Pressure ( Pc , <str> ) return prop  @ refDoc ( __doi__ , [ 9 , 14 ] ) def prop_Magoulas_Tassios ( M , SG ) :      Tc = - 1247.4 + 0.792 * M + 1971 * SG - 27000. / M + 707.4 / SG Pc = exp ( 0.01901 - 0.0048442 * M + 0.13239 * SG + 227. / M - 1.1663 / SG + 1.2702 * log ( M ) ) w = - 0.64235 + 0.00014667 * M + 0.021876 * SG - 4.539 / M + 0.21699 * log ( M ) prop = { } prop [ <str> ] = unidades . Dimensionless ( M ) prop [ <str> ] = unidades . Dimensionless ( SG ) prop [ <str> ] = unidades . Temperature ( Tc , <str> ) prop [ <str> ] = unidades . Pressure ( Pc , <str> ) prop [ <str> ] = unidades . Dimensionless ( w ) return prop  @ refDoc ( __doi__ , [ 65 ] ) def prop_Tsonopoulos ( SG , Tb ) :      Tc = 10 ** ( 1.20016 - 0.61954 * log10 ( Tb ) + 0.48262 * log10 ( SG ) + 0.67365 * log10 ( SG ) ** 2 ) Pc = 10 ** ( 7.37498 - 2.15833 * log10 ( Tb ) + 3.35417 * log10 ( SG ) + 5.64019 * log10 ( SG ) ** 2 ) prop = { } prop [ <str> ] = unidades . Temperature ( Tb ) prop [ <str> ] = unidades . Dimensionless ( SG ) prop [ <str> ] = unidades . Temperature ( Tc ) prop [ <str> ] = unidades . Pressure ( Pc , <str> ) return prop  @ refDoc ( __doi__ , [ 5 ] ) def prop_Twu ( Tb , SG ) :      Tb_R = unidades . K2R ( Tb ) Tco = Tb_R / ( 0.533272 + 0.191017e-3 * Tb_R + 0.779681e-7 * Tb_R ** 2 - 0.284376e-10 * Tb_R ** 3 + 0.959468e28 / Tb_R ** 13 ) alfa = 1 - Tb_R / Tco Vco = ( 1 - ( 0.419869 - 0.505839 * alfa - 1.56436 * alfa ** 3 - 9481.7 * alfa ** 14 ) ) ** - 8 SGo = 0.843593 - 0.128624 * alfa - 3.36159 * alfa ** 3 - 13749.5 * alfa ** 12 Pco = ( 3.83354 + 1.19629 * alfa ** 0.5 + 34.8888 * alfa + 36.1952 * alfa ** 2 + 104.193 * alfa ** 4 ) ** 2 def f ( M ) :          Tita = log ( M ) return exp ( 5.71419 + 2.71579 * Tita - 0.286590 * Tita ** 2 - 39.8544 / Tita - 0.122488 / Tita ** 2 ) - 24.7522 * Tita + 35.3155 * Tita ** 2 - Tb_R  Moo = Tb_R / ( 10.44 - 0.0052 * Tb_R ) Mo = newton ( f , Moo ) DSGt = exp ( 5 * ( SGo - SG ) ) - 1 ft = DSGt * ( - 0.362456 / Tb_R ** 0.5 + ( .0398285 - 0.948125 / Tb_R ** 0.5 ) * DSGt ) Tc = Tco * ( ( 1 + 2 * ft ) / ( 1 - 2 * ft ) ) ** 2 DSGv = exp ( 4 * ( SGo ** 2 - SG ** 2 ) ) - 1 fv = DSGv * ( 0.46659 / Tb_R ** 0.5 + ( - 0.182421 + 3.01721 / Tb_R ** 0.5 ) * DSGv ) Vc = Vco * ( ( 1 + 2 * fv ) / ( 1 - 2 * fv ) ) ** 2 DSGp = exp ( 0.5 * ( SGo - SG ) ) - 1 fp = DSGp * ( 2.53262 - 46.1955 / Tb_R ** 0.5 - 0.00127885 * Tb_R + ( - 11.4277 + 252.14 / Tb_R ** 0.5 + 0.00230535 * Tb_R ) * DSGp ) Pc = Pco * Tc / Tco * Vco / Vc * ( ( 1 + 2 * fp ) / ( 1 - 2 * fp ) ) ** 2 DSGm = exp ( 5 * ( SGo - SG ) ) - 1 x = abs ( 0.012342 - 0.328086 / Tb_R ** 0.5 ) fm = DSGm * ( x + ( - 0.0175691 + 0.193168 / Tb_R ** 0.5 ) * DSGm ) M = exp ( log ( Mo ) * ( ( 1 + 2 * fm ) / ( 1 - 2 * fm ) ) ** 2 ) prop = { } prop [ <str> ] = unidades . Temperature ( Tb ) prop [ <str> ] = unidades . Dimensionless ( SG ) prop [ <str> ] = unidades . Dimensionless ( M ) prop [ <str> ] = unidades . Temperature ( Tc , <str> ) prop [ <str> ] = unidades . Pressure ( Pc , <str> ) prop [ <str> ] = unidades . SpecificVolume ( Vc / M , <str> ) return prop  @ refDoc ( __doi__ , [ 5 , 9 ] ) def prop_Sancet ( M ) :      Pc = 82.82 + 653 * exp ( - 0.007427 * M ) Tc = - 778.5 + 383.5 * log ( M - 4.075 ) Tb = 194 + 0.001241 * Tc ** 1.869 prop = { } prop [ <str> ] = unidades . Dimensionless ( M ) prop [ <str> ] = unidades . Pressure ( Pc , <str> ) prop [ <str> ] = unidades . Temperature ( Tc , <str> ) prop [ <str> ] = unidades . Temperature ( Tb , <str> ) return prop  @ refDoc ( __doi__ , [ 16 , 9 ] ) def prop_Silva_Rodriguez ( M ) :      Tb = 447.08725 * log ( M / 64.2576 ) SG = 0.132467 * log ( Tb ) + 0.0116483 prop = { } prop [ <str> ] = unidades . Dimensionless ( M ) prop [ <str> ] = unidades . Dimensionless ( SG ) prop [ <str> ] = unidades . Temperature ( Tb , <str> ) return prop  @ refDoc ( __doi__ , [ 17 ] ) def Tb_Soreide ( M , SG ) :      Tb = 1928.3 - 1.695e5 * SG ** 3.266 / M ** 0.03522 * exp ( - 4.922e-3 * M - 4.7685 * SG + 3.462e-3 * M * SG ) return { <str> : unidades . Temperature ( Tb , <str> ) }  @ refDoc ( __doi__ , [ 18 ] ) def vc_Hall_Yarborough ( M , SG ) :      Vc = 0.025 * M ** 1.15 / SG ** 0.7985 return { <str> : unidades . SpecificVolume ( Vc / M , <str> ) }  @ refDoc ( __doi__ , [ 63 ] ) def M_Goossens ( Tb , d20 ) :      b = 1.52869 + 0.06486 * log ( Tb / ( 1078 - Tb ) ) M = 0.01077 * Tb ** b / d20 return { <str> : unidades . Dimensionless ( M ) }  @ refDoc ( __doi__ , [ 64 ] ) def w_Korsten ( Tb , Tc , Pc ) :      tbr = Tb / Tc w = 0.5899 * tbr ** 1.3 / ( 1 - tbr ** 1.3 ) * log10 ( Pc / 101325 ) - 1. return { <str> : unidades . Dimensionless ( w ) }  @ refDoc ( __doi__ , [ 29 ] ) def prop_Riazi ( SG , tita , val ) :      if tita not in [ <str> , <str> ] :          raise NotImplementedError ( QApplication . translate ( <str> , <str> ) )  if tita == <str> :          val = unidades . K2R ( val )  par = { <str> : { <str> : [ 35.9416 , - 6.9e-4 , - 1.4442 , 4.91e-4 , 0.7293 , 1.2771 ] , <str> : [ 218.9592 , - 3.4e-4 , - 0.40852 , - 2.5e-5 , 0.331 , 0.8136 ] } , <str> : { <str> : [ 6.9575 , - 0.0135 , - 0.3129 , 9.174e-3 , 0.6791 , - 0.6807 ] , <str> : [ 8.2365e4 , - 9.04e-3 , - 3.3304 , 0.01006 , - 0.9366 , 3.1353 ] } , <str> : { <str> : [ 6.1677e10 , - 7.583e-3 , - 28.5524 , 0.01172 , 1.20493 , 17.2074 ] , <str> : [ 9.703e6 , - 9.512e-3 , - 15.8092 , 0.01111 , 1.08283 , 10.5118 ] } , <str> : { <str> : [ 9.3369 , 1.65e-4 , 1.4103 , - 7.5152e-4 , 0.5369 , - 0.7276 ] } , <str> : { <str> : [ 3.2709e-3 , 8.4377e-4 , 4.59487 , - 1.0617e-3 , 0.03201 , - 2.34887 ] , <str> : [ 1.2419e-2 , 7.27e-4 , 3.3323 , - 8.87e-4 , 6.438e-3 , - 1.61166 ] } , <str> : { <str> : [ 0.997 , 2.9e-4 , 5.0425 , - 3.1e-4 , - 0.00929 , 1.01772 ] , <str> : [ 1.04908 , 2.9e-4 , - 7.339e-2 , - 3.4e-4 , 3.484e-3 , 1.05015 ] } } prop = { } prop [ tita ] = _unit ( tita , val ) for key in par . keys ( ) :          if key != tita and ( tita != <str> or key != <str> ) :              a , b , c , d , e , f = par [ key ] [ tita ] x = a * val ** e * SG ** f * exp ( b * val + c * SG + d * val * SG ) unit = <str> if key == <str> :                  unit = <str>  val = _unit ( key , x , unit ) prop [ key ] = val   return prop  @ refDoc ( __doi__ , [ 26 ] ) def prop_Riazi_Alsahhaf ( Tb , M , d20 ) :      a = [ 1.60193 , 10.74145 , - 8.84800 ] b = [ 0.00558 , 0.07434 , - 0.03632 ] c = [ - 0.00112 , - 0.00047 , - 0.00547 ] d = [ - 0.52398 , - 2.10482 , 0.16629 ] e = [ 0.00104 , 0.00508 , - 0.00028 ] f = [ - 0.06403 , - 1.18869 , 0.04660 ] g = [ 0.93857 , - 0.66773 , 2.00241 ] h = [ - 0.00085 , - 0.01154 , 0.00587 ] i = [ 0.28290 , 1.53161 , - 0.96608 ] prop = { } prop [ <str> ] = unidades . Temperature ( Tb ) prop [ <str> ] = unidades . Density ( d , <str> ) for j , key in enumerate ( [ <str> , <str> , <str> ] ) :          x = exp ( a [ j ] + b [ j ] * M + c [ j ] * Tb + d [ j ] * d20 + e [ j ] * Tb * d20 ) * M ** f [ j ] * Tb ** ( g [ j ] + h [ j ] * M ) * d20 ** i [ j ] val = _unit ( key , x , <str> ) prop [ key ] = val  return prop  @ refDoc ( __doi__ , [ 27 , 28 ] ) def prop_Riazi_Alsahhaf_PNA ( M , cmp ) :      if cmp == <str> :          tita = [ 397 , 1070 , 0.85 , 0.859 , 0.2833 , 1.15 , 0 , 0.26 , 0.3 , 33.2 ] a = [ 6.5096 , 6.98291 , 92.22793 , 88.01379 , 87.6593 , - 0.41966 , 4.65757 , - 3.50532 , - 3.06826 , 5.29577 ] b = [ 0.14187 , 0.02013 , 89.82301 , 85.7446 , 86.62167 , 0.02436 , 0.13423 , 1.5e-6 , - 1.04987 , 0.61653 ] c = [ 0.470 , 2 / 3 , 0.01 , 0.01 , 0.01 , 0.58 , 0.5 , 2.38 , 0.2 , 0.32 ]  elif cmp == <str> :          tita = [ 370 , 1028 , 0.853 , 0.857 , 0.283 , 1.2 , 0 , - 0.255 , 0.3 , 30.6 ] a = [ 6.52504 , 6.95649 , 97.72532 , 85.1824 , 87.55238 , 0.06765 , 7.25857 , - 3.18846 , - 8.25682 , 14.17595 ] b = [ 0.04945 , 0.02239 , 95.73589 , 83.65758 , 86.97556 , 0.13763 , 1.13139 , 0.1658 , - 5.33934 , 7.02549 ] c = [ 2 / 3 , 2 / 3 , 0.01 , 0.01 , 0.01 , 0.35 , 0.26 , 0.5 , 0.08 , 0.12 ]  elif cmp == <str> :          tita = [ 375 , 1015 , - 0.8562 , - 0.854 , - 0.2829 , 1.03 , 0 , - 0.22 , 0 , 30.4 ] a = [ 6.53599 , 6.91062 , 224.7257 , 238.791 , 137.0918 , - 0.29875 , 9.77968 , - 1.43083 , - 14.97 , 1.98292 ] b = [ 0.04912 , 0.02247 , 218.518 , 232.315 , 135.433 , 0.06814 , 3.07555 , 0.12744 , - 9.48345 , - 0.0142 ] c = [ 2 / 3 , 2 / 3 , 0.01 , 0.01 , 0.01 , 0.5 , 0.15 , 0.5 , 0.08 , 1.0 ]  prop = { } prop [ <str> ] = unidades . Dimensionless ( M ) properties = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] for i , key in enumerate ( properties ) :          x = tita [ i ] - exp ( a [ i ] - b [ i ] * M ** c [ i ] ) if key == <str> :              x = prop [ <str> ] / x  elif key in [ <str> , <str> ] :              x = - x  elif key == <str> :              x = 1 / x  unit = <str> if key == <str> :              unit = <str>  elif key == <str> :              unit = <str>  elif key == <str> :              unit = <str>  val = _unit ( key , x , unit ) prop [ key ] = val  return prop  @ refDoc ( __doi__ , [ 22 ] ) def Zc_Hougen ( w ) :      Zc = 1 / ( 1.28 * w + 3.41 ) return unidades . Dimensionless ( Zc )  @ refDoc ( __doi__ , [ 23 ] ) def Zc_Reid ( w ) :      Zc = 0.2918 - 0.0928 * w return unidades . Dimensionless ( Zc )  @ refDoc ( __doi__ , [ 21 ] ) def Zc_Salerno ( w ) :      Zc = 0.291 - 0.08 * w - 0.016 * w ** 2 return unidades . Dimensionless ( Zc )  @ refDoc ( __doi__ , [ 24 ] ) def Zc_Nath ( w ) :      Zc = 0.2908 - 0.0825 * w return unidades . Dimensionless ( Zc )  @ refDoc ( __doi__ , [ 25 ] ) def Zc_Lee_Kesler ( w ) :      Zc = 0.2905 - 0.085 * w return unidades . Dimensionless ( Zc )  @ refDoc ( __doi__ , [ 51 , 29 ] ) def D86_TBP_Riazi ( Ti , Xi = None , reverse = False ) :      if Xi is None :          Xi = [ 0 , 0.1 , 0.3 , 0.5 , 0.7 , 0.9 , 0.95 ]  a = [ 0.9177 , 0.5564 , 0.76517 , 0.9013 , 0.8821 , 0.9552 , 0.8177 ] b = [ 1.0019 , 1.09 , 1.0425 , 1.0176 , 1.0226 , 1.011 , 1.0355 ] Xmin = [ 0 , 0.1 , 0.3 , 0.5 , 0.7 , 0.9 , 0.95 ] Xmax = [ 0.1 , 0.3 , 0.5 , 0.7 , 0.9 , 0.95 , 1.0001 ] A = [ ] B = [ ] for x in Xi :          for xmin , xmax , ai , bi in zip ( Xmin , Xmax , a , b ) :              if xmin <= x < xmax :                  A . append ( ai ) B . append ( bi ) break    TBP = [ ] if reverse :          for ai , bi , T in zip ( A , B , Ti ) :              TBP . append ( unidades . Temperature ( ( 1 / ai ) ** ( 1 / bi ) * T ** ( 1 / bi ) ) )   else :          for ai , bi , T in zip ( A , B , Ti ) :              TBP . append ( unidades . Temperature ( ai * T ** bi ) )   return TBP  @ refDoc ( __doi__ , [ 52 , 20 , 29 ] ) def D86_TBP_Daubert ( Ti , Xi = None , T50 = None , reverse = False ) :      Ti = [ unidades . K2F ( t ) for t in Ti ] if Xi is None :          Xi = [ 0 , 0.1 , 0.3 , 0.5 , 0.7 , 0.9 , 1 ]  if T50 is None :          T50 = Ti [ 3 ]  else :          T50 = unidades . K2F ( T50 )  a = [ 7.4012 , 4.9004 , 3.0305 , 2.5282 , 3.0419 , 0.11798 ] b = [ 0.60244 , 0.71644 , 0.80076 , 0.82002 , 0.75497 , 1.6606 ] Xmin = [ 0 , 0.1 , 0.3 , 0.5 , 0.7 , 0.9 ] Xmax = [ 0.1 , 0.3 , 0.5 , 0.7 , 0.9 , 1.0001 ] A = [ ] B = [ ] for x in Xi :          for xmin , xmax , ai , bi in zip ( Xmin , Xmax , a , b ) :              if xmin <= x < xmax :                  A . append ( ai ) B . append ( bi ) break    if reverse :          TBP50 = exp ( log ( T50 / 0.87180 ) / 1.0258 ) Y = [ exp ( log ( ( Ti [ i + 1 ] - T ) / A [ i ] ) / B [ i ] ) for i , T in enumerate ( Ti [ : - 1 ] ) ]  else :          TBP50 = 0.87180 * T50 ** 1.0258 Y = [ A [ i ] * ( Ti [ i + 1 ] - T ) ** B [ i ] for i , T in enumerate ( Ti [ : - 1 ] ) ]  TBP = [ TBP50 ] * len ( Ti ) for i , T in enumerate ( TBP ) :          for y , x in zip ( Y [ i : ] , Xi [ i : ] ) :              if Xi [ i ] < 0.5 and x < 0.5 :                  TBP [ i ] -= y   for y , x in zip ( Y [ : i ] , Xi [ : i ] ) :              if Xi [ i ] >= 0.5 and x >= 0.5 :                  TBP [ i ] += y    return [ unidades . Temperature ( t , <str> ) for t in TBP ]  @ refDoc ( __doi__ , [ 51 , 29 ] ) def SD_D86_Riazi ( Ti , Xi = None , F = None ) :      if Xi is None :          Xi = [ 0 , 0.1 , 0.3 , 0.5 , 0.7 , 0.9 , 1 ]  if F is None :          F = 0.01411 * Ti [ 1 ] ** 0.05434 * Ti [ 3 ] ** 0.6147  a = [ 5.1764 , 3.7452 , 4.2749 , 18.445 , 1.0751 , 1.0849 , 1.7991 ] b = [ 0.7445 , 0.7944 , 0.7719 , 0.5425 , 0.9867 , 0.9834 , 0.9007 ] c = [ 0.2879 , 0.2671 , 0.345 , 0.7132 , 0.0486 , 0.0354 , 0.0625 ] Xmin = [ 0 , 0.1 , 0.3 , 0.5 , 0.7 , 0.9 , 1 ] Xmax = [ 0.1 , 0.3 , 0.5 , 0.7 , 0.9 , 1 , 1.0001 ] A = [ ] B = [ ] C = [ ] for x in Xi :          for xmin , xmax , ai , bi , ci in zip ( Xmin , Xmax , a , b , c ) :              if xmin <= x < xmax :                  A . append ( ai ) B . append ( bi ) C . append ( ci ) break    D86 = [ ] for ai , bi , ci , T in zip ( A , B , C , Ti ) :          D86 . append ( unidades . Temperature ( ai * T ** bi * F ** ci ) )  return D86  @ refDoc ( __doi__ , [ 52 , 20 , 29 ] ) def SD_D86_Daubert ( Ti , Xi = None , SD50 = None ) :      Ti = [ unidades . K2F ( t ) for t in Ti ] if Xi is None :          Xi = [ 0 , 0.1 , 0.3 , 0.5 , 0.7 , 0.9 ]  if SD50 is None :          SD50 = Ti [ 3 ]  else :          SD50 = unidades . K2F ( SD50 )  e = [ 0.3047 , 0.06069 , 0.07978 , 0.14862 , 0.30785 , 2.6029 ] f = [ 1.1259 , 1.5176 , 1.5386 , 1.4287 , 1.2341 , 0.65962 ] Xmin = [ 0 , 0.1 , 0.3 , 0.5 , 0.7 , 0.9 ] Xmax = [ 0.1 , 0.3 , 0.5 , 0.7 , 0.9 , 1.0001 ] E = [ ] F = [ ] for x in Xi :          for xmin , xmax , ei , fi in zip ( Xmin , Xmax , e , f ) :              if xmin <= x < xmax :                  E . append ( ei ) F . append ( fi ) break    U = [ E [ i ] * ( Ti [ i + 1 ] - T ) ** F [ i ] for i , T in enumerate ( Ti [ : - 1 ] ) ] D86_50 = 0.77601 * SD50 ** 1.0395 D86 = [ D86_50 ] * len ( Ti ) for i , T in enumerate ( D86 ) :          for y , x in zip ( U [ i : ] , Xi [ i : ] ) :              if Xi [ i ] < 0.5 and x < 0.5 :                  D86 [ i ] -= y   for y , x in zip ( U [ : i ] , Xi [ : i ] ) :              if Xi [ i ] >= 0.5 and x >= 0.5 :                  D86 [ i ] += y    return [ unidades . Temperature ( t , <str> ) for t in D86 ]  @ refDoc ( __doi__ , [ 51 , 29 ] ) def D86_EFV ( Ti , Xi = None , SG = None , reverse = False ) :      if Xi is None :          Xi = [ 0 , 0.1 , 0.3 , 0.5 , 0.7 , 0.9 , 1 ]  if SG is None :          SG = 0.08342 * Ti [ 1 ] ** 0.10731 * Ti [ 3 ] ** 0.26288  a = [ 2.9747 , 1.4459 , 0.8506 , 3.268 , 8.2873 , 10.6266 , 7.9952 ] b = [ 0.8466 , 0.9511 , 1.0315 , 0.8274 , 0.6874 , 0.6529 , 0.6949 ] c = [ 0.4209 , 0.1287 , 0.0817 , 0.6214 , 0.934 , 1.1025 , 1.0737 ] Xmin = [ 0 , 0.1 , 0.3 , 0.5 , 0.7 , 0.9 , 1 ] Xmax = [ 0.1 , 0.3 , 0.5 , 0.7 , 0.9 , 1 , 1.0001 ] A = [ ] B = [ ] C = [ ] for x in Xi :          for xmin , xmax , ai , bi , ci in zip ( Xmin , Xmax , a , b , c ) :              if xmin <= x < xmax :                  A . append ( ai ) B . append ( bi ) C . append ( ci ) break    EFV = [ ] if reverse :          for ai , bi , ci , T in zip ( A , B , C , Ti ) :              EFV . append ( unidades . Temperature ( ( T / ai / SG ** ci ) ** ( 1. / bi ) ) )   else :          for ai , bi , ci , T in zip ( A , B , C , Ti ) :              EFV . append ( unidades . Temperature ( ai * T ** bi * SG ** ci ) )   return EFV  @ refDoc ( __doi__ , [ 52 , 20 , 29 ] ) def SD_TBP ( Ti , Xi = None , SD50 = None ) :      Ti = [ unidades . K2F ( t ) for t in Ti ] if Xi is None :          Xi = [ 0.05 , 0.1 , 0.3 , 0.5 , 0.7 , 0.9 , 0.95 ]  if SD50 is None :          SD50 = Ti [ 3 ]  else :          SD50 = unidades . K2F ( SD50 )  c = [ 0.15779 , 0.011903 , 0.05342 , 0.19861 , 0.31531 , 0.97476 , 0.02172 ] d = [ 1.4296 , 2.0253 , 1.6988 , 1.3975 , 1.2938 , 0.8723 , 1.9733 ] Xmin = [ 0.05 , 0.1 , 0.3 , 0.5 , 0.7 , 0.9 , 0.95 ] Xmax = [ 0.1 , 0.3 , 0.5 , 0.7 , 0.9 , 0.95 , 1.0001 ] C = [ ] D = [ ] for x in Xi :          for xmin , xmax , ci , di in zip ( Xmin , Xmax , c , d ) :              if xmin <= x < xmax :                  C . append ( ci ) D . append ( di ) break    W = [ C [ i ] * ( Ti [ i + 1 ] - T ) ** D [ i ] for i , T in enumerate ( Ti [ : - 1 ] ) ] TBP = [ SD50 ] * len ( Ti ) for i , T in enumerate ( TBP ) :          for y , x in zip ( W [ i : ] , Xi [ i : ] ) :              if Xi [ i ] < 0.5 and x < 0.5 :                  TBP [ i ] -= y   for y , x in zip ( W [ : i ] , Xi [ : i ] ) :              if Xi [ i ] >= 0.5 and x >= 0.5 :                  TBP [ i ] += y    return [ unidades . Temperature ( t , <str> ) for t in TBP ]  @ refDoc ( __doi__ , [ 53 , 29 ] ) def D1160_TBP_10mmHg ( Ti , Xi = None , reverse = False ) :      if Xi is None :          Xi = [ 0.1 , 0.3 , 0.5 , 0.7 , 0.9 , 1 ]  TBP = [ ] for i , T in enumerate ( Ti ) :          if Xi [ i ] >= 0.5 :              TBP . append ( T )  else :              DT = Ti [ i + 1 ] - T if Xi [ i ] >= 0.1 :                  F = 0.3 + 1.2775 * DT - 5.539e-3 * DT ** 2 + 2.7486e-5 * DT ** 3  else :                  F = 2.2566 * DT - 266.2e-4 * DT ** 2 + 1.4093e-4 * DT ** 3  TBP . append ( Ti [ i + 1 ] - F )   return [ unidades . Temperature ( t ) for t in TBP ]  @ refDoc ( __doi__ , [ 20 , 29 ] ) def Tb_Pressure ( T , P , Kw = None , reverse = False ) :      p = unidades . Pressure ( P , <str> ) if p . mmHg < 2 :          Q = ( 6.76156 - 0.987672 * log10 ( p . mmHg ) ) / ( 3000.538 - 43 * log10 ( p . mmHg ) )  elif p . mmHg < 760 :          Q = ( 5.994296 - 0.972546 * log10 ( p . mmHg ) ) / ( 2663.129 - 95.76 * log10 ( p . mmHg ) )  else :          Q = ( 6.412631 - 0.989679 * log10 ( p . mmHg ) ) / ( 2770.085 - 36. * log10 ( p . mmHg ) )  if reverse :          if T < 367 or not Kw :              F = 0  elif T < 478 :              F = - 3.2985 + 0.009 * T * ( Kw - 12 )  else :              F = 1  Tb_ = T - 1.3889 * F * log10 ( p . atm ) Tb = Tb_ / ( 748.1 * Q - Tb_ * ( 0.3861 * Q - 0.00051606 ) )  else :          Tb_ = 748.1 * Q * T / ( 1 + T * ( 0.3861 * Q - 0.00051606 ) ) if Tb_ < 367 or not Kw :              F = 0  elif Tb_ < 478 :              F = - 3.2985 + 0.009 * Tb_ * ( Kw - 12 )  else :              F = 1  Tb = Tb_ + 1.3889 * F * log10 ( p . atm )  return unidades . Temperature ( Tb )  @ refDoc ( __doi__ , [ 54 ] ) def curve_Predicted ( x , T ) :      x = array ( x ) T = array ( T ) p0 = [ T [ 0 ] , 0.1 , 1 ] def errf ( p , xw , Tb ) :          return _Tb_Predicted ( p , xw ) - Tb  p , cov , info , mesg , ier = leastsq ( errf , p0 , args = ( x , T ) , full_output = True ) ss_err = ( info [ <str> ] ** 2 ) . sum ( ) ss_tot = ( ( T - T . mean ( ) ) ** 2 ) . sum ( ) r = 1 - ( ss_err / ss_tot ) return p , r  def _Tb_Predicted ( par , x ) :      return par [ 0 ] + par [ 0 ] * ( par [ 1 ] / par [ 2 ] * log ( 1 / ( 1 - x ) ) ) ** ( 1. / par [ 2 ] )  @ refDoc ( __doi__ , [ 20 ] ) def PourPoint ( SG , Tb , v100 = None ) :      Tb_R = unidades . K2R ( Tb ) v100 = unidades . Diffusivity ( v100 ) . cSt if SG < 0.8 or SG > 1 or Tb_R < 800 or Tb_R > 1500 :          raise NotImplementedError ( <str> )  elif v100 is not None and ( v100 < 2 or v100 > 960 ) :          raise NotImplementedError ( <str> )  if v100 is not None :          PP = 753 + 136 * ( 1 - exp ( - 0.15 * v100 ) ) - 572 * SG + 0.0512 * v100 + 0.139 * Tb_R  else :          PP = 3.85e-8 * Tb_R ** 5.49 * 10 ** - ( 0.712 * Tb . R ** 0.315 + 0.133 * SG ) + 1.4  return unidades . Temperature ( PP , <str> )  @ refDoc ( __doi__ , [ 20 ] ) def AnilinePoint ( SG , Tb ) :      Tb_F = unidades . K2F ( Tb ) Tb_R = unidades . K2R ( Tb ) Kw = Tb_R ** ( 1 / 3 ) / SG if SG < 0.7 or SG > 1 or Tb_F < 200 or Tb_F > 1100 :          raise NotImplementedError ( <str> )  AP = - 1253.7 - 0.139 * Tb_R + 107.8 * Kw + 868.7 * SG return unidades . Temperature ( AP , <str> )  @ refDoc ( __doi__ , [ 20 ] ) def SmokePoint ( SG , Tb ) :      Tb_F = unidades . K2F ( Tb ) Tb_R = unidades . K2R ( Tb ) Kw = Tb_R ** ( 1 / 3 ) / SG if SG < 0.7 or SG > 0.86 or Tb_F < 200 or Tb_F > 550 :          raise NotImplementedError ( <str> )  SP = exp ( - 1.028 + 0.474 * Kw - 0.00168 * Tb_R ) return unidades . Length ( SP , <str> )  @ refDoc ( __doi__ , [ 20 ] ) def FreezingPoint ( SG , Tb ) :      Tb_R = unidades . K2R ( Tb ) Kw = Tb_R ** ( 1 / 3 ) / SG if SG < 0.74 or SG > 0.90 or Tb_R < 725 or Tb_R > 1130 :          raise NotImplementedError ( <str> )  FP = - 2390.42 + 1826 * SG + 122.49 * Kw - 0.135 * Tb_R return unidades . Temperature ( FP , <str> )  @ refDoc ( __doi__ , [ 20 ] ) def CloudPoint ( SG , Tb ) :      Tb_R = unidades . K2R ( Tb ) if SG < 0.77 or SG > 0.93 or Tb_R < 800 or Tb_R > 1225 :          raise NotImplementedError ( <str> )  CP = 10 ** ( - 7.41 + 5.49 * log10 ( Tb_R ) - 0.712 * Tb_R ** 0.315 - 0.133 * SG ) return unidades . Temperature ( CP , <str> )  @ refDoc ( __doi__ , [ 20 ] ) def CetaneIndex ( API , Tb ) :      Tb_F = unidades . K2F ( Tb ) if API < 27 or API > 47 or Tb_F < 360 or Tb_F > 700 :          raise NotImplementedError ( <str> )  CI = 415.26 - 7.673 * API + 0.186 * Tb_F + 3.503 * API * log10 ( Tb_F ) - 193.816 * log10 ( Tb . F ) return unidades . Dimensionless ( CI )  @ refDoc ( __doi__ , [ 20 ] ) def PNA_Riazi ( M , SG , n , d20 = None , VGC = None , CH = None ) :      if d20 is None :          d20 = SG - 4.5e-3 * ( 2.34 - 1.9 * SG )  Ri = n - d20 / 2. m = M * ( n - 1.475 ) if VGC is not None :          if M <= 200 :              a , b , c = - 13.359 , 14.4591 , - 1.41344 d , e , f = 23.9825 , - 23.333 , 0.81517  else :              a , b , c = 2.5737 , 1.0133 , - 3.573 d , e , f = 2.464 , - 3.6701 , 1.96312  xp = a + b * Ri + c * VGC xn = d + e * Ri + f * VGC  elif CH is not None :          if M <= 200 :              xp = 2.57 - 2.877 * SG + 0.02876 * CH xn = 0.52641 - 0.7494 * xp - 0.021811 * m  else :              xp = 1.9842 - 0.27722 * Ri - 0.15643 * CH xn = 0.5977 - 0.761745 * Ri + 0.068048 * CH   else :          raise NotImplementedError ( )  xa = 1 - xp - xn return xp , xn , xa  @ refDoc ( __doi__ , [ 56 , 58 ] ) def PNA_Peng_Robinson ( Nc , M , WABP ) :      WABP_R = unidades . K2R ( WABP ) Tbp = exp ( log ( 1.8 ) + 5.8345183 + 0.84909035e-1 * ( Nc - 6 ) - 0.52635428e-2 * ( Nc - 6 ) ** 2 + 0.21252908e-3 * ( Nc - 6 ) ** 3 - 0.44933363e-5 * ( Nc - 6 ) ** 4 + 0.37285365e-7 * ( Nc - 6 ) ** 5 ) Tbn = exp ( log ( 1.8 ) + 5.8579332 + 0.79805995e-1 * ( Nc - 6 ) - 0.43098101e-2 * ( Nc - 6 ) ** 2 + 0.14783123e-3 * ( Nc - 6 ) ** 3 - 0.27095216e-5 * ( Nc - 6 ) ** 4 + 0.19907794e-7 * ( Nc - 6 ) ** 5 ) Tba = exp ( log ( 1.8 ) + 5.867176 + 0.80436947e-1 * ( Nc - 6 ) - 0.47136506e-2 * ( Nc - 6 ) ** 2 + 0.18233365e-3 * ( Nc - 6 ) ** 3 - 0.38327239e-5 * ( Nc - 6 ) ** 4 + 0.32550576e-7 * ( Nc - 6 ) ** 5 ) Mp = 14.026 * Nc + 2.016 Mn = 14.026 * Nc - 14.026 Ma = 14.026 * Nc - 20.074 a = [ [ 1 , 1 , 1 ] , [ Tbp * Mp , Tbn * Mn , Tba * Ma ] , [ Mp , Mn , Ma ] ] b = [ 1 , M * WABP_R , M ] Xp , Xn , Xa = solve ( a , b ) return Xp , Xn , Xa  @ refDoc ( __doi__ , [ 56 , 57 ] ) def PNA_Bergman ( Tb , SG , Kw ) :      Tb_F = unidades . K2F ( Tb ) Xwa = 8.47 - Kw gp = 0.582486 + 0.00069481 * Tb_F - 0.7572818e-6 * Tb_F ** 2 + 0.3207736e-9 * Tb_F ** 3 gn = 0.694208 + 0.0004909267 * Tb_F - 0.659746e-6 * Tb_F ** 2 + 0.330966e-9 * Tb_F ** 3 ga = 0.916103 - 0.000250418 * Tb_F + 0.357967e-6 * Tb_F ** 2 - 0.166318e-9 * Tb_F ** 3 a = [ [ 1 , 1 ] , [ 1 / gp , 1 / gn ] ] b = [ 1 - Xwa , 1 / SG - Xwa / ga ] Xwp , Xwn = solve ( a , b ) return Xwp , Xwn , Xwa  @ refDoc ( __doi__ , [ 55 , 29 ] ) def PNA_van_Nes ( M , n , d20 , S ) :      v = 2.51 * ( n - 1.475 ) - ( d20 - 0.851 ) w = ( d20 - 0.851 ) - 1.11 * ( n - 1.475 ) if v > 0 :          a = 430  else :          a = 670  if w > 0 :          CR = 820 * w - 3 * S + 10000. / M  else :          CR = 1440 * w - 3 * S + 10600. / M  Ca = a * v + 3660 / M Cn = CR - Ca Cp = 100 - CR return Cp / 100. , Cn / 100. , Ca / 100.  @ refDoc ( __doi__ , [ 20 ] ) def viscoAPI ( Tb = None , Kw = None , v100 = None , v210 = None , T = None , T1 = None , T2 = None ) :      if v100 is None or v210 is None :          Tb_R = unidades . K2R ( Tb )  if v100 is None :          mu_ref = 10 ** ( - 1.35579 + 8.16059e-4 * Tb_R + 8.38505e-7 * Tb_R ** 2 ) A1 = 34.931 - 8.84387e-2 * Tb_R + 6.73513e-5 * Tb_R ** 2 - 1.01394e-8 * Tb_R ** 3 A2 = - 2.92649 + 6.98405e-3 * Tb_R - 5.09947e-6 * Tb_R ** 2 + 7.49378e-10 * Tb_R ** 3 mu_cor = 10 ** ( A1 + A2 * Kw ) v100 = unidades . Diffusivity ( mu_ref + mu_cor , <str> )  else :          v100 = unidades . Diffusivity ( v100 )  if v210 is None :          mu = 10 ** ( - 1.92353 + 2.41071e-4 * Tb_R + 0.5113 * log10 ( Tb_R * v100 . cSt ) ) v210 = unidades . Diffusivity ( mu , <str> )  else :          v210 = unidades . Diffusivity ( v210 )  vs = { } vs [ <str> ] = v100 vs [ <str> ] = v210 if T is not None :          T_R = unidades . K2R ( T ) if T1 is None :              T1 = unidades . Temperature ( 100 , <str> )  T1_R = T1 . R if T2 is None :              T2 = unidades . Temperature ( 210 , <str> )  T2_R = T2 . R Z1 = v100 . cSt + 0.7 + exp ( - 1.47 - 1.84 * v100 . cSt - 0.51 * v100 . cSt ** 2 ) Z2 = v210 . cSt + 0.7 + exp ( - 1.47 - 1.84 * v210 . cSt - 0.51 * v210 . cSt ** 2 ) B = ( log10 ( log10 ( Z1 ) ) - log10 ( log10 ( Z2 ) ) ) / ( log10 ( T1_R ) - log10 ( T2_R ) ) Z = 10 ** ( 10 ** ( log10 ( log10 ( Z1 ) ) + B * ( log10 ( T_R ) - log10 ( T1_R ) ) ) ) mu = Z - 0.7 - exp ( - 0.7487 - 3.295 * ( Z - 0.7 ) + 0.6119 * ( Z - 0.7 ) ** 2 - 0.3191 * ( Z - 0.7 ) ** 3 ) vs [ <str> ] = unidades . Diffusivity ( mu , <str> )  return vs  @ refDoc ( __doi__ , [ 20 , 30 ] ) def SUS ( T , v ) :      t_F = unidades . K2F ( T ) U100 = 4.6324 * v + ( 1 + 0.03264 * v ) / ( 3930.2 + 262.7 * v + 23.97 * v ** 2 + 1.646 * v ** 3 ) * 1e5 Ut = ( 1 + 0.000061 * ( t_F - 100 ) ) * U100 return unidades . Time ( Ut )  @ refDoc ( __doi__ , [ 20 , 30 ] ) def SFS ( T , v ) :      if T == 323.15 :          S = 0.4717 * v + 13924 / ( v ** 2 - 72.59 * v + 6816 )  else :          S = 0.4792 * v + 5610 / ( v ** 2 + 2130 )  return unidades . Time ( S )  @ refDoc ( __doi__ , [ 20 , 31 ] ) def MuL_Singh ( T , v100 ) :      t_R = unidades . K2R ( T ) S = 0.28008 * log10 ( v100 ) + 1.8616 B = log10 ( v100 ) + 0.86960 mu = 10 ** ( B * ( 559.67 / t_R ) ** S - 0.86960 ) return unidades . Diffusivity ( mu , <str> )  @ refDoc ( __doi__ , [ 29 ] ) def H_Riazi ( S , CH ) :      H = ( 100 - S ) / ( 1 + CH ) return H  @ refDoc ( __doi__ , [ 60 ] ) def H_Goossens ( M , n , d20 ) :      H = 30.346 + ( 82.952 - 65.341 * n ) / d20 - 306 / M return H  @ refDoc ( __doi__ , [ 29 , 62 ] ) def H_ASTM ( Tb , SG , xa ) :      H = ( 5.2407 + 0.01448 * Tb - 7.018 * xa ) / SG - 0.901 * xa + 0.01298 * xa * Tb - 0.01345 * Tb + 5.6879 return H  @ refDoc ( __doi__ , [ 61 ] ) def H_Jenkins_Walsh ( SG , anilineP ) :      H = 11.17 - 12.89 * SG + 0.0389 * anilineP return H  @ refDoc ( __doi__ , [ 59 ] ) def S_Riazi ( M , SG , Ri , m ) :      if M < 200 :          S = 177.448 - 170.946 * Ri + 0.2258 * m + 4.054 * SG  else :          S = - 58.02 + 38.463 * Ri - 0.023 * m + 22.4 * SG  return S  @ refDoc ( __doi__ , [ 20 ] ) def CombustionHeat ( API , water = 0 , ash = 0 , S = 0 ) :      if API < 35 :          _api = [ 0 , 5 , 10 , 15 , 20 , 15 , 30 , 35 ] _S = [ 2.95 , 2.35 , 1.8 , 1.35 , 1. , 0.7 , 0.4 , 0.3 ] _ash = [ 1.15 , 1. , 0.95 , 0.85 , 0.75 , 0.7 , 0.65 , 0.6 ] S -= interp1d ( _api , _S ) ( API ) ash -= interp1d ( _api , _ash ) ( API )  hg = 17672 + 66.6 * API - 0.316 * API ** 2 - 0.0014 * API ** 3 hgc = unidades . Enthalpy ( hg - 0.01 * hg * ( water + S + ash ) + 40.5 * S , <str> ) hn = 16796 + 54.5 * API - 0.217 * API ** 2 - 0.0019 * API ** 3 hnc = hn - 0.01 * hn * ( water + S + ash ) + 40.5 * S - 10.53 * water hnc = unidades . Enthalpy ( hnc , <str> ) return hgc , hnc  class Petroleo ( newComponente ) :      kwargs = { <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 0 , <str> : <str> , <str> : <str> , <str> : [ ] , <str> : [ ] , <str> : 101325 , <str> : [ ] } status = 0 _bool = False msg = <str> definicion = 0 calculatedMethod = { } CURVE_TYPE = [ <str> , <str> , <str> , <str> , <str> ] METHODS_PNA = [ <str> , <str> , <str> , <str> ] METHODS_M = [ <str> , <str> , <str> , <str> , <str> , <str> ] METHODS_Tb = [ <str> , <str> , <str> , <str> , <str> , <str> ] METHODS_SG = [ <str> , <str> ] METHODS_w = [ <str> , <str> , <str> , <str> , <str> ] METHODS_crit = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] METHODS_Vc = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] METHODS_n = [ <str> , <str> , <str> ] METHODS_H = [ <str> , <str> , <str> , <str> ] METHODS_Zc = [ <str> , <str> , <str> , <str> , <str> ] def __init__ ( self , ** kwargs ) :          self . Preferences = ConfigParser ( ) self . Preferences . read ( conf_dir + <str> ) self . __call__ ( ** kwargs )  def __call__ ( self , ** kwargs ) :          self . kwargs . update ( kwargs ) if kwargs :              self . _bool = True  if self . isCalculable ( ) :              self . calculo ( )   def isCalculable ( self ) :          self . status = 0 self . msg = QApplication . translate ( <str> , <str> ) self . hasSG = self . kwargs [ <str> ] or self . kwargs [ <str> ] or ( self . kwargs [ <str> ] and self . kwargs [ <str> ] ) self . hasRefraction = self . kwargs [ <str> ] or self . kwargs [ <str> ] self . hasCurve = self . kwargs [ <str> ] and self . kwargs [ <str> ] and self . kwargs [ <str> ] if self . hasCurve or ( self . kwargs [ <str> ] and self . hasSG ) :              self . definicion = 1  elif self . kwargs [ <str> ] and self . hasSG :              self . definicion = 2  elif self . kwargs [ <str> ] and self . hasRefraction :              self . definicion = 3  elif self . kwargs [ <str> ] and self . hasRefraction :              self . definicion = 4  elif self . kwargs [ <str> ] and self . kwargs [ <str> ] :              self . definicion = 5  elif self . kwargs [ <str> ] and self . kwargs [ <str> ] :              self . definicion = 6  elif self . kwargs [ <str> ] and self . hasRefraction :              self . definicion = 7  elif self . kwargs [ <str> ] :              self . definicion = 8  if self . definicion :              self . status = 1 self . msg = <str> return True   def calculo ( self ) :          self . formula = <str> self . cp = [ ] self . Vliq = 0 self . rackett = 0 self . Tf = 0 self . Hf = 0 self . Gf = 0 if self . hasCurve :              if self . kwargs [ <str> ] :                  parCurva = self . kwargs [ <str> ]  else :                  x = self . kwargs [ <str> ] T = self . kwargs [ <str> ] parCurva , r = curve_Predicted ( x , T )  curva = [ ] for x in [ 0 , 5 , 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 95 , 99 ] :                  if x / 100 in self . kwargs [ <str> ] :                      index = self . kwargs [ <str> ] . index ( x / 100 ) T = self . kwargs [ <str> ] [ index ]  else :                      T = _Tb_Predicted ( parCurva , x / 100 )  curva . append ( unidades . Temperature ( T ) )  if self . kwargs [ <str> ] == <str> :                  a , b , c = 0.08342 , 0.10731 , 0.26288  elif self . kwargs [ <str> ] == <str> :                  a , b , c = 0.10431 , 0.12550 , 0.26288  elif self . kwargs [ <str> ] == <str> :                  a , b , c = 0.09138 , - 0.0153 , 0.36844  else :                  pass  self . SG = a * curva [ 2 ] ** b * curva [ 6 ] ** c P = unidades . Pressure ( 10 , <str> ) Pcurve = self . kwargs [ <str> ] X = self . kwargs [ <str> ] if self . kwargs [ <str> ] == <str> :                  self . D86 = curva self . TBP = self . _D86_TBP ( curva , X ) self . EFV = D86_EFV ( curva , X , self . SG ) self . SD = None TBP_10mHg = [ Tb_Pressure ( t , P , reverse = True ) for t in self . TBP ] D1160_10mHg = D1160_TBP_10mmHg ( TBP_10mHg , reverse = True ) self . D1160 = [ Tb_Pressure ( t , P ) for t in D1160_10mHg ]  elif self . kwargs [ <str> ] :                  if Pcurve == 101325 :                      self . TBP = curva TBP_10mmHg = [ Tb_Pressure ( t , P , reverse = True ) for t in self . TBP ]  else :                      self . TBP = [ Tb_Pressure ( t , Pcurve ) for t in curva ] if Pcurve == P :                          TBP_10mmHg = curva  else :                          TBP_10mmHg = [ Tb_Pressure ( t , P , reverse = True ) for t in self . TBP ]   self . D86 = self . _D86_TBP ( curva , X , reverse = True ) self . EFV = D86_EFV ( self . D86 , X , self . SG ) self . SD = None D1160_10mmHg = D1160_TBP_10mmHg ( TBP_10mmHg , reverse = True ) self . D1160 = [ Tb_Pressure ( t , 10. / 760 ) for t in D1160_10mmHg ]  elif self . kwargs [ <str> ] :                  self . SD = curva self . D86 = self . _SD_D86 ( curva , X ) self . TBP = SD_TBP ( curva , X ) self . EFV = D86_EFV ( self . D86 , X , self . SG ) TBP_10mmHg = [ Tb_Pressure ( t , P , True ) for t in self . TBP ] D1160_10mmHg = D1160_TBP_10mmHg ( TBP_10mmHg , reverse = True ) self . D1160 = [ Tb_Pressure ( t , P ) for t in D1160_10mmHg ]  elif self . kwargs [ <str> ] :                  if Pcurve == 101325 :                      self . EFV = curva  else :                      self . EFV = [ Tb_Pressure ( t , Pcurve ) for t in curva ]  self . D86 = D86_EFV ( curva , X , self . SG , reverse = True ) self . SD = None self . TBP = self . _D86_TBP ( self . D86 , X ) TBP_10mmHg = [ Tb_Pressure ( t , P , True ) for t in self . TBP ] D1160_10mmHg = D1160_TBP_10mmHg ( TBP_10mmHg , reverse = True ) self . D1160 = [ Tb_Pressure ( t , P ) for t in D1160_10mmHg ]  else :                  if Pcurve == P :                      D1160_10mmHg = curva self . D1160 = [ Tb_Pressure ( t , P ) for t in D1160_10mmHg ]  elif Pcurve == 101325 :                      self . D1160 = curva D1160_10mmHg = [ Tb_Pressure ( t , P , True ) for t in curva ]  else :                      self . D1160 = [ Tb_Pressure ( t , Pcurve ) for t in curva ] D1160_10mmHg = [ Tb_Pressure ( t , P , reverse = True ) for t in self . D1160 ]  TBP_10mmHg = D1160_TBP_10mmHg ( D1160_10mmHg ) self . TBP = [ Tb_Pressure ( t , P ) for t in TBP_10mmHg ] self . D86 = self . _D86_TBP ( self . TBP , X , reverse = True ) self . EFV = D86_EFV ( self . D86 , X , self . SG ) self . SD = None  self . T5 = self . D86 [ 1 ] self . T10 = self . D86 [ 2 ] self . T20 = self . D86 [ 3 ] self . T30 = self . D86 [ 4 ] self . T40 = self . D86 [ 5 ] self . T50 = self . D86 [ 6 ] self . T60 = self . D86 [ 7 ] self . T70 = self . D86 [ 8 ] self . T80 = self . D86 [ 9 ] self . T90 = self . D86 [ 10 ] self . VABP = unidades . Temperature ( ( self . T10 + self . T30 + self . T50 + self . T70 + self . T90 ) / 5. ) SL = ( self . T90 . F - self . T10 . F ) / 80. DT1 = - 3.062123 - 0.01829 * ( self . VABP . F - 32 ) ** 0.6667 + 4.45818 * SL ** 0.25 DT2 = - 0.56379 - 0.007981 * ( self . VABP . F - 32 ) ** 0.6667 + 3.04729 * SL ** 0.333 DT3 = - 0.23589 - 0.06906 * ( self . VABP . F - 32 ) ** 0.45 + 1.8858 * SL ** 0.45 DT4 = - 0.94402 - 0.00865 * ( self . VABP . F - 32 ) ** 0.6667 + 2.99791 * SL ** 0.333 self . WABP = unidades . Temperature ( self . VABP . F + exp ( DT1 ) , <str> ) self . MABP = unidades . Temperature ( self . VABP . F - exp ( DT2 ) , <str> ) self . CABP = unidades . Temperature ( self . VABP . F - exp ( DT3 ) , <str> ) self . MeABP = unidades . Temperature ( self . VABP . F - exp ( DT4 ) , <str> ) self . Tb = self . MeABP ReidVP = 3.3922 - 0.02537 * self . T5 . C - 0.070739 * self . T10 . C + .00917 * self . T30 . C - .0393 * self . T50 . C + 6.8257e-4 * self . T10 . C ** 2 self . ReidVP = unidades . Pressure ( ReidVP , <str> ) self . VL_12 = 88.5 - 0.19 * self . T70 - 42.5 * self . ReidVP . bar self . VL_20 = 90.6 - 0.25 * self . T70 - 39.2 * self . ReidVP . bar self . VL_36 = 94.7 - 0.36 * self . T70 - 32.3 * self . ReidVP . bar self . CVLI = 4.27 + 0.24 * self . T70 + 0.069 * self . ReidVP . bar self . FVI = 1000 * self . ReidVP . bar + 7 * self . T70 self . FlashPc = unidades . Temperature ( 0.69 * self . T10 . F - 118.2 , <str> ) self . FlashPo = unidades . Temperature ( 0.68 * self . T10 . F - 109.6 , <str> )  if self . definicion == 8 :              prop = prop_Ahmed ( self . kwargs [ <str> ] ) self . M = prop [ <str> ] self . Tc = prop [ <str> ] self . Pc = prop [ <str> ] self . Vc = prop [ <str> ] self . Tb = prop [ <str> ] self . f_acent = prop [ <str> ] self . SG = prop [ <str> ] self . API = 141.5 / self . SG - 131.5 self . d20 = self . SG - 4.5e-3 * ( 2.34 - 1.9 * self . SG )  else :              if self . kwargs [ <str> ] :                  self . Tb = unidades . Temperature ( self . kwargs [ <str> ] )  if self . kwargs [ <str> ] :                  self . M = self . kwargs [ <str> ]  if self . hasSG :                  if self . kwargs [ <str> ] :                      self . SG = self . kwargs [ <str> ]  elif self . kwargs [ <str> ] :                      self . SG = 141.5 / ( self . kwargs [ <str> ] + 131.5 )  elif self . kwargs [ <str> ] and self . kwarg [ <str> ] :                      self . SG = self . Tb . R ** ( 1. / 3 ) / self . kwargs [ <str> ]  self . API = 141.5 / self . SG - 131.5 self . d20 = self . SG - 4.5e-3 * ( 2.34 - 1.9 * self . SG )  if self . hasRefraction :                  if self . kwargs [ <str> ] :                      self . n = self . kwargs [ <str> ]  else :                      I = self . kwargs [ <str> ] self . n = ( ( 1 + 2 * I ) / ( 1 - I ) ) ** 0.5  self . I = ( self . n ** 2 - 1 ) / ( self . n ** 2 + 2 )  if self . kwargs [ <str> ] :                  self . CH = self . kwargs [ <str> ]  if self . kwargs [ <str> ] :                  self . v100 = unidades . Diffusivity ( self . kwargs [ <str> ] )  if self . kwargs [ <str> ] :                  self . v210 = unidades . Diffusivity ( self . kwargs [ <str> ] )   if not self . kwargs [ <str> ] :              self . M = self . _M ( )  if not self . kwargs [ <str> ] :              self . Tb = self . _Tb ( )  if self . kwargs [ <str> ] :              self . Kw = self . kwargs [ <str> ]  else :              self . Kw = self . Tb . R ** ( 1. / 3 ) / self . SG  if not self . hasSG :              self . SG = self . _SG ( ) self . API = 141.5 / self . SG - 131.5  if not self . hasRefraction :              self . n , self . I = self . _n ( )  if not self . kwargs [ <str> ] :              self . CH = self . _CH ( )  self . Tc , self . Pc = self . _critic ( ) self . Vc = self . _Vc ( ) self . f_acent = self . _f_acent ( ) self . Zc = self . _Zc ( ) if not self . kwargs [ <str> ] and not self . kwargs [ <str> ] :              visco = viscoAPI ( self . Tb , self . Kw ) self . v100 = visco [ <str> ] self . v210 = visco [ <str> ]  elif not self . kwargs [ <str> ] :              visco = viscoAPI ( self . Tb , self . Kw , v100 = self . kwargs [ <str> ] ) self . v210 = visco [ <str> ]  else :              visco = viscoAPI ( self . Tb , self . Kw ) self . v100 = visco [ <str> ]  if self . kwargs [ <str> ] and not self . kwargs [ <str> ] :              T = unidades . Temperature ( 210 , <str> ) vSUS = SUS ( T , self . v210 . cSt ) self . VGC = ( self . SG - 0.24 - 0.022 * log10 ( vSUS - 35.5 ) )  else :              T = unidades . Temperature ( 100 , <str> ) vSUS = SUS ( T , self . v100 . cSt ) self . VGC = ( 10 * self . SG - 1.0752 * log10 ( vSUS - 38 ) ) / ( 10 - log10 ( vSUS - 38 ) )  if not self . hasSG :              self . d20 = self . SG - 4.5e-3 * ( 2.34 - 1.9 * self . SG )  self . Ri = self . n - self . d20 / 2. self . m = self . M * ( self . n - 1.475 ) self . VI = self . Viscosity_Index ( ) try :              self . PourP = PourPoint ( self . SG , self . Tb , self . v100 )  except NotImplementedError :              self . PourP = None  try :              self . CloudP = CloudPoint ( self . SG , self . Tb )  except NotImplementedError :              self . CloudP = None  try :              self . FreezingP = FreezingPoint ( self . SG , self . Tb )  except NotImplementedError :              self . FreezingP = None  try :              self . AnilineP = AnilinePoint ( self . SG , self . Tb ) self . DieselI = self . API * self . AnilineP . F / 100.  except NotImplementedError :              self . AnilineP = None self . DieselI = None  try :              self . SmokeP = SmokePoint ( self . SG , self . Tb )  except NotImplementedError :              self . SmokeP = None  try :              self . CetaneI = CetaneIndex ( self . API , self . Tb )  except NotImplementedError :              self . CetaneI = None  if self . kwargs [ <str> ] :              self . S = self . kwargs [ <str> ]  else :              self . S = S_Riazi ( self . M , self . SG , self . Ri , self . m )  if self . kwargs [ <str> ] :              self . H = self . kwargs [ <str> ]  else :              self . H = self . _H ( )  self . N = self . kwargs [ <str> ] HC = 11.9147 / self . CH CCR = 148 - 86.96 / HC if CCR < 0 :              CCR = 0  elif CCR > 100 :              CCR = 100  self . CCR = unidades . Dimensionless ( CCR ) self . NetHeating , self . GrossHeating = CombustionHeat ( self . API , S = self . S ) newComponente . calculo ( self )  def tr ( self , T ) :          return T / self . Tc  def pr ( self , P ) :          return P / self . Pc . atm  def _M ( self ) :          if self . definicion != 1 :              methodIndex = 0  else :              methodIndex = self . Preferences . getint ( <str> , <str> )  methods = [ prop_Riazi_Daubert , prop_Riazi_Daubert_1980 , prop_Lee_Kesler , prop_Sim_Daubert , M_Goossens , prop_Twu ] method = methods [ methodIndex ] if method . __name__ not in self . calculatedMethod :              self . calculateMethod ( method )  M = self . calculatedMethod [ method . __name__ ] [ <str> ] return unidades . Dimensionless ( M )  def _critic ( self ) :          methodIndex = self . Preferences . getint ( <str> , <str> ) if methodIndex in [ 1 , 2 , 3 , 4 , 10 , 11 ] and self . definicion != 1 :              methodIndex = 0  if methodIndex in [ 7 , 9 ] and self . definicion != 2 :              methodIndex = 0  if methodIndex in [ 6 , 12 ] and not self . kwargs [ <str> ] :              methodIndex = 0  if methodIndex == 8 and not self . kwargs [ <str> ] :              methodIndex = 0  if methodIndex in [ 13 , 14 ] and self . definicion not in [ 1 , 2 ] :              methodIndex = 0  methods = [ prop_Riazi_Daubert , prop_Riazi_Daubert_1980 , prop_Cavett , prop_Lee_Kesler , prop_Sim_Daubert , prop_Watansiri_Owens_Starling , prop_Rowe , prop_Standing , prop_Willman_Teja , prop_Magoulas_Tassios , prop_Tsonopoulos , prop_Twu , prop_Sancet , prop_Riazi , prop_Riazi_Alsahhaf ] method = methods [ methodIndex ] if method . __name__ not in self . calculatedMethod :              self . calculateMethod ( method )  Tc = self . calculatedMethod [ method . __name__ ] [ <str> ] Pc = self . calculatedMethod [ method . __name__ ] [ <str> ] return unidades . Temperature ( Tc ) , unidades . Pressure ( Pc )  def _Vc ( self ) :          methodIndex = self . Preferences . getint ( <str> , <str> ) if methodIndex in [ 1 , 2 , 4 ] and self . definicion != 1 :              methodIndex = 0  if methodIndex == 5 and self . definicion != 2 :              methodIndex = 0  if methodIndex in [ 3 , 6 , 7 ] and self . definicion not in [ 1 , 2 ] :              methodIndex = 0  methods = [ prop_Riazi_Daubert , prop_Riazi_Daubert_1980 , prop_Watansiri_Owens_Starling , prop_Twu , vc_Hall_Yarborough , prop_Riazi , prop_Riazi_Alsahhaf ] method = methods [ methodIndex ] if method . __name__ not in self . calculatedMethod :              self . calculateMethod ( method )  Vc = self . calculatedMethod [ method . __name__ ] [ <str> ] return unidades . SpecificVolume ( Vc )  def _f_acent ( self ) :          methodIndex = self . Preferences . getint ( <str> , <str> ) methods = [ prop_Edmister , prop_Lee_Kesler , w_Korsten , prop_Watansiri_Owens_Starling , prop_Magoulas_Tassios ] method = methods [ methodIndex ] if method . __name__ not in self . calculatedMethod :              self . calculateMethod ( method )  w = self . calculatedMethod [ method . __name__ ] [ <str> ] return unidades . Dimensionless ( w )  def _Tb ( self ) :          methodIndex = self . Preferences . getint ( <str> , <str> ) if self . definicion not in [ 1 , 2 ] and methodIndex > 1 :              methodIndex = 0  methods = [ prop_Riazi_Daubert , prop_Riazi , prop_Rowe , prop_Sancet , prop_Silva_Rodriguez , Tb_Soreide ] method = methods [ methodIndex ] if method . __name__ not in self . calculatedMethod :              self . calculateMethod ( method )  Tb = self . calculatedMethod [ method . __name__ ] [ <str> ] return unidades . Temperature ( Tb )  def _SG ( self ) :          methodIndex = self . Preferences . getint ( <str> , <str> ) if methodIndex == 1 and not self . kwargs [ <str> ] :              methodIndex = 0  methods = [ prop_Riazi_Daubert , prop_Silva_Rodriguez ] method = methods [ methodIndex ] if method . __name__ not in self . calculatedMethod :              self . calculateMethod ( method )  SG = self . calculatedMethod [ method . __name__ ] [ <str> ] return unidades . Dimensionless ( SG )  def _n ( self ) :          methodIndex = self . Preferences . getint ( <str> , <str> ) if methodIndex == 2 and not self . kwargs [ <str> ] :              methodIndex = 0  if self . definicion not in [ 1 , 2 ] and methodIndex == 1 :              methodIndex = 0  methods = [ prop_Riazi_Daubert , prop_Willman_Teja , prop_Riazi ] method = methods [ methodIndex ] if method . __name__ not in self . calculatedMethod :              self . calculateMethod ( method )  if method == prop_Willman_Teja :              n = self . calculatedMethod [ method . __name__ ] [ <str> ] I = ( n ** 2 - 1 ) / ( n ** 2 + 2 )  else :              I = self . calculatedMethod [ method . __name__ ] [ <str> ] n = ( ( 1 + 2 * I ) / ( 1 - I ) ) ** 0.5  return unidades . Dimensionless ( n ) , unidades . Dimensionless ( I )  def _CH ( self ) :          method = prop_Riazi_Daubert if method . __name__ not in self . calculatedMethod :              self . calculateMethod ( method )  CH = self . calculatedMethod [ method . __name__ ] [ <str> ] return unidades . Dimensionless ( CH )  def calculateMethod ( self , method ) :          Tb_SG = [ prop_Riazi_Daubert_1980 , prop_Lee_Kesler , prop_Sim_Daubert , prop_Twu ] M_SG = [ prop_Standing , prop_Magoulas_Tassios , Tb_Soreide , vc_Hall_Yarborough ] M = [ prop_Rowe , prop_Sancet , prop_Silva_Rodriguez ] if method == prop_Riazi_Daubert :              if self . definicion in [ 1 , 8 ] :                  prop = prop_Riazi_Daubert ( <str> , self . Tb , <str> , self . SG )  elif self . definicion == 2 :                  prop = prop_Riazi_Daubert ( <str> , self . M , <str> , self . SG )  elif self . definicion == 3 :                  prop = prop_Riazi_Daubert ( <str> , self . Tb , <str> , self . I )  elif self . definicion == 4 :                  prop = prop_Riazi_Daubert ( <str> , self . M , <str> , self . I )  elif self . definicion == 5 :                  prop = prop_Riazi_Daubert ( <str> , self . Tb , <str> , self . CH )  elif self . definicion == 6 :                  prop = prop_Riazi_Daubert ( <str> , self . M , <str> , self . CH )  elif self . definicion == 7 :                  prop = prop_Riazi_Daubert ( <str> , self . v100 , <str> , self . I )   elif method == prop_Riazi :              if self . definicion in [ 1 , 8 ] :                  prop = prop_Riazi ( self . SG , <str> , self . Tb )  elif self . definicion == 2 :                  prop = prop_Riazi ( self . SG , <str> , self . M )   elif method == prop_Cavett :              prop = prop_Cavett ( self . Tb , self . API )  elif method == M_Goossens :              prop = M_Goossens ( self . Tb , self . d20 )  elif method == prop_Willman_Teja :              prop = prop_Willman_Teja ( self . Tb )  elif method == prop_Watansiri_Owens_Starling :              prop = prop_Watansiri_Owens_Starling ( self . Tb , self . SG , self . M )  elif method == prop_Riazi_Alsahhaf :              prop = prop_Riazi_Alsahhaf ( self . Tb , self . M , self . d20 )  elif method == prop_Edmister :              prop = prop_Edmister ( Tb = self . Tb , Tc = self . Tc , Pc = self . Pc )  elif method in Tb_SG :              prop = method ( self . Tb , self . SG )  elif method in M_SG :              prop = method ( self . M , self . SG )  elif method in M :              prop = method ( self . M )  self . calculatedMethod [ method . __name__ ] = prop  def _Zc ( self ) :          methods = [ Zc_Lee_Kesler , Zc_Salerno , Zc_Nath , Zc_Reid , Zc_Hougen ] Zc = methods [ self . Preferences . getint ( <str> , <str> ) ] return Zc ( self . f_acent )  def _H ( self ) :          if self . Preferences . getint ( <str> , <str> ) == 0 :              H = H_Riazi ( self . S , self . CH )  elif self . Preferences . getint ( <str> , <str> ) == 1 :              H = H_Goossens ( self . M , self . n , self . d20 )  elif self . Preferences . getint ( <str> , <str> ) == 2 :              if self . hasCurve :                  Tb = ( self . T10 + self . T50 + self . T90 ) / 3.  else :                  Tb = self . Tb  H = H_ASTM ( Tb , self . SG , self . xa )  else :              H = H_Jenkins_Walsh ( self . SG , self . AnilineP )  return H  def _D86_TBP ( self , D86 , reverse = False ) :          index = self . Preferences . getint ( <str> , <str> ) method = [ D86_TBP_Riazi , D86_TBP_Daubert ] [ index ] TBP = method ( D86 , reverse ) return TBP  def _SD_D86 ( self , SD ) :          index = self . Preferences . getint ( <str> , <str> ) method = [ SD_D86_Riazi , SD_D86_Daubert ] [ index ] D86 = method ( SD ) return D86  def _PNA ( self ) :          if self . Preferences . getint ( <str> , <str> ) == 0 :              xp , xn , xa = PNA_Riazi ( self . M , self . SG , self . n , d20 = None , VGC = self . VGC , CH = None )  elif self . Preferences . getint ( <str> , <str> ) == 1 :              xp , xn , xa = PNA_Bergman ( self . Tb , self . SG , self . Kw )  elif self . Preferences . getint ( <str> , <str> ) == 2 :              xp , xn , xa = PNA_Peng_Robinson ( self . Nc , self . M , self . WABP )  else :              xp , xn , xa = PNA_van_Nes ( self . M , self . n , self . d20 , self . S )  return xp , xn , xa  def Pv_Maxwell_Bonnell ( self , T , mod = False ) :          if mod :              if self . Tb <= 366.5 :                  F1 = 0  else :                  F1 = - 1 + 0.009 * ( self . Tb - 255.37 )  F2 = ( self . watson - 12 ) - 0.01304 * ( self . watson - 12 ) ** 2  else :              if self . Tb < 367 :                  F = 0  elif self . Tb < 478 :                  F = - 3.2985 + 0.0009 * self . Tb  else :                  F = - 3.2985 + 0.009 * self . Tb   pvap = 0. pvapcalc = 1. while abs ( pvap - pvapcalc ) < 1e-6 :              pvap = pvapcalc if mod :                  if pvap <= 760 :                      F3 = 1.47422 * log10 ( pvap / 760. )  else :                      F3 = 1.47422 * log10 ( pvap / 760. ) + 1.190833 * ( log10 ( pvap / 760. ) ) ** 2  DTb = F1 * F2 * F3  else :                  DTb = 1.3889 * F * ( self . watson - 12 ) * log10 ( pvap / 760. )  Tb_ = self . Tb - DTb Q = ( Tb_ / T - 0.00051606 * Tb_ ) / ( 748.1 - 0.3861 * Tb_ ) if Q > 0.0022 :                  pvapcalc = 10 ** ( ( 3000.538 * Q - 6.76156 ) / ( 43 * Q - 0.987672 ) )  elif Q >= 0.0013 :                  pvapcalc = 10 ** ( ( 2663.129 * Q - 5.994296 ) / ( 95.76 * Q - 0.972546 ) )  else :                  pvapcalc = 10 ** ( ( 2770.085 * Q - 6.412631 ) / ( 36 * Q - 0.989679 ) )   return unidades . Pressure ( pvapcalc , <str> )  def Pv_Tsonopoulos ( self , T ) :          Tr = T / self . tpc A = 5.671485 + 12.439604 * self . f_acent B = 5.809839 + 12.755971 * self . f_acent C = 0.867513 + 9.654169 * self . f_acent D = 0.1383536 + 0.316367 * self . f_acent pr = exp ( A - B / Tr - C * log ( Tr ) + D * Tr ** 6 ) return unidades . Pressure ( pr , <str> )  def Pv_simple ( self , T ) :          pv = 10 ** ( 3.2041 * ( 1. - 0.998 * ( self . Tb - 41 ) / ( self . Tb - 41 ) * ( 1393 - T ) / ( 1393 - self . Tb ) ) ) return unidades . Pressure ( pr , <str> )  def Pv_gasoline ( self , T ) :          t = unidades . Temperature ( T ) SL = ( unidades . Temperature ( self . D86 [ - 3 ] ) . F - unidades . Temperature ( self . D86 [ 1 ] ) . F ) / 15. p = exp ( 1 / t . R * ( 21.36412862 - 6.7769666 * sqrt ( SL ) - 0.93213944 * log ( self . ReidVP . psi ) + 1.42680425 * sqrt ( SL ) * log ( self . ReidVP . psi ) - 0.29458386 * self . ReidVP . psi + ( - 0.00568374 + 0.00577103 * sqrt ( SL ) - 0.00106045 * sqrt ( SL ) * log ( self . ReidVP . psi ) + 0.00060246 * self . ReidVP . psi ) * t . R + ( - 10177.78660360 + 2306.00561642 * sqrt ( SL ) + 1097.68947465 * log ( self . ReidVP . psi ) - 463.19014182 * sqrt ( SL ) * log ( self . ReidVP . psi ) + 65.61239475 * self . ReidVP . psi + 0.13751932 * self . ReidVP . psi ** 2 ) ) ) return unidades . Pressure ( p , <str> )  def Pv_API ( self , T ) :          t = unidades . Temperature ( T ) p = exp ( 7.78511307 - 1.08100387 * log ( self . ReidVP . psi ) + 0.05319502 * self . ReidVP . psi + 0.00451316 * t . R + ( - 5756.85623050 + 1104.41248797 * log ( self . ReidVP . psi ) - 0.00068023 * self . ReidVP . psi ** 4 ) / t . R ) return unidades . Pressure ( p , <str> )  def RhoL ( self , T ) :          t = unidades . Temperature ( T ) rho = 62.3636 * sqrt ( self . SG ** 2 - ( 1.2655 * self . SG - 0.5098 + 8.011e-5 * self . Tb . R ) * ( t . R - 519.67 ) / self . Tb . R ) return unidades . Density ( rho , <str> )  def RhoL_Rackett ( self , T ) :          rho = self . SG * 1000 t = unidades . Temperature ( 60 , <str> ) Zra = ( self . Pc . atm / ( rho / self . M * R_atml * self . Tc ) ) ** ( 1 / ( 1 + ( 1 - t / self . Tc ) ** ( 2. / 7 ) ) ) inv = R_atml * self . Tc / self . Pc . atm * Zra ** ( 1 + ( 1 - T / self . Tc ) ** ( 2. / 7 ) ) return unidades . Density ( 1 / inv * self . M , <str> )  def RhoL_Presion ( self , T , P ) :          rho0 = self . RhoL_Rackett ( T ) p = unidades . Pressure ( P , <str> ) t = unidades . Temperature ( T ) B20 = 10 ** ( - 6.1e-4 * t . F + 4.9547 + 0.7133 * rho0 . kgl ) m = 21646 + 0.0734 * p . psig + 1.4463e-7 * p . psig ** 2 X = ( B20 - 100000 ) / 23170 B1 = 1.52e+4 + 4.704 * p . psig - 2.5807e-5 * p . psig ** 2 + 1.0611e-10 * p . psig ** 3 Bt = m * X + B1 return unidades . Density ( rho0 / ( 1.0 - p . psig / Bt ) )  def Entalpia ( self , T , P ) :          T = unidades . Temperature ( T ) if T < self . Tb and self . tr ( T ) <= 0.8 and self . pr ( P ) < 1. :              A1 = 1e-3 * ( - 1171.26 + ( 23.722 + 24.907 * self . SG ) * self . watson + ( 1149.82 - 46.535 * self . watson ) / self . SG ) A2 = 1e-6 * ( ( 1. + 0.82463 * self . watson ) * ( 56.086 - 13.817 / self . SG ) ) A3 = - 1e-9 * ( ( 1. + 0.82463 * self . watson ) * ( 9.6757 - 2.3653 / self . SG ) ) H = A1 * ( T . R - 259.7 ) + A2 * ( T . R ** 2 - 259.7 ** 2 ) + A3 * ( T . R ** 3 - 259.7 ** 3 )  else :              Hl = self . Entalpia ( 0.8 * self . Tc , 0.1 * self . Pc . atm ) if T < self . Tb :                  H_adimensional_presion = Lee_Kesler_Entalpia_lib ( self . tr ( T ) , self . pr ( P ) , self . f_acent , fase = 1 )  else :                  H_adimensional_presion = Lee_Kesler_Entalpia_lib ( self . tr ( T ) , self . pr ( P ) , self . f_acent , fase = 0 )  if 10. < self . watson < 12.8 and 0.7 < self . SG < 0.885 :                  B4 = ( ( 12.8 / self . watson - 1. ) * ( 1. - 10. / self . watson ) * ( self . SG - 0.885 ) * ( self . SG - 0.7 ) * 1e4 ) ** 2  else :                  B4 = 0  B1 = 1e-3 * ( - 356.44 + 29.72 * self . watson + B4 * ( 295.02 - 248.49 / self . SG ) ) B2 = 1e-6 * ( - 146.24 + ( 77.62 - 2.772 * self . watson ) * self . watson - B4 * ( 301.42 - 253.87 / self . SG ) ) B3 = 1e-9 * ( - 56.487 - 2.95 * B4 ) H = Hl . Btulb + B1 * ( T . R - 0.8 * self . Tc . R ) + B2 * ( T . R ** 2 - 0.64 * self . Tc . R ** 2 ) + B3 * ( T . R ** 3 - 0.512 * self . Tc . R ** 3 ) + R_Btu * self . Tc . R / self . M * ( 4.507 + 5.266 * self . f_acent - H_adimensional_presion )  return unidades . Enthalpy ( H , <str> )  def Cp_liquid_API ( self , T ) :          t = unidades . Temperature ( T ) A1 = - 1.17126 + ( 0.023722 + 0.024907 * self . SG ) * self . watson + ( 1.14982 - 0.046535 * self . watson ) / self . SG A2 = 1e-4 * ( 1 + 0.82463 * self . watson ) * ( 1.12172 - 0.27634 / self . SG ) A3 = - 1e-8 * ( 1 + 0.82463 * self . watson ) * ( 2.9027 - 0.70958 / self . SG ) return unidades . SpecificHeat ( A1 + A2 * t . R + A3 * t . R ** 2 , <str> )  def Cp_liquid_Tsonopoulos ( self , T ) :          cp = ( 0.28299 + 0.23605 * self . watson ) * ( 0.645 - 0.05959 * self . SG + ( 2.32056 - 0.94752 * self . SG ) * ( T / 1000. - 0.25537 ) ) return unidades . SpecificHeat ( cp , <str> )  def Cp_liquid_Kesler_Lee ( self , T ) :          a = 1.4651 + 0.2302 * self . watson b = 0.306469 - 0.16734 * self . SG c = 0.001467 - 0.000551 * self . SG return unidades . SpecificHeat ( a * ( b + c * T ) , <str> )  def Cp_liquid_Bondi ( self , T ) :          Tr = T / self . Tc Cp_ideal cp_adimensional = 1.586 + 0.49 * ( 1 - Tr ) + self . f_acent * ( 4.2775 + 6.3 * ( 1 - Tr ) ** ( 1. / 3 ) / Tr + 0.4355 / ( 1 - Tr ) ) return unidades . SpecificHeat ( cp_adimensional * R + Cp_ideal , <str> )  def Lee_Kesler_lib_Cp ( self , T , P ) :          Tr = self . tr ( T ) vr0 , vrh = self . Lee_Kesler_lib ( T , P . atm , <str> ) E = 0.042724 / 2 / Tr ** 3 / 0.060167 * ( 0.65392 + 1 - ( 0.65392 + 1 + 0.060167 / vr0 ** 2 ) * exp ( - 0.060167 / vr0 ** 2 ) ) Cv0 = - 2 * ( 0.154790 + 3 * 0.030323 / Tr ) / Tr ** 2 / vr0 + 6 * E E = 0.041577 / 2 / Tr ** 3 / 0.03754 * ( 1.226 + 1 - ( 1.226 + 1 + 0.03754 / vrh ** 2 ) * exp ( - 0.03754 / vrh ** 2 ) ) Cvh = - 2 * ( 0.027655 + 3 * 0.203488 / Tr ) / Tr ** 2 / vrh + 3 * 0.016901 / Tr ** 3 / vrh ** 2 + 6 * E return Cv0 , Cvh  def Cp_gas ( self , T , P ) :          if 10. <= self . watson <= 12.8 and 0.70 < self . SG <= 0.885 :              A4 = ( ( 12.8 / self . watson - 1. ) * ( 1. - 10 / self . watson ) * ( self . SG - 0.885 ) * ( self . SG - 0.7 ) * 1e4 ) ** 2  else : A4 = 0 A1 = - 0.35644 + 0.02972 * self . watson + A4 * ( 0.29502 - 0.24846 / self . SG ) A2 = - 1e-4 * ( 2.9247 - ( 1.5524 - 0.05543 * self . watson ) * self . watson + A4 * ( 6.0283 - 5.0694 / self . SG ) ) A3 = - 1e-7 * ( 1.6946 + 0.0844 * A4 ) Cp0 , Cph = self . Lee_Kesler_lib_Cp ( T , P ) Cp_adimensional = Cp0 + self . f_acent / 0.3978 * ( Cph - Cp0 ) return unidades . SpecificHeat ( A1 + A2 * t . R + A3 * t . R ** 2 - R_Btu / self . M * Cp_adimensional , <str> )  def flash ( self ) :          pass  def flash2 ( self ) :          pass  def Tension_API ( self , T ) :          t = unidades . Temperature ( T ) sigma = 673.7 / self . watson * ( ( self . Tc . R - t . R ) / self . Tc . R ) ** 1.232 return unidades . Tension ( sigma , <str> )  def Tension_Baker_Swerdloff ( self , T , P = 1 ) :          t = unidades . Temperature ( T ) p = unidades . Pressure ( P , <str> ) s68 = 39. - 0.2571 * self . API s100 = 37.5 - 0.2571 * self . API if t . F <= 68. :              s = s68  elif t . F < 100 :              s = s68 - ( ( t . F - 68 ) * ( s68 - s100 ) ) / 32  else :              s = s100  F = 1. - 0.024 * p . psi ** 0.45 return unidades . Tension ( F * s , <str> )  def Tension_Tsonopoulos ( self , T ) :          Pa = 1.7237 * self . Tb ** 0.05873 * self . SG ** - 0.64927 rhoL = self . RhoL ( T ) rhoV return unidades . Tension ( ( Pa * ( rhoL - rhoV ) ) ** 4 , <str> )  def Tension_Miqueu ( self , T ) :          Pa = ( 0.85 - 0.19 * self . f_acent ) * self . Tc ** ( 12 / 11. ) / ( self . Pc . bar / 10 ) ** ( 9. / 11 ) rhoL = self . RhoL ( T ) rhoV return unidades . Tension ( ( Pa / self . M * ( rhoL - rhoV ) ) ** ( 11. / 3 ) , <str> )  def Tension_PNA ( self , T ) :          PaP = 27.503 + 2.9963 * self . M PaN = 18.384 + 2.7367 * self . M PaA = 25.511 + 2.8332 * self . M Pa = self . xa * PaA + self . xn * PaN + self . xp * PaP rhoL = self . RhoL ( T ) rhoV return unidades . Tension ( ( Pa / self . M * ( rhoL - rhoV ) ) ** ( 11. / 3 ) , <str> )  def Mu_Singh ( self , T , mu ) :          t = unidades . Temperature ( T ) S = 0.28008 * log10 ( mu ) + 1.8616 B = log10 ( mu ) + 0.86960 return 10 ** ( B * ( 559.67 / t . R ) ** S - 0.86960 )  def V100_API ( self ) :          A1 = 34.9310 - 8.84387e-2 * self . Tb . R + 6.73513e-5 * self . Tb . R ** 2 - 1.01394e-8 * self . Tb . R ** 3 A2 = - 2.92649 + 6.98405e-3 * self . Tb . R - 5.09947e-6 * self . Tb . R ** 2 + 7.49378e-10 * self . Tb . R ** 3 mu_ref = 10 ** ( - 1.35579 + 8.16059e-4 * self . Tb . R + 8.38505e-7 * self . Tb . R ** 2 ) mu_cor = 10 ** ( A1 + A2 * self . watson ) return unidades . Diffusivity ( mu_ref + mu_cor , <str> )  def V210_API ( self ) :          if self . v100 :              v100 = self . v100  else :              v100 = self . V100_API ( )  return unidades . Diffusivity ( 10 ** ( - 1.92353 + 2.41071e-4 * self . Tb . R + 0.5113 * log10 ( self . Tb . R * v100 ) ) , <str> )  def Viscosidad_ASTM ( self , T , T1 = unidades . Temperature ( 100 , <str> ) , T2 = unidades . Temperature ( 210 , <str> ) , mu1 = 0 , mu2 = 0 ) :          if mu1 == 0 :              mu1 = self . v100 . cSt  if mu2 == 0 :              mu2 = self . v210 . cSt  t = unidades . Temperature ( T ) Z1 = mu1 + 0.7 + exp ( - 1.47 - 1.84 * mu1 - 0.51 * mu1 ** 2 ) Z2 = mu2 + 0.7 + exp ( - 1.47 - 1.84 * mu2 - 0.51 * mu2 ** 2 ) B = ( log10 ( log10 ( Z1 ) ) - log10 ( log10 ( Z2 ) ) ) / ( log10 ( T1 . R ) - log10 ( T2 . R ) ) Z = 10 ** ( 10 ** ( log10 ( log10 ( Z1 ) ) + B * ( log10 ( t . R ) - log10 ( T1 . R ) ) ) ) return unidades . Diffusivity ( Z - 0.7 - exp ( - 0.7487 - 3.295 * ( Z - 0.7 ) + 0.6119 * ( Z - 0.7 ) ** 2 - 0.3191 * ( Z - 0.7 ) ** 3 ) , <str> )  def Viscosidad_liquido_blend ( self , T , fraccion_masica , petro1 , petro2 ) :          t = unidades . Temperature ( T ) T1 = unidades . Temperature ( petro1 [ 0 ] ) T2 = unidades . Temperature ( petro1 [ 1 ] ) ml = ( log ( log ( petro1 [ 3 ] + 0.7 ) ) - log ( log ( petro1 [ 2 ] + 0.7 ) ) ) / ( log ( T2 . R ) - log ( T1 . R ) ) bl = log ( log ( petro1 [ 2 ] + 0.7 ) ) - ml * log ( T1 . R ) mh = ( log ( log ( petro2 [ 3 ] + 0.7 ) ) - log ( log ( petro2 [ 2 ] + 0.7 ) ) ) / ( log ( T2 . R ) - log ( T1 . R ) ) bh = log ( log ( petro2 [ 2 ] + 0.7 ) ) - mh * log ( T1 . R ) Tl = exp ( ( log ( log ( petro2 [ 2 ] + 0.7 ) ) - bl ) / ml ) Tx = exp ( fraccion_masica [ 0 ] * log ( Tl ) + fraccion_masica [ 1 ] * log ( T1 . R ) ) Th = exp ( ( log ( log ( petro1 [ 3 ] + 0.7 ) ) - bh ) / mh ) Ty = exp ( fraccion_masica [ 0 ] * log ( T2 . R ) + fraccion_masica [ 1 ] * log ( Th ) ) m = ( log ( log ( petro1 [ 3 ] + 0.7 ) ) - log ( log ( petro2 [ 2 ] + 0.7 ) ) ) / ( log ( Ty ) - log ( Tx ) ) b = log ( log ( petro2 [ 2 ] + 0.7 ) ) - m * log ( Tx ) return exp ( exp ( m * log ( t . R ) + b ) ) - 0.7  def Viscosity_Index ( self ) :          if self . v210 . cSt > 70 :              L = 0.8353 * self . v210 . cSt ** 2 + 14.67 * self . v210 . cSt - 216 H = 0.1684 * self . v210 . cSt ** 2 + 11.85 * self . v210 . cSt - 97  else :              L = - 1.2756691045812e+01 + 6.1466654146190 * self . v210 . cSt + 9.9774520581931e-01 * self . v210 . cSt ** 2 - 2.5045430263656e-03 * self . v210 . cSt ** 3 + 3.1748553181177e-05 * self . v210 . cSt ** 4 - 1.8264076604682e-07 * self . v210 . cSt ** 5 H = - 7.6607640162508 + 5.4845434135144 * self . v210 . cSt + 0.38222987985934 * self . v210 . cSt ** 2 - 4.6556329076069e-03 * self . v210 . cSt ** 3 + 5.1653200038471e-05 * self . v210 . cSt ** 4 - 2.3274903246922e-07 * self . v210 . cSt ** 5  if self . v100 . cSt > H :              VI = ( L - self . v100 . cSt ) / ( L - H ) * 100  else :              N = ( log10 ( H ) - log10 ( self . v100 . cSt ) ) / log10 ( self . v210 . cSt ) VI = ( 10 ** N - 1 ) / 0.00715 + 100  return VI  def ThCond_Liquido_simple ( self , T ) :          t = unidades . Temperature ( T ) k = 0.07577 - 4.1e-5 * t . F return unidades . Conductividad_termica ( k , <str> )  def ThCond_Liquido_Tsonopoulos ( self , T ) :          k = 0.05351 + 0.10177 * ( 1 - T / self . Tc ) ** ( 2. / 3 ) return unidades . Conductividad_termica ( k )  def ThCond_Liquido_API ( self , T ) :          t = unidades . Temperature ( T ) k = self . Tb . R ** 0.2904 * ( 9.961e-3 - 5.364e-6 * t . F ) return unidades . Conductividad_termica ( k , <str> )  def ThCond_Liquido_Riazi_Faghri ( self , T ) :          t = ( 1.8 * T - 460 ) / 100 A = exp ( - 4.5093 - 0.6844 * t - 0.1305 * t ** 2 ) B = 0.3003 + 0.0918 * t + 0.01195 * t ** 2 C = 0.1029 + 0.0894 * t + 0.0292 * t ** 2 k = 1.7307 * A * self . Tb . R ** B * self . SG ** C return unidades . Conductividad_termica ( k )  def ThCond_Liquido_Lenoir ( self , T , P , ko = 0 ) :          Tr = self . tr ( T ) if ko == 0 :              k1 = self . Conductividad_termica_liquido ( T ) C1 = 17.77 + 0.065 * self . pr ( 1 ) - 7.764 * Tr - 2.065 * Tr ** 2 / exp ( 0.2 * self . pr ( 1 ) )  else :              k1 = ko [ 0 ] C1 = 17.77 + 0.065 * self . pr ( ko [ 2 ] ) - 7.764 * self . tr ( ko [ 1 ] ) - 2.065 * self . tr ( ko [ 1 ] ) ** 2 / exp ( 0.2 * self . pr ( ko [ 2 ] ) )  C2 = 17.77 + 0.065 * self . pr ( P ) - 7.764 * Tr - 2.065 * Tr ** 2 / exp ( 0.2 * self . pr ( P ) ) k = k1 * C2 / C1 return unidades . Conductividad_termica ( k )  def ThCond_Gas ( self , T ) :          t = unidades . Temperature ( T ) k = 0.0013349 + 0.24628 / self . M + 1.1493 / self . M ** 2 + t . F * ( 3.2768e-5 + 4.1881e-5 / self . M + 0.0018427 / self . M ** 2 ) return unidades . Conductividad_termica ( k , <str> )  def ThCond_Gas_Riazi_Faghri ( self , T ) :          t = ( 1.8 * T - 460 ) / 100 A = exp ( 21.78 - 8.07986 * t + 1.12981 * t ** 2 - 0.05309 * t ** 3 ) B = - 4.13948 + 1.29924 * t - 0.17813 * t ** 2 + 0.00833 * t ** 3 C = 0.19876 - 0.0312 * t - 0.00567 * t ** 2 k = 1.7307 * A * self . Tb . R ** B * self . SG ** C return unidades . Conductividad_termica ( k )   if __name__ == <str> :      v = [ 10 , 30 , 50 , 70 , 90 ] D1160 = [ i + 273.15 for i in [ 150 , 205 , 250 , 290 , 350 ] ] petroleo = Petroleo ( P_dist = 10 , curveType = <str> , X_curve = v , T_curve = D1160 )   