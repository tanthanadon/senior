<str> from itertools import product import json import logging import os from PyQt5 . QtWidgets import QApplication from scipy import exp , log , sinh , cosh , tanh , arctan from scipy . constants import Boltzmann , pi , Avogadro , R , u from scipy . optimize import fsolve from lib import unidades from lib . config import conf_dir from lib . utilities import SimpleEq from lib . physics import R_atml , Collision_Neufeld from lib . thermo import ThermoAdvanced from lib . compuestos import RhoL_Costald , Pv_Lee_Kesler , MuG_Chung , MuG_P_Chung from lib . compuestos import ThG_Chung , ThG_P_Chung , Tension_Pitzer from lib . utilities import refDoc __doi__ = { 1 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 2 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 3 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 4 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 5 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 6 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 7 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 8 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 9 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 10 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 11 : { <str> : <str> , <str> : <str> <str> <str> , <str> : <str> , <str> : <str> } , 12 : { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } , 13 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 14 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 15 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 16 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 17 : { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } , 18 : { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } , 19 : { <str> : <str> , <str> : <str> <str> <str> , <str> : <str> , <str> : <str> } , 20 : { <str> : <str> , <str> : <str> <str> <str> , <str> : <str> , <str> : <str> } , 21 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 22 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 23 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 24 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 25 : { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } , } def _Helmholtz_phir ( tau , delta , coef ) :      <str> fir = 0 if delta :          nr1 = coef . get ( <str> , [ ] ) d1 = coef . get ( <str> , [ ] ) t1 = coef . get ( <str> , [ ] ) for n , d , t in zip ( nr1 , d1 , t1 ) :              fir += n * delta ** d * tau ** t  nr2 = coef . get ( <str> , [ ] ) d2 = coef . get ( <str> , [ ] ) g2 = coef . get ( <str> , [ ] ) t2 = coef . get ( <str> , [ ] ) c2 = coef . get ( <str> , [ ] ) for n , d , g , t , c in zip ( nr2 , d2 , g2 , t2 , c2 ) :              fir += n * delta ** d * tau ** t * exp ( - g * delta ** c )  nr3 = coef . get ( <str> , [ ] ) d3 = coef . get ( <str> , [ ] ) t3 = coef . get ( <str> , [ ] ) a3 = coef . get ( <str> , [ ] ) e3 = coef . get ( <str> , [ ] ) b3 = coef . get ( <str> , [ ] ) g3 = coef . get ( <str> , [ ] ) exp1 = coef . get ( <str> , [ 2 ] * len ( nr3 ) ) exp2 = coef . get ( <str> , [ 2 ] * len ( nr3 ) ) for n , d , t , a , e , b , g , ex1 , ex2 in zip ( nr3 , d3 , t3 , a3 , e3 , b3 , g3 , exp1 , exp2 ) :              expr = exp ( - a * ( delta - e ) ** ex1 - b * ( tau - g ) ** ex2 ) fir += n * delta ** d * tau ** t * expr  ni = coef . get ( <str> , [ ] ) ai = coef . get ( <str> , [ ] ) bi = coef . get ( <str> , [ ] ) Ai = coef . get ( <str> , [ ] ) Bi = coef . get ( <str> , [ ] ) Ci = coef . get ( <str> , [ ] ) Di = coef . get ( <str> , [ ] ) b_ = coef . get ( <str> , [ ] ) for n , a , b , A , B , C , D , bt in zip ( ni , ai , bi , Ai , Bi , Ci , Di , b_ ) :              Tita = ( 1 - tau ) + A * ( ( delta - 1 ) ** 2 ) ** ( 0.5 / bt ) F = exp ( - C * ( delta - 1 ) ** 2 - D * ( tau - 1 ) ** 2 ) Delta = Tita ** 2 + B * ( ( delta - 1 ) ** 2 ) ** a fir += n * Delta ** b * delta * F  if <str> in coef :              if delta < 0.2 :                  factor = 1.6 * delta ** 6 * ( 1 - 1.2 * delta ** 6 )  else :                  factor = exp ( - 0.4 * delta ** 6 ) - exp ( - 2 * delta ** 6 )  nr5 = coef . get ( <str> , [ ] ) d5 = coef . get ( <str> , [ ] ) t5 = coef . get ( <str> , [ ] ) fr = 0 for n , d , t in zip ( nr5 , d5 , t5 ) :                  fr += n * delta ** d * tau ** t  fir += factor * fr   return fir  def _MBWR_phir ( T , rho , rhoc , M , coef ) :      <str> rhocm = rhoc / M delta = rho / rhoc rhom = rho / M b = coef [ <str> ] R = coef [ <str> ] a = [ None ] a . append ( R / 100 * T ) a . append ( b [ 1 ] * T + b [ 2 ] * T ** 0.5 + b [ 3 ] + b [ 4 ] / T + b [ 5 ] / T ** 2 ) a . append ( b [ 6 ] * T + b [ 7 ] + b [ 8 ] / T + b [ 9 ] / T ** 2 ) a . append ( b [ 10 ] * T + b [ 11 ] + b [ 12 ] / T ) a . append ( b [ 13 ] ) a . append ( b [ 14 ] / T + b [ 15 ] / T ** 2 ) a . append ( b [ 16 ] / T ) a . append ( b [ 17 ] / T + b [ 18 ] / T ** 2 ) a . append ( b [ 19 ] / T ** 2 ) a . append ( b [ 20 ] / T ** 2 + b [ 21 ] / T ** 3 ) a . append ( b [ 22 ] / T ** 2 + b [ 23 ] / T ** 4 ) a . append ( b [ 24 ] / T ** 2 + b [ 25 ] / T ** 3 ) a . append ( b [ 26 ] / T ** 2 + b [ 27 ] / T ** 4 ) a . append ( b [ 28 ] / T ** 2 + b [ 29 ] / T ** 3 ) a . append ( b [ 30 ] / T ** 2 + b [ 31 ] / T ** 3 + b [ 32 ] / T ** 4 ) A = 0 for n in range ( 2 , 10 ) :          A += a [ n ] / ( n - 1 ) * rhom ** ( n - 1 )  A -= 0.5 * a [ 10 ] * rhocm ** 2 * ( exp ( - delta ** 2 ) - 1 ) A -= 0.5 * a [ 11 ] * rhocm ** 4 * ( exp ( - delta ** 2 ) * ( delta ** 2 + 1 ) - 1 ) A -= 0.5 * a [ 12 ] * rhocm ** 6 * ( exp ( - delta ** 2 ) * ( delta ** 4 + 2 * delta ** 2 + 2 ) - 2 ) A -= 0.5 * a [ 13 ] * rhocm ** 8 * ( exp ( - delta ** 2 ) * ( delta ** 6 + 3 * delta ** 4 + 6 * delta ** 2 + 6 ) - 6 ) A -= 0.5 * a [ 14 ] * rhocm ** 10 * ( exp ( - delta ** 2 ) * ( delta ** 8 + 4 * delta ** 6 + 12 * delta ** 4 + 24 * delta ** 2 + 24 ) - 24 ) A -= 0.5 * a [ 15 ] * rhocm ** 12 * ( exp ( - delta ** 2 ) * ( delta ** 10 + 5 * delta ** 8 + 20 * delta ** 6 + 60 * delta ** 4 + 120 * delta ** 2 + 120 ) - 120 ) A = A * 100 return A / R / T  def _Helmholtz_phird ( tau , delta , coef ) :      <str> fird = 0 if delta :          nr1 = coef . get ( <str> , [ ] ) d1 = coef . get ( <str> , [ ] ) t1 = coef . get ( <str> , [ ] ) for n , d , t in zip ( nr1 , d1 , t1 ) :              fird += n * d * delta ** ( d - 1 ) * tau ** t  nr2 = coef . get ( <str> , [ ] ) d2 = coef . get ( <str> , [ ] ) g2 = coef . get ( <str> , [ ] ) t2 = coef . get ( <str> , [ ] ) c2 = coef . get ( <str> , [ ] ) for n , d , g , t , c in zip ( nr2 , d2 , g2 , t2 , c2 ) :              fird += n * exp ( - g * delta ** c ) * delta ** ( d - 1 ) * tau ** t * ( d - g * c * delta ** c )  nr3 = coef . get ( <str> , [ ] ) d3 = coef . get ( <str> , [ ] ) t3 = coef . get ( <str> , [ ] ) a3 = coef . get ( <str> , [ ] ) e3 = coef . get ( <str> , [ ] ) b3 = coef . get ( <str> , [ ] ) g3 = coef . get ( <str> , [ ] ) exp1 = coef . get ( <str> , [ 2 ] * len ( nr3 ) ) exp2 = coef . get ( <str> , [ 2 ] * len ( nr3 ) ) for n , d , t , a , e , b , g , ex1 , ex2 in zip ( nr3 , d3 , t3 , a3 , e3 , b3 , g3 , exp1 , exp2 ) :              expr = exp ( - a * ( delta - e ) ** ex1 - b * ( tau - g ) ** ex2 ) fird += expr * ( n * d * delta ** ( d - 1 ) * tau ** t - n * a * delta ** d * ( delta - e ) ** ( ex1 - 1 ) * ex1 * tau ** t )  ni = coef . get ( <str> , [ ] ) ai = coef . get ( <str> , [ ] ) bi = coef . get ( <str> , [ ] ) Ai = coef . get ( <str> , [ ] ) Bi = coef . get ( <str> , [ ] ) Ci = coef . get ( <str> , [ ] ) Di = coef . get ( <str> , [ ] ) b_ = coef . get ( <str> , [ ] ) for n , a , b , A , B , C , D , bt in zip ( ni , ai , bi , Ai , Bi , Ci , Di , b_ ) :              Tita = ( 1 - tau ) + A * ( ( delta - 1 ) ** 2 ) ** ( 0.5 / bt ) F = exp ( - C * ( delta - 1 ) ** 2 - D * ( tau - 1 ) ** 2 ) Fd = - 2 * C * F * ( delta - 1 ) Delta = Tita ** 2 + B * ( ( delta - 1 ) ** 2 ) ** a Deltad = ( delta - 1 ) * ( A * Tita * 2 / bt * ( ( delta - 1 ) ** 2 ) ** ( 0.5 / bt - 1 ) + 2 * B * a * ( ( delta - 1 ) ** 2 ) ** ( a - 1 ) ) DeltaBd = b * Delta ** ( b - 1 ) * Deltad fird += n * ( Delta ** b * ( F + delta * Fd ) + DeltaBd * delta * F )  if <str> in coef :              if delta < 0.2 :                  factor = 1.6 * delta ** 6 * ( 1 - 1.2 * delta ** 6 )  else :                  factor = exp ( - 0.4 * delta ** 6 ) - exp ( - 2 * delta ** 6 )  nr5 = coef . get ( <str> , [ ] ) d5 = coef . get ( <str> , [ ] ) t5 = coef . get ( <str> , [ ] ) frd1 , frd2 = 0 , 0 for n , d , t in zip ( nr5 , d5 , t5 ) :                  frd1 += n * delta ** ( d + 5 ) * tau ** t frd2 += n * d * delta ** ( d - 1 ) * tau ** t  fird += ( - 2.4 * exp ( - 0.4 * delta ** 6 ) + 12 * exp ( - 2 * delta ** 6 ) ) * frd1 + factor * frd2   return fird  def _Helmholtz_phirt ( tau , delta , coef ) :      <str> firt = 0 if delta :          nr1 = coef . get ( <str> , [ ] ) d1 = coef . get ( <str> , [ ] ) t1 = coef . get ( <str> , [ ] ) for n , d , t in zip ( nr1 , d1 , t1 ) :              firt += n * t * delta ** d * tau ** ( t - 1 )  nr2 = coef . get ( <str> , [ ] ) d2 = coef . get ( <str> , [ ] ) g2 = coef . get ( <str> , [ ] ) t2 = coef . get ( <str> , [ ] ) c2 = coef . get ( <str> , [ ] ) for n , d , g , t , c in zip ( nr2 , d2 , g2 , t2 , c2 ) :              firt += n * t * delta ** d * tau ** ( t - 1 ) * exp ( - g * delta ** c )  nr3 = coef . get ( <str> , [ ] ) d3 = coef . get ( <str> , [ ] ) t3 = coef . get ( <str> , [ ] ) a3 = coef . get ( <str> , [ ] ) e3 = coef . get ( <str> , [ ] ) b3 = coef . get ( <str> , [ ] ) g3 = coef . get ( <str> , [ ] ) exp1 = coef . get ( <str> , [ 2 ] * len ( nr3 ) ) exp2 = coef . get ( <str> , [ 2 ] * len ( nr3 ) ) for n , d , t , a , e , b , g , ex1 , ex2 in zip ( nr3 , d3 , t3 , a3 , e3 , b3 , g3 , exp1 , exp2 ) :              expr = exp ( - a * ( delta - e ) ** ex1 - b * ( tau - g ) ** ex2 ) firt += expr * ( n * delta ** d * t * tau ** ( t - 1 ) - n * b * delta ** d * ex2 * tau ** t * ( tau - g ) ** ( ex2 - 1 ) )  ni = coef . get ( <str> , [ ] ) ai = coef . get ( <str> , [ ] ) bi = coef . get ( <str> , [ ] ) Ai = coef . get ( <str> , [ ] ) Bi = coef . get ( <str> , [ ] ) Ci = coef . get ( <str> , [ ] ) Di = coef . get ( <str> , [ ] ) b_ = coef . get ( <str> , [ ] ) for n , a , b , A , B , C , D , bt in zip ( ni , ai , bi , Ai , Bi , Ci , Di , b_ ) :              Tita = ( 1 - tau ) + A * ( ( delta - 1 ) ** 2 ) ** ( 0.5 / bt ) F = exp ( - C * ( delta - 1 ) ** 2 - D * ( tau - 1 ) ** 2 ) Ft = - 2 * D * F * ( tau - 1 ) Delta = Tita ** 2 + B * ( ( delta - 1 ) ** 2 ) ** a DeltaBt = - 2 * Tita * b * Delta ** ( b - 1 ) firt += n * delta * ( DeltaBt * F + Delta ** b * Ft )  if <str> in coef :              if delta < 0.2 :                  factor = 1.6 * delta ** 6 * ( 1 - 1.2 * delta ** 6 )  else :                  factor = exp ( - 0.4 * delta ** 6 ) - exp ( - 2 * delta ** 6 )  nr5 = coef . get ( <str> , [ ] ) d5 = coef . get ( <str> , [ ] ) t5 = coef . get ( <str> , [ ] ) frt = 0 for n , d , t in zip ( nr5 , d5 , t5 ) :                  frt += n * delta ** d * t * tau ** ( t - 1 )  firt += factor * frt   return firt  def _MBWR_phir ( T , rho , rhoc , M , coef ) :      <str> rhom = rho / M rhocm = rhoc / M delta = rho / rhoc b = coef [ <str> ] R = coef [ <str> ] a = [ None ] a . append ( R / 100 * T ) a . append ( b [ 1 ] * T + b [ 2 ] * T ** 0.5 + b [ 3 ] + b [ 4 ] / T + b [ 5 ] / T ** 2 ) a . append ( b [ 6 ] * T + b [ 7 ] + b [ 8 ] / T + b [ 9 ] / T ** 2 ) a . append ( b [ 10 ] * T + b [ 11 ] + b [ 12 ] / T ) a . append ( b [ 13 ] ) a . append ( b [ 14 ] / T + b [ 15 ] / T ** 2 ) a . append ( b [ 16 ] / T ) a . append ( b [ 17 ] / T + b [ 18 ] / T ** 2 ) a . append ( b [ 19 ] / T ** 2 ) a . append ( b [ 20 ] / T ** 2 + b [ 21 ] / T ** 3 ) a . append ( b [ 22 ] / T ** 2 + b [ 23 ] / T ** 4 ) a . append ( b [ 24 ] / T ** 2 + b [ 25 ] / T ** 3 ) a . append ( b [ 26 ] / T ** 2 + b [ 27 ] / T ** 4 ) a . append ( b [ 28 ] / T ** 2 + b [ 29 ] / T ** 3 ) a . append ( b [ 30 ] / T ** 2 + b [ 31 ] / T ** 3 + b [ 32 ] / T ** 4 ) A = 0 for n in range ( 2 , 10 ) :          A += a [ n ] / ( n - 1 ) * rhom ** ( n - 1 )  A -= 0.5 * a [ 10 ] * rhocm ** 2 * ( exp ( - delta ** 2 ) - 1 ) A -= 0.5 * a [ 11 ] * rhocm ** 4 * ( exp ( - delta ** 2 ) * ( delta ** 2 + 1 ) - 1 ) A -= 0.5 * a [ 12 ] * rhocm ** 6 * ( exp ( - delta ** 2 ) * ( delta ** 4 + 2 * delta ** 2 + 2 ) - 2 ) A -= 0.5 * a [ 13 ] * rhocm ** 8 * ( exp ( - delta ** 2 ) * ( delta ** 6 + 3 * delta ** 4 + 6 * delta ** 2 + 6 ) - 6 ) A -= 0.5 * a [ 14 ] * rhocm ** 10 * ( exp ( - delta ** 2 ) * ( delta ** 8 + 4 * delta ** 6 + 12 * delta ** 4 + 24 * delta ** 2 + 24 ) - 24 ) A -= 0.5 * a [ 15 ] * rhocm ** 12 * ( exp ( - delta ** 2 ) * ( delta ** 10 + 5 * delta ** 8 + 20 * delta ** 6 + 60 * delta ** 4 + 120 * delta ** 2 + 120 ) - 120 ) A = A * 100 return A / R / T  def _MBWR_phird ( T , rho , rhoc , M , coef ) :      <str> rhom = rho / M delta = rho / rhoc b = coef [ <str> ] R = coef [ <str> ] a = [ None ] a . append ( R / 100 * T ) a . append ( b [ 1 ] * T + b [ 2 ] * T ** 0.5 + b [ 3 ] + b [ 4 ] / T + b [ 5 ] / T ** 2 ) a . append ( b [ 6 ] * T + b [ 7 ] + b [ 8 ] / T + b [ 9 ] / T ** 2 ) a . append ( b [ 10 ] * T + b [ 11 ] + b [ 12 ] / T ) a . append ( b [ 13 ] ) a . append ( b [ 14 ] / T + b [ 15 ] / T ** 2 ) a . append ( b [ 16 ] / T ) a . append ( b [ 17 ] / T + b [ 18 ] / T ** 2 ) a . append ( b [ 19 ] / T ** 2 ) a . append ( b [ 20 ] / T ** 2 + b [ 21 ] / T ** 3 ) a . append ( b [ 22 ] / T ** 2 + b [ 23 ] / T ** 4 ) a . append ( b [ 24 ] / T ** 2 + b [ 25 ] / T ** 3 ) a . append ( b [ 26 ] / T ** 2 + b [ 27 ] / T ** 4 ) a . append ( b [ 28 ] / T ** 2 + b [ 29 ] / T ** 3 ) a . append ( b [ 30 ] / T ** 2 + b [ 31 ] / T ** 3 + b [ 32 ] / T ** 4 ) P = sum ( [ a [ n ] * rhom ** n for n in range ( 1 , 10 ) ] ) P += exp ( - ( delta ** 2 ) ) * sum ( [ a [ n ] * rhom ** ( 2 * n - 17 ) for n in range ( 10 , 16 ) ] ) P *= 100 return ( P / rhom / T / R - 1 ) / delta  def _MBWR_phirt ( T , Tc , rho , rhoc , M , coef ) :      <str> rhom = rho / M rhocm = rhoc / M tau = Tc / T delta = rho / rhoc b = coef [ <str> ] R = coef [ <str> ] a = [ None ] a . append ( R / 100 * T ) a . append ( b [ 1 ] * T + b [ 2 ] * T ** 0.5 + b [ 3 ] + b [ 4 ] / T + b [ 5 ] / T ** 2 ) a . append ( b [ 6 ] * T + b [ 7 ] + b [ 8 ] / T + b [ 9 ] / T ** 2 ) a . append ( b [ 10 ] * T + b [ 11 ] + b [ 12 ] / T ) a . append ( b [ 13 ] ) a . append ( b [ 14 ] / T + b [ 15 ] / T ** 2 ) a . append ( b [ 16 ] / T ) a . append ( b [ 17 ] / T + b [ 18 ] / T ** 2 ) a . append ( b [ 19 ] / T ** 2 ) a . append ( b [ 20 ] / T ** 2 + b [ 21 ] / T ** 3 ) a . append ( b [ 22 ] / T ** 2 + b [ 23 ] / T ** 4 ) a . append ( b [ 24 ] / T ** 2 + b [ 25 ] / T ** 3 ) a . append ( b [ 26 ] / T ** 2 + b [ 27 ] / T ** 4 ) a . append ( b [ 28 ] / T ** 2 + b [ 29 ] / T ** 3 ) a . append ( b [ 30 ] / T ** 2 + b [ 31 ] / T ** 3 + b [ 32 ] / T ** 4 ) A = 0 for n in range ( 2 , 10 ) :          A += a [ n ] / ( n - 1 ) * rhom ** ( n - 1 )  A -= 0.5 * a [ 10 ] * rhocm ** 2 * ( exp ( - delta ** 2 ) - 1 ) A -= 0.5 * a [ 11 ] * rhocm ** 4 * ( exp ( - delta ** 2 ) * ( delta ** 2 + 1 ) - 1 ) A -= 0.5 * a [ 12 ] * rhocm ** 6 * ( exp ( - delta ** 2 ) * ( delta ** 4 + 2 * delta ** 2 + 2 ) - 2 ) A -= 0.5 * a [ 13 ] * rhocm ** 8 * ( exp ( - delta ** 2 ) * ( delta ** 6 + 3 * delta ** 4 + 6 * delta ** 2 + 6 ) - 6 ) A -= 0.5 * a [ 14 ] * rhocm ** 10 * ( exp ( - delta ** 2 ) * ( delta ** 8 + 4 * delta ** 6 + 12 * delta ** 4 + 24 * delta ** 2 + 24 ) - 24 ) A -= 0.5 * a [ 15 ] * rhocm ** 12 * ( exp ( - delta ** 2 ) * ( delta ** 10 + 5 * delta ** 8 + 20 * delta ** 6 + 60 * delta ** 4 + 120 * delta ** 2 + 120 ) - 120 ) A = A * 100 adT = [ None , R / 100 ] adT . append ( b [ 1 ] + b [ 2 ] / 2 / T ** 0.5 - b [ 4 ] / T ** 2 - 2 * b [ 5 ] / T ** 3 ) adT . append ( b [ 6 ] - b [ 8 ] / T ** 2 - 2 * b [ 9 ] / T ** 3 ) adT . append ( b [ 10 ] - b [ 12 ] / T ** 2 ) adT . append ( 0 ) adT . append ( - b [ 14 ] / T ** 2 - 2 * b [ 15 ] / T ** 3 ) adT . append ( - b [ 16 ] / T ** 2 ) adT . append ( - b [ 17 ] / T ** 2 - 2 * b [ 18 ] / T ** 3 ) adT . append ( - 2 * b [ 19 ] / T ** 3 ) adT . append ( - 2 * b [ 20 ] / T ** 3 - 3 * b [ 21 ] / T ** 4 ) adT . append ( - 2 * b [ 22 ] / T ** 3 - 4 * b [ 23 ] / T ** 5 ) adT . append ( - 2 * b [ 24 ] / T ** 3 - 3 * b [ 25 ] / T ** 4 ) adT . append ( - 2 * b [ 26 ] / T ** 3 - 4 * b [ 27 ] / T ** 5 ) adT . append ( - 2 * b [ 28 ] / T ** 3 - 3 * b [ 29 ] / T ** 4 ) adT . append ( - 2 * b [ 30 ] / T ** 3 - 3 * b [ 31 ] / T ** 4 - 4 * b [ 32 ] / T ** 5 ) dAT = 0 for n in range ( 2 , 10 ) :          dAT += adT [ n ] / ( n - 1 ) * rhom ** ( n - 1 )  dAT -= 0.5 * adT [ 10 ] * rhocm ** 2 * ( exp ( - delta ** 2 ) - 1 ) dAT -= 0.5 * adT [ 11 ] * rhocm ** 4 * ( exp ( - delta ** 2 ) * ( delta ** 2 + 1 ) - 1 ) dAT -= 0.5 * adT [ 12 ] * rhocm ** 6 * ( exp ( - delta ** 2 ) * ( delta ** 4 + 2 * delta ** 2 + 2 ) - 2 ) dAT -= 0.5 * adT [ 13 ] * rhocm ** 8 * ( exp ( - delta ** 2 ) * ( delta ** 6 + 3 * delta ** 4 + 6 * delta ** 2 + 6 ) - 6 ) dAT -= 0.5 * adT [ 14 ] * rhocm ** 10 * ( exp ( - delta ** 2 ) * ( delta ** 8 + 4 * delta ** 6 + 12 * delta ** 4 + 24 * delta ** 2 + 24 ) - 24 ) dAT -= 0.5 * adT [ 15 ] * rhocm ** 12 * ( exp ( - delta ** 2 ) * ( delta ** 10 + 5 * delta ** 8 + 20 * delta ** 6 + 60 * delta ** 4 + 120 * delta ** 2 + 120 ) - 120 ) dAT = dAT * 100 return ( A / T - dAT ) / R / tau  class MEoS ( ThermoAdvanced ) :      <str> id = None _refPropName = <str> _coolPropName = <str> _Tr = None _rhor = None _w = None eq = ( ) _PR = 0. _dielectric = None _melting = None _sublimation = None _surface = None _vapor_Pressure = None _liquid_Density = None _vapor_Density = None _omega = None _viscosity = None _thermal = None _critical = None _T0_ecs = None _rho0_ecs = None _ecs_msg = <str> _test = [ ] kwargs = { <str> : 0.0 , <str> : 0.0 , <str> : None , <str> : None , <str> : None , <str> : None , <str> : None , <str> : 0.0 , <str> : 0 , <str> : 0 , <str> : 0 , <str> : None , <str> : None , <str> : 0 , <str> : 0 } status = 0 msg = QApplication . translate ( <str> , <str> ) def __init__ ( self , ** kwargs ) :          self . kwargs = MEoS . kwargs . copy ( ) self . __call__ ( ** kwargs ) if self . _surface and <str> not in self . _surface :              self . _surface [ <str> ] = __doi__ [ 1 ]  if self . _dielectric and <str> not in self . _dielectric :              self . _dielectric [ <str> ] = __doi__ [ 24 ]   def __call__ ( self , ** kwargs ) :          eq = kwargs . get ( <str> , 0 ) if isinstance ( eq , str ) and eq in self . __class__ . __dict__ :              eq = self . eq . index ( self . __class__ . __dict__ [ eq ] ) kwargs [ <str> ] = eq  elif isinstance ( eq , str ) and eq not in self . __class__ . __dict__ and eq not in [ <str> , <str> , <str> ] :              raise ValueError ( <str> )  self . kwargs . update ( kwargs ) self . _code = <str> if eq == <str> :              self . _constants = self . eq [ 0 ] self . _code = <str>  elif eq == <str> :              self . _Generalised ( ) self . _code = <str>  elif eq == <str> :              try :                  self . _constants = self . GERG  except :                  self . _constants = self . eq [ 0 ]   elif self . eq [ eq ] [ <str> ] == <str> :              self . _constants = self . eq [ eq ]  elif self . eq [ eq ] [ <str> ] == <str> :              self . _constants = self . eq [ eq ]  if not self . _code :              self . _code = str ( eq )  visco = self . kwargs [ <str> ] thermal = self . kwargs [ <str> ] if self . _viscosity :              self . _viscosity = self . _viscosity [ visco ]  if self . _thermal :              self . _thermal = self . _thermal [ thermal ]  if <str> in self . _constants :              self . M = self . _constants [ <str> ]  if <str> in self . _constants :              self . Tc = unidades . Temperature ( self . _constants [ <str> ] )  if <str> in self . _constants :              self . Pc = unidades . Pressure ( self . _constants [ <str> ] , <str> )  if <str> in self . _constants :              self . rhoc = unidades . Density ( self . _constants [ <str> ] * self . M )  if <str> in self . _constants :              self . Tt = unidades . Temperature ( self . _constants [ <str> ] )  self . R = unidades . SpecificHeat ( self . _constants [ <str> ] / self . M , <str> ) self . Zc = self . Pc / self . rhoc / self . R / self . Tc self . cleanOldValues ( ** kwargs ) if self . calculable :              self . calculo ( ) if self . status in ( 1 , 3 ) :                  converge = True for input in self . _mode . split ( <str> ) :                      inp = self . kwargs [ input ] out = self . __getattribute__ ( input ) . _data if input in ( <str> , <str> , <str> , <str> ) :                          maxError = 1e-1  else :                          maxError = 1e-3  if abs ( inp - out ) > maxError :                          converge = False break   if not converge :                      self . status = 5 self . msg = QApplication . translate ( <str> , <str> ) err = self . kwargs [ input ] - self . __getattribute__ ( input ) . _data msg = <str> % ( self . __class__ . __name__ , input , err ) logging . warning ( msg )     def cleanOldValues ( self , ** kwargs ) :          if <str> in kwargs :              kwargs [ <str> ] = kwargs [ <str> ] * self . M del kwargs [ <str> ]  elif kwargs . get ( <str> , 0 ) :              kwargs [ <str> ] = 1. / kwargs [ <str> ] del kwargs [ <str> ]  elif kwargs . get ( <str> , 0 ) :              kwargs [ <str> ] = self . M / kwargs [ <str> ] del kwargs [ <str> ]  self . kwargs . update ( kwargs )  @ property def calculable ( self ) :          self . _mode = <str> if self . kwargs [ <str> ] and self . kwargs [ <str> ] :              self . _mode = <str>  elif self . kwargs [ <str> ] and self . kwargs [ <str> ] is not None :              self . _mode = <str>  elif self . kwargs [ <str> ] and self . kwargs [ <str> ] is not None :              self . _mode = <str>  elif self . kwargs [ <str> ] and self . kwargs [ <str> ] is not None :              self . _mode = <str>  elif self . kwargs [ <str> ] and self . kwargs [ <str> ] is not None :              self . _mode = <str>  elif self . kwargs [ <str> ] and self . kwargs [ <str> ] is not None :              self . _mode = <str>  elif self . kwargs [ <str> ] and self . kwargs [ <str> ] is not None :              self . _mode = <str>  elif self . kwargs [ <str> ] and self . kwargs [ <str> ] is not None :              self . _mode = <str>  elif self . kwargs [ <str> ] and self . kwargs [ <str> ] is not None :              self . _mode = <str>  elif self . kwargs [ <str> ] is not None and self . kwargs [ <str> ] is not None :              self . _mode = <str>  elif self . kwargs [ <str> ] is not None and self . kwargs [ <str> ] is not None :              self . _mode = <str>  elif self . kwargs [ <str> ] is not None and self . kwargs [ <str> ] is not None :              self . _mode = <str>  elif self . kwargs [ <str> ] is not None and self . kwargs [ <str> ] is not None :              self . _mode = <str>  elif self . kwargs [ <str> ] is not None and self . kwargs [ <str> ] is not None :              self . _mode = <str>  elif self . kwargs [ <str> ] is not None and self . kwargs [ <str> ] is not None :              self . _mode = <str>  elif self . kwargs [ <str> ] and self . kwargs [ <str> ] is not None :              self . _mode = <str>  elif self . kwargs [ <str> ] and self . kwargs [ <str> ] is not None :              self . _mode = <str>  return bool ( self . _mode )  def calculo ( self ) :          T = self . kwargs [ <str> ] rho = self . kwargs [ <str> ] P = self . kwargs [ <str> ] s = self . kwargs [ <str> ] h = self . kwargs [ <str> ] u = self . kwargs [ <str> ] x = self . kwargs [ <str> ] ref = self . kwargs [ <str> ] refvalues = self . kwargs [ <str> ] self . _ref ( ref , refvalues ) propiedades = None vapor = None liquido = None if self . _constants [ <str> ] == <str> and <str> in self . _constants :              rhocm = 1 / ( - self . _constants [ <str> ] ) ** 0.5 self . rhoc = rhocm * self . M  if self . _mode == <str> :              tau = self . Tc / T rhoo = [ ] if self . kwargs [ <str> ] :                  rhoo . append ( self . kwargs [ <str> ] )  if T < self . Tc :                  Pv = self . _Vapor_Pressure ( T ) rhov = self . _Vapor_Density ( T ) rhol = self . _Liquid_Density ( T ) if P > Pv :                      rhoo . append ( rhol )  else :                      rhoo . append ( rhov )   else :                  rhoo . append ( self . _Liquid_Density ( self . Tc ) )  rhoo . append ( self . _constants [ <str> ] * self . M ) rhoo . append ( self . rhoc ) rhoo . append ( P / T / self . R ) def f ( rho ) :                  delta = rho / self . rhoc fird = self . _phird ( tau , delta ) return ( 1 + delta * fird ) * self . R . kJkgK * T * rho - P / 1000  prop = self . fsolve ( f , ** { <str> : P , <str> : T , <str> : rhoo } ) rho = prop [ <str> ]  elif self . _mode == <str> :              rhol = self . _Liquid_Density ( T ) rhov = self . _Vapor_Density ( T ) if T > self . Tc :                  x = 1  elif rho >= rhol :                  x = 0  elif rho <= rhov :                  x = 1  else :                  rhoL , rhoG , Ps = self . _saturation ( T ) if rho >= rhoL :                      x = 0  elif rho <= rhoG :                      x = 1  else :                      x = ( 1. / rho - 1 / rhoL ) / ( 1 / rhoG - 1 / rhoL )    elif self . _mode == <str> :              tau = self . Tc / T def f ( rho ) :                  if rho < 0 :                      rho = 0  delta = rho / self . rhoc ideal = self . _phi0 ( self . _constants [ <str> ] , tau , delta ) fiot = ideal [ <str> ] fird = self . _phird ( tau , delta ) firt = self . _phirt ( tau , delta ) ho = self . R * T * ( 1 + tau * ( fiot + firt ) + delta * fird ) return ho - h  if T < self . Tc :                  rhov = self . _Vapor_Density ( T ) rhol = self . _Liquid_Density ( T ) deltaL = rhol / self . rhoc deltaG = rhov / self . rhoc ideal = self . _phi0 ( self . _constants [ <str> ] , tau , deltaL ) fiot = ideal [ <str> ] firdL = self . _phird ( tau , deltaL ) firtL = self . _phirt ( tau , deltaL ) firdG = self . _phird ( tau , deltaG ) firtG = self . _phirt ( tau , deltaG ) hoL = self . R * T * ( 1 + tau * ( fiot + firtL ) + deltaL * firdL ) hoG = self . R * T * ( 1 + tau * ( fiot + firtG ) + deltaG * firdG ) if hoL <= h <= hoG :                      rhoL , rhoG , Ps = self . _saturation ( T ) deltaL = rhoL / self . rhoc deltaG = rhoG / self . rhoc ideal = self . _phi0 ( self . _constants [ <str> ] , tau , deltaL ) fiot = ideal [ <str> ] firdL = self . _phird ( tau , deltaL ) firtL = self . _phirt ( tau , deltaL ) firdG = self . _phird ( tau , deltaG ) firtG = self . _phirt ( tau , deltaG ) hoL = self . R * T * ( 1 + tau * ( fiot + firtL ) + deltaL * firdL ) hoG = self . R * T * ( 1 + tau * ( fiot + firtG ) + deltaG * firdG ) x = ( h - hoL ) / ( hoG - hoL ) rho = 1 / ( x / rhoG + ( 1 - x ) / rhoL )  else :                      if h > hoG :                          rhoo = rhov  else :                          rhoo = rhol  rho = fsolve ( f , rhoo ) [ 0 ]   else :                  rho = fsolve ( f , self . rhoc ) [ 0 ]   elif self . _mode == <str> :              tau = self . Tc / T def f ( rho ) :                  if rho < 0 :                      rho = 0  delta = rho / self . rhoc ideal = self . _phi0 ( self . _constants [ <str> ] , tau , delta ) fio = ideal [ <str> ] fiot = ideal [ <str> ] fir = self . _phir ( tau , delta ) firt = self . _phirt ( tau , delta ) so = self . R * ( tau * ( fiot + firt ) - fio - fir ) return so - s  if T < self . Tc :                  rhov = self . _Vapor_Density ( T ) rhol = self . _Liquid_Density ( T ) deltaL = rhol / self . rhoc deltaG = rhov / self . rhoc idealL = self . _phi0 ( self . _constants [ <str> ] , tau , deltaL ) idealG = self . _phi0 ( self . _constants [ <str> ] , tau , deltaG ) fioL = idealL [ <str> ] fioG = idealG [ <str> ] fiot = idealL [ <str> ] firL = self . _phir ( tau , deltaL ) firtL = self . _phirt ( tau , deltaL ) sl = self . R * ( tau * ( fiot + firtL ) - fioL - firL ) firG = self . _phir ( tau , deltaG ) firtG = self . _phirt ( tau , deltaG ) sv = self . R * ( tau * ( fiot + firtG ) - fioG - firG ) if sl <= s <= sv :                      rhoL , rhoG , Ps = self . _saturation ( T ) deltaL = rhol / self . rhoc deltaG = rhov / self . rhoc idealL = self . _phi0 ( self . _constants [ <str> ] , tau , deltaL ) idealG = self . _phi0 ( self . _constants [ <str> ] , tau , deltaG ) fioL = idealL [ <str> ] fioG = idealG [ <str> ] fiot = idealL [ <str> ] firL = self . _phir ( tau , deltaL ) firtL = self . _phirt ( tau , deltaL ) sl = self . R * ( tau * ( fiot + firtL ) - fioL - firL ) firG = self . _phir ( tau , deltaG ) firtG = self . _phirt ( tau , deltaG ) sv = self . R * ( tau * ( fiot + firtG ) - fioG - firG ) x = ( s - sl ) / ( sv - sl ) rho = 1 / ( x / rhoG + ( 1 - x ) / rhoL )  else :                      if s > sv :                          rhoo = rhov  else :                          rhoo = rhol  rho = fsolve ( f , rhoo ) [ 0 ]   else :                  rho = fsolve ( f , self . rhoc ) [ 0 ]   elif self . _mode == <str> :              tau = self . Tc / T def f ( rho ) :                  if rho < 0 :                      rho = 0  delta = rho / self . rhoc ideal = self . _phi0 ( self . _constants [ <str> ] , tau , delta ) fiot = ideal [ <str> ] fird = self . _phird ( tau , delta ) firt = self . _phirt ( tau , delta ) Po = self . R . kJkgK * T * ( 1 + delta * fird ) * rho ho = self . R * T * ( 1 + tau * ( fiot + firt ) + delta * fird ) return ho - Po * 1e3 / rho - u  if T < self . Tc :                  rhov = self . _Vapor_Density ( T ) rhol = self . _Liquid_Density ( T ) deltaL = rhol / self . rhoc deltaG = rhov / self . rhoc ideal = self . _phi0 ( self . _constants [ <str> ] , tau , deltaL ) fiot = ideal [ <str> ] firdL = self . _phird ( tau , deltaL ) firtL = self . _phirt ( tau , deltaL ) firdG = self . _phird ( tau , deltaG ) firtG = self . _phirt ( tau , deltaG ) Po = self . R . kJkgK * T * ( 1 + deltaL * firdL ) * rhol hoL = self . R * T * ( 1 + tau * ( fiot + firtL ) + deltaL * firdL ) hoG = self . R * T * ( 1 + tau * ( fiot + firtG ) + deltaG * firdG ) lu = hoL - Po * 1e3 / rhol vu = hoG - Po * 1e3 / rhov if lu <= u <= vu :                      rhoL , rhoG , Ps = self . _saturation ( T ) deltaL = rhoL / self . rhoc deltaG = rhoG / self . rhoc ideal = self . _phi0 ( self . _constants [ <str> ] , tau , deltaL ) fiot = ideal [ <str> ] firdL = self . _phird ( tau , deltaL ) firtL = self . _phirt ( tau , deltaL ) firdG = self . _phird ( tau , deltaG ) firtG = self . _phirt ( tau , deltaG ) Po = self . R . kJkgK * T * ( 1 + deltaL * firdL ) * rhoL hoL = self . R * T * ( 1 + tau * ( fiot + firtL ) + deltaL * firdL ) hoG = self . R * T * ( 1 + tau * ( fiot + firtG ) + deltaG * firdG ) lu = hoL - Po * 1e3 / rhoL vu = hoG - Po * 1e3 / rhoG x = ( u - lu ) / ( vu - lu ) rho = 1 / ( x / rhoG + ( 1 - x ) / rhoL )  else :                      if u > vu :                          rhoo = rhov  else :                          rhoo = rhol  rho = fsolve ( f , rhoo ) [ 0 ]   else :                  rho = fsolve ( f , self . rhoc ) [ 0 ]   elif self . _mode == <str> :              def f ( T ) :                  delta = rho / self . rhoc if T < 0 :                      T = 0  tau = self . Tc / T fird = self . _phird ( tau , delta ) return ( 1 + delta * fird ) * self . R . kJkgK * T * rho - P / 1000  def f2 ( parr ) :                  T , rhol , rhog = parr if T < 0 :                      T = 0  if rhol < 0 :                      rhol = 0  if rhog < 0 :                      rhog = 0  tau = self . Tc / T deltaL = rhol / self . rhoc deltaG = rhog / self . rhoc firL = self . _phir ( tau , deltaL ) firdL = self . _phird ( tau , deltaL ) firG = self . _phir ( tau , deltaG ) firdG = self . _phird ( tau , deltaG ) Jl = rhol * ( 1 + deltaL * firdL ) Jv = rhog * ( 1 + deltaG * firdG ) K = firL - firG Ps = self . R . kJkgK * T * rhol * rhog / ( rhol - rhog ) * ( K + log ( rhol / rhog ) ) return ( Jl - Jv , Jl * ( 1 / rhog - 1 / rhol ) - log ( rhol / rhog ) - K , Ps - P / 1000 )  prop = self . fsolve ( f , f2 , ** { <str> : P , <str> : rho } ) T = prop [ <str> ] if <str> in prop :                  rho = prop [ <str> ]  elif <str> in prop :                  rhoG = prop [ <str> ] rhoL = prop [ <str> ] x = ( 1. / rho - 1 / rhoL ) / ( 1 / rhoG - 1 / rhoL )   elif self . _mode == <str> :              def f ( parr ) :                  rho , T = parr if rho < 0 :                      rho = 0  if T < 0 :                      T = 0  delta = rho / self . rhoc tau = self . Tc / T ideal = self . _phi0 ( self . _constants [ <str> ] , tau , delta ) fiot = ideal [ <str> ] fird = self . _phird ( tau , delta ) firt = self . _phirt ( tau , delta ) Po = self . R . kJkgK * T * ( 1 + delta * fird ) * rho ho = self . R * T * ( 1 + tau * ( fiot + firt ) + delta * fird ) return Po - P / 1e3 , ho - h  def f2 ( parr ) :                  T , rhol , rhog , x = parr if T < 0 :                      T = 0  if rhol < 0 :                      rhol = 0  if rhog < 0 :                      rhog = 0  if x < 0 :                      x = 0  if x > 1 :                      x = 1  tau = self . Tc / T deltaL = rhol / self . rhoc deltaG = rhog / self . rhoc ideal = self . _phi0 ( self . _constants [ <str> ] , tau , deltaL ) fiot = ideal [ <str> ] firL = self . _phir ( tau , deltaL ) firdL = self . _phird ( tau , deltaL ) firtL = self . _phirt ( tau , deltaL ) hoL = self . R * T * ( 1 + tau * ( fiot + firtL ) + deltaL * firdL ) firG = self . _phir ( tau , deltaG ) firdG = self . _phird ( tau , deltaG ) firtG = self . _phirt ( tau , deltaG ) hoG = self . R * T * ( 1 + tau * ( fiot + firtG ) + deltaG * firdG ) Jl = rhol * ( 1 + deltaL * firdL ) Jv = rhog * ( 1 + deltaG * firdG ) K = firL - firG Ps = self . R . kJkgK * T * rhol * rhog / ( rhol - rhog ) * ( K + log ( rhol / rhog ) ) return ( Jl - Jv , Jl * ( 1 / rhog - 1 / rhol ) - log ( rhol / rhog ) - K , hoL * ( 1 - x ) + hoG * x - h , Ps - P / 1000 )  prop = self . fsolve ( f , f2 , ** { <str> : P , <str> : h } ) T = prop [ <str> ] if <str> in prop :                  rho = prop [ <str> ]  else :                  rhoG = prop [ <str> ] rhoL = prop [ <str> ] x = prop [ <str> ]   elif self . _mode == <str> :              def f ( parr ) :                  rho , T = parr if rho < 0 :                      rho = 0  if T < 0 :                      T = 0  delta = rho / self . rhoc tau = self . Tc / T ideal = self . _phi0 ( self . _constants [ <str> ] , tau , delta ) fio = ideal [ <str> ] fiot = ideal [ <str> ] fir = self . _phir ( tau , delta ) fird = self . _phird ( tau , delta ) firt = self . _phirt ( tau , delta ) Po = self . R . kJkgK * T * ( 1 + delta * fird ) * rho so = self . R * ( tau * ( fiot + firt ) - fio - fir ) return Po - P / 1e3 , so - s  def f2 ( parr ) :                  T , rhol , rhog , x = parr if T < 0 :                      T = 0  if rhol < 0 :                      rhol = 0  if rhog < 0 :                      rhog = 0  if x < 0 :                      x = 0  if x > 1 :                      x = 1  tau = self . Tc / T deltaL = rhol / self . rhoc deltaG = rhog / self . rhoc idealL = self . _phi0 ( self . _constants [ <str> ] , tau , deltaL ) fioL = idealL [ <str> ] fiot = idealL [ <str> ] idealG = self . _phi0 ( self . _constants [ <str> ] , tau , deltaG ) fioG = idealG [ <str> ] firL = self . _phir ( tau , deltaL ) firdL = self . _phird ( tau , deltaL ) firtL = self . _phirt ( tau , deltaL ) soL = self . R * ( tau * ( fiot + firtL ) - fioL - firL ) firG = self . _phir ( tau , deltaG ) firdG = self . _phird ( tau , deltaG ) firtG = self . _phirt ( tau , deltaG ) soG = self . R * ( tau * ( fiot + firtG ) - fioG - firG ) Jl = rhol * ( 1 + deltaL * firdL ) Jv = rhog * ( 1 + deltaG * firdG ) K = firL - firG Ps = self . R . kJkgK * T * rhol * rhog / ( rhol - rhog ) * ( K + log ( rhol / rhog ) ) return ( Jl - Jv , Jl * ( 1 / rhog - 1 / rhol ) - log ( rhol / rhog ) - K , soL * ( 1 - x ) + soG * x - s , Ps - P / 1000 )  prop = self . fsolve ( f , f2 , ** { <str> : P , <str> : s } ) T = prop [ <str> ] if <str> in prop :                  rho = prop [ <str> ]  else :                  rhoG = prop [ <str> ] rhoL = prop [ <str> ] x = prop [ <str> ]   elif self . _mode == <str> :              def f ( parr ) :                  rho , T = parr if rho < 0 :                      rho = 0  if T < 0 :                      T = 0  delta = rho / self . rhoc tau = self . Tc / T ideal = self . _phi0 ( self . _constants [ <str> ] , tau , delta ) fiot = ideal [ <str> ] fird = self . _phird ( tau , delta ) firt = self . _phirt ( tau , delta ) Po = self . R . kJkgK * T * ( 1 + delta * fird ) * rho ho = self . R * T * ( 1 + tau * ( fiot + firt ) + delta * fird ) return Po - P / 1e3 , ho - Po * 1e3 / rho - u  def f2 ( parr ) :                  T , rhol , rhog , x = parr if T < 0 :                      T = 0  if rhol < 0 :                      rhol = 0  if rhog < 0 :                      rhog = 0  if x < 0 :                      x = 0  if x > 1 :                      x = 1  tau = self . Tc / T deltaL = rhol / self . rhoc deltaG = rhog / self . rhoc ideal = self . _phi0 ( self . _constants [ <str> ] , tau , deltaL ) fiot = ideal [ <str> ] firL = self . _phir ( tau , deltaL ) firdL = self . _phird ( tau , deltaL ) firtL = self . _phirt ( tau , deltaL ) hoL = self . R * T * ( 1 + tau * ( fiot + firtL ) + deltaL * firdL ) firG = self . _phir ( tau , deltaG ) firdG = self . _phird ( tau , deltaG ) firtG = self . _phirt ( tau , deltaG ) hoG = self . R * T * ( 1 + tau * ( fiot + firtG ) + deltaG * firdG ) Jl = rhol * ( 1 + deltaL * firdL ) Jv = rhog * ( 1 + deltaG * firdG ) K = firL - firG Ps = self . R . kJkgK * T * rhol * rhog / ( rhol - rhog ) * ( K + log ( rhol / rhog ) ) vu = hoG - Ps * 1000 / rhog lu = hoL - Ps * 1000 / rhol return ( Jl - Jv , Jl * ( 1 / rhog - 1 / rhol ) - log ( rhol / rhog ) - K , lu * ( 1 - x ) + vu * x - u , Ps - P / 1000 )  prop = self . fsolve ( f , f2 , ** { <str> : P , <str> : u } ) T = prop [ <str> ] if <str> in prop :                  rho = prop [ <str> ]  else :                  rhoG = prop [ <str> ] rhoL = prop [ <str> ] x = prop [ <str> ]   elif self . _mode == <str> :              delta = rho / self . rhoc def f ( T ) :                  if T < 0 :                      T = 0  tau = self . Tc / T ideal = self . _phi0 ( self . _constants [ <str> ] , tau , delta ) fiot = ideal [ <str> ] fird = self . _phird ( tau , delta ) firt = self . _phirt ( tau , delta ) ho = self . R * T * ( 1 + tau * ( fiot + firt ) + delta * fird ) return ho - h  def f2 ( parr ) :                  T , rhol , rhog = parr if T < 0 :                      T = 0  if rhol < 0 :                      rhol = 0  if rhog < 0 :                      rhog = 0  tau = self . Tc / T deltaL = rhol / self . rhoc deltaG = rhog / self . rhoc ideal = self . _phi0 ( self . _constants [ <str> ] , tau , deltaL ) fiot = ideal [ <str> ] firL = self . _phir ( tau , deltaL ) firdL = self . _phird ( tau , deltaL ) firtL = self . _phirt ( tau , deltaL ) hoL = self . R * T * ( 1 + tau * ( fiot + firtL ) + deltaL * firdL ) firG = self . _phir ( tau , deltaG ) firdG = self . _phird ( tau , deltaG ) firtG = self . _phirt ( tau , deltaG ) hoG = self . R * T * ( 1 + tau * ( fiot + firtG ) + deltaG * firdG ) Jl = rhol * ( 1 + deltaL * firdL ) Jv = rhog * ( 1 + deltaG * firdG ) K = firL - firG x = ( 1. / rho - 1 / rhol ) / ( 1 / rhog - 1 / rhol ) return ( Jl - Jv , Jl * ( 1 / rhog - 1 / rhol ) - log ( rhol / rhog ) - K , hoL * ( 1 - x ) + hoG * x - h )  prop = self . fsolve ( f , f2 , ** { <str> : h , <str> : rho } ) T = prop [ <str> ] if <str> in prop :                  rho = prop [ <str> ]  elif <str> in prop :                  rhoG = prop [ <str> ] rhoL = prop [ <str> ] x = ( 1. / rho - 1 / rhoL ) / ( 1 / rhoG - 1 / rhoL )   elif self . _mode == <str> :              delta = rho / self . rhoc def f ( T ) :                  if T < 0 :                      T = 0  tau = self . Tc / T ideal = self . _phi0 ( self . _constants [ <str> ] , tau , delta ) fio = ideal [ <str> ] fiot = ideal [ <str> ] fir = self . _phir ( tau , delta ) firt = self . _phirt ( tau , delta ) so = self . R * ( tau * ( fiot + firt ) - fio - fir ) return so - s  def f2 ( parr ) :                  T , rhol , rhog = parr if T < 0 :                      T = 0  if rhol < 0 :                      rhol = 0  if rhog < 0 :                      rhog = 0  tau = self . Tc / T deltaL = rhol / self . rhoc deltaG = rhog / self . rhoc idealL = self . _phi0 ( self . _constants [ <str> ] , tau , deltaL ) fioL = idealL [ <str> ] fiot = idealL [ <str> ] idealG = self . _phi0 ( self . _constants [ <str> ] , tau , deltaG ) fioG = idealG [ <str> ] firL = self . _phir ( tau , deltaL ) firdL = self . _phird ( tau , deltaL ) firtL = self . _phirt ( tau , deltaL ) soL = self . R * ( tau * ( fiot + firtL ) - fioL - firL ) firG = self . _phir ( tau , deltaG ) firdG = self . _phird ( tau , deltaG ) firtG = self . _phirt ( tau , deltaG ) soG = self . R * ( tau * ( fiot + firtG ) - fioG - firG ) Jl = rhol * ( 1 + deltaL * firdL ) Jv = rhog * ( 1 + deltaG * firdG ) K = firL - firG x = ( 1. / rho - 1 / rhol ) / ( 1 / rhog - 1 / rhol ) return ( Jl - Jv , Jl * ( 1 / rhog - 1 / rhol ) - log ( rhol / rhog ) - K , soL * ( 1 - x ) + soG * x - s )  prop = self . fsolve ( f , f2 , ** { <str> : s , <str> : rho } ) T = prop [ <str> ] if <str> in prop :                  rho = prop [ <str> ]  elif <str> in prop :                  rhoG = prop [ <str> ] rhoL = prop [ <str> ] x = ( 1. / rho - 1 / rhoL ) / ( 1 / rhoG - 1 / rhoL )   elif self . _mode == <str> :              delta = rho / self . rhoc def f ( T ) :                  if T < 0 :                      T = 0  tau = self . Tc / T ideal = self . _phi0 ( self . _constants [ <str> ] , tau , delta ) fiot = ideal [ <str> ] fird = self . _phird ( tau , delta ) firt = self . _phirt ( tau , delta ) Po = self . R . kJkgK * T * ( 1 + delta * fird ) * rho ho = self . R * T * ( 1 + tau * ( fiot + firt ) + delta * fird ) return ho - Po * 1e3 / rho - u  def f2 ( parr ) :                  T , rhol , rhog = parr if T < 0 :                      T = 0  if rhol < 0 :                      rhol = 0  if rhog < 0 :                      rhog = 0  tau = self . Tc / T deltaL = rhol / self . rhoc deltaG = rhog / self . rhoc ideal = self . _phi0 ( self . _constants [ <str> ] , tau , deltaL ) fiot = ideal [ <str> ] firL = self . _phir ( tau , deltaL ) firdL = self . _phird ( tau , deltaL ) firtL = self . _phirt ( tau , deltaL ) hoL = self . R * T * ( 1 + tau * ( fiot + firtL ) + deltaL * firdL ) firG = self . _phir ( tau , deltaG ) firdG = self . _phird ( tau , deltaG ) firtG = self . _phirt ( tau , deltaG ) hoG = self . R * T * ( 1 + tau * ( fiot + firtG ) + deltaG * firdG ) Jl = rhol * ( 1 + deltaL * firdL ) Jv = rhog * ( 1 + deltaG * firdG ) K = firL - firG Ps = self . R . kJkgK * T * rhol * rhog / ( rhol - rhog ) * ( K + log ( rhol / rhog ) ) x = ( 1. / rho - 1 / rhol ) / ( 1 / rhog - 1 / rhol ) vu = hoG - Ps * 1000 / rhog lu = hoL - Ps * 1000 / rhol return ( Jl - Jv , Jl * ( 1 / rhog - 1 / rhol ) - log ( rhol / rhog ) - K , lu * ( 1 - x ) + vu * x - u )  prop = self . fsolve ( f , f2 , ** { <str> : h , <str> : rho } ) T = prop [ <str> ] if <str> in prop :                  rho = prop [ <str> ]  elif <str> in prop :                  rhoG = prop [ <str> ] rhoL = prop [ <str> ] x = ( 1. / rho - 1 / rhoL ) / ( 1 / rhoG - 1 / rhoL )   elif self . _mode == <str> :              def f ( parr ) :                  rho , T = parr if rho < 0 :                      rho = 0  if T < 0 :                      T = 1  delta = rho / self . rhoc tau = self . Tc / T ideal = self . _phi0 ( self . _constants [ <str> ] , tau , delta ) fio = ideal [ <str> ] fiot = ideal [ <str> ] fir = self . _phir ( tau , delta ) fird = self . _phird ( tau , delta ) firt = self . _phirt ( tau , delta ) ho = self . R * T * ( 1 + tau * ( fiot + firt ) + delta * fird ) so = self . R * ( tau * ( fiot + firt ) - fio - fir ) return ho - h , so - s  def f2 ( parr ) :                  T , rhol , rhog , x = parr if T < 0 :                      T = 0  if rhol < 0 :                      rhol = 0  if rhog < 0 :                      rhog = 0  if x < 0 :                      x = 0  if x > 1 :                      x = 1  tau = self . Tc / T deltaL = rhol / self . rhoc deltaG = rhog / self . rhoc idealL = self . _phi0 ( self . _constants [ <str> ] , tau , deltaL ) fioL = idealL [ <str> ] fiot = idealL [ <str> ] idealG = self . _phi0 ( self . _constants [ <str> ] , tau , deltaG ) fioG = idealG [ <str> ] firL = self . _phir ( tau , deltaL ) firdL = self . _phird ( tau , deltaL ) firtL = self . _phirt ( tau , deltaL ) hoL = self . R * T * ( 1 + tau * ( fiot + firtL ) + deltaL * firdL ) soL = self . R * ( tau * ( fiot + firtL ) - fioL - firL ) firG = self . _phir ( tau , deltaG ) firdG = self . _phird ( tau , deltaG ) firtG = self . _phirt ( tau , deltaG ) hoG = self . R * T * ( 1 + tau * ( fiot + firtG ) + deltaG * firdG ) soG = self . R * ( tau * ( fiot + firtG ) - fioG - firG ) Jl = rhol * ( 1 + deltaL * firdL ) Jv = rhog * ( 1 + deltaG * firdG ) K = firL - firG return ( Jl - Jv , Jl * ( 1 / rhog - 1 / rhol ) - log ( rhol / rhog ) - K , hoL * ( 1 - x ) + hoG * x - h , soL * ( 1 - x ) + soG * x - s )  prop = self . fsolve ( f , f2 , ** { <str> : h , <str> : s , <str> : self . Tt } ) T = prop [ <str> ] if <str> in prop :                  rho = prop [ <str> ]  else :                  rhoG = prop [ <str> ] rhoL = prop [ <str> ] x = prop [ <str> ]   elif self . _mode == <str> :              def f ( parr ) :                  rho , T = parr if rho < 0 :                      rho = 0  if T < 0 :                      T = 0  delta = rho / self . rhoc tau = self . Tc / T ideal = self . _phi0 ( self . _constants [ <str> ] , tau , delta ) fiot = ideal [ <str> ] fird = self . _phird ( tau , delta ) firt = self . _phirt ( tau , delta ) Po = self . R . kJkgK * T * ( 1 + delta * fird ) * rho ho = self . R * T * ( 1 + tau * ( fiot + firt ) + delta * fird ) return ho - h , ho - Po * 1e3 / rho - u  def f2 ( parr ) :                  T , rhol , rhog , x = parr if T < 0 :                      T = 0  if rhol < 0 :                      rhol = 0  if rhog < 0 :                      rhog = 0  if x < 0 :                      x = 0  if x > 1 :                      x = 1  tau = self . Tc / T deltaL = rhol / self . rhoc deltaG = rhog / self . rhoc ideal = self . _phi0 ( self . _constants [ <str> ] , tau , deltaL ) fiot = ideal [ <str> ] firL = self . _phir ( tau , deltaL ) firdL = self . _phird ( tau , deltaL ) firtL = self . _phirt ( tau , deltaL ) hoL = self . R * T * ( 1 + tau * ( fiot + firtL ) + deltaL * firdL ) firG = self . _phir ( tau , deltaG ) firdG = self . _phird ( tau , deltaG ) firtG = self . _phirt ( tau , deltaG ) hoG = self . R * T * ( 1 + tau * ( fiot + firtG ) + deltaG * firdG ) Jl = rhol * ( 1 + deltaL * firdL ) Jv = rhog * ( 1 + deltaG * firdG ) K = firL - firG Ps = self . R . kJkgK * T * rhol * rhog / ( rhol - rhog ) * ( K + log ( rhol / rhog ) ) vu = hoG - Ps * 1000 / rhog lu = hoL - Ps * 1000 / rhol return ( Jl - Jv , Jl * ( 1 / rhog - 1 / rhol ) - log ( rhol / rhog ) - K , hoL * ( 1 - x ) + hoG * x - h , lu * ( 1 - x ) + vu * x - u )  prop = self . fsolve ( f , f2 , ** { <str> : h , <str> : u } ) T = prop [ <str> ] if <str> in prop :                  rho = prop [ <str> ]  else :                  rhoG = prop [ <str> ] rhoL = prop [ <str> ] x = prop [ <str> ]   elif self . _mode == <str> :              def f ( parr ) :                  rho , T = parr if rho < 0 :                      rho = 0  if T < 0 :                      T = 0  delta = rho / self . rhoc tau = self . Tc / T ideal = self . _phi0 ( self . _constants [ <str> ] , tau , delta ) fio = ideal [ <str> ] fiot = ideal [ <str> ] fir = self . _phir ( tau , delta ) fird = self . _phird ( tau , delta ) firt = self . _phirt ( tau , delta ) ho = self . R * T * ( 1 + tau * ( fiot + firt ) + delta * fird ) so = self . R * ( tau * ( fiot + firt ) - fio - fir ) Po = self . R . kJkgK * T * ( 1 + delta * fird ) * rho return so - s , ho - Po * 1e3 / rho - u  def f2 ( parr ) :                  T , rhol , rhog , x = parr if T < 0 :                      T = 0  if rhol < 0 :                      rhol = 0  if rhog < 0 :                      rhog = 0  if x < 0 :                      x = 0  if x > 1 :                      x = 1  tau = self . Tc / T deltaL = rhol / self . rhoc deltaG = rhog / self . rhoc idealL = self . _phi0 ( self . _constants [ <str> ] , tau , deltaL ) fioL = idealL [ <str> ] fiot = idealL [ <str> ] idealG = self . _phi0 ( self . _constants [ <str> ] , tau , deltaG ) fioG = idealG [ <str> ] firL = self . _phir ( tau , deltaL ) firdL = self . _phird ( tau , deltaL ) firtL = self . _phirt ( tau , deltaL ) hoL = self . R * T * ( 1 + tau * ( fiot + firtL ) + deltaL * firdL ) soL = self . R * ( tau * ( fiot + firtL ) - fioL - firL ) firG = self . _phir ( tau , deltaG ) firdG = self . _phird ( tau , deltaG ) firtG = self . _phirt ( tau , deltaG ) hoG = self . R * T * ( 1 + tau * ( fiot + firtG ) + deltaG * firdG ) soG = self . R * ( tau * ( fiot + firtG ) - fioG - firG ) Jl = rhol * ( 1 + deltaL * firdL ) Jv = rhog * ( 1 + deltaG * firdG ) K = firL - firG Ps = self . R . kJkgK * T * rhol * rhog / ( rhol - rhog ) * ( K + log ( rhol / rhog ) ) vu = hoG - Ps * 1000 / rhog lu = hoL - Ps * 1000 / rhol return ( Jl - Jv , Jl * ( 1 / rhog - 1 / rhol ) - log ( rhol / rhog ) - K , soL * ( 1 - x ) + soG * x - s , lu * ( 1 - x ) + vu * x - u )  prop = self . fsolve ( f , f2 , ** { <str> : s , <str> : u } ) T = prop [ <str> ] if <str> in prop :                  rho = prop [ <str> ]  else :                  rhoG = prop [ <str> ] rhoL = prop [ <str> ] x = prop [ <str> ]   elif self . _mode == <str> :              if self . Tt > T or self . Tc < T :                  raise ValueError ( <str> )  rhoL , rhoG , Ps = self . _saturation ( T ) rho = 1 / ( 1 / rhoG * x + 1 / rhoL * ( 1 - x ) ) P = Ps self . status = 1  elif self . _mode == <str> :              def funcion ( T ) :                  T = float ( T ) rhol , rhov , Ps = self . _saturation ( T ) return Ps - P  T = fsolve ( funcion , 0.99 * self . Tc ) [ 0 ] rhoL , rhoG , Ps = self . _saturation ( T ) rho = 1 / ( 1 / rhoG * x + 1 / rhoL * ( 1 - x ) ) self . status = 1  if x is None :              if T > self . Tc :                  x = 1  else :                  rhol , rhov , Ps = self . _saturation ( T ) if Ps > P :                      x = 1  else :                      x = 0    elif 0 < x < 1 :              rho = 1 / ( 1 / rhoG * x + 1 / rhoL * ( 1 - x ) )  if self . _mode == <str> and self . kwargs [ <str> ] == 0 :              self . status = 3 self . msg = QApplication . translate ( <str> , <str> )  elif self . _constants [ <str> ] <= T <= self . _constants [ <str> ] and 0 < rho :              self . status = 1 self . msg = <str>  else :              self . status = 5 self . msg = QApplication . translate ( <str> , <str> ) return  if x == 0 :              rhoL = rho liquido = self . _eq ( rhoL , T ) if self . _code == <str> :                  v = self . vtPR ( ) liquido [ <str> ] = v  propiedades = liquido  elif x == 1 :              rhoG = rho vapor = self . _eq ( rhoG , T ) propiedades = vapor  else :              liquido = self . _eq ( rhoL , T ) vapor = self . _eq ( rhoG , T ) if self . _code == <str> :                  v = self . vtPR ( ) liquido [ <str> ] = v   if self . kwargs [ <str> ] :              P = self . kwargs [ <str> ]  elif 0 < x < 1 :              P = vapor [ <str> ]  elif not P :              P = propiedades [ <str> ]  self . T = unidades . Temperature ( T ) self . Tr = unidades . Dimensionless ( T / self . Tc ) self . P = unidades . Pressure ( P ) self . Pr = unidades . Dimensionless ( self . P / self . Pc ) self . x = unidades . Dimensionless ( x ) cp0 = self . _prop0 ( rho , self . T ) self . v0 = unidades . SpecificVolume ( cp0 [ <str> ] ) self . rho0 = unidades . Density ( 1. / self . v0 ) self . rhoM0 = unidades . MolarDensity ( self . rho0 / self . M ) self . h0 = unidades . Enthalpy ( cp0 [ <str> ] ) self . hM0 = unidades . MolarEnthalpy ( self . h0 / self . M ) self . u0 = unidades . Enthalpy ( self . h0 - self . P * self . v0 ) self . uM0 = unidades . MolarEnthalpy ( self . u0 / self . M ) self . s0 = unidades . SpecificHeat ( cp0 [ <str> ] ) self . sM0 = unidades . MolarSpecificHeat ( self . s0 / self . M ) self . a0 = unidades . Enthalpy ( self . u0 - self . T * self . s0 ) self . aM0 = unidades . MolarEnthalpy ( self . a0 / self . M ) self . g0 = unidades . Enthalpy ( self . h0 - self . T * self . s0 ) self . gM0 = unidades . MolarEnthalpy ( self . g0 / self . M ) self . cp0 = unidades . SpecificHeat ( cp0 [ <str> ] ) self . cpM0 = unidades . MolarSpecificHeat ( self . cp0 / self . M ) self . cv0 = unidades . SpecificHeat ( cp0 [ <str> ] ) self . cvM0 = unidades . MolarSpecificHeat ( self . cv0 / self . M ) self . cp0_cv = unidades . Dimensionless ( self . cp0 / self . cv0 ) self . gamma0 = self . cp0_cv self . Liquido = ThermoAdvanced ( ) self . Gas = ThermoAdvanced ( ) if x == 0 :              self . fill ( self . Liquido , propiedades ) self . fill ( self , propiedades ) self . fillNone ( self . Gas )  elif x == 1 :              self . fill ( self . Gas , propiedades ) self . fill ( self , propiedades ) self . fillNone ( self . Liquido )  else :              self . fillNone ( self ) self . fill ( self . Liquido , liquido ) self . fill ( self . Gas , vapor ) self . v = unidades . SpecificVolume ( x * self . Gas . v + ( 1 - x ) * self . Liquido . v ) self . rho = unidades . Density ( 1. / self . v ) self . h = unidades . Enthalpy ( x * self . Gas . h + ( 1 - x ) * self . Liquido . h ) self . s = unidades . SpecificHeat ( x * self . Gas . s + ( 1 - x ) * self . Liquido . s ) self . u = unidades . Enthalpy ( x * self . Gas . u + ( 1 - x ) * self . Liquido . u ) self . a = unidades . Enthalpy ( x * self . Gas . a + ( 1 - x ) * self . Liquido . a ) self . g = unidades . Enthalpy ( x * self . Gas . g + ( 1 - x ) * self . Liquido . g ) self . rhoM = unidades . MolarDensity ( self . rho / self . M ) self . hM = unidades . MolarEnthalpy ( self . h * self . M ) self . sM = unidades . MolarSpecificHeat ( self . s * self . M ) self . uM = unidades . MolarEnthalpy ( self . u * self . M ) self . aM = unidades . MolarEnthalpy ( self . a * self . M ) self . gM = unidades . MolarEnthalpy ( self . g * self . M )  if x < 1 and self . Tt <= T <= self . Tc :              self . sigma = unidades . Tension ( self . _Surface ( T ) )  else :              self . sigma = unidades . Tension ( None )  if 0 < self . x < 1 :              self . Hvap = unidades . Enthalpy ( self . Gas . h - self . Liquido . h ) self . Svap = unidades . SpecificHeat ( self . Gas . s - self . Liquido . s )  else :              self . Hvap = unidades . Enthalpy ( None ) self . Svap = unidades . SpecificHeat ( None )  self . invT = unidades . InvTemperature ( - 1 / self . T ) if self . _constants [ <str> ] == <str> and <str> in self . _constants :              if <str> in self . _constants :                  self . rhoc = unidades . Density ( self . _constants [ <str> ] * self . M )  else :                  self . rhoc = self . __class__ . rhoc    def fsolve ( self , f , f2 = None , ** kwargs ) :          if <str> not in kwargs :              to = [ self . _constants [ <str> ] , ( self . Tt + self . Tc ) / 2 , self . Tc , self . _constants [ <str> ] ] if self . kwargs [ <str> ] :                  if isinstance ( kwargs [ <str> ] , list ) :                      for t in kwargs [ <str> ] [ - 1 : : - 1 ] :                          to . insert ( 0 , t )   else :                      to . insert ( 0 , self . kwargs [ <str> ] )    if <str> not in kwargs :              rhov = self . _Vapor_Density ( self . Tt ) rhol = self . _Liquid_Density ( self . Tt ) ro = [ rhov , rhol , self . rhoc , self . _constants [ <str> ] * self . M ] if <str> in kwargs and kwargs [ <str> ] :                  if isinstance ( kwargs [ <str> ] , list ) :                      for rho in kwargs [ <str> ] [ - 1 : : - 1 ] :                          ro . insert ( 0 , rho )   else :                      ro . insert ( 0 , kwargs [ <str> ] )    prop = { } rinput = None rho , T = 0 , 0 converge = False if <str> in kwargs :              T = kwargs [ <str> ] for r in ro :                  try :                      rinput = fsolve ( f , r , full_output = True ) rho = rinput [ 0 ] [ 0 ]  except :                      pass  else :                      f1 = sum ( abs ( rinput [ 1 ] [ <str> ] ) ) idx = rinput [ 2 ] if 0 < rho < self . _constants [ <str> ] * self . M and f1 < 1e-5 and idx == 1 :                          converge = True break     elif <str> in kwargs :              rho = kwargs [ <str> ] for t in to :                  try :                      rinput = fsolve ( f , t , full_output = True ) T = rinput [ 0 ] [ 0 ]  except :                      pass  else :                      f1 = sum ( abs ( rinput [ 1 ] [ <str> ] ) ) if self . _liquid_Density and self . _vapor_Density :                          rhol = self . _Liquid_Density ( T ) rhov = self . _Vapor_Density ( T ) twophases = self . Tt < T < self . Tc and rhov < rho < rhol  else :                          twophases = False  v = self . _constants [ <str> ] <= T <= self . _constants [ <str> ] if v and f1 < 1e-5 and not twophases :                          converge = True break     else :              for r , t in product ( ro , to ) :                  try :                      rinput = fsolve ( f , [ r , t ] , full_output = True ) rho , T = rinput [ 0 ]  except :                      pass  else :                      f1 = sum ( abs ( rinput [ 1 ] [ <str> ] ) ) if self . _liquid_Density and self . _vapor_Density :                          rhol = self . _Liquid_Density ( T ) rhov = self . _Vapor_Density ( T ) twophases = self . Tt < T < self . Tc and rhov < rho < rhol  else :                          twophases = False  if ( rho != r or T != t ) and 0 < rho < self . _constants [ <str> ] * self . M and f1 < 1e-5 and not twophases :                          converge = True break     if f2 is not None and not converge :              for to in ( ( self . Tc + self . Tt ) / 2 , self . Tt , self . Tc ) :                  rLo = self . _Liquid_Density ( to ) rGo = self . _Vapor_Density ( to ) if <str> in kwargs :                      try :                          rinput = fsolve ( f2 , [ to , rLo , rGo ] , full_output = True ) T , rhoL , rhoG = rinput [ 0 ]  except :                          pass  else :                          if sum ( abs ( rinput [ 1 ] [ <str> ] ) ) < 1e-5 :                              prop [ <str> ] = T prop [ <str> ] = rhoL prop [ <str> ] = rhoG break    else :                      try :                          rinput = fsolve ( f2 , [ to , rLo , rGo , 0.5 ] , full_output = True ) T , rhoL , rhoG , x = rinput [ 0 ]  except :                          pass  else :                          if sum ( abs ( rinput [ 1 ] [ <str> ] ) ) < 1e-5 :                              prop [ <str> ] = T prop [ <str> ] = rhoL prop [ <str> ] = rhoG prop [ <str> ] = x break      else :              if <str> in kwargs :                  prop [ <str> ] = rho  elif <str> in kwargs :                  prop [ <str> ] = T  else :                  prop [ <str> ] = rho prop [ <str> ] = T   return prop  def fill ( self , fase , estado ) :          fase . _bool = True fase . M = unidades . Dimensionless ( self . M ) fase . v = unidades . SpecificVolume ( estado [ <str> ] ) fase . rho = unidades . Density ( 1 / fase . v ) fase . Z = unidades . Dimensionless ( self . P * fase . v / self . T / self . R ) tau = estado [ <str> ] delta = estado [ <str> ] fio = estado [ <str> ] fiot = estado [ <str> ] fiott = estado [ <str> ] fiodt = estado [ <str> ] fir = estado [ <str> ] firt = estado [ <str> ] firtt = estado [ <str> ] fird = estado [ <str> ] firdd = estado [ <str> ] firdt = estado [ <str> ] fase . fir = fir fase . fird = fird fase . firdd = firdd fase . firt = firt fase . firtt = firtt fase . firdt = firdt h = self . R . kJkgK * self . T * ( 1 + tau * ( fiot + firt ) + delta * fird ) + self . href - self . hoffset s = self . R . kJkgK * ( tau * ( fiot + firt ) - fio - fir ) + self . sref - self . soffset cv = - self . R . kJkgK * tau ** 2 * ( fiott + firtt ) cp = self . R . kJkgK * ( - tau ** 2 * ( fiott + firtt ) + ( 1 + delta * fird - delta * tau * firdt ) ** 2 / ( 1 + 2 * delta * fird + delta ** 2 * firdd ) ) w = ( self . R * self . T * ( 1 + 2 * delta * fird + delta ** 2 * firdd - ( 1 + delta * fird - delta * tau * firdt ) ** 2 / tau ** 2 / ( fiott + firtt ) ) ) ** 0.5 fugacity = exp ( fir + delta * fird - log ( 1 + delta * fird ) ) alfap = ( 1 - delta * tau * firdt / ( 1 + delta * fird ) ) / self . T betap = fase . rho * ( 1 + ( delta * fird + delta ** 2 * firdd ) / ( 1 + delta * fird ) ) fase . h = unidades . Enthalpy ( h , <str> ) fase . s = unidades . SpecificHeat ( s , <str> ) fase . u = unidades . Enthalpy ( fase . h - self . P * fase . v ) fase . a = unidades . Enthalpy ( fase . u - self . T * fase . s ) fase . g = unidades . Enthalpy ( fase . h - self . T * fase . s ) fase . fi = [ unidades . Dimensionless ( fugacity ) ] fase . f = [ unidades . Pressure ( f * self . P ) for f in fase . fi ] fase . cp = unidades . SpecificHeat ( cp , <str> ) fase . cv = unidades . SpecificHeat ( cv , <str> ) fase . cp_cv = unidades . Dimensionless ( fase . cp / fase . cv ) fase . w = unidades . Speed ( w ) fase . rhoM = unidades . MolarDensity ( fase . rho / self . M ) fase . hM = unidades . MolarEnthalpy ( fase . h * self . M ) fase . sM = unidades . MolarSpecificHeat ( fase . s * self . M ) fase . uM = unidades . MolarEnthalpy ( fase . u * self . M ) fase . aM = unidades . MolarEnthalpy ( fase . a * self . M ) fase . gM = unidades . MolarEnthalpy ( fase . g * self . M ) fase . cvM = unidades . MolarSpecificHeat ( fase . cv * self . M ) fase . cpM = unidades . MolarSpecificHeat ( fase . cp * self . M ) fase . alfap = unidades . InvTemperature ( alfap ) fase . betap = unidades . Density ( betap ) if fase . rho :              fase . gamma = unidades . Dimensionless ( - fase . v / self . P * self . derivative ( <str> , <str> , <str> , fase ) )  else :              fase . gamma = self . gamma0  fase . joule = unidades . TemperaturePressure ( self . derivative ( <str> , <str> , <str> , fase ) ) fase . Gruneisen = unidades . Dimensionless ( fase . v / fase . cv * self . derivative ( <str> , <str> , <str> , fase ) ) if fase . rho :              fase . alfav = unidades . InvTemperature ( self . derivative ( <str> , <str> , <str> , fase ) / fase . v ) fase . kappa = unidades . InvPressure ( - self . derivative ( <str> , <str> , <str> , fase ) / fase . v ) fase . kappas = unidades . InvPressure ( - 1 / fase . v * self . derivative ( <str> , <str> , <str> , fase ) ) fase . betas = unidades . TemperaturePressure ( self . derivative ( <str> , <str> , <str> , fase ) ) fase . kt = unidades . Dimensionless ( - fase . v / self . P * self . derivative ( <str> , <str> , <str> , fase ) ) fase . ks = unidades . Dimensionless ( - fase . v / self . P * self . derivative ( <str> , <str> , <str> , fase ) ) fase . Ks = unidades . Pressure ( - fase . v * self . derivative ( <str> , <str> , <str> , fase ) ) fase . Kt = unidades . Pressure ( - fase . v * self . derivative ( <str> , <str> , <str> , fase ) ) fase . dhdT_rho = unidades . SpecificHeat ( self . derivative ( <str> , <str> , <str> , fase ) ) fase . dhdT_P = unidades . SpecificHeat ( self . derivative ( <str> , <str> , <str> , fase ) ) fase . dhdP_T = unidades . EnthalpyPressure ( self . derivative ( <str> , <str> , <str> , fase ) ) fase . deltat = fase . dhdP_T fase . dhdP_rho = unidades . EnthalpyPressure ( self . derivative ( <str> , <str> , <str> , fase ) ) dpdrho = self . R * self . T * ( 1 + 2 * delta * fird + delta ** 2 * firdd ) drhodt = - fase . rho * ( 1 + delta * fird - delta * tau * firdt ) / ( self . T * ( 1 + 2 * delta * fird + delta ** 2 * firdd ) ) dhdrho = self . R * self . T / fase . rho * ( tau * delta * ( fiodt + firdt ) + delta * fird + delta ** 2 * firdd ) fase . dhdrho_T = unidades . EnthalpyDensity ( dhdrho ) fase . dhdrho_P = unidades . EnthalpyDensity ( dhdrho + fase . dhdT_rho / drhodt ) fase . dpdrho_T = unidades . PressureDensity ( dpdrho ) fase . drhodP_T = unidades . DensityPressure ( 1 / dpdrho ) fase . drhodT_P = unidades . DensityTemperature ( drhodt ) fase . Z_rho = unidades . SpecificVolume ( ( fase . Z - 1 ) / fase . rho ) fase . hInput = unidades . Enthalpy ( fase . v * self . derivative ( <str> , <str> , <str> , fase ) )  fase . dpdT_rho = unidades . PressureTemperature ( self . derivative ( <str> , <str> , <str> , fase ) ) fase . IntP = unidades . Pressure ( self . derivative ( <str> , <str> , <str> , fase ) ) fase . virialB = unidades . SpecificVolume ( estado [ <str> ] / self . rhoc ) fase . virialC = unidades . SpecificVolume_square ( estado [ <str> ] / self . rhoc ** 2 ) fase . virialD = unidades . Dimensionless ( estado [ <str> ] / self . rhoc ** 3 ) fase . invT = unidades . InvTemperature ( - 1 / self . T ) fase . mu = self . _Viscosity ( fase . rho , self . T , fase ) fase . k = self . _ThCond ( fase . rho , self . T , fase ) if fase . mu and fase . rho :              fase . nu = unidades . Diffusivity ( fase . mu / fase . rho )  else :              fase . nu = unidades . Diffusivity ( None )  if fase . k and fase . rho :              fase . alfa = unidades . Diffusivity ( fase . k / fase . rho / fase . cp )  else :              fase . alfa = unidades . Diffusivity ( None )  if fase . mu and fase . k :              fase . Prandt = unidades . Dimensionless ( fase . mu * fase . cp / fase . k )  else :              fase . Prandt = unidades . Dimensionless ( None )  fase . epsilon = unidades . Dimensionless ( self . _Dielectric ( fase . rho , self . T ) ) fase . fraccion = [ 1 ] fase . fraccion_masica = [ 1 ]  @ refDoc ( __doi__ , [ 9 ] , tab = 8 ) def _saturation ( self , T = None ) :          if not T :              T = self . T  if T > self . Tc :              T = self . Tc  T = float ( T ) rhoLo = self . _Liquid_Density ( T ) rhoGo = self . _Vapor_Density ( T ) def f ( parr ) :              rhol , rhog = parr deltaL = rhol / self . rhoc deltaG = rhog / self . rhoc liquidofird = self . _phird ( self . Tc / T , deltaL ) liquidofir = self . _phir ( self . Tc / T , deltaL ) vaporfird = self . _phird ( self . Tc / T , deltaG ) vaporfir = self . _phir ( self . Tc / T , deltaG ) Jl = deltaL * ( 1 + deltaL * liquidofird ) Jv = deltaG * ( 1 + deltaG * vaporfird ) Kl = deltaL * liquidofird + liquidofir + log ( deltaL ) Kv = deltaG * vaporfird + vaporfir + log ( deltaG ) return Kv - Kl , Jv - Jl  rhoL , rhoG = fsolve ( f , [ rhoLo , rhoGo ] ) if rhoL == rhoG :              Ps = self . Pc  else :              liquido = self . _eq ( rhoL , T ) vapor = self . _eq ( rhoG , T ) deltaL = rhoL / self . rhoc deltaG = rhoG / self . rhoc Ps = self . R * T * rhoL * rhoG / ( rhoL - rhoG ) * ( liquido [ <str> ] - vapor [ <str> ] + log ( deltaL / deltaG ) )  return rhoL , rhoG , Ps  def _eq ( self , rho , T ) :          delta = rho / self . rhoc tau = self . Tc / T prop = self . _phi0 ( self . _constants [ <str> ] , tau , delta ) if self . _code == <str> :              res = self . _PengRobinson ( rho , T )  elif self . _constants [ <str> ] == <str> :              res = self . _Helmholtz ( tau , delta ) prop [ <str> ] = ( 1 + delta * res [ <str> ] ) * self . R * T * rho  elif self . _constants [ <str> ] == <str> :              res = self . _MBWR ( rho , T )  else :              pass  prop . update ( res ) prop [ <str> ] = tau prop [ <str> ] = delta prop [ <str> ] = T if rho :              prop [ <str> ] = 1. / rho  else :              prop [ <str> ] = float ( <str> )  return prop  def _phir ( self , tau , delta ) :          if self . _code == <str> :              kw = { } kw [ <str> ] = self . rhoc kw [ <str> ] = self . Tc kw [ <str> ] = 0.0778 * R * self . Tc / self . Pc kw [ <str> ] = 1 + 2 ** 0.5 kw [ <str> ] = 1 - 2 ** 0.5 a = 0.457235 * R ** 2 * self . Tc ** 2 / self . Pc Tr = 1 / tau m = 0.37464 + 1.54226 * self . f_acent - 0.26992 * self . f_acent ** 2 alfa = a * ( 1 + m * ( 1 - Tr ** 0.5 ) ) ** 2 kw [ <str> ] = alfa fir = _PR_phir ( tau , delta , ** kw )  elif self . _constants [ <str> ] == <str> :              fir = _Helmholtz_phir ( tau , delta , self . _constants )  elif self . _constants [ <str> ] == <str> :              T = self . Tc / tau rho = delta * self . rhoc if <str> in self . _constants :                  rhocm = 1 / ( - self . _constants [ <str> ] ) ** 0.5 rhoc = rhocm * self . M  else :                  rhoc = self . rhoc rhocm = rhoc / self . M  fir = _MBWR_phir ( T , rho , rhoc , self . M , self . _constants )  return fir  def _phird ( self , tau , delta ) :          if self . _code == <str> :              kw = { } kw [ <str> ] = self . rhoc kw [ <str> ] = 0.0778 * R * self . Tc / self . Pc kw [ <str> ] = 1 + 2 ** 0.5 kw [ <str> ] = 1 - 2 ** 0.5 a = 0.457235 * R ** 2 * self . Tc ** 2 / self . Pc Tr = 1 / tau m = 0.37464 + 1.54226 * self . f_acent - 0.26992 * self . f_acent ** 2 alfa = a * ( 1 + m * ( 1 - Tr ** 0.5 ) ) ** 2 kw [ <str> ] = alfa fir = _PR_phird ( tau , delta , ** kw )  elif self . _constants [ <str> ] == <str> :              fir = _Helmholtz_phird ( tau , delta , self . _constants )  elif self . _constants [ <str> ] == <str> :              T = self . Tc / tau if <str> in self . _constants :                  rhocm = 1 / ( - self . _constants [ <str> ] ) ** 0.5 rhoc = rhocm * self . M  else :                  rhoc = self . rhoc  rho = delta * rhoc fir = _MBWR_phird ( T , rho , rhoc , self . M , self . _constants )  return fir  def _phirt ( self , tau , delta ) :          if self . _code == <str> :              kw = { } kw [ <str> ] = self . rhoc kw [ <str> ] = 0.0778 * R * self . Tc / self . Pc kw [ <str> ] = 1 + 2 ** 0.5 kw [ <str> ] = 1 - 2 ** 0.5 a = 0.457235 * R ** 2 * self . Tc ** 2 / self . Pc Tr = 1 / tau m = 0.37464 + 1.54226 * self . f_acent - 0.26992 * self . f_acent ** 2 alfa = a * ( 1 + m * ( 1 - Tr ** 0.5 ) ) ** 2 kw [ <str> ] = alfa fir = _PR_phirt ( tau , delta , ** kw )  elif self . _constants [ <str> ] == <str> :              fir = _Helmholtz_phirt ( tau , delta , self . _constants )  elif self . _constants [ <str> ] == <str> :              T = self . Tc / tau if <str> in self . _constants :                  rhocm = 1 / ( - self . _constants [ <str> ] ) ** 0.5 rhoc = rhocm * self . M  else :                  rhoc = self . rhoc  rho = delta * rhoc fir = _MBWR_phirt ( T , self . Tc , rho , rhoc , self . M , self . _constants )  return fir  @ refDoc ( __doi__ , [ 10 ] , tab = 8 ) def _Generalised ( self ) :          if self . _Tr :              Tref = self . _Tr  else :              Tref = self . Tc  if self . _rhor :              rhoref = self . _rhor  else :              rhoref = self . rhoc  if self . _w :              w = self . _w  else :              w = self . f_acent  helmholtz = { <str> : 8.31451 , <str> : Tref , <str> : rhoref , <str> : self . eq [ 0 ] [ <str> ] , <str> : [ 1 , 1 , 2 , 3 , 8 ] , <str> : [ 0.125 , 1.125 , 1.25 , 0.25 , 0.75 ] , <str> : [ 2 , 3 , 1 , 4 , 3 ] , <str> : [ 0.625 , 2 , 4.125 , 4.125 , 17 ] , <str> : [ 1 , 1 , 2 , 2 , 3 ] , <str> : [ 1 ] * 5 } c1 = [ 0.636479524 , - 0.174667493e1 , - 0.144442644e-1 , 0.6799731e-1 , 0.767320032e-4 , 0.218194143 , 0.810318494e-1 , - 0.907368899e-1 , 0.25312225e-1 , - 0.209937023e-1 ] c2 = [ 0.82247342 , - 0.954932692 , - 0.745462328 , 0.182685593 , 0.547120142e-4 , 0.761697913 , 0.415691324 , - 0.825206373 , - 0.240558288 , - 0.643818403e-1 ] c3 = [ - 0.186193063e1 , 0.105083555e2 , 0.16403233e1 , - 0.613747797 , - 0.69318829e-3 , - 0.705727791e1 , - 0.290006245e1 , - 0.232497527 , - 0.282346515 , 0.254250643e1 ] nr = [ c1 [ i ] + c2 [ i ] * w + c3 [ i ] * w ** 4 for i in range ( 10 ) ] helmholtz [ <str> ] = nr [ : 5 ] helmholtz [ <str> ] = nr [ 5 : ] self . _constants = helmholtz  def _ref ( self , ref , refvalues = None ) :          applyOffset = <str> in self . _constants [ <str> ] or ref is not None if ref is None :              rf = self . _constants [ <str> ] if isinstance ( rf , str ) :                  ref = rf  elif isinstance ( rf , dict ) :                  ref = <str> refvalues = ( rf [ <str> ] , rf [ <str> ] , rf [ <str> ] , rf [ <str> ] )  else :                  ref = <str>   self . href = 0 self . sref = 0 if applyOffset :              if ref in [ <str> , <str> , <str> , <str> ] :                  self . href = 0 self . sref = 0  elif ref == <str> :                  self . href = 200 self . sref = 1  elif refvalues :                  self . href = refvalues [ 2 ] / self . M self . sref = refvalues [ 3 ] / self . M  self . _refOffset ( ref , refvalues )  else :              self . _refOffset ( False , refvalues )   def _refOffset ( self , ref , refvalues ) :          name = <str> % ( self . __class__ . __name__ , self . _code ) if ref == <str> :              if refvalues is None :                  refvalues = [ 298.15 , 101325. , 0. , 0. ]  ref = <str> % refvalues  if ref is False :              self . hoffset = 0 self . soffset = 0 return  filename = conf_dir + <str> if os . path . isfile ( filename ) :              with open ( filename , <str> ) as archivo :                  dat = json . load ( archivo )   else :              dat = { }  if name in dat and ref in dat [ name ] :              self . hoffset = dat [ name ] [ ref ] [ <str> ] self . soffset = dat [ name ] [ ref ] [ <str> ]  else :              if name not in dat :                  dat [ name ] = { }  kw = { <str> : False } kw [ <str> ] = self . kwargs [ <str> ] kw [ <str> ] = self . kwargs [ <str> ] kw [ <str> ] = self . kwargs [ <str> ] if ref == <str> :                  st = self . __class__ ( T = 298.15 , P = 101325 , ** kw ) self . hoffset = st . h0 . kJkg self . soffset = st . s0 . kJkgK  elif ref == <str> :                  st = self . __class__ ( T = 298.15 , P = 101325 , ** kw ) self . hoffset = st . h . kJkg self . soffset = st . s . kJkgK  elif ref == <str> :                  st = self . __class__ ( P = 101325 , x = 0 , ** kw ) self . hoffset = st . h . kJkg self . soffset = st . s . kJkgK  elif ref == <str> :                  st = self . __class__ ( T = 273.15 , x = 0 , ** kw ) self . hoffset = st . h . kJkg self . soffset = st . s . kJkgK  elif ref == <str> :                  st = self . __class__ ( T = 233.15 , x = 0 , ** kw ) self . hoffset = st . h . kJkg self . soffset = st . s . kJkgK  elif ref [ : 6 ] == <str> :                  code = <str> % refvalues if code not in dat [ name ] :                      T = refvalues [ 0 ] P = refvalues [ 1 ] * 1e3 st = self . __class__ ( T = T , P = P , ** kw ) self . hoffset = st . h . kJkg self . soffset = st . s . kJkgK   dat [ name ] [ ref ] = { <str> : self . hoffset , <str> : self . soffset } with open ( filename , <str> ) as archivo :                  json . dump ( dat , archivo )    def _prop0 ( self , rho , T ) :          delta = rho / self . rhoc tau = self . Tc / T ideal = self . _phi0 ( self . _constants [ <str> ] , tau , delta ) fio = ideal [ <str> ] fiot = ideal [ <str> ] fiott = ideal [ <str> ] propiedades = { } if rho :              propiedades [ <str> ] = self . R * T / self . P  else :              propiedades [ <str> ] = float ( <str> )  propiedades [ <str> ] = self . R * T * ( 1 + tau * fiot ) propiedades [ <str> ] = self . R * ( tau * fiot - fio ) propiedades [ <str> ] = - self . R * tau ** 2 * fiott propiedades [ <str> ] = self . R * ( - tau ** 2 * fiott + 1 ) return propiedades  def _PHIO ( self , cp ) :          co = cp [ <str> ] - 1 ti = [ ] ci = [ ] taulogtau = 0 for n , t in zip ( cp [ <str> ] , cp [ <str> ] ) :              if t == - 1 :                  taulogtau = - n / self . Tc  else :                  ti . append ( - t ) ci . append ( - n / ( t * ( t + 1 ) ) * self . Tc ** t )   titao = [ fi / self . Tc for fi in cp [ <str> ] ] sinh = [ fi / self . Tc for fi in cp . get ( <str> , [ ] ) ] cosh = [ fi / self . Tc for fi in cp . get ( <str> , [ ] ) ] cI = 0 cII = 0 Fi0 = { <str> : [ 1 , co ] , <str> : [ 0 , 1 ] + ti , <str> : [ cII , cI ] + ci , <str> : cp [ <str> ] , <str> : titao , <str> : cp . get ( <str> , [ ] ) , <str> : sinh , <str> : cp . get ( <str> , [ ] ) , <str> : cosh } if taulogtau :              Fi0 [ <str> ] = taulogtau  return Fi0  def _phi0 ( self , cp , tau , delta ) :          <str> if <str> in cp :              Fi0 = cp  else :              Fi0 = self . _PHIO ( cp )  fio = Fi0 [ <str> ] [ 1 ] * log ( tau ) fiot = Fi0 [ <str> ] [ 1 ] / tau fiott = - Fi0 [ <str> ] [ 1 ] / tau ** 2 if delta :              fiod = 1 / delta fiodd = - 1 / delta ** 2  else :              fiod , fiodd = 0 , 0  fiodt = 0 R_ = cp . get ( <str> , self . _constants [ <str> ] ) for n , t in zip ( Fi0 [ <str> ] , Fi0 [ <str> ] ) :              fio += n * tau ** t if t != 0 :                  fiot += t * n * tau ** ( t - 1 )  if t not in [ 0 , 1 ] :                  fiott += n * t * ( t - 1 ) * tau ** ( t - 2 )   for n , g in zip ( Fi0 [ <str> ] , Fi0 [ <str> ] ) :              fio += n * log ( 1 - exp ( - g * tau ) ) fiot += n * g * ( ( 1 - exp ( - g * tau ) ) ** - 1 - 1 ) fiott -= n * g ** 2 * exp ( - g * tau ) * ( 1 - exp ( - g * tau ) ) ** - 2  if <str> in Fi0 :              fio += Fi0 [ <str> ] * tau * log ( tau ) fiot += Fi0 [ <str> ] * ( log ( tau ) + 1 ) fiott += Fi0 [ <str> ] / tau  if <str> in Fi0 and delta :              fio += Fi0 [ <str> ] * tau * log ( delta ) fiot += Fi0 [ <str> ] * log ( delta ) fiod += Fi0 [ <str> ] * tau / delta fiodd -= Fi0 [ <str> ] * tau / delta ** 2 fiodt += Fi0 [ <str> ] / delta  if <str> in Fi0 :              for n , g , C in zip ( Fi0 [ <str> ] , Fi0 [ <str> ] , Fi0 [ <str> ] ) :                  fio += n * log ( C + exp ( g * tau ) ) fiot += n * g / ( C * exp ( - g * tau ) + 1 ) fiott += C * n * g ** 2 * exp ( - g * tau ) / ( C * exp ( - g * tau ) + 1 ) ** 2   if <str> in Fi0 :              for n , c in zip ( Fi0 [ <str> ] , Fi0 [ <str> ] ) :                  fio += n * log ( abs ( sinh ( c * tau ) ) ) fiot += n * c / tanh ( c * tau ) fiott -= n * c ** 2 / sinh ( c * tau ) ** 2   if <str> in Fi0 :              for n , c in zip ( Fi0 [ <str> ] , Fi0 [ <str> ] ) :                  fio -= n * log ( abs ( cosh ( c * tau ) ) ) fiot -= n * c * tanh ( c * tau ) fiott -= n * c ** 2 / cosh ( c * tau ) ** 2   R_ = cp . get ( <str> , self . _constants [ <str> ] ) factor = R_ / self . _constants [ <str> ] if delta :              fio = Fi0 [ <str> ] [ 0 ] * log ( delta ) + factor * fio  else :              fio *= factor  prop = { } prop [ <str> ] = fio prop [ <str> ] = fiot * factor prop [ <str> ] = fiott * factor prop [ <str> ] = fiod prop [ <str> ] = fiodd prop [ <str> ] = fiodt return prop  def _Helmholtz ( self , tau , delta ) :          <str> fir = fird = firdd = firt = firtt = firdt = firdtt = 0 firddd = firttt = firddt = 0 delta_0 = 1e-100 B = C = D = 0 if delta :              nr1 = self . _constants . get ( <str> , [ ] ) d1 = self . _constants . get ( <str> , [ ] ) t1 = self . _constants . get ( <str> , [ ] ) for n , d , t in zip ( nr1 , d1 , t1 ) :                  fir += n * delta ** d * tau ** t fird += n * d * delta ** ( d - 1 ) * tau ** t firdd += n * d * ( d - 1 ) * delta ** ( d - 2 ) * tau ** t firt += n * t * delta ** d * tau ** ( t - 1 ) firtt += n * t * ( t - 1 ) * delta ** d * tau ** ( t - 2 ) firdt += n * t * d * delta ** ( d - 1 ) * tau ** ( t - 1 ) firdtt += n * t * d * ( t - 1 ) * delta ** ( d - 1 ) * tau ** ( t - 2 ) B += n * d * delta_0 ** ( d - 1 ) * tau ** t C += n * d * ( d - 1 ) * delta_0 ** ( d - 2 ) * tau ** t  nr2 = self . _constants . get ( <str> , [ ] ) d2 = self . _constants . get ( <str> , [ ] ) g2 = self . _constants . get ( <str> , [ ] ) t2 = self . _constants . get ( <str> , [ ] ) c2 = self . _constants . get ( <str> , [ ] ) for n , d , g , t , c in zip ( nr2 , d2 , g2 , t2 , c2 ) :                  fir += n * delta ** d * tau ** t * exp ( - g * delta ** c ) fird += n * exp ( - g * delta ** c ) * delta ** ( d - 1 ) * tau ** t * ( d - g * c * delta ** c ) firdd += n * exp ( - g * delta ** c ) * delta ** ( d - 2 ) * tau ** t * ( ( d - g * c * delta ** c ) * ( d - 1 - g * c * delta ** c ) - g ** 2 * c ** 2 * delta ** c ) firt += n * t * delta ** d * tau ** ( t - 1 ) * exp ( - g * delta ** c ) firtt += n * t * ( t - 1 ) * delta ** d * tau ** ( t - 2 ) * exp ( - g * delta ** c ) firdt += n * t * delta ** ( d - 1 ) * tau ** ( t - 1 ) * ( d - g * c * delta ** c ) * exp ( - g * delta ** c ) firdtt += n * t * ( t - 1 ) * delta ** ( d - 1 ) * tau ** ( t - 2 ) * ( d - g * c * delta ** c ) * exp ( - g * delta ** c ) B += n * exp ( - g * delta_0 ** c ) * delta_0 ** ( d - 1 ) * tau ** t * ( d - g * c * delta_0 ** c ) C += n * exp ( - g * delta_0 ** c ) * ( delta_0 ** ( d - 2 ) * tau ** t * ( ( d - g * c * delta_0 ** c ) * ( d - 1 - g * c * delta_0 ** c ) - g ** 2 * c ** 2 * delta_0 ** c ) )  nr3 = self . _constants . get ( <str> , [ ] ) d3 = self . _constants . get ( <str> , [ ] ) t3 = self . _constants . get ( <str> , [ ] ) a3 = self . _constants . get ( <str> , [ ] ) e3 = self . _constants . get ( <str> , [ ] ) b3 = self . _constants . get ( <str> , [ ] ) g3 = self . _constants . get ( <str> , [ ] ) exp1 = self . _constants . get ( <str> , [ 2 ] * len ( nr3 ) ) exp2 = self . _constants . get ( <str> , [ 2 ] * len ( nr3 ) ) for n , d , t , a , e , b , g , ex1 , ex2 in zip ( nr3 , d3 , t3 , a3 , e3 , b3 , g3 , exp1 , exp2 ) :                  expr = exp ( - a * ( delta - e ) ** ex1 - b * ( tau - g ) ** ex2 ) fir += n * delta ** d * tau ** t * expr fird += expr * ( n * d * delta ** ( d - 1 ) * tau ** t - n * a * delta ** d * ( delta - e ) ** ( ex1 - 1 ) * ex1 * tau ** t ) firdd += expr * ( n * a ** 2 * delta ** d * ( delta - e ) ** ( 2 * ex1 - 2 ) * ex1 ** 2 * tau ** t - n * a * delta ** d * ( delta - e ) ** ( ex1 - 2 ) * ( ex1 - 1 ) * ex1 * tau ** t - 2 * n * a * d * delta ** ( d - 1 ) * ( delta - e ) ** ( ex1 - 1 ) * ex1 * tau ** t + n * ( d - 1 ) * d * delta ** ( d - 2 ) * tau ** t ) firt += expr * ( n * delta ** d * t * tau ** ( t - 1 ) - n * b * delta ** d * ex2 * tau ** t * ( tau - g ) ** ( ex2 - 1 ) ) firtt += expr * ( n * b ** 2 * delta ** d * ex2 ** 2 * tau ** t * ( tau - g ) ** ( 2 * ex2 - 2 ) - 2 * n * b * delta ** d * ex2 * t * tau ** ( t - 1 ) * ( tau - g ) ** ( ex2 - 1 ) - n * b * delta ** d * ( ex2 - 1 ) * ex2 * tau ** t * ( tau - g ) ** ( ex2 - 2 ) + n * delta ** d * ( t - 1 ) * t * tau ** ( t - 2 ) ) firdt += expr * ( n * a * b * delta ** d * ( delta - e ) ** ( ex1 - 1 ) * ex1 * ex2 * tau ** t * ( tau - g ) ** ( ex2 - 1 ) - n * b * d * delta ** ( d - 1 ) * ex2 * tau ** t * ( tau - g ) ** ( ex2 - 1 ) - n * a * delta ** d * ( delta - e ) ** ( ex1 - 1 ) * ex1 * t * tau ** ( t - 1 ) + n * d * delta ** ( d - 1 ) * t * tau ** ( t - 1 ) ) firdtt += expr * ( - n * a * b ** 2 * delta ** d * ( delta - e ) ** ( ex1 - 1 ) * ex1 * ex2 ** 2 * tau ** t * ( tau - g ) ** ( 2 * ex2 - 2 ) + n * b ** 2 * d * delta ** ( d - 1 ) * ex2 ** 2 * tau ** t * ( tau - g ) ** ( 2 * ex2 - 2 ) + 2 * n * a * b * delta ** d * ( delta - e ) ** ( ex1 - 1 ) * ex1 * ex2 * t * tau ** ( t - 1 ) * ( tau - g ) ** ( ex2 - 1 ) - 2 * n * b * d * delta ** ( d - 1 ) * ex2 * t * tau ** ( t - 1 ) * ( tau - g ) ** ( ex2 - 1 ) + n * a * b * delta ** d * ( delta - e ) ** ( ex1 - 1 ) * ex1 * ( ex2 - 1 ) * ex2 * tau ** t * ( tau - g ) ** ( ex2 - 2 ) - n * b * d * delta ** ( d - 1 ) * ( ex2 - 1 ) * ex2 * tau ** t * ( tau - g ) ** ( ex2 - 2 ) - n * a * delta ** d * ( delta - e ) ** ( ex1 - 1 ) * ex1 * ( t - 1 ) * t * tau ** ( t - 2 ) + n * d * delta ** ( d - 1 ) * ( t - 1 ) * t * tau ** ( t - 2 ) ) expr_ = exp ( - a * ( delta_0 - e ) ** ex1 - b * ( tau - g ) ** ex2 ) B += expr_ * ( n * d * delta_0 ** ( d - 1 ) * tau ** t - n * a * delta_0 ** d * ( delta_0 - e ) ** ( ex1 - 1 ) * ex1 * tau ** t ) C += expr_ * ( n * a ** 2 * delta_0 ** d * ( delta_0 - e ) ** ( 2 * ex1 - 2 ) * ex1 ** 2 * tau ** t - n * a * delta_0 ** d * ( delta_0 - e ) ** ( ex1 - 2 ) * ( ex1 - 1 ) * ex1 * tau ** t - 2 * n * a * d * delta_0 ** ( d - 1 ) * ( delta_0 - e ) ** ( ex1 - 1 ) * ex1 * tau ** t + n * ( d - 1 ) * d * delta_0 ** ( d - 2 ) * tau ** t )  ni = self . _constants . get ( <str> , [ ] ) ai = self . _constants . get ( <str> , [ ] ) bi = self . _constants . get ( <str> , [ ] ) Ai = self . _constants . get ( <str> , [ ] ) Bi = self . _constants . get ( <str> , [ ] ) Ci = self . _constants . get ( <str> , [ ] ) Di = self . _constants . get ( <str> , [ ] ) b_ = self . _constants . get ( <str> , [ ] ) for n , a , b , A , B , C , D , bt in zip ( ni , ai , bi , Ai , Bi , Ci , Di , b_ ) :                  Tita = ( 1 - tau ) + A * ( ( delta - 1 ) ** 2 ) ** ( 0.5 / bt ) F = exp ( - C * ( delta - 1 ) ** 2 - D * ( tau - 1 ) ** 2 ) Fd = - 2 * C * F * ( delta - 1 ) Fdd = 2 * C * F * ( 2 * C * ( delta - 1 ) ** 2 - 1 ) Ft = - 2 * D * F * ( tau - 1 ) Ftt = 2 * D * F * ( 2 * D * ( tau - 1 ) ** 2 - 1 ) Fdt = 4 * C * D * F * ( delta - 1 ) * ( tau - 1 ) Fdtt = 4 * C * D * F * ( delta - 1 ) * ( 2 * D * ( tau - 1 ) ** 2 - 1 ) Delta = Tita ** 2 + B * ( ( delta - 1 ) ** 2 ) ** a Deltad = ( delta - 1 ) * ( A * Tita * 2 / bt * ( ( delta - 1 ) ** 2 ) ** ( 0.5 / bt - 1 ) + 2 * B * a * ( ( delta - 1 ) ** 2 ) ** ( a - 1 ) ) if delta == 1 :                      Deltadd = 0  else :                      Deltadd = Deltad / ( delta - 1 ) + ( delta - 1 ) ** 2 * ( 4 * B * a * ( a - 1 ) * ( ( delta - 1 ) ** 2 ) ** ( a - 2 ) + 2 * A ** 2 / bt ** 2 * ( ( ( delta - 1 ) ** 2 ) ** ( 0.5 / bt - 1 ) ) ** 2 + A * Tita * 4 / bt * ( 0.5 / bt - 1 ) * ( ( delta - 1 ) ** 2 ) ** ( 0.5 / bt - 2 ) )  DeltaBd = b * Delta ** ( b - 1 ) * Deltad DeltaBdd = b * ( Delta ** ( b - 1 ) * Deltadd + ( b - 1 ) * Delta ** ( b - 2 ) * Deltad ** 2 ) DeltaBt = - 2 * Tita * b * Delta ** ( b - 1 ) DeltaBtt = 2 * b * Delta ** ( b - 1 ) + 4 * Tita ** 2 * b * ( b - 1 ) * Delta ** ( b - 2 ) DeltaBdt = - A * b * 2 / bt * Delta ** ( b - 1 ) * ( delta - 1 ) * ( ( delta - 1 ) ** 2 ) ** ( 0.5 / bt - 1 ) - 2 * Tita * b * ( b - 1 ) * Delta ** ( b - 2 ) * Deltad DeltaBdtt = 2 * b * ( b - 1 ) * Delta ** ( b - 2 ) * ( Deltad * ( 1 + 2 * Tita ** 2 * ( b - 2 ) / Delta ) + 4 * Tita * A * ( delta - 1 ) / bt * ( ( delta - 1 ) ** 2 ) ** ( 0.5 / bt - 1 ) ) fir += n * Delta ** b * delta * F fird += n * ( Delta ** b * ( F + delta * Fd ) + DeltaBd * delta * F ) firdd += n * ( Delta ** b * ( 2 * Fd + delta * Fdd ) + 2 * DeltaBd * ( F + delta * Fd ) + DeltaBdd * delta * F ) firt += n * delta * ( DeltaBt * F + Delta ** b * Ft ) firtt += n * delta * ( DeltaBtt * F + 2 * DeltaBt * Ft + Delta ** b * Ftt ) firdt += n * ( Delta ** b * ( Ft + delta * Fdt ) + delta * DeltaBd * Ft + DeltaBt * ( F + delta * Fd ) + DeltaBdt * delta * F ) firdtt += n * ( ( DeltaBtt * F + 2 * DeltaBt * Ft + Delta ** b * Ftt ) + delta * ( DeltaBdtt * F + DeltaBtt * Fd + 2 * DeltaBdt * Ft + 2 * DeltaBt * Fdt + DeltaBt * Ftt + Delta ** b * Fdtt ) ) Tita_ = ( 1 - tau ) + A * ( ( delta_0 - 1 ) ** 2 ) ** ( 0.5 / bt ) Delta_ = Tita_ ** 2 + B * ( ( delta_0 - 1 ) ** 2 ) ** a Deltad_ = ( delta_0 - 1 ) * ( A * Tita_ * 2 / bt * ( ( delta_0 - 1 ) ** 2 ) ** ( 0.5 / bt - 1 ) + 2 * B * a * ( ( delta_0 - 1 ) ** 2 ) ** ( a - 1 ) ) Deltadd_ = Deltad_ / ( delta_0 - 1 ) + ( delta_0 - 1 ) ** 2 * ( 4 * B * a * ( a - 1 ) * ( ( delta_0 - 1 ) ** 2 ) ** ( a - 2 ) + 2 * A ** 2 / bt ** 2 * ( ( ( delta_0 - 1 ) ** 2 ) ** ( 0.5 / bt - 1 ) ) ** 2 + A * Tita_ * 4 / bt * ( 0.5 / bt - 1 ) * ( ( delta_0 - 1 ) ** 2 ) ** ( 0.5 / bt - 2 ) ) DeltaBd_ = b * Delta_ ** ( b - 1 ) * Deltad_ DeltaBdd_ = b * ( Delta_ ** ( b - 1 ) * Deltadd_ + ( b - 1 ) * Delta_ ** ( b - 2 ) * Deltad_ ** 2 ) F_ = exp ( - C * ( delta_0 - 1 ) ** 2 - D * ( tau - 1 ) ** 2 ) Fd_ = - 2 * C * F_ * ( delta_0 - 1 ) Fdd_ = 2 * C * F_ * ( 2 * C * ( delta_0 - 1 ) ** 2 - 1 ) B += n * ( Delta_ ** b * ( F_ + delta_0 * Fd_ ) + DeltaBd_ * delta_0 * F_ ) C += n * ( Delta_ ** b * ( 2 * Fd_ + delta_0 * Fdd_ ) + 2 * DeltaBd_ * ( F_ + delta * Fd_ ) + DeltaBdd_ * delta_0 * F_ )  if <str> in self . _constants :                  if delta < 0.2 :                      factor = 1.6 * delta ** 6 * ( 1 - 1.2 * delta ** 6 )  else :                      factor = exp ( - 0.4 * delta ** 6 ) - exp ( - 2 * delta ** 6 )  nr5 = self . _constants . get ( <str> , [ ] ) d5 = self . _constants . get ( <str> , [ ] ) t5 = self . _constants . get ( <str> , [ ] ) fr , frt , frtt , frdtt1 , frdtt2 = 0 , 0 , 0 , 0 , 0 frd1 , frd2 = 0 , 0 frdd1 , frdd2 , frdd3 = 0 , 0 , 0 frdt1 , frdt2 = 0 , 0 Bsum1 , Bsum2 , Csum1 , Csum2 , Csum3 = 0 , 0 , 0 , 0 , 0 for n , d , t in zip ( nr5 , d5 , t5 ) :                      fr += n * delta ** d * tau ** t frd1 += n * delta ** ( d + 5 ) * tau ** t frd2 += n * d * delta ** ( d - 1 ) * tau ** t frdd1 += n * delta ** ( d + 10 ) * tau ** t frdd2 += n * ( 2 * d + 5 ) * delta ** ( d + 4 ) * tau ** t frdd3 += n * d * ( d - 1 ) * delta ** ( d - 2 ) * tau ** t frt += n * delta ** d * t * tau ** ( t - 1 ) frtt += n * delta ** d * t * ( t - 1 ) * tau ** ( t - 2 ) frdt1 += n * delta ** ( d + 5 ) * t * tau ** ( t - 1 ) frdt2 += n * d * delta ** ( d - 1 ) * t * tau ** ( t - 1 ) frdtt1 += n * delta ** ( d + 5 ) * t * ( t - 1 ) * tau ** ( t - 2 ) frdtt2 += n * d * delta ** ( d - 1 ) * t * ( t - 1 ) * tau ** ( t - 2 ) Bsum1 += n * delta_0 ** ( d + 5 ) * tau ** t Bsum2 += n * d * delta_0 ** ( d - 1 ) * tau ** t Csum1 += n * delta_0 ** ( d + 10 ) * tau ** t Csum2 += n * ( 2 * d + 5 ) * delta_0 ** ( d + 4 ) * tau ** t Csum3 += n * d * ( d - 1 ) * delta_0 ** ( d - 2 ) * tau ** t  fir += factor * fr fird += ( - 2.4 * exp ( - 0.4 * delta ** 6 ) + 12 * exp ( - 2 * delta ** 6 ) ) * frd1 + factor * frd2 firdd += ( 5.76 * exp ( - 0.4 * delta ** 6 ) - 144 * exp ( - 2 * delta ** 6 ) ) * frdd1 + ( - 2.4 * exp ( - 0.4 * delta ** 6 ) + 12 * exp ( - 2 * delta ** 6 ) ) * frdd2 + factor * frdd3 firt += factor * frt firtt += factor * frtt firdt += ( - 2.4 * exp ( - 0.4 * delta ** 6 ) + 12 * exp ( - 2 * delta ** 6 ) ) * frdt1 + factor * frdt2 firdtt += ( - 2.4 * exp ( - 0.4 * delta ** 6 ) + 12 * exp ( - 2 * delta ** 6 ) ) * frdtt1 + factor * frdtt2 B += ( - 2.4 * exp ( - 0.4 * delta_0 ** 6 ) + 12 * exp ( - 2 * delta_0 ** 6 ) ) * Bsum1 + ( exp ( 0.4 * delta_0 ** 6 ) - exp ( - 2 * delta_0 ** 6 ) ) * Bsum2 C += ( 5.76 * exp ( - 0.4 * delta_0 ** 6 ) - 144 * exp ( - 2 * delta_0 ** 6 ) ) * Csum1 + ( - 2.4 * exp ( - 0.4 * delta_0 ** 6 ) + 12 * exp ( - 2 * delta_0 ** 6 ) ) * Csum2 + ( exp ( 0.4 * delta_0 ** 6 ) - exp ( - 2 * delta_0 ** 6 ) ) * Csum3   prop = { } prop [ <str> ] = fir prop [ <str> ] = firt prop [ <str> ] = firtt prop [ <str> ] = fird prop [ <str> ] = firdd prop [ <str> ] = firdt prop [ <str> ] = firddd prop [ <str> ] = firddt prop [ <str> ] = firdtt prop [ <str> ] = firttt prop [ <str> ] = B prop [ <str> ] = C prop [ <str> ] = D return prop  @ refDoc ( __doi__ , [ 11 ] , tab = 8 ) def _MBWR ( self , rho , T ) :          <str> rhom = rho / self . M if <str> in self . _constants :              rhocm = 1 / ( - self . _constants [ <str> ] ) ** 0.5 rhoc = rhocm * self . M  else :              rhoc = self . rhoc rhocm = rhoc / self . M  delta = rho / rhoc b = self . _constants [ <str> ] R = self . _constants [ <str> ] a = [ None ] a . append ( R / 100 * T ) a . append ( b [ 1 ] * T + b [ 2 ] * T ** 0.5 + b [ 3 ] + b [ 4 ] / T + b [ 5 ] / T ** 2 ) a . append ( b [ 6 ] * T + b [ 7 ] + b [ 8 ] / T + b [ 9 ] / T ** 2 ) a . append ( b [ 10 ] * T + b [ 11 ] + b [ 12 ] / T ) a . append ( b [ 13 ] ) a . append ( b [ 14 ] / T + b [ 15 ] / T ** 2 ) a . append ( b [ 16 ] / T ) a . append ( b [ 17 ] / T + b [ 18 ] / T ** 2 ) a . append ( b [ 19 ] / T ** 2 ) a . append ( b [ 20 ] / T ** 2 + b [ 21 ] / T ** 3 ) a . append ( b [ 22 ] / T ** 2 + b [ 23 ] / T ** 4 ) a . append ( b [ 24 ] / T ** 2 + b [ 25 ] / T ** 3 ) a . append ( b [ 26 ] / T ** 2 + b [ 27 ] / T ** 4 ) a . append ( b [ 28 ] / T ** 2 + b [ 29 ] / T ** 3 ) a . append ( b [ 30 ] / T ** 2 + b [ 31 ] / T ** 3 + b [ 32 ] / T ** 4 ) P = sum ( [ a [ n ] * rhom ** n for n in range ( 1 , 10 ) ] ) P += exp ( - ( delta ** 2 ) ) * sum ( [ a [ n ] * rhom ** ( 2 * n - 17 ) for n in range ( 10 , 16 ) ] ) P *= 100 A = 0 for n in range ( 2 , 10 ) :              A += a [ n ] / ( n - 1 ) * rhom ** ( n - 1 )  A -= 0.5 * a [ 10 ] * rhocm ** 2 * ( exp ( - delta ** 2 ) - 1 ) A -= 0.5 * a [ 11 ] * rhocm ** 4 * ( exp ( - delta ** 2 ) * ( delta ** 2 + 1 ) - 1 ) A -= 0.5 * a [ 12 ] * rhocm ** 6 * ( exp ( - delta ** 2 ) * ( delta ** 4 + 2 * delta ** 2 + 2 ) - 2 ) A -= 0.5 * a [ 13 ] * rhocm ** 8 * ( exp ( - delta ** 2 ) * ( delta ** 6 + 3 * delta ** 4 + 6 * delta ** 2 + 6 ) - 6 ) A -= 0.5 * a [ 14 ] * rhocm ** 10 * ( exp ( - delta ** 2 ) * ( delta ** 8 + 4 * delta ** 6 + 12 * delta ** 4 + 24 * delta ** 2 + 24 ) - 24 ) A -= 0.5 * a [ 15 ] * rhocm ** 12 * ( exp ( - delta ** 2 ) * ( delta ** 10 + 5 * delta ** 8 + 20 * delta ** 6 + 60 * delta ** 4 + 120 * delta ** 2 + 120 ) - 120 ) A = A * 100 adT = [ None , R / 100 ] adT . append ( b [ 1 ] + b [ 2 ] / 2 / T ** 0.5 - b [ 4 ] / T ** 2 - 2 * b [ 5 ] / T ** 3 ) adT . append ( b [ 6 ] - b [ 8 ] / T ** 2 - 2 * b [ 9 ] / T ** 3 ) adT . append ( b [ 10 ] - b [ 12 ] / T ** 2 ) adT . append ( 0 ) adT . append ( - b [ 14 ] / T ** 2 - 2 * b [ 15 ] / T ** 3 ) adT . append ( - b [ 16 ] / T ** 2 ) adT . append ( - b [ 17 ] / T ** 2 - 2 * b [ 18 ] / T ** 3 ) adT . append ( - 2 * b [ 19 ] / T ** 3 ) adT . append ( - 2 * b [ 20 ] / T ** 3 - 3 * b [ 21 ] / T ** 4 ) adT . append ( - 2 * b [ 22 ] / T ** 3 - 4 * b [ 23 ] / T ** 5 ) adT . append ( - 2 * b [ 24 ] / T ** 3 - 3 * b [ 25 ] / T ** 4 ) adT . append ( - 2 * b [ 26 ] / T ** 3 - 4 * b [ 27 ] / T ** 5 ) adT . append ( - 2 * b [ 28 ] / T ** 3 - 3 * b [ 29 ] / T ** 4 ) adT . append ( - 2 * b [ 30 ] / T ** 3 - 3 * b [ 31 ] / T ** 4 - 4 * b [ 32 ] / T ** 5 ) dAT = 0 for n in range ( 2 , 10 ) :              dAT += adT [ n ] / ( n - 1 ) * rhom ** ( n - 1 )  dAT -= 0.5 * adT [ 10 ] * rhocm ** 2 * ( exp ( - delta ** 2 ) - 1 ) dAT -= 0.5 * adT [ 11 ] * rhocm ** 4 * ( exp ( - delta ** 2 ) * ( delta ** 2 + 1 ) - 1 ) dAT -= 0.5 * adT [ 12 ] * rhocm ** 6 * ( exp ( - delta ** 2 ) * ( delta ** 4 + 2 * delta ** 2 + 2 ) - 2 ) dAT -= 0.5 * adT [ 13 ] * rhocm ** 8 * ( exp ( - delta ** 2 ) * ( delta ** 6 + 3 * delta ** 4 + 6 * delta ** 2 + 6 ) - 6 ) dAT -= 0.5 * adT [ 14 ] * rhocm ** 10 * ( exp ( - delta ** 2 ) * ( delta ** 8 + 4 * delta ** 6 + 12 * delta ** 4 + 24 * delta ** 2 + 24 ) - 24 ) dAT -= 0.5 * adT [ 15 ] * rhocm ** 12 * ( exp ( - delta ** 2 ) * ( delta ** 10 + 5 * delta ** 8 + 20 * delta ** 6 + 60 * delta ** 4 + 120 * delta ** 2 + 120 ) - 120 ) dAT = dAT * 100 adTT = [ None , 0 ] adTT . append ( - b [ 2 ] / 4 / T ** 1.5 + 2 * b [ 4 ] / T ** 3 + 6 * b [ 5 ] / T ** 4 ) adTT . append ( 2 * b [ 8 ] / T ** 3 + 6 * b [ 9 ] / T ** 4 ) adTT . append ( 2 * b [ 12 ] / T ** 3 ) adTT . append ( 0 ) adTT . append ( 2 * b [ 14 ] / T ** 3 + 6 * b [ 15 ] / T ** 4 ) adTT . append ( 2 * b [ 16 ] / T ** 3 ) adTT . append ( 2 * b [ 17 ] / T ** 3 + 6 * b [ 18 ] / T ** 4 ) adTT . append ( 6 * b [ 19 ] / T ** 4 ) adTT . append ( 6 * b [ 20 ] / T ** 4 + 12 * b [ 21 ] / T ** 5 ) adTT . append ( 6 * b [ 22 ] / T ** 4 + 20 * b [ 23 ] / T ** 6 ) adTT . append ( 6 * b [ 24 ] / T ** 4 + 12 * b [ 25 ] / T ** 5 ) adTT . append ( 6 * b [ 26 ] / T ** 4 + 20 * b [ 27 ] / T ** 6 ) adTT . append ( 6 * b [ 28 ] / T ** 4 + 12 * b [ 29 ] / T ** 5 ) adTT . append ( 6 * b [ 30 ] / T ** 4 + 12 * b [ 31 ] / T ** 5 + 20 * b [ 32 ] / T ** 6 ) d2AT = 0 for n in range ( 2 , 10 ) :              d2AT += adTT [ n ] * rhom ** ( n - 1 ) / ( n - 1 )  d2AT -= 0.5 * adTT [ 10 ] * rhocm ** 2 * ( exp ( - delta ** 2 ) - 1 ) d2AT -= 0.5 * adTT [ 11 ] * rhocm ** 4 * ( exp ( - delta ** 2 ) * ( delta ** 2 + 1 ) - 1 ) d2AT -= 0.5 * adTT [ 12 ] * rhocm ** 6 * ( exp ( - delta ** 2 ) * ( delta ** 4 + 2 * delta ** 2 + 2 ) - 2 ) d2AT -= 0.5 * adTT [ 13 ] * rhocm ** 8 * ( exp ( - delta ** 2 ) * ( delta ** 6 + 3 * delta ** 4 + 6 * delta ** 2 + 6 ) - 6 ) d2AT -= 0.5 * adTT [ 14 ] * rhocm ** 10 * ( exp ( - delta ** 2 ) * ( delta ** 8 + 4 * delta ** 6 + 12 * delta ** 4 + 24 * delta ** 2 + 24 ) - 24 ) d2AT -= 0.5 * adTT [ 15 ] * rhocm ** 12 * ( exp ( - delta ** 2 ) * ( delta ** 10 + 5 * delta ** 8 + 20 * delta ** 6 + 60 * delta ** 4 + 120 * delta ** 2 + 120 ) - 120 ) d2AT = d2AT * 100 dPdrho = sum ( [ a [ n ] * n * rhom ** ( n - 1 ) for n in range ( 1 , 10 ) ] ) dPdrho += exp ( - delta ** 2 ) * sum ( [ ( 2 * n - 17 - 2 * delta ** 2 ) * a [ n ] * rhom ** ( 2 * n - 18 ) for n in range ( 10 , 16 ) ] ) dPdrho = dPdrho * 100 d2Prho = sum ( [ a [ n ] * n * ( n - 1 ) * rhom ** ( n - 2 ) for n in range ( 1 , 10 ) ] ) d2Prho += exp ( - delta ** 2 ) * sum ( [ ( - 35 * n + 2 * n ** 2 + 153 + 33 * delta ** 2 + 2 * delta ** 4 - 4 * n * delta ** 2 ) * 2 * a [ n ] * rhom ** ( 2 * n - 19 ) for n in range ( 10 , 16 ) ] ) d2Prho *= 100 dPdT = sum ( [ adT [ n ] * rhom ** n for n in range ( 1 , 10 ) ] ) dPdT += exp ( - delta ** 2 ) * sum ( [ adT [ n ] * rhom ** ( 2 * n - 17 ) for n in range ( 10 , 16 ) ] ) dPdT *= 100 tau = self . Tc / T prop = { } prop [ <str> ] = P * 1e3 prop [ <str> ] = A prop [ <str> ] = dAT prop [ <str> ] = d2AT prop [ <str> ] = dPdrho prop [ <str> ] = d2Prho prop [ <str> ] = dPdT prop [ <str> ] = A / R / T prop [ <str> ] = ( A / T - dAT ) / R / tau prop [ <str> ] = d2AT * T / R / tau ** 2 prop [ <str> ] = ( P / rhom / T / R - 1 ) / delta prop [ <str> ] = ( ( dPdrho - 2 * P / rhom ) / R / T + 1 ) / delta ** 2 prop [ <str> ] = ( P / T - dPdT ) / R / rhom / tau / delta prop [ <str> ] = ( d2Prho * rhom - 4 * dPdrho + 6 * P / rhom ) / R / T - 2 B , C , D = 0 , 0 , 0 firddt , firdtt , firttt = 0 , 0 , 0 prop [ <str> ] = firddt prop [ <str> ] = firdtt prop [ <str> ] = firttt prop [ <str> ] = B prop [ <str> ] = C prop [ <str> ] = D return prop  @ refDoc ( __doi__ , [ 12 , 13 , 14 ] , tab = 8 ) def _PengRobinson ( self , rho , T ) :          <str> Tc = self . Tc delta = rho / self . rhoc / self . M * 1000 tau = Tc / T kw = { } kw [ <str> ] = self . rhoc kw [ <str> ] = self . Tc kw [ <str> ] = 0.0778 * R * self . Tc / self . Pc kw [ <str> ] = 1 + 2 ** 0.5 kw [ <str> ] = 1 - 2 ** 0.5 a = 0.457235 * R ** 2 * self . Tc ** 2 / self . Pc m = 0.37464 + 1.54226 * self . f_acent - 0.26992 * self . f_acent ** 2 alfa = a * ( 1 + m * ( 1 - ( T / Tc ) ** 0.5 ) ) ** 2 B = 1 + m * ( 1 - 1 / tau ** 0.5 ) kw [ <str> ] = alfa kw [ <str> ] = a * m * B / tau ** 1.5 kw [ <str> ] = a * m / 2 * ( m * Tc / tau ** 3 / Tc - 3 * B / tau ** 2.5 ) kw [ <str> ] = 3 * a * m / 4 * ( - 3 * m * Tc / tau ** 4 / Tc + 5 * B / tau ** 3.5 ) prop = CubicHelmholtz ( tau , delta , ** kw ) return prop  @ refDoc ( __doi__ , [ 13 ] , tab = 8 ) def vtPR ( self ) :          if self . _PR :              b , g = self . _PR  else :              b = - 2.8431 * exp ( - 64.2184 * ( 0.3074 - self . Zc ) ) + 0.1735 g = - 99.2558 + 301.6201 * self . Zc  Tr = 1 / tau f = b + ( 1 - b ) * exp ( g * abs ( 1 - Tr ) ) cc = ( 0.3074 - self . Zc ) * self . R * self . Tc / self . Pc c = cc * f v = 1. / rho - c return v  def derivative ( self , z , x , y , fase ) :          dT = { <str> : self . P * fase . alfap , <str> : 1 , <str> : 0 , <str> : 0 , <str> : fase . cv , <str> : fase . cv + self . P * fase . v * fase . alfap , <str> : fase . cv / self . T , <str> : self . P * fase . v * fase . alfap - fase . s , <str> : - fase . s } dv = { <str> : - self . P * fase . betap , <str> : 0 , <str> : 1 , <str> : - 1 , <str> : self . P * ( self . T * fase . alfap - 1 ) , <str> : self . P * ( self . T * fase . alfap - fase . v * fase . betap ) , <str> : self . P * fase . alfap , <str> : - self . P * fase . v * fase . betap , <str> : - self . P } return ( dv [ z ] * dT [ y ] - dT [ z ] * dv [ y ] ) / ( dv [ x ] * dT [ y ] - dT [ x ] * dv [ y ] )  def _Vapor_Pressure ( self , T ) :          if self . _vapor_Pressure :              Pr = SimpleEq ( self . Tc , T , self . _vapor_Pressure ) Pv = unidades . Pressure ( Pr * self . Pc )  else :              Pv = Pv_Lee_Kesler ( T , self . Tc , self . Pc , self . f_acent )  return Pv  def _Liquid_Density ( self , T ) :          if T > self . Tc :              T = self . Tc  if self . _liquid_Density :              if T < self . Tt :                  T = self . Tt  if T > self . Tc :                  T = self . Tc  Pr = SimpleEq ( self . Tc , T , self . _liquid_Density ) rho = unidades . Density ( Pr * self . rhoc )  else :              rho = RhoL_Costald ( T , self . Tc , self . f_acent , 1 / self . rhoc )  return rho  def _Vapor_Density ( self , T ) :          if self . _vapor_Density :              if T < self . Tt :                  T = self . Tt  if T > self . Tc :                  T = self . Tc  Pr = SimpleEq ( self . Tc , T , self . _vapor_Density ) rho = unidades . Density ( Pr * self . rhoc )  else :              P = self . _Vapor_Pressure ( T ) rho = P * 1e-3 / T / R * self . M  return rho  @ refDoc ( __doi__ , [ 1 ] , tab = 8 ) def _Surface ( self , T ) :          <str> if self . Tt <= self . T <= self . Tc :              if self . _surface :                  tau = 1 - T / self . Tc tension = 0 for sigma , n in zip ( self . _surface [ <str> ] , self . _surface [ <str> ] ) :                      tension += sigma * tau ** n  sigma = unidades . Tension ( tension )  else :                  sigma = Tension_Pitzer ( T , self . Tc , self . Pc , self . f_acent )   else :              sigma = None  return sigma  @ refDoc ( __doi__ , [ 24 ] , tab = 8 ) def _Dielectric ( self , rho , T ) :          <str> rhom = rho / self . M / 1000 if self . _dielectric :              if rho :                  ai = self . _dielectric [ <str> ] bi = self . _dielectric [ <str> ] ci = self . _dielectric [ <str> ] D = self . _dielectric [ <str> ] Au = self . _dielectric [ <str> ] T0 = self . _dielectric . get ( <str> , 273.16 ) Ae = ai [ 0 ] + ai [ 1 ] * ( T / T0 - 1 ) Be = bi [ 0 ] + bi [ 1 ] * ( T0 / T - 1 ) C = ci [ 0 ] + ci [ 1 ] * ( T0 / T - 1 ) P = rhom * ( Ae + Au / T + Be * rhom + C * rhom ** D ) if self . _dielectric [ <str> ] == 1 :                      e = ( 1 + 2 * P ) / ( 1 - P )  elif self . _dielectric [ <str> ] == 2 :                      e = 0.25 * ( 1 + 9 * P + 3 * ( 9 * P ** 2 + 2 * P + 1 ) ** 0.5 )   else :                  e = 1   else :              e = None  return unidades . Dimensionless ( e )  @ classmethod def _Melting_Pressure ( cls , T ) :          <str> if cls . _melting :              Tref = cls . _melting [ <str> ] Pref = cls . _melting [ <str> ] Tita = T / Tref suma = 0 if <str> in cls . _melting :                  suma += cls . _melting [ <str> ]  if <str> in cls . _melting :                  for a , t in zip ( cls . _melting [ <str> ] , cls . _melting [ <str> ] ) :                      suma += a * Tita ** t   if <str> in cls . _melting :                  for a , t in zip ( cls . _melting [ <str> ] , cls . _melting [ <str> ] ) :                      suma += a * ( Tita ** t - 1 )   if <str> in cls . _melting :                  for a , t in zip ( cls . _melting [ <str> ] , cls . _melting [ <str> ] ) :                      suma += a * log ( Tita ) ** t   if <str> in cls . _melting :                  for a , t in zip ( cls . _melting [ <str> ] , cls . _melting [ <str> ] ) :                      suma += a * ( Tita - 1 ) ** t   if cls . _melting [ <str> ] == 1 :                  P = suma * Pref  elif cls . _melting [ <str> ] == 2 :                  P = suma + Pref  elif cls . _melting [ <str> ] == 2 :                  P = exp ( suma ) * Pref  return unidades . Pressure ( P )  else :              return None   @ classmethod def _Sublimation_Pressure ( cls , T ) :          <str> if cls . _sublimation :              coef = cls . _sublimation Tref = coef [ <str> ] Pref = coef [ <str> ] Tita = T / Tref suma = 0 if <str> in cls . _melting :                  suma += cls . _melting [ <str> ]  if <str> in coef :                  for a , t in zip ( coef [ <str> ] , coef [ <str> ] ) :                      suma += a * Tita ** t   if <str> in coef :                  for a , t in zip ( coef [ <str> ] , coef [ <str> ] ) :                      suma += a * ( 1 - Tita ) ** t   if <str> in coef :                  for a , t in zip ( coef [ <str> ] , coef [ <str> ] ) :                      suma += a * log ( Tita ) ** t   if cls . _sublimation [ <str> ] == 1 :                  P = suma * Pref  elif cls . _sublimation [ <str> ] == 2 :                  P = exp ( suma ) * Pref  elif cls . _sublimation [ <str> ] == 3 :                  P = exp ( Tref / T * suma ) * Pref  return unidades . Pressure ( P )  else :              return None   @ refDoc ( __doi__ , [ 2 , 3 , 4 , 5 , 20 , 22 ] , tab = 8 ) def _Viscosity ( self , rho , T , fase , coef = False , residual = False ) :          <str> if coef is False :              coef = self . _viscosity  if coef :              M = coef . get ( <str> , self . M ) if coef [ <str> ] == 0 :                  method = self . __getattribute__ ( coef [ <str> ] ) mu = method ( rho , T , fase ) . muPas  elif coef [ <str> ] == 1 :                  muo = self . _Visco0 ( T ) mud = 0 if rho and <str> in coef :                      Tc = coef . get ( <str> , self . Tc ) if <str> in coef :                          mur = coef [ <str> ]  else :                          mur = Avogadro * ( coef [ <str> ] * 1e-9 ) ** 3  tau = T / Tc B_ = 0 for n , t in zip ( coef [ <str> ] , coef [ <str> ] ) :                          B_ += n * tau ** t  mud = mur * B_ * 1e3 * rho / M * muo  Tr = coef . get ( <str> , self . Tc ) tau = Tr / T rhor = coef . get ( <str> , self . rhoc ) delta = rho / rhor mured = coef . get ( <str> , 1 ) mur = 0 if rho and <str> in coef :                      if <str> in coef :                          for n , t , d , c , g in zip ( coef [ <str> ] , coef [ <str> ] , coef [ <str> ] , coef [ <str> ] , coef [ <str> ] ) :                              mur += n * tau ** t * delta ** d * exp ( - g * delta ** c )   else :                          for n , t , d in zip ( coef [ <str> ] , coef [ <str> ] , coef [ <str> ] ) :                              mur += n * tau ** t * delta ** d    if rho and <str> in coef :                      num = 0 den = 0 if <str> in coef :                          for n , t , d , c , g in zip ( coef [ <str> ] , coef [ <str> ] , coef [ <str> ] , coef [ <str> ] , coef [ <str> ] ) :                              num += n * tau ** t * delta ** d * exp ( - g * delta ** c )   else :                          for n , t , d in zip ( coef [ <str> ] , coef [ <str> ] , coef [ <str> ] ) :                              num += n * tau ** t * delta ** d   if <str> in coef :                          if <str> in coef :                              for n , t , d , c , g in zip ( coef [ <str> ] , coef [ <str> ] , coef [ <str> ] , coef [ <str> ] , coef [ <str> ] ) :                                  den += n * tau ** t * delta ** d * exp ( - g * delta ** c )   else :                              for n , t , d in zip ( coef [ <str> ] , coef [ <str> ] , coef [ <str> ] ) :                                  den += n * tau ** t * delta ** d    else :                          den = 1.  mur += num / den  if rho and <str> in coef :                      for n , b , e in zip ( coef [ <str> ] , coef [ <str> ] , coef [ <str> ] ) :                          mur += n * tau * delta * exp ( - b * ( delta - 1 ) ** 2 - e * abs ( tau - 1 ) )   mur *= mured muCP = 0 if <str> in coef :                      f = coef [ <str> ] g1 = coef [ <str> ] gi = coef [ <str> ] ti = coef [ <str> ] rest = 0 for g , t in zip ( gi , ti ) :                          rest += g * tau ** t  delta0 = g1 * ( 1 + rest ) muCP = f * ( delta / ( delta0 - delta ) - delta / delta0 )  mue = 0 if <str> in coef :                      method = self . __getattribute__ ( coef [ <str> ] ) mue = method ( rho , T , fase )  if residual :                      return mud + mur + muCP + mue  mu = muo + mud + mur + muCP + mue  elif coef [ <str> ] == 2 :                  f = coef [ <str> ] e = coef [ <str> ] mod = coef . get ( <str> , False ) rhoc = coef [ <str> ] if mod :                      rhogcc = rho / 1000 rhoc *= self . M / 1000  else :                      rhogcc = rho / self . M  muo = self . _Visco0 ( T ) mu1 = f [ 0 ] + f [ 1 ] * ( f [ 2 ] - log ( T / f [ 3 ] ) ) ** 2 G = e [ 0 ] + e [ 1 ] / T H = rhogcc ** 0.5 * ( rhogcc - rhoc ) / rhoc if mod :                      F = e [ 0 ] + e [ 1 ] * H + e [ 2 ] * rhogcc ** 0.1 + e [ 3 ] * H / T ** 2 + e [ 4 ] * rhogcc ** 0.1 / T ** 1.5 + e [ 5 ] / T + e [ 6 ] * H / T  else :                      F = G + ( e [ 2 ] + e [ 3 ] / T ** 1.5 ) * rhogcc ** 0.1 + H * ( e [ 4 ] + e [ 5 ] / T + e [ 6 ] / T ** 2 )  mu2 = exp ( F ) - exp ( G ) mu = muo + mu1 * rhogcc + mu2  elif coef [ <str> ] == 3 or coef [ <str> ] == <str> :                  tau = self . Tc / T delta = rho / self . rhoc ref = coef [ <str> ] visco0 = ref . __getattribute__ ( ref , coef [ <str> ] ) def f ( parr ) :                      T0 , rho0 = parr tau0 = ref . Tc / T0 delta0 = rho0 / ref . rhoc ar = self . _phir ( tau , delta ) ar0 = ref ( ) . _phir ( tau0 , delta0 ) fird = self . _phird ( tau , delta ) fird0 = ref ( ) . _phird ( tau0 , delta0 ) Z = 1 + delta * fird Z0 = 1 + delta0 * fird0 return ar - ar0 , Z - Z0  rinput = fsolve ( f , [ T , rho ] , full_output = True ) if sum ( abs ( rinput [ 1 ] [ <str> ] ) ) < 1e-5 :                      T0 , rho0 = rinput [ 0 ] f = T / T0 h = rho0 / ref . M / rho * self . M  else :                      self . _ecs_msg = <str> prop = self . _ECSEstela ( delta , tau , ref ) teta = prop [ <str> ] phi = prop [ <str> ] f = self . Tc / ref . Tc * teta T0 = T / f h = ref . rhoc / ref . M * self . M / self . rhoc * phi rho0 = rho / self . M * h * ref . M  self . _T0_ecs = T0 self . _rho0_ecs = rho0 visco = { } visco [ <str> ] = 5 visco [ <str> ] = coef [ <str> ] visco [ <str> ] = coef [ <str> ] muo = self . _Visco0 ( T , visco ) psi = 0 for n , d in zip ( coef [ <str> ] , coef [ <str> ] ) :                      psi += n * delta ** d  rho0 *= psi F = f ** 0.5 / h ** ( 2 / 3 ) * ( self . M / ref . M ) ** 0.5 mur = ref ( ) . _Viscosity ( rho0 , T0 , fase , visco0 , True ) mu = muo + mur * F  elif coef [ <str> ] == 4 :                  muo = self . _Visco0 ( T ) Gamma = self . Tc / T psi1 = exp ( Gamma ) - 1.0 psi2 = exp ( Gamma ** 2 ) - 1.0 a = coef [ <str> ] b = coef [ <str> ] c = coef [ <str> ] A = coef [ <str> ] B = coef [ <str> ] C = coef [ <str> ] ka = ( a [ 0 ] + a [ 1 ] * psi1 + a [ 2 ] * psi2 ) * Gamma kaa = ( A [ 0 ] + A [ 1 ] * psi1 + A [ 2 ] * psi2 ) * Gamma ** 3 kr = ( b [ 0 ] + b [ 1 ] * psi1 + b [ 2 ] * psi2 ) * Gamma krr = ( B [ 0 ] + B [ 1 ] * psi1 + B [ 2 ] * psi2 ) * Gamma ** 3 ki = ( c [ 0 ] + c [ 1 ] * psi1 + c [ 2 ] * psi2 ) * Gamma kii = ( C [ 0 ] + C [ 1 ] * psi1 + C [ 2 ] * psi2 ) * Gamma ** 3 Patt = - fase . IntP . bar Prep = T * fase . dpdT_rho . barK Pid = rho * self . R * self . T / 1e5 delPr = Prep - Pid mur = ki * Pid + kr * delPr + ka * Patt + kii * Pid ** 2 + krr * delPr ** 2 + kaa * Patt ** 2 if <str> in coef :                      D = coef [ <str> ] E = coef [ <str> ] krrr = ( D [ 0 ] + D [ 1 ] * psi1 + D [ 2 ] * psi2 ) * Gamma kaaa = ( E [ 0 ] + E [ 1 ] * psi1 + E [ 2 ] * psi2 ) * Gamma mur += krrr * Prep ** 3 + kaaa * Patt ** 3  mu = ( muo + mur * 1e3 )   else :              muo = MuG_Chung ( T , self . Tc , 1 / self . rhoc , self . M , self . f_acent , self . momentoDipolar . Debye , 0 ) mu = MuG_P_Chung ( T , self . Tc , 1 / self . rhoc , self . M , self . f_acent , self . momentoDipolar . Debye , 0 , rho , muo ) . muPas  return unidades . Viscosity ( mu , <str> )  def _Visco0 ( self , T , coef = None ) :          <str> if coef is None :              coef = self . _viscosity  if not coef :              muo = MuG_Chung ( T , self . Tc , 1 / self . rhoc , self . M , self . f_acent , self . momentoDipolar . Debye , 0 ) return muo  muo = 0 M = coef . get ( <str> , self . M ) if coef [ <str> ] :              omega = self . _Omega ( T , coef ) N_chap = coef . get ( <str> , 0.0266958 ) t_chap = coef . get ( <str> , 0.5 ) Tr = coef . get ( <str> , 1. ) muo += N_chap * ( M * T / Tr ) ** t_chap / ( coef [ <str> ] ** 2 * omega )  tau = T / coef . get ( <str> , 1. ) if <str> in coef :              for n , t in zip ( coef [ <str> ] , coef [ <str> ] ) :                  muo += n * tau ** t   if <str> in coef :              num = 0 den = 0 for n , t in zip ( coef [ <str> ] , coef [ <str> ] ) :                  num += n * tau ** t  if <str> in coef :                  for n , t , in zip ( coef [ <str> ] , coef [ <str> ] ) :                      den += n * tau ** t   else :                  den = 1  muo += num / den  if <str> in coef :              method = self . __getattribute__ ( coef [ <str> ] ) muo += method ( T )  return muo  @ refDoc ( __doi__ , [ 6 , 5 , 7 , 3 , 8 ] , tab = 8 ) def _Omega ( self , T , coef ) :          <str> b = coef . get ( <str> , None ) if coef [ <str> ] == 1 :              if not b :                  b = [ 0.431 , - 0.4623 , 0.08406 , 0.005341 , - 0.00331 ]  T_ = log ( T / coef [ <str> ] ) suma = 0 for i , bi in enumerate ( b ) :                  suma += bi * T_ ** i  omega = exp ( suma )  elif coef [ <str> ] == 2 :              if not b :                  b = [ - 3.0328138281 , 16.918880086 , - 37.189364917 , 41.288861858 , - 24.615921140 , 8.9488430959 , - 1.8739245042 , 0.20966101390 , - 0.0096570437074 ]  T_ = coef [ <str> ] / T suma = 0 for i , bi in enumerate ( b ) :                  suma += bi * T_ ** ( ( 3. - i ) / 3. )  omega = 1. / suma  elif coef [ <str> ] == 3 :              Tr = T / coef . get ( <str> , 1 ) suma = 0 for i , bi in enumerate ( b ) :                  suma += bi / Tr ** i  omega = exp ( suma )  elif coef [ <str> ] == 4 :              Tr = T / coef . get ( <str> , 1 ) omega = 0 for i , bi in enumerate ( b ) :                  omega += bi / Tr ** i   elif coef [ <str> ] == 5 :              T_ = T / coef [ <str> ] omega = Collision_Neufeld ( T_ )  return omega  @ refDoc ( __doi__ , [ 6 , 4 , 5 , 17 , 18 , 20 , 22 ] , tab = 8 ) def _ThCond ( self , rho , T , fase , coef = False , contribution = False ) :          <str> if coef is False :              coef = self . _thermal  if coef :              if <str> in coef :                  visco = coef [ <str> ]  else :                  visco = None  if coef [ <str> ] == 0 :                  method = self . __getattribute__ ( coef [ <str> ] ) k = method ( rho , T , fase )  elif coef [ <str> ] == 1 :                  Tr = T / coef . get ( <str> , 1 ) kg = 0 if <str> in coef :                      muo = self . _Visco0 ( T , visco ) kg += coef [ <str> ] * muo  if <str> in coef :                      f = 0 for n , t in zip ( coef [ <str> ] , coef [ <str> ] ) :                          f += n * Tr ** t  muo = self . _Visco0 ( T , visco ) n = 1e-6 * self . R / u / Avogadro kg += muo * n * ( 3.75 + f * ( self . cp0 / self . R - 2.5 ) )  if <str> in coef :                      for n , t in zip ( coef [ <str> ] , coef [ <str> ] ) :                          kg += n * Tr ** t   if <str> in coef :                      num = 0 for n , t in zip ( coef [ <str> ] , coef [ <str> ] ) :                          num += n * Tr ** t  den = 0 for n , t in zip ( coef [ <str> ] , coef [ <str> ] ) :                          den += n * Tr ** t  kg += num / den  kg *= coef . get ( <str> , 1 ) kr = 0 kc = 0 if rho > 0 :                      Tr = coef . get ( <str> , self . Tc ) tau = Tr / T rhor = coef . get ( <str> , self . rhoc ) delta = rho / rhor if <str> in coef :                          if <str> in coef :                              for n , t , d , c , g in zip ( coef [ <str> ] , coef [ <str> ] , coef [ <str> ] , coef [ <str> ] , coef [ <str> ] ) :                                  kr += n * tau ** t * delta ** d * exp ( - g * delta ** c )   else :                              for n , t , d , in zip ( coef [ <str> ] , coef [ <str> ] , coef [ <str> ] ) :                                  kr += n * tau ** t * delta ** d    if <str> in coef :                          num = 0 den = 0 if <str> in coef :                              for n , t , d , c , g in zip ( coef [ <str> ] , coef [ <str> ] , coef [ <str> ] , coef [ <str> ] , coef [ <str> ] ) :                                  num += n * tau ** t * delta ** d * exp ( - g * delta ** c )   else :                              for n , t , d in zip ( coef [ <str> ] , coef [ <str> ] , coef [ <str> ] ) :                                  num += n * tau ** t * delta ** d   if <str> in coef :                              if <str> in coef :                                  for n , t , d , c , g in zip ( coef [ <str> ] , coef [ <str> ] , coef [ <str> ] , coef [ <str> ] , coef [ <str> ] ) :                                      den += n * tau ** t * delta ** d * exp ( - g * delta ** c )   else :                                  for n , t , d in zip ( coef [ <str> ] , coef [ <str> ] , coef [ <str> ] ) :                                      den += n * tau ** t * delta ** d    else :                              den = 1.  kr += num / den  if <str> in coef :                          if T < self . Tc and rho < rhor :                              delta_s = self . _Vapor_Density ( T ) / rhor  else :                              delta_s = 1  for n , t , d , in zip ( coef [ <str> ] , coef [ <str> ] , coef [ <str> ] ) :                              kr += n * tau ** t * delta ** d / delta_s   kr *= coef . get ( <str> , 1 ) kc = self . _KCritical ( rho , T , fase )  ke = 0 if <str> in coef :                      method = self . __getattribute__ ( coef [ <str> ] ) ke = method ( rho , T , fase )  if contribution :                      return kr + ke  k = kg + kr + kc + ke  elif coef [ <str> ] == 2 :                  rhogcc = rho / 1000 f = coef [ <str> ] e = coef [ <str> ] ko = 0 for n , t in zip ( coef [ <str> ] , coef [ <str> ] ) :                      ko += n * T ** t  k1 = f [ 0 ] + f [ 1 ] * ( f [ 2 ] - log ( T / f [ 3 ] ) ) ** 2 G = e [ 0 ] + e [ 1 ] / T H = rhogcc ** 0.5 * ( rhogcc - e [ 7 ] ) / e [ 7 ] F = e [ 0 ] + e [ 1 ] * H + e [ 2 ] * rhogcc ** 0.1 + e [ 3 ] * H / T ** 2 + e [ 4 ] * rhogcc ** 0.1 / T ** 1.5 + e [ 5 ] / T + e [ 6 ] * H / T k2 = exp ( F ) - exp ( G ) kc = self . _KCritical ( rho , T , fase ) k = ko + k1 * rhogcc + k2 + kc  elif coef [ <str> ] == 3 :                  muo = self . _Visco0 ( T ) kg = 1e-6 * muo * ( 3.75 * self . R + ( self . cp0 - 2.5 * self . R ) * ( coef [ <str> ] [ 0 ] + coef [ <str> ] [ 1 ] * coef [ <str> ] / T ) ) if rho :                      E = coef [ <str> ] F0 = E [ 0 ] + E [ 1 ] / T + E [ 2 ] / T ** 2 F1 = E [ 3 ] + E [ 4 ] / T + E [ 5 ] / T ** 2 F2 = E [ 6 ] + E [ 7 ] / T rhom = rho / self . M kb = ( F0 + F1 * rhom ) * rhom / ( 1 + F2 * rhom ) kc = self . _KCritical ( rho , T , fase )  else :                      kb = 0 kc = 0  k = kg + kb + kc  elif coef [ <str> ] == 4 or coef [ <str> ] == <str> :                  Tr = T / self . Tc rhor = rho / self . rhoc tau = 1 / Tr delta = rhor muo = self . _Visco0 ( T ) ref = coef [ <str> ] thermo0 = ref . __getattribute__ ( ref , coef [ <str> ] ) if self . _T0_ecs :                      T0 = self . _T0_ecs rho0 = self . _rho0_ecs f = T / T0 h = rho0 / ref . M / rho * self . M  else :                      def f ( parr ) :                          T0 , rho0 = parr tau0 = ref . Tc / T0 delta0 = rho0 / ref . rhoc ar = self . _phir ( tau , delta ) ar0 = ref ( ) . _phir ( tau0 , delta0 ) fird = self . _phird ( tau , delta ) fird0 = ref ( ) . _phird ( tau0 , delta0 ) Z = 1 + delta * fird Z0 = 1 + delta0 * fird0 return ar - ar0 , Z - Z0  rinput = fsolve ( f , [ T , rho ] , full_output = True ) if sum ( abs ( rinput [ 1 ] [ <str> ] ) ) < 1e-5 :                          T0 , rho0 = rinput [ 0 ] f = T / T0 h = rho0 / ref . M / rho * self . M rho0 = rho / self . M * h * ref . M  else :                          self . _ecs_msg = <str> prop = self . _ECSEstela ( delta , tau , ref ) teta = prop [ <str> ] phi = prop [ <str> ] f = self . Tc / ref . Tc * teta T0 = T / f h = ref . rhoc / ref . M * self . M / self . rhoc * phi rho0 = rho / self . M * h * ref . M   fint = 0 for n , t in zip ( coef [ <str> ] , coef [ <str> ] ) :                      fint += n * T ** t  kg = muo * fint * ( self . cp0 . kJkgK - 2.5 * self . R . kJkgK ) ko = 15 / 4 * self . R . kJkgK * muo * 1e-3 kr , kc = 0 , 0 if rho :                      chi = 0 for n , d in zip ( coef [ <str> ] , coef [ <str> ] ) :                          chi += n * rhor ** d  rho0 *= chi F = f ** 0.5 / h ** ( 2 / 3 ) * ( ref . M / self . M ) ** 0.5 kr = F * ref ( ) . _ThCond ( rho0 , T0 , fase , thermo0 , True ) kc = self . _KCritical ( rho , T , fase )  k = kg + ko + kr + kc   else :              muo = MuG_Chung ( T , self . Tc , 1 / self . rhoc , self . M , self . f_acent , self . momentoDipolar . Debye , 0 ) ko = ThG_Chung ( T , self . Tc , self . M , self . f_acent , fase . cv , muo ) k = ThG_P_Chung ( T , self . Tc , 1 / self . rhoc , self . M , self . f_acent , self . momentoDipolar . Debye , 0 , rho , ko )  if type ( k ) == complex :              k = None  return unidades . ThermalConductivity ( k )  @ refDoc ( __doi__ , [ 4 , 5 , 15 , 16 , 19 ] , tab = 8 ) def _KCritical ( self , rho , T , fase ) :          <str> if self . _thermal [ <str> ] == 0 :              tc = 0  elif self . _thermal [ <str> ] == 1 :              rhogcc = rho / 1000 rhoc = self . _thermal [ <str> ] Tc = self . _thermal [ <str> ] f = self . _thermal [ <str> ] gm = self . _thermal [ <str> ] ek = self . _thermal [ <str> ] Kt = self . derivative ( <str> , <str> , <str> , fase ) / fase . rho l = f * ( gm ** 5 * rho * Avogadro / self . M * ek / T ) ** 0.5 Y = 6 * pi * fase . mu * l * ( 1e-3 * Boltzmann * T * rho * Avogadro / self . M ) ** 0.5 if Kt > 0 :                  dL = Boltzmann * T ** 2 * fase . dpdT_rho ** 2 * Kt ** 0.5 / Y  else :                  dL = 0.0  tc = dL * exp ( - 4.25 * ( abs ( rhogcc - rhoc ) / rhoc ) ** 4 ) * exp ( - 18.66 * ( abs ( T - Tc ) / Tc ) ** 2 ) * 1e-2  elif self . _thermal [ <str> ] == 2 :              Tc = self . _thermal . get ( <str> , self . Tc ) rhoc = self . _thermal . get ( <str> , self . rhoc ) X = self . _thermal [ <str> ] Z = self . _thermal [ <str> ] delT = abs ( T - Tc ) / Tc delrho = abs ( rho - rhoc ) / rhoc xi = self . Pc * rho / rhoc ** 2 / fase . dpdrho_T DLc = X [ 3 ] * Boltzmann / self . Pc * ( T * fase . dpdT_rho * self . rhoc / rho ) ** 2 * xi ** X [ 2 ] tc = DLc * exp ( - X [ 0 ] * delT ** 4 - X [ 1 ] * delrho ** 4 ) / ( 6 * pi * fase . mu * Z )  elif self . _thermal [ <str> ] == 3 :              qd = self . _thermal [ <str> ] Tref = self . _thermal [ <str> ] Xio = self . _thermal [ <str> ] gam0 = self . _thermal [ <str> ] gnu = self . _thermal [ <str> ] gamma = self . _thermal [ <str> ] R0 = self . _thermal [ <str> ] Pc = self . _thermal . get ( <str> , self . Pc ) rhoc = self . _thermal . get ( <str> , self . rhoc ) Xi = Pc * rho / rhoc ** 2 * fase . drhodP_T st = self . _eq ( rho , Tref ) delta = st [ <str> ] fird = st [ <str> ] firdd = st [ <str> ] dpdrho = self . R * Tref * ( 1 + 2 * delta * fird + delta ** 2 * firdd ) drho = 1 / dpdrho Xi_Tr = Pc * rho / rhoc ** 2 * drho delchi = Xi - Xi_Tr * Tref / T if delchi <= 0 :                  tc = 0  else :                  Xi = Xio * ( delchi / gam0 ) ** ( gnu / gamma ) Xq = Xi / qd omega = 2 / pi * ( ( fase . cp - fase . cv ) / fase . cp * arctan ( Xq ) + fase . cv / fase . cp * Xq ) omega0 = 2 / pi * ( 1 - exp ( - 1 / ( 1 / Xq + Xq ** 2 / 3 * ( rhoc / rho ) ** 2 ) ) ) Kb = 1.380658e-23 tc = rho * fase . cp * Kb * R0 * T / ( 6 * pi * Xi * fase . mu ) * ( omega - omega0 )   elif self . _thermal [ <str> ] == 4 :              tau = self . _thermal [ <str> ] / T delta = rho / self . _thermal [ <str> ] expo = 0 for n , alfa , t , beta , d in zip ( self . _thermal [ <str> ] , self . _thermal [ <str> ] , self . _thermal [ <str> ] , self . _thermal [ <str> ] , self . _thermal [ <str> ] ) :                  expo += n * ( tau + alfa ) ** t * ( delta + beta ) ** d  tc = self . _thermal [ <str> ] * exp ( expo )  elif isinstance ( self . _thermal [ <str> ] , str ) :              method = self . __getattribute__ ( self . _thermal [ <str> ] ) tc = method ( rho , T , fase )  return tc  @ refDoc ( __doi__ , [ 21 ] , tab = 8 ) def _ECSEstela ( self , delta , tau , ref ) :          <str> a = [ [ 0.05899028 , - 0.93046626 ] , [ - 0.08809157 , 0.18165944 ] , [ 0.01301722 , 0.28587945 ] , [ 0.00436092 , 0.41092573 ] ] b = [ 0.21343372 , - 0.64441400 ] c = [ - 0.12147697 , 0.12392723 ] Zc = self . Pc / self . rhoc / self . R / self . Tc R = ref . eq [ 0 ] [ <str> ] / ref . M * 1000 Zc0 = ref . Pc / ref . rhoc / R / ref . Tc w = self . f_acent w0 = ref . f_acent Delta = ( delta - 1 ) ** 2 + ( 1 / tau - 1 ) ** 2 A1 = a [ 0 ] [ 0 ] - a [ 0 ] [ 1 ] * log ( tau ) A2 = a [ 1 ] [ 0 ] - a [ 1 ] [ 1 ] * log ( tau ) A3 = a [ 2 ] [ 0 ] - a [ 2 ] [ 1 ] * log ( tau ) A4 = a [ 3 ] [ 0 ] - a [ 3 ] [ 1 ] * log ( tau ) phi_teta = b [ 0 ] * delta * exp ( - b [ 1 ] * Delta ** 2 ) phi_phi = c [ 0 ] * delta * exp ( - c [ 1 ] * Delta ** 2 ) teta = 1 + ( w - w0 ) * ( A1 + A2 * exp ( - delta ** 2 ) + phi_teta ) phi = Zc0 / Zc * ( 1 + ( w - w0 ) * ( A3 + A4 * exp ( - delta ** 2 ) + phi_phi ) ) prop = { <str> : teta , <str> : phi } return prop  @ refDoc ( __doi__ , [ 10 ] , tab = 8 ) def _IdealCurve ( self , name , T , rho0 = None ) :          <str> tau = self . Tc / T if name == <str> :              def f ( rho ) :                  delta = rho / self . rhoc return self . _phird ( tau , delta )   elif name == <str> :              def f ( rho ) :                  delta = rho / self . rhoc prop = self . _eq ( rho , T ) return prop [ <str> ] + delta * prop [ <str> ]   elif name == <str> :              def f ( rho ) :                  delta = rho / self . rhoc prop = self . _eq ( rho , T ) return prop [ <str> ] + delta * prop [ <str> ] + tau * prop [ <str> ]   elif name == <str> :              def f ( rho ) :                  prop = self . _eq ( rho , T ) return prop [ <str> ]   if rho0 is None and T < self . Tc :              rho0 = self . _Liquid_Density ( T ) * 2  elif rho0 is None :              rho0 = self . rhoc / 3  rinput = fsolve ( f , rho0 , full_output = True ) if rinput [ 2 ] == 1 and abs ( rinput [ 1 ] [ <str> ] ) < 1e-5 :              rho = rinput [ 0 ] [ 0 ] delta = rho / self . rhoc P = ( 1 + delta * self . _phird ( tau , delta ) ) * self . R * T * rho print ( name , T , rho , P ) return P  else :              print ( rho0 , rinput ) return 0    class MEoSBlend ( MEoS ) :      @ classmethod def _dewP ( cls , T , eq = 0 ) :          c = cls . eq [ eq ] [ <str> ] Tj = cls . eq [ eq ] [ <str> ] Pj = cls . eq [ eq ] [ <str> ] Tita = 1 - T / Tj suma = 0 for i , n in zip ( c [ <str> ] , c [ <str> ] ) :              suma += n * Tita ** ( i / 2. )  P = Pj * exp ( Tj / T * suma ) return unidades . Pressure ( P , <str> )  @ classmethod def _bubbleP ( cls , T , eq = 0 ) :          c = cls . eq [ eq ] [ <str> ] Tj = cls . eq [ eq ] [ <str> ] Pj = cls . eq [ eq ] [ <str> ] Tita = 1 - T / Tj suma = 0 for i , n in zip ( c [ <str> ] , c [ <str> ] ) :              suma += n * Tita ** ( i / 2. )  P = Pj * exp ( Tj / T * suma ) return unidades . Pressure ( P , <str> )  @ classmethod def _Vapor_Pressure ( cls , T , eq = 0 ) :          dew = cls . _dewP ( T , eq ) bubble = cls . _bubbleP ( T , eq ) Pv = unidades . Pressure ( ( dew + bubble ) / 2 ) return Pv   data = MEoS . properties ( ) propiedades = [ p [ 0 ] for p in data ] keys = [ p [ 1 ] for p in data ] units = [ p [ 2 ] for p in data ] properties = dict ( list ( zip ( keys , propiedades ) ) ) inputData = [ data [ 0 ] , data [ 2 ] , data [ 4 ] , data [ 5 ] , data [ 6 ] , data [ 7 ] , data [ 8 ] , data [ 9 ] ] if __name__ == <str> :      from lib . mEoS import H2O st = H2O ( T = 300 , P = 1e5 ) print ( st . rho , st . s ) st1 = H2O ( T = 300 , s = st . s ) print ( st . s , st1 . s )   