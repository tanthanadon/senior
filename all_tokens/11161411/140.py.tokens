<str> from scipy import roots , r_ , log , exp , sqrt from scipy . constants import R from PyQt5 . QtWidgets import QApplication from lib import unidades from lib . eos import EoS from lib . physics import R_atml from lib . bip import Kij , Mixing_Rule from lib . utilities import refDoc __doi__ = { 1 : { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } , 2 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 3 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 4 : { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } , } alfa = ( QApplication . translate ( <str> , <str> ) , <str> , <str> , <str> ) @ refDoc ( __doi__ , [ 3 ] ) def CubicHelmholtz ( tau , delta , ** kw ) :      <str> b = kw [ <str> ] a = kw [ <str> ] dat = kw [ <str> ] datt = kw [ <str> ] dattt = kw [ <str> ] Delta1 = kw [ <str> ] Delta2 = kw [ <str> ] rhoc = kw . get ( <str> , 1 ) Tc = kw . get ( <str> , 1 ) phi1 = - log ( 1 - b * delta * rhoc ) if Delta1 == Delta2 :          phi2 = rhoc * delta  else :          phi2 = log ( ( Delta1 * b * rhoc * delta + 1 ) / ( Delta2 * b * rhoc * delta + 1 ) ) / b / ( Delta1 - Delta2 )  phi1d = b * rhoc / ( 1 - b * delta * rhoc ) phi1dd = b ** 2 * rhoc ** 2 / ( 1 - b * delta * rhoc ) ** 2 phi1ddd = 2 * b ** 3 * rhoc ** 3 / ( 1 - b * delta * rhoc ) ** 3 PI12 = ( 1 + Delta1 * b * rhoc * delta ) * ( 1 + Delta2 * b * rhoc * delta ) PI12d = b * rhoc * ( 2 * Delta1 * Delta2 * b * delta * rhoc + Delta1 + Delta2 ) PI12dd = 2 * Delta1 * Delta2 * b ** 2 * rhoc ** 2 phi2d = rhoc / PI12 phi2dd = - rhoc * PI12d / PI12 ** 2 phi2ddd = rhoc * ( - PI12 * PI12dd + 2 * PI12d ** 2 ) / PI12 ** 3 fir = phi1 - tau * a / R / Tc * phi2 fird = phi1d - tau * a / R / Tc * phi2d firdd = phi1dd - tau * a / R / Tc * phi2dd firddd = phi1ddd - tau * a / R / Tc * phi2ddd dtat = tau * dat + a dtatt = tau * datt + 2 * dat dtattt = tau * dattt + 3 * datt firt = - dtat / R / Tc * phi2 firtt = - dtatt / R / Tc * phi2 firttt = - dtattt / R / Tc * phi2 firdt = - dtat / R / Tc * phi2d firddt = - dtat / R / Tc * phi2dd firdtt = - dtatt / R / Tc * phi2d prop = { } prop [ <str> ] = fir prop [ <str> ] = fird prop [ <str> ] = firt prop [ <str> ] = firdd prop [ <str> ] = firdt prop [ <str> ] = firtt prop [ <str> ] = firddd prop [ <str> ] = firddt prop [ <str> ] = firdtt prop [ <str> ] = firttt prop [ <str> ] = 0 prop [ <str> ] = 0 prop [ <str> ] = 0 return prop  @ refDoc ( __doi__ , [ 1 , 2 ] ) class Cubic ( EoS ) :      <str> def __init__ ( self , T , P , mezcla ) :          P_atm = P / 101325 self . T = unidades . Temperature ( T ) self . P = unidades . Pressure ( P ) self . mezcla = mezcla self . componente = mezcla . componente self . zi = mezcla . fraccion self . B = self . b * P / R / T self . Tita = self . tita * P / ( R * T ) ** 2 delta = self . delta * P / R / T epsilon = self . epsilon * ( P / R / T ) ** 2 self . delta1 = ( ( self . delta ** 2 - 4 * self . epsilon ) ** 0.5 - self . delta ) / 2 / self . b self . delta2 = ( ( self . delta ** 2 - 4 * self . epsilon ) ** 0.5 + self . delta ) / 2 / self . b coeff = [ 1 , delta - self . B - 1 , self . Tita + epsilon - delta * ( self . B + 1 ) , - epsilon * ( self . B + 1 ) - self . Tita * self . B ] Z = roots ( coeff ) self . Z = r_ [ Z [ 0 ] . real , Z [ 2 ] . real ] self . Zl = min ( Z ) . real self . Zg = max ( Z ) . real self . V = self . Z * R_atml * T / P_atm self . rho = 1 / self . V self . Vl = unidades . MolarVolume ( self . Zl * R * T / P , <str> ) self . Vg = unidades . MolarVolume ( self . Zg * R * T / P , <str> )  def _mixture ( self , eq , ids , par ) :          self . kij = Kij ( ids , eq ) mixpar = Mixing_Rule ( self . mezcla . fraccion , par , self . kij ) return mixpar  def _excess ( self , tau , delta ) :          fir = self . fir [ <str> ] fird = self . fir [ <str> ] firt = self . fir [ <str> ] firtt = self . fir [ <str> ] p = { } p [ <str> ] = 1 + delta * fird p [ <str> ] = tau * firt + delta * fird p [ <str> ] = tau * firt - fir p [ <str> ] = - tau ** 2 * firtt return p  def _departure ( self , a , b , d , e , TdadT , V , T ) :          Z = 1 + b / ( V - b ) - a * V / R_atml / T / ( V ** 2 + d * V + e ) K = ( d ** 2 - 4 * e ) ** 0.5 num = 2 * V + d - K den = 2 * V + d + K kw = { } kw [ <str> ] = Z if K :              kw [ <str> ] = 1 - ( a + TdadT ) / R_atml / T / K * log ( num / den ) - Z kw [ <str> ] = TdadT / R_atml / K * log ( num / den ) - log ( Z * ( 1 - b / V ) ) kw [ <str> ] = - a / R_atml / T / K * log ( num / den ) + log ( Z * ( 1 - b / V ) ) kw [ <str> ] = a / R_atml / T / K * log ( num / den ) - log ( Z * ( 1 - b / V ) ) - ( 1 - Z )  else :              kw [ <str> ] = 1 - Z kw [ <str> ] = - log ( Z * ( 1 - b / V ) ) kw [ <str> ] = log ( Z * ( 1 - b / V ) ) kw [ <str> ] = - log ( Z * ( 1 - b / V ) ) - ( 1 - Z )  return kw  def _fug ( self , Z , xi ) :          V = Z * R_atml * self . T / self . P g = log ( V - self . b ) - log ( V ) f = 1 / R_atml / self . b / ( self . delta1 - self . delta2 ) * log ( ( V + self . delta1 * self . b ) / ( V + self . delta2 * self . b ) ) gB = - 1 / ( V - self . b ) An = - g AB = - n * gB - D / self . T * fB AD = - f / self . T dAni = An + AB * Bi + AD * Di fi = dAni - log ( Z ) return  def _fug ( self , Z , xi ) :          Ai = [ ] for i in range ( len ( self . componente ) ) :              suma = 0 for j in range ( len ( self . componente ) ) :                  suma += self . zi [ j ] * self . ai [ j ] ** 0.5 * ( 1 - self . kij [ i ] [ j ] )  Ai . append ( 1 / self . tita * 2 * self . ai [ i ] ** 0.5 * suma )  tita = [ ] for i in range ( len ( self . componente ) ) :              tita . append ( exp ( self . bi [ i ] / self . b * ( Z - 1 ) - log ( Z - self . B ) - self . Tita / self . B / sqrt ( self . u ** 2 - 4 * self . w ) * ( Ai [ i ] - self . bi [ i ] / self . b ) * log ( ( Z + self . B / 2 * ( self . u + sqrt ( self . u ** 2 - 4 * self . w ) ) ) / ( Z + self . B / 2 * ( self . u - sqrt ( self . u ** 2 - 4 * self . w ) ) ) ) ) . real )  return tita    