import os from math import exp , sqrt , ceil from PyQt5 . QtWidgets import QApplication from scipy import roots from scipy . constants import pi , g , e , epsilon_0 from scipy . optimize import fsolve from lib . unidades import ( Length , Pressure , DeltaP , Speed , Time , Area , VolFlow , PotencialElectric , Currency , Dimensionless , MassFlow ) from lib . datasheet import pdf from lib . corriente import Corriente from equipment . parents import equipment class Separador_SolidGas ( equipment ) :      def calcularRendimiento ( self , rendimientos ) :          entrada = self . kwargs [ <str> ] rendimiento_global = 0 for i , fraccion in enumerate ( entrada . solido . fracciones ) :              rendimiento_global += rendimientos [ i ] * fraccion  return Dimensionless ( rendimiento_global )  def CalcularSalidas ( self , entrada = None ) :          if entrada is None :              entrada = self . kwargs [ <str> ]  self . _Salidas ( entrada ) self . Pin = entrada . P self . Pout = self . salida [ 0 ] . P self . Min = entrada . solido . caudal self . Dmin = entrada . solido . diametro_medio self . Mr = self . salida [ 0 ] . solido . caudal self . Dmr = self . salida [ 0 ] . solido . diametro_medio self . Ms = self . salida [ 1 ] . solido . caudal self . Dms = self . salida [ 1 ] . solido . diametro_medio  def _Salidas ( self , entrada ) :          unfiltered , filtered = entrada . solido . Separar ( self . rendimiento_parcial ) Pout = entrada . P - self . deltaP self . salida = [ ] if self . rendimiento == 0 :              self . salida . append ( entrada . clone ( P = Pout ) ) self . salida . append ( entrada . clone ( split = 0 , P = Pout ) )  else :              self . salida . append ( entrada . clone ( solido = unfiltered , P = Pout ) ) self . salida . append ( Corriente ( P = Pout , T = entrada . T , solido = filtered ) )   def propTxt ( self , i , entrada = None ) :          if entrada is None :              entrada = self . kwargs [ <str> ]  txt = os . linesep + <str> txt += QApplication . translate ( <str> , <str> ) txt += <str> + os . linesep txt += self . propertiesToText ( range ( i + 2 , i + 8 ) ) + os . linesep txt += self . propertiesToText ( i ) + os . linesep if len ( entrada . solido . diametros ) >= 1 :              txt += <str> % ( <str> , <str> , <str> , <str> , <str> ) txt += os . linesep for d , X , eta , Xs , Xg in zip ( entrada . solido . diametros , entrada . solido . fracciones , self . rendimiento_parcial , self . salida [ 1 ] . solido . fracciones , self . salida [ 0 ] . solido . fracciones ) :                  txt += <str> % ( d . str , X , eta , Xs , Xg ) txt += os . linesep   return txt  @ classmethod def propertiesEquipment ( cls ) :          l = [ ( QApplication . translate ( <str> , <str> ) , <str> , Pressure ) , ( QApplication . translate ( <str> , <str> ) , <str> , Pressure ) , ( QApplication . translate ( <str> , <str> ) , <str> , DeltaP ) , ( QApplication . translate ( <str> , <str> ) , <str> , Dimensionless ) , ( QApplication . translate ( <str> , <str> ) , <str> , Dimensionless ) , ( QApplication . translate ( <str> , <str> ) , <str> , MassFlow ) , ( QApplication . translate ( <str> , <str> ) , <str> , Length ) , ( QApplication . translate ( <str> , <str> ) , <str> , MassFlow ) , ( QApplication . translate ( <str> , <str> ) , <str> , Length ) , ( QApplication . translate ( <str> , <str> ) , <str> , MassFlow ) , ( QApplication . translate ( <str> , <str> ) , <str> , Length ) ] return l  def writeStatetoJSON ( self , state ) :          state [ <str> ] = self . Pin state [ <str> ] = self . Pout state [ <str> ] = self . deltaP state [ <str> ] = self . Min state [ <str> ] = self . Dmin state [ <str> ] = self . Mr state [ <str> ] = self . Dmr state [ <str> ] = self . Ms state [ <str> ] = self . Dms state [ <str> ] = self . rendimiento_parcial state [ <str> ] = self . rendimiento  def readStatefromJSON ( self , state ) :          self . Pin = Pressure ( state [ <str> ] ) self . Pout = Pressure ( state [ <str> ] ) self . deltaP = DeltaP ( state [ <str> ] ) self . Min = MassFlow ( state [ <str> ] ) self . Dmin = Length ( state [ <str> ] ) self . Mr = MassFlow ( state [ <str> ] ) self . Dmr = Length ( state [ <str> ] ) self . Ms = MassFlow ( state [ <str> ] ) self . Dms = Length ( state [ <str> ] ) eta = [ Dimensionless ( nu ) for nu in state [ <str> ] ] self . rendimiento_parcial = eta self . rendimiento = Dimensionless ( state [ <str> ] )   class GravityChamber ( Separador_SolidGas ) :      title = QApplication . translate ( <str> , <str> ) kwargs = { <str> : None , <str> : 0 , <str> : 0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 } kwargsInput = ( <str> , ) kwargsValue = ( <str> , <str> , <str> , <str> , <str> , <str> ) kwargsList = ( <str> , <str> ) calculateValue = ( <str> , <str> , <str> , <str> , <str> , <str> ) TEXT_TIPO = [ QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) ] TEXT_MODEL = [ QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) ] @ property def isCalculable ( self ) :          if not self . kwargs [ <str> ] :              self . msg = QApplication . translate ( <str> , <str> ) self . status = 0 return  if self . kwargs [ <str> ] :              if self . kwargs [ <str> ] :                  self . msg = <str> self . status = 1 return True  else :                  self . msg = QApplication . translate ( <str> , <str> ) self . status = 0   else :              if not self . kwargs [ <str> ] :                  self . msg = QApplication . translate ( <str> , <str> ) self . status = 0  elif self . kwargs [ <str> ] and self . kwargs [ <str> ] and self . kwargs [ <str> ] :                  self . msg = <str> self . status = 1 return True  elif not self . kwargs [ <str> ] :                  self . msg = QApplication . translate ( <str> , <str> ) self . status = 3 return True  else :                  self . msg = <str> self . status = 1 return True    def calculo ( self ) :          entrada = self . kwargs [ <str> ] W = Length ( self . kwargs [ <str> ] ) L = Length ( self . kwargs [ <str> ] ) self . deltaP = DeltaP ( self . kwargs [ <str> ] ) if self . kwargs [ <str> ] :              self . H = Length ( self . kwargs [ <str> ] )  else :              self . H = Length ( 1 )  if self . kwargs [ <str> ] :              velocidadAdmisible = self . kwargs [ <str> ]  else :              velocidadAdmisible = 1.  if self . kwargs [ <str> ] == 0 :              self . Vgas = Speed ( entrada . Q / self . H / W ) self . rendimiento_parcial = self . calcularRendimientos_parciales ( L ) rendimiento = self . calcularRendimiento ( self . rendimiento_parcial ) self . rendimiento = Dimensionless ( rendimiento )  else :              self . Vgas = Speed ( velocidadAdmisible ) W = Length ( entrada . Q / velocidadAdmisible / self . H ) def f ( longitud ) :                  eta = self . calcularRendimientos_parciales ( longitud ) eta_adm = self . kwargs [ <str> ] return self . calcularRendimiento ( eta ) - eta_adm  if f ( 0.1 ) > self . kwargs [ <str> ] :                  longitud = 1  else :                  longitud_ = 0.1 longitud = fsolve ( f , longitud_ ) [ 0 ]  L = Length ( float ( longitud ) ) eta_i = self . calcularRendimientos_parciales ( L ) self . rendimiento_parcial = eta_i self . rendimiento = Dimensionless ( self . calcularRendimiento ( eta_i ) )  self . LCalc = L self . WCalc = W self . HCalc = self . H self . Q = entrada . Q self . CalcularSalidas ( )  def calcularRendimientos_parciales ( self , L ) :          entrada = self . kwargs [ <str> ] rhoS = entrada . solido . rho rhoG = entrada . Gas . rho muG = entrada . Gas . mu rendimientos = [ ] for d in entrada . solido . diametros :              Ar = d ** 3 * rhoG * ( rhoS - rhoG ) * g / muG ** 2 Vt = muG / d * rhoG * ( ( 14.42 + 1.827 * Ar ** 0.5 ) ** 0.5 - 3.798 ) ** 2 if self . kwargs [ <str> ] == 0 :                  r = Vt * L / self . Vgas / self . H  else :                  r = 1 - exp ( - Vt * L / self . Vgas / self . H )  if r > 1 :                  rendimientos . append ( 1 )  else :                  rendimientos . append ( r )   return rendimientos  def propTxt ( self ) :          txt = os . linesep + <str> txt += QApplication . translate ( <str> , <str> ) txt += <str> + os . linesep txt += self . propertiesToText ( range ( 10 ) ) txt += Separador_SolidGas . propTxt ( self , 10 ) return txt  @ classmethod def propertiesEquipment ( cls ) :          l = [ ( QApplication . translate ( <str> , <str> ) , ( <str> , <str> ) , str ) , ( QApplication . translate ( <str> , <str> ) , ( <str> , <str> ) , str ) , ( QApplication . translate ( <str> , <str> ) , <str> , Length ) , ( QApplication . translate ( <str> , <str> ) , <str> , Length ) , ( QApplication . translate ( <str> , <str> ) , <str> , Length ) , ( QApplication . translate ( <str> , <str> ) , <str> , Speed ) , ( QApplication . translate ( <str> , <str> ) , <str> , VolFlow ) ] for prop in Separador_SolidGas . propertiesEquipment ( ) :              l . append ( prop )  return l  def writeStatetoJSON ( self , state ) :          state [ <str> ] = self . LCalc state [ <str> ] = self . WCalc state [ <str> ] = self . HCalc state [ <str> ] = self . Vgas state [ <str> ] = self . Q Separador_SolidGas . writeStatetoJSON ( self , state )  def readStatefromJSON ( self , state ) :          self . LCalc = Length ( state [ <str> ] ) self . WCalc = Length ( state [ <str> ] ) self . HCalc = Length ( state [ <str> ] ) self . Vgas = Speed ( state [ <str> ] ) self . Q = VolFlow ( state [ <str> ] ) Separador_SolidGas . readStatefromJSON ( self , state ) self . salida = [ None ]   class Ciclon ( Separador_SolidGas ) :      title = QApplication . translate ( <str> , <str> ) help = os . environ [ <str> ] + <str> kwargs = { <str> : None , <str> : 0 , <str> : 0 , <str> : 0 , <str> : 0 , <str> : 0.0 , <str> : 0 , <str> : [ ] , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 1.4 , <str> : 0.0 , <str> : 0.0 , <str> : 0 } kwargsInput = ( <str> , ) kwargsValue = ( <str> , <str> , <str> , <str> , <str> ) kwargsList = ( <str> , <str> , <str> , <str> , <str> ) calculateValue = ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) calculateCostos = ( <str> , <str> , <str> , <str> ) indiceCostos = 2 TEXT_TIPO = [ QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) ] TEXT_MODEL = [ <str> , <str> ] TEXT_MODEL_DELTAP = [ QApplication . translate ( <str> , <str> ) , <str> , <str> , <str> ] TEXT_MODEL_CICLON = [ <str> + QApplication . translate ( <str> , <str> ) + <str> , <str> + QApplication . translate ( <str> , <str> ) + <str> , <str> + QApplication . translate ( <str> , <str> ) + <str> , <str> + QApplication . translate ( <str> , <str> ) + <str> , <str> + QApplication . translate ( <str> , <str> ) + <str> , <str> , <str> , <str> , QApplication . translate ( <str> , <str> ) ] TEXT_COST = [ QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) ] @ property def isCalculable ( self ) :          if self . kwargs [ <str> ] and self . kwargs [ <str> ] and self . kwargs [ <str> ] :              self . statusCoste = True  else :              self . statusCoste = False  if not self . kwargs [ <str> ] :              self . msg = QApplication . translate ( <str> , <str> ) self . status = 0 return  if self . kwargs [ <str> ] :              if self . kwargs [ <str> ] == 8 :                  if self . kwargs [ <str> ] and self . kwargs [ <str> ] and self . kwargs [ <str> ] and self . kwargs [ <str> ] :                      self . msg = <str> self . status = 1 return True  else :                      self . msg = QApplication . translate ( <str> , <str> ) self . status = 0   else :                  if ( self . kwargs [ <str> ] or self . kwargs [ <str> ] ) and self . kwargs [ <str> ] :                      self . msg = <str> self . status = 1 return True  elif self . kwargs [ <str> ] :                      self . msg = QApplication . translate ( <str> , <str> ) self . status = 0  else :                      self . msg = QApplication . translate ( <str> , <str> ) self . status = 0    else :              if self . kwargs [ <str> ] and self . kwargs [ <str> ] :                  self . msg = <str> self . status = 1 return True  elif self . kwargs [ <str> ] :                  self . msg = QApplication . translate ( <str> , <str> ) self . status = 0  else :                  self . msg = QApplication . translate ( <str> , <str> ) self . status = 0    def calculo ( self ) :          entrada = self . kwargs [ <str> ] self . Dc = Length ( self . kwargs [ <str> ] ) self . num_ciclones = int ( self . kwargs [ <str> ] ) self . dimensiones = self . kwargs [ <str> ] self . rendimientoAdmisible = self . kwargs [ <str> ] self . DeltaPAdmisible = Pressure ( self . kwargs [ <str> ] ) rhoS = entrada . solido . rho rhoG = entrada . Gas . rho muG = entrada . Gas . mu if self . kwargs [ <str> ] == 0 :              if self . kwargs [ <str> ] != 8 :                  self . dimensiones = self . dimensionado ( Dc = self . Dc )  else :                  dimensiones = self . dimensionado ( dimensiones = self . dimensiones ) self . dimensiones = dimensiones  self . Hc = Length ( self . dimensiones [ 0 ] ) self . Bc = Length ( self . dimensiones [ 1 ] ) self . Jc = Length ( self . dimensiones [ 2 ] ) self . Lc = Length ( self . dimensiones [ 3 ] ) self . Zc = Length ( self . dimensiones [ 4 ] ) self . De = Length ( self . dimensiones [ 5 ] ) self . Sc = Length ( self . dimensiones [ 6 ] ) self . kf = Length ( self . dimensiones [ 7 ] ) self . G = Length ( self . dimensiones [ 8 ] ) self . V = Speed ( entrada . Q / ( self . Bc * self . Hc * self . num_ciclones ) ) if self . kwargs [ <str> ] == 0 :                  self . N = 11.3 * ( self . Hc * self . Bc / self . Sc ** 2 ) ** 2 + 3.33 dc = sqrt ( 9 * self . Bc * muG / ( 2 * pi * self . N * self . V * ( rhoS - rhoG ) ) ) self . dc = Length ( dc , <str> )  else :                  self . N = self . V * ( 0.1079 - 0.00077 * self . V + 1.924e-6 * self . V ** 2 )  eta_i = self . calcularRendimientos_parciales ( ) self . rendimiento_parcial = eta_i self . rendimiento = self . calcularRendimiento ( eta_i )  else :              if self . DeltaPAdmisible and self . kwargs [ <str> ] :                  V_fpresion = self . velocidad_f_presion ( ) if self . kwargs [ <str> ] > V_fpresion :                      self . kwargs [ <str> ] = V_fpresion   elif self . DeltaPAdmisible :                  self . kwargs [ <str> ] = self . velocidad_f_presion ( )  def f ( diametro ) :                  self . dimensiones = self . dimensionado ( Dc = diametro ) self . Dc = Length ( diametro ) self . Hc = Length ( self . dimensiones [ 0 ] ) self . Bc = Length ( self . dimensiones [ 1 ] ) self . Jc = Length ( self . dimensiones [ 2 ] ) self . Lc = Length ( self . dimensiones [ 3 ] ) self . Zc = Length ( self . dimensiones [ 4 ] ) self . De = Length ( self . dimensiones [ 5 ] ) self . Sc = Length ( self . dimensiones [ 6 ] ) self . kf = Length ( self . dimensiones [ 7 ] ) self . G = Length ( self . dimensiones [ 8 ] ) n = entrada . Q / self . Bc / self . Hc / self . kwargs [ <str> ] self . num_ciclones = int ( ceil ( n ) ) self . V = Speed ( entrada . Q / ( self . Bc * self . Hc * ceil ( n ) ) ) if self . kwargs [ <str> ] == 0 :                      N = 11.3 * ( self . Hc * self . Bc / self . Sc ** 2 ) ** 2 + 3.33 self . N = Dimensionless ( N ) dc = sqrt ( 9 * self . Bc * muG / ( 2 * pi * N * self . V * ( rhoS - rhoG ) ) ) self . dc = Length ( dc , magnitud = <str> )  else :                      N = self . V * ( 0.1079 - 0.00077 * self . V + 1.924e-6 * self . V ** 2 ) self . N = Dimensionless ( N )  rendimiento_parcial = self . calcularRendimientos_parciales ( ) rendimiento = self . calcularRendimiento ( rendimiento_parcial ) return rendimiento - self . kwargs [ <str> ]  Dc0 = 1 diametro = fsolve ( f , Dc0 ) self . Dc = Length ( diametro [ 0 ] ) self . dimensiones = self . dimensionado ( self . Dc ) self . Hc = Length ( self . dimensiones [ 0 ] ) self . Bc = Length ( self . dimensiones [ 1 ] ) self . Jc = Length ( self . dimensiones [ 2 ] ) self . Lc = Length ( self . dimensiones [ 3 ] ) self . Zc = Length ( self . dimensiones [ 4 ] ) self . De = Length ( self . dimensiones [ 5 ] ) self . Sc = Length ( self . dimensiones [ 6 ] ) self . kf = Length ( self . dimensiones [ 7 ] ) self . G = Length ( self . dimensiones [ 8 ] ) eta_i = self . calcularRendimientos_parciales ( ) self . rendimiento_parcial = eta_i self . rendimiento = self . calcularRendimiento ( eta_i )  self . deltaP = self . PerdidaPresion ( ) self . num_ciclonesCoste = self . num_ciclones self . NCalc = self . num_ciclones self . Q = entrada . Q self . Dcc = self . Dc self . CalcularSalidas ( )  def dimensionado ( self , Dc = 0 , dimensiones = [ ] ) :          coef = [ [ 0.5 , 0.2 , 0.375 , 1.5 , 2.5 , 0.5 , 0.5 , 6.4 , 551.3 ] , [ 0.44 , 0.21 , 0.4 , 1.4 , 2.5 , 0.4 , 0.5 , 9.2 , 699.2 ] , [ 0.5 , 0.25 , 0.25 , 2 , 2 , 0.5 , 0.625 , 8 , 402.9 ] , [ 0.5 , 0.25 , 0.4 , 1.75 , 2 , 0.5 , 0.6 , 7.6 , 381.8 ] , [ 0.583 , 0.208 , 0.5 , 1.333 , 1.837 , 0.5 , 0.583 , 7.760896 , 0 ] , [ 0.533 , 0.133 , 0.333 , 0.693 , 1.887 , 0.333 , 0.733 , 11.187981 , 0 ] , [ 0.533 , 0.133 , 0.333 , 0.693 , 1.887 , 0.233 , 0.733 , 22.85221684 , 0 ] , [ 0.4 , 0.1 , 0.333 , 0.693 , 1.887 , 0.233 , 0.733 , 11.78876 , 0 ] ] if self . kwargs [ <str> ] == 8 :              coef = dimensiones dimensiones . append ( 16 * coef [ 0 ] * coef [ 1 ] / coef [ 5 ] ** 2 ) dimensiones . append ( 0 )  else :              coef = coef [ self . kwargs [ <str> ] ]  Hc = Dc * coef [ 0 ] Bc = Dc * coef [ 1 ] Jc = Dc * coef [ 2 ] Lc = Dc * coef [ 3 ] Zc = Dc * coef [ 4 ] De = Dc * coef [ 5 ] Sc = Dc * coef [ 6 ] kf = coef [ 7 ] G = coef [ 8 ] return Hc , Bc , Jc , Lc , Zc , De , Sc , kf , G  def calcularRendimientos_parciales ( self ) :          entrada = self . kwargs [ <str> ] rhoS = entrada . solido . rho muG = entrada . Gas . mu rendimiento_parcial = [ ] if self . kwargs [ <str> ] :              Vo = entrada . Q / self . num_ciclones n = 1 - ( 1 - ( 12 * self . Dc . ft ) ** 0.14 / 2.5 ) * ( ( entrada . T . F + 460 ) / 530 ) ** 0.3 if self . G == 0 :                  Vs = entrada . solido . caudal / entrada . solido . rho / self . num_ciclones self . G = 4 * self . Dc * ( 2 * Vs + Vo ) / self . num_ciclones / self . Hc ** 2 / self . Bc ** 2  for d in entrada . solido . diametros :                  t = rhoS * ( d ) ** 2 / 18 / muG rendimiento_parcial . append ( 1 - exp ( - 2 * ( self . G * t * Vo / self . Dc ** 3 * ( n + 1 ) ) ** ( 0.5 / ( n + 1 ) ) ) )   else :              for d in entrada . solido . diametros :                  rendimiento_parcial . append ( ( d / self . dc ) ** 2 / ( 1 + ( d / self . dc ) ** 2 ) )   return rendimiento_parcial  def PerdidaPresion ( self ) :          entrada = self . kwargs [ <str> ] rhoS = entrada . solido . rho rhoG = entrada . Gas . rho QS = entrada . solido . caudal Q = entrada . caudalmasico if self . kwargs [ <str> ] == 0 :              DeltaP = Pressure ( self . kf / 2. * rhoG * self . V ** 2 )  elif self . kwargs [ <str> ] == 1 :              DeltaP = Pressure ( 0.003 * self . N * rhoG * self . V ** 2 , <str> )  elif self . kwargs [ <str> ] == 2 :              DeltaP = Pressure ( 0.003 * rhoG * 16 * ( entrada . Q / self . num_ciclones ) ** 2 / self . De ** 2 / self . Bc / self . Hc , <str> )  else :              Ae = self . Bc * self . Hc As = pi / 4 * self . De ** 2 rhom = rhoG + QS / rhoG / ( Q + QS / rhoG ) * ( rhoS - rhoG ) DeltaP = Pressure ( 1.078 * ( Ae / As ) ** 1.21 * rhom * self . V ** 2 , <str> )  return DeltaP  def velocidad_f_presion ( self ) :          entrada = self . kwargs [ <str> ] rhoS = entrada . solido . rho rhoG = entrada . Gas . rho dP = self . DeltaPAdmisible QS = entrada . solido . caudal Q = entrada . caudalmasico if self . kwargs [ <str> ] == 0 :              velocidad = sqrt ( dP * 2 / self . kf / rhoG )  elif self . kwargs [ <str> ] == 1 :              velocidad = sqrt ( dP . inH2O / self . N / 0.003 / rhoG )  elif self . kwargs [ <str> ] == 2 :              velocidad = sqrt ( dP * self . De ** 2 * self . Bc * self . Hc / 0.003 / rhoG / 16 )  else :              Ae = self . Bc * self . Hc As = pi / 4 * self . De ** 2 rhom = rhoG + QS / rhoG / ( Q + QS / rhoG ) * ( rhoS - rhoG ) velocidad = sqrt ( dP . mmH2O / 1.078 / ( Ae / As ) ** 1.21 / rhom )  return velocidad  def coste ( self ) :          CI = self . kwargs [ <str> ] BI = self . kwargs [ <str> ] Q = self . kwargs [ <str> ] . Q . kft3min if self . num_ciclones != 1 :              Q = Q / self . num_ciclones  if self . kwargs [ <str> ] == 0 :              C = 1.39 * Q ** 0.98 * 1000  elif self . kwargs [ <str> ] == 1 :              C = 0.65 * Q ** 0.91 * 1000  else :              C = 1.56 * Q ** 0.68 * 1000  self . C_adq = Currency ( C * CI / BI ) self . C_inst = Currency ( self . C_adq * self . kwargs [ <str> ] ) self . C_adqTotal = Currency ( self . C_adq * self . num_ciclones ) self . C_instTotal = Currency ( self . C_inst * self . num_ciclones )  def Pdf ( self ) :          archivo = pdf ( <str> ) archivo . ciclon ( <str> , self ) archivo . dibujar ( )  def propTxt ( self ) :          txt = os . linesep + <str> txt += QApplication . translate ( <str> , <str> ) txt += <str> + os . linesep txt += self . propertiesToText ( range ( 8 ) ) txt += self . propertiesToText ( range ( 17 , 20 ) ) txt += os . linesep + <str> txt += QApplication . translate ( <str> , <str> ) txt += <str> + os . linesep txt += self . propertiesToText ( range ( 8 , 17 ) ) txt += Separador_SolidGas . propTxt ( self , 20 ) if self . statusCoste :              txt += os . linesep + <str> txt += QApplication . translate ( <str> , <str> ) txt += <str> + os . linesep txt += self . propertiesToText ( range ( 27 , 33 ) )  return txt  @ classmethod def propertiesEquipment ( cls ) :          l = [ ( QApplication . translate ( <str> , <str> ) , ( <str> , <str> ) , str ) , ( QApplication . translate ( <str> , <str> ) , ( <str> , <str> ) , str ) , ( QApplication . translate ( <str> , <str> ) , ( <str> , <str> ) , str ) , ( QApplication . translate ( <str> , <str> ) , ( <str> , <str> ) , str ) , ( QApplication . translate ( <str> , <str> ) , <str> , Length ) , ( QApplication . translate ( <str> , <str> ) , <str> , Dimensionless ) , ( QApplication . translate ( <str> , <str> ) , <str> , Speed ) , ( QApplication . translate ( <str> , <str> ) , <str> , VolFlow ) , ( QApplication . translate ( <str> , <str> ) , <str> , int ) , ( QApplication . translate ( <str> , <str> ) , <str> , Length ) , ( QApplication . translate ( <str> , <str> ) , <str> , Length ) , ( QApplication . translate ( <str> , <str> ) , <str> , Length ) , ( QApplication . translate ( <str> , <str> ) , <str> , Length ) , ( QApplication . translate ( <str> , <str> ) , <str> , Length ) , ( QApplication . translate ( <str> , <str> ) , <str> , Length ) , ( QApplication . translate ( <str> , <str> ) , <str> , Length ) , ( QApplication . translate ( <str> , <str> ) , <str> , Length ) , ( QApplication . translate ( <str> , <str> ) , <str> , float ) , ( QApplication . translate ( <str> , <str> ) , <str> , float ) , ( QApplication . translate ( <str> , <str> ) , <str> , float ) , ( QApplication . translate ( <str> , <str> ) , ( <str> , <str> ) , str ) , ( QApplication . translate ( <str> , <str> ) , <str> , Currency ) , ( QApplication . translate ( <str> , <str> ) , <str> , Currency ) ] for prop in Separador_SolidGas . propertiesEquipment ( ) [ - 1 : : - 1 ] :              l . insert ( 17 , prop )  return l  def writeStatetoJSON ( self , state ) :          state [ <str> ] = self . dc state [ <str> ] = self . N state [ <str> ] = self . V state [ <str> ] = self . num_ciclones state [ <str> ] = self . Q state [ <str> ] = self . Dc state [ <str> ] = self . Hc state [ <str> ] = self . Bc state [ <str> ] = self . Jc state [ <str> ] = self . Lc state [ <str> ] = self . Zc state [ <str> ] = self . De state [ <str> ] = self . Sc Separador_SolidGas . writeStatetoJSON ( self , state ) state [ <str> ] = self . statusCoste if self . statusCoste :              state [ <str> ] = self . C_adq state [ <str> ] = self . C_inst   def readStatefromJSON ( self , state ) :          self . dc = Length ( state [ <str> ] ) self . N = Dimensionless ( state [ <str> ] ) self . V = Speed ( state [ <str> ] ) self . num_ciclones = state [ <str> ] self . num_ciclonesCoste = self . num_ciclones self . NCalc = self . num_ciclones self . Q = VolFlow ( state [ <str> ] ) self . Dc = Length ( state [ <str> ] ) self . Dcc = self . Dc self . Hc = Length ( state [ <str> ] ) self . Bc = Length ( state [ <str> ] ) self . Jc = Length ( state [ <str> ] ) self . Lc = Length ( state [ <str> ] ) self . Zc = Length ( state [ <str> ] ) self . De = Length ( state [ <str> ] ) self . Sc = Length ( state [ <str> ] ) Separador_SolidGas . readStatefromJSON ( self , state ) self . statusCoste = state [ <str> ] if self . statusCoste :              self . C_adq = Currency ( state [ <str> ] ) self . C_inst = Currency ( state [ <str> ] )  self . salida = [ None ]   class Baghouse ( Separador_SolidGas ) :      title = QApplication . translate ( <str> , <str> ) kwargs = { <str> : None , <str> : 0 , <str> : 0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 0 , <str> : 0 , <str> : 0.0 , <str> : 0.0 , <str> : [ ] } kwargsInput = ( <str> , ) kwargsValue = ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) kwargsList = ( <str> , ) calculateValue = ( <str> , <str> , <str> , <str> , <str> , <str> ) TEXT_TIPO = [ QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) ] @ property def isCalculable ( self ) :          if not self . kwargs [ <str> ] :              self . msg = QApplication . translate ( <str> , <str> ) self . status = 0 return  if self . kwargs [ <str> ] == 0 and ( not self . kwargs [ <str> ] or not self . kwargs [ <str> ] ) :              self . msg = QApplication . translate ( <str> , <str> ) self . status = 0 return  elif self . kwargs [ <str> ] == 1 and ( not self . kwargs [ <str> ] or not self . kwargs [ <str> ] ) :              self . msg = QApplication . translate ( <str> , <str> ) self . status = 0 return  elif self . kwargs [ <str> ] == 2 and ( not self . kwargs [ <str> ] or not self . kwargs [ <str> ] ) :              self . msg = QApplication . translate ( <str> , <str> ) self . status = 0 return  if self . kwargs [ <str> ] == 2 and self . kwargs [ <str> ] >= self . kwargs [ <str> ] :              self . msg = QApplication . translate ( <str> , <str> ) self . status = 0 return  if not self . kwargs [ <str> ] :              self . msg = QApplication . translate ( <str> , <str> ) self . status = 3 return True  if len ( self . kwargs [ <str> ] ) != len ( self . kwargs [ <str> ] . solido . diametros ) :              self . msg = QApplication . translate ( <str> , <str> ) self . status = 3 return True  self . msg = <str> self . status = 1 return True  def calculo ( self ) :          entrada = self . kwargs [ <str> ] muG = entrada . Gas . mu self . metodo = self . kwargs [ <str> ] self . num_filtros = self . kwargs [ <str> ] self . tiempo = Time ( self . kwargs [ <str> ] ) self . deltaP = Pressure ( self . kwargs [ <str> ] ) if self . kwargs [ <str> ] :              self . resistenciaFiltro = Dimensionless ( self . kwargs [ <str> ] )  else :              self . resistenciaFiltro = Dimensionless ( 0.84 )  if self . kwargs [ <str> ] :              self . resistenciaTorta = Dimensionless ( self . kwargs [ <str> ] )  else :              self . resistenciaTorta = Dimensionless ( 0.1 )  if self . kwargs [ <str> ] :              self . limpieza = self . kwargs [ <str> ]  else :              self . limpieza = 1  if self . kwargs [ <str> ] :              self . membranasFiltro = self . kwargs [ <str> ]  else :              self . membranasFiltro = 78  if self . kwargs [ <str> ] :              self . diametroMembrana = Length ( self . kwargs [ <str> ] )  else :              self . diametroMembrana = Length ( 0.5 , <str> )  if self . kwargs [ <str> ] :              self . areaMembrana = Area ( self . kwargs [ <str> ] )  else :              self . areaMembrana = Area ( 16 , <str> )  if any ( self . kwargs [ <str> ] ) :              self . rendimiento_parcial = self . kwargs [ <str> ]  else :              self . rendimiento_parcial = self . defaultRendimiento ( )  self . rendimiento = self . calcularRendimiento ( self . rendimiento_parcial ) if self . kwargs [ <str> ] == 0 :              self . area = Area ( self . areaMembrana * self . membranasFiltro * ( self . num_filtros - self . limpieza ) ) ms = entrada . solido . caudal . gmin * self . tiempo . min / self . area . ft2 self . Vgas = Speed ( entrada . Q / self . area ) dP = self . resistenciaFiltro * muG . cP * self . Vgas . ftmin + self . resistenciaTorta * muG . cP * ms * self . Vgas . ftmin self . deltaP = Pressure ( dP , <str> )  elif self . kwargs [ <str> ] == 1 :              self . area = Area ( self . areaMembrana * self . membranasFiltro * ( self . num_filtros - self . limpieza ) ) self . Vgas = Speed ( entrada . Q / self . area ) dP = self . resistenciaFiltro * muG . cP * self . Vgas . ftmin deltaPMinimo = Pressure ( dP , <str> ) if deltaPMinimo > self . deltaP :                  self . deltaP = deltaPMinimo self . tiempo = Time ( 0 )  else :                  ms = ( dP - self . resistenciaFiltro * muG . cP * self . Vgas . ftmin ) / ( self . resistenciaTorta * muG . cP * self . Vgas . ftmin ) self . tiempo = Time ( ms * self . area . ft2 / entrada . solido . caudal . gs )   else :              a0 = self . deltaP . inH2O a1 = - self . resistenciaFiltro * muG . cP * entrada . Q . ft3min / self . areaMembrana . ft2 / self . membranasFiltro a2 = - self . resistenciaTorta * muG . cP * entrada . Q . ft3min * entrada . solido . caudal . gmin * self . tiempo . min / self . areaMembrana . ft2 ** 2 / self . membranasFiltro ** 2 N = roots ( [ a0 , a1 , a2 ] ) if N [ 0 ] > 0 :                  self . num_filtros = int ( ceil ( N [ 0 ] ) + self . limpieza )  else :                  self . num_filtros = int ( ceil ( N [ 1 ] ) + self . limpieza )  self . area = Area ( self . areaMembrana * self . membranasFiltro * ( self . num_filtros - self . limpieza ) ) ms = entrada . solido . caudal . gmin * self . tiempo . min / self . area . ft2 self . Vgas = Speed ( entrada . Q / self . area ) dP = self . resistenciaFiltro * muG . cP * self . Vgas . ftmin + self . resistenciaTorta * muG . cP * ms * self . Vgas . ftmin self . deltaP = Pressure ( dP , <str> )  self . floorArea = Area ( self . num_filtros * self . membranasFiltro * self . diametroMembrana ** 2 ) self . num_filtrosCalc = self . num_filtros self . tiempoCalc = self . tiempo self . deltaPCalc = self . deltaP self . CalcularSalidas ( )  def defaultRendimiento ( self ) :          dia = self . kwargs [ <str> ] . solido . diametros rendimiento = [ ( d / 0.3177e-6 ) / ( 1 + ( d / 0.3177e-6 ) ) for d in dia ] return rendimiento  def propTxt ( self ) :          txt = os . linesep + <str> txt += QApplication . translate ( <str> , <str> ) txt += <str> + os . linesep txt += self . propertiesToText ( range ( 3 ) ) suf = <str> % QApplication . translate ( <str> , <str> ) txt += self . propertiesToText ( range ( 3 , 9 ) , kwCheck = True , kwValue = 0 , kwSuffix = suf ) txt += self . propertiesToText ( range ( 9 , 14 ) ) txt += Separador_SolidGas . propTxt ( self , 14 ) return txt  @ classmethod def propertiesEquipment ( cls ) :          l = [ ( QApplication . translate ( <str> , <str> ) , ( <str> , <str> ) , str ) , ( QApplication . translate ( <str> , <str> ) , <str> , int ) , ( QApplication . translate ( <str> , <str> ) , <str> , Time ) , ( QApplication . translate ( <str> , <str> ) , <str> , Dimensionless ) , ( QApplication . translate ( <str> , <str> ) , <str> , Dimensionless ) , ( QApplication . translate ( <str> , <str> ) , <str> , int ) , ( QApplication . translate ( <str> , <str> ) , <str> , int ) , ( QApplication . translate ( <str> , <str> ) , <str> , Length ) , ( QApplication . translate ( <str> , <str> ) , <str> , Area ) , ( QApplication . translate ( <str> , <str> ) , <str> , Speed ) , ( QApplication . translate ( <str> , <str> ) , <str> , Area ) ] for prop in Separador_SolidGas . propertiesEquipment ( ) :              l . append ( prop )  return l  def writeStatetoJSON ( self , state ) :          state [ <str> ] = self . num_filtros state [ <str> ] = self . tiempo state [ <str> ] = self . resistenciaFiltro state [ <str> ] = self . resistenciaTorta state [ <str> ] = self . limpieza state [ <str> ] = self . membranasFiltro state [ <str> ] = self . diametroMembrana state [ <str> ] = self . areaMembrana state [ <str> ] = self . Vgas state [ <str> ] = self . floorArea Separador_SolidGas . writeStatetoJSON ( self , state )  def readStatefromJSON ( self , state ) :          self . num_filtros = state [ <str> ] self . tiempo = Time ( state [ <str> ] ) self . resistenciaFiltro = Dimensionless ( state [ <str> ] ) self . resistenciaTorta = Dimensionless ( state [ <str> ] ) self . limpieza = state [ <str> ] self . membranasFiltro = state [ <str> ] self . diametroMembrana = Length ( state [ <str> ] ) self . areaMembrana = Area ( state [ <str> ] ) self . Vgas = Speed ( state [ <str> ] ) self . floorArea = Area ( state [ <str> ] ) Separador_SolidGas . readStatefromJSON ( self , state ) self . salida = [ None ]   class ElectricPrecipitator ( Separador_SolidGas ) :      title = QApplication . translate ( <str> , <str> ) kwargs = { <str> : None , <str> : 0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 } kwargsInput = ( <str> , ) kwargsValue = ( <str> , <str> , <str> , <str> , <str> , <str> ) kwargsList = ( <str> , ) calculateValue = ( <str> , <str> ) TEXT_TIPO = [ QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) ] @ property def isCalculable ( self ) :          if not self . kwargs [ <str> ] :              self . msg = QApplication . translate ( <str> , <str> ) self . status = 0 return  if self . kwargs [ <str> ] == 0 and not self . kwargs [ <str> ] :              self . msg = QApplication . translate ( <str> , <str> ) self . status = 0 return  elif self . kwargs [ <str> ] == 1 and not self . kwargs [ <str> ] :              self . msg = QApplication . translate ( <str> , <str> ) self . status = 0 return  if not self . kwargs [ <str> ] :              self . msg = QApplication . translate ( <str> , <str> ) self . status = 3 return True  if not self . kwargs [ <str> ] :              self . msg = QApplication . translate ( <str> , <str> ) self . status = 3 return True  if not self . kwargs [ <str> ] :              self . msg = QApplication . translate ( <str> , <str> ) self . status = 3 return True  self . msg = <str> self . status = 1 return True  def calculo ( self ) :          self . areaCalculada = Area ( self . kwargs [ <str> ] ) self . deltaP = Pressure ( self . kwargs [ <str> ] ) if self . kwargs [ <str> ] :              self . potencialCarga = PotencialElectric ( self . kwargs [ <str> ] )  else :              self . potencialCarga = PotencialElectric ( 24000 )  if self . kwargs [ <str> ] :              self . potencialDescarga = PotencialElectric ( self . kwargs [ <str> ] )  else :              self . potencialDescarga = PotencialElectric ( 24000 )  if self . kwargs [ <str> ] :              self . epsilon = Dimensionless ( self . kwargs [ <str> ] )  else :              self . epsilon = Dimensionless ( 4. )  if self . kwargs [ <str> ] == 1 :              def f ( area ) :                  eta_i = self . calcularRendimientos_parciales ( area ) eta = self . calcularRendimiento ( eta_i ) return eta - self . kwargs [ <str> ]  self . areaCalculada = Area ( fsolve ( f , 100 ) [ 0 ] )  eta_i = self . calcularRendimientos_parciales ( self . areaCalculada ) self . rendimiento_parcial = eta_i self . rendimiento = self . calcularRendimiento ( eta_i ) self . CalcularSalidas ( )  def calcularRendimientos_parciales ( self , A ) :          entrada = self . kwargs [ <str> ] rendimiento_parcial = [ ] for dp in entrada . solido . diametros :              if dp <= 1e-6 :                  q = dp * e * 1e8  else :                  q = pi * epsilon_0 * self . potencialCarga * dp ** 2 * ( 1 + 2 * ( self . epsilon - 1. ) / ( self . epsilon + 2. ) )  U = q * self . potencialDescarga / ( 3 * pi * dp * entrada . Gas . mu ) rendimiento_parcial . append ( Dimensionless ( 1 - exp ( - U * A / entrada . Q ) ) )  return rendimiento_parcial  def propTxt ( self ) :          txt = os . linesep + <str> txt += QApplication . translate ( <str> , <str> ) txt += <str> + os . linesep txt += self . propertiesToText ( 0 ) suf = <str> % QApplication . translate ( <str> , <str> ) txt += self . propertiesToText ( range ( 1 , 4 ) , kwCheck = True , kwValue = 0 , kwSuffix = suf ) txt += self . propertiesToText ( range ( 4 , 8 ) ) txt += Separador_SolidGas . propTxt ( self , 8 ) return txt  @ classmethod def propertiesEquipment ( cls ) :          l = [ ( QApplication . translate ( <str> , <str> ) , ( <str> , <str> ) , str ) , ( QApplication . translate ( <str> , <str> ) , <str> , PotencialElectric ) , ( QApplication . translate ( <str> , <str> ) , <str> , PotencialElectric ) , ( QApplication . translate ( <str> , <str> ) , <str> , Dimensionless ) , ( QApplication . translate ( <str> , <str> ) , <str> , Area ) ] for prop in Separador_SolidGas . propertiesEquipment ( ) :              l . append ( prop )  return l  def writeStatetoJSON ( self , state ) :          state [ <str> ] = self . potencialCarga state [ <str> ] = self . potencialDescarga state [ <str> ] = self . epsilon state [ <str> ] = self . areaCalculada Separador_SolidGas . writeStatetoJSON ( self , state )  def readStatefromJSON ( self , state ) :          self . potencialCarga = PotencialElectric ( state [ <str> ] ) self . potencialDescarga = PotencialElectric ( state [ <str> ] ) self . epsilon = Dimensionless ( state [ <str> ] ) self . areaCalculada = Area ( state [ <str> ] ) Separador_SolidGas . readStatefromJSON ( self , state ) self . salida = [ None ]   if __name__ == <str> :      import doctest doctest . testmod ( )   