import math import os import re import tempfile from scipy import exp , cosh , sinh , tanh , log , log10 , roots , absolute , array from scipy . optimize import fsolve from scipy . constants import R , Avogadro , Boltzmann from scipy . interpolate import interp1d , interp2d from lib . physics import R_atml , Collision_Neufeld from lib import unidades , config , sql from lib . utilities import refDoc __doi__ = { 1 : { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } , 2 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 3 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 4 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 5 : { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } , 6 : { <str> : <str> , <str> : <str> <str> <str> , <str> : <str> , <str> : <str> } , 7 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 8 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 9 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 10 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 11 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 12 : { <str> : <str> <str> , <str> : <str> <str> <str> , <str> : <str> , <str> : <str> } , 13 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 14 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 15 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 16 : { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } , 17 : { <str> : <str> , <str> : <str> <str> <str> , <str> : <str> , <str> : <str> } , 18 : { <str> : <str> , <str> : <str> <str> <str> , <str> : <str> , <str> : <str> } , 19 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 20 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 21 : { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } , 22 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 23 : { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } , 24 : { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } , 25 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 26 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 27 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 28 : { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } , 29 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 30 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 31 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 32 : { <str> : <str> , <str> : <str> <str> <str> , <str> : <str> , <str> : <str> } , 33 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 34 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 35 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 36 : { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } , 37 : { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } , 38 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 39 : { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } , 40 : { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } , 41 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 42 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 43 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 44 : { <str> : <str> <str> , <str> : <str> <str> <str> , <str> : <str> , <str> : <str> } , 45 : { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } , 46 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 47 : { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } , 48 : { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } , 49 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 50 : { <str> : <str> , <str> : <str> <str> <str> , <str> : <str> , <str> : <str> } , 51 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 52 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 53 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 54 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 55 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 56 : { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } , 57 : { <str> : <str> <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 58 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 59 : { <str> : <str> , <str> : <str> , <str> : <str> , <str> : <str> } , 60 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } , 61 : { <str> : <str> , <str> : <str> <str> , <str> : <str> , <str> : <str> } } def atomic_decomposition ( cmp ) :      kw = { } for element , c in re . findall ( <str> , cmp ) :          if element not in kw :              kw [ element ] = 0  if not c :              c = 1  else :              c = int ( c )  kw [ element ] += c  return kw  def DIPPR ( prop , T , args , Tc = None , M = None ) :      <str> mul = 1 if <str> in prop :          unit = unidades . Density mul = M  elif prop == <str> :          unit = unidades . Pressure  elif prop == <str> :          unit = unidades . MolarEnthalpy mul = 1 / M  elif <str> in prop :          unit = unidades . SpecificHeat mul = 1 / M  elif <str> in prop :          unit = unidades . Viscosity  elif <str> in prop :          unit = unidades . ThermalConductivity  elif prop == <str> :          unit = unidades . Tension  eq , A , B , C , D , E = args if eq == 1 :          value = A + B * T + C * T ** 2 + D * T ** 3 + E * T ** 4  elif eq == 2 :          value = exp ( A + B / T + C * log ( T ) + D * T ** E )  elif eq == 3 :          value = A * T ** B / ( 1 + C / T + D / T ** 2 )  elif eq == 4 :          value = A + B * exp ( - C / T ** D )  elif eq == 5 :          value = A + B / T + C / T ** 3 + D / T ** 8 + E / T ** 9  elif eq == 6 :          value = A / ( B ** ( 1 + ( ( 1 - T / C ) ** D ) ) )  elif eq == 7 :          Tr = T / Tc value = A * ( 1 - Tr ) ** ( B + C * Tr + D * Tr ** 2 + E * Tr ** 3 )  elif eq == 8 :          value = A + B * ( C / T / sinh ( C / T ) ) ** 2 + D * ( E / T / cosh ( E / T ) ) ** 2  elif eq == 9 :          Tr = T / Tc value = A ** 2 / Tr + B - 2 * A * C * Tr - A * D * Tr ** 2 - C ** 2 * Tr ** 3 / 3 - C * D * Tr ** 4 / 2 - D ** 2 * Tr ** 5 / 5  return unit ( value * mul )  @ refDoc ( __doi__ , [ 21 , 35 , 5 ] ) def RhoL_Rackett ( T , Tc , Pc , Zra , M ) :      <str> Pc_atm = Pc / 101325 Tr = T / Tc V = R_atml * Tc / Pc_atm * Zra ** ( 1 + ( 1 - Tr ) ** ( 2 / 7 ) ) return unidades . Density ( M / V )  @ refDoc ( __doi__ , [ 20 , 5 ] ) def RhoL_Costald ( T , Tc , w , Vc ) :      <str> a = - 1.52816 b = 1.43907 c = - 0.81446 d = 0.190454 e = - 0.296123 f = 0.386914 g = - 0.0427258 h = - 0.0480645 Tr = T / Tc Vr0 = 1 + a * ( 1 - Tr ) ** ( 1 / 3 ) + b * ( 1 - Tr ) ** ( 2 / 3 ) + c * ( 1 - Tr ) + d * ( 1 - Tr ) ** ( 4 / 3 ) Vr1 = ( e + f * Tr + g * Tr ** 2 + h * Tr ** 3 ) / ( Tr - 1.00001 ) V = Vc * Vr0 * ( 1 - w * Vr1 ) return unidades . Density ( 1 / V )  def RhoL_Cavett ( T , Tc , M , Vliq ) :      <str> Tr = T / Tc V = Vliq * ( 5.7 + 3 * Tr ) / M return unidades . Density ( 1 / V , <str> )  @ refDoc ( __doi__ , [ 26 ] ) def RhoL_YenWoods ( T , Tc , Vc , Zc ) :      <str> Tr = T / Tc A = 17.4425 - 214.578 * Zc + 989.625 * Zc ** 2 - 1522.06 * Zc ** 3 if Zc <= 0.26 :          B = - 3.28257 + 13.6377 * Zc + 107.4844 * Zc ** 2 - 384.211 * Zc ** 3  else :          B = 60.2091 - 402.063 * Zc + 501.0 * Zc ** 2 + 641.0 * Zc ** 3  D = 0.93 - B rhos = ( 1 + A * ( 1 - Tr ) ** ( 1 / 3 ) + B * ( 1 - Tr ) ** ( 2 / 3 ) + D * ( 1 - Tr ) ** ( 4 / 3 ) ) / Vc return unidades . Density ( rhos )  @ refDoc ( __doi__ , [ 23 , 27 ] ) def RhoL_YamadaGunn ( T , Tc , Pc , w , M ) :      <str> Tr = T / Tc if Tr < 0.8 :          Vr = 0.33593 - 0.33953 * Tr + 1.51941 * Tr ** 2 - 2.02512 * Tr ** 3 + 1.11422 * Tr ** 4  elif Tr < 1 :          Vr = 1 + 1.3 * ( 1 - Tr ) ** 0.5 * log10 ( 1 - Tr ) - 0.50879 * ( 1 - Tr ) - 0.91534 * ( 1 - Tr ) ** 2  elif Tr == 1 :          Vr = 1  d = 0.29607 - 0.09045 * Tr - 0.04842 * Tr ** 2 Zsc = 0.292 - 0.0967 * w Vsc = Zsc * R * Tc / Pc V = Vsc * Vr * ( 1 - w * d ) return unidades . Density ( M / V , <str> )  @ refDoc ( __doi__ , [ 28 ] ) def RhoL_Bhirud ( T , Tc , Pc , w , M ) :      <str> Tr = T / Tc if Tr <= 0.98 :          lnU0 = 1.39644 - 24.076 * Tr + 102.615 * Tr ** 2 - 255.719 * Tr ** 3 + 355.805 * Tr ** 4 - 256.671 * Tr ** 5 + 75.1088 * Tr ** 6 lnU1 = 13.4412 - 135.7437 * Tr + 533.380 * Tr ** 2 - 1091.453 * Tr ** 3 + 1231.43 * Tr ** 4 - 728.227 * Tr ** 5 + 176.737 * Tr ** 6  elif Tr < 1 :          Trs_ = [ 0.98 , 0.982 , 0.984 , 0.986 , 0.988 , 0.99 , 0.992 , 0.994 , 0.996 , 0.998 , 0.999 , 1 ] lnU0_ = [ - 1.6198 , - 1.604 , - 1.59 , - 1.578 , - 1.564 , - 1.548 , - 1.533 , - 1.515 , - 1.489 , - 1.454 , - 1.425 , - 1.243 ] lnU1_ = [ - 0.4626 , - 0.459 , - 0.451 , - 0.441 , - 0.428 , - 0.412 , - 0.392 , - 0.367 , - 0.337 , - 0.302 , - 0.283 , - 0.2629 ] lnU0 = interp1d ( Trs_ , lnU0_ , kind = <str> ) ( Tr ) lnU1 = interp1d ( Trs_ , lnU1_ , kind = <str> ) ( Tr )  else :          raise NotImplementedError ( <str> )  U = exp ( lnU0 + w * lnU1 ) Vs = U * R * T / Pc return unidades . Density ( M / Vs , <str> )  @ refDoc ( __doi__ , [ 29 ] ) def RhoL_Mchaweh ( T , Tc , Vc , w , delta ) :      <str> Tr = T / Tc m = 0.480 + 1.574 * w - 0.176 * w ** 2 alpha = ( 1 + m * ( 1 - Tr ** 0.5 ) ) ** 2 tau = 1 - Tr / alpha rho0 = 1 + 1.169 * tau ** ( 1 / 3 ) + 1.818 * tau ** ( 2 / 3 ) - 2.658 * tau + 2.161 * tau ** ( 4 / 3 ) rhos = rho0 / Vc * ( 1 + delta * ( alpha - 1 ) ** ( 1 / 3 ) ) return unidades . Density ( rhos )  Mchaweh_d = { 28 : 0.57510 , 24 : 2.09626 , 35 : 2.42033 , 83 : 1.37209 , 146 : - 0.13014 , 130 : - 1.03473 , 140 : 1.75281 , 65 : 0.07747 , 63 : 6.79976 , 98 : - 3.25962 , 40 : 1.44502 , 343 : 2.68664 , 6 : 0.13196 , 49 : 1.54186 , 48 : 0.80200 , 105 : 1.30100 , 172 : 4.46227 , 25 : 1.12156 , 30 : 5.68825 , 38 : - 0.45300 , 325 : 2.70939 , 36 : - 0.28797 , 69 : 1.79061 , 14 : 5.12504 , 3 : - 1.46429 , 22 : - 0.46558 , 45 : 2.94376 , 59 : 0.94253 , 162 : 0.10621 , 208 : - 3.03979 , 50 : 0.59860 , 1 : - 19.75170 , 5 : 3.10327 , 27 : 0.98728 , 7 : 0.09888 , 61 : 4.21712 , 145 : - 1.10422 , 2 : - 3.20525 , 117 : 0.71947 , 39 : - 0.57591 , 37 : 0.59017 , 160 : 0.23343 , 107 : - 5.63803 , 11 : 1.87922 , 10 : 1.19300 , 46 : - 0.79463 , 91 : - 3.71806 , 13 : 3.60629 , 8 : 0.62738 , 90 : 9.08709 , 12 : 3.64147 , 47 : - 2.70491 , 19 : 6.93421 , 229 : - 2.62285 , 400 : - 1.76731 , 57 : 10.90360 , 4 : - 0.25595 , 23 : 1.47939 , 51 : 3.29577 , 100 : - 1.31517 , 41 : 1.39931 , 26 : 0.19733 , } @ refDoc ( __doi__ , [ 32 ] ) def RhoL_Riedel ( T , Tc , Vc , w ) :      <str> Tr = T / Tc rhos = ( 1 + 0.85 * ( 1 - Tr ) + ( 1.6916 + 0.984 * w ) * ( 1 - Tr ) ** ( 1 / 3 ) ) / Vc return unidades . Density ( rhos )  @ refDoc ( __doi__ , [ 33 ] ) def RhoL_ChuehPrausnitz ( T , Tc , Vc , w ) :      <str> a = ( 0.11917 , 0.98465 , - 0.55314 ) b = ( 0.009513 , - 1.60378 , - 0.15793 ) c = ( 0.21091 , 1.82484 , - 1.01601 ) d = ( - 0.06922 , - 0.61432 , 0.34095 ) e = ( 0.07480 , - 0.34546 , 0.46795 ) f = ( - 0.084476 , 0.087037 , - 0.239938 ) Tr = T / Tc v0 = a [ 0 ] + b [ 0 ] * Tr + c [ 0 ] * Tr ** 2 + d [ 0 ] * Tr ** 3 + e [ 0 ] / Tr + f [ 0 ] * log ( 1 - Tr ) v1 = a [ 1 ] + b [ 1 ] * Tr + c [ 1 ] * Tr ** 2 + d [ 1 ] * Tr ** 3 + e [ 1 ] / Tr + f [ 1 ] * log ( 1 - Tr ) v2 = a [ 2 ] + b [ 2 ] * Tr + c [ 2 ] * Tr ** 2 + d [ 2 ] * Tr ** 3 + e [ 2 ] / Tr + f [ 2 ] * log ( 1 - Tr ) Vr = v0 + w * v1 + w ** 2 * v2 return unidades . Density ( 1 / Vr / Vc )  @ refDoc ( __doi__ , [ 22 , 5 ] ) def RhoL_TaitCostald ( T , P , Tc , Pc , w , Ps , rhos ) :      <str> Tr = T / Tc C = 0.0861488 + 0.0344483 * w e = exp ( 4.79594 + 0.250047 * w + 1.14188 * w ** 2 ) B = Pc * ( - 1 - 9.070217 * ( 1 - Tr ) ** ( 1 / 3 ) + 62.45326 * ( 1 - Tr ) ** ( 2 / 3 ) - 135.1102 * ( 1 - Tr ) + e * ( 1 - Tr ) ** ( 4 / 3 ) ) rho = rhos / ( 1 - C * log ( ( B + P ) / ( B + Ps ) ) ) return unidades . Density ( rho , <str> )  @ refDoc ( __doi__ , [ 30 ] ) def RhoL_ChangZhao ( T , P , Tc , Pc , w , Ps , rhos ) :      <str> Tr = T / Tc Pr = P / Pc Psr = Ps / Pc a = ( 99.42 , - 78.68 , - 75.18 , 41.49 , 7.257 ) b = ( 0.38144 , - 0.30144 ) A = sum ( ai * Tr ** i for i , ai in enumerate ( a ) ) B = sum ( bi * w ** i for i , bi in enumerate ( b ) ) rho = rhos * ( A + 2.81 * ( Pr - Psr ) ) / ( A + 2.81 ** ( 1.1 - Tr ) ** B * ( Pr - Psr ) ) return unidades . Density ( rho )  @ refDoc ( __doi__ , [ 31 , 1 ] ) def RhoL_AaltoKeskinen ( T , P , Tc , Pc , w , Ps , rhos ) :      <str> Tr = T / Tc Pr = P / Pc Psr = Ps / Pc a = ( - 170.335 , - 28.5784 , 124.809 , - 55.5393 , 130.010 ) b = ( 0.164813 , - 0.0914427 ) C = math . e A = a [ 0 ] + a [ 1 ] * Tr + a [ 2 ] * Tr ** 3 + a [ 3 ] * Tr ** 6 + a [ 4 ] / Tr B = b [ 0 ] + b [ 1 ] * w rho = rhos * ( A + C * ( Pr - Psr ) ) / ( A + C ** ( 1.00588 - Tr ) ** B * ( Pr - Psr ) ) return unidades . Density ( rho )  @ refDoc ( __doi__ , [ 37 , 38 ] ) def RhoL_AaltoKeskinen2 ( T , P , Tc , Pc , w , Ps , rhos ) :      <str> Tr = T / Tc Pr = P / Pc Psr = Ps / Pc a = ( 482.85416 , - 1154.2977 , 790.09727 , - 212.14413 , 93.4904 ) b = ( 0.0264002 , 0.42711522 , 0.5 ) c = ( 9.2892236 , 2.5103968 , 0.59397220 , 0.0010895002 ) E = 0.80329503 A = a [ 0 ] + a [ 1 ] * Tr + a [ 2 ] * Tr ** 3 + a [ 3 ] * Tr ** 6 + a [ 4 ] / Tr B = b [ 0 ] + b [ 1 ] / ( b [ 2 ] + w ) C = c [ 0 ] * ( 1 - Tr ) ** c [ 1 ] + ( 1 - ( 1 - Tr ) ** c [ 1 ] ) * exp ( c [ 2 ] + c [ 3 ] * ( Pr - Psr ) ) rho = rhos * ( A + C * ( Pr - Psr ) ** E ) / ( A + C ** ( 1.00001 - Tr ) ** B * ( Pr - Psr ) ** E ) return unidades . Density ( rho )  @ refDoc ( __doi__ , [ 36 ] ) def RhoL_Nasrifar ( T , P , Tc , Pc , w , M , Ps , rhos ) :      <str> j = ( 1.3168e-3 , 3.4448e-2 , 5.4131e-2 ) L = 9.6840e-2 m = 8.6761e-6 f = 48.8756 G = 0.7185 I = 3.4031e-5 c = ( 5.5526 , - 2.7659 ) om = ( 7.9019e-2 , - 2.8431e-2 ) Tr = T / Tc Pr = P / Pc Prs = Ps / Pc vs = 1 / rhos J = j [ 0 ] + j [ 1 ] * ( 1 - Tr ) ** ( 1 / 3 ) + j [ 2 ] * ( 1 - Tr ) ** ( 2 / 3 ) F = f * ( 1 - Tr ) C = c [ 0 ] + c [ 1 ] * w OM = om [ 0 ] + om [ 1 ] * w v_inf = OM * R * 1000 / M * Tc / Pc phi = ( J + L * ( Pr - Prs ) + m * ( Pr - Prs ) ** 3 ) / ( F + G * ( Pr - Prs ) + I * ( Pr - Prs ) ** 3 ) v = C * tanh ( phi ) * ( v_inf - vs ) + vs return unidades . Density ( 1 / v )  @ refDoc ( __doi__ , [ 33 , 5 ] ) def RhoL_API ( T , P , Tc , Pc , SG , rhos ) :      <str> Pr = P / Pc Tr = T / Tc A0 = 1.6368 - 0.04615 * Pr + 2.1138e-3 * Pr ** 2 - 0.7845e-5 * Pr ** 3 - 0.6923e-6 * Pr ** 4 A1 = - 1.9693 + 0.21874 * Pr - 8.0028e-3 * Pr ** 2 - 8.2328e-5 * Pr ** 3 + 5.2604e-6 * Pr ** 4 A2 = 2.4638 - 0.36461 * Pr + 12.8763e-3 * Pr ** 2 + 14.8059e-5 * Pr ** 3 - 8.6895e-6 * Pr ** 4 A3 = - 1.5841 + 0.25136 * Pr - 11.3805e-3 * Pr ** 2 + 9.5672e-5 * Pr ** 3 + 2.1812e-6 * Pr ** 4 C2 = A0 + A1 * Tr + A2 * Tr ** 2 + A3 * Tr ** 3 d2 = rhos * C2 / SG return unidades . Density ( d2 )  @ refDoc ( __doi__ , [ 1 , 3 ] ) def Pv_Antoine ( T , args , Tc = None , base = math . e , Punit = <str> ) :      <str> if len ( args ) > 3 and args [ 3 ] is None :          args = args [ : 3 ]  if len ( args ) == 3 :          A , B , C = args Pv = base ** ( A - B / ( T + C ) )  elif len ( args ) == 7 and args [ 3 ] is not None and Tc is not None :          A , B , C , n , E , F , to = args x = ( T - to ) / Tc if x <= 0 :              Pv = base ** ( A - B / ( T + C ) )  else :              Pv = base ** ( A - B / ( T + C ) + 0.43429 * x ** n + E * x ** 8 + F * x ** 12 )   return unidades . Pressure ( Pv , Punit )  @ refDoc ( __doi__ , [ 4 , 2 ] ) def Pv_Lee_Kesler ( T , Tc , Pc , w ) :      <str> Tr = T / Tc f0 = 5.92714 - 6.09648 / Tr - 1.28862 * log ( Tr ) + 0.169347 * Tr ** 6 f1 = 15.2518 - 15.6875 / Tr - 13.4721 * log ( Tr ) + 0.43577 * Tr ** 6 return unidades . Pressure ( exp ( f0 + w * f1 ) * Pc )  @ refDoc ( __doi__ , [ 6 , 1 , 5 , 7 ] ) def Pv_Wagner ( T , args , Tc , Pc ) :      <str> a , b , c , d = args Tr = T / Tc tau = 1 - Tr Pv = Pc / Tr * exp ( a * tau + b * tau ** 1.5 + c * tau ** 3 + d * tau ** 6 ) return unidades . Pressure ( Pv )  @ refDoc ( __doi__ , [ 8 , 1 ] ) def Pv_AmbroseWalton ( T , Tc , Pc , w ) :      <str> Tr = T / Tc t = 1 - T / Tc f0 = ( - 5.97616 * t + 1.29874 * t ** 1.5 - 0.60394 * t ** 2.5 - 1.06841 * t ** 5 ) / Tr f1 = ( - 5.03365 * t + 1.11505 * t ** 1.5 - 5.41217 * t ** 2.5 - 7.46628 * t ** 5 ) / Tr f2 = ( - 0.64771 * t + 2.41539 * t ** 1.5 - 4.26979 * t ** 2.5 + 3.25259 * t ** 5 ) / Tr Pv = Pc * exp ( f0 + w * f1 + w ** 2 * f2 ) return unidades . Pressure ( Pv )  @ refDoc ( __doi__ , [ 1 ] ) def Pv_Riedel ( T , Tc , Pc , Tb ) :      <str> Tr = T / Tc Tbr = Tb / Tc K = 0.0838 fib = - 35 + 36 / Tbr + 42 * log ( Tbr ) - Tbr ** 6 alfa_c = ( 3.758 * K * fib + log ( Pc * 1e-5 / 1.01325 ) ) / ( K * fib - log ( Tbr ) ) Q = K * ( 3.758 - alfa_c ) Pv = Pc * exp ( - 35 * Q + 36 * Q / Tr + ( 42 * Q + alfa_c ) * log ( Tr ) - Q * Tr ** 6 ) return unidades . Pressure ( Pv )  @ refDoc ( __doi__ , [ 5 ] ) def Pv_MaxwellBonnel ( T , Tb , Kw ) :      <str> Tb_F = unidades . K2F ( Tb ) Tb_R = unidades . K2R ( Tb ) T_R = unidades . K2R ( T ) if Tb_F > 400 :          f = 1.0  elif Tb_F < 200 :          f = 0.0  else :          f = ( Tb_R - 659.7 ) / 200  def P ( Tb ) :          X = ( Tb / T_R - 0.0002867 * Tb ) / ( 748.1 - 0.2145 * Tb ) if X > 0.0022 :              p = 10 ** ( ( 3000.538 * X - 6.761560 ) / ( 43 * X - 0.987672 ) )  elif X < 0.0013 :              p = 10 ** ( ( 2770.085 * X - 6.412631 ) / ( 36 * X - 0.989679 ) )  else :              p = 10 ** ( ( 2663.129 * X - 5.994296 ) / ( 95.76 * X - 0.972546 ) )  return p  Tb = fsolve ( lambda Tb : Tb - Tb_R + 2.5 * f * ( Kw - 12 ) * log10 ( P ( Tb ) / 760 ) , Tb ) p = P ( Tb ) return unidades . Pressure ( p , <str> )  @ refDoc ( __doi__ , [ 9 ] ) def Pv_Sanjari ( T , Tc , Pc , w ) :      <str> a = [ None , 6.83377 , - 5.76051 , 0.90654 , - 1.16906 , 5.32034 , - 28.1460 , - 58.0352 , 23.57466 , 18.19967 , 16.33839 , 65.6995 , - 35.9739 ] Tr = T / Tc f0 = a [ 1 ] + a [ 2 ] / Tr + a [ 3 ] * log ( Tr ) + a [ 4 ] * Tr ** 1.9 f1 = a [ 5 ] + a [ 6 ] / Tr + a [ 7 ] * log ( Tr ) + a [ 8 ] * Tr ** 1.9 f2 = a [ 9 ] + a [ 10 ] / Tr + a [ 11 ] * log ( Tr ) + a [ 12 ] * Tr ** 1.9 Pv = Pc * exp ( f0 + w * f1 + w ** 2 * f2 ) return unidades . Pressure ( Pv )  def MuL_Parametric ( T , args ) :      <str> A , B = args mu = 10 ** ( A * ( 1 / T - 1 / B ) ) return unidades . Viscosity ( mu , <str> )  @ refDoc ( __doi__ , [ 10 ] ) def MuL_LetsouStiel ( T , M , Tc , Pc , w ) :      <str> Pc_atm = unidades . Pressure ( Pc ) . atm Tr = T / Tc x = Tc ** ( 1 / 6 ) / M ** 0.5 / Pc_atm ** ( 2 / 3 ) x0 = 0.015178 - 0.021351 * Tr + 0.007503 * Tr ** 2 x1 = 0.042559 - 0.07675 * Tr + 0.034007 * Tr ** 2 mu = ( x0 + w * x1 ) / x return unidades . Viscosity ( mu , <str> )  @ refDoc ( __doi__ , [ 45 , 1 ] ) def MuL_PrzedzieckiSridhar ( T , Tc , Pc , Vc , w , M , Tf , Vr = None , Tv = None ) :      <str> if Vr is None :          Vr = Vc Tv = Tc  Pc = Pc / 101325 Vc = Vc * M * 1000 Vr = Vr * M * 1000 def f ( Tr ) :          G = 0.29607 - 0.09045 * Tr - 0.04842 * Tr ** 2 Vr = .33593 - .33953 * Tr + 1.51941 * Tr ** 2 - 2.02512 * Tr ** 3 + 1.11422 * Tr ** 4 f2 = Vr * ( 1 - w * G ) return f2  f2 = f ( T / Tc ) f2R = f ( Tv / Tc ) f2m = f ( Tf / Tc ) V = f2 / f2R * Vr Vm = f2m / f2R * Vr Vo = 0.0085 * Tc * w - 2.02 + Vm / ( 0.342 * Tf / Tc + 0.894 ) f1 = 4.27 + 0.032 * M - 0.077 * Pc + 0.014 * Tf - 3.82 * Tf / Tc B = 0.33 * Vc / f1 - 1.12 mu = Vo / B / ( V - Vo ) return unidades . Viscosity ( mu , <str> )  @ refDoc ( __doi__ , [ 46 , 1 ] ) def MuL_Lucas ( T , P , Tc , Pc , w , Ps , mus ) :      <str> Tr = T / Tc if P < Ps :          dPr = 0  else :          dPr = P / Pc - Ps / Pc  f1 = 0.9990614 - 4.6739e-4 / ( 1.052278 * Tr ** - 0.03876963 - 1.05134195 ) f2 = - 0.20863153 + 0.32569953 / ( 1.00383978 - Tr ** 2.57327058 ) ** 0.29063299 Fs = w * ( - 0.079206 + 2.161577 * Tr - 13.403985 * Tr ** 2 + 44.170595 * Tr ** 3 - 84.829114 * Tr ** 4 + 96.120856 * Tr ** 5 - 59.812675 * Tr ** 6 + 15.671878 * Tr ** 7 ) Fpr = 1 + f2 * ( dPr / 2.11824066 ) ** f1 Fp = Fpr / ( 1 + Fs * dPr ) mu = mus * Fp return unidades . Viscosity ( mu )  @ refDoc ( __doi__ , [ 5 ] ) def MuL_API ( T , P , Tc , Pc , w , muc ) :      Tr = T / Tc Pr = P / Pc A1 = 3.0294 * Tr ** 9.0740 + 0.0032 * Tr ** 10.9399 - 0.3689 A2 = - 0.038 * Tr ** - 7.2309 + 0.0229 * Tr ** 11.7631 + 0.5781 A3 = - 0.1415 * Tr ** 27.2842 + 0.0778 * Tr ** - 4.3406 + 0.0014 A4 = 0.0028 * Tr ** 69.4404 - 0.0042 * Tr ** 3.3586 + 0.0062 A5 = 0.0107 * Tr ** - 7.4626 - 85.8276 * Tr ** 0.1392 + 87.3164 mur0 = A1 * log10 ( Pr ) + A2 * log10 ( Pr ) ** 2 + A3 * Pr + A4 * Pr ** 2 + A5 if Pr <= 0.75 :          B1 = - 0.2462 * Tr ** 0.0484 - 0.7275 * log ( Tr ) - 0.0588 * Tr + 0.0079 B2 = - 0.3199 * Tr ** 17.0626 - 0.0695 * log ( Tr ) + 0.1267 * Tr - 0.0101 B3 = 4.7217 * Tr ** - 1.9831 + 19.2008 * Tr ** - 1.7595 + 65.5728 * log ( Tr ) + 0.6110 * Tr - 19.1590  else :          B1 = - 0.0214 * Tr ** 0.0484 - 0.1827 * log ( Tr ) - 0.0183 * Tr + 0.0090 B2 = - 0.3588 * Tr ** 5.0537 - 0.1321 * log ( Tr ) + 0.0204 * Tr - 0.0075 B3 = 3.7266 * Tr ** - 2.5689 + 52.1358 * Tr ** 0.3514 - 13.0750 * log ( Tr ) + 0.6358 * Tr - 56.6687  mur1 = B1 * Pr + B2 * log ( Pr ) + B3 mur = mur0 + w * mur1 return unidades . Viscosity ( mur * muc )  @ refDoc ( __doi__ , [ 5 ] ) def MuL_Kouzel ( T , P , muo ) :      psig = unidades . Pressure ( P ) . psig muocp = unidades . Viscosity ( muo ) . cP mu = muocp * 10 ** ( psig / 1000 * ( - 0.0102 + 0.04042 * muocp ** 0.181 ) ) return unidades . Viscosity ( mu , <str> )  @ refDoc ( __doi__ , [ 1 ] ) def MuG_ChapmanEnskog ( T , M , sigma , omega ) :      <str> mu = 26.69 * M ** 0.5 * T ** 0.5 / sigma ** 2 / omega return unidades . Viscosity ( mu , <str> )  @ refDoc ( __doi__ , [ 24 , 5 ] ) def MuG_StielThodos ( T , Tc , Pc , M ) :      <str> Pc_atm = Pc / 101325 Tr = T / Tc T_R = unidades . K2R ( T ) if M < 2 :          if Tr <= 1.5 :              mu = 3.7e-5 * T_R ** 0.94  else :              mu = 9.071e-4 * ( 7.639e-2 * T_R - 1.67 ) ** 0.625   else :          if Tr <= 1.5 :              N = 3.5e-4 * Tr ** 0.94  else :              N = 1.778e-4 * ( 4.58 * Tr - 1.67 ) ** 0.625  x = Tc ** ( 1 / 6 ) / M ** 0.5 / Pc_atm ** ( 2 / 3 ) mu = N / x  return unidades . Viscosity ( mu , <str> )  @ refDoc ( __doi__ , [ 57 ] ) def MuG_Gharagheizi ( T , Tc , Pc , M ) :      <str> Tr = T / Tc mu = 1e-5 * Pc * Tr + ( 0.091 - 0.477 / M ) * T + M * ( 1e-5 * Pc - 8 * M ** 2 / T ** 2 ) * ( 10.7639 / Tc - 4.1929 / T ) return unidades . Viscosity ( mu * 1e-7 )  @ refDoc ( __doi__ , [ 56 ] ) def MuG_YoonThodos ( T , Tc , Pc , M ) :      <str> Pc_atm = Pc / 101325 Tr = T / Tc x = Tc ** ( 1 / 6 ) / M ** 0.5 / Pc_atm ** ( 2 / 3 ) if M == 2.0158 :          mur = 47.65 * Tr ** 0.657 - 20 * exp ( - 0.858 * Tr ) + 19 * exp ( - 3.995 * Tr ) + 1  elif M == 4.0026 :          mur = 52.57 * Tr ** 0.656 - 18.9 * exp ( - 1.144 * Tr ) + 17.9 * exp ( - 5.182 * Tr ) + 1  else :          mur = 46.1 * Tr ** 0.618 - 20.4 * exp ( - 0.449 * Tr ) + 19.4 * exp ( - 4.058 * Tr ) + 1  return unidades . Viscosity ( mur * 1e-5 / x , <str> )  @ refDoc ( __doi__ , [ 49 , 50 , 1 ] ) def MuG_Chung ( T , Tc , Vc , M , w , D , k = 0 ) :      <str> Vc = Vc * M * 1000 T_ = 1.2593 * T / Tc omega = Collision_Neufeld ( T_ ) mur = 131.3 * D / ( Vc * Tc ) ** 0.5 Fc = 1 - 0.2756 * w + 0.059035 * mur ** 4 + k mu = 40.785 * Fc * M ** 0.5 * T ** 0.5 / Vc ** ( 2 / 3 ) / omega return unidades . Viscosity ( mu , <str> )  @ refDoc ( __doi__ , [ 49 , 50 , 1 ] ) def MuG_P_Chung ( T , Tc , Vc , M , w , D , k , rho , muo ) :      <str> Vc = Vc * M * 1000 rho = rho / M / 1000 T_ = 1.2593 * T / Tc mur = 131.3 * D / ( Vc * Tc ) ** 0.5 dat = [ ( 6.32402 , 50.4119 , - 51.6801 , 1189.02 ) , ( 0.12102e-2 , - 0.11536e-2 , - 0.62571e-2 , 0.37283e-1 ) , ( 5.28346 , 254.209 , - 168.481 , 3898.27 ) , ( 6.62263 , 38.09570 , - 8.46414 , 31.4178 ) , ( 19.74540 , 7.63034 , - 14.35440 , 31.5267 ) , ( - 1.89992 , - 12.53670 , 4.98529 , - 18.1507 ) , ( 24.27450 , 3.44945 , - 11.29130 , 69.3466 ) , ( 0.79716 , 1.11764 , 0.12348e-1 , - 4.11661 ) , ( - 0.23816 , 0.67695e-1 , - 0.81630 , 4.02528 ) , ( 0.68629e-1 , 0.34793 , 0.59256 , - 0.72663 ) ] A = [ ] for ao , a1 , a2 , a3 in dat :          A . append ( ao + a1 * w + a2 * mur ** 4 + a3 * k )  A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 , A10 = A Y = rho * Vc / 6 G1 = ( 1 - 0.5 * Y ) / ( 1 - Y ) ** 3 G2 = ( A1 * ( ( 1 - exp ( - A4 * Y ) ) / Y ) + A2 * G1 * exp ( A5 * Y ) + A3 * G1 ) / ( A1 * A4 + A2 + A3 ) muk = 10 * muo * ( 1 / G2 + A6 * Y ) mup = ( 36.344e-6 * ( M * Tc ) ** 0.5 / Vc ** ( 2 / 3 ) ) * A7 * Y ** 2 * G2 * exp ( A8 + A9 / T_ + A10 / T_ ** 2 ) return unidades . Viscosity ( muk + mup , <str> )  @ refDoc ( __doi__ , [ 1 ] ) def MuG_Reichenberg ( T , P , Tc , Pc , Vc , M , D , muo ) :      <str> if D :          Vc = Vc * M / 1000 mu_r = 131.3 * D / ( Vc * Tc ) ** 0.5 Q = 1 - 5.655 * mu_r  else :          Q = 1  Tr = T / Tc Pr = P / Pc A = 1.9824e-3 / Tr * exp ( 5.2683 * Tr ** - 0.5767 ) B = A * ( 1.6552 * Tr - 1.276 ) C = 1.319 / Tr * exp ( 3.7035 * Tr ** - 79.8678 ) D = 2.9496 / Tr * exp ( 2.9190 * Tr ** - 16.6169 ) mur = 1 + Q * A * Pr ** 1.5 / ( B * Pr + 1 / ( 1 + C * Pr ** D ) ) return unidades . Viscosity ( mur * muo )  @ refDoc ( __doi__ , [ 1 ] ) def MuG_Lucas ( T , P , Tc , Pc , Zc , M , D ) :      Tr = T / Tc Pr = P / Pc Pc_bar = Pc * 1e-5 xi = 0.176 * Tc ** ( 1 / 6 ) / M ** 0.5 / Pc_bar ** ( 2 / 3 ) mur = 52.46 * D ** 2 * Pc_bar / Tc ** 2 if mur < 0.022 :          Fpo = 1  elif mur < 0.075 :          Fpo = 1 + 30.55 * ( 0.292 - Zc ) ** 1.72  else :          Fpo = 1 + 30.55 * ( 0.292 - Zc ) ** 1.72 * abs ( 0.96 + 0.1 * ( Tr - 0.7 ) )  if Tr < 12 :          sign = - 1  else :          sign = 1  if M == 2.0158 :          Q = 0.76 Fqo = 1.22 * Q ** 0.15 * ( 1 + 0.00385 * ( ( Tr - 12 ) ** 2 ) ** ( 1 / M ) * sign )  elif M == 4.0026 :          Q = 1.38 Fqo = 1.22 * Q ** 0.15 * ( 1 + 0.00385 * ( ( Tr - 12 ) ** 2 ) ** ( 1 / M ) * sign )  else :          Fqo = 1  Z1 = Fpo * Fqo * ( 0.807 * Tr ** 0.618 - 0.357 * exp ( - 0.449 * Tr ) + 0.34 * exp ( - 4.058 * Tr ) + 0.018 ) if Pr < 0.6 :          mu = Z1 / xi  else :          if Tr <= 1 :              alfa = 3.262 + 14.98 * Pr ** 5.508 beta = 1.39 + 14.98 * Pr Z2 = 0.6 + 0.76 * Pr ** alfa + ( 6.99 * Pr ** beta - 0.6 ) * ( 1 - Tr )  else :              a = 1.245e-3 / Tr * exp ( 5.1726 * Tr ** - 0.3286 ) b = a * ( 1.6553 * Tr - 1.2723 ) c = 0.4489 / Tr * exp ( 3.0578 * Tr ** - 37.7332 ) d = 1.7368 / Tr * exp ( 2.231 * Tr ** - 7.6351 ) e = 1.3088 f = 0.9425 * exp ( - 0.1853 * Tr ** 0.4489 ) Z2 = Z1 * ( 1 + a * Pr ** e / ( b * Pr ** f + 1 / ( 1 + c * Pr ** d ) ) )  Y = Z2 / Z1 Fp = ( 1 + ( Fpo - 1 ) / Y ** 3 ) / Fpo Fq = ( 1 + ( Fqo - 1 ) * ( 1 / Y - 0.007 * log ( Y ) ** 4 ) ) / Fqo mu = Z2 * Fp * Fq / xi  return unidades . Viscosity ( mu , <str> )  @ refDoc ( __doi__ , [ 51 ] ) def MuG_Jossi ( Tc , Pc , rhoc , M , rho , muo ) :      <str> Pc_atm = Pc / 101325 x = Tc ** ( 1 / 6 ) / M ** 0.5 / Pc_atm ** ( 2 / 3 ) rhor = rho / rhoc mur = 0.1023 + 0.023364 * rhor + 0.058533 * rhor ** 2 - 0.040758 * rhor ** 3 + 0.0093324 * rhor ** 4 mu = ( mur ** 4 - 1e-4 ) / x + muo * 1e3 return unidades . Viscosity ( mu , <str> )  @ refDoc ( __doi__ , [ 52 ] ) def MuG_P_StielThodos ( Tc , Pc , rhoc , M , rho , muo ) :      <str> Pc_atm = Pc / 101325 x = Tc ** ( 1 / 6 ) / M ** 0.5 / Pc_atm ** ( 2 / 3 ) rhor = rho / rhoc if rhor <= 0.1 :          mur = 1.656e-5 * rhor ** 1.111  elif 0.1 < rhor <= 0.9 :          mur = 0.607e-5 * ( 9.045 * rhor + 0.63 ) ** 1.739  else :          if rhor < 2.2 :              D = 0  else :              D = 4.75e-4 * ( rhor ** 3 - 10.65 ) ** 2  mur = 10 ** ( 4 - 10 ** ( 0.6439 - 0.1005 * rhor - D ) )  return unidades . Viscosity ( mur / x + muo * 1e7 , <str> )  @ refDoc ( __doi__ , [ 1 , 61 , 53 ] ) def MuG_TRAPP ( T , Tc , Vc , Zc , M , w , rho , muo ) :      TcR = 369.83 rhocR = 1 / 200 ZcR = 0.276 wR = 0.152 Vc = Vc * M * 1000 rho = rho / M / 1000 rhoc = 1 / Vc Tr = T / Tc f = Tc / TcR * ( 1 + ( w - wR ) * ( 0.05203 - 0.7498 * log ( Tr ) ) ) h = rhocR / rhoc * ZcR / Zc * ( 1 - ( w - wR ) * ( 0.1436 - 0.2822 * log ( Tr ) ) ) To = T / f rho0 = rho * h Fn = ( M / 44.094 * f ) ** 0.5 / h ** ( 2 / 3 ) rho0 *= 1000 rhocR *= 1000 G = - 14.113294896 + 968.22940153 / To H = rho0 ** 0.5 * ( rho0 - rhocR ) / rhocR G2 = 13.686545032 - 12511.628378 / To ** 1.5 G3 = 0.0168910864 + 43.527109444 / To + 7659.4543472 / To ** 2 F = G + G2 * rho0 ** 0.1 + G3 * H muR = exp ( F ) - exp ( G ) return unidades . Viscosity ( Fn * muR * 1e-6 + muo )  @ refDoc ( __doi__ , [ 54 ] ) def MuG_Brule ( T , Tc , Vc , M , w , rho , muo ) :      <str> Vc = Vc * M * 1000 rho = rho / M / 1000 T_ = 1.2593 * T / Tc dat = { 0 : ( 1. , - 0.2756 ) , 1 : ( 17.4499 , 34.0631 ) , 2 : ( - 0.961125e-3 , 0.723459e-2 ) , 3 : ( 51.0431 , 169.460 ) , 4 : ( - 0.605917 , 71.1743 ) , 5 : ( 21.3818 , - 2.11014 ) , 6 : ( 4.66798 , - 39.9408 ) , 7 : ( 3.76241 , 56.6234 ) , 8 : ( 1.00377 , 3.13962 ) , 9 : ( - 0.7774233e-1 , - 3.58446 ) , 10 : ( 0.317523 , 1.15995 ) } E = [ ] for i in range ( 1 , 11 ) :          ai , bi = dat [ i ] E . append ( ai + bi * w )  E1 , E2 , E3 , E4 , E5 , E6 , E7 , E8 , E9 , E10 = E Y = rho * Vc / 6 G1 = ( 1 - 0.5 * Y ) / ( 1 - Y ) ** 3 G2 = ( E1 * ( ( 1 - exp ( - E4 * Y ) ) / Y ) + E2 * G1 * exp ( E5 * Y ) + E3 * G1 ) / ( E1 * E4 + E2 + E3 ) muk = muo * ( 1 / G2 + E6 * Y ) mup = ( 36.344e-6 * ( M * Tc ) ** 0.5 / Vc ** ( 2 / 3 ) ) * E7 * Y ** 2 * G2 * exp ( E8 + E9 / T_ + E10 / T_ ** 2 ) return unidades . Viscosity ( muk + mup , <str> )  @ refDoc ( __doi__ , [ 55 , 5 ] ) def MuG_DeanStiel ( Tc , Pc , rhoc , M , rho , muo ) :      <str> Pc_atm = Pc / 101325 x = Tc ** ( 1 / 6 ) / M ** 0.5 / Pc_atm ** ( 2.0 / 3 ) rhor = rho / rhoc mur = 10.8e-5 * ( exp ( 1.439 * rhor ) - exp ( - 1.11 * rhor ** 1.858 ) ) return unidades . Viscosity ( muo * 1e3 + mur / x , <str> )  @ refDoc ( __doi__ , [ 5 ] ) def MuG_API ( T , P , Tc , Pc , muo ) :      <str> Tr = T / Tc Pr = P / Pc A1 = 83.8970 * Tr ** 0.0105 + 0.603 * Tr ** - 0.0822 + 0.9017 * Tr ** - 0.12 - 85.308 A2 = 1.514 * Tr ** - 11.3036 + 0.3018 * Tr ** - 0.6856 + 2.0636 * Tr ** - 2.7611 mur = A1 * 1.5071 * Pr ** - 0.4487 + A2 * ( 11.4789 * Pr ** 0.2606 - 12.6843 * Pr ** 0.1773 + 1.6953 * Pr ** - 0.1052 ) return unidades . Viscosity ( muo * mur )  @ refDoc ( __doi__ , [ 11 ] ) def ThL_RiaziFaghri ( T , Tb , SG ) :      <str> Tb_R = unidades . K2R ( Tb ) t = unidades . K2F ( T ) / 100 A = exp ( - 4.5093 - 0.6844 * t - 0.1305 * t ** 2 ) B = 0.3003 + 0.0918 * t + 0.0195 * t ** 2 C = 0.1029 + 0.0894 * t + 0.0292 * t ** 2 k = A * Tb_R ** B * SG ** C return unidades . ThermalConductivity ( k , <str> )  @ refDoc ( __doi__ , [ 12 ] ) def ThL_Gharagheizi ( T , Pc , Tb , M , w ) :      <str> Pc_bar = Pc * 1e-5 B = 16.0407 * M + 2 * Tb - 27.9074 A = 3.8588 * M ** 8 * ( 1.0045 * B + 6.5152 * M - 8.9756 ) k = 1e-4 * ( 10 * w + 2 * Pc_bar - 2 * T + 4 + 1.908 * ( Tb + 1.009 * B ** 2 / M ** 2 ) + 3.9287 * M ** 4 / B ** 4 + A / B ** 8 ) return unidades . ThermalConductivity ( k )  @ refDoc ( __doi__ , [ 13 ] ) def ThL_LakshmiPrasad ( T , M ) :      <str> k = 0.0655 + ( 1.3855 - 0.00197 * T ) / M ** 0.5 - 0.00005 * T return unidades . ThermalConductivity ( k )  @ refDoc ( __doi__ , [ 14 ] ) def ThL_Nicola ( T , M , Tc , Pc , w , mu = None ) :      <str> Pc_bar = unidades . Pressure ( Pc ) . bar if mu :          k = 0.6542 * ( - 0.2034 * T / Tc + 0.0013 * Pc_bar + 0.1714 * w + ( 1 / M ) ** 0.3539 - 0.007 * mu )  else :          k = 0.5147 * ( - 0.2537 * T / Tc + 0.0017 * Pc_bar + 0.1501 * w + ( 1 / M ) ** - 0.2999 )  return unidades . ThermalConductivity ( k )  @ refDoc ( __doi__ , [ 1 ] ) def ThL_SatoRiedel ( T , Tc , M , Tb ) :      <str> Tr = T / Tc Tbr = Tb / Tc k = 1.1053152 / M ** 0.5 * ( 3 + 20 * ( 1 - Tr ) ** ( 2 / 3 ) ) / ( 3 + 20 * ( 1 - Tbr ) ** ( 2 / 3 ) ) return unidades . ThermalConductivity ( k )  @ refDoc ( __doi__ , [ 15 , 5 ] ) def ThL_Pachaiyappan ( T , Tc , M , rho , branched = True ) :      <str> if branched :          n = 0.7717 C = 4.079e-3  else :          n = 1.001 C = 1.676e-3  Tr = T / Tc Tc_R = unidades . K2R ( Tc ) rhom = unidades . Density ( rho / M ) . lbft3 Vm = 1 / rhom k = C * M ** n / Vm * ( 3 + 20 * ( 1 - Tr ) ** ( 2. / 3 ) ) / ( 3 + 20 * ( 1 - 527.67 / Tc_R ) ** ( 2. / 3 ) ) return unidades . ThermalConductivity ( k , <str> )  @ refDoc ( __doi__ , [ 16 , 5 ] ) def ThL_KanitkarThodos ( T , P , Tc , Pc , Vc , M , rho ) :      <str> Pc_atm = Pc / 101325 Tc_R = unidades . K2R ( Tc ) Pr = P / Pc rhor = rho * Vc l = Tc_R ** ( 1 / 6 ) * M ** 0.5 / Pc_atm ** ( 2 / 3 ) b = 0.4 + 0.986 / exp ( 0.58 * l ) alfa = 7.137e-3 / b ** 3.322 k = ( - 1.884e-6 * Pr ** 2 + 1.442e-3 * Pr + alfa * exp ( b * rhor ) ) / l return unidades . ThermalConductivity ( k , <str> )  @ refDoc ( __doi__ , [ 59 , 1 , 5 ] ) def ThL_Lenoir ( T , P , Tc , Pc , ko , To = None , Po = None ) :      <str> if To is None :          To = T  if Po is None :          Po = 101325  Tr2 = T / Tc Pr2 = P / Pc Tr1 = To / Tc Pr1 = Po / Pc Pmin = unidades . Pressure ( 500 , <str> ) if Tr2 < 0.4 or Tr2 > 0.8 or P < Pmin :          raise NotImplementedError ( <str> )  C1 = 17.77 + 0.065 * Pr1 - 7.764 * Tr1 - 2.054 * Tr1 ** 2 / exp ( 0.2 * Pr1 ) C2 = 17.77 + 0.065 * Pr2 - 7.764 * Tr2 - 2.054 * Tr2 ** 2 / exp ( 0.2 * Pr2 ) return unidades . ThermalConductivity ( ko * C2 / C1 )  @ refDoc ( __doi__ , [ 1 ] ) def ThL_Missenard ( T , P , Tc , Pc , ko ) :      <str> Tr = T / Tc Pr = P / Pc if Tr < 0.5 or Tr > 0.8 or Pr < 1 or Pr > 200 :          raise NotImplementedError ( <str> )  Tri = [ 0.8 , 0.7 , 0.6 , 0.5 ] Pri = [ 1 , 5 , 10 , 50 , 100 , 200 ] Qi = array ( [ [ 0.036 , 0.038 , 0.038 , 0.038 , 0.038 , 0.038 ] , [ 0.018 , 0.025 , 0.027 , 0.031 , 0.032 , 0.032 ] , [ 0.015 , 0.020 , 0.022 , 0.024 , 0.025 , 0.025 ] , [ 0.012 , 0.0165 , 0.017 , 0.019 , 0.020 , 0.020 ] ] ) f_Q = interp2d ( Pri , Tri , Qi ) Q = f_Q ( Pr , Tr ) k = ko * ( 1 + Q * Pr ** 0.7 ) return unidades . ThermalConductivity ( k )  @ refDoc ( __doi__ , [ 25 , 5 ] ) def ThG_MisicThodos ( T , Tc , Pc , M , Cp ) :      <str> Pc_atm = Pc / 101325 Tr = T / Tc cp = unidades . MolarSpecificHeat ( Cp * M ) . calmolK l = Tc ** ( 1 / 6 ) * M ** 0.5 / Pc_atm ** ( 2 / 3 ) if Tr < 1 :          k = 0.445e-5 * Tr * cp / l  else :          k = 1e-6 * ( 14.52 * Tr - 5.14 ) ** ( 2 / 3 ) * cp / l  return unidades . ThermalConductivity ( k , <str> )  @ refDoc ( __doi__ , [ 11 ] ) def ThG_RiaziFaghri ( T , Tb , SG ) :      <str> Tb_R = unidades . K2R ( Tb ) t = unidades . K2F ( T ) / 100 A = exp ( 21.78 - 8.07986 * t + 1.12981 * t ** 2 - 0.05309 * t ** 3 ) B = - 4.13948 + 1.29924 * t - 0.17813 * t ** 2 + 0.00833 * t ** 3 C = 0.19876 - 0.0313 * t - 0.00567 * t ** 2 k = A * Tb_R ** B * SG ** C return unidades . ThermalConductivity ( k , <str> )  @ refDoc ( __doi__ , [ 1 ] ) def ThG_Eucken ( M , Cv , mu ) :      <str> Cvm = Cv * M / 1000 M = M / 1000. k = ( 1 + 9 / 4 / ( Cvm / R ) ) * mu * Cvm / M return unidades . ThermalConductivity ( k )  @ refDoc ( __doi__ , [ 1 ] ) def ThG_EuckenMod ( M , Cv , mu ) :      <str> Cvm = Cv * M / 1000 M = M / 1000. k = ( 1.32 + 1.77 / ( Cvm / R ) ) * mu * Cvm / M return unidades . ThermalConductivity ( k )  @ refDoc ( __doi__ , [ 49 , 1 ] ) def ThG_Chung ( T , Tc , M , w , Cv , mu ) :      <str> Tr = T / Tc Cvm = Cv * M / 1000 alpha = Cvm / R - 1.5 beta = 0.7862 - 0.7109 * w + 1.3168 * w ** 2 Z = 2 + 10.5 * Tr ** 2 phi = 1 + alpha * ( ( 0.215 + 0.28288 * alpha - 1.061 * beta + 0.26665 * Z ) / ( 0.6366 + beta * Z + 1.061 * alpha * beta ) ) k = 7.452 * mu * 10 / M * phi return unidades . ThermalConductivity ( k , <str> )  @ refDoc ( __doi__ , [ 5 ] ) def ThG_NonHydrocarbon ( T , P , id ) :      <str> dat = { 1 : ( 4.681e-3 , 2.e-4 , - 3.6e-8 , 0.0 , 0.0 , 0.0 , 1.7e-3 ) , 46 : ( 4.561e-3 , 1.61e-5 , 0.0 , 2.56e-9 , 5.299e-3 , 2.47e-3 , 0.0 ) , 47 : ( 5.95e-4 , 1.71e-5 , 0.0 , - 2.10e-8 , 5.869e-3 , 6.995e-3 , 0.0 ) , 48 : ( 1.757e-3 , 1.55e-5 , 0.0 , 2.08e-8 , 5.751e-3 , 5.6e-3 , 0.0 ) , 50 : ( - 1.51e-3 , 2.25e-5 , 3.32e-10 , 0.0 , 0.0 , 0.0 , 0.0 ) , 51 : ( 2.5826e-2 , 1.35e-5 , 0.0 , - 4.4e-7 , 1.026e-2 , - 2.631e-2 , 0.0 ) , 111 : ( - 1.02e-3 , 1.35e-5 , 4.17e-9 , 0.0 , 0.0 , 0.0 , 0.0 ) } if id not in dat :          raise NotImplementedError ( <str> )  t = unidades . K2R ( T ) p = unidades . Pressure ( P ) . psi if id == 1 :          tmin = 260 tmax = 2260 pmin = 15 pmax = 10000  elif id in ( 46 , 47 ) :          tmin = 460 tmax = 2460 pmin = 15 pmax = 10000  elif id == 48 :          tmin = 460 tmax = 2460 pmin = 15 pmax = 15000  elif id == 50 :          tmin = 960 tmax = 2460 pmin = 15 pmax = 10000  elif id in ( 51 , 111 ) :          tmin = 460 tmax = 2460 pmin = 1 pmax = 100  if t < tmin or t > tmax or p < pmin or p > pmax :          raise NotImplementedError ( <str> )  A , B , C , D , E , F , G = dat [ id ] k = A + B * t + C * t ** 2 + D * p + E * p / t ** 1.2 + F / ( .4 * p - .001 * t ) ** .015 + G * log ( p ) return unidades . ThermalConductivity ( k , <str> )  @ refDoc ( __doi__ , [ 58 , 1 ] ) def ThG_StielThodos ( T , Tc , Pc , Vc , M , V , ko ) :      Zc = Pc * 1e-3 * Vc * M / Tc / R ko = unidades . ThermalConductivity ( ko ) . calscmK rhor = Vc / V gamma = ( Tc * M ** 3 / ( Pc / 101325 ) ** 4 ) ** ( 1 / 6 ) if rhor < 0.5 :          lr = 14 * ( exp ( 0.535 * rhor ) - 1 )  elif rhor < 2 :          lr = 13.1 * ( exp ( 0.67 * rhor ) - 1.069 )  else :          lr = 2.976 * ( exp ( 1.155 * rhor ) + 2.016 )  k = ko + lr * 1e-8 / Zc ** 5 / gamma return unidades . ThermalConductivity ( k , <str> )  @ refDoc ( __doi__ , [ 49 , 1 ] ) def ThG_P_Chung ( T , Tc , Vc , M , w , D , k , rho , ko ) :      <str> Vc = Vc * M * 1000 rho = rho / M / 1000 ko = unidades . ThermalConductivity ( ko ) . calscmK Tr = T / Tc mur = 131.3 * D / ( Vc * Tc ) ** 0.5 dat = [ ( 2.41657 , 0.74824 , - 0.91858 , 121.72100 ) , ( - 0.50924 , - 1.50936 , - 49.99120 , 69.98340 ) , ( 6.61069 , 5.62073 , 64.75990 , 27.03890 ) , ( 14.54250 , - 8.91387 , - 5.63794 , 74.34350 ) , ( 0.79274 , 0.82019 , - 0.69369 , 6.31734 ) , ( - 5.86340 , 12.80050 , 9.58926 , - 65.52920 ) , ( 81.17100 , 114.15800 , - 60.84100 , 466.77500 ) ] B = [ ] for bo , b1 , b2 , b3 in dat :          B . append ( bo + b1 * w + b2 * mur ** 4 + b3 * k )  B1 , B2 , B3 , B4 , B5 , B6 , B7 = B Y = rho * Vc / 6 G1 = ( 1 - 0.5 * Y ) / ( 1 - Y ) ** 3 H2 = ( B1 * ( ( 1 - exp ( - B4 * Y ) ) / Y ) + B2 * G1 * exp ( B5 * Y ) + B3 * G1 ) / ( B1 * B4 + B2 + B3 ) kk = ko * ( 1 / H2 + B6 * Y ) kp = ( 3.039e-4 * ( Tc / M ) ** 0.5 / Vc ** ( 2 / 3 ) ) * B7 * Y ** 2 * H2 * Tr ** 0.5 return unidades . ThermalConductivity ( kk + kp , <str> )  @ refDoc ( __doi__ , [ 61 , 1 ] ) def ThG_TRAPP ( T , Tc , Vc , Zc , M , w , rho , ko ) :      TcR = 369.83 rhocR = 1 / 200 ZcR = 0.276 wR = 0.152 Vc = Vc * M * 1000 rho = rho / M / 1000 rhoc = 1 / Vc Tr = T / Tc f = Tc / TcR * ( 1 + ( w - wR ) * ( 0.05203 - 0.7498 * log ( Tr ) ) ) h = rhocR / rhoc * ZcR / Zc * ( 1 - ( w - wR ) * ( 0.1436 - 0.2822 * log ( Tr ) ) ) To = T / f rho0 = rho * h Fl = ( 44.094 / M * f ) ** 0.5 / h ** ( 2 / 3 ) Xl = ( 1 + 2.1866 * ( w - wR ) / ( 1 - 0.505 * ( w - wR ) ) ) ** 0.5 rho0 *= 1000 rhocR *= 1000 rhorR = rho0 / rhocR TrR = To / TcR lR = 15.2583985944 * rhorR + 5.29917319127 * rhorR ** 3 + ( - 3.05330414748 + 0.450477583739 / TrR ) * rhorR ** 4 + ( 1.03144050679 - 0.185480417707 / TrR ) * rhorR ** 5 return unidades . ThermalConductivity ( Fl * Xl * lR * 1e-3 + ko )  def Tension_Parametric ( T , args , Tc ) :      <str> A , B = args Tr = T / Tc sigma = A * ( 1 - Tr ) ** B return unidades . Tension ( sigma )  @ refDoc ( __doi__ , [ 39 , 40 , 1 ] ) def Tension_BlockBird ( T , Tc , Pc , Tb ) :      <str> Tr = T / Tc Trb = Tb / Tc Pc_atm = Pc / 101325 Pc_bar = Pc * 1e-5 alfa = 0.9076 * ( 1 + Trb * log ( Pc_atm ) / ( 1 - Trb ) ) sr = ( 0.132 * alfa - 0.279 ) * ( 1 - Tr ) ** ( 11 / 9 ) sigma = sr * Pc_bar ** ( 2 / 3 ) * Tc ** ( 1 / 3 ) return unidades . Tension ( sigma , <str> )  @ refDoc ( __doi__ , [ 1 ] ) def Tension_Pitzer ( T , Tc , Pc , w ) :      <str> Tr = T / Tc Pc_bar = Pc * 1e-5 sigma = Pc_bar ** ( 2 / 3 ) * Tc ** ( 1 / 3 ) * ( 1.86 + 1.18 * w ) / 19.05 * ( ( 3.75 + 0.91 * w ) / ( 0.291 - 0.08 * w ) ) ** ( 2 / 3 ) * ( 1 - Tr ) ** ( 11 / 9 ) return unidades . Tension ( sigma , <str> )  @ refDoc ( __doi__ , [ 41 ] ) def Tension_ZuoStenby ( T , Tc , Pc , w ) :      <str> from lib . mEoS import CH4 , nC8 Tr = T / Tc Pc_bar = Pc * 1e-5 s1 = 40.520 * ( 1 - Tr ) ** 1.287 s2 = 52.095 * ( 1 - Tr ) ** 1.21548 sr1 = log ( s1 / ( CH4 . Tc ** ( 1 / 3 ) * CH4 . Pc . bar ** ( 2 / 3 ) ) + 1 ) sr2 = log ( s2 / ( nC8 . Tc ** ( 1 / 3 ) * nC8 . Pc . bar ** ( 2 / 3 ) ) + 1 ) sr = sr1 + ( w - CH4 . f_acent ) / ( nC8 . f_acent - CH4 . f_acent ) * ( sr2 - sr1 ) sigma = Tc ** ( 1 / 3 ) * Pc_bar ** ( 2 / 3 ) * ( exp ( sr ) - 1 ) return unidades . Tension ( sigma , <str> )  @ refDoc ( __doi__ , [ 42 ] ) def Tension_SastriRao ( T , Tc , Pc , Tb , alcohol = False , acid = False ) :      <str> if alcohol :          K , x , y , z , m = 2.28 , 0.175 , 0.25 , 0 , 0.8  elif acid :          K , x , y , z , m = 0.125 , 0.35 , 0.5 , - 1.85 , 11 / 9  else :          K , x , y , z , m = 0.158 , 0.35 , 0.5 , - 1.85 , 11 / 9  Tbr = Tb / Tc Pc_bar = Pc * 1e-5 sigma = K * Tb ** x * Pc_bar ** y * Tbr ** z * ( ( Tc - T ) / ( Tc - Tb ) ) ** m return unidades . Tension ( sigma , <str> )  @ refDoc ( __doi__ , [ 43 , 42 ] ) def Tension_Hakim ( T , Tc , Pc , w , X ) :      <str> Tr = T / Tc Pc_atm = Pc / 101325 sr06 = 0.1574 + 0.359 * w - 1.769 * X - 13.69 * X ** 2 - 0.510 * w ** 2 + 1.298 * X * w m = 1.210 + 0.5385 * w - 14.61 * X - 32.07 * X ** 2 - 1.656 * w ** 2 + 22.03 * X * w sigma = Pc_atm ** ( 2 / 3 ) * Tc ** ( 1 / 3 ) * sr06 * ( ( 1 - Tr ) / 0.4 ) ** m return unidades . Tension ( sigma , <str> )  @ refDoc ( __doi__ , [ 44 ] ) def Tension_Miqueu ( T , Tc , Vc , M , w ) :      <str> t = 1 - T / Tc sigma = Boltzmann * Tc * ( Avogadro / Vc / 1000 / M ) ** ( 2 / 3 ) * ( 4.35 + 4.14 * w ) * t ** 1.26 * ( 1 + 0.19 * t ** 0.5 - 0.25 * t ) return unidades . Tension ( sigma , <str> )  @ refDoc ( __doi__ , [ 4 ] ) def facent_LeeKesler ( Tb , Tc , Pc ) :      <str> Tr = Tb / Tc Pr = 101325 / Pc w = ( log ( Pr ) - 5.92714 + 6.09648 / Tr + 1.28862 * log ( Tr ) - 0.169347 * Tr ** 6 ) / ( 15.2518 - 15.6875 / Tr - 13.4721 * log ( Tr ) + 0.43577 * Tr ** 6 ) return unidades . Dimensionless ( w )  @ refDoc ( __doi__ , [ 19 ] ) def prop_Edmister ( ** kwargs ) :      count_available = 0 if <str> in kwargs and kwargs [ <str> ] :          count_available += 1 Tc = unidades . Temperature ( kwargs [ <str> ] )  else :          unknown = <str>  if <str> in kwargs and kwargs [ <str> ] :          count_available += 1 Pc = unidades . Pressure ( kwargs [ <str> ] )  else :          unknown = <str>  if <str> in kwargs and kwargs [ <str> ] :          count_available += 1 Tb = unidades . Temperature ( kwargs [ <str> ] )  else :          unknown = <str>  if <str> in kwargs :          count_available += 1 w = unidades . Dimensionless ( kwargs [ <str> ] )  else :          unknown = <str>  if count_available != 3 :          raise ValueError ( <str> )  if unknown == <str> :          Tc = unidades . Temperature ( Tb . R * ( 3 * log10 ( Pc . psi ) / 7 / ( w + 1 ) + 1 ) , <str> )  elif unknown == <str> :          Pc = unidades . Pressure ( 10 ** ( 7 / 3. * ( w + 1 ) * ( Tc . R / Tb . R - 1 ) ) , <str> )  elif unknown == <str> :          Tb = unidades . Temperature ( Tb . R / ( 3 * log10 ( Pc . atm ) / 7 / ( w + 1 ) + 1 ) , <str> )  elif unknown == <str> :          w = unidades . Dimensionless ( 3 / 7 * log10 ( Pc . atm ) / ( Tc . R / Tb . R - 1 ) - 1 )  prop = { } prop [ <str> ] = Tc prop [ <str> ] = Pc prop [ <str> ] = Tb prop [ <str> ] = w return prop  @ refDoc ( __doi__ , [ 8 , 1 ] ) def facent_AmbroseWalton ( Pvr ) :      Tr = 0.7 t = 1 - Tr f0 = ( - 5.97616 * t + 1.29874 * t ** 1.5 - 0.60394 * t ** 2.5 - 1.06841 * t ** 5 ) / Tr f1 = ( - 5.03365 * t + 1.11505 * t ** 1.5 - 5.41217 * t ** 2.5 - 7.46628 * t ** 5 ) / Tr f2 = ( - 0.64771 * t + 2.41539 * t ** 1.5 - 4.26979 * t ** 2.5 + 3.25259 * t ** 5 ) / Tr coef = roots ( [ f2 , f1 , f0 - log ( Pvr ) ] ) if absolute ( coef [ 0 ] ) < absolute ( coef [ 1 ] ) :          return coef [ 0 ]  else :          return coef [ 1 ]   @ refDoc ( __doi__ , [ 17 , 18 , 5 ] ) def Vc_Riedel ( Tc , Pc , w , M ) :      alfa = 5.811 + 4.919 * w Vc = R * 1000 * Tc / Pc / ( 3.72 + 0.26 * ( alfa - 7 ) ) / M return unidades . SpecificVolume ( Vc , <str> )  @ refDoc ( __doi__ , [ 23 ] ) def Rackett ( w ) :      Zra = 0.29056 - 0.08775 * w return Zra  @ refDoc ( __doi__ , [ 60 , 5 ] ) def Henry ( T , args ) :      <str> T_R = unidades . K2R ( T ) B1 , B2 , B3 , B4 = args H = exp ( B1 / T_R + B2 * log ( T_R ) + B3 * T_R + B4 ) return unidades . Pressure ( H , <str> )  class Componente ( object ) :      _bool = False kwargs = { <str> : None , <str> : None , <str> : None , <str> : None , <str> : None , <str> : None , <str> : None , <str> : None , <str> : None , <str> : None , <str> : None , <str> : None , <str> : None } METHODS_RhoL = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] METHODS_RhoLP = [ <str> , <str> , <str> , <str> , <str> , <str> ] METHODS_MuL = [ <str> , <str> , <str> , <str> ] METHODS_MuLP = [ <str> , <str> , <str> ] METHODS_MuG = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> ] METHODS_MuGP = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] METHODS_ThG = [ <str> , <str> , <str> , <str> , <str> , <str> ] METHODS_ThGP = [ <str> , <str> , <str> ] METHODS_ThL = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] METHODS_ThLP = [ <str> , <str> , <str> ] METHODS_Pv = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] METHODS_facent = [ <str> , <str> , <str> ] METHODS_Tension = [ <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ] def __init__ ( self , id = None , ** kwargs ) :          if not id :              return  self . _bool = True self . id = id self . kwargs = Componente . kwargs . copy ( ) self . kwargs . update ( kwargs ) self . Config = config . getMainWindowConfig ( ) cmp = sql . getElement ( id ) self . formula = cmp [ 1 ] self . name = cmp [ 2 ] self . M = cmp [ 3 ] self . SG = cmp [ 124 ] self . Tc = unidades . Temperature ( cmp [ 4 ] ) self . Pc = unidades . Pressure ( cmp [ 5 ] , <str> ) self . Tb = unidades . Temperature ( cmp [ 131 ] ) self . Tf = unidades . Temperature ( cmp [ 132 ] ) if cmp [ 125 ] != 0 :              self . f_acent = cmp [ 125 ]  elif self . Pc and self . Tc and self . Tb :              self . f_acent = self . _f_acent ( )  else :              self . f_acent = 0  if cmp [ 6 ] != 0 :              self . Vc = unidades . SpecificVolume ( cmp [ 6 ] / self . M )  elif self . f_acent != 0 and self . Tc != 0 and self . Pc != 0 :              self . Vc = Vc_Riedel ( self . Tc , self . Pc , self . f_acent , self . M )  else :              self . Vc = 0  self . rhoc = 1 / self . Vc self . Zc = self . Pc * self . Vc * self . M / 1000 / R / self . Tc if cmp [ 7 ] != 0 :              self . API = cmp [ 7 ]  elif cmp [ 124 ] != 0 :              self . API = 141.5 / cmp [ 124 ] - 131.5  else :              self . API = 0  self . cp = cmp [ 8 : 14 ] self . antoine = cmp [ 14 : 17 ] self . antoine += cmp [ 152 : 156 ] self . wagner = cmp [ 156 : 160 ] self . _parametricMu = cmp [ 21 : 23 ] self . _parametricSigma = cmp [ 23 : 25 ] self . henry = cmp [ 17 : 21 ] self . _dipprRhoS = cmp [ 25 : 33 ] self . _dipprRhoL = cmp [ 33 : 41 ] self . _dipprPv = cmp [ 41 : 49 ] self . _dipprHv = cmp [ 49 : 57 ] self . _dipprCpS = cmp [ 57 : 65 ] self . _dipprCpL = cmp [ 65 : 73 ] self . _dipprCpG = cmp [ 73 : 81 ] self . _dipprMuL = cmp [ 81 : 89 ] self . _dipprMuG = cmp [ 89 : 97 ] self . _dipprKL = cmp [ 97 : 105 ] self . _dipprKG = cmp [ 105 : 113 ] self . _dipprSigma = cmp [ 113 : 121 ] self . dipole = unidades . DipoleMoment ( cmp [ 121 ] ) if cmp [ 123 ] != 0.0 :              self . rackett = cmp [ 123 ]  else :              self . rackett = Rackett ( self . f_acent )  self . Vliq = cmp [ 122 ] self . SolubilityParameter = unidades . SolubilityParameter ( cmp [ 126 ] ) self . Kw = cmp [ 127 ] self . MSRK = cmp [ 128 : 130 ] self . stiel = cmp [ 130 ] self . CASNumber = cmp [ 133 ] self . alternateFormula = cmp [ 134 ] self . UNIFAC = eval ( cmp [ 135 ] ) self . Dm = cmp [ 136 ] self . ek = cmp [ 137 ] self . UNIQUAC_area = cmp [ 138 ] self . UNIQUAC_volumen = cmp [ 139 ] if cmp [ 140 ] == 0.0 :              self . f_acent_mod = cmp [ 125 ]  else :              self . f_acent_mod = cmp [ 140 ]  self . Hf = unidades . Enthalpy ( cmp [ 141 ] / self . M ) self . Gf = unidades . Enthalpy ( cmp [ 142 ] / self . M ) self . wilson = cmp [ 143 ] self . NetHeating = unidades . Enthalpy ( cmp [ 144 ] / self . M ) self . GrossHeating = unidades . Enthalpy ( cmp [ 145 ] / self . M ) self . Synonyms = cmp [ 146 ] self . V_char = cmp [ 147 ] self . calor_formacion_solido = cmp [ 148 ] self . energia_formacion_solido = cmp [ 149 ] self . PolarParameter = cmp [ 150 ] self . smile = cmp [ 151 ] if self . smile and os . environ [ <str> ] == <str> :              from pybel import readstring mol = readstring ( <str> , self . smile ) self . imageFile = tempfile . NamedTemporaryFile ( <str> , suffix = <str> ) Pref = config . Preferences opt = { } opt [ <str> ] = Pref . get ( <str> , <str> ) alpha = Pref . getfloat ( <str> , <str> ) if alpha :                  opt [ <str> ] = Pref . get ( <str> , <str> )  else :                  opt [ <str> ] = <str>  if not Pref . getboolean ( <str> , <str> ) :                  opt [ <str> ] = None  if Pref . getboolean ( <str> , <str> ) :                  opt [ <str> ] = None  elif Pref . getboolean ( <str> , <str> ) :                  opt [ <str> ] = None  if Pref . getboolean ( <str> , <str> ) :                  opt [ <str> ] = None  mol . write ( <str> , filename = self . imageFile . name , overwrite = True , opt = opt )  decmp = atomic_decomposition ( self . formula ) atoms = sum ( [ val for val in decmp . values ( ) ] ) self . C = decmp . get ( <str> , 0 ) self . H = decmp . get ( <str> , 0 ) self . O = decmp . get ( <str> , 0 ) self . N = decmp . get ( <str> , 0 ) self . S = decmp . get ( <str> , 0 ) if self . C and self . H :              self . HC = self . H / self . C  if self . C + self . H == atoms :              self . isHydrocarbon = True  else :              self . isHydrocarbon = False  if self . O >= 1 and self . name [ : - 2 ] == <str> :              self . isAlcohol = True  else :              self . isAlcohol = False  if self . O >= 2 and self . name [ : - 4 ] . lower ( ) == <str> :              self . isAcid = True  else :              self . isAcid = False  lineal = [ 1 , 2 , 3 , 4 , 6 , 8 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 90 , 91 , 92 , 1763 , 1765 , 1767 , 1738 , 1769 , 1770 , 1844 , 1741 , 1842 , 1771 , 1742 , 22 , 23 , 24 , 25 , 26 , 28 , 29 , 30 , 31 , 35 , 56 , 57 , 58 ] if self . id in lineal :              self . branched = False  else :              self . branched = True   def __bool__ ( self ) :          return self . _bool  def _f_acent ( self ) :          method = self . kwargs [ <str> ] if method is None or method >= len ( Componente . METHODS_facent ) :              method = self . Config . getint ( <str> , <str> )  if method == 0 :              return facent_LeeKesler ( self . Tb , self . Tc , self . Pc )  elif method == 1 :              return prop_Edmister ( Tb = self . Tb , Tc = self . Tc , Pc = self . Pc )  elif method == 2 :              Pvr = self . Pv ( 0.7 * self . Tc ) / self . Pc return facent_AmbroseWalton ( Pvr )   @ refDoc ( __doi__ , [ 47 ] , tab = 8 ) def _MuCritical ( self ) :          if 1 < self . id <= 21 and self . id != 7 :              muc = [ 0 , 0 , 0.014 , 0.02 , 0.0237 , 0.027 , 0.0245 , 0 , 0.0255 , 0.0350 , 0.0264 , 0.0273 , 0.0282 , 0.0291 , 0.0305 , 0.0309 , 0.0315 , 0.0328 , 0.0337 , 0.0348 , 0.0355 , 0.0362 ] [ self . id ]  elif id == 90 :              muc = 0.0370  elif id == 91 :              muc = 0.0375  elif id == 92 :              muc = 0.0388  else :              xi = self . Tc ** ( 1 / 6 ) / self . M ** 0.5 / self . Pc . atm ** ( 2 / 3 ) muc = 7.7e-4 / xi  return unidades . Viscosity ( muc , <str> )  @ refDoc ( __doi__ , [ 5 ] , tab = 8 ) def _Cpo ( self , T ) :          A , B , C , D , E , F = self . cp cp = A + B * T + C * T ** 2 + D * T ** 3 + E * T ** 4 + F * T ** 5 return unidades . SpecificHeat ( cp / self . M , <str> )  @ refDoc ( __doi__ , [ 5 ] , tab = 8 ) def _Ho ( self , T ) :          To = 298.15 A , B , C , D , E , F = self . cp H = B * T + C / 2 * T ** 2 + D / 3 * T ** 3 + E / 4 * T ** 4 + F / 5 * T ** 5 Ho = B * To + C / 2 * To ** 2 + D / 3 * To ** 3 + E / 4 * To ** 4 + F / 5 * To ** 5 return unidades . Enthalpy ( ( H - Ho ) / self . M , <str> )  @ refDoc ( __doi__ , [ 5 ] , tab = 8 ) def _so ( self , T ) :          A , B , C , D , E , F = self . cp so = A * log ( T ) + B * T + C / 2 * T ** 2 + D / 3 * T ** 3 + E / 4 * T ** 4 + F / 5 * T ** 5 return unidades . SpecificHeat ( so / self . M , <str> )  def RhoS ( self , T ) :          return DIPPR ( <str> , T , self . _dipprRhoS [ : - 2 ] , M = self . M , Tc = self . Tc )  def RhoL ( self , T , P ) :          method = self . kwargs [ <str> ] if method is None or method >= len ( Componente . METHODS_RhoL ) :              method = self . Config . getint ( <str> , <str> )  Pcorr = self . kwargs [ <str> ] if Pcorr is None or method >= len ( Componente . METHODS_RhoLP ) :              Pcorr = self . Config . getint ( <str> , <str> )  if method == 0 and self . _dipprRhoL and self . _dipprRhoL [ 6 ] <= T <= self . _dipprRhoL [ 7 ] :              rhos = DIPPR ( <str> , T , self . _dipprRhoL [ : - 2 ] , M = self . M , Tc = self . Tc )  elif method == 1 and self . rackett != 0 and T < self . Tc :              rhos = RhoL_Rackett ( T , self . Tc , self . Pc , self . rackett , self . M )  elif method == 2 and self . Vliq != 0 :              rhos = RhoL_Cavett ( T , self . Tc , self . M , self . Vliq )  elif method == 3 :              if self . f_acent_mod != 0 :                  w = self . f_acent_mod  else :                  w = self . f_acent  rhos = RhoL_Costald ( T , self . Tc , w , self . Vc )  elif method == 4 :              rhos = RhoL_YenWoods ( T , self . Tc , self . Vc , self . Zc )  elif method == 5 :              rhos = RhoL_YamadaGunn ( T , self . Tc , self . Pc , self . f_acent , self . M )  elif method == 6 :              rhos = RhoL_Bhirud ( T , self . Tc , self . Pc , self . f_acent , self . M )  elif method == 7 :              d = Mchaweh_d . get ( self . id , 0 ) / 100 rhos = RhoL_Mchaweh ( T , self . Tc , self . Vc , self . f_acent , d )  elif method == 8 :              rhos = RhoL_Riedel ( T , self . Tc , self . Vc , self . f_acent )  elif method == 9 :              rhos = RhoL_ChuehPrausnitz ( T , self . Tc , self . Vc , self . f_acent )  else :              if self . _dipprRhoL and self . _dipprRhoL [ 6 ] <= T <= self . _dipprRhoL [ 7 ] :                  rhos = DIPPR ( <str> , T , self . _dipprRhoL [ : - 2 ] , M = self . M , Tc = self . Tc )  elif self . rackett != 0 and T < self . Tc :                  rhos = RhoL_Rackett ( T , self . Tc , self . Pc , self . rackett , self . M )  elif self . Vliq != 0 :                  rhos = RhoL_Cavett ( T , self . Tc , self . M , self . Vliq )  else :                  if self . f_acent_mod != 0 :                      w = self . f_acent_mod  else :                      w = self . f_acent  rhos = RhoL_Costald ( T , self . Tc , w , self . Vc )   if P < 1e6 :              rho = rhos  elif Pcorr == 0 :              if self . f_acent_mod :                  w = self . f_acent_mod  else :                  w = self . f_acent  Ps = self . Pv ( T ) rho = RhoL_TaitCostald ( T , P , self . Tc , self . Pc , w , Ps , rhos )  elif Pcorr == 1 :              if self . f_acent_mod :                  w = self . f_acent_mod  else :                  w = self . f_acent  Ps = self . Pv ( T ) rho = RhoL_ChangZhao ( T , P , self . Tc , self . Pc , w , Ps , rhos )  elif Pcorr == 2 :              if self . f_acent_mod :                  w = self . f_acent_mod  else :                  w = self . f_acent  Ps = self . Pv ( T ) rho = RhoL_AaltoKeskinen ( T , P , self . Tc , self . Pc , w , Ps , rhos )  elif Pcorr == 3 :              if self . f_acent_mod :                  w = self . f_acent_mod  else :                  w = self . f_acent  Ps = self . Pv ( T ) rho = RhoL_AaltoKeskinen2 ( T , P , self . Tc , self . Pc , w , Ps , rhos )  elif Pcorr == 4 :              if self . f_acent_mod :                  w = self . f_acent_mod  else :                  w = self . f_acent  Ps = self . Pv ( T ) rho = RhoL_Nasrifar ( T , P , self . Tc , self . Pc , w , self . M , Ps , rhos )  else :              rho = RhoL_API ( T , P , self . Tc , self . Pc , self . SG , rhos )  return rho  def Pv ( self , T ) :          method = self . kwargs [ <str> ] if method is None or method >= len ( Componente . METHODS_Pv ) :              method = self . Config . getint ( <str> , <str> )  if method == 0 and self . _dipprPv and self . _dipprPv [ 6 ] <= T <= self . _dipprPv [ 7 ] :              return DIPPR ( <str> , T , self . _dipprPv [ : - 2 ] , M = self . M , Tc = self . Tc )  elif method == 1 and self . wagner [ 0 ] :              return Pv_Wagner ( T , self . Tc , self . Pc , self . wagner )  elif method == 2 and self . antoine [ 0 ] :              return Pv_Antoine ( T , self . antoine , Tc = self . Tc )  elif method == 3 and self . Pc and self . Tc and self . f_acent :              return Pv_AmbroseWalton ( T , self . Tc , self . Pc , self . f_acent )  elif method == 4 and self . Pc and self . Tc and self . f_acent :              return Pv_Lee_Kesler ( T , self . Tc , self . Pc , self . f_acent )  elif method == 5 and self . Pc and self . Tc and self . Tb :              return Pv_Riedel ( T , self . Tc , self . Pc , self . Tb )  elif method == 6 and self . Pc and self . Tc and self . Tb :              return Pv_Sanjari ( T , self . Tc , self . Pc , self . f_acent )  elif method == 7 and self . Kw and self . Tb :              return Pv_MaxwellBonnel ( T , self . Tb , self . Kw )  else :              if self . _dipprPv and self . _dipprPv [ 6 ] <= T <= self . _dipprPv [ 7 ] :                  return DIPPR ( <str> , T , self . _dipprPv [ : - 2 ] , M = self . M , Tc = self . Tc )  elif self . wagner [ 0 ] :                  return Pv_Wagner ( T , self . Tc , self . Pc , self . wagner )  elif self . antoine [ 0 ] :                  return Pv_Antoine ( T , self . antoine , Tc = self . Tc )  elif self . Pc and self . Tc and self . f_acent :                  return Pv_AmbroseWalton ( T , self . Tc , self . Pc , self . f_acent )  elif self . Pc and self . Tc and self . Tb :                  return Pv_Riedel ( T , self . Tc , self . Pc , self . Tb )  elif self . Kw and self . Tb :                  return Pv_MaxwellBonnel ( T , self . Tb , self . Kw )    def ThCond_Liquido ( self , T , P , rho ) :          method = self . kwargs [ <str> ] if method is None or method >= len ( Componente . METHODS_ThL ) :              method = self . Config . getint ( <str> , <str> )  Pcorr = self . kwargs [ <str> ] if Pcorr is None or method >= len ( Componente . METHODS_ThLP ) :              Pcorr = self . Config . getint ( <str> , <str> )  if method == 0 and self . _dipprKL and self . _dipprKL [ 6 ] <= T <= self . _dipprKL [ 7 ] :              ko = DIPPR ( <str> , T , self . _dipprKL [ : - 2 ] , M = self . M , Tc = self . Tc )  elif method == 1 and T < self . Tc :              ko = ThL_Pachaiyappan ( T , self . Tc , self . M , rho , self . branched )  elif method == 2 and self . Tb :              ko = ThL_SatoRiedel ( T , self . Tc , self . M , self . Tb )  elif method == 3 :              ko = ThL_KanitkarThodos ( T , P , self . Tc , self . Pc , self . Vc , self . M , rho )  elif method == 4 and self . Tb and self . SG :              ko = ThL_RiaziFaghri ( T , self . Tb , self . SG )  elif method == 5 and self . Tb :              ko = ThL_Gharagheizi ( T , self . Pc , self . Tb , self . M , self . f_acent )  elif method == 6 :              ko = ThL_LakshmiPrasad ( T , self . M )  elif method == 7 :              ko = ThL_Nicola ( T , self . M , self . Tc , self . Pc , self . f_acent , self . dipole . Debye )  else :              if self . _dipprKL and self . _dipprKL [ 6 ] <= T <= self . _dipprKL [ 7 ] :                  ko = DIPPR ( <str> , T , self . _dipprKL [ : - 2 ] , M = self . M , Tc = self . Tc )  elif T < self . Tc :                  ko = ThL_Pachaiyappan ( T , self . Tc , self . M , rho , self . branched )  elif self . Tb :                  ko = ThL_SatoRiedel ( T , self . Tc , self . M , self . Tb )  else :                  ko = ThL_KanitkarThodos ( T , P , self . Tc , self . Pc , self . Vc , self . M , rho )   if P < 1e6 :              k = ko  elif Pcorr == 0 :              k = ThL_KanitkarThodos ( T , P , self . Tc , self . Pc , self . Vc , self . M , rho )  elif Pcorr == 1 :              k = ThL_Lenoir ( T , P , self . Tc , self . Pc , ko )  elif Pcorr == 2 :              k = ThL_Missenard ( T , P , self . Tc , self . Pc , ko )  return k  def ThCond_Gas ( self , T , P , rho ) :          method = self . kwargs [ <str> ] if method is None or method >= len ( Componente . METHODS_ThG ) :              method = self . Config . getint ( <str> , <str> )  Pcorr = self . kwargs [ <str> ] if Pcorr is None or method >= len ( Componente . METHODS_ThGP ) :              Pcorr = self . Config . getint ( <str> , <str> )  if method == 0 and self . _dipprKG and self . _dipprKG [ 6 ] <= T <= self . _dipprKG [ 7 ] :              ko = DIPPR ( <str> , T , self . _dipprKG [ : - 2 ] , M = self . M , Tc = self . Tc )  elif method == 1 :              cp = self . Cp_Gas_DIPPR ( T ) ko = ThG_MisicThodos ( T , self . Tc , self . Pc , self . M , cp )  elif method == 2 :              cv = self . Cv ( T ) muo = self . Mu_Gas ( T , 101325 , rho ) ko = ThG_Chung ( T , self . Tc , self . M , self . f_acent , cv , muo )  elif method == 3 :              cv = self . Cv ( T ) muo = self . Mu_Gas ( T , 101325 , rho ) ko = ThG_Eucken ( self . M , cv , muo )  elif method == 4 :              cv = self . Cv ( T ) muo = self . Mu_Gas ( T , 101325 , rho ) ko = ThG_EuckenMod ( self . M , cv , muo )  elif method == 5 and self . SG and self . Tb :              ko = ThG_RiaziFaghri ( T , self . Tb , self . SG )  else :              if self . _dipprKG and self . _dipprKG [ 6 ] <= T <= self . _dipprKG [ 7 ] :                  ko = DIPPR ( <str> , T , self . _dipprKG [ : - 2 ] , M = self . M , Tc = self . Tc )  else :                  cp = self . Cp_Gas_DIPPR ( T ) ko = ThG_MisicThodos ( T , self . Tc , self . Pc , self . M , cp )   if P < 1e6 :              k = ko  elif self . id in [ 1 , 46 , 47 , 48 , 50 , 51 , 111 ] :              k = ThG_NonHydrocarbon ( T , P , self . id )  elif Pcorr == 0 :              k = ThG_StielThodos ( T , self . Tc , self . Pc , self . Vc , self . M , 1 / rho , ko )  elif Pcorr == 1 :              K = self . _K_Chung ( ) k = ThG_P_Chung ( T , self . Tc , self . Vc , self . M , self . f_acent , self . dipole . Debye , K , rho , ko )  elif Pcorr == 2 :              k = ThG_TRAPP ( T , self . Tc , self . Vc , self . Zc , self . M , self . f_acent , rho , ko )  return k  def Mu_Gas ( self , T , P , rho ) :          method = self . kwargs [ <str> ] if method is None or method >= len ( Componente . METHODS_MuG ) :              method = self . Config . getint ( <str> , <str> )  Pcorr = self . kwargs [ <str> ] if Pcorr is None or method >= len ( Componente . METHODS_MuGP ) :              Pcorr = self . Config . getint ( <str> , <str> )  if method == 0 and self . _dipprMuG and self . _dipprMuG [ 6 ] <= T <= self . _dipprMuG [ 7 ] :              muo = DIPPR ( <str> , T , self . _dipprMuG [ : - 2 ] , M = self . M , Tc = self . Tc )  elif method == 1 and self . Dm and self . ek :              omega = self . _Collision ( T ) muo = MuG_ChapmanEnskog ( T , self . M , self . Dm , omega )  elif method == 2 :              k = self . _K_Chung ( ) muo = MuG_Chung ( T , self . Tc , self . Vc , self . M , self . f_acent , self . dipole . Debye , k )  elif method == 3 :              muo = MuG_Lucas ( T , P , self . Tc , self . Pc , self . Zc , self . M , self . dipole . Debye )  elif method == 4 :              muo = MuG_StielThodos ( T , self . Tc , self . Pc , self . M )  elif method == 5 :              muo = MuG_Gharagheizi ( T , self . Tc , self . Pc , self . M )  elif method == 6 :              muo = MuG_YoonThodos ( T , self . Tc , self . Pc , self . M )  else :              if self . _dipprMuG and self . _dipprMuG [ 6 ] <= T <= self . _dipprMuG [ 7 ] :                  muo = DIPPR ( <str> , T , self . _dipprMuG [ : - 2 ] , M = self . M , Tc = self . Tc )  elif self . Dm and self . ek :                  omega = self . _Collision ( T ) muo = MuG_ChapmanEnskog ( T , self . M , self . Dm , omega )  else :                  muo = MuG_StielThodos ( T , self . Tc , self . Pc , self . M )   if P < 0.6 * self . Pc :              mu = muo  elif Pcorr == 0 :              mu = MuG_Lucas ( T , P , self . Tc , self . Pc , self . Zc , self . M , self . dipole . Debye )  elif Pcorr == 1 :              k = self . _K_Chung ( ) mu = MuG_P_Chung ( T , self . Tc , self . Vc , self . M , self . f_acent , self . dipole . Debye , k , rho , muo )  elif Pcorr == 2 :              mu = MuG_Brule ( T , self . Tc , self . Vc , self . M , self . f_acent , rho , muo )  elif Pcorr == 3 :              mu = MuG_Jossi ( self . Tc , self . Pc , self . rhoc , self . M , rho , muo )  elif Pcorr == 4 :              mu = MuG_TRAPP ( T , self . Tc , self . Vc , self . Zc , self . M , self . f_acent , rho , muo )  elif Pcorr == 5 :              mu = MuG_P_StielThodos ( self . Tc , self . Pc , self . rhoc , self . M , rho , muo )  elif Pcorr == 6 :              mu = MuG_Reichenberg ( T , P , self . Tc , self . Pc , self . Vc , self . M , self . dipole . Debye , muo )  elif Pcorr == 7 :              mu = MuG_DeanStiel ( self . Tc , self . Pc , self . rhoc , self . M , rho , muo )  elif Pcorr == 8 :              mu = MuG_API ( T , P , self . Tc , self . Pc , muo )  else :              if self . dipole :                  mu = MuG_Lucas ( T , P , self . Tc , self . Pc , self . Zc , self . M , self . dipole . Debye )  elif self . isHydrocarbon :                  mu = MuG_DeanStiel ( self . Tc , self . Pc , self . rhoc , self . M , rho , muo )  else :                  mu = MuG_TRAPP ( T , P , self . Tc , self . Pc , muo )   return mu  def _K_Chung ( self ) :          ki = { 117 : 0.215175 , 134 : 0.174823 , 146 : 0.143453 , 145 : 0.143453 , 160 : 0.131671 , 159 : 0.131671 , 313 : 0.121555 , 335 : 0.114230 , 357 : 0.108674 , 130 : 0.091549 , 62 : 0.075908 } k = ki . get ( self . id , 0 ) if not k and self . isAlcohol :              k = 0.0682 + 0.276659 * 17 * self . O / self . M  return k  def _Collision ( self , T ) :          T_ = T / self . ek omega = Collision_Neufeld ( T_ ) if self . PolarParameter :              omega += 0.2 * self . PolarParameter ** 2 / T_  return omega  def Mu_Liquido ( self , T , P ) :          method = self . kwargs [ <str> ] if method is None or method >= len ( Componente . METHODS_MuL ) :              method = self . Config . getint ( <str> , <str> )  Pcorr = self . kwargs [ <str> ] if Pcorr is None or method >= len ( Componente . METHODS_MuLP ) :              Pcorr = self . Config . getint ( <str> , <str> )  if method == 0 and self . _dipprMuL and self . _dipprMuL [ 6 ] <= T <= self . _dipprMuL [ 7 ] :              muo = DIPPR ( <str> , T , self . _dipprMuL [ : - 2 ] , M = self . M , Tc = self . Tc )  elif method == 1 and self . _parametricMu [ 0 ] :              muo = MuL_Parametric ( T , self . _parametricMu )  elif method == 2 :              muo = MuL_LetsouStiel ( T , self . M , self . Tc , self . Pc , self . f_acent )  elif method == 3 and self . Tf :              muo = MuL_PrzedzieckiSridhar ( T , self . Tc , self . Pc , self . Vc , self . f_acent , self . M , self . Tf )  else :              if self . _dipprMuL and self . _dipprMuL [ 6 ] <= T <= self . _dipprMuL [ 7 ] :                  return DIPPR ( <str> , T , self . _dipprMuL [ : - 2 ] , M = self . M , Tc = self . Tc )  elif self . _parametricMu [ 0 ] :                  return MuL_Parametric ( T , self . _parametricMu )  elif self . Tc and self . Pc and self . f_acent and self . M :                  return MuL_LetsouStiel ( T , self . M , self . Tc , self . Pc , self . f_acent )   if P < 0.6 * self . Pc :              mu = muo  elif Pcorr == 0 :              Ps = self . Pv ( T ) mu = MuL_Lucas ( T , P , self . Tc , self . Pc , self . f_acent , Ps , muo )  elif Pcorr == 1 and self . Pc and self . f_acent :              muc = self . _MuCritical ( ) mu = MuL_API ( T , P , self . Tc , self . Pc , self . f_acent , muc )  elif Pcorr == 2 :              mu = MuL_Kouzel ( T , P , muo )  else :              if self . Pc and self . f_acent :                  Ps = self . Pv ( T ) mu = MuL_Lucas ( T , P , self . Tc , self . Pc , self . f_acent , Ps , muo )  elif self . Tb < 650 :                  muc = self . _MuCritical ( ) mu = MuL_API ( T , P , self . Tc , self . Pc , self . f_acent , muc )  else :                  mu = MuL_Kouzel ( T , P , muo )   return mu  def Tension ( self , T ) :          method = self . kwargs [ <str> ] if method is None or method >= len ( Componente . METHODS_Tension ) :              method = self . Config . getint ( <str> , <str> )  if method == 0 and self . _dipprSigma and self . _dipprSigma [ 6 ] <= T <= self . _dipprSigma [ 7 ] :              return DIPPR ( <str> , T , self . _dipprSigma [ : - 2 ] , M = self . M , Tc = self . Tc )  elif method == 1 and self . _parametricSigma [ 0 ] :              return Tension_Parametric ( T , self . _parametricSigma , self . Tc )  elif method == 2 and self . Tb :              return Tension_BlockBird ( T , self . Tc , self . Pc , self . Tb )  elif method == 3 and self . f_acent :              return Tension_Pitzer ( T , self . Tc , self . Pc , self . f_acent )  elif method == 4 :              return Tension_ZuoStenby ( T , self . Tc , self . Pc , self . f_acent )  elif method == 5 :              return Tension_SastriRao ( T , self . Tc , self . Pc , self . Tb , alcohol = self . isAlcohol , acid = self . isAcid )  elif method == 6 and self . stiel :              return Tension_Hakim ( T , self . Tc , self . Pc , self . f_acent , self . stiel )  elif method == 7 and self . Vc :              return Tension_Miqueu ( T , self . Tc , self . Vc , self . M , self . f_acent )  else :              if self . _dipprSigma and self . _dipprSigma [ 6 ] <= T <= self . _dipprSigma [ 7 ] :                  return DIPPR ( <str> , T , self . _dipprSigma [ : - 2 ] , M = self . M , Tc = self . Tc )  elif self . _parametricSigma [ 0 ] :                  return Tension_Parametric ( T , self . _parametricSigma , self . Tc )  elif self . stiel :                  return Tension_Hakim ( T , self . Tc , self . Pc , self . f_acent , self . stiel )  elif self . Vc :                  return Tension_Miqueu ( T , self . Tc , self . Vc , self . M , self . f_acent )  elif self . Tb :                  return Tension_BlockBird ( T , self . Tc , self . Pc , self . Tb )  else :                  return Tension_Pitzer ( T , self . Tc , self . Pc , self . f_acent )    def Hv_DIPPR ( self , T ) :          return DIPPR ( <str> , T , self . _dipprHv [ : - 2 ] , M = self . M , Tc = self . Tc )  def Cp_Solido_DIPPR ( self , T ) :          return DIPPR ( <str> , T , self . _dipprCpS [ : - 2 ] , M = self . M , Tc = self . Tc )  def Cp_Liquido_DIPPR ( self , T ) :          return DIPPR ( <str> , T , self . _dipprCpL [ : - 2 ] , M = self . M , Tc = self . Tc )  def Cp_Gas_DIPPR ( self , T ) :          if self . _dipprCpG :              return DIPPR ( <str> , T , self . _dipprCpG [ : - 2 ] , M = self . M , Tc = self . Tc )  else :              return self . _Cpo ( T )   def Cv ( self , T ) :          cp = self . Cp_Gas_DIPPR ( T ) cv = cp / 1000 - R / self . M return unidades . SpecificHeat ( cv , <str> )  def Fase ( self , T , P ) :          Pv = self . Pv ( T ) . atm if Pv > P :              return 1  else :              return 0     