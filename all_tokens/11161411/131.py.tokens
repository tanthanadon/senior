import os import pickle from scipy import exp , log , zeros , r_ from scipy . constants import R from scipy . optimize import fsolve from lib import unidades from lib . physics import R_atml from lib import mEoS from lib . thermo import ThermoAdvanced Tref = 298.15 Pref = 101325. class GERG ( object ) :      kwargs = { <str> : [ ] , <str> : [ ] , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : None , <str> : None , <str> : None , <str> : None , <str> : None } componentes = [ mEoS . CH4 , mEoS . N2 , mEoS . CO2 , mEoS . C2 , mEoS . C3 , mEoS . nC4 , mEoS . iC4 , mEoS . nC5 , mEoS . iC5 , mEoS . nC6 , mEoS . nC7 , mEoS . nC8 , mEoS . H2 , mEoS . O2 , mEoS . CO , mEoS . H2O , mEoS . He , mEoS . Ar , mEoS . H2S , mEoS . nC9 , mEoS . nC10 ] Fij = pickle . load ( open ( os . path . join ( os . environ [ <str> ] , <str> , <str> ) , <str> ) ) Prop_c = pickle . load ( open ( os . path . join ( os . environ [ <str> ] , <str> , <str> ) , <str> ) ) fir_ij = { <str> : { <str> : [ - 0.98038985517335e-2 , 0.42487270143005e-3 ] , <str> : [ 1 , 4 ] , <str> : [ 0.000 , 1.850 ] , <str> : [ - .34800214576142e-1 , - .13333813013896 , - .11993694974627e-1 , 0.69243379775168e-1 , - 0.31022508148249 , 0.24495491753226 , 0.22369816716981 ] , <str> : [ 1 , 2 , 2 , 2 , 2 , 2 , 3 ] , <str> : [ 7.850 , 5.400 , 0.000 , 0.750 , 2.800 , 4.450 , 4.250 ] , <str> : [ 1 , 1 , 0.25 , 0 , 0 , 0 , 0 ] , <str> : [ 0.5 ] * 7 , <str> : [ 1 , 1 , 2.5 , 3 , 3 , 3 , 3 ] , <str> : [ 0.5 ] * 7 } , <str> : { <str> : [ - .10859387354942 , .80228576727389e-1 , - .93303985115717e-2 ] , <str> : [ 1 , 2 , 3 ] , <str> : [ 2.6 , 1.95 , 0 ] , <str> : [ 0.40989274005848e-1 , - 0.24338019772494 , 0.23855347281124 ] , <str> : [ 1 , 2 , 3 ] , <str> : [ 3.95 , 7.95 , 8 ] , <str> : [ 1 , 0.5 , 0 ] , <str> : [ 0.5 ] * 3 , <str> : [ 1 , 2 , 3 ] , <str> : [ 0.5 ] * 3 } , <str> : { <str> : [ - 0.80926050298746e-3 , - 0.75381925080059e-3 ] , <str> : [ 3 , 4 ] , <str> : [ 0.65 , 1.55 ] , <str> : [ - 0.41618768891219e-1 , - 0.23452173681569 , 0.14003840584586 , .63281744807738e-1 , - .34660425848809e-1 , - .23918747334251 , 0.19855255066891e-2 , 0.61777746171555e1 , - 0.69575358271105e1 , 0.10630185306388e1 ] , <str> : [ 1 , 2 , 2 , 2 , 2 , 2 , 2 , 3 , 3 , 3 ] , <str> : [ 3.1 , 5.9 , 7.05 , 3.35 , 1.2 , 5.8 , 2.7 , 0.45 , 0.55 , 1.95 ] , <str> : [ 1 , 1 , 1 , 0.875 , 0.75 , 0.5 , 0 , 0 , 0 , 0 ] , <str> : [ 0.5 ] * 10 , <str> : [ 1 , 1 , 1 , 1.25 , 1.5 , 2 , 3 , 3 , 3 , 3 ] , <str> : [ 0.5 ] * 10 } , <str> : { <str> : [ .13746429958576e-1 , - .74425012129552e-2 , - .45516600213685e-2 , - 0.54546603350237e-2 , 0.23682016824471e-2 ] , <str> : [ 3 , 3 , 4 , 4 , 4 ] , <str> : [ 1.85 , 3.95 , 0 , 1.85 , 3.85 ] , <str> : [ 0.18007763721438 , - 0.44773942932486 , 0.19327374888200e-1 , - 0.30632197804624 ] , <str> : [ 1 , 1 , 1 , 2 ] , <str> : [ 5.25 , 3.85 , 0.2 , 6.5 ] , <str> : [ 0.25 , 0.25 , 0 , 0 ] , <str> : [ 0.5 , 0.5 , 0.5 , 0.5 ] , <str> : [ 0.75 , 1 , 2 , 3 ] , <str> : [ 0.5 , 0.5 , 0.5 , 0.5 ] } , <str> : { <str> : [ 0.28661625028399 , - 0.10919833861247 ] , <str> : [ 2 , 3 ] , <str> : [ 1.85 , 1.4 ] , <str> : [ - 0.11374032082270e1 , 0.76580544237358 , 0.42638000926819e-2 , 0.17673538204534 ] , <str> : [ 1 , 1 , 1 , 2 ] , <str> : [ 3.2 , 2.5 , 8 , 3.75 ] , <str> : [ 0.25 , 0.25 , 0 , 0 ] , <str> : [ 0.5 , 0.5 , 0.5 , 0.5 ] , <str> : [ 0.75 , 1. , 2. , 3. ] , <str> : [ 0.5 , 0.5 , 0.5 , 0.5 ] } , <str> : { <str> : [ - 0.47376518126608 , 0.48961193461001 , - 0.57011062090535e-2 ] , <str> : [ 2 , 2 , 3 ] , <str> : [ 0 , 0.05 , 0 ] , <str> : [ - 0.19966820041320 , - 0.69411103101723 , 0.69226192739021 ] , <str> : [ 1 , 2 , 2 ] , <str> : [ 3.65 , 4.9 , 4.45 ] , <str> : [ 1 , 1 , 0.875 ] , <str> : [ 0.5 , 0.5 , 0.5 ] , <str> : [ 1 , 1 , 1.25 ] , <str> : [ 0.5 , 0.5 , 0.5 ] } , <str> : { <str> : [ - .25157134971934 , - .62203841111983e-2 , .88850315184396e-1 , - 0.35592212573239e-1 ] , <str> : [ 1 , 3 , 3 , 4 ] , <str> : [ 2 , - 1 , 1.75 , 1.4 ] , <str> : [ ] } , <str> : { <str> : [ .25574776844118e1 , - .79846357136353e1 , 0.47859131465806e1 , - 0.73265392369587 , 0.13805471345312e1 , 0.28349603476365 , - 0.49087385940425 , - 0.10291888921447 , 0.11836314681968 , 0.55527385721943e-4 ] , <str> : [ 1 , 1 , 1 , 2 , 2 , 3 , 3 , 4 , 4 , 4 ] , <str> : [ 1.0 , 1.550 , 1.700 , 0.250 , 1.350 , 0.0 , 1.250 , 0.0 , 0.7 , 5.4 ] , <str> : [ ] } , <str> : { <str> : [ .25574776844118e1 , - .79846357136353e1 , 0.47859131465806e1 , - 0.73265392369587 , 0.13805471345312e1 , 0.28349603476365 , - 0.49087385940425 , - 0.10291888921447 , 0.11836314681968 , 0.55527385721943e-4 ] , <str> : [ 1 , 1 , 1 , 2 , 2 , 3 , 3 , 4 , 4 , 4 ] , <str> : [ 1.0 , 1.55 , 1.70 , 0.25 , 1.35 , 0.0 , 1.25 , 0.0 , 0.70 , 5.40 ] , <str> : [ ] } , <str> : { <str> : [ 0.25574776844118e1 , - .79846357136353e1 , 0.47859131465806e1 , - 0.73265392369587 , 0.13805471345312e1 , 0.28349603476365 , - 0.49087385940425 , - 0.10291888921447 , 0.11836314681968 , 0.55527385721943e-4 ] , <str> : [ 1 , 1 , 1 , 2 , 2 , 3 , 3 , 4 , 4 , 4 ] , <str> : [ 1.0 , 1.550 , 1.700 , 0.250 , 1.350 , 0.0 , 1.250 , 0.0 , 0.7 , 5.4 ] , <str> : [ ] } , <str> : { <str> : [ .25574776844118e1 , - .79846357136353e1 , .47859131465806e1 , - 0.73265392369587 , 0.13805471345312e1 , 0.28349603476365 , - 0.49087385940425 , - 0.10291888921447 , 0.11836314681968 , 0.55527385721943e-4 ] , <str> : [ 1 , 1 , 1 , 2 , 2 , 3 , 3 , 4 , 4 , 4 ] , <str> : [ 1.0 , 1.550 , 1.700 , 0.250 , 1.350 , 0.0 , 1.250 , 0.0 , 0.7 , 5.4 ] , <str> : [ ] } , <str> : { <str> : [ .25574776844118e1 , - 0.79846357136353e1 , 0.47859131465806e1 , - 0.73265392369587 , 0.13805471345312e1 , 0.28349603476365 , - 0.49087385940425 , - 0.10291888921447 , 0.11836314681968 , 0.55527385721943e-4 ] , <str> : [ 1 , 1 , 1 , 2 , 2 , 3 , 3 , 4 , 4 , 4 ] , <str> : [ 1.0 , 1.550 , 1.7 , 0.250 , 1.350 , 0.0 , 1.250 , 0.0 , 0.70 , 5.4 ] , <str> : [ ] } , <str> : { <str> : [ 0.25574776844118e1 , - .79846357136353e1 , 0.47859131465806e1 , - 0.73265392369587 , 0.13805471345312e1 , 0.28349603476365 , - 0.49087385940425 , - 0.10291888921447 , 0.11836314681968 , 0.55527385721943e-4 ] , <str> : [ 1 , 1 , 1 , 2 , 2 , 3 , 3 , 4 , 4 , 4 ] , <str> : [ 1.0 , 1.550 , 1.7 , 0.250 , 1.350 , 0.0 , 1.250 , 0.0 , 0.7 , 5.4 ] , <str> : [ ] } , <str> : { <str> : [ .25574776844118e1 , - 0.79846357136353e1 , 0.47859131465806e1 , - 0.73265392369587 , 0.13805471345312e1 , 0.28349603476365 , - 0.49087385940425 , - 0.10291888921447 , 0.11836314681968 , 0.55527385721943e-4 ] , <str> : [ 1 , 1 , 1 , 2 , 2 , 3 , 3 , 4 , 4 , 4 ] , <str> : [ 1.0 , 1.550 , 1.7 , 0.250 , 1.350 , 0.0 , 1.250 , 0.0 , 0.7 , 5.4 ] , <str> : [ ] } , <str> : { <str> : [ .25574776844118e1 , - 0.79846357136353e1 , 0.47859131465806e1 , - 0.73265392369587 , 0.13805471345312e1 , 0.28349603476365 , - 0.49087385940425 , - 0.10291888921447 , 0.11836314681968 , 0.55527385721943e-4 ] , <str> : [ 1 , 1 , 1 , 2 , 2 , 3 , 3 , 4 , 4 , 4 ] , <str> : [ 1.0 , 1.550 , 1.7 , 0.250 , 1.350 , 0.0 , 1.250 , 0.0 , 0.7 , 5.400 ] , <str> : [ ] } } def __init__ ( self , ** kwargs ) :          self . kwargs = GERG . kwargs . copy ( ) self . __call__ ( ** kwargs )  def __call__ ( self , ** kwargs ) :          self . kwargs . update ( kwargs ) if self . calculable :              self . status = 1 self . calculo ( ) self . msg = <str>   @ property def calculable ( self ) :          if self . kwargs [ <str> ] and self . kwargs [ <str> ] :              self . _definition = True  else :              self . _definition = False  thermo = 0 for key in ( <str> , <str> , <str> , <str> ) :              if self . kwargs [ key ] :                  thermo += 1   for key in ( <str> , <str> , <str> , <str> ) :              if self . kwargs [ key ] is not None :                  thermo += 1   return self . _definition and thermo >= 2  def calculo ( self ) :          T = self . kwargs [ <str> ] rho = self . kwargs [ <str> ] P = self . kwargs [ <str> ] v = self . kwargs [ <str> ] h = self . kwargs [ <str> ] s = self . kwargs [ <str> ] u = self . kwargs [ <str> ] x = self . kwargs [ <str> ] self . comp = [ ] for i in self . kwargs [ <str> ] :              c = self . componentes [ i ] ( eq = <str> , ** self . kwargs ) self . comp . append ( c )  self . id = self . kwargs [ <str> ] self . xi = self . kwargs [ <str> ] bt = self . Prop_c [ <str> ] bv = self . Prop_c [ <str> ] gt = self . Prop_c [ <str> ] gv = self . Prop_c [ <str> ] c_T = zeros ( ( len ( self . comp ) , len ( self . comp ) ) ) c_rho = zeros ( ( len ( self . comp ) , len ( self . comp ) ) ) for i , cmpi in enumerate ( self . comp ) :              for j , cmpj in enumerate ( self . comp ) :                  c_T [ i , j ] = 2 * bt [ i ] [ j ] * gt [ i ] [ j ] * ( cmpi . Tc * cmpj . Tc ) ** 0.5 c_rho [ i , j ] = 2 * bv [ i ] [ j ] * gv [ i ] [ j ] / 8. * ( 1. / cmpi . rhoc ** ( 1. / 3 ) + 1. / cmpj . rhoc ** ( 1. / 3 ) ) ** 3   f_T = zeros ( ( len ( self . comp ) , len ( self . comp ) ) ) f_rho = zeros ( ( len ( self . comp ) , len ( self . comp ) ) ) dFT_ik = zeros ( ( len ( self . comp ) , len ( self . comp ) ) ) dFT_ki = zeros ( ( len ( self . comp ) , len ( self . comp ) ) ) dFrho_ik = zeros ( ( len ( self . comp ) , len ( self . comp ) ) ) dFrho_ki = zeros ( ( len ( self . comp ) , len ( self . comp ) ) ) for i , x_i in enumerate ( self . xi ) :              for j , x_j in enumerate ( self . xi ) :                  f_T [ i , j ] = x_i * x_j * ( x_i + x_j ) / ( bt [ i ] [ j ] ** 2 * x_i + x_j ) f_rho [ i , j ] = x_i * x_j * ( x_i + x_j ) / ( bv [ i ] [ j ] ** 2 * x_i + x_j ) dFT_ik [ i , j ] = x_j * ( x_j + x_i ) / ( bt [ i ] [ j ] ** 2 * x_i + x_j ) + x_j * x_i / ( bt [ i ] [ j ] ** 2 * x_i + x_j ) * ( 1 - bt [ i ] [ j ] ** 2 * ( x_j + x_i ) / ( bt [ i ] [ j ] ** 2 * x_i + x_j ) ) dFrho_ik [ i , j ] = x_j * ( x_j + x_i ) / ( bv [ i ] [ j ] ** 2 * x_i + x_j ) + x_j * x_i / ( bv [ i ] [ j ] ** 2 * x_i + x_j ) * ( 1 - bv [ i ] [ j ] ** 2 * ( x_j + x_i ) / ( bv [ i ] [ j ] ** 2 * x_i + x_j ) ) dFT_ki [ j , i ] = x_j * ( x_j + x_i ) / ( bt [ i ] [ j ] ** 2 * x_j + x_i ) + x_j * x_i / ( bt [ i ] [ j ] ** 2 * x_j + x_i ) * ( 1 - ( x_j + x_i ) / ( bt [ i ] [ j ] ** 2 * x_j + x_i ) ) dFrho_ki [ j , i ] = x_j * ( x_j + x_i ) / ( bv [ i ] [ j ] ** 2 * x_j + x_i ) + x_j * x_i / ( bv [ i ] [ j ] ** 2 * x_j + x_i ) * ( 1 - ( x_j + x_i ) / ( bv [ i ] [ j ] ** 2 * x_j + x_i ) )   sumai_v = sumaij_v = sumai_T = sumaij_T = m = 0 for i , componentei in enumerate ( self . comp ) :              sumai_v += self . xi [ i ] ** 2 / componentei . rhoc sumai_T += self . xi [ i ] ** 2 * componentei . Tc m += self . xi [ i ] * componentei . M for j , componentej in enumerate ( self . comp ) :                  if j > i :                      sumaij_v += c_rho [ i , j ] * f_rho [ i , j ] sumaij_T += c_T [ i , j ] * f_T [ i , j ]    self . rhoc = unidades . Density ( 1. / ( sumai_v + sumaij_v ) ) self . Tc = unidades . Temperature ( sumai_T + sumaij_T ) self . M = m self . R = unidades . SpecificHeat ( R / self . M , <str> ) Tcxi = rhocxi = [ ] for i , componentei in enumerate ( self . comp ) :              sumav1 = sumat1 = 0 for k in range ( i ) :                  sumav1 += c_rho [ k , i ] * dFrho_ki [ k , i ] sumat1 += c_T [ k , i ] * dFT_ki [ k , i ]  sumav2 = sumat2 = 0 for k in range ( i + 1 , len ( self . xi ) ) :                  sumav2 += c_rho [ i , k ] * dFrho_ik [ i , k ] sumat2 += c_T [ i , k ] * dFT_ik [ i , k ]  Tcxi . append ( 2 * self . xi [ i ] * componentei . Tc + sumat1 + sumat2 ) rhocxi . append ( 2 * self . xi [ i ] / componentei . rhoc + sumav1 + sumav2 )  self . Tcxi = Tcxi self . rhocxi = rhocxi if v and not rho :              rho = 1. / v  if T and x is not None :              pass  else :              if T and P :                  rhoo = 2. rho = fsolve ( lambda rho : self . _solve ( rho , T ) [ <str> ] - P * 1e6 , rhoo )  elif T and rho :                  pass  elif T and h is not None :                  rho = fsolve ( lambda rho : self . _solve ( rho , T ) [ <str> ] - h , 200 )  elif T and s is not None :                  rho = fsolve ( lambda rho : self . _solve ( rho , T ) [ <str> ] - s , 200 )  elif T and u is not None :                  rho = fsolve ( lambda rho : self . _solve ( rho , T ) [ <str> ] - u , 200 )  elif P and rho :                  T = fsolve ( lambda T : self . _solve ( rho , T ) [ <str> ] - P * 1e6 , 600 )  elif P and h is not None :                  rho , T = fsolve ( lambda par : ( self . _solve ( par [ 0 ] , par [ 1 ] ) [ <str> ] - P * 1e6 , self . _solve ( par [ 0 ] , par [ 1 ] ) [ <str> ] - h ) , [ 200 , 600 ] )  elif P and s is not None :                  rho , T = fsolve ( lambda par : ( self . _solve ( par [ 0 ] , par [ 1 ] ) [ <str> ] - P * 1e6 , self . _solve ( par [ 0 ] , par [ 1 ] ) [ <str> ] - s ) , [ 200 , 600 ] )  elif P and u is not None :                  rho , T = fsolve ( lambda par : ( self . _solve ( par [ 0 ] , par [ 1 ] ) [ <str> ] - P * 1e6 , self . _solve ( par [ 0 ] , par [ 1 ] ) [ <str> ] - u ) , [ 200 , 600 ] )  elif rho and h is not None :                  T = fsolve ( lambda T : self . _solve ( rho , T ) [ <str> ] - h , 600 )  elif rho and s is not None :                  T = fsolve ( lambda T : self . _solve ( rho , T ) [ <str> ] - s , 600 )  elif rho and u is not None :                  T = fsolve ( lambda T : self . _solve ( rho , T ) [ <str> ] - u , 600 )  elif h is not None and s is not None :                  rho , T = fsolve ( lambda par : ( self . _solve ( par [ 0 ] , par [ 1 ] ) [ <str> ] - h , self . _solve ( par [ 0 ] , par [ 1 ] ) [ <str> ] - s ) , [ 200 , 600 ] )  elif h is not None and u is not None :                  rho , T = fsolve ( lambda par : ( self . _solve ( par [ 0 ] , par [ 1 ] ) [ <str> ] - h , self . _solve ( par [ 0 ] , par [ 1 ] ) [ <str> ] - u ) , [ 200 , 600 ] )  elif s is not None and u is not None :                  rho , T = fsolve ( lambda par : ( self . _solve ( par [ 0 ] , par [ 1 ] ) [ <str> ] - s , self . _solve ( par [ 0 ] , par [ 1 ] ) [ <str> ] - u ) , [ 200 , 600 ] )  else :                  raise IOError   fio , fiot , fiott , fiod , fiodd , fiodt , fir , firt , firtt , fird , firdd , firdt , firdtt , nfioni , nfirni = self . _eq ( rho , T ) tau = self . Tc / T delta = rho / self . rhoc self . T = unidades . Temperature ( T ) self . rho = unidades . Density ( rho ) self . v = unidades . SpecificVolume ( 1. / rho ) self . P = unidades . Pressure ( ( 1 + delta * fird ) * self . R . JkgK * T * rho ) self . Z = 1 + delta * fird self . s = unidades . SpecificHeat ( self . R . kJkgK * ( tau * ( fiot + firt ) - fio - fir ) ) self . u = unidades . Enthalpy ( self . R * T * tau * ( fiot + firt ) ) self . h = unidades . Enthalpy ( self . R * T * ( 1 + tau * ( fiot + firt ) + delta * fird ) ) self . cp = unidades . SpecificHeat ( self . R * ( - tau ** 2 * ( fiott + firtt ) + ( 1 + delta * fird - delta * tau * firdt ) ** 2 / ( 1 + 2 * delta * fird + delta ** 2 * firdd ) ) ) self . cv = unidades . SpecificHeat ( - self . R * tau ** 2 * ( fiott + firtt ) ) self . g = unidades . Enthalpy ( self . R * T * ( 1 + fio + fir + delta * fird ) ) self . w = unidades . Speed ( ( self . R * T * ( 1 + 2 * delta * fird + delta ** 2 * firdd - ( 1 + delta * fird - delta * tau * firdt ) ** 2 / tau ** 2 / ( fiott + firtt ) ) ) ** 0.5 ) f , FI = self . fug ( rho , T , nfirni ) Ki , xi , yi , Q = self . flash ( ) self . x = unidades . Dimensionless ( Q ) self . xl = xi self . xv = yi if self . kwargs [ <str> ] :              self . Pc = self . kwargs [ <str> ] . Pc  self . Liquido = ThermoAdvanced ( ) self . Gas = ThermoAdvanced ( )  def fug ( self , rho , T , nfirni = None ) :          if not nfirni :              tau = self . Tc / T delta = rho / self . rhoc fir , firt , firtt , fird , firdd , firdt , firdtt , nfirni = self . _phir ( tau , delta )  f = [ ] FI = [ ] for xi , dn in zip ( self . xi , nfirni ) :              f . append ( unidades . Pressure ( xi * rho / self . M * R_atml * T * exp ( dn ) , <str> ) ) FI . append ( dn - log ( self . Z ) )  return f , FI  def _eq ( self , rho , T ) :          tau = self . Tc / T delta = rho / self . rhoc fio , fiot , fiott , fiod , fiodd , fiodt , nfioni = self . _phi0 ( tau , delta ) fir , firt , firtt , fird , firdd , firdt , firdtt , nfirni = self . _phir ( tau , delta ) return ( fio , fiot , fiott , fiod , fiodd , fiodt , fir , firt , firtt , fird , firdd , firdt , firdtt , nfioni , nfirni )  def _solve ( self , rho , T ) :          tau = self . Tc / T delta = rho / self . rhoc fio , fiot , fiott , fiod , fiodd , fiodt , nfioni = self . _phi0 ( tau , delta ) fir , firt , firtt , fird , firdd , firdt , firdtt , nfirni = self . _phir ( tau , delta ) propiedades = { } propiedades [ <str> ] = ( 1 + delta * fird ) * self . R . JkgK * T * rho propiedades [ <str> ] = self . R . kJkgK * ( tau * ( fiot + firt ) - fio - fir ) propiedades [ <str> ] = self . R . kJkgK * T * tau * ( fiot + firt ) propiedades [ <str> ] = self . R . kJkgK * T * ( 1 + tau * ( fiot + firt ) + delta * fird ) return propiedades  def _phi0 ( self , tau , delta ) :          fio = fiot = fiott = fiod = fiodd = fiodt = 0 nfioni = [ ] for i , componente in enumerate ( self . comp ) :              deltai = delta * self . rhoc / componente . rhoc taui = componente . Tc * tau / self . Tc fio_ , fiot_ , fiott_ , fiod_ , fiodd_ , fiodt_ = componente . _phi0 ( componente . GERG [ <str> ] , taui , deltai ) fio += self . xi [ i ] * ( fio_ + log ( self . xi [ i ] ) ) fiot += self . xi [ i ] * fiot_ fiott += self . xi [ i ] * fiott_ fiod += self . xi [ i ] * fiod_ fiodd += self . xi [ i ] * fiodd_ fiodt += self . xi [ i ] * fiodt_ nfioni . append ( fio_ + 1 + log ( self . xi [ i ] ) )  return fio , fiot , fiott , fiod , fiodd , fiodt , nfioni  def _phir ( self , tau , delta ) :          fir = firt = firtt = fird = firdd = firdt = firdtt = 0 firxi = [ ] firxixj = zeros ( ( len ( self . comp ) , len ( self . comp ) ) ) firdxi = [ ] firtxi = [ ] for i , componente in enumerate ( self . comp ) :              deltai = delta * self . rhoc / componente . rhoc taui = componente . Tc * tau / self . Tc fir_ , firt_ , firtt_ , fird_ , firdd_ , firdt_ , firdtt_ , B_ , C_ = componente . _Helmholtz ( taui , deltai ) fir += self . xi [ i ] * fir_ firt += self . xi [ i ] * firt_ firtt += self . xi [ i ] * firtt_ fird += self . xi [ i ] * fird_ firdd += self . xi [ i ] * firdd_ firdt += self . xi [ i ] * firdt_ firxi . append ( fir_ ) firdxi . append ( fird_ ) firtxi . append ( firt_ )  for i , x_i in enumerate ( self . xi ) :              for j , x_j in enumerate ( self . xi ) :                  if j > i :                      ( fir_ , firt_ , firtt_ , fird_ , firdd_ , firdt_ , firdtt_ , B_ , C_ ) = self . _phijr ( i , j , tau , delta ) fir += x_i * x_j * self . Fij [ self . id [ i ] ] [ self . id [ j ] ] * fir_ firt += x_i * x_j * self . Fij [ self . id [ i ] ] [ self . id [ j ] ] * firt_ firtt += x_i * x_j * self . Fij [ self . id [ i ] ] [ self . id [ j ] ] * firtt_ fird += x_i * x_j * self . Fij [ self . id [ i ] ] [ self . id [ j ] ] * fird_ firdd += x_i * x_j * self . Fij [ self . id [ i ] ] [ self . id [ j ] ] * firdd_ firdt += x_i * x_j * self . Fij [ self . id [ i ] ] [ self . id [ j ] ] * firdt_ firxi [ i ] += x_j * self . Fij [ self . id [ i ] ] [ self . id [ j ] ] * fir_ firxixj [ i , j ] = self . Fij [ self . id [ i ] ] [ self . id [ j ] ] * fir_ firdxi [ i ] += x_j * self . Fij [ self . id [ i ] ] [ self . id [ j ] ] * fird_ firtxi [ i ] += x_j * self . Fij [ self . id [ i ] ] [ self . id [ j ] ] * firt_    suma = suma_rho = suma_T = 0 for i , x_i in enumerate ( self . xi ) :              suma += x_i * firxi [ i ] suma_rho += x_i * self . rhocxi [ i ] suma_T += x_i * self . Tcxi [ i ]  n_rhocni = [ ] n_Tcni = [ ] for i , x_i in enumerate ( self . xi ) :              n_rhocni . append ( self . rhocxi [ i ] - suma_rho ) n_Tcni . append ( self . Tcxi [ i ] - suma_T )  n_firni = [ ] nfirni = [ ] for i , componente in enumerate ( self . comp ) :              n_firni . append ( delta * fird * ( 1 - 1. / self . rhoc * n_rhocni [ i ] ) + tau * firt / self . Tc * n_Tcni [ i ] + firxi [ i ] - suma ) nfirni . append ( fir_ + n_firni [ i ] )  return fir , firt , firtt , fird , firdd , firdt , firdtt , nfirni  def _phijr ( self , i , j , tau , delta ) :          txt = str ( i ) + <str> + str ( j ) constants = self . fir_ij . get ( txt , 0 ) fir = fird = firdd = firt = firtt = firdt = firdtt = B = C = 0 if constants :              delta_0 = 1e-50 nr1 = constants [ <str> ] d1 = constants [ <str> ] t1 = constants [ <str> ] for i in range ( len ( constants . get ( <str> , [ ] ) ) ) :                  fir += nr1 [ i ] * delta ** d1 [ i ] * tau ** t1 [ i ] fird += nr1 [ i ] * d1 [ i ] * delta ** ( d1 [ i ] - 1 ) * tau ** t1 [ i ] firdd += nr1 [ i ] * d1 [ i ] * ( d1 [ i ] - 1 ) * delta ** ( d1 [ i ] - 2 ) * tau ** t1 [ i ] firt += nr1 [ i ] * t1 [ i ] * delta ** d1 [ i ] * tau ** ( t1 [ i ] - 1 ) firtt += nr1 [ i ] * t1 [ i ] * ( t1 [ i ] - 1 ) * delta ** d1 [ i ] * tau ** ( t1 [ i ] - 2 ) firdt += nr1 [ i ] * t1 [ i ] * d1 [ i ] * delta ** ( d1 [ i ] - 1 ) * tau ** ( t1 [ i ] - 1 ) firdtt += nr1 [ i ] * t1 [ i ] * d1 [ i ] * ( t1 [ i ] - 1 ) * delta ** ( d1 [ i ] - 1 ) * tau ** ( t1 [ i ] - 2 ) B += nr1 [ i ] * d1 [ i ] * delta_0 ** ( d1 [ i ] - 1 ) * tau ** t1 [ i ] C += nr1 [ i ] * d1 [ i ] * ( d1 [ i ] - 1 ) * delta_0 ** ( d1 [ i ] - 2 ) * tau ** t1 [ i ]  nr2 = constants [ <str> ] if nr2 :                  d2 = constants [ <str> ] t2 = constants [ <str> ] n2 = constants [ <str> ] e2 = constants [ <str> ] b2 = constants [ <str> ] g2 = constants [ <str> ] for i in range ( len ( constants . get ( <str> , [ ] ) ) ) :                      fir += nr2 [ i ] * delta ** d2 [ i ] * tau ** t2 [ i ] * exp ( - n2 [ i ] * ( delta - e2 [ i ] ) ** 2 - b2 [ i ] * ( tau - g2 [ i ] ) ** ( 2 ) ) fird += nr2 [ i ] * delta ** d2 [ i ] * tau ** t2 [ i ] * exp ( - n2 [ i ] * ( delta - e2 [ i ] ) ** 2 - b2 [ i ] * ( tau - g2 [ i ] ) ** ( 2 ) ) * ( d2 [ i ] / delta - 2 * n2 [ i ] * ( delta - e2 [ i ] ) ) firdd += nr2 [ i ] * tau ** t2 [ i ] * exp ( - n2 [ i ] * ( delta - e2 [ i ] ) ** 2 - b2 [ i ] * ( tau - g2 [ i ] ) ** ( 2 ) ) * ( - 2 * n2 [ i ] * delta ** d2 [ i ] + 4 * n2 [ i ] ** 2 * delta ** d2 [ i ] * ( delta - e2 [ i ] ) ** 2 - 4 * d2 [ i ] * n2 [ i ] * delta ** 2 * ( delta - e2 [ i ] ) + d2 [ i ] * 2 * delta ) firt += nr2 [ i ] * delta ** d2 [ i ] * tau ** t2 [ i ] * exp ( - n2 [ i ] * ( delta - e2 [ i ] ) ** 2 - b2 [ i ] * ( tau - g2 [ i ] ) ** ( 2 ) ) * ( t2 [ i ] / tau - 2 * b2 [ i ] * ( tau - g2 [ i ] ) ) firtt += nr2 [ i ] * delta ** d2 [ i ] * tau ** t2 [ i ] * exp ( - n2 [ i ] * ( delta - e2 [ i ] ) ** 2 - b2 [ i ] * ( tau - g2 [ i ] ) ** ( 2 ) ) * ( ( t2 [ i ] / tau - 2 * b2 [ i ] * ( tau - g2 [ i ] ) ) ** ( 2 ) - t2 [ i ] / tau ** 2 - 2 * b2 [ i ] ) firdt += nr2 [ i ] * delta ** d2 [ i ] * tau ** t2 [ i ] * exp ( - n2 [ i ] * ( delta - e2 [ i ] ) ** 2 - b2 [ i ] * ( tau - g2 [ i ] ) ** ( 2 ) ) * ( t2 [ i ] / tau - 2 * b2 [ i ] * ( tau - g2 [ i ] ) ) * ( d2 [ i ] / delta - 2 * n2 [ i ] * ( delta - e2 [ i ] ) ) firdtt += nr2 [ i ] * delta ** d2 [ i ] * tau ** t2 [ i ] * exp ( - n2 [ i ] * ( delta - e2 [ i ] ) ** 2 - b2 [ i ] * ( tau - g2 [ i ] ) ** ( 2 ) ) * ( ( t2 [ i ] / tau - 2 * b2 [ i ] * ( tau - g2 [ i ] ) ) ** ( 2 ) - t2 [ i ] / tau ** 2 - 2 * b2 [ i ] ) * ( d2 [ i ] / delta - 2 * n2 [ i ] * ( delta - e2 [ i ] ) ) B += nr2 [ i ] * delta_0 ** d2 [ i ] * tau ** t2 [ i ] * exp ( - n2 [ i ] * ( delta_0 - e2 [ i ] ) ** 2 - b2 [ i ] * ( tau - g2 [ i ] ) ** ( 2 ) ) * ( d2 [ i ] / delta_0 - 2 * n2 [ i ] * ( delta_0 - e2 [ i ] ) ) C += nr2 [ i ] * tau ** t2 [ i ] * exp ( - n2 [ i ] * ( delta_0 - e2 [ i ] ) ** 2 - b2 [ i ] * ( tau - g2 [ i ] ) ** ( 2 ) ) * ( - 2 * n2 [ i ] * delta_0 ** d2 [ i ] + 4 * n2 [ i ] ** 2 * delta_0 ** d2 [ i ] * ( delta_0 - e2 [ i ] ) ** 2 - 4 * d2 [ i ] * n2 [ i ] * delta_0 ** 2 * ( delta_0 - e2 [ i ] ) + d2 [ i ] * 2 * delta_0 )    return fir , firt , firtt , fird , firdd , firdt , firdtt , B , C  def flash ( self ) :          Ki = [ ] for componente in self . comp :              Ki . append ( componente . Pc / self . P * exp ( 5.373 * ( 1. + componente . f_acent ) * ( 1. - componente . Tc / self . T ) ) )  def f ( Q ) :              sum = 0 for i , x in enumerate ( self . xi ) :                  sum += x * ( Ki [ i ] - 1. ) / ( 1. + Q + Q * Ki [ i ] )  return sum  if f ( 0 ) > 0 and f ( 1 ) > 0 :              xi = self . xi yi = self . xi Q = 1  elif f ( 0 ) < 0 and f ( 1 ) < 0 :              xi = self . xi yi = self . xi Q = 0  else :              Qo = 0.5 while True :                  Q = Qo Qo = fsolve ( Vr , Q ) xi = [ ] yi = [ ] for i , fraccion in enumerate ( self . xi ) :                      xi . append ( fraccion / ( 1 + Qo * ( Ki [ i ] - 1 ) ) ) yi . append ( fraccion * Ki [ i ] / ( 1 + Qo * ( Ki [ i ] - 1 ) ) )  fi , Fi = self . fug ( self . rho , self . T ) fiv = r_ [ yi ] * r_ [ self . titaiv ] * self . P fil = r_ [ xi ] * r_ [ self . titail ] * self . P if sum ( ( fil / fiv - 1 ) ** 2 ) < 1e-15 and ( Q - Qo ) ** 2 < 1e-15 :                      break  else :                      Ki = r_ [ self . titail ] / r_ [ self . titaiv ]    return Ki , xi , yi , Q   id_GERG = [ i . id for i in GERG . componentes ] if __name__ == <str> :      T = unidades . Temperature ( 205 , <str> ) P = unidades . Pressure ( 315 , <str> ) aire = GERG ( T = T , P = P , componente = [ 0 , 3 , 4 , 5 , 7 , 9 ] , fraccion = [ 0.26 , 0.09 , 0.25 , 0.17 , 0.11 , 0.12 ] )   