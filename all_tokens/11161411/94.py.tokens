import os from PyQt5 . QtWidgets import QApplication from scipy import sqrt , exp , log , pi , arccos , sin , cos , tanh from scipy . constants import g from scipy . optimize import fsolve from lib import unidades from lib . adimensional import Re , Pr , Gr , Gz from lib . friction import f_friccion from lib . heatTransfer import * from equipment . parents import equipment class Heat_Exchanger ( equipment ) :      title = QApplication . translate ( <str> , <str> ) help = <str> kwargs = { <str> : None , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 } kwargsInput = ( <str> , ) kwargsValue = ( <str> , <str> , <str> , <str> , <str> , <str> , <str> ) calculateValue = ( <str> , <str> ) def cleanOldValues ( self , ** kwargs ) :          if kwargs . get ( <str> , 0 ) :              self . kwargs [ <str> ] = 0 self . kwargs [ <str> ] = 0 self . kwargs [ <str> ] = 0 self . kwargs [ <str> ] = 0 self . kwargs [ <str> ] = 0  elif kwargs . get ( <str> , 0 ) :              self . kwargs [ <str> ] = 0 self . kwargs [ <str> ] = 0 self . kwargs [ <str> ] = 0 self . kwargs [ <str> ] = 0 self . kwargs [ <str> ] = 0  elif kwargs . get ( <str> , 0 ) :              self . kwargs [ <str> ] = 0 self . kwargs [ <str> ] = 0 self . kwargs [ <str> ] = 0 self . kwargs [ <str> ] = 0 self . kwargs [ <str> ] = 0  self . kwargs . update ( kwargs )  @ property def isCalculable ( self ) :          if not self . kwargs [ <str> ] :              self . msg = QApplication . translate ( <str> , <str> ) self . status = 0 self . modo = 0 return  if self . kwargs [ <str> ] and self . kwargs [ <str> ] and self . kwargs [ <str> ] :              self . modo = 3  elif self . kwargs [ <str> ] :              self . modo = 2  elif self . kwargs [ <str> ] or self . kwargs [ <str> ] :              self . modo = 1  else :              self . msg = QApplication . translate ( <str> , <str> ) self . status = 0 self . modo = 0  if self . modo :              self . msg = <str> self . status = 1 return True   def calculo ( self ) :          entrada = self . kwargs [ <str> ] self . deltaP = unidades . DeltaP ( self . kwargs [ <str> ] ) self . HeatCalc = unidades . Power ( self . kwargs [ <str> ] ) if self . kwargs [ <str> ] :              Tout = unidades . Temperature ( self . kwargs [ <str> ] )  elif self . kwargs [ <str> ] :              Tout = unidades . Temperature ( entrada . T + self . kwargs [ <str> ] )  A = unidades . Area ( self . kwargs [ <str> ] ) U = unidades . HeatTransfCoef ( self . kwargs [ <str> ] ) Text = unidades . Temperature ( self . kwargs [ <str> ] ) if self . modo == 1 :              self . salida = [ entrada . clone ( T = Tout , P = entrada . P - self . deltaP ) ] self . HeatCalc = unidades . Power ( self . salida [ 0 ] . h - entrada . h )  else :              if self . modo == 2 :                  self . HeatCalc = unidades . Power ( 0 )  else :                  self . HeatCalc = unidades . Power ( A * U * ( Text - entrada . T ) )  def f ( ) :                  output = entrada . clone ( T = T , P = entrada . P - self . deltaP ) return output . h - entrada . h - self . HeatCalc  T = fsolve ( f , entrada . T ) [ 0 ] if T > max ( Text , entrada . T ) or T < min ( Text , entrada . T ) :                  T = self . Text  self . salida = [ entrada . clone ( T = T , P = entrada . P - self . deltaP ) ]  self . Tin = entrada . T self . ToutCalc = self . salida [ 0 ] . T self . deltaT = unidades . DeltaT ( self . ToutCalc - entrada . T )  def propTxt ( self ) :          txt = <str> txt += QApplication . translate ( <str> , <str> ) txt += <str> + os . linesep txt += self . propertiesToText ( range ( 5 ) ) return txt  @ classmethod def propertiesEquipment ( cls ) :          l = [ ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Temperature ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Temperature ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . DeltaT ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . DeltaP ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Power ) ] return l  def writeStatetoJSON ( self , state ) :          state [ <str> ] = self . Tin state [ <str> ] = self . ToutCalc state [ <str> ] = self . deltaT state [ <str> ] = self . deltaP state [ <str> ] = self . HeatCalc  def readStatefromJSON ( self , state ) :          self . Tin = unidades . Temperature ( state [ <str> ] ) self . ToutCalc = unidades . Temperature ( state [ <str> ] ) self . deltaT = unidades . DeltaT ( state [ <str> ] ) self . deltaP = unidades . DeltaP ( state [ <str> ] ) self . HeatCalc = unidades . Power ( state [ <str> ] ) self . salida = [ None ]   class Fired_Heater ( equipment ) :      title = QApplication . translate ( <str> , <str> ) help = os . environ [ <str> ] + <str> kwargs = { <str> : None , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 1.3 , <str> : 0.0 , <str> : 0.0 , <str> : 0 , <str> : 0 , <str> : 0 , <str> : 0 , <str> : 0.0 } kwargsInput = ( <str> , ) kwargsValue = ( <str> , <str> , <str> , <str> , <str> , <str> ) kwargsList = ( <str> , <str> , <str> , <str> ) calculateValue = ( <str> , <str> ) calculateCostos = ( <str> , <str> ) indiceCostos = 3 salida = [ None ] TEXT_TIPO = [ QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) ] TEXT_SUBTIPOBOX = [ QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) ] TEXT_SUBTIPOCYLINDRICAL = [ QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) ] TEXT_MATERIAL = [ QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) ] @ property def isCalculable ( self ) :          if self . kwargs [ <str> ] and self . kwargs [ <str> ] and self . kwargs [ <str> ] :              self . statusCoste = True  else :              self . statusCoste = False  if not self . kwargs [ <str> ] :              self . msg = QApplication . translate ( <str> , <str> ) self . status = 0 return  if not self . kwargs [ <str> ] :              self . msg = QApplication . translate ( <str> , <str> ) self . status = 0 return  if self . kwargs [ <str> ] <= self . kwargs [ <str> ] . T :              self . msg = QApplication . translate ( <str> , <str> ) self . status = 0 return  if not self . kwargs [ <str> ] :              self . msg = QApplication . translate ( <str> , <str> ) self . status = 3 return True  if not self . kwargs [ <str> ] :              self . msg = QApplication . translate ( <str> , <str> ) self . status = 3 return True  self . msg = <str> self . status = 1 return True  def calculo ( self ) :          entrada = self . kwargs [ <str> ] self . Tout = unidades . Temperature ( self . kwargs [ <str> ] ) self . deltaP = unidades . DeltaP ( self . kwargs [ <str> ] ) self . Hmax = unidades . Power ( self . kwargs [ <str> ] ) if self . kwargs [ <str> ] :              eficiencia = self . kwargs [ <str> ]  else :              eficiencia = 0.75  if self . kwargs [ <str> ] :              poderCalorifico = self . kwargs [ <str> ]  else :              poderCalorifico = 900  salida = entrada . clone ( T = self . Tout , P = entrada . P - self . deltaP ) Ho = entrada . h H1 = salida . h Heat = unidades . Power ( H1 - Ho ) if self . Hmax and Heat > self . Hmax :              self . Heat = unidades . Power ( self . Hmax ) To = ( entrada . T + self . Tout ) / 2 T = fsolve ( lambda T : entrada . clone ( T = T , P = entrada . P - self . deltaP ) . h - Ho - self . Hmax , To ) [ 0 ] self . salida = [ entrada . clone ( T = T , P = entrada . P - self . deltaP ) ]  else :              self . Heat = Heat self . salida = [ salida ]  fuel = self . Heat . Btuh / poderCalorifico / eficiencia self . CombustibleRequerido = unidades . VolFlow ( fuel , <str> ) self . deltaT = unidades . DeltaT ( self . salida [ 0 ] . T - entrada . T ) self . eficiencia = unidades . Dimensionless ( eficiencia ) self . poderCalorifico = unidades . Dimensionless ( poderCalorifico ) self . Tin = entrada . T self . Tout = self . salida [ 0 ] . T  def coste ( self ) :          if self . kwargs [ <str> ] :              P_dis = unidades . Pressure ( self . kwargs [ <str> ] )  else :              P_dis = self . kwargs [ <str> ] . P  CI = self . kwargs [ <str> ] BI = self . kwargs [ <str> ] if self . kwargs [ <str> ] == 0 :              k = [ 25.5 , 33.8 , 45. ] [ self . kwargs [ <str> ] ] Fd = [ 0 , 0.1 , 0.35 ] [ self . kwargs [ <str> ] ] if P_dis . psi <= 500 :                  Fp = 0  elif P_dis . psi <= 1000 :                  Fp = 0.1  elif P_dis . psi <= 1500 :                  Fp = 0.15  elif P_dis . psi <= 2000 :                  Fp = 0.25  elif P_dis . psi <= 2500 :                  Fp = 0.4  else :                  Fp = 0.6  C = k * ( 1 + Fd + Fp ) * self . Heat . MBtuh ** 0.86 * 1000  else :              k = [ 27.3 , 40.2 , 42. ] [ self . kwargs [ <str> ] ] Fd = [ 0 , 0.33 ] [ self . kwargs [ <str> ] ] if P_dis . psi <= 500 :                  Fp = 0  elif P_dis . psi <= 1000 :                  Fp = 0.15  else :                  Fp = 0.2  C = k * ( 1 + Fd + Fp ) * self . Heat . MBtuh ** 0.82 * 1000  self . P_dis = P_dis self . C_adq = unidades . Currency ( C * CI / BI ) self . C_inst = unidades . Currency ( self . C_adq * self . kwargs [ <str> ] )  def propTxt ( self ) :          txt = <str> txt += QApplication . translate ( <str> , <str> ) txt += <str> + os . linesep txt += self . propertiesToText ( range ( 5 ) ) stimated = <str> % QApplication . translate ( <str> , <str> ) txt += self . propertiesToText ( 5 , kwCheck = True , kwSuffix = stimated , kwKey = <str> , kwValue = 0.0 ) txt += self . propertiesToText ( 6 , kwCheck = True , kwSuffix = stimated , kwKey = <str> , kwValue = 0.0 ) txt += self . propertiesToText ( 7 ) if self . statusCoste :              txt += os . linesep + <str> txt += QApplication . translate ( <str> , <str> ) txt += <str> + os . linesep txt += self . propertiesToText ( range ( 8 , 18 ) )  return txt  @ classmethod def propertiesEquipment ( cls ) :          l = [ ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Temperature ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Temperature ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . DeltaT ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . DeltaP ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Power ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Dimensionless ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Dimensionless ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . VolFlow ) , ( QApplication . translate ( <str> , <str> ) , <str> , float ) , ( QApplication . translate ( <str> , <str> ) , <str> , float ) , ( QApplication . translate ( <str> , <str> ) , <str> , float ) , ( QApplication . translate ( <str> , <str> ) , ( <str> , <str> ) , str ) , ( QApplication . translate ( <str> , <str> ) , ( <str> , <str> ) , str ) , ( QApplication . translate ( <str> , <str> ) , ( <str> , <str> ) , str ) , ( QApplication . translate ( <str> , <str> ) , ( <str> , <str> ) , str ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Pressure ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Currency ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Currency ) ] return l  def writeStatetoJSON ( self , state ) :          state [ <str> ] = self . Tout state [ <str> ] = self . deltaP state [ <str> ] = self . Hmax state [ <str> ] = self . Heat state [ <str> ] = self . CombustibleRequerido state [ <str> ] = self . deltaT state [ <str> ] = self . eficiencia state [ <str> ] = self . poderCalorifico state [ <str> ] = self . Tin state [ <str> ] = self . statusCoste if self . statusCoste :              state [ <str> ] = self . P_dis state [ <str> ] = self . C_adq state [ <str> ] = self . C_inst   def readStatefromJSON ( self , state ) :          self . Tout = unidades . Temperature ( state [ <str> ] ) self . deltaP = unidades . DeltaP ( state [ <str> ] ) self . Hmax = unidades . Power ( state [ <str> ] ) self . Heat = unidades . Power ( state [ <str> ] ) self . CombustibleRequerido = unidades . VolFlow ( state [ <str> ] ) self . deltaT = unidades . DeltaT ( state [ <str> ] ) self . eficiencia = unidades . Dimensionless ( state [ <str> ] ) self . poderCalorifico = unidades . Dimensionless ( state [ <str> ] ) self . Tin = unidades . Temperature ( state [ <str> ] ) self . statusCoste = state [ <str> ] if self . statusCoste :              self . P_dis = unidades . Pressure ( state [ <str> ] ) self . C_adq = unidades . Currency ( state [ <str> ] ) self . C_inst = unidades . Currency ( state [ <str> ] )  self . salida = [ None ]   class Hairpin ( equipment ) :      title = QApplication . translate ( <str> , <str> ) help = <str> kwargs = { <str> : None , <str> : None , <str> : 0 , <str> : 0 , <str> : 0 , <str> : 0 , <str> : 0 , <str> : 0 , <str> : 0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 0 , <str> : 0.0 , <str> : - 1.0 , <str> : 0.0 , <str> : - 1.0 , <str> : 3. , <str> : 0.0 , <str> : 0.0 , <str> : 0 , <str> : 0 } kwargsInput = ( <str> , <str> ) kwargsValue = ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) kwargsList = ( <str> , <str> , <str> ) kwargsCheck = ( <str> , ) calculateValue = ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) calculateCostos = ( <str> , <str> ) indiceCostos = 2 TEXT_MODO = [ QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) ] TEXT_FLUJO = [ QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) ] TEXT_ORIENTACION = [ QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) ] TEXT_MATERIAL = [ QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) ] CODE_FLUJO = ( <str> , <str> ) @ property def isCalculable ( self ) :          self . status = 1 self . msg = <str> if self . kwargs [ <str> ] and self . kwargs [ <str> ] and self . kwargs [ <str> ] :              self . statusCoste = True  else :              self . statusCoste = False  if not self . kwargs [ <str> ] :              self . msg = QApplication . translate ( <str> , <str> ) self . status = 0 return  if not self . kwargs [ <str> ] :              self . msg = QApplication . translate ( <str> , <str> ) self . status = 0 return  if not self . kwargs [ <str> ] :              self . msg = QApplication . translate ( <str> , <str> ) self . status = 0 return  self . statusPipe = 0 if self . kwargs [ <str> ] and self . kwargs [ <str> ] :              self . statusPipe = 1  elif self . kwargs [ <str> ] and self . kwargs [ <str> ] :              self . statusPipe = 2  elif self . kwargs [ <str> ] and self . kwargs [ <str> ] :              self . statusPipe = 3  else :              self . msg = QApplication . translate ( <str> , <str> ) self . status = 0 return  if not self . kwargs [ <str> ] :              self . msg = QApplication . translate ( <str> , <str> ) self . status = 0 return  self . statusFinned = 0 self . tubefinned = QApplication . translate ( <str> , <str> ) if self . kwargs [ <str> ] :              self . tubefinned = QApplication . translate ( <str> , <str> ) if self . kwargs [ <str> ] and ( self . kwargs [ <str> ] or self . kwargs [ <str> ] ) :                  self . statusFinned = 1 self . msg = <str>  else :                  self . msg = QApplication . translate ( <str> , <str> ) self . status = 3   if self . kwargs [ <str> ] :              if not self . kwargs [ <str> ] :                  self . msg = QApplication . translate ( <str> , <str> ) self . status = 0 return   else :              self . statusOut = 0 o1 = self . kwargs [ <str> ] or self . kwargs [ <str> ] != - 1 o2 = self . kwargs [ <str> ] or self . kwargs [ <str> ] != - 1 if o1 and o2 :                  self . statusOut = 1  elif o1 :                  self . statusOut = 2  elif o2 :                  self . statusOut = 3  else :                  self . msg = QApplication . translate ( <str> , <str> ) self . status = 0 return   return True  def calculo ( self ) :          if self . kwargs [ <str> ] :              self . flujo = <str>  else :              self . flujo = <str>  if self . statusPipe == 1 :              self . De = unidades . Length ( self . kwargs [ <str> ] ) self . Di = unidades . Length ( self . kwargs [ <str> ] ) self . w = unidades . Length ( ( self . De - self . Di ) / 2 ) if self . kwargs [ <str> ] and w != self . kwargs [ <str> ] :                  self . msg = QApplication . translate ( <str> , <str> ) self . status = 3   elif self . statusPipe == 2 :              self . De = unidades . Length ( self . kwargs [ <str> ] ) self . w = unidades . Length ( self . kwargs [ <str> ] ) self . Di = unidades . Length ( self . De - w * 2 )  else :              self . Di = unidades . Length ( self . kwargs [ <str> ] ) self . w = unidades . Length ( self . kwargs [ <str> ] ) self . De = unidades . Length ( self . Di + w * 2 )  self . Dee = unidades . Length ( self . kwargs [ <str> ] ) self . rugosidad = unidades . Length ( self . kwargs [ <str> ] ) self . k = unidades . ThermalConductivity ( self . kwargs [ <str> ] ) self . fi = unidades . Fouling ( self . kwargs [ <str> ] ) self . fo = unidades . Fouling ( self . kwargs [ <str> ] ) if self . kwargs [ <str> ] :              self . rating ( )  else :              self . design ( )  eD = unidades . Dimensionless ( self . kwargs [ <str> ] / self . Di ) f = f_friccion ( self . ReTube , eD ) dp_tube = self . L * self . VTube ** 2 / self . Di * f * self . rhoTube / 2 self . deltaPTube = unidades . DeltaP ( dp_tube ) f_a = f_friccion ( self . ReAnnulli , geometry = 6 ) dp_annulli = self . L * self . VAnnulli ** 2 / self . De * f_a * self . rhoAnnulli / 2 self . deltaPAnnulli = unidades . DeltaP ( dp_annulli ) self . salida = [ self . outTube . clone ( P = self . outTube . P - self . deltaPTube ) , self . outAnnulli . clone ( P = self . outAnnulli . P - self . deltaPAnnulli ) ] self . ToutTube = self . salida [ 0 ] . T self . ToutAnnulli = self . salida [ 1 ] . T self . XoutTube = self . salida [ 0 ] . x self . XoutAnnulli = self . salida [ 1 ] . x self . TinTube = self . kwargs [ <str> ] . T self . XinTube = self . kwargs [ <str> ] . x self . TinAnnulli = self . kwargs [ <str> ] . T self . XinAnnulli = self . kwargs [ <str> ] . x  def rating ( self ) :          inTube = self . kwargs [ <str> ] inAnnulli = self . kwargs [ <str> ] self . L = unidades . Length ( self . kwargs [ <str> ] ) if self . kwargs [ <str> ] == 0 :              self . phaseTube = self . ThermalPhase ( inTube , inTube ) self . phaseAnnulli = self . ThermalPhase ( inAnnulli , inAnnulli ) Ci = inTube . Liquido . cp * inTube . caudalmasico Co = inAnnulli . Liquido . cp * inAnnulli . caudalmasico Cmin = min ( Ci , Co ) Cmax = max ( Ci , Co ) C_ = Cmin / Cmax self . A = unidades . Area ( self . L * pi * self . De ) hi = self . _hTube ( inTube ) ho = self . _hAnnulli ( inAnnulli ) ni , no = self . rendimientoAletas ( hi , ho ) self . Ug ( hi , ni , ho , no ) NTU = self . A * self . U / Cmin ep = efectividad ( NTU , C_ , self . CODE_FLUJO [ self . kwargs [ <str> ] ] ) self . Q = unidades . Power ( ep * Cmin * abs ( inTube . T - inAnnulli . T ) ) if inTube . T > inAnnulli . T :                  QTube = self . Q QAnnulli = - self . Q  else :                  QTube = - self . Q QAnnulli = self . Q  def f ( T ) :                  return inTube . clone ( T = T ) . h - inTube . h + QTube  T = fsolve ( f , inTube . T ) [ 0 ] self . outTube = inTube . clone ( T = T ) def f ( T ) :                  return inAnnulli . clone ( T = T ) . h - inAnnulli . h + QAnnulli  T = fsolve ( f , inAnnulli . T ) [ 0 ] self . outAnnulli = inAnnulli . clone ( T = T )   def design ( self ) :          inTube = self . kwargs [ <str> ] inAnnulli = self . kwargs [ <str> ] if self . kwargs [ <str> ] == 0 :              if self . statusOut == 1 :                  if self . kwargs [ <str> ] :                      self . outTube = inTube . clone ( T = self . kwargs [ <str> ] )  else :                      self . outTube = inTube . clone ( x = self . kwargs [ <str> ] )  if self . kwargs [ <str> ] :                      Tout = self . kwargs [ <str> ] self . outAnnulli = inAnnulli . clone ( T = Tout )  else :                      Xout = self . kwargs [ <str> ] self . outAnnulli = inAnnulli . clone ( x = Xout )  Qo = abs ( self . outAnnulli . h - inAnnulli . h ) Qi = abs ( self . outTube . h - inTube . h ) self . Q = unidades . Power ( ( Qo + Qi ) / 2. )  elif self . statusOut == 2 :                  if self . kwargs [ <str> ] :                      self . outTube = inTube . clone ( T = self . kwargs [ <str> ] )  else :                      self . outTube = inTube . clone ( x = self . kwargs [ <str> ] )  Qi = abs ( self . outTube . h - inTube . h ) self . Q = unidades . Power ( Qi ) def f ( T ) :                      return inAnnulli . clone ( T = T ) . h - inAnnulli . h - Qi  T = fsolve ( f , inAnnulli . T ) [ 0 ] self . outAnnulli = inAnnulli . clone ( T = T )  elif self . statusOut == 3 :                  if self . kwargs [ <str> ] :                      Tout = self . kwargs [ <str> ] self . outAnnulli = inAnnulli . clone ( T = Tout )  else :                      Xout = self . kwargs [ <str> ] self . outAnnulli = inAnnulli . clone ( x = Xout )  Qo = abs ( self . outAnnulli . h - inAnnulli . h ) self . Q = unidades . Power ( Qo ) def f ( T ) :                      return inTube . clone ( T = T ) . h - inTube . h - Qi  T = fsolve ( f , inTube . T ) [ 0 ] self . outTube = inTube . clone ( T = T )  self . phaseTube = self . ThermalPhase ( inTube , self . outTube ) self . phaseAnnulli = self . ThermalPhase ( inAnnulli , self . outAnnulli ) fluidTube = inTube . clone ( T = ( inTube . T + self . outTube . T ) / 2. ) T = ( inAnnulli . T + self . outAnnulli . T ) / 2. fluidAnnulli = inAnnulli . clone ( T = T ) hi = self . _hTube ( fluidTube ) ho = self . _hAnnulli ( fluidAnnulli ) ni , no = self . rendimientoAletas ( hi , ho ) self . Ug ( hi , ni , ho , no ) if self . kwargs [ <str> ] :                  DTin = abs ( inAnnulli . T - inTube . T ) DTout = abs ( self . kwargs [ <str> ] - self . kwargs [ <str> ] )  else :                  DTin = abs ( self . kwargs [ <str> ] - inAnnulli . T ) DTout = abs ( self . kwargs [ <str> ] - inTube . T )  if DTin == DTout :                  DTm = DTin  else :                  DTm = ( DTin - DTout ) / log ( DTin / DTout )   self . A = unidades . Area ( self . Q / self . U / DTm ) self . L = unidades . Length ( self . A / 2 / pi )  def Ug ( self , hi , ni , ho , no ) :          Ui = self . De / self . Di / hi / ni Ufi = self . De * self . fi / self . Di / ni k = self . De * log ( self . De / self . Di ) / 2 / self . k U = 1 / ( Ui + Ufi + k + self . fo / no + 1 / ho / no ) Uc = 1 / ( Ui + k + 1 / ho / no ) self . hTube = unidades . HeatTransfCoef ( hi ) self . hAnnulli = unidades . HeatTransfCoef ( ho ) self . U = unidades . HeatTransfCoef ( U ) self . CF = unidades . Dimensionless ( U / Uc ) self . OS = unidades . Dimensionless ( Uc * ( self . fi + self . fo ) )  def ThermalPhase ( self , input , output ) :          if input . x == output . x :              if input . x == 0 :                  phase = <str>  else :                  phase = <str>   elif input . x < output . x :              phase = <str>  else :              phase = <str>  return phase  def rendimientoAletas ( self , hi , ho ) :          self . hFin = unidades . Length ( self . kwargs [ <str> ] ) self . thicknessBaseFin = unidades . Length ( self . kwargs [ <str> ] ) self . thicknessTopFin = unidades . Length ( self . kwargs [ <str> ] ) self . rootDoFin = unidades . Length ( self . kwargs [ <str> ] ) self . kFin = unidades . ThermalConductivity ( self . kwargs [ <str> ] ) self . nFin = unidades . Dimensionless ( self . kwargs [ <str> ] ) if self . kwargs [ <str> ] :              if self . statusFinned :                  do = self . kwargs [ <str> ] D = do + self . kwargs [ <str> ] * 2 phi = ( D / do - 1 ) * ( 1 + 0.35 * log ( D / do ) ) w_b = self . kwargs [ <str> ] w_t = self . kwargs [ <str> ] if w_b and w_t :                      delta = ( w_b + w_t ) / 2  else :                      delta = w_b + w_t  if self . kwargs [ <str> ] :                      kf = self . kwargs [ <str> ]  else :                      kf = self . kwargs [ <str> ]  X = phi * do / 2 * sqrt ( 2 * ho / kf / delta ) no = tanh ( X ) / X  else :                  no = 1  ni = 1  else :              ni = 1 no = 1  return ni , no  def _hTube ( self , fluidTube ) :          if self . phaseTube [ : 6 ] == <str> :              if fluidTube . x == 0 :                  fluido = fluidTube . Liquido  else :                  fluido = fluidTube . Vapor  rho_i = fluido . rho mu = fluido . mu k = fluido . k v_i = fluidTube . Q * 4 / pi / self . Di ** 2 re_i = Re ( D = self . Di , V = v_i , rho = rho_i , mu = mu ) self . VTube = unidades . Speed ( v_i ) self . rhoTube = rho_i self . ReTube = unidades . Dimensionless ( re_i ) pr = fluido . Prandt if re_i < 2300 :                  L = self . L cp = fluido . cp w = fluido . caudalmasico gz = Gz ( w = w , cp = cp , k = k , L = L ) beta = fluido . alfav gr = Gr ( beta = beta , T = fluidTube . T , To = fluidTube . T , L = L , mu = mu ) if self . kwargs [ <str> ] == 0 :                      Nu = h_tubeside_laminar_Eubank_Proctor ( Pr = pr , Gz = gz , Gr = gr , D = self . Di , L = L )  elif self . kwargs [ <str> ] == 1 :                      Nu = h_tubeside_laminar_VDI ( Re = re_i , Pr = pr , D = self . Di , L = L )  elif self . kwargs [ <str> ] == 2 :                      Nu = h_tubeside_laminar_Hausen ( Gz = gz )  elif self . kwargs [ <str> ] == 3 :                      Nu = h_tubeside_laminar_Sieder_Tate ( Gz = gz , Gr = gr )   else :                  if self . kwargs [ <str> ] == 0 :                      Nu = h_tubeside_turbulent_Sieder_Tate ( Re = re_i , Pr = pr )  elif self . kwargs [ <str> ] == 1 :                      Nu = h_tubeside_turbulent_Colburn ( Re = re_i , Pr = pr )  elif self . kwargs [ <str> ] == 2 :                      frio = self . kwargs [ <str> ] . T > fluidTube . T Nu = h_tubeside_turbulent_Dittus_Boelter ( Re = re_i , Pr = pr , calentamiento = frio )  elif self . kwargs [ <str> ] == 3 :                      Nu = h_tubeside_turbulent_ESDU ( Re = re_i , Pr = pr )  elif self . kwargs [ <str> ] == 4 :                      Nu = h_tubeside_turbulent_Gnielinski ( Re = re_i , Pr = pr , D = self . Di , L = L )  elif self . kwargs [ <str> ] == 5 :                      line = self . kwargs [ <str> ] == 3 filas = self . kwargs [ <str> ] ** 0.5 Nu = h_tubeside_turbulent_VDI ( Re = re_i , Pr = pr , filas_tubos = filas , alineados = line )    if self . phaseTube == <str> :              if self . kwargs [ <str> ] == 0 :                  if 0 < fluidTube . x < 1 :                      X_lockhart = ( ( 1 - fluidTube . x ) / fluidTube . x ) ** 0.9 * ( fluidTube . Vapor . rho / fluidTube . Liquido . rho ) ** 0.5 * ( fluidTube . Liquido . mu / fluidTube . Vapor . mu ) ** 0.1 G = fluidTube . caudalmasico * 4 / pi / self . Di ** 2 j = fluidTube . x * G / ( g * self . Di * fluidTube . Vapor . rho * ( fluidTube . Liquido . rho - fluidTube . Vapor . rho ) ) ** 0.5 print ( ( j , X_lockhart ) )   else :                  pass   return unidades . HeatTransfCoef ( Nu * k / self . Di )  def _hAnnulli ( self , fluidAnnulli ) :          a = self . Dee / self . De dh = self . Dee - self . De rho = fluidAnnulli . Liquido . rho mu = fluidAnnulli . Liquido . mu k = fluidAnnulli . Liquido . k v = fluidAnnulli . Q * 4 / pi / ( self . Dee ** 2 - self . De ** 2 ) re = Re ( D = dh , V = v , rho = rho , mu = mu ) self . VAnnulli = unidades . Speed ( v ) self . rhoAnnulli = rho self . ReAnnulli = unidades . Dimensionless ( re ) pr = fluidAnnulli . Liquido . Prandt if re <= 2300 :              Nu = h_anulli_Laminar ( re , pr , a )  elif re >= 1e4 :              Nu = h_anulli_Turbulent ( re , pr , a )  else :              Nu = h_anulli_Transition ( re , pr , a )  return unidades . HeatTransfCoef ( Nu * k / self . Di )  def coste ( self ) :          self . material = self . kwargs [ <str> ] CI = self . kwargs [ <str> ] BI = self . kwargs [ <str> ] if self . kwargs [ <str> ] :              self . P_dis = unidades . Pressure ( self . kwargs [ <str> ] )  else :              self . P_dis = max ( self . kwargs [ <str> ] . P , self . kwargs [ <str> ] . P )  Pd = self . P_dis . psi Fm = [ 1. , 1.9 , 2.2 ] [ self . kwargs [ <str> ] ] if Pd < 4 :              Fp = 1.  elif Pd < 6 :              Fp = 1.1  else :              Fp = 1.25  C = Fm * Fp * 900 * self . A . ft2 ** 0.18 self . C_adq = unidades . Currency ( C * CI / BI ) self . C_inst = unidades . Currency ( self . C_adq * self . kwargs [ <str> ] )  def propTxt ( self ) :          txt = <str> txt += QApplication . translate ( <str> , <str> ) txt += <str> + os . linesep txt += self . propertiesToText ( range ( 11 ) ) if self . kwargs [ <str> ] :              txt += <str> + self . propertiesToText ( range ( 11 , 17 ) )  txt += os . linesep + <str> txt += QApplication . translate ( <str> , <str> ) txt += <str> + os . linesep txt += self . propertiesToText ( range ( 17 , 20 ) ) + os . linesep txt += self . propertiesToText ( range ( 20 , 29 ) ) + os . linesep txt += self . propertiesToText ( range ( 29 , 38 ) ) + os . linesep txt += self . propertiesToText ( range ( 38 , 41 ) ) + os . linesep if self . statusCoste :              txt += os . linesep + <str> txt += QApplication . translate ( <str> , <str> ) txt += <str> + os . linesep txt += self . propertiesToText ( range ( 41 , 48 ) )  return txt  @ classmethod def propertiesEquipment ( cls ) :          l = [ ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Length ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Length ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Length ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Length ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Length ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Length ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Area ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . ThermalConductivity ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Fouling ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Fouling ) , ( QApplication . translate ( <str> , <str> ) , <str> , str ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Length ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Length ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Length ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Length ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . ThermalConductivity ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Dimensionless ) , ( QApplication . translate ( <str> , <str> ) , ( <str> , <str> ) , str ) , ( QApplication . translate ( <str> , <str> ) , ( <str> , <str> ) , str ) , ( QApplication . translate ( <str> , <str> ) , ( <str> , <str> ) , str ) , ( QApplication . translate ( <str> , <str> ) , <str> , str ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Speed ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Dimensionless ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Temperature ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Dimensionless ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Temperature ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Dimensionless ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . DeltaP ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . HeatTransfCoef ) , ( QApplication . translate ( <str> , <str> ) , <str> , str ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Speed ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Dimensionless ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Temperature ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Dimensionless ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Temperature ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Dimensionless ) , ( QApplication . translate ( <str> , <str> , None ) , <str> , unidades . DeltaP ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . HeatTransfCoef ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . HeatTransfCoef ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Dimensionless ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Dimensionless ) , ( QApplication . translate ( <str> , <str> ) , <str> , float ) , ( QApplication . translate ( <str> , <str> ) , <str> , float ) , ( QApplication . translate ( <str> , <str> ) , <str> , float ) , ( QApplication . translate ( <str> , <str> ) , ( <str> , <str> ) , str ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Pressure ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Currency ) , ( QApplication . translate ( <str> , <str> ) , <str> , unidades . Currency ) ] return l  def writeStatetoJSON ( self , state ) :          state [ <str> ] = self . L state [ <str> ] = self . Di state [ <str> ] = self . De state [ <str> ] = self . Dee state [ <str> ] = self . w state [ <str> ] = self . rugosidad state [ <str> ] = self . A state [ <str> ] = self . k state [ <str> ] = self . fi state [ <str> ] = self . fo state [ <str> ] = self . tubefinned state [ <str> ] = self . hFin state [ <str> ] = self . thicknessBaseFin state [ <str> ] = self . thicknessTopFin state [ <str> ] = self . rootDoFin state [ <str> ] = self . kFin state [ <str> ] = self . nFin state [ <str> ] = self . phaseTube state [ <str> ] = self . VTube state [ <str> ] = self . ReTube state [ <str> ] = self . TinTube state [ <str> ] = self . XinTube state [ <str> ] = self . ToutTube state [ <str> ] = self . XoutTube state [ <str> ] = self . deltaPTube state [ <str> ] = self . hTube state [ <str> ] = self . phaseAnnulli state [ <str> ] = self . VAnnulli state [ <str> ] = self . ReAnnulli state [ <str> ] = self . TinAnnulli state [ <str> ] = self . XinAnnulli state [ <str> ] = self . ToutAnnulli state [ <str> ] = self . XoutAnnulli state [ <str> ] = self . deltaPAnnulli state [ <str> ] = self . hAnnulli state [ <str> ] = self . U state [ <str> ] = self . CF state [ <str> ] = self . OS state [ <str> ] = self . statusCoste if self . statusCoste :              state [ <str> ] = self . P_dis state [ <str> ] = self . C_adq state [ <str> ] = self . C_inst   def readStatefromJSON ( self , state ) :          self . L = unidades . Length ( state [ <str> ] ) self . Di = unidades . Length ( state [ <str> ] ) self . De = unidades . Length ( state [ <str> ] ) self . Dee = unidades . Length ( state [ <str> ] ) self . w = unidades . Length ( state [ <str> ] ) self . rugosidad = unidades . Length ( state [ <str> ] ) self . A = unidades . Area ( state [ <str> ] ) self . k = unidades . ThermalConductivity ( state [ <str> ] ) self . fi = unidades . Fouling ( state [ <str> ] ) self . fo = unidades . Fouling ( state [ <str> ] ) self . tubefinned = state [ <str> ] self . hFin = unidades . Length ( state [ <str> ] ) self . thicknessBaseFin = unidades . Length ( state [ <str> ] ) self . thicknessTopFin = unidades . Length ( state [ <str> ] ) self . rootDoFin = unidades . Length ( state [ <str> ] ) self . kFin = unidades . ThermalConductivity ( state [ <str> ] ) self . nFin = unidades . Dimensionless ( state [ <str> ] ) self . phaseTube = state [ <str> ] self . VTube = unidades . Speed ( state [ <str> ] ) self . ReTube = unidades . Dimensionless ( state [ <str> ] ) self . TinTube = unidades . Temperature ( state [ <str> ] ) self . XinTube = unidades . Dimensionless ( state [ <str> ] ) self . ToutTube = unidades . Temperature ( state [ <str> ] ) self . XoutTube = unidades . Dimensionless ( state [ <str> ] ) self . deltaPTube = unidades . DeltaP ( state [ <str> ] ) self . hTube = unidades . HeatTransfCoef ( state [ <str> ] ) self . phaseAnnulli = state [ <str> ] self . VAnnulli = unidades . Speed ( state [ <str> ] ) self . ReAnnulli = unidades . Dimensionless ( state [ <str> ] ) self . TinAnnulli = unidades . Temperature ( state [ <str> ] ) self . XinAnnulli = unidades . Dimensionless ( state [ <str> ] ) self . ToutAnnulli = unidades . Temperature ( state [ <str> ] ) self . XoutAnnulli = unidades . Dimensionless ( state [ <str> ] ) self . deltaPAnnulli = unidades . DeltaP ( state [ <str> ] ) self . hAnnulli = unidades . HeatTransfCoef ( state [ <str> ] ) self . U = unidades . HeatTransfCoef ( state [ <str> ] ) self . CF = unidades . Dimensionless ( state [ <str> ] ) self . OS = unidades . Dimensionless ( state [ <str> ] ) self . statusCoste = state [ <str> ] if self . statusCoste :              self . P_dis = unidades . Pressure ( state [ <str> ] ) self . C_adq = unidades . Currency ( state [ <str> ] ) self . C_inst = unidades . Currency ( state [ <str> ] )  self . salida = [ None ]   class Shell_Tube ( equipment ) :      title = QApplication . translate ( <str> , <str> ) help = <str> kwargs = { <str> : [ ] , <str> : None , <str> : None , <str> : 0 , <str> : 0 , <str> : 0 , <str> : 0 , <str> : 0 , <str> : 0 , <str> : 0 , <str> : 0 , <str> : 0 , <str> : 0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 0 , <str> : 0 , <str> : 0 , <str> : 0 , <str> : 0.0 , <str> : 0.0 , <str> : 0 , <str> : 0 , <str> : 0.0 , <str> : 0.0 , <str> : 0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 0 , <str> : 0.0 , <str> : 0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 0.0 , <str> : 0 , <str> : 3. , <str> : 0.0 , <str> : 0.0 , <str> : 0 , <str> : 0 , <str> : 0.0 } indiceCostos = 2 TEXT_METHOD_TUBE_LAMINAR = [ <str> , <str> , <str> , <str> ] TEXT_METHOD_TUBE_TURBULENT = [ <str> , <str> , <str> , <str> , <str> , <str> ] TEXT_METHOD_SHELL = [ <str> , <str> , <str> ] TEXT_CLASS = [ <str> , <str> , <str> ] TEXT_FRONTHEAD = [ <str> + QApplication . translate ( <str> , <str> ) , <str> + QApplication . translate ( <str> , <str> ) , <str> + QApplication . translate ( <str> , <str> ) , <str> + QApplication . translate ( <str> , <str> ) , <str> + QApplication . translate ( <str> , <str> ) ] TEXT_SHELL = [ <str> + QApplication . translate ( <str> , <str> ) , <str> + QApplication . translate ( <str> , <str> ) , <str> + QApplication . translate ( <str> , <str> ) , <str> + QApplication . translate ( <str> , <str> ) , <str> + QApplication . translate ( <str> , <str> ) , <str> + QApplication . translate ( <str> , <str> ) , <str> + QApplication . translate ( <str> , <str> ) ] TEXT_REARHEAD = [ <str> + QApplication . translate ( <str> , <str> ) , <str> + QApplication . translate ( <str> , <str> ) , <str> + QApplication . translate ( <str> , <str> ) , <str> + QApplication . translate ( <str> , <str> ) , <str> + QApplication . translate ( <str> , <str> ) , <str> + QApplication . translate ( <str> , <str> ) , <str> + QApplication . translate ( <str> , <str> ) , <str> + QApplication . translate ( <str> , <str> ) ] TEXT_ORIENTATION = [ QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) ] TEXT_DISTRIBUTION_TUBE = [ QApplication . translate ( <str> , <str> ) + <str> , QApplication . translate ( <str> , <str> ) + <str> , QApplication . translate ( <str> , <str> ) + <str> , QApplication . translate ( <str> , <str> ) + <str> ] TEXT_BAFFLE_TYPE = [ QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) ] TEXT_COST_TYPE = [ QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) ] TEXT_COST_MATERIAL = [ QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) , QApplication . translate ( <str> , <str> ) ] @ property def isCalculable ( self ) :          if self . kwargs [ <str> ] and self . kwargs [ <str> ] and self . kwargs [ <str> ] :              self . statusCoste = True  else :              self . statusCoste = False  if not self . kwargs [ <str> ] :              self . msg = QApplication . translate ( <str> , <str> ) self . status = 0 return  if not self . kwargs [ <str> ] :              self . msg = QApplication . translate ( <str> , <str> ) self . status = 0 return  return True  def calculo ( self ) :          if self . kwargs [ <str> ] :              pass  else :              N = self . kwargs [ <str> ] De = unidades . Length ( self . kwargs [ <str> ] ) Di = unidades . Length ( De - 2 * self . kwargs [ <str> ] ) L = unidades . Length ( self . kwargs [ <str> ] ) rho = self . kwargs [ <str> ] . Liquido . rho mu = self . kwargs [ <str> ] . Liquido . mu cp = self . kwargs [ <str> ] . Liquido . cp k = self . kwargs [ <str> ] . Liquido . k w = self . kwargs [ <str> ] . Liquido . caudalmasico beta = self . kwargs [ <str> ] . Liquido . alfav v = self . kwargs [ <str> ] . Q / N * 4 / pi / Di re = Re ( D = Di , V = v , rho = rho , mu = mu ) pr = self . kwargs [ <str> ] . Liquido . Pr gz = Gz ( w = w , cp = cp , k = k , L = L ) gr = Gr ( beta = beta , T = self . kwargs [ <str> ] . T , To = self . kwargs [ <str> ] . T , L = L , mu = mu ) if re < 2300 :                  if self . kwargs [ <str> ] == 0 :                      Nu = h_tubeside_laminar_Eubank_Proctor ( Pr = pr , Gz = gz , Gr = gr , D = Di , L = L )  elif self . kwargs [ <str> ] == 1 :                      Nu = h_tubeside_laminar_VDI ( Re = re , Pr = pr , D = Di , L = L )  elif self . kwargs [ <str> ] == 2 :                      Nu = h_tubeside_laminar_Hausen ( Gz = gz )  elif self . kwargs [ <str> ] == 3 :                      Nu = h_tubeside_laminar_Sieder_Tate ( Gz = gz , Gr = gr )   else :                  if self . kwargs [ <str> ] == 0 :                      Nu = h_tubeside_turbulent_Sieder_Tate ( Re = re , Pr = pr )  elif self . kwargs [ <str> ] == 1 :                      Nu = h_tubeside_turbulent_Colburn ( Re = re , Pr = pr )  elif self . kwargs [ <str> ] == 2 :                      frio = self . kwargs [ <str> ] > self . kwargs [ <str> ] Nu = h_tubeside_turbulent_Dittus_Boelter ( Re = re , Pr = pr , calentamiento = frio )  elif self . kwargs [ <str> ] == 3 :                      Nu = h_tubeside_turbulent_ESDU ( Re = re , Pr = pr )  elif self . kwargs [ <str> ] == 4 :                      Nu = h_tubeside_turbulent_Gnielinski ( Re = re , Pr = pr , D = Di , L = L )  elif self . kwargs [ <str> ] == 5 :                      line = self . kwargs [ <str> ] == 3 filas = self . kwargs [ <str> ] ** 0.5 Nu = h_tubeside_turbulent_VDI ( Re = re , Pr = pr , filas_tubos = filas , alineados = line )   hi = unidades . HeatTransfCoef ( Nu * k / Di ) if self . kwargs [ <str> ] == 0 :                  h , DP = self . h_shellside_turbulent_Stream_Analysis ( )  elif self . kwargs [ <str> ] == 1 :                  self . h_shellside_turbulent_Bell_Delaware ( )  else :                  h = self . h_shelside_turbulent_Kern ( )  fi = self . kwargs [ <str> ] fo = self . kwargs [ <str> ]  self . area = unidades . Area ( 25 )  def fw ( self ) :          if self . kwargs [ <str> ] :              fw = self . kwargs [ <str> ] / self . kwargs [ <str> ] * ( ( self . kwargs [ <str> ] + 2 * self . kwargs [ <str> ] * self . kwargs [ <str> ] * ( self . kwargs [ <str> ] + self . kwargs [ <str> ] ) ) / ( self . kwargs [ <str> ] - self . kwargs [ <str> ] ) )  else :              fw = self . kwargs [ <str> ] / 2 / self . kwargs [ <str> ] * log ( self . kwargs [ <str> ] / ( self . kwargs [ <str> ] - 2 * self . kwargs [ <str> ] ) )  return fw  @ staticmethod def h_shellside_turbulent_Stream_Analysis ( ) :           def h_shellside_turbulent_Bell_Delaware ( self ) :          fi = 1 P = self . kwargs [ <str> ] / self . kwargs [ <str> ] mo = self . kwargs [ <str> ] . caudalmasico if self . kwargs [ <str> ] == 2 :              Ptef = self . kwargs [ <str> ] / 2 ** 0.5  else :              Ptef = self . kwargs [ <str> ]  if self . kwargs [ <str> ] < 3 :              tita_tp = unidades . Angle ( [ 30 , 45 , 60 ] [ self . kwargs [ <str> ] ] , <str> ) Pt_ = self . kwargs [ <str> ] * cos ( tita_tp )  else :              Pt_ = self . kwargs [ <str> ]  Nc = self . kwargs [ <str> ] * ( 1 - 2 * self . kwargs [ <str> ] ) / Pt_ Ncw = 0.8 * self . kwargs [ <str> ] * self . kwargs [ <str> ] / Pt_ Dotl = self . kwargs [ <str> ] - 2 * self . kwargs [ <str> ] Sm = self . kwargs [ <str> ] * ( self . kwargs [ <str> ] - Dotl + ( Dotl - self . kwargs [ <str> ] ) / Ptef * ( self . kwargs [ <str> ] - self . kwargs [ <str> ] ) ) G = mo / Sm Re = self . kwargs [ <str> ] * G / self . kwargs [ <str> ] . Liquido . mu Pr = self . kwargs [ <str> ] . Liquido . Pr rho = self . kwargs [ <str> ] . Liquido . rho cp = self . kwargs [ <str> ] . Liquido . cp Dctl = Dotl - self . kwargs [ <str> ] tita_ctl = 2 * arccos ( self . kwargs [ <str> ] * ( 1 - 2 * self . kwargs [ <str> ] ) / Dctl ) Fc = 1 + 1. / pi * ( sin ( tita_ctl ) - tita_ctl ) Fw = 1. / 2 / pi * ( tita_ctl - sin ( tita_ctl ) ) Stb = pi / 8 * ( ( self . kwargs [ <str> ] + 2 * self . kwargs [ <str> ] ) ** 2 - self . kwargs [ <str> ] ** 2 ) * self . kwargs [ <str> ] * ( 1 + Fc ) tita_ds = 2 * arccos ( 1 - 2 * self . kwargs [ <str> ] ) Ssb = self . kwargs [ <str> ] * self . kwargs [ <str> ] * ( pi - 0.5 * tita_ds ) Sb = self . kwargs [ <str> ] * ( self . kwargs [ <str> ] - Dotl ) Sw = 1. / 8 * self . kwargs [ <str> ] ** 2 * ( tita_ds - sin ( tita_ds ) ) - 1. / 4 * self . kwargs [ <str> ] * Fw * pi * self . kwargs [ <str> ] ** 2 Dw = 4 * Sw / ( pi * self . kwargs [ <str> ] * self . kwargs [ <str> ] * 0.5 * ( 1 - Fc ) + self . kwargs [ <str> ] * tita_ds ) Jc = 0.55 + 0.72 * Fc rs = Ssb / ( Ssb + Stb ) rl = ( Ssb + Stb ) / Sm Jl = 0.44 * ( 1 - rs ) + ( 1 - 0.44 * ( 1 - rs ) ) * exp ( - 2.2 * rl ) Rl = exp ( - 1.33 * ( 1 + rs ) * rl ** ( 0.8 - 0.15 * ( 1 + rs ) ) ) rss = self . kwargs [ <str> ] / Nc if rss < 0.5 :              if Re < 100 :                  Cj = 1.35 Cr = 4.5  else :                  Cj = 1.25 Cr = 3.7  Jb = exp ( - Cj * Sb / Sm * ( 1 - ( 2 * rss ) ** ( 1. / 3 ) ) ) Rb = exp ( - Cr * Sb / Sm * ( 1 - ( 2 * rss ) ** ( 1. / 3 ) ) )  else :              Jb = 1. Rb = 1.  if Re < 100 :              n1 = 1. / 3 n2 = 1.  else :              n1 = 0.6 n2 = 0.2  nb = self . kwargs [ <str> ] / self . kwargs [ <str> ] if self . kwargs [ <str> ] > self . kwargs [ <str> ] :              nb += 1  if self . kwargs [ <str> ] > self . kwargs [ <str> ] :              nb += 1  Js = ( nb - 1 + ( self . kwargs [ <str> ] / self . kwargs [ <str> ] ) ** ( 1 - n1 ) + ( self . kwargs [ <str> ] / self . kwargs [ <str> ] ) ** ( 1 - n1 ) ) / ( nb - 1 + ( self . kwargs [ <str> ] / self . kwargs [ <str> ] ) + self . kwargs [ <str> ] / self . kwargs [ <str> ] ) Rs = 0.5 * ( ( self . kwargs [ <str> ] / self . kwargs [ <str> ] ) ** ( 2 - n2 ) + ( self . kwargs [ <str> ] / self . kwargs [ <str> ] ) ** ( 2 - n2 ) ) Nct = ( nb + 1 ) * ( Nc + Ncw ) if Re <= 20 :              Jr = ( 10 / Nct ) ** 0.18  elif Re >= 100 :              Jr = 1.  else :              Jr = 0.853379 + 0.0014662 * Re  if self . kwargs [ <str> ] == 1 :              a3 , a4 = 0 , 0 if Re < 10 :                  a1 = 1.55 a2 = - 0.667  elif Re < 100 :                  a1 = 0.498 a2 = - 0.656  elif Re < 1000 :                  a1 = 0.73 a2 = - 0.500  elif Re < 10000 :                  a1 = 0.37 a2 = - 0.396  else :                  a1 = 0.37 a2 = - 0.396 a3 = 1.93 a4 = 0.5   elif self . kwargs [ <str> ] == 3 :              a3 , a4 = 0 , 0 if Re < 10 :                  a1 = 0.97 a2 = - 0.667  elif Re < 100 :                  a1 = 0.9 a2 = - 0.631  elif Re < 1000 :                  a1 = 0.408 a2 = - 0.46  elif Re < 10000 :                  a1 = 0.107 a2 = - 0.266  else :                  a1 = 0.37 a2 = - 0.395 a3 = 1.187 a4 = 0.37   else :              a3 , a4 = 0 , 0 if Re < 10 :                  a1 = 1.4 a2 = - 0.667  elif Re < 100 :                  a1 = 1.36 a2 = - 0.657  elif Re < 1000 :                  a1 = 0.593 a2 = - 0.477  elif Re < 10000 :                  a1 = 0.321 a2 = - 0.388  else :                  a1 = 0.321 a2 = - 0.388 a3 = 1.45 a4 = 0.519   if self . kwargs [ <str> ] == 1 :              b3 , b4 = 0 , 0 if Re < 10 :                  b1 = 32 b2 = - 1.  elif Re < 100 :                  b1 = 26.2 b2 = - 0.913  elif Re < 1000 :                  b1 = 3.5 b2 = - 0.476  elif Re < 10000 :                  b1 = 0.333 b2 = - 0.136  else :                  b1 = 0.303 b2 = - 0.126 b3 = 6.59 b4 = 0.52   elif self . kwargs [ <str> ] == 3 :              b3 , b4 = 0 , 0 if Re < 10 :                  b1 = 35.0 b2 = - 1.  elif Re < 100 :                  b1 = 32.1 b2 = - 0.963  elif Re < 1000 :                  b1 = 6.09 b2 = - 0.602  elif Re < 10000 :                  b1 = 0.0815 b2 = 0.022  else :                  b1 = 0.391 b2 = - 0.148 b3 = 6.3 b4 = 0.378   else :              b3 , b4 = 0 , 0 if Re < 10 :                  b1 = 48.0 b2 = - 1.  elif Re < 100 :                  b1 = 45.1 b2 = - 0.973  elif Re < 1000 :                  b1 = 4.570 b2 = - 0.476  elif Re < 10000 :                  b1 = 0.486 b2 = - 0.152  else :                  b1 = 0.372 b2 = - 0.123 b3 = 7.0 b4 = 0.5   a = a3 / ( 1 + 0.14 * Re ** a4 ) b = b3 / ( 1 + 0.14 * Re ** b4 ) j = a1 * ( 1.33 / P ) ** a * Re ** a2 f = b1 * ( 1.33 / P ) ** b * Re ** b2 hid = j * cp * G * fi / Pr ** ( 2. / 3 ) h = unidades . HeatTransfCoef ( hid * Jc * Jl * Jb * Jr * Js ) DPideal = 2 * f * Nc * G ** 2 / g / rho / fi DPc = ( nb - 1 ) * DPideal * Rl * Rb if Re > 100 :              DPwideal = ( 2 + 0.6 * Ncw ) * mo ** 2 / 2 / g / rho / Sm / Sw  else :              DPwideal = 26 * nu * mo / g / ( Sm * Sw ) ** 0.5 * ( Ncw / P + self . kwargs [ <str> ] * self . kwargs [ <str> ] / Dw ** 2 ) + mo ** 2 / g / rho / Sm / Sw  DPw = nb * DPwideal * Rl DPe = 2 * DPideal * ( 1 + Ncw / Nc ) * Rb * Rs mon = mo / self . kwargs [ <str> ] DPn = 0 for D in self . kwargs [ <str> ] , self . kwargs [ <str> ] :              Ren = D * mon / self . kwargs [ <str> ] . Liquido . mu Sn = pi / 4 * D ** 2 if Ren > 100 :                  DPn += 2e-13 * self . kwargs [ <str> ] * mon ** 2 / Sn  else :                  DPn += 4e-13 * self . kwargs [ <str> ] * mon ** 2 / Sn   DP = unidades . DeltaP ( DPc + DPw + DPe + DPn ) return h , DP  @ staticmethod def h_shelside_turbulent_Kern ( Re , Pr ) :          return 0.36 * Re ** 0.55 * Pr ** ( 1. / 3 ) * ( mu / muw ) ** 0.14  def h_tubeside_laminar_condensation_Kern ( self ) :          return 0.815 * ( k ** 3 * rho_l * ( rho_l - rho_g ) * g * l / ( pi * mu_l * Do * ( T - Tw ) ) ) ** 0.25  def h_tubeside_laminar_condensation_Nusselt ( self ) :          return 0.72 * eg ** 0.75 * ( k ** 3 * rho_l * ( rho_l - rho_g ) * g * hlg / ( mu_l * Do * ( T - Tw ) ) ) ** 0.25  def h_tubeSide_fined_Young ( self ) :          return 0.1378 * Re ** 0.718 * Pr ** ( 1. / 3 ) * ( finSpacing / finHeight ) ** 0.296  def coste ( self ) :          if self . kwargs [ <str> ] :              Pd = unidades . Pressure ( self . kwargs [ <str> ] )  else :              Pd = unidades . Pressure ( max ( self . kwargs [ <str> ] . P , self . kwargs [ <str> ] . P ) )  if self . kwargs [ <str> ] == 0 :              Fd = exp ( - 1.1156 + 0.09060 * log ( self . area . ft2 ) )  elif self . kwargs [ <str> ] == 1 :              Fd = 1.35  else :              Fd = exp ( - 0.9816 + 0.0803 * log ( self . area . ft2 ) )  g1 = [ 0. , 0.8603 , 0.8193 , 0.6116 , 1.5092 , 1.2989 , 1.204 , 1.1854 , 1.5420 , 0.1549 ] [ self . kwargs [ <str> ] ] g2 = [ 1. , 0.23296 , 0.15984 , 0.22186 , 0.60859 , 0.43377 , 0.50764 , 0.49706 , 0.42913 , 0.51774 ] [ self . kwargs [ <str> ] ] Fm = g1 + g2 * log ( self . area . ft2 ) if Pd . psi <= 300 :              Fp = 0.771 + 0.04981 * log ( self . area . ft2 )  elif Pd . psi <= 600 :              Fp = 1.0305 + 0.0714 * log ( self . area . ft2 )  else :              Fp = 1.14 + 0.12088 * log ( self . area . ft2 )  C_base = exp ( 8.821 - 0.30863 * log ( self . area . ft2 ) + 0.0681 * log ( self . area . ft2 ) ** 2 ) C = Fd * Fm * Fp * C_base self . C_adq = unidades . Currency ( C * self . kwargs [ <str> ] / self . kwargs [ <str> ] ) self . C_inst = unidades . Currency ( self . C_adq * self . kwargs [ <str> ] )   class Air_Cooler ( equipment ) :      title = <str> help = <str> def coste ( self , * args ) :          self . _indicesCoste ( * args ) C = 24.6 * self . area . ft2 ** 0.4 * 1000 self . C_adq = unidades . Currency ( C * self . Current_index / self . Base_index ) self . C_inst = unidades . Currency ( self . C_adq * self . f_install )   class Evaporator ( equipment ) :      title = <str> help = <str> def coste ( self , * args , ** kwargs ) :          self . _indicesCoste ( * args ) self . tipo = kwargs . get ( <str> , 0 ) self . material = kwargs . get ( <str> , 0 ) A = self . area . ft2 if self . tipo == 0 :              C_base = exp ( 5.9785 - 0.6056 * log ( A ) + 0.08514 * log ( A ) ** 2 ) * 1000 if self . material == 0 :                  Fm = 1.  elif self . material == 1 :                  Fm = 1.35  else :                  Fm = 1.8   elif self . tipo == 1 :              C_base = 0.36 * A ** 0.85 * 1000 if self . material == 0 :                  Fm = 1.  elif self . material == 1 :                  Fm = 0.6  elif self . material == 2 :                  Fm = 0.7  else :                  Fm = 3.3   else :              C_base = exp ( 3.2362 - 0.0126 * log ( A ) + 0.0244 * log ( A ) ** 2 ) * 1000 Fm = 1  C = Fm * C_base self . C_adq = unidades . Currency ( C * self . Current_index / self . Base_index ) self . C_inst = unidades . Currency ( self . C_adq * self . f_install )   class Refrigeration ( equipment ) :      title = <str> help = <str> def Coste ( self , * args , ** kwargs ) :          self . _indicesCoste ( * args ) Tmax = self . Tmax . C Q = self . calor . MBtuh if Tmax >= 0 :              F = 1.  elif Tmax >= - 10 :              F = 1.55  elif Tmax >= - 20 :              F = 2.1  elif Tmax >= - 30 :              F = 2.65  elif Tmax >= - 3 :              F = 3.2  else :              F = 4.  C = 146 * F * Q ** 0.65 * 1000 C_adq = C * self . Current_index / self . Base_index C_inst = C_adq * self . kwargs [ <str> ] self . C_adq = C_adq self . C_inst = C_inst   def unsteady ( ) :      dtau = 0.001 dx = 0.05 Tmax = 0.95 M = 21 dx = 1.0 / ( M - 1 ) dx_x = 1.0 / ( M - 1 ) ratio = dtau / ( dx ** 2 ) const = 1.0 - 2.0 * ratio i = 0 tau = 0.0 Tnew = zeros ( M , dtype = float ) T = zeros ( M , dtype = float ) T [ 0 ] = 1.0 T [ - 1 ] = 1.0 print ( ( <str> , T ) ) T_sol = zeros ( ( 400 , M ) , dtype = float ) T_sol [ : , 0 ] = 1.0 T_sol [ : , - 1 ] = 1.0 while T [ 10 ] < Tmax :          i = i + 1 tau = tau + dtau for j in range ( 1 , M - 1 ) :              Tnew [ j ] = ratio * ( T [ j - 1 ] + T [ j + 1 ] ) + const * T [ j ]  for k in range ( 1 , M - 1 ) :              T [ k ] = Tnew [ k ] T_sol [ i , k ] = T [ k ]   print ( ( <str> , tau , T_sol [ i , : ] ) ) x = [ i * dx_x for i in range ( M - 1 ) ] x . append ( 1.0 ) plot ( x , T_sol [ 50 , : ] ) plot ( x , T_sol [ 100 , : ] ) plot ( x , T_sol [ 150 , : ] ) plot ( x , T_sol [ 250 , : ] ) plot ( x , T_sol [ i , : ] ) title ( <str> ) plt . show ( ) grid ( )  if __name__ == <str> :      import doctest doctest . testmod ( )   