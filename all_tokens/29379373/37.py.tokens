def install ( job ) :      service = job . service cuisine = service . executor . cuisine if <str> not in service . producers :          raise j . exceptions . AYSNotFound ( <str> )  redis = service . producers [ <str> ] [ 0 ] cfg_path = cuisine . core . args_replace ( <str> ) config = j . data . serializer . yaml . loads ( <str> ) if cuisine . core . file_exists ( cfg_path ) :          config = j . data . serializer . yaml . loads ( cuisine . core . file_read ( cfg_path ) )  if <str> not in config :          config [ <str> ] = { }  if redis . model . data . unixsocket != <str> :          config [ <str> ] [ <str> ] = redis . model . data . unixsocket  else :          config [ <str> ] = { <str> : redis . model . data . host , <str> : redis . model . data . port , }  cuisine . core . dir_ensure ( j . sal . fs . getParent ( cfg_path ) ) cuisine . core . file_write ( cfg_path , j . data . serializer . yaml . dumps ( config ) ) raml = cuisine . core . file_read ( <str> ) if service . model . data . domain == <str> :          node = service . aysrepo . servicesFind ( actor = <str> ) [ 0 ] service . model . data . domain = node . model . data . ipPublic raml = raml . replace ( <str> , <str> % service . model . data . domain )  else :          raml = raml . replace ( <str> , <str> % service . model . data . domain )  cuisine . core . file_write ( <str> , raml ) content = cuisine . core . file_read ( <str> ) if <str> not in content :          cuisine . core . file_write ( <str> , <str> , append = True )  if service . model . data . oauthRedirectUrl . split ( <str> ) [ 2 ] == <str> :          node = service . aysrepo . servicesFind ( actor = <str> ) [ 0 ] redirect_url = service . model . data . oauthRedirectUrl . split ( <str> ) redirect_url [ 2 ] = node . model . data . ipPublic redirect_url [ 0 ] = <str> service . model . data . oauthRedirectUrl = <str> . join ( redirect_url )  api_cfg = { <str> : { <str> : service . model . data . oauthClientSecret , <str> : service . model . data . oauthClientId , <str> : service . model . data . oauthOrganization , <str> : service . model . data . oauthJwtKey , <str> : service . model . data . oauthRedirectUrl , } , <str> : { <str> : { <str> : service . model . data . apiHost , <str> : service . model . data . apiPort , } } } cuisine . core . file_write ( <str> , j . data . serializer . toml . dumps ( api_cfg ) ) cuisine . package . mdupdate ( ) cuisine . package . install ( <str> ) cmd = <str> pm = cuisine . processmanager . get ( <str> ) pm . ensure ( cmd = cmd , name = <str> % service . name , autostart = True ) cmd = <str> pm . ensure ( cmd = cmd , name = <str> % service . name , path = cuisine . core . args_replace ( <str> ) , autostart = True ) cuisine . core . dir_ensure ( <str> ) cuisine . core . upload ( service . aysrepo . path , <str> ) cuisine . core . run ( <str> , profile = True ) rc_local = cuisine . core . file_read ( <str> ) . split ( <str> ) for idx , line in enumerate ( rc_local ) :          if line == <str> :              rc_local . insert ( idx , <str> ) rc_local . insert ( idx , <str> ) break   cuisine . core . file_write ( <str> , <str> . join ( rc_local ) )  def start ( job ) :      service = job . service cuisine = service . executor . cuisine pm = cuisine . processmanager . get ( <str> ) cmd = <str> pm . ensure ( cmd = cmd , name = <str> % service . name ) raml = cuisine . core . file_read ( <str> ) raml = raml . replace ( <str> , <str> % service . model . data . domain ) cuisine . core . file_write ( <str> , raml ) cmd = <str> pm . ensure ( cmd = cmd , name = <str> % service . name , path = cuisine . core . args_replace ( <str> ) )  def stop ( job ) :      service = job . service cuisine = service . executor . cuisine pm = cuisine . processmanager . get ( <str> ) pm . stop ( name = <str> % service . name ) pm . stop ( name = <str> % service . name )   