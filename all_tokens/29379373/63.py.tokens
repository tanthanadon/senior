def input ( job ) :      args = job . model . args if <str> in args :          args [ <str> ] = args [ <str> ] del args [ <str> ]  return args  def init ( job ) :      service = job . service os_actor = service . aysrepo . actorGet ( <str> ) os_actor . serviceCreate ( service . name , args = { <str> : service . name , <str> : service . model . data . sshkey } )  def install ( job ) :      service = job . service vdc = service . parent if <str> not in vdc . producers :          raise j . exceptions . AYSNotFound ( <str> % service )  g8client = vdc . producers [ <str> ] [ 0 ] cl = j . clients . openvcloud . getFromService ( g8client ) acc = cl . account_get ( vdc . model . data . account ) space = acc . space_get ( vdc . model . dbobj . name , vdc . model . data . location ) if service . name in space . machines :          machine = space . machines [ service . name ]  else :          image_names = [ i [ <str> ] for i in space . images ] if service . model . data . osImage not in image_names :              raise j . exceptions . NotFound ( <str> % ( service . model . data . osImage , vdc . name ) )  machine = space . machine_create ( name = service . name , image = service . model . data . osImage , memsize = service . model . data . memory , disksize = service . model . data . bootdiskSize , sizeId = service . model . data . sizeID if service . model . data . sizeID >= 0 else None , stackId = service . model . data . stackID if service . model . data . stackID >= 0 else None )  service . model . data . machineId = machine . id service . model . data . ipPublic = machine . space . model [ <str> ] or space . get_space_ip ( ) ip , vm_info = machine . get_machine_ip ( ) if not ip :          raise j . exceptions . RuntimeError ( <str> % service . name )  service . model . data . ipPrivate = ip service . model . data . sshLogin = vm_info [ <str> ] [ 0 ] [ <str> ] service . model . data . sshPassword = vm_info [ <str> ] [ 0 ] [ <str> ] ssh_present = any ( [ ports for ports in service . model . data . ports if ports . startswith ( <str> ) ] ) data = j . data . serializer . json . loads ( service . model . dataJSON ) ports = data . get ( <str> , [ ] ) if ssh_present else data . get ( <str> , [ ] ) + [ <str> ] for i , port in enumerate ( ports ) :          ss = port . split ( <str> ) if len ( ss ) == 2 :              public_port , local_port = ss  else :              local_port = port public_port = None  public , local = machine . create_portforwarding ( publicport = public_port , localport = local_port , protocol = <str> ) ports [ i ] = <str> % ( public , local )  service . model . data . ports = ports if <str> not in service . producers :          raise j . exceptions . AYSNotFound ( <str> )  sshkey = service . producers [ <str> ] [ 0 ] service . logger . info ( <str> ) node = service ssh_port = <str> for port in ports :          src , _ , dst = port . partition ( <str> ) if ssh_port == dst :              ssh_port = src break   service . model . data . sshPort = int ( ssh_port ) sshkey = service . producers [ <str> ] [ 0 ] key_path = j . sal . fs . joinPaths ( sshkey . path , <str> ) password = node . model . data . sshPassword if node . model . data . sshPassword != <str> else None executor = j . tools . executor . getSSHBased ( addr = node . model . data . ipPublic , port = service . model . data . sshPort , login = node . model . data . sshLogin , passwd = password , allow_agent = True , look_for_keys = True , timeout = 5 , usecache = False , passphrase = None , key_filename = key_path ) executor . cuisine . ssh . authorize ( <str> , sshkey . model . data . keyPub ) cuisine = executor . cuisine rc , out , err = cuisine . core . run ( <str> , die = False ) if rc != 0 :          raise j . exceptions . RuntimeError ( <str> )  jsonout = j . data . serializer . json . loads ( out ) available_devices = [ x [ <str> ] for x in jsonout [ <str> ] if x [ <str> ] is None and x [ <str> ] == <str> and <str> not in x ] datadisks = service . producers . get ( <str> , [ ] ) takendevices = [ x . model . data . devicename for x in datadisks if x . model . data . devicename != <str> ] for data_disk in datadisks :          disk_args = data_disk . model . data if data_disk . model . data . devicename == <str> and len ( available_devices ) :              data_disk . model . data . devicename = available_devices . pop ( 0 ) takendevices . append ( data_disk . model . data . devicename )  else :              disk_id = machine . add_disk ( name = data_disk . model . dbobj . name , description = disk_args . description , size = disk_args . size , type = disk_args . type . upper ( ) , ssdSize = disk_args . ssdSize ) machine . disk_limit_io ( disk_id , disk_args . maxIOPS ) rc , out , err = cuisine . core . run ( <str> , die = False ) if rc != 0 :                  raise j . exceptions . RuntimeError ( <str> )  jsonout = j . data . serializer . json . loads ( out ) available_devices = [ x [ <str> ] for x in jsonout [ <str> ] if x [ <str> ] is None and x [ <str> ] == <str> and <str> not in x and x [ <str> ] not in takendevices ] data_disk . model . data . devicename = available_devices . pop ( 0 ) takendevices . append ( data_disk . model . data . devicename )  data_disk . saveAll ( )  service . saveAll ( )  def processChange ( job ) :      service = job . service vdc = service . parent if <str> not in vdc . producers :          raise j . exceptions . AYSNotFound ( <str> % service )  g8client = vdc . producers [ <str> ] [ 0 ] cl = j . clients . openvcloud . getFromService ( g8client ) acc = cl . account_get ( vdc . model . data . account ) space = acc . space_get ( vdc . model . dbobj . name , vdc . model . data . location ) if service . name in space . machines :          machine = space . machines [ service . name ]  args = job . model . args category = args . pop ( <str> ) if category == <str> and service . model . actionsState [ <str> ] == <str> :          for key , value in args . items ( ) :              if key == <str> :                  oldpfs_set = set ( ) newpfs_set = set ( ) oldports = service . model . data . ports oldlocal22 = <str> oldpublic22 = None for port in oldports :                      public_port = None local_port = None ss = port . split ( <str> ) if len ( ss ) == 2 :                          public_port , local_port = ss  else :                          local_port = port public_port = None  if local_port == <str> :                          oldpublic22 = public_port  oldpfs_set . add ( ( public_port , local_port ) )  if not isinstance ( value , list ) :                      raise j . exceptions . Input ( message = <str> )  ports_list = value if oldlocal22 :                      ports_list . append ( <str> % ( oldpublic22 , oldlocal22 ) )  for i , port in enumerate ( ports_list ) :                      public_port = None local_port = None ss = port . split ( <str> ) if len ( ss ) == 2 :                          public_port , local_port = ss  else :                          local_port = port public_port = None  newpfs_set . add ( ( public_port , local_port ) )  toremove = oldpfs_set - newpfs_set tocreate = newpfs_set - oldpfs_set for idx , ( public_port , local_port ) in enumerate ( toremove ) :                      if local_port == <str> :                          continue  machine . delete_portforwarding ( public_port )  ports = [ None ] * ( len ( tocreate ) - ( 1 if oldlocal22 else 0 ) ) for idx , ( public_port , local_port ) in enumerate ( tocreate ) :                      if local_port == oldlocal22 :                          idx -= 1 continue  public , local = machine . create_portforwarding ( publicport = public_port , localport = local_port , protocol = <str> ) ports . append ( <str> % ( public , local ) )  ports . append ( <str> % ( oldpublic22 , oldlocal22 ) ) setattr ( service . model . data , key , value )  if key == <str> :                  machine_disks = { disk [ <str> ] : disk [ <str> ] for disk in acc . disks if disk [ <str> ] == machine . id and disk [ <str> ] != <str> } old_disks_services = service . producers . get ( <str> , [ ] ) for old_disk_service in old_disks_services :                      if old_disk_service . name not in value and old_disk_service . model . data . type != <str> :                          service . model . producerRemove ( old_disk_service ) device_name = old_disk_service . model . dbobj . name if device_name in machine_disks :                              acc . delete_disk ( machine_disks [ device_name ] )    for disk_service_name in value :                      disk_service = service . aysrepo . serviceGet ( <str> , disk_service_name ) if disk_service not in old_disks_services :                          service . consume ( disk_service ) disk_args = disk_service . model . data disk_id = machine . add_disk ( name = disk_service . name , description = disk_args . description , size = disk_args . size , type = disk_args . type . upper ( ) , ssdSize = disk_args . ssdSize ) machine . disk_limit_io ( disk_id , disk_args . maxIOPS )   setattr ( service . model . data , key , value )   space . save ( ) service . save ( )   def export ( job ) :      service = job . service vdc = service . parent if <str> not in vdc . producers :          raise j . exceptions . AYSNotFound ( <str> % service )  g8client = vdc . producers [ <str> ] [ 0 ] cl = j . clients . openvcloud . getFromService ( g8client ) acc = cl . account_get ( vdc . model . data . account ) space = acc . space_get ( vdc . model . dbobj . name , vdc . model . data . location ) if service . name in space . machines :          machine = space . machines [ service . name ]  else :          raise j . exceptions . NotFound ( <str> % service . name )  cl . api . cloudapi . machines . exportOVF ( link = service . model . data . ovfLink , username = service . model . data . ovfUsername , passwd = service . model . data . ovfPassword , path = service . model . data . ovfPath , machineId = service . model . data . machineId , callbackUrl = service . model . data . ovfCallbackUrl )  def import_ ( job ) :      service = job . service vdc = service . parent if <str> not in vdc . producers :          raise j . exceptions . AYSNotFound ( <str> % service )  g8client = vdc . producers [ <str> ] [ 0 ] cl = j . clients . openvcloud . getFromService ( g8client ) acc = cl . account_get ( vdc . model . data . account ) space = acc . space_get ( vdc . model . dbobj . name , vdc . model . data . location ) sizeId = space . size_find_id ( service . model . data . memory ) cl . api . cloudapi . machines . importOVF ( link = service . model . data . ovfLink , username = service . model . data . ovfUsername , passwd = service . model . data . ovfPassword , path = service . model . data . ovfPath , cloudspaceId = space . id , name = service . name , sizeId = sizeId , callbackUrl = service . model . data . ovfCallbackUrl )  def init_actions_ ( service , args ) :      action_required = args . get ( <str> ) if action_required in [ <str> , <str> ] :          for action_name , action_model in service . model . actions . items ( ) :              if action_name in [ <str> , <str> ] :                  continue  if action_model . state == <str> :                  action_model . state = <str>    if action_required in [ <str> ] :          for action_name , action_model in service . model . actions . items ( ) :              if action_name in [ <str> , <str> ] and action_model . state == <str> :                  action_model . state = <str>    if action_required == <str> :          if service . model . actionsState [ <str> ] == <str> :              service . model . actionsState [ <str> ] = <str>   if action_required == <str> :          if service . model . actionsState [ <str> ] == <str> :              service . model . actionsState [ <str> ] = <str>   service . save ( ) return { <str> : [ ] , <str> : [ <str> ] , <str> : [ <str> ] , <str> : [ <str> ] , <str> : [ <str> ] , <str> : [ <str> ] , <str> : [ ] , <str> : [ <str> ] , }  def add_disk ( job ) :      service = job . service repo = service . aysrepo vdc = service . parent if <str> not in vdc . producers :          raise j . exceptions . AYSNotFound ( <str> % service )  os = None for child in service . children :          if child . model . role == <str> :              os = child break   if os is None :          raise RuntimeError ( <str> )  g8client = vdc . producers [ <str> ] [ 0 ] cl = j . clients . openvcloud . getFromService ( g8client ) acc = cl . account_get ( vdc . model . data . account ) space = acc . space_get ( vdc . model . dbobj . name , vdc . model . data . location ) machine = None if service . name in space . machines :          machine = space . machines [ service . name ]  else :          raise RuntimeError ( <str> )  args = job . model . args prefix = args . get ( <str> , <str> ) avaialble_disks = service . producers . get ( <str> , [ ] ) available_names = service . model . data . disk device_names = list ( map ( lambda d : d . model . data . devicename , avaialble_disks ) ) idx = 1 name = <str> % ( prefix , idx ) while name in available_names :          idx += 1 name = <str> % ( prefix , idx )  model = { <str> : args . get ( <str> , 1000 ) , <str> : args . get ( <str> , <str> ) , } disk_id = machine . add_disk ( name = name , description = model [ <str> ] , size = model [ <str> ] , type = <str> ) code , out , err = os . executor . cuisine . core . run ( <str> , die = False ) if code != 0 :          raise RuntimeError ( <str> % err )  jsonout = j . data . serializer . json . loads ( out ) devices = [ x for x in jsonout [ <str> ] if x [ <str> ] is None and x [ <str> ] == <str> ] for dv in devices :          if <str> in dv or dv [ <str> ] in device_names :              continue  model [ <str> ] = dv [ <str> ]  disk_service = repo . actorGet ( <str> ) . serviceCreate ( name , model ) disk_service . saveAll ( ) service . consume ( disk_service ) disks = list ( service . model . data . disk ) disks . append ( name ) service . model . data . disk = disks service . saveAll ( )  def open_port ( job ) :      requested_port = job . model . args [ <str> ] public_port = job . model . args . get ( <str> , None ) service = job . service vdc = service . parent if <str> not in vdc . producers :          raise j . exceptions . AYSNotFound ( <str> % service )  g8client = vdc . producers [ <str> ] [ 0 ] cl = j . clients . openvcloud . getFromService ( g8client ) acc = cl . account_get ( vdc . model . data . account ) space = acc . space_get ( vdc . model . dbobj . name , vdc . model . data . location ) if service . name in space . machines :          machine = space . machines [ service . name ]  else :          raise RuntimeError ( <str> )  spaceport = None for pf in machine . portforwardings :          if pf [ <str> ] == requested_port :              spaceport = pf [ <str> ] break   ports = set ( service . model . data . ports ) if spaceport is None :          if public_port is None :              unavailable_ports = [ int ( portinfo [ <str> ] ) for portinfo in machine . space . portforwardings ] spaceport = 2200 while True :                  if spaceport not in unavailable_ports :                      break  else :                      spaceport += 1    else :              spaceport = public_port  machine . create_portforwarding ( spaceport , requested_port )  ports . add ( <str> % ( spaceport , requested_port ) ) service . model . data . ports = list ( ports ) service . saveAll ( ) return spaceport  def uninstall ( job ) :      service = job . service vdc = service . parent if <str> not in vdc . producers :          raise j . exceptions . RuntimeError ( <str> % service )  g8client = vdc . producers [ <str> ] [ 0 ] cl = j . clients . openvcloud . getFromService ( g8client ) acc = cl . account_get ( vdc . model . data . account ) space = acc . space_get ( vdc . model . dbobj . name , vdc . model . data . location ) if service . name not in space . machines :          return  machine = space . machines [ service . name ] machine . delete ( )  def start ( job ) :      service = job . service vdc = service . parent if <str> not in vdc . producers :          raise j . exceptions . RuntimeError ( <str> % service )  g8client = vdc . producers [ <str> ] [ 0 ] cl = j . clients . openvcloud . getFromService ( g8client ) acc = cl . account_get ( vdc . model . data . account ) space = acc . space_get ( vdc . model . dbobj . name , vdc . model . data . location ) if service . name not in space . machines :          return  machine = space . machines [ service . name ] machine . start ( )  def stop ( job ) :      service = job . service vdc = service . parent if <str> not in vdc . producers :          raise j . exceptions . RuntimeError ( <str> % service )  g8client = vdc . producers [ <str> ] [ 0 ] cl = j . clients . openvcloud . getFromService ( g8client ) acc = cl . account_get ( vdc . model . data . account ) space = acc . space_get ( vdc . model . dbobj . name , vdc . model . data . location ) if service . name not in space . machines :          return  machine = space . machines [ service . name ] machine . stop ( )  def restart ( job ) :      service = job . service vdc = service . parent if <str> not in vdc . producers :          raise j . exceptions . RuntimeError ( <str> % service )  g8client = vdc . producers [ <str> ] [ 0 ] cl = j . clients . openvcloud . getFromService ( g8client ) acc = cl . account_get ( vdc . model . data . account ) space = acc . space_get ( vdc . model . dbobj . name , vdc . model . data . location ) if service . name not in space . machines :          return  machine = space . machines [ service . name ] machine . restart ( )  def mail ( job ) :      print ( <str> )   