import unittest from contextlib import contextmanager from datetime import datetime , timedelta from xoutil . future . functools import lru_cache @ lru_cache ( 3 ) def fib ( n ) :      print ( n ) if n <= 1 :          return 1  else :          a = fib ( n - 1 ) b = fib ( n - 2 ) return a + b   def takes_no_more_than ( duration , msg = None ) :      if not msg :          msg = <str> . format ( s = duration )  @ contextmanager def inner ( ) :          start = datetime . now ( ) yield end = datetime . now ( ) max_duration = timedelta ( seconds = duration ) if ( end - start ) > max_duration :              raise AssertionError ( msg )   return inner ( )  def test_lrucache ( ) :      fib . cache_clear ( ) with takes_no_more_than ( 90 ) :          assert fib ( 120 ) == 8670007398507948658051921   def test_lrucache_stats ( ) :      pass  from xoutil . fp . tools import compose , identity class TestCompose ( unittest . TestCase ) :      def test_needs_at_least_an_argument ( self ) :          self . assertIs ( compose ( ) , identity )  def test_single_argument_is_identitical ( self ) :          def anything ( ) :              pass  self . assertIs ( anything , compose ( anything ) )  def test_only_callables ( self ) :          with self . assertRaises ( TypeError ) :              compose ( 1 )   def test_simple_case ( self ) :          incr = lambda x : x + 1 add_3 = compose ( incr , incr , incr ) self . assertEqual ( 3 , add_3 ( 0 ) )  def test_with_pow ( self ) :          from xoutil . future . functools import power incr = lambda x : x + 1 add_1 = power ( incr , 1 ) self . assertIs ( incr , add_1 ) add_3 = power ( incr , 3 ) self . assertEqual ( 3 , add_3 ( 0 ) )   def test_lwraps ( ) :      from xoutil . future . functools import lwraps class foobar :          @ lwraps ( <str> , one = True ) def one ( self ) :              return type ( self ) . __name__  @ lwraps ( <str> , two = True ) @ classmethod def two ( cls ) :              return cls . __name__  @ lwraps ( <str> , three = True ) @ staticmethod def three ( ) :              return <str>   @ lwraps ( <str> , four = True , one = False ) def four ( * args ) :          return [ ( arg . __name__ , arg ( ) ) for arg in args ]  f = foobar ( ) names = ( <str> , <str> , <str> , <str> ) assert four . __name__ == names [ 3 ] assert foobar . one . __name__ == names [ 0 ] assert foobar . two . __name__ == names [ 1 ] assert foobar . three . __name__ == names [ 2 ] assert f . one . __name__ == names [ 0 ] assert f . two . __name__ == names [ 1 ] assert f . three . __name__ == names [ 2 ] assert four . four assert not four . one assert f . one . one assert f . two . two assert f . three . three for i , ( a , b ) in enumerate ( four ( f . one , f . two , f . three ) ) :          assert a == names [ i ] assert b == <str>    