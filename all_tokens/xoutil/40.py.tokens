from xotl . tools . symbols import Unset from xotl . tools . future . functools import lru_cache @ lru_cache ( ) def field_descriptor ( field_name ) :      class descriptor :          def __get__ ( self , instance , owner ) :              if instance :                  return owner . get_field ( instance . _raw_data , owner . _rec_fields [ field_name ] )  else :                  return self    return descriptor  class _record_type ( type ) :      @ staticmethod def _is_rec_definition ( attr , val = Unset ) :          result = not attr . startswith ( <str> ) and attr . upper ( ) == attr if val is not Unset :              from numbers import Integral result = result and isinstance ( val , ( Integral , str ) )  return result  @ staticmethod def is_reader ( attr , func , fields = None ) :          from xotl . tools . future . types import FunctionType attr = attr . lower ( ) good_name = attr . startswith ( <str> ) and attr . endswith ( <str> ) good_type = isinstance ( func , ( FunctionType , staticmethod ) ) return good_name and good_type  def __new__ ( cls , name , bases , attrs ) :          def static ( f ) :              return f if isinstance ( f , staticmethod ) else staticmethod ( f )  cls_fields = { attr : val for attr , val in attrs . items ( ) if cls . _is_rec_definition ( attr , val ) } descriptors = { attr . lower ( ) : field_descriptor ( attr ) ( ) for attr in cls_fields } readers = { attr . lower ( ) : static ( func ) for attr , func in attrs . items ( ) if cls . is_reader ( attr , func ) } new_attrs = dict ( attrs , ** descriptors ) new_attrs . update ( readers ) result = super ( ) . __new__ ( cls , name , bases , new_attrs ) fields = dict ( getattr ( result , <str> , { } ) ) index = dict ( getattr ( result , <str> , { } ) ) fields . update ( cls_fields ) if len ( fields ) != len ( { val for val in fields . values ( ) } ) :              msg = <str> % name import logging logger = logging . getLogger ( __name__ ) logger . error ( msg ) logger . debug ( fields ) raise TypeError ( msg )  result . _rec_fields = fields index . update ( { val : attr for attr , val in cls_fields . items ( ) } ) result . _rec_index = index return result  def get_field ( self , raw_data , field ) :          from xotl . tools . symbols import Undefined field_name = self . _rec_index [ field ] try :              value = raw_data [ field ]  except ( IndexError , KeyError ) :              value = Undefined  reader_name = <str> % field_name . lower ( ) reader = getattr ( self , reader_name , None ) if reader :              return reader ( value )  else :              return value    class record ( metaclass = _record_type ) :      def __init__ ( self , raw_data ) :          self . _raw_data = raw_data  def __repr__ ( self ) :          cls = type ( self ) return <str> % ( cls . __name__ , self . _raw_data )  def __getitem__ ( self , field_index ) :          return type ( self ) . get_field ( self . _raw_data , field_index )   def isnull ( val ) :      from xotl . tools . symbols import boolean return val in ( None , <str> ) or ( isinstance ( val , boolean ) and not val )  def check_nullable ( val , nullable ) :      null = isnull ( val ) if not null or nullable :          return not null  else :          raise ValueError ( <str> )   @ lru_cache ( ) def datetime_reader ( format , nullable = False , default = None , strict = True ) :      try :          from dateutil . parser import parse  except ImportError :          parse = None  def reader ( val ) :          if check_nullable ( val , nullable ) :              from datetime import datetime try :                  return datetime . strptime ( val , format )  except ValueError :                  if strict :                      raise  elif parse :                      return parse ( val )  else :                      if nullable :                          return None  elif not isnull ( default ) :                          return default  else :                          raise ValueError     else :              return default   return reader  @ lru_cache ( ) def date_reader ( format , nullable = False , default = None , strict = True ) :      reader = datetime_reader ( format , nullable = nullable , default = default , strict = strict ) def res ( val ) :          result = reader ( val ) if not isnull ( result ) and result is not default :              return result . date ( )  else :              return result   return res  @ lru_cache ( ) def boolean_reader ( true = ( <str> , ) , nullable = False , default = None ) :      def reader ( val ) :          if check_nullable ( val , nullable ) :              return val in true  else :              return default   return reader  @ lru_cache ( ) def integer_reader ( nullable = False , default = None ) :      def reader ( val ) :          if check_nullable ( val , nullable ) :              return int ( val )  else :              return default   return reader  @ lru_cache ( ) def decimal_reader ( nullable = False , default = None ) :      def reader ( val ) :          if check_nullable ( val , nullable ) :              from decimal import Decimal return Decimal ( val )  else :              return default   return reader  @ lru_cache ( ) def float_reader ( nullable = False , default = None ) :      def reader ( val ) :          if check_nullable ( val , nullable ) :              return float ( val )  else :              return default   return reader  del lru_cache  