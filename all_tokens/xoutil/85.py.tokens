import sys import os from re import compile as _rcompile from xotl . tools . fs . path import normalize_path re_magic = _rcompile ( <str> ) has_magic = lambda s : re_magic . search ( s ) is not None def _get_regex ( pattern = None , regex_pattern = None , shell_pattern = None ) :      from functools import reduce import fnmatch from xotl . tools . params import check_count arg_count = reduce ( lambda count , p : count + ( 1 if p is not None else 0 ) , ( pattern , regex_pattern , shell_pattern ) , 0 , ) check_count ( arg_count , 0 , 1 , caller = <str> ) if arg_count == 1 :          if pattern is not None :              if pattern . startswith ( <str> ) or pattern . startswith ( <str> ) :                  regex_pattern = pattern  else :                  shell_pattern = pattern   return _rcompile ( regex_pattern or fnmatch . translate ( shell_pattern ) )  elif arg_count == 0 :          return None   def iter_files ( top = <str> , pattern = None , regex_pattern = None , shell_pattern = None , followlinks = False , maxdepth = None , ) :      regex = _get_regex ( pattern , regex_pattern , shell_pattern ) depth = 0 for dirpath , _dirs , filenames in os . walk ( normalize_path ( top ) , topdown = True , followlinks = followlinks ) :          for filename in filenames :              path = os . path . join ( dirpath , filename ) if ( regex is None ) or regex . search ( path ) :                  yield path   if maxdepth is not None :              depth += 1 if depth >= maxdepth :                  _dirs [ : ] = [ ]     _REGEX_PYTHON_PACKAGE = _rcompile ( <str> <str> <str> <str> ) _REGEX_DEFAULT_ALLFILES = _rcompile ( <str> <str> <str> ) def iter_dict_files ( top = <str> , regex = None , wrong = None , followlinks = False ) :      if regex :          if isinstance ( regex , str ) :              regex = _rcompile ( regex )   else :          regex = _REGEX_DEFAULT_ALLFILES  for dirpath , _dirs , filenames in os . walk ( normalize_path ( top ) , followlinks = followlinks ) :          for filename in filenames :              path = os . path . join ( dirpath , filename ) match = regex . match ( path ) if match :                  yield match . groupdict ( )  elif wrong is not None :                  yield { wrong : path }     def iter_dirs ( top = <str> , pattern = None , regex_pattern = None , shell_pattern = None ) :      regex = _get_regex ( pattern , regex_pattern , shell_pattern ) for path , _dirs , _files in os . walk ( normalize_path ( top ) ) :          if ( regex is None ) or regex . search ( path ) :              yield path    def rmdirs ( top = <str> , pattern = None , regex_pattern = None , shell_pattern = None , exclude = None , confirm = None , ) :      regex = _get_regex ( pattern , regex_pattern , shell_pattern ) exclude = _get_regex ( exclude ) if confirm is None :          confirm = lambda _ : True  for path , _dirs , _files in os . walk ( normalize_path ( top ) ) :          if ( ( regex is None or regex . search ( path ) ) and ( exclude is None or not exclude . search ( path ) ) and not _dirs and not _files and confirm ( path ) and not os . path . ismount ( path ) ) :              os . rmdir ( path )    def regex_rename ( top , pattern , repl , maxdepth = None ) :      from re import subn as _re_subn if isinstance ( pattern , str ) :          pattern = _rcompile ( pattern )  depth = 0 for path , _dirs , files in os . walk ( top ) :          for item in files :              new_file , count = _re_subn ( pattern , repl , item ) if count > 0 :                  old = os . path . join ( path , item ) new = os . path . join ( path , new_file ) os . rename ( old , new )   if maxdepth is not None :              depth += 1 if depth >= maxdepth :                  _dirs [ : ] = [ ]     filter_not_hidden = lambda path , _st : ( path [ 0 ] != <str> ) and ( <str> not in path ) filter_false = lambda path , stat_info : False def get_regex_filter ( regex ) :      if isinstance ( regex , str ) :          regex = _rcompile ( regex )  def _filter ( path , stat_info ) :          return regex . match ( os . path . basename ( path ) ) is not None  return _filter  def get_wildcard_filter ( pattern ) :      regex = _get_regex ( pattern ) def _filter ( path , stat_info ) :          return regex . match ( os . path . basename ( path ) ) is not None  return _filter  def get_mime_filter ( mime_start ) :      import mimetypes def _filter ( path , stat_info ) :          t = mimetypes . guess_type ( path ) [ 0 ] return t . startswith ( mime_start ) if t else False  return _filter  def nice_size ( size ) :      tails = <str> order , highest = 0 , len ( tails ) - 1 while ( size >= 1024 ) and ( order < highest ) :          size /= 1024 order += 1  res = ( <str> % size ) . rstrip ( <str> ) . rstrip ( <str> ) return <str> % ( res , tails [ order ] )  def stat ( path ) :      try :          return os . stat ( path )  except os . error :          return None   def lstat ( path ) :      try :          return os . lstat ( path )  except os . error :          return None   def set_stat ( fname , stat_info ) :      os . chmod ( fname , stat_info . st_mode ) os . chown ( fname , stat_info . st_uid , stat_info . st_gid ) os . utime ( fname , ( stat_info . st_atime , stat_info . st_mtime ) )  def read_file ( path ) :      try :          with open ( path , <str> ) as f :              return f . read ( )   except OSError :          return <str>   def listdir ( path ) :      try :          return os . listdir ( normalize_path ( path ) )  except os . error :          return [ ]   def _list_magic ( dirname , pattern ) :      re = _get_regex ( pattern ) for name in listdir ( dirname or os . curdir ) :          if re . match ( name ) :              full = os . path . join ( dirname , name ) yield full , lstat ( full )    def _list_one ( fname ) :      st = lstat ( fname ) if st :          yield fname , st   def _list ( pattern ) :      from stat import S_ISDIR as _ISDIR if has_magic ( pattern ) :          head , tail = os . path . split ( pattern ) for dirname , st in _list ( head ) :              if _ISDIR ( st . st_mode ) :                  if has_magic ( tail ) :                      items = _list_magic ( dirname , tail )  elif tail :                      items = _list_one ( os . path . join ( dirname , tail ) )  else :                      items = ( ( dirname , st ) , )   for item in items :                  yield item    elif pattern :          for item in _list_one ( pattern ) :              yield item   else :          yield ( <str> , lstat ( os . curdir ) )   def imap ( func , pattern ) :      <str> for item , st in _list ( pattern ) :          res = func ( item , st ) if res is not None :              yield res    def walk_up ( start , sentinel ) :      from os . path import abspath , exists , isdir , join , dirname current = abspath ( start ) if not exists ( current ) or not isdir ( current ) :          raise OSError ( <str> % current )  previouspath = None found = False while not found and current is not previouspath :          clue = join ( current , sentinel ) if exists ( clue ) :              found = True  else :              previouspath = current current = dirname ( current )   return current if found else None  from os import makedirs def ensure_filename ( filename , yields = False ) :      if not os . path . exists ( filename ) :          filename = normalize_path ( filename ) dirname = os . path . dirname ( filename ) makedirs ( dirname , exist_ok = True ) fh = open ( filename , <str> ) if not yields :              fh . close ( )  else :              return fh   else :          if not os . path . isfile ( filename ) :              raise OSError ( <str> % filename )    def concatfiles ( * files ) :      import shutil from xotl . tools . values . simple import force_iterable_coerce from xotl . tools . params import check_count check_count ( files , 2 , caller = <str> ) if len ( files ) == 2 :          files , target = force_iterable_coerce ( files [ 0 ] ) , files [ 1 ]  else :          files , target = files [ : - 1 ] , files [ - 1 ]  if isinstance ( target , str ) :          target , opened = open ( target , <str> ) , True  else :          opened = False  try :          for f in files :              if isinstance ( f , str ) :                  fh = open ( f , <str> ) closefh = True  else :                  fh = f closefh = False  try :                  shutil . copyfileobj ( fh , target )  finally :                  if closefh :                      fh . close ( )     finally :          if opened :              target . close ( )    del sys  