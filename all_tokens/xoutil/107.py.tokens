import sys from functools import wraps from types import FunctionType as function from xotl . tools . decorator . meta import decorator __all__ = ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , ) class AttributeAlias :      def __init__ ( self , attr_name ) :          super ( ) . __init__ ( ) self . attr_name = attr_name  def __get__ ( self , instance , owner ) :          return getattr ( instance or owner , self . attr_name )  def __set__ ( self , instance , value ) :          setattr ( instance , self . attr_name , value )  def __delete__ ( self , instance ) :          delattr ( instance , self . attr_name )   def settle ( ** kwargs ) :      def inner ( target ) :          for attr in kwargs :              setattr ( target , attr , kwargs [ attr ] )  return target  return inner  def namer ( name , ** kwargs ) :      return settle ( __name__ = name , ** kwargs )  def aliases ( * names , ** kwargs ) :      def inner ( target ) :          if kwargs :              assert isinstance ( target , type ) , <str>  if names :              _locals = sys . _getframe ( 1 ) . f_locals for name in names :                  _locals [ str ( name ) ] = target   if kwargs :              for alias in kwargs :                  field = kwargs [ alias ] setattr ( target , alias , AttributeAlias ( field ) )   return target  return inner  @ decorator def assignment_operator ( func , maybe_inline = False ) :      import inspect import ast if not isinstance ( func , function ) :          raise TypeError ( <str> )  @ wraps ( func ) def inner ( * args ) :          frm = sys . _getframe ( 1 ) filename , line , funcname , src_lines , idx = inspect . getframeinfo ( frm ) try :              sourceline = src_lines [ idx ] . strip ( ) parsed_line = ast . parse ( sourceline , filename ) . body [ 0 ] assert maybe_inline or isinstance ( parsed_line , ast . Assign ) if isinstance ( parsed_line , ast . Assign ) :                  assert len ( parsed_line . targets ) == 1 assert isinstance ( parsed_line . targets [ 0 ] , ast . Name ) name = parsed_line . targets [ 0 ] . id  elif maybe_inline :                  assert isinstance ( parsed_line , ast . Expr ) name = None  else :                  assert False  return func ( name , * args )  except ( AssertionError , SyntaxError ) :              if maybe_inline :                  return func ( None , * args )  else :                  return func ( * args )   finally :              del filename , line , funcname , src_lines , idx   return inner  @ decorator def instantiate ( target , * args , ** kwargs ) :      target ( * args , ** kwargs ) return target  @ decorator def constant_bagger ( func , * args , ** kwds ) :      from xotl . tools . objects import mass_setattr wraps = ( ( a , getattr ( func , a , None ) ) for a in ( <str> , <str> ) ) attrs = { a : v for ( a , v ) in wraps if v } attrs . update ( __new__ = mass_setattr , ** func ( * args , ** kwds ) ) return type ( func . __name__ , ( object , ) , attrs )  @ decorator def singleton ( target , * args , ** kwargs ) :      res = target ( * args , ** kwargs ) if isinstance ( target , type ) :          try :              def __init__ ( * args , ** kwds ) :                  msg = <str> raise TypeError ( msg . format ( target . __name__ ) )  target . __init__ = __init__  except Exception :              pass   return res  class memoized_instancemethod :      def __init__ ( self , fget , doc = None ) :          from warnings import warn msg = <str> <str> warn ( msg , stacklevel = 2 ) self . fget = fget self . __doc__ = doc or fget . __doc__ self . __name__ = fget . __name__  def __get__ ( self , obj , cls ) :          if obj is None :              return self  def oneshot ( * args , ** kw ) :              result = self . fget ( obj , * args , ** kw ) memo = lambda * a , ** kw : result memo . __name__ = self . __name__ memo . __doc__ = self . __doc__ obj . __dict__ [ self . __name__ ] = memo return result  oneshot . __name__ = self . __name__ oneshot . __doc__ = self . __doc__ return oneshot   def reset_memoized ( instance , name ) :      from warnings import warn msg = ( <str> <str> ) warn ( msg , stacklevel = 2 ) instance . __dict__ . pop ( name , None )  if __name__ == <str> :      import doctest doctest . testmod ( verbose = True )   