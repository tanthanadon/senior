from xotl . tools . decorator import singleton def _check ( info ) :      from collections import Iterable from distutils . version import LooseVersion , StrictVersion MAX_COUNT = 3 if isinstance ( info , ( int , float ) ) :          aux = str ( info )  elif isinstance ( info , Iterable ) and not isinstance ( info , str ) :          aux = <str> . join ( map ( str , info ) )  else :          aux = info  if isinstance ( aux , str ) :          try :              essay = StrictVersion ( aux )  except ( TypeError , ValueError ) :              essay = LooseVersion ( aux )  res = essay . version [ : MAX_COUNT ] if any ( res ) :              return tuple ( res )  else :              raise ValueError ( <str> . format ( info ) )   else :          msg = <str> raise TypeError ( msg . format ( type ( info ) . __name__ , info ) )   class ThreeNumbersVersion ( tuple ) :      def __new__ ( cls , info ) :          MAX_COUNT = 3 head = _check ( info ) tail = ( 0 , ) * ( MAX_COUNT - len ( head ) ) return super ( ) . __new__ ( cls , head + tail )  @ property def major ( self ) :          return self [ 0 ]  @ property def minor ( self ) :          return self [ 1 ]  @ property def micro ( self ) :          return self [ 2 ]  def to_float ( self ) :          return float ( <str> . format ( * self [ : 2 ] ) )  __float__ = to_float __trunc__ = major def __eq__ ( self , other ) :          try :              aux = _check ( other ) this = self [ : len ( aux ) ] return this == aux  except ( TypeError , ValueError ) :              return False   def __lt__ ( self , other ) :          try :              return tuple ( self ) < _check ( other )  except ( TypeError , ValueError ) :              return NotImplemented   def __gt__ ( self , other ) :          try :              return tuple ( self ) > _check ( other )  except ( TypeError , ValueError ) :              return NotImplemented   def __ne__ ( self , other ) :          return not ( self == other )  def __le__ ( self , other ) :          return not ( self > other )  def __ge__ ( self , other ) :          return not ( self < other )   @ singleton class python_version ( ThreeNumbersVersion ) :      def __new__ ( cls ) :          import sys self = super ( ) . __new__ ( cls , sys . version_info ) self . pypy = sys . version . find ( <str> ) >= 0 return self  @ property def releaselevel ( self ) :          return self [ 3 ]  @ property def serial ( self ) :          return self [ 4 ]   def _get_mod_version ( mod ) :      valid_names = ( <str> , <str> , <str> , <str> , <str> , <str> , ) i = 0 res = None while res is None and i < len ( valid_names ) :          name = valid_names [ i ] version = getattr ( mod , name , None ) if version is not None :              try :                  res = _check ( version )  except ( TypeError , ValueError ) :                  pass   i += 1  if not res :          import os path = os . path . dirname ( os . __file__ ) if mod . __file__ . startswith ( path ) :              res = python_version   return res  class PackageVersion ( ThreeNumbersVersion ) :      def __new__ ( cls , package_name ) :          info = cls . _find_version ( package_name ) if info :              return super ( ) . __new__ ( cls , info )  else :              msg = <str> raise ValueError ( msg . format ( cls . __name__ ) )   @ staticmethod def _find_version ( package_name ) :          from pkg_resources import get_distribution , ResolutionError if package_name in ( <str> , <str> ) :              return python_version  else :              res = None while not res and package_name :                  try :                      dist = get_distribution ( package_name ) try :                          res = dist . parsed_version . base_version  except AttributeError :                          res = dist . version   except ResolutionError :                      from importlib import import_module try :                          mod = import_module ( <str> . join ( ( package_name , <str> ) ) ) res = _get_mod_version ( mod )  except ImportError :                          try :                              mod = import_module ( package_name ) res = _get_mod_version ( mod )  except ImportError :                              mod = __import__ ( package_name ) res = _get_mod_version ( mod )    if not res :                      aux = package_name . rsplit ( <str> , 1 ) package_name = aux [ 0 ] if len ( aux ) > 1 else <str>   return res     