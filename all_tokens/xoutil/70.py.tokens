from threading import * import threading as _stdlib from threading import Event , Thread , RLock , Timer def async_call ( func , args = None , kwargs = None , callback = None , onerror = None ) :      event = Event ( ) event . clear ( ) if not args :          args = ( )  if not kwargs :          kwargs = { }  def async_ ( ) :          try :              result = func ( * args , ** kwargs ) if callback :                  callback ( result )   except Exception as error :              if onerror :                  onerror ( error )   finally :              event . set ( )   thread = Thread ( target = async_ ) thread . setDaemon ( True ) thread . start ( ) return event  class _SyncronizedCaller :      def __init__ ( self , pooling = 0.005 ) :          self . lock = RLock ( ) self . _not_bailed = True self . pooling = pooling  def __call__ ( self , funcs , callback , timeout = None ) :          def _syncronized_callback ( result ) :              with self . lock :                  if self . _not_bailed :                      callback ( result )    events , threads = [ ] , [ ] for which in funcs :              event , thread = async_call ( which , callback = _syncronized_callback ) events . append ( event ) threads . append ( thread )  if timeout :              def set_all_events ( ) :                  with self . lock :                      self . _not_bailed = False  for e in events :                      e . set ( )   timer = Timer ( timeout , set_all_events ) timer . start ( )  while events :              terminated = [ ] for event in events :                  flag = event . wait ( self . pooling ) if flag :                      terminated . append ( event )   for e in terminated :                  events . remove ( e )   if timeout :              timer . cancel ( )    def sync_call ( funcs , callback , timeout = None ) :      sync_caller = _SyncronizedCaller ( ) sync_caller ( funcs , callback , timeout )  from threading import __all__ __all__ = list ( __all__ ) + [ <str> , <str> ]  