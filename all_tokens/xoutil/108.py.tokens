import sys import re import inspect from functools import wraps , partial from types import FunctionType as function from inspect import getfullargspec as _getfullargspec __all__ = ( <str> , <str> , <str> ) DEF = re . compile ( <str> ) class FunctionMaker :      def __init__ ( self , func = None , name = None , signature = None , defaults = None , doc = None , module = None , funcdict = None , ) :          self . shortsignature = signature if func :              self . name = func . __name__ if self . name == <str> :                  self . name = <str>  self . doc = func . __doc__ self . module = func . __module__ if inspect . isfunction ( func ) :                  argspec = _getfullargspec ( func ) for a in ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , ) :                      setattr ( self , a , getattr ( argspec , a , None ) )  for i , arg in enumerate ( self . args ) :                      setattr ( self , <str> % i , arg )  self . signature = inspect . formatargspec ( formatvalue = lambda val : <str> , * argspec ) [ 1 : - 1 ] allargs = list ( self . args ) if self . varargs :                      allargs . append ( <str> + self . varargs )  if self . varkw :                      allargs . append ( <str> + self . varkw )  try :                      self . shortsignature = <str> . join ( allargs )  except TypeError :                      self . shortsignature = self . signature  self . dict = func . __dict__ . copy ( )   if name :              self . name = name  if signature is not None :              self . signature = signature  if defaults :              self . defaults = defaults  if doc :              self . doc = doc  if module :              self . module = module  if funcdict :              self . dict = funcdict  assert hasattr ( self , <str> ) if not hasattr ( self , <str> ) :              raise TypeError ( <str> % func )   def update ( self , func , ** kw ) :          <str> func . __name__ = self . name func . __doc__ = getattr ( self , <str> , None ) func . __dict__ = getattr ( self , <str> , { } ) func . func_defaults = getattr ( self , <str> , ( ) ) func . __kwdefaults__ = getattr ( self , <str> , None ) callermodule = sys . _getframe ( 3 ) . f_globals . get ( <str> , <str> ) func . __module__ = getattr ( self , <str> , callermodule ) func . __dict__ . update ( kw )  def make ( self , src_templ , evaldict = None , addsource = False , ** attrs ) :          <str> src = src_templ % vars ( self ) evaldict = evaldict or { } mo = DEF . match ( src ) if mo is None :              raise SyntaxError ( <str> % src )  name = mo . group ( 1 ) names = set ( [ name ] + [ arg . strip ( <str> ) for arg in self . shortsignature . split ( <str> ) ] ) for n in names :              if n in ( <str> , <str> ) :                  raise NameError ( <str> % ( n , src ) )   if not src . endswith ( <str> ) :              src += <str>  try :              code = compile ( src , <str> , <str> ) eval ( code , evaldict , evaldict )  except Exception :              raise  func = evaldict [ name ] if addsource :              attrs [ <str> ] = src  self . update ( func , ** attrs ) return func  @ classmethod def create ( cls , obj , body , evaldict , defaults = None , doc = None , module = None , addsource = True , ** attrs ) :          if isinstance ( obj , str ) :              obj = str ( obj ) name , rest = obj . strip ( ) . split ( str ( <str> ) , 1 ) signature = rest [ : - 1 ] func = None  else :              name = None signature = None func = obj  self = cls ( func , name , signature , defaults , doc , module ) ibody = <str> . join ( <str> + line for line in body . splitlines ( ) ) return self . make ( <str> + ibody , evaldict , addsource , ** attrs )   def flat_decorator ( caller , func = None ) :      if func is not None :          evaldict = func . __globals__ . copy ( ) evaldict [ <str> ] = caller evaldict [ <str> ] = func return FunctionMaker . create ( func , <str> , evaldict , undecorated = func , __wrapped__ = func , )  else :          if isinstance ( caller , partial ) :              return partial ( decorator , caller )  try :              first = inspect . getargspec ( caller ) [ 0 ] [ 0 ] deco_sign = <str> % ( caller . __name__ , first ) deco_body = <str> % first  except IndexError :              deco_sign = <str> % caller . __name__ deco_body = <str>  evaldict = caller . __globals__ . copy ( ) evaldict [ <str> ] = caller evaldict [ <str> ] = evaldict [ <str> ] = flat_decorator return FunctionMaker . create ( deco_sign , deco_body , evaldict , undecorated = caller , __wrapped__ = caller , doc = caller . __doc__ , module = caller . __module__ , )   def decorator ( caller ) :      @ wraps ( caller ) def outer_decorator ( * args , ** kwargs ) :          try :              from zope . interface import Interface  except ImportError :              Interface = None  if ( len ( args ) == 1 and not kwargs and ( isinstance ( args [ 0 ] , ( function , type ) ) or issubclass ( type ( args [ 0 ] ) , type ( Interface ) ) ) ) :              func = args [ 0 ] return caller ( func )  elif len ( args ) > 0 or len ( kwargs ) > 0 :              def _decorator ( func ) :                  return partial ( caller , ** kwargs ) ( * ( ( func , ) + args ) )  return _decorator  else :              return caller   return outer_decorator   