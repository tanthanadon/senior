from xotl . tools . values import coercer , nil @ coercer def not_false_coercer ( arg ) :      from xotl . tools . symbols import boolean false = arg is None or ( not arg and isinstance ( arg , boolean ) ) return arg if not false else nil  def not_false ( default ) :      @ coercer def inner_coercer ( arg ) :          coercer = not_false_coercer return arg if coercer ( arg ) is arg else coercer ( default )  return inner_coercer  def isnot ( value ) :      @ coercer def inner_coercer ( arg ) :          return arg if arg is not value else nil  return inner_coercer  @ coercer def name_coerce ( arg ) :      from types import GeneratorType if isinstance ( arg , GeneratorType ) :          return nil  else :          if isinstance ( arg , ( staticmethod , classmethod ) ) :              fn = getattr ( arg , <str> , None ) if fn :                  arg = fn   res = getattr ( arg , <str> , None ) return res if isinstance ( res , str ) else nil   @ coercer def iterable_coerce ( arg ) :      from collections import Iterable return arg if isinstance ( arg , Iterable ) else nil  def collection ( arg = nil , avoid = ( ) , force = False , base = None , name = None ) :      if not base :          from collections import Iterable as base  if not isinstance ( avoid , tuple ) :          avoid = ( avoid , )  @ coercer def collection_coerce ( arg ) :          invalid = ( str , ) + avoid ok = not isinstance ( arg , invalid ) and isinstance ( arg , base ) return arg if ok else ( [ arg ] if force else nil )  if arg is nil :          doc = ( <str> <str> ) . format ( <str> . format ( avoid ) if avoid else <str> ) if force :              doc += <str>  collection_coerce . __doc__ = doc del doc if name :              collection_coerce . __name__ = name  return collection_coerce  else :          assert not name return collection_coerce ( arg )   from collections import Mapping , Sequence logic_iterable_coerce = collection ( name = <str> ) force_iterable_coerce = collection ( force = True , name = <str> ) logic_collection_coerce = collection ( avoid = Mapping , name = <str> ) force_collection_coerce = collection ( avoid = Mapping , force = True , name = <str> ) logic_sequence_coerce = collection ( avoid = Mapping , base = Sequence , name = <str> ) force_sequence_coerce = collection ( avoid = Mapping , force = True , base = Sequence , name = <str> ) del Mapping , Sequence @ coercer def decode_coerce ( arg ) :      import locale encoding = locale . getpreferredencoding ( ) or <str> decode = getattr ( arg , <str> , None ) if callable ( decode ) :          try :              res = decode ( encoding , <str> ) if not isinstance ( res , str ) :                  res = None   except Exception :              res = None   else :          res = None  if res is None :          try :              import codecs res = codecs . decode ( arg , encoding , <str> )  except Exception :              res = nil   return res  @ coercer def encode_coerce ( arg ) :      import locale encoding = locale . getpreferredencoding ( ) or <str> encode = getattr ( arg , <str> , None ) if callable ( encode ) :          try :              res = encode ( encoding , <str> ) if not isinstance ( res , bytes ) :                  res = None   except Exception :              res = None   else :          res = None  if res is None :          try :              import codecs res = codecs . encode ( arg , encoding , <str> )  except Exception :              res = nil   return res  @ coercer def unicode_coerce ( arg ) :      from array import array aux = name_coerce ( arg ) if aux is not nil :          arg = aux  if isinstance ( arg , str ) :          return arg  elif isinstance ( arg , bytearray ) :          arg = bytes ( arg )  elif isinstance ( arg , memoryview ) :          arg = arg . tobytes ( )  elif isinstance ( arg , array ) :          try :              return arg . tounicode ( )  except Exception :              try :                  arg = bytes ( bytearray ( arg . tolist ( ) ) )  except Exception :                  arg = str ( arg )  return arg   res = decode_coerce ( arg ) return str ( arg ) if res is nil else res  @ coercer def bytes_coerce ( arg ) :      from array import array aux = name_coerce ( arg ) if aux is not nil :          arg = aux  if isinstance ( arg , bytes ) :          return arg  elif isinstance ( arg , bytearray ) :          return bytes ( arg )  elif isinstance ( arg , memoryview ) :          return arg . tobytes ( )  elif isinstance ( arg , array ) :          try :              arg = arg . tounicode ( )  except Exception :              try :                  return bytes ( bytearray ( arg . tolist ( ) ) )  except Exception :                  arg = str ( arg )    res = encode_coerce ( arg ) return encode_coerce ( str ( arg ) ) if res is nil else res  @ coercer def str_coerce ( arg ) :      return unicode_coerce ( arg )  @ coercer def ascii_coerce ( arg ) :      import unicodedata if not isinstance ( arg , str ) :          arg = unicode_coerce ( arg )  res = unicodedata . normalize ( <str> , arg ) . encode ( <str> , <str> ) return str_coerce ( res )  @ coercer def ascii_set_coerce ( arg ) :      return <str> . join ( set ( ascii_coerce ( arg ) ) )  @ coercer def lower_ascii_coerce ( arg ) :      return ascii_coerce ( arg ) . lower ( )  @ coercer def lower_ascii_set_coerce ( arg ) :      return <str> . join ( set ( lower_ascii_coerce ( arg ) ) )  @ coercer def chars_coerce ( arg ) :      if isinstance ( arg , int ) and 0 <= arg <= 0x10FFFF :          return chr ( arg )  else :          return unicode_coerce ( arg )   @ coercer def strict_string_coerce ( arg ) :      return str_coerce ( arg ) if isinstance ( arg , str ) else nil  class text ( str ) :      def __new__ ( cls , obj = <str> , * args , ** kwargs ) :          if not ( args or kwargs ) :              obj = unicode_coerce ( obj )  return super ( ) . __new__ ( cls , obj , * args , ** kwargs )  def join ( self , * args ) :          return self . _join ( unicode_coerce , args )  def chr_join ( self , * args ) :          return self . _join ( chars_coerce , args )  def _join ( self , coercer , args ) :          from collections import Iterable if len ( args ) == 1 and isinstance ( args [ 0 ] , Iterable ) :              args = args [ 0 ]  return super ( ) . join ( coercer ( obj ) for obj in args )    