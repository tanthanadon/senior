import heapq class Solution :      def medianII ( self , nums ) :          if not nums :              return  cur_median = nums [ 0 ] left_heap = [ ] right_heap = [ ] result = [ nums [ 0 ] ] for n in nums [ 1 : ] :              if n > cur_median :                  heapq . heappush ( right_heap , n )  else :                  heapq . heappush ( left_heap , n * - 1 )  if len ( right_heap ) > len ( left_heap ) + 1 :                  old_median = cur_median cur_median = heapq . heappop ( right_heap ) heapq . heappush ( left_heap , old_median * - 1 )  if len ( left_heap ) > len ( right_heap ) :                  old_median = cur_median cur_median = heapq . heappop ( left_heap ) * - 1 heapq . heappush ( right_heap , old_median )  result . append ( cur_median )  return result   import heapq class MedianFinder ( object ) :      def __init__ ( self ) :          self . left_heap = [ ] self . right_heap = [ ]  def addNum ( self , num ) :          heapq . heappush ( self . left_heap , num * - 1 ) heapq . heappush ( self . right_heap , heapq . heappop ( self . left_heap ) * - 1 ) if len ( self . left_heap ) < len ( self . right_heap ) :              heapq . heappush ( self . left_heap , heapq . heappop ( self . right_heap ) * - 1 )   def findMedian ( self ) :          if not self . left_heap and not self . right_heap :              return None  if len ( self . left_heap ) == len ( self . right_heap ) :              return ( self . right_heap [ 0 ] + self . left_heap [ 0 ] * - 1 ) / 2.0  return self . left_heap [ 0 ] * - 1.0    