class IntervalWrapper ( object ) :      def __init__ ( self , i ) :          self . start = i . start self . end = i . end  def __cmp__ ( self , other ) :          return self . end - other . end   class Solution ( object ) :      def minMeetingRooms ( self , intervals ) :          if not intervals :              return 0  intervals . sort ( cmp = lambda i1 , i2 : i1 . start - i2 . start ) heap = [ IntervalWrapper ( intervals [ 0 ] ) ] for i in xrange ( 1 , len ( intervals ) ) :              min_end = heapq . heappop ( heap ) if intervals [ i ] . start < min_end . end :                  heapq . heappush ( heap , IntervalWrapper ( intervals [ i ] ) )  else :                  min_end . end = intervals [ i ] . end  heapq . heappush ( heap , min_end )  return len ( heap )   class Solution ( object ) :      def minMeetingRooms ( self , intervals ) :          if not intervals :              return 0  starts , ends = [ ] , [ ] for i in intervals :              starts . append ( i . start ) ends . append ( i . end )  starts . sort ( ) ends . sort ( ) rooms = end_pos = 0 for i in xrange ( len ( starts ) ) :              if starts [ i ] < ends [ end_pos ] :                  rooms += 1  else :                  end_pos += 1   return rooms    