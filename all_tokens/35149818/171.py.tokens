class DfsSolution ( object ) :      def numIslands ( self , grid ) :          row = len ( grid ) if row == 0 : return 0 column = len ( grid [ 0 ] ) result = 0 def dfs ( r , c ) :              if r >= row or r < 0 or c >= column or c < 0 or grid [ r ] [ c ] == <str> :                  return  grid [ r ] [ c ] = <str> dfs ( r + 1 , c ) dfs ( r - 1 , c ) dfs ( r , c + 1 ) dfs ( r , c - 1 )  for r in range ( row ) :              for c in range ( column ) :                  if grid [ r ] [ c ] == <str> :                      dfs ( r , c ) result += 1    return result   from collections import deque class Solution ( object ) :      def numIslands ( self , grid ) :          row = len ( grid ) if row == 0 : return 0 column = len ( grid [ 0 ] ) result = 0 def bfs ( r , c ) :              q = deque ( ) q . appendleft ( ( r , c ) ) grid [ r ] [ c ] = <str> while len ( q ) > 0 :                  cur = q . pop ( ) cur_r = cur [ 0 ] cur_c = cur [ 1 ] if cur_r + 1 < row and grid [ cur_r + 1 ] [ cur_c ] == <str> :                      q . appendleft ( ( cur_r + 1 , cur_c ) ) grid [ cur_r + 1 ] [ cur_c ] = <str>  if cur_r - 1 >= 0 and grid [ cur_r - 1 ] [ cur_c ] == <str> :                      q . appendleft ( ( cur_r - 1 , cur_c ) ) grid [ cur_r - 1 ] [ cur_c ] = <str>  if cur_c + 1 < column and grid [ cur_r ] [ cur_c + 1 ] == <str> :                      q . appendleft ( ( cur_r , cur_c + 1 ) ) grid [ cur_r ] [ cur_c + 1 ] = <str>  if cur_c - 1 >= 0 and grid [ cur_r ] [ cur_c - 1 ] == <str> :                      q . appendleft ( ( cur_r , cur_c - 1 ) ) grid [ cur_r ] [ cur_c - 1 ] = <str>    for r in range ( row ) :              for c in range ( column ) :                  if grid [ r ] [ c ] == <str> :                      bfs ( r , c ) result += 1    return result    