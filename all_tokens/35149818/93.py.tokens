class Solution ( object ) :      def wordBreak ( self , s , wordDict ) :          words_set = set ( wordDict ) dp = [ False ] * ( len ( s ) + 1 ) dp [ - 1 ] = True for outer in xrange ( len ( s ) - 1 , - 1 , - 1 ) :              for inner in xrange ( outer , len ( s ) ) :                  cur_word = s [ outer : inner + 1 ] if cur_word in words_set and dp [ inner + 1 ] :                      dp [ outer ] = True break    if not dp [ 0 ] :              return [ ]  def dfs ( target , start , cur_path , ws , dp , result ) :              if start == len ( target ) :                  result . append ( cur_path )  for i in xrange ( start , len ( target ) ) :                  cur_word = target [ start : i + 1 ] if cur_word in ws and dp [ i + 1 ] :                      cur_word = <str> + cur_word if cur_path else cur_word dfs ( target , i + 1 , cur_path + cur_word , ws , dp , result )    result = [ ] dfs ( s , 0 , <str> , words_set , dp , result ) return result   class Solution ( object ) :      def wordBreak ( self , s , wordDict ) :          def dfs ( target , word_List , memo ) :              if not target :                  return [ ]  if target in memo :                  return memo [ target ]  result = [ ] for word in word_List :                  if not target . startswith ( word ) :                      continue  elif len ( target ) == len ( word ) :                      result . append ( word )  else :                      subresult = dfs ( target [ len ( word ) : ] , word_List , memo ) result += map ( lambda x : word + <str> + x , subresult )   memo [ target ] = result return result  return dfs ( s , wordDict , { } )    