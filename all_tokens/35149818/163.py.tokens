class Solution ( object ) :      def ladderLength ( self , beginWord , endWord , wordList ) :          d = set ( ) all_chars = set ( ) for w in wordList :              d . add ( w ) for c in w :                  all_chars . add ( c )   if endWord not in d :              return 0  visited = set ( [ beginWord ] ) level = 0 q = collections . deque ( [ beginWord ] ) while len ( q ) > 0 :              level += 1 print q cur_len = len ( q ) for i in xrange ( cur_len ) :                  cur_word = q . pop ( ) for c in xrange ( len ( cur_word ) ) :                      for next_c in all_chars :                          if cur_word [ c ] == next_c :                              continue  next_word = cur_word [ : c ] + next_c + cur_word [ c + 1 : ] if next_word == endWord :                              return level + 1  if next_word in d and next_word not in visited :                              q . appendleft ( next_word ) visited . add ( next_word )      return 0   class Solution ( object ) :      def ladderLength ( self , beginWord , endWord , wordList ) :          if not wordList :              return 0  d = set ( wordList ) if endWord not in d :              return 0  begin = set ( [ beginWord ] ) end = set ( [ endWord ] ) visited = set ( [ beginWord , endWord ] ) level = 1 while len ( begin ) > 0 and len ( end ) > 0 :              if len ( begin ) > len ( end ) :                  begin , end = end , begin  tmp = set ( ) for w in begin :                  for c in xrange ( len ( w ) ) :                      for next_c in xrange ( ord ( <str> ) , ord ( <str> ) + 1 ) :                          next_char = chr ( next_c ) if next_char == w [ c ] :                              continue  next_word = w [ : c ] + next_char + w [ c + 1 : ] if next_word in end :                              return level + 1  if next_word in d and next_word not in visited :                              tmp . add ( next_word ) visited . add ( next_word )     begin = tmp level += 1  return 0    