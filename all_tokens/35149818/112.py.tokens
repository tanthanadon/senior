class UnionFind ( object ) :      def __init__ ( self , d ) :          self . father = d self . count = len ( d )  def __find ( self , c ) :          if self . father [ c ] == c :              return c  f = self . __find ( self . father [ c ] ) self . father [ c ] = f return f  def union ( self , c1 , c2 ) :          f1 = self . __find ( c1 ) f2 = self . __find ( c2 ) if f1 != f2 :              self . father [ f1 ] = f2 self . count -= 1 return True  return False  def query ( self ) :          return self . count   class Solution :      def lowestCost ( self , connections ) :          if not connections :              return [ ]  def connection_cmp ( c1 , c2 ) :              if c1 . cost != c2 . cost :                  return c1 . cost - c2 . cost  if c1 . city1 != c2 . city1 :                  return 1 if c1 . city1 > c2 . city1 else - 1  if c1 . city2 != c2 . city2 :                  return 1 if c1 . city2 > c2 . city2 else - 1  return 0  connections . sort ( cmp = connection_cmp ) d = { } for n in connections :              if n . city1 not in d :                  d [ n . city1 ] = n . city1  if n . city2 not in d :                  d [ n . city2 ] = n . city2   uf = UnionFind ( d ) result = [ ] for n in connections :              if uf . union ( n . city1 , n . city2 ) :                  result . append ( n )   return result if uf . query ( ) == 1 else [ ]    