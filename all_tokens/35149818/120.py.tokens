class CriticalPoint ( object ) :      def __init__ ( self , id , a = True , x = 0 , h = 0 , p = - 1 ) :          self . id = id self . a = a self . x = x self . h = h  def __cmp__ ( self , other ) :          return other . h - self . h  def __str__ ( self ) :          return <str> % ( self . id , self . h )   class HeapQueueWithDelete ( object ) :      def __init__ ( self ) :          self . heap = [ CriticalPoint ( id = - 1 ) ] self . delete_map = { }  def push ( self , point ) :          heapq . heappush ( self . heap , point ) self . delete_map [ str ( point ) ] = point  def peak ( self ) :          while self . heap and not self . heap [ 0 ] . a :              heapq . heappop ( self . heap )  return self . heap [ 0 ]  def delete ( self , point ) :          pid = point . id prev_map_key = <str> % ( pid , - point . h ) prev_point = self . delete_map . pop ( prev_map_key ) prev_point . a = False   class Solution ( object ) :      def getSkyline ( self , buildings ) :          if not buildings :              return [ ]  critical_points = [ ] counter = itertools . count ( ) for b in buildings :              id = next ( counter ) critical_points . append ( CriticalPoint ( id , True , b [ 0 ] , b [ 2 ] ) ) critical_points . append ( CriticalPoint ( id , True , b [ 1 ] , - b [ 2 ] ) )  def custom_cmp ( a , b ) :              return a . x - b . x  critical_points . sort ( cmp = custom_cmp ) result = [ ] heap = HeapQueueWithDelete ( ) prev = 0 i = 0 while i < len ( critical_points ) :              while i < len ( critical_points ) :                  cur_cp = critical_points [ i ] if cur_cp . h > 0 :                      heap . push ( cur_cp )  else :                      heap . delete ( cur_cp )  if i + 1 < len ( critical_points ) and cur_cp . x == critical_points [ i + 1 ] . x :                      i += 1  else :                      break   cur_max = heap . peak ( ) if cur_max . h != prev :                  result . append ( [ cur_cp . x , cur_max . h ] ) prev = cur_max . h  i += 1  return result    